<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/memnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;oops/objArrayKlass.hpp&quot;
  33 #include &quot;opto/addnode.hpp&quot;
  34 #include &quot;opto/arraycopynode.hpp&quot;
  35 #include &quot;opto/cfgnode.hpp&quot;
  36 #include &quot;opto/compile.hpp&quot;
  37 #include &quot;opto/connode.hpp&quot;
  38 #include &quot;opto/convertnode.hpp&quot;
  39 #include &quot;opto/loopnode.hpp&quot;
  40 #include &quot;opto/machnode.hpp&quot;
  41 #include &quot;opto/matcher.hpp&quot;
  42 #include &quot;opto/memnode.hpp&quot;
  43 #include &quot;opto/mulnode.hpp&quot;
  44 #include &quot;opto/narrowptrnode.hpp&quot;
  45 #include &quot;opto/phaseX.hpp&quot;
  46 #include &quot;opto/regmask.hpp&quot;
  47 #include &quot;opto/rootnode.hpp&quot;
  48 #include &quot;utilities/align.hpp&quot;
  49 #include &quot;utilities/copy.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 #include &quot;utilities/vmError.hpp&quot;
  52 
  53 // Portions of code courtesy of Clifford Click
  54 
  55 // Optimization - Graph Style
  56 
  57 static Node *step_through_mergemem(PhaseGVN *phase, MergeMemNode *mmem,  const TypePtr *tp, const TypePtr *adr_check, outputStream *st);
  58 
  59 //=============================================================================
  60 uint MemNode::size_of() const { return sizeof(*this); }
  61 
  62 const TypePtr *MemNode::adr_type() const {
  63   Node* adr = in(Address);
  64   if (adr == NULL)  return NULL; // node is dead
  65   const TypePtr* cross_check = NULL;
  66   DEBUG_ONLY(cross_check = _adr_type);
  67   return calculate_adr_type(adr-&gt;bottom_type(), cross_check);
  68 }
  69 
  70 bool MemNode::check_if_adr_maybe_raw(Node* adr) {
  71   if (adr != NULL) {
  72     if (adr-&gt;bottom_type()-&gt;base() == Type::RawPtr || adr-&gt;bottom_type()-&gt;base() == Type::AnyPtr) {
  73       return true;
  74     }
  75   }
  76   return false;
  77 }
  78 
  79 #ifndef PRODUCT
  80 void MemNode::dump_spec(outputStream *st) const {
  81   if (in(Address) == NULL)  return; // node is dead
  82 #ifndef ASSERT
  83   // fake the missing field
  84   const TypePtr* _adr_type = NULL;
  85   if (in(Address) != NULL)
  86     _adr_type = in(Address)-&gt;bottom_type()-&gt;isa_ptr();
  87 #endif
  88   dump_adr_type(this, _adr_type, st);
  89 
  90   Compile* C = Compile::current();
  91   if (C-&gt;alias_type(_adr_type)-&gt;is_volatile()) {
  92     st-&gt;print(&quot; Volatile!&quot;);
  93   }
  94   if (_unaligned_access) {
  95     st-&gt;print(&quot; unaligned&quot;);
  96   }
  97   if (_mismatched_access) {
  98     st-&gt;print(&quot; mismatched&quot;);
  99   }
 100   if (_unsafe_access) {
 101     st-&gt;print(&quot; unsafe&quot;);
 102   }
 103 }
 104 
 105 void MemNode::dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st) {
 106   st-&gt;print(&quot; @&quot;);
 107   if (adr_type == NULL) {
 108     st-&gt;print(&quot;NULL&quot;);
 109   } else {
 110     adr_type-&gt;dump_on(st);
 111     Compile* C = Compile::current();
 112     Compile::AliasType* atp = NULL;
 113     if (C-&gt;have_alias_type(adr_type))  atp = C-&gt;alias_type(adr_type);
 114     if (atp == NULL)
 115       st-&gt;print(&quot;, idx=?\?;&quot;);
 116     else if (atp-&gt;index() == Compile::AliasIdxBot)
 117       st-&gt;print(&quot;, idx=Bot;&quot;);
 118     else if (atp-&gt;index() == Compile::AliasIdxTop)
 119       st-&gt;print(&quot;, idx=Top;&quot;);
 120     else if (atp-&gt;index() == Compile::AliasIdxRaw)
 121       st-&gt;print(&quot;, idx=Raw;&quot;);
 122     else {
 123       ciField* field = atp-&gt;field();
 124       if (field) {
 125         st-&gt;print(&quot;, name=&quot;);
 126         field-&gt;print_name_on(st);
 127       }
 128       st-&gt;print(&quot;, idx=%d;&quot;, atp-&gt;index());
 129     }
 130   }
 131 }
 132 
 133 extern void print_alias_types();
 134 
 135 #endif
 136 
 137 Node *MemNode::optimize_simple_memory_chain(Node *mchain, const TypeOopPtr *t_oop, Node *load, PhaseGVN *phase) {
 138   assert((t_oop != NULL), &quot;sanity&quot;);
 139   bool is_instance = t_oop-&gt;is_known_instance_field();
 140   bool is_boxed_value_load = t_oop-&gt;is_ptr_to_boxed_value() &amp;&amp;
 141                              (load != NULL) &amp;&amp; load-&gt;is_Load() &amp;&amp;
 142                              (phase-&gt;is_IterGVN() != NULL);
 143   if (!(is_instance || is_boxed_value_load))
 144     return mchain;  // don&#39;t try to optimize non-instance types
 145   uint instance_id = t_oop-&gt;instance_id();
 146   Node *start_mem = phase-&gt;C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 147   Node *prev = NULL;
 148   Node *result = mchain;
 149   while (prev != result) {
 150     prev = result;
 151     if (result == start_mem)
 152       break;  // hit one of our sentinels
 153     // skip over a call which does not affect this memory slice
 154     if (result-&gt;is_Proj() &amp;&amp; result-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
 155       Node *proj_in = result-&gt;in(0);
 156       if (proj_in-&gt;is_Allocate() &amp;&amp; proj_in-&gt;_idx == instance_id) {
 157         break;  // hit one of our sentinels
 158       } else if (proj_in-&gt;is_Call()) {
 159         // ArrayCopyNodes processed here as well
 160         CallNode *call = proj_in-&gt;as_Call();
 161         if (!call-&gt;may_modify(t_oop, phase)) { // returns false for instances
 162           result = call-&gt;in(TypeFunc::Memory);
 163         }
 164       } else if (proj_in-&gt;is_Initialize()) {
 165         AllocateNode* alloc = proj_in-&gt;as_Initialize()-&gt;allocation();
 166         // Stop if this is the initialization for the object instance which
 167         // contains this memory slice, otherwise skip over it.
 168         if ((alloc == NULL) || (alloc-&gt;_idx == instance_id)) {
 169           break;
 170         }
 171         if (is_instance) {
 172           result = proj_in-&gt;in(TypeFunc::Memory);
 173         } else if (is_boxed_value_load) {
 174           Node* klass = alloc-&gt;in(AllocateNode::KlassNode);
 175           const TypeKlassPtr* tklass = phase-&gt;type(klass)-&gt;is_klassptr();
 176           if (tklass-&gt;klass_is_exact() &amp;&amp; !tklass-&gt;klass()-&gt;equals(t_oop-&gt;klass())) {
 177             result = proj_in-&gt;in(TypeFunc::Memory); // not related allocation
 178           }
 179         }
 180       } else if (proj_in-&gt;is_MemBar()) {
 181         ArrayCopyNode* ac = NULL;
 182         if (ArrayCopyNode::may_modify(t_oop, proj_in-&gt;as_MemBar(), phase, ac)) {
 183           break;
 184         }
 185         result = proj_in-&gt;in(TypeFunc::Memory);
 186       } else {
 187         assert(false, &quot;unexpected projection&quot;);
 188       }
 189     } else if (result-&gt;is_ClearArray()) {
 190       if (!is_instance || !ClearArrayNode::step_through(&amp;result, instance_id, phase)) {
 191         // Can not bypass initialization of the instance
 192         // we are looking for.
 193         break;
 194       }
 195       // Otherwise skip it (the call updated &#39;result&#39; value).
 196     } else if (result-&gt;is_MergeMem()) {
 197       result = step_through_mergemem(phase, result-&gt;as_MergeMem(), t_oop, NULL, tty);
 198     }
 199   }
 200   return result;
 201 }
 202 
 203 Node *MemNode::optimize_memory_chain(Node *mchain, const TypePtr *t_adr, Node *load, PhaseGVN *phase) {
 204   const TypeOopPtr* t_oop = t_adr-&gt;isa_oopptr();
 205   if (t_oop == NULL)
 206     return mchain;  // don&#39;t try to optimize non-oop types
 207   Node* result = optimize_simple_memory_chain(mchain, t_oop, load, phase);
 208   bool is_instance = t_oop-&gt;is_known_instance_field();
 209   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 210   if (is_instance &amp;&amp; igvn != NULL &amp;&amp; result-&gt;is_Phi()) {
 211     PhiNode *mphi = result-&gt;as_Phi();
 212     assert(mphi-&gt;bottom_type() == Type::MEMORY, &quot;memory phi required&quot;);
 213     const TypePtr *t = mphi-&gt;adr_type();
 214     if (t == TypePtr::BOTTOM || t == TypeRawPtr::BOTTOM ||
 215         (t-&gt;isa_oopptr() &amp;&amp; !t-&gt;is_oopptr()-&gt;is_known_instance() &amp;&amp;
 216          t-&gt;is_oopptr()-&gt;cast_to_exactness(true)
 217            -&gt;is_oopptr()-&gt;cast_to_ptr_type(t_oop-&gt;ptr())
 218             -&gt;is_oopptr()-&gt;cast_to_instance_id(t_oop-&gt;instance_id()) == t_oop)) {
 219       // clone the Phi with our address type
 220       result = mphi-&gt;split_out_instance(t_adr, igvn);
 221     } else {
 222       assert(phase-&gt;C-&gt;get_alias_index(t) == phase-&gt;C-&gt;get_alias_index(t_adr), &quot;correct memory chain&quot;);
 223     }
 224   }
 225   return result;
 226 }
 227 
 228 static Node *step_through_mergemem(PhaseGVN *phase, MergeMemNode *mmem,  const TypePtr *tp, const TypePtr *adr_check, outputStream *st) {
 229   uint alias_idx = phase-&gt;C-&gt;get_alias_index(tp);
 230   Node *mem = mmem;
 231 #ifdef ASSERT
 232   {
 233     // Check that current type is consistent with the alias index used during graph construction
 234     assert(alias_idx &gt;= Compile::AliasIdxRaw, &quot;must not be a bad alias_idx&quot;);
 235     bool consistent =  adr_check == NULL || adr_check-&gt;empty() ||
 236                        phase-&gt;C-&gt;must_alias(adr_check, alias_idx );
 237     // Sometimes dead array references collapse to a[-1], a[-2], or a[-3]
 238     if( !consistent &amp;&amp; adr_check != NULL &amp;&amp; !adr_check-&gt;empty() &amp;&amp;
 239                tp-&gt;isa_aryptr() &amp;&amp;        tp-&gt;offset() == Type::OffsetBot &amp;&amp;
 240         adr_check-&gt;isa_aryptr() &amp;&amp; adr_check-&gt;offset() != Type::OffsetBot &amp;&amp;
 241         ( adr_check-&gt;offset() == arrayOopDesc::length_offset_in_bytes() ||
 242           adr_check-&gt;offset() == oopDesc::klass_offset_in_bytes() ||
 243           adr_check-&gt;offset() == oopDesc::mark_offset_in_bytes() ) ) {
 244       // don&#39;t assert if it is dead code.
 245       consistent = true;
 246     }
 247     if( !consistent ) {
 248       st-&gt;print(&quot;alias_idx==%d, adr_check==&quot;, alias_idx);
 249       if( adr_check == NULL ) {
 250         st-&gt;print(&quot;NULL&quot;);
 251       } else {
 252         adr_check-&gt;dump();
 253       }
 254       st-&gt;cr();
 255       print_alias_types();
 256       assert(consistent, &quot;adr_check must match alias idx&quot;);
 257     }
 258   }
 259 #endif
 260   // TypeOopPtr::NOTNULL+any is an OOP with unknown offset - generally
 261   // means an array I have not precisely typed yet.  Do not do any
 262   // alias stuff with it any time soon.
 263   const TypeOopPtr *toop = tp-&gt;isa_oopptr();
 264   if( tp-&gt;base() != Type::AnyPtr &amp;&amp;
 265       !(toop &amp;&amp;
 266         toop-&gt;klass() != NULL &amp;&amp;
 267         toop-&gt;klass()-&gt;is_java_lang_Object() &amp;&amp;
 268         toop-&gt;offset() == Type::OffsetBot) ) {
 269     // compress paths and change unreachable cycles to TOP
 270     // If not, we can update the input infinitely along a MergeMem cycle
 271     // Equivalent code in PhiNode::Ideal
 272     Node* m  = phase-&gt;transform(mmem);
 273     // If transformed to a MergeMem, get the desired slice
 274     // Otherwise the returned node represents memory for every slice
 275     mem = (m-&gt;is_MergeMem())? m-&gt;as_MergeMem()-&gt;memory_at(alias_idx) : m;
 276     // Update input if it is progress over what we have now
 277   }
 278   return mem;
 279 }
 280 
 281 //--------------------------Ideal_common---------------------------------------
 282 // Look for degenerate control and memory inputs.  Bypass MergeMem inputs.
 283 // Unhook non-raw memories from complete (macro-expanded) initializations.
 284 Node *MemNode::Ideal_common(PhaseGVN *phase, bool can_reshape) {
 285   // If our control input is a dead region, kill all below the region
 286   Node *ctl = in(MemNode::Control);
 287   if (ctl &amp;&amp; remove_dead_region(phase, can_reshape))
 288     return this;
 289   ctl = in(MemNode::Control);
 290   // Don&#39;t bother trying to transform a dead node
 291   if (ctl &amp;&amp; ctl-&gt;is_top())  return NodeSentinel;
 292 
 293   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 294   // Wait if control on the worklist.
 295   if (ctl &amp;&amp; can_reshape &amp;&amp; igvn != NULL) {
 296     Node* bol = NULL;
 297     Node* cmp = NULL;
 298     if (ctl-&gt;in(0)-&gt;is_If()) {
 299       assert(ctl-&gt;is_IfTrue() || ctl-&gt;is_IfFalse(), &quot;sanity&quot;);
 300       bol = ctl-&gt;in(0)-&gt;in(1);
 301       if (bol-&gt;is_Bool())
 302         cmp = ctl-&gt;in(0)-&gt;in(1)-&gt;in(1);
 303     }
 304     if (igvn-&gt;_worklist.member(ctl) ||
 305         (bol != NULL &amp;&amp; igvn-&gt;_worklist.member(bol)) ||
 306         (cmp != NULL &amp;&amp; igvn-&gt;_worklist.member(cmp)) ) {
 307       // This control path may be dead.
 308       // Delay this memory node transformation until the control is processed.
 309       phase-&gt;is_IterGVN()-&gt;_worklist.push(this);
 310       return NodeSentinel; // caller will return NULL
 311     }
 312   }
 313   // Ignore if memory is dead, or self-loop
 314   Node *mem = in(MemNode::Memory);
 315   if (phase-&gt;type( mem ) == Type::TOP) return NodeSentinel; // caller will return NULL
 316   assert(mem != this, &quot;dead loop in MemNode::Ideal&quot;);
 317 
 318   if (can_reshape &amp;&amp; igvn != NULL &amp;&amp; igvn-&gt;_worklist.member(mem)) {
 319     // This memory slice may be dead.
 320     // Delay this mem node transformation until the memory is processed.
 321     phase-&gt;is_IterGVN()-&gt;_worklist.push(this);
 322     return NodeSentinel; // caller will return NULL
 323   }
 324 
 325   Node *address = in(MemNode::Address);
 326   const Type *t_adr = phase-&gt;type(address);
 327   if (t_adr == Type::TOP)              return NodeSentinel; // caller will return NULL
 328 
 329   if (can_reshape &amp;&amp; is_unsafe_access() &amp;&amp; (t_adr == TypePtr::NULL_PTR)) {
 330     // Unsafe off-heap access with zero address. Remove access and other control users
 331     // to not confuse optimizations and add a HaltNode to fail if this is ever executed.
 332     assert(ctl != NULL, &quot;unsafe accesses should be control dependent&quot;);
 333     for (DUIterator_Fast imax, i = ctl-&gt;fast_outs(imax); i &lt; imax; i++) {
 334       Node* u = ctl-&gt;fast_out(i);
 335       if (u != ctl) {
 336         igvn-&gt;rehash_node_delayed(u);
 337         int nb = u-&gt;replace_edge(ctl, phase-&gt;C-&gt;top());
 338         --i, imax -= nb;
 339       }
 340     }
 341     Node* frame = igvn-&gt;transform(new ParmNode(phase-&gt;C-&gt;start(), TypeFunc::FramePtr));
 342     Node* halt = igvn-&gt;transform(new HaltNode(ctl, frame, &quot;unsafe off-heap access with zero address&quot;));
 343     phase-&gt;C-&gt;root()-&gt;add_req(halt);
 344     return this;
 345   }
 346 
 347   if (can_reshape &amp;&amp; igvn != NULL &amp;&amp;
 348       (igvn-&gt;_worklist.member(address) ||
 349        (igvn-&gt;_worklist.size() &gt; 0 &amp;&amp; t_adr != adr_type())) ) {
 350     // The address&#39;s base and type may change when the address is processed.
 351     // Delay this mem node transformation until the address is processed.
 352     phase-&gt;is_IterGVN()-&gt;_worklist.push(this);
 353     return NodeSentinel; // caller will return NULL
 354   }
 355 
 356   // Do NOT remove or optimize the next lines: ensure a new alias index
 357   // is allocated for an oop pointer type before Escape Analysis.
 358   // Note: C++ will not remove it since the call has side effect.
 359   if (t_adr-&gt;isa_oopptr()) {
 360     int alias_idx = phase-&gt;C-&gt;get_alias_index(t_adr-&gt;is_ptr());
 361   }
 362 
 363   Node* base = NULL;
 364   if (address-&gt;is_AddP()) {
 365     base = address-&gt;in(AddPNode::Base);
 366   }
 367   if (base != NULL &amp;&amp; phase-&gt;type(base)-&gt;higher_equal(TypePtr::NULL_PTR) &amp;&amp;
 368       !t_adr-&gt;isa_rawptr()) {
 369     // Note: raw address has TOP base and top-&gt;higher_equal(TypePtr::NULL_PTR) is true.
 370     // Skip this node optimization if its address has TOP base.
 371     return NodeSentinel; // caller will return NULL
 372   }
 373 
 374   // Avoid independent memory operations
 375   Node* old_mem = mem;
 376 
 377   // The code which unhooks non-raw memories from complete (macro-expanded)
 378   // initializations was removed. After macro-expansion all stores catched
 379   // by Initialize node became raw stores and there is no information
 380   // which memory slices they modify. So it is unsafe to move any memory
 381   // operation above these stores. Also in most cases hooked non-raw memories
 382   // were already unhooked by using information from detect_ptr_independence()
 383   // and find_previous_store().
 384 
 385   if (mem-&gt;is_MergeMem()) {
 386     MergeMemNode* mmem = mem-&gt;as_MergeMem();
 387     const TypePtr *tp = t_adr-&gt;is_ptr();
 388 
 389     mem = step_through_mergemem(phase, mmem, tp, adr_type(), tty);
 390   }
 391 
 392   if (mem != old_mem) {
 393     set_req(MemNode::Memory, mem);
 394     if (can_reshape &amp;&amp; old_mem-&gt;outcnt() == 0 &amp;&amp; igvn != NULL) {
 395       igvn-&gt;_worklist.push(old_mem);
 396     }
 397     if (phase-&gt;type(mem) == Type::TOP) return NodeSentinel;
 398     return this;
 399   }
 400 
 401   // let the subclass continue analyzing...
 402   return NULL;
 403 }
 404 
 405 // Helper function for proving some simple control dominations.
 406 // Attempt to prove that all control inputs of &#39;dom&#39; dominate &#39;sub&#39;.
 407 // Already assumes that &#39;dom&#39; is available at &#39;sub&#39;, and that &#39;sub&#39;
 408 // is not a constant (dominated by the method&#39;s StartNode).
 409 // Used by MemNode::find_previous_store to prove that the
 410 // control input of a memory operation predates (dominates)
 411 // an allocation it wants to look past.
 412 bool MemNode::all_controls_dominate(Node* dom, Node* sub) {
 413   if (dom == NULL || dom-&gt;is_top() || sub == NULL || sub-&gt;is_top())
 414     return false; // Conservative answer for dead code
 415 
 416   // Check &#39;dom&#39;. Skip Proj and CatchProj nodes.
 417   dom = dom-&gt;find_exact_control(dom);
 418   if (dom == NULL || dom-&gt;is_top())
 419     return false; // Conservative answer for dead code
 420 
 421   if (dom == sub) {
 422     // For the case when, for example, &#39;sub&#39; is Initialize and the original
 423     // &#39;dom&#39; is Proj node of the &#39;sub&#39;.
 424     return false;
 425   }
 426 
 427   if (dom-&gt;is_Con() || dom-&gt;is_Start() || dom-&gt;is_Root() || dom == sub)
 428     return true;
 429 
 430   // &#39;dom&#39; dominates &#39;sub&#39; if its control edge and control edges
 431   // of all its inputs dominate or equal to sub&#39;s control edge.
 432 
 433   // Currently &#39;sub&#39; is either Allocate, Initialize or Start nodes.
 434   // Or Region for the check in LoadNode::Ideal();
 435   // &#39;sub&#39; should have sub-&gt;in(0) != NULL.
 436   assert(sub-&gt;is_Allocate() || sub-&gt;is_Initialize() || sub-&gt;is_Start() ||
 437          sub-&gt;is_Region() || sub-&gt;is_Call(), &quot;expecting only these nodes&quot;);
 438 
 439   // Get control edge of &#39;sub&#39;.
 440   Node* orig_sub = sub;
 441   sub = sub-&gt;find_exact_control(sub-&gt;in(0));
 442   if (sub == NULL || sub-&gt;is_top())
 443     return false; // Conservative answer for dead code
 444 
 445   assert(sub-&gt;is_CFG(), &quot;expecting control&quot;);
 446 
 447   if (sub == dom)
 448     return true;
 449 
 450   if (sub-&gt;is_Start() || sub-&gt;is_Root())
 451     return false;
 452 
 453   {
 454     // Check all control edges of &#39;dom&#39;.
 455 
 456     ResourceMark rm;
 457     Arena* arena = Thread::current()-&gt;resource_area();
 458     Node_List nlist(arena);
 459     Unique_Node_List dom_list(arena);
 460 
 461     dom_list.push(dom);
 462     bool only_dominating_controls = false;
 463 
 464     for (uint next = 0; next &lt; dom_list.size(); next++) {
 465       Node* n = dom_list.at(next);
 466       if (n == orig_sub)
 467         return false; // One of dom&#39;s inputs dominated by sub.
 468       if (!n-&gt;is_CFG() &amp;&amp; n-&gt;pinned()) {
 469         // Check only own control edge for pinned non-control nodes.
 470         n = n-&gt;find_exact_control(n-&gt;in(0));
 471         if (n == NULL || n-&gt;is_top())
 472           return false; // Conservative answer for dead code
 473         assert(n-&gt;is_CFG(), &quot;expecting control&quot;);
 474         dom_list.push(n);
 475       } else if (n-&gt;is_Con() || n-&gt;is_Start() || n-&gt;is_Root()) {
 476         only_dominating_controls = true;
 477       } else if (n-&gt;is_CFG()) {
 478         if (n-&gt;dominates(sub, nlist))
 479           only_dominating_controls = true;
 480         else
 481           return false;
 482       } else {
 483         // First, own control edge.
 484         Node* m = n-&gt;find_exact_control(n-&gt;in(0));
 485         if (m != NULL) {
 486           if (m-&gt;is_top())
 487             return false; // Conservative answer for dead code
 488           dom_list.push(m);
 489         }
 490         // Now, the rest of edges.
 491         uint cnt = n-&gt;req();
 492         for (uint i = 1; i &lt; cnt; i++) {
 493           m = n-&gt;find_exact_control(n-&gt;in(i));
 494           if (m == NULL || m-&gt;is_top())
 495             continue;
 496           dom_list.push(m);
 497         }
 498       }
 499     }
 500     return only_dominating_controls;
 501   }
 502 }
 503 
 504 //---------------------detect_ptr_independence---------------------------------
 505 // Used by MemNode::find_previous_store to prove that two base
 506 // pointers are never equal.
 507 // The pointers are accompanied by their associated allocations,
 508 // if any, which have been previously discovered by the caller.
 509 bool MemNode::detect_ptr_independence(Node* p1, AllocateNode* a1,
 510                                       Node* p2, AllocateNode* a2,
 511                                       PhaseTransform* phase) {
 512   // Attempt to prove that these two pointers cannot be aliased.
 513   // They may both manifestly be allocations, and they should differ.
 514   // Or, if they are not both allocations, they can be distinct constants.
 515   // Otherwise, one is an allocation and the other a pre-existing value.
 516   if (a1 == NULL &amp;&amp; a2 == NULL) {           // neither an allocation
 517     return (p1 != p2) &amp;&amp; p1-&gt;is_Con() &amp;&amp; p2-&gt;is_Con();
 518   } else if (a1 != NULL &amp;&amp; a2 != NULL) {    // both allocations
 519     return (a1 != a2);
 520   } else if (a1 != NULL) {                  // one allocation a1
 521     // (Note:  p2-&gt;is_Con implies p2-&gt;in(0)-&gt;is_Root, which dominates.)
 522     return all_controls_dominate(p2, a1);
 523   } else { //(a2 != NULL)                   // one allocation a2
 524     return all_controls_dominate(p1, a2);
 525   }
 526   return false;
 527 }
 528 
 529 
 530 // Find an arraycopy that must have set (can_see_stored_value=true) or
 531 // could have set (can_see_stored_value=false) the value for this load
 532 Node* LoadNode::find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const {
 533   if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0) != NULL &amp;&amp; (mem-&gt;in(0)-&gt;Opcode() == Op_MemBarStoreStore ||
 534                                                mem-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder)) {
 535     Node* mb = mem-&gt;in(0);
 536     if (mb-&gt;in(0) != NULL &amp;&amp; mb-&gt;in(0)-&gt;is_Proj() &amp;&amp;
 537         mb-&gt;in(0)-&gt;in(0) != NULL &amp;&amp; mb-&gt;in(0)-&gt;in(0)-&gt;is_ArrayCopy()) {
 538       ArrayCopyNode* ac = mb-&gt;in(0)-&gt;in(0)-&gt;as_ArrayCopy();
 539       if (ac-&gt;is_clonebasic()) {
 540         intptr_t offset;
 541         AllocateNode* alloc = AllocateNode::Ideal_allocation(ac-&gt;in(ArrayCopyNode::Dest), phase, offset);
 542         if (alloc != NULL &amp;&amp; alloc == ld_alloc) {
 543           return ac;
 544         }
 545       }
 546     }
 547   } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0) != NULL &amp;&amp; mem-&gt;in(0)-&gt;is_ArrayCopy()) {
 548     ArrayCopyNode* ac = mem-&gt;in(0)-&gt;as_ArrayCopy();
 549 
 550     if (ac-&gt;is_arraycopy_validated() ||
 551         ac-&gt;is_copyof_validated() ||
 552         ac-&gt;is_copyofrange_validated()) {
 553       Node* ld_addp = in(MemNode::Address);
 554       if (ld_addp-&gt;is_AddP()) {
 555         Node* ld_base = ld_addp-&gt;in(AddPNode::Address);
 556         Node* ld_offs = ld_addp-&gt;in(AddPNode::Offset);
 557 
 558         Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
 559 
 560         if (dest == ld_base) {
 561           const TypeX *ld_offs_t = phase-&gt;type(ld_offs)-&gt;isa_intptr_t();
 562           if (ac-&gt;modifies(ld_offs_t-&gt;_lo, ld_offs_t-&gt;_hi, phase, can_see_stored_value)) {
 563             return ac;
 564           }
 565           if (!can_see_stored_value) {
 566             mem = ac-&gt;in(TypeFunc::Memory);
 567           }
 568         }
 569       }
 570     }
 571   }
 572   return NULL;
 573 }
 574 
 575 // The logic for reordering loads and stores uses four steps:
 576 // (a) Walk carefully past stores and initializations which we
 577 //     can prove are independent of this load.
 578 // (b) Observe that the next memory state makes an exact match
 579 //     with self (load or store), and locate the relevant store.
 580 // (c) Ensure that, if we were to wire self directly to the store,
 581 //     the optimizer would fold it up somehow.
 582 // (d) Do the rewiring, and return, depending on some other part of
 583 //     the optimizer to fold up the load.
 584 // This routine handles steps (a) and (b).  Steps (c) and (d) are
 585 // specific to loads and stores, so they are handled by the callers.
 586 // (Currently, only LoadNode::Ideal has steps (c), (d).  More later.)
 587 //
 588 Node* MemNode::find_previous_store(PhaseTransform* phase) {
 589   Node*         ctrl   = in(MemNode::Control);
 590   Node*         adr    = in(MemNode::Address);
 591   intptr_t      offset = 0;
 592   Node*         base   = AddPNode::Ideal_base_and_offset(adr, phase, offset);
 593   AllocateNode* alloc  = AllocateNode::Ideal_allocation(base, phase);
 594 
 595   if (offset == Type::OffsetBot)
 596     return NULL;            // cannot unalias unless there are precise offsets
 597 
 598   const bool adr_maybe_raw = check_if_adr_maybe_raw(adr);
 599   const TypeOopPtr *addr_t = adr-&gt;bottom_type()-&gt;isa_oopptr();
 600 
 601   intptr_t size_in_bytes = memory_size();
 602 
 603   Node* mem = in(MemNode::Memory);   // start searching here...
 604 
 605   int cnt = 50;             // Cycle limiter
 606   for (;;) {                // While we can dance past unrelated stores...
 607     if (--cnt &lt; 0)  break;  // Caught in cycle or a complicated dance?
 608 
 609     Node* prev = mem;
 610     if (mem-&gt;is_Store()) {
 611       Node* st_adr = mem-&gt;in(MemNode::Address);
 612       intptr_t st_offset = 0;
 613       Node* st_base = AddPNode::Ideal_base_and_offset(st_adr, phase, st_offset);
 614       if (st_base == NULL)
 615         break;              // inscrutable pointer
 616 
 617       // For raw accesses it&#39;s not enough to prove that constant offsets don&#39;t intersect.
 618       // We need the bases to be the equal in order for the offset check to make sense.
 619       if ((adr_maybe_raw || check_if_adr_maybe_raw(st_adr)) &amp;&amp; st_base != base) {
 620         break;
 621       }
 622 
 623       if (st_offset != offset &amp;&amp; st_offset != Type::OffsetBot) {
 624         const int MAX_STORE = BytesPerLong;
 625         if (st_offset &gt;= offset + size_in_bytes ||
 626             st_offset &lt;= offset - MAX_STORE ||
 627             st_offset &lt;= offset - mem-&gt;as_Store()-&gt;memory_size()) {
 628           // Success:  The offsets are provably independent.
 629           // (You may ask, why not just test st_offset != offset and be done?
 630           // The answer is that stores of different sizes can co-exist
 631           // in the same sequence of RawMem effects.  We sometimes initialize
 632           // a whole &#39;tile&#39; of array elements with a single jint or jlong.)
 633           mem = mem-&gt;in(MemNode::Memory);
 634           continue;           // (a) advance through independent store memory
 635         }
 636       }
 637       if (st_base != base &amp;&amp;
 638           detect_ptr_independence(base, alloc,
 639                                   st_base,
 640                                   AllocateNode::Ideal_allocation(st_base, phase),
 641                                   phase)) {
 642         // Success:  The bases are provably independent.
 643         mem = mem-&gt;in(MemNode::Memory);
 644         continue;           // (a) advance through independent store memory
 645       }
 646 
 647       // (b) At this point, if the bases or offsets do not agree, we lose,
 648       // since we have not managed to prove &#39;this&#39; and &#39;mem&#39; independent.
 649       if (st_base == base &amp;&amp; st_offset == offset) {
 650         return mem;         // let caller handle steps (c), (d)
 651       }
 652 
 653     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Initialize()) {
 654       InitializeNode* st_init = mem-&gt;in(0)-&gt;as_Initialize();
 655       AllocateNode*  st_alloc = st_init-&gt;allocation();
 656       if (st_alloc == NULL)
 657         break;              // something degenerated
 658       bool known_identical = false;
 659       bool known_independent = false;
 660       if (alloc == st_alloc)
 661         known_identical = true;
 662       else if (alloc != NULL)
 663         known_independent = true;
 664       else if (all_controls_dominate(this, st_alloc))
 665         known_independent = true;
 666 
 667       if (known_independent) {
 668         // The bases are provably independent: Either they are
 669         // manifestly distinct allocations, or else the control
 670         // of this load dominates the store&#39;s allocation.
 671         int alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type());
 672         if (alias_idx == Compile::AliasIdxRaw) {
 673           mem = st_alloc-&gt;in(TypeFunc::Memory);
 674         } else {
 675           mem = st_init-&gt;memory(alias_idx);
 676         }
 677         continue;           // (a) advance through independent store memory
 678       }
 679 
 680       // (b) at this point, if we are not looking at a store initializing
 681       // the same allocation we are loading from, we lose.
 682       if (known_identical) {
 683         // From caller, can_see_stored_value will consult find_captured_store.
 684         return mem;         // let caller handle steps (c), (d)
 685       }
 686 
 687     } else if (find_previous_arraycopy(phase, alloc, mem, false) != NULL) {
 688       if (prev != mem) {
 689         // Found an arraycopy but it doesn&#39;t affect that load
 690         continue;
 691       }
 692       // Found an arraycopy that may affect that load
 693       return mem;
 694     } else if (addr_t != NULL &amp;&amp; addr_t-&gt;is_known_instance_field()) {
 695       // Can&#39;t use optimize_simple_memory_chain() since it needs PhaseGVN.
 696       if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Call()) {
 697         // ArrayCopyNodes processed here as well.
 698         CallNode *call = mem-&gt;in(0)-&gt;as_Call();
 699         if (!call-&gt;may_modify(addr_t, phase)) {
 700           mem = call-&gt;in(TypeFunc::Memory);
 701           continue;         // (a) advance through independent call memory
 702         }
 703       } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_MemBar()) {
 704         ArrayCopyNode* ac = NULL;
 705         if (ArrayCopyNode::may_modify(addr_t, mem-&gt;in(0)-&gt;as_MemBar(), phase, ac)) {
 706           break;
 707         }
 708         mem = mem-&gt;in(0)-&gt;in(TypeFunc::Memory);
 709         continue;           // (a) advance through independent MemBar memory
 710       } else if (mem-&gt;is_ClearArray()) {
 711         if (ClearArrayNode::step_through(&amp;mem, (uint)addr_t-&gt;instance_id(), phase)) {
 712           // (the call updated &#39;mem&#39; value)
 713           continue;         // (a) advance through independent allocation memory
 714         } else {
 715           // Can not bypass initialization of the instance
 716           // we are looking for.
 717           return mem;
 718         }
 719       } else if (mem-&gt;is_MergeMem()) {
 720         int alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type());
 721         mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias_idx);
 722         continue;           // (a) advance through independent MergeMem memory
 723       }
 724     }
 725 
 726     // Unless there is an explicit &#39;continue&#39;, we must bail out here,
 727     // because &#39;mem&#39; is an inscrutable memory state (e.g., a call).
 728     break;
 729   }
 730 
 731   return NULL;              // bail out
 732 }
 733 
 734 //----------------------calculate_adr_type-------------------------------------
 735 // Helper function.  Notices when the given type of address hits top or bottom.
 736 // Also, asserts a cross-check of the type against the expected address type.
 737 const TypePtr* MemNode::calculate_adr_type(const Type* t, const TypePtr* cross_check) {
 738   if (t == Type::TOP)  return NULL; // does not touch memory any more?
 739   #ifdef ASSERT
 740   if (!VerifyAliases || VMError::is_error_reported() || Node::in_dump())  cross_check = NULL;
 741   #endif
 742   const TypePtr* tp = t-&gt;isa_ptr();
 743   if (tp == NULL) {
 744     assert(cross_check == NULL || cross_check == TypePtr::BOTTOM, &quot;expected memory type must be wide&quot;);
 745     return TypePtr::BOTTOM;           // touches lots of memory
 746   } else {
 747     #ifdef ASSERT
 748     // %%%% [phh] We don&#39;t check the alias index if cross_check is
 749     //            TypeRawPtr::BOTTOM.  Needs to be investigated.
 750     if (cross_check != NULL &amp;&amp;
 751         cross_check != TypePtr::BOTTOM &amp;&amp;
 752         cross_check != TypeRawPtr::BOTTOM) {
 753       // Recheck the alias index, to see if it has changed (due to a bug).
 754       Compile* C = Compile::current();
 755       assert(C-&gt;get_alias_index(cross_check) == C-&gt;get_alias_index(tp),
 756              &quot;must stay in the original alias category&quot;);
 757       // The type of the address must be contained in the adr_type,
 758       // disregarding &quot;null&quot;-ness.
 759       // (We make an exception for TypeRawPtr::BOTTOM, which is a bit bucket.)
 760       const TypePtr* tp_notnull = tp-&gt;join(TypePtr::NOTNULL)-&gt;is_ptr();
 761       assert(cross_check-&gt;meet(tp_notnull) == cross_check-&gt;remove_speculative(),
 762              &quot;real address must not escape from expected memory type&quot;);
 763     }
 764     #endif
 765     return tp;
 766   }
 767 }
 768 
 769 //=============================================================================
 770 // Should LoadNode::Ideal() attempt to remove control edges?
 771 bool LoadNode::can_remove_control() const {
 772   return true;
 773 }
 774 uint LoadNode::size_of() const { return sizeof(*this); }
 775 bool LoadNode::cmp( const Node &amp;n ) const
 776 { return !Type::cmp( _type, ((LoadNode&amp;)n)._type ); }
 777 const Type *LoadNode::bottom_type() const { return _type; }
 778 uint LoadNode::ideal_reg() const {
 779   return _type-&gt;ideal_reg();
 780 }
 781 
 782 #ifndef PRODUCT
 783 void LoadNode::dump_spec(outputStream *st) const {
 784   MemNode::dump_spec(st);
 785   if( !Verbose &amp;&amp; !WizardMode ) {
 786     // standard dump does this in Verbose and WizardMode
 787     st-&gt;print(&quot; #&quot;); _type-&gt;dump_on(st);
 788   }
 789   if (!depends_only_on_test()) {
 790     st-&gt;print(&quot; (does not depend only on test)&quot;);
 791   }
 792 }
 793 #endif
 794 
 795 #ifdef ASSERT
 796 //----------------------------is_immutable_value-------------------------------
 797 // Helper function to allow a raw load without control edge for some cases
 798 bool LoadNode::is_immutable_value(Node* adr) {
 799   return (adr-&gt;is_AddP() &amp;&amp; adr-&gt;in(AddPNode::Base)-&gt;is_top() &amp;&amp;
 800           adr-&gt;in(AddPNode::Address)-&gt;Opcode() == Op_ThreadLocal &amp;&amp;
 801           (adr-&gt;in(AddPNode::Offset)-&gt;find_intptr_t_con(-1) ==
 802            in_bytes(JavaThread::osthread_offset())));
 803 }
 804 #endif
 805 
 806 //----------------------------LoadNode::make-----------------------------------
 807 // Polymorphic factory method:
 808 Node *LoadNode::make(PhaseGVN&amp; gvn, Node *ctl, Node *mem, Node *adr, const TypePtr* adr_type, const Type *rt, BasicType bt, MemOrd mo,
 809                      ControlDependency control_dependency, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {
 810   Compile* C = gvn.C;
 811 
 812   // sanity check the alias category against the created node type
 813   assert(!(adr_type-&gt;isa_oopptr() &amp;&amp;
 814            adr_type-&gt;offset() == oopDesc::klass_offset_in_bytes()),
 815          &quot;use LoadKlassNode instead&quot;);
 816   assert(!(adr_type-&gt;isa_aryptr() &amp;&amp;
 817            adr_type-&gt;offset() == arrayOopDesc::length_offset_in_bytes()),
 818          &quot;use LoadRangeNode instead&quot;);
 819   // Check control edge of raw loads
 820   assert( ctl != NULL || C-&gt;get_alias_index(adr_type) != Compile::AliasIdxRaw ||
 821           // oop will be recorded in oop map if load crosses safepoint
 822           rt-&gt;isa_oopptr() || is_immutable_value(adr),
 823           &quot;raw memory operations should have control edge&quot;);
 824   LoadNode* load = NULL;
 825   switch (bt) {
 826   case T_BOOLEAN: load = new LoadUBNode(ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 827   case T_BYTE:    load = new LoadBNode (ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 828   case T_INT:     load = new LoadINode (ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 829   case T_CHAR:    load = new LoadUSNode(ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 830   case T_SHORT:   load = new LoadSNode (ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 831   case T_LONG:    load = new LoadLNode (ctl, mem, adr, adr_type, rt-&gt;is_long(), mo, control_dependency); break;
 832   case T_FLOAT:   load = new LoadFNode (ctl, mem, adr, adr_type, rt,            mo, control_dependency); break;
 833   case T_DOUBLE:  load = new LoadDNode (ctl, mem, adr, adr_type, rt,            mo, control_dependency); break;
 834   case T_ADDRESS: load = new LoadPNode (ctl, mem, adr, adr_type, rt-&gt;is_ptr(),  mo, control_dependency); break;
 835   case T_OBJECT:
 836 #ifdef _LP64
 837     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 838       load = new LoadNNode(ctl, mem, adr, adr_type, rt-&gt;make_narrowoop(), mo, control_dependency);
 839     } else
 840 #endif
 841     {
 842       assert(!adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() &amp;&amp; !adr-&gt;bottom_type()-&gt;is_ptr_to_narrowklass(), &quot;should have got back a narrow oop&quot;);
 843       load = new LoadPNode(ctl, mem, adr, adr_type, rt-&gt;is_ptr(), mo, control_dependency);
 844     }
 845     break;
 846   default:
 847     ShouldNotReachHere();
 848     break;
 849   }
 850   assert(load != NULL, &quot;LoadNode should have been created&quot;);
 851   if (unaligned) {
 852     load-&gt;set_unaligned_access();
 853   }
 854   if (mismatched) {
 855     load-&gt;set_mismatched_access();
 856   }
 857   if (unsafe) {
 858     load-&gt;set_unsafe_access();
 859   }
 860   load-&gt;set_barrier_data(barrier_data);
 861   if (load-&gt;Opcode() == Op_LoadN) {
 862     Node* ld = gvn.transform(load);
 863     return new DecodeNNode(ld, ld-&gt;bottom_type()-&gt;make_ptr());
 864   }
 865 
 866   return load;
 867 }
 868 
 869 LoadLNode* LoadLNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, const Type* rt, MemOrd mo,
 870                                   ControlDependency control_dependency, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {
 871   bool require_atomic = true;
 872   LoadLNode* load = new LoadLNode(ctl, mem, adr, adr_type, rt-&gt;is_long(), mo, control_dependency, require_atomic);
 873   if (unaligned) {
 874     load-&gt;set_unaligned_access();
 875   }
 876   if (mismatched) {
 877     load-&gt;set_mismatched_access();
 878   }
 879   if (unsafe) {
 880     load-&gt;set_unsafe_access();
 881   }
 882   load-&gt;set_barrier_data(barrier_data);
 883   return load;
 884 }
 885 
 886 LoadDNode* LoadDNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, const Type* rt, MemOrd mo,
 887                                   ControlDependency control_dependency, bool unaligned, bool mismatched, bool unsafe, uint8_t barrier_data) {
 888   bool require_atomic = true;
 889   LoadDNode* load = new LoadDNode(ctl, mem, adr, adr_type, rt, mo, control_dependency, require_atomic);
 890   if (unaligned) {
 891     load-&gt;set_unaligned_access();
 892   }
 893   if (mismatched) {
 894     load-&gt;set_mismatched_access();
 895   }
 896   if (unsafe) {
 897     load-&gt;set_unsafe_access();
 898   }
 899   load-&gt;set_barrier_data(barrier_data);
 900   return load;
 901 }
 902 
 903 
 904 
 905 //------------------------------hash-------------------------------------------
 906 uint LoadNode::hash() const {
 907   // unroll addition of interesting fields
 908   return (uintptr_t)in(Control) + (uintptr_t)in(Memory) + (uintptr_t)in(Address);
 909 }
 910 
 911 static bool skip_through_membars(Compile::AliasType* atp, const TypeInstPtr* tp, bool eliminate_boxing) {
 912   if ((atp != NULL) &amp;&amp; (atp-&gt;index() &gt;= Compile::AliasIdxRaw)) {
 913     bool non_volatile = (atp-&gt;field() != NULL) &amp;&amp; !atp-&gt;field()-&gt;is_volatile();
 914     bool is_stable_ary = FoldStableValues &amp;&amp;
 915                          (tp != NULL) &amp;&amp; (tp-&gt;isa_aryptr() != NULL) &amp;&amp;
 916                          tp-&gt;isa_aryptr()-&gt;is_stable();
 917 
 918     return (eliminate_boxing &amp;&amp; non_volatile) || is_stable_ary;
 919   }
 920 
 921   return false;
 922 }
 923 
 924 // Is the value loaded previously stored by an arraycopy? If so return
 925 // a load node that reads from the source array so we may be able to
 926 // optimize out the ArrayCopy node later.
 927 Node* LoadNode::can_see_arraycopy_value(Node* st, PhaseGVN* phase) const {
 928   Node* ld_adr = in(MemNode::Address);
 929   intptr_t ld_off = 0;
 930   AllocateNode* ld_alloc = AllocateNode::Ideal_allocation(ld_adr, phase, ld_off);
 931   Node* ac = find_previous_arraycopy(phase, ld_alloc, st, true);
 932   if (ac != NULL) {
 933     assert(ac-&gt;is_ArrayCopy(), &quot;what kind of node can this be?&quot;);
 934 
 935     Node* mem = ac-&gt;in(TypeFunc::Memory);
 936     Node* ctl = ac-&gt;in(0);
 937     Node* src = ac-&gt;in(ArrayCopyNode::Src);
 938 
 939     if (!ac-&gt;as_ArrayCopy()-&gt;is_clonebasic() &amp;&amp; !phase-&gt;type(src)-&gt;isa_aryptr()) {
 940       return NULL;
 941     }
 942 
 943     LoadNode* ld = clone()-&gt;as_Load();
 944     Node* addp = in(MemNode::Address)-&gt;clone();
 945     if (ac-&gt;as_ArrayCopy()-&gt;is_clonebasic()) {
 946       assert(ld_alloc != NULL, &quot;need an alloc&quot;);
 947       assert(addp-&gt;is_AddP(), &quot;address must be addp&quot;);
 948       assert(ac-&gt;in(ArrayCopyNode::Dest)-&gt;is_AddP(), &quot;dest must be an address&quot;);
 949       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 950       assert(bs-&gt;step_over_gc_barrier(addp-&gt;in(AddPNode::Base)) == bs-&gt;step_over_gc_barrier(ac-&gt;in(ArrayCopyNode::Dest)-&gt;in(AddPNode::Base)), &quot;strange pattern&quot;);
 951       assert(bs-&gt;step_over_gc_barrier(addp-&gt;in(AddPNode::Address)) == bs-&gt;step_over_gc_barrier(ac-&gt;in(ArrayCopyNode::Dest)-&gt;in(AddPNode::Address)), &quot;strange pattern&quot;);
 952       addp-&gt;set_req(AddPNode::Base, src-&gt;in(AddPNode::Base));
 953       addp-&gt;set_req(AddPNode::Address, src-&gt;in(AddPNode::Address));
 954     } else {
 955       assert(ac-&gt;as_ArrayCopy()-&gt;is_arraycopy_validated() ||
 956              ac-&gt;as_ArrayCopy()-&gt;is_copyof_validated() ||
 957              ac-&gt;as_ArrayCopy()-&gt;is_copyofrange_validated(), &quot;only supported cases&quot;);
 958       assert(addp-&gt;in(AddPNode::Base) == addp-&gt;in(AddPNode::Address), &quot;should be&quot;);
 959       addp-&gt;set_req(AddPNode::Base, src);
 960       addp-&gt;set_req(AddPNode::Address, src);
 961 
 962       const TypeAryPtr* ary_t = phase-&gt;type(in(MemNode::Address))-&gt;isa_aryptr();
 963       BasicType ary_elem  = ary_t-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
 964       uint header = arrayOopDesc::base_offset_in_bytes(ary_elem);
 965       uint shift  = exact_log2(type2aelembytes(ary_elem));
 966 
 967       Node* diff = phase-&gt;transform(new SubINode(ac-&gt;in(ArrayCopyNode::SrcPos), ac-&gt;in(ArrayCopyNode::DestPos)));
 968 #ifdef _LP64
 969       diff = phase-&gt;transform(new ConvI2LNode(diff));
 970 #endif
 971       diff = phase-&gt;transform(new LShiftXNode(diff, phase-&gt;intcon(shift)));
 972 
 973       Node* offset = phase-&gt;transform(new AddXNode(addp-&gt;in(AddPNode::Offset), diff));
 974       addp-&gt;set_req(AddPNode::Offset, offset);
 975     }
 976     addp = phase-&gt;transform(addp);
 977 #ifdef ASSERT
 978     const TypePtr* adr_type = phase-&gt;type(addp)-&gt;is_ptr();
 979     ld-&gt;_adr_type = adr_type;
 980 #endif
 981     ld-&gt;set_req(MemNode::Address, addp);
 982     ld-&gt;set_req(0, ctl);
 983     ld-&gt;set_req(MemNode::Memory, mem);
 984     // load depends on the tests that validate the arraycopy
 985     ld-&gt;_control_dependency = UnknownControl;
 986     return ld;
 987   }
 988   return NULL;
 989 }
 990 
 991 
 992 //---------------------------can_see_stored_value------------------------------
 993 // This routine exists to make sure this set of tests is done the same
 994 // everywhere.  We need to make a coordinated change: first LoadNode::Ideal
 995 // will change the graph shape in a way which makes memory alive twice at the
 996 // same time (uses the Oracle model of aliasing), then some
 997 // LoadXNode::Identity will fold things back to the equivalence-class model
 998 // of aliasing.
 999 Node* MemNode::can_see_stored_value(Node* st, PhaseTransform* phase) const {
1000   Node* ld_adr = in(MemNode::Address);
1001   intptr_t ld_off = 0;
1002   Node* ld_base = AddPNode::Ideal_base_and_offset(ld_adr, phase, ld_off);
1003   Node* ld_alloc = AllocateNode::Ideal_allocation(ld_base, phase);
1004   const TypeInstPtr* tp = phase-&gt;type(ld_adr)-&gt;isa_instptr();
1005   Compile::AliasType* atp = (tp != NULL) ? phase-&gt;C-&gt;alias_type(tp) : NULL;
1006   // This is more general than load from boxing objects.
1007   if (skip_through_membars(atp, tp, phase-&gt;C-&gt;eliminate_boxing())) {
1008     uint alias_idx = atp-&gt;index();
1009     bool final = !atp-&gt;is_rewritable();
1010     Node* result = NULL;
1011     Node* current = st;
1012     // Skip through chains of MemBarNodes checking the MergeMems for
1013     // new states for the slice of this load.  Stop once any other
1014     // kind of node is encountered.  Loads from final memory can skip
1015     // through any kind of MemBar but normal loads shouldn&#39;t skip
1016     // through MemBarAcquire since the could allow them to move out of
1017     // a synchronized region.
1018     while (current-&gt;is_Proj()) {
1019       int opc = current-&gt;in(0)-&gt;Opcode();
1020       if ((final &amp;&amp; (opc == Op_MemBarAcquire ||
1021                      opc == Op_MemBarAcquireLock ||
1022                      opc == Op_LoadFence)) ||
1023           opc == Op_MemBarRelease ||
1024           opc == Op_StoreFence ||
1025           opc == Op_MemBarReleaseLock ||
1026           opc == Op_MemBarStoreStore ||
1027           opc == Op_MemBarCPUOrder) {
1028         Node* mem = current-&gt;in(0)-&gt;in(TypeFunc::Memory);
1029         if (mem-&gt;is_MergeMem()) {
1030           MergeMemNode* merge = mem-&gt;as_MergeMem();
1031           Node* new_st = merge-&gt;memory_at(alias_idx);
1032           if (new_st == merge-&gt;base_memory()) {
1033             // Keep searching
1034             current = new_st;
1035             continue;
1036           }
1037           // Save the new memory state for the slice and fall through
1038           // to exit.
1039           result = new_st;
1040         }
1041       }
1042       break;
1043     }
1044     if (result != NULL) {
1045       st = result;
1046     }
1047   }
1048 
1049   // Loop around twice in the case Load -&gt; Initialize -&gt; Store.
1050   // (See PhaseIterGVN::add_users_to_worklist, which knows about this case.)
1051   for (int trip = 0; trip &lt;= 1; trip++) {
1052 
1053     if (st-&gt;is_Store()) {
1054       Node* st_adr = st-&gt;in(MemNode::Address);
1055       if (!phase-&gt;eqv(st_adr, ld_adr)) {
1056         // Try harder before giving up. Unify base pointers with casts (e.g., raw/non-raw pointers).
1057         intptr_t st_off = 0;
1058         Node* st_base = AddPNode::Ideal_base_and_offset(st_adr, phase, st_off);
1059         if (ld_base == NULL)                                   return NULL;
1060         if (st_base == NULL)                                   return NULL;
1061         if (!ld_base-&gt;eqv_uncast(st_base, /*keep_deps=*/true)) return NULL;
1062         if (ld_off != st_off)                                  return NULL;
1063         if (ld_off == Type::OffsetBot)                         return NULL;
1064         // Same base, same offset.
1065         // Possible improvement for arrays: check index value instead of absolute offset.
1066 
1067         // At this point we have proven something like this setup:
1068         //   B = &lt;&lt; base &gt;&gt;
1069         //   L =  LoadQ(AddP(Check/CastPP(B), #Off))
1070         //   S = StoreQ(AddP(             B , #Off), V)
1071         // (Actually, we haven&#39;t yet proven the Q&#39;s are the same.)
1072         // In other words, we are loading from a casted version of
1073         // the same pointer-and-offset that we stored to.
1074         // Casted version may carry a dependency and it is respected.
1075         // Thus, we are able to replace L by V.
1076       }
1077       // Now prove that we have a LoadQ matched to a StoreQ, for some Q.
1078       if (store_Opcode() != st-&gt;Opcode())
1079         return NULL;
1080       return st-&gt;in(MemNode::ValueIn);
1081     }
1082 
1083     // A load from a freshly-created object always returns zero.
1084     // (This can happen after LoadNode::Ideal resets the load&#39;s memory input
1085     // to find_captured_store, which returned InitializeNode::zero_memory.)
1086     if (st-&gt;is_Proj() &amp;&amp; st-&gt;in(0)-&gt;is_Allocate() &amp;&amp;
1087         (st-&gt;in(0) == ld_alloc) &amp;&amp;
1088         (ld_off &gt;= st-&gt;in(0)-&gt;as_Allocate()-&gt;minimum_header_size())) {
1089       // return a zero value for the load&#39;s basic type
1090       // (This is one of the few places where a generic PhaseTransform
1091       // can create new nodes.  Think of it as lazily manifesting
1092       // virtually pre-existing constants.)
1093       return phase-&gt;zerocon(memory_type());
1094     }
1095 
1096     // A load from an initialization barrier can match a captured store.
1097     if (st-&gt;is_Proj() &amp;&amp; st-&gt;in(0)-&gt;is_Initialize()) {
1098       InitializeNode* init = st-&gt;in(0)-&gt;as_Initialize();
1099       AllocateNode* alloc = init-&gt;allocation();
1100       if ((alloc != NULL) &amp;&amp; (alloc == ld_alloc)) {
1101         // examine a captured store value
1102         st = init-&gt;find_captured_store(ld_off, memory_size(), phase);
1103         if (st != NULL) {
1104           continue;             // take one more trip around
1105         }
1106       }
1107     }
1108 
1109     // Load boxed value from result of valueOf() call is input parameter.
1110     if (this-&gt;is_Load() &amp;&amp; ld_adr-&gt;is_AddP() &amp;&amp;
1111         (tp != NULL) &amp;&amp; tp-&gt;is_ptr_to_boxed_value()) {
1112       intptr_t ignore = 0;
1113       Node* base = AddPNode::Ideal_base_and_offset(ld_adr, phase, ignore);
1114       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1115       base = bs-&gt;step_over_gc_barrier(base);
1116       if (base != NULL &amp;&amp; base-&gt;is_Proj() &amp;&amp;
1117           base-&gt;as_Proj()-&gt;_con == TypeFunc::Parms &amp;&amp;
1118           base-&gt;in(0)-&gt;is_CallStaticJava() &amp;&amp;
1119           base-&gt;in(0)-&gt;as_CallStaticJava()-&gt;is_boxing_method()) {
1120         return base-&gt;in(0)-&gt;in(TypeFunc::Parms);
1121       }
1122     }
1123 
1124     break;
1125   }
1126 
1127   return NULL;
1128 }
1129 
1130 //----------------------is_instance_field_load_with_local_phi------------------
1131 bool LoadNode::is_instance_field_load_with_local_phi(Node* ctrl) {
1132   if( in(Memory)-&gt;is_Phi() &amp;&amp; in(Memory)-&gt;in(0) == ctrl &amp;&amp;
1133       in(Address)-&gt;is_AddP() ) {
1134     const TypeOopPtr* t_oop = in(Address)-&gt;bottom_type()-&gt;isa_oopptr();
1135     // Only instances and boxed values.
1136     if( t_oop != NULL &amp;&amp;
1137         (t_oop-&gt;is_ptr_to_boxed_value() ||
1138          t_oop-&gt;is_known_instance_field()) &amp;&amp;
1139         t_oop-&gt;offset() != Type::OffsetBot &amp;&amp;
1140         t_oop-&gt;offset() != Type::OffsetTop) {
1141       return true;
1142     }
1143   }
1144   return false;
1145 }
1146 
1147 //------------------------------Identity---------------------------------------
1148 // Loads are identity if previous store is to same address
1149 Node* LoadNode::Identity(PhaseGVN* phase) {
1150   // If the previous store-maker is the right kind of Store, and the store is
1151   // to the same address, then we are equal to the value stored.
1152   Node* mem = in(Memory);
1153   Node* value = can_see_stored_value(mem, phase);
1154   if( value ) {
1155     // byte, short &amp; char stores truncate naturally.
1156     // A load has to load the truncated value which requires
1157     // some sort of masking operation and that requires an
1158     // Ideal call instead of an Identity call.
1159     if (memory_size() &lt; BytesPerInt) {
1160       // If the input to the store does not fit with the load&#39;s result type,
1161       // it must be truncated via an Ideal call.
1162       if (!phase-&gt;type(value)-&gt;higher_equal(phase-&gt;type(this)))
1163         return this;
1164     }
1165     // (This works even when value is a Con, but LoadNode::Value
1166     // usually runs first, producing the singleton type of the Con.)
1167     return value;
1168   }
1169 
1170   // Search for an existing data phi which was generated before for the same
1171   // instance&#39;s field to avoid infinite generation of phis in a loop.
1172   Node *region = mem-&gt;in(0);
1173   if (is_instance_field_load_with_local_phi(region)) {
1174     const TypeOopPtr *addr_t = in(Address)-&gt;bottom_type()-&gt;isa_oopptr();
1175     int this_index  = phase-&gt;C-&gt;get_alias_index(addr_t);
1176     int this_offset = addr_t-&gt;offset();
1177     int this_iid    = addr_t-&gt;instance_id();
1178     if (!addr_t-&gt;is_known_instance() &amp;&amp;
1179          addr_t-&gt;is_ptr_to_boxed_value()) {
1180       // Use _idx of address base (could be Phi node) for boxed values.
1181       intptr_t   ignore = 0;
1182       Node*      base = AddPNode::Ideal_base_and_offset(in(Address), phase, ignore);
1183       if (base == NULL) {
1184         return this;
1185       }
1186       this_iid = base-&gt;_idx;
1187     }
1188     const Type* this_type = bottom_type();
1189     for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
1190       Node* phi = region-&gt;fast_out(i);
1191       if (phi-&gt;is_Phi() &amp;&amp; phi != mem &amp;&amp;
1192           phi-&gt;as_Phi()-&gt;is_same_inst_field(this_type, (int)mem-&gt;_idx, this_iid, this_index, this_offset)) {
1193         return phi;
1194       }
1195     }
1196   }
1197 
1198   return this;
1199 }
1200 
1201 // Construct an equivalent unsigned load.
1202 Node* LoadNode::convert_to_unsigned_load(PhaseGVN&amp; gvn) {
1203   BasicType bt = T_ILLEGAL;
1204   const Type* rt = NULL;
1205   switch (Opcode()) {
1206     case Op_LoadUB: return this;
1207     case Op_LoadUS: return this;
1208     case Op_LoadB: bt = T_BOOLEAN; rt = TypeInt::UBYTE; break;
1209     case Op_LoadS: bt = T_CHAR;    rt = TypeInt::CHAR;  break;
1210     default:
1211       assert(false, &quot;no unsigned variant: %s&quot;, Name());
1212       return NULL;
1213   }
1214   return LoadNode::make(gvn, in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address),
1215                         raw_adr_type(), rt, bt, _mo, _control_dependency,
1216                         is_unaligned_access(), is_mismatched_access());
1217 }
1218 
1219 // Construct an equivalent signed load.
1220 Node* LoadNode::convert_to_signed_load(PhaseGVN&amp; gvn) {
1221   BasicType bt = T_ILLEGAL;
1222   const Type* rt = NULL;
1223   switch (Opcode()) {
1224     case Op_LoadUB: bt = T_BYTE;  rt = TypeInt::BYTE;  break;
1225     case Op_LoadUS: bt = T_SHORT; rt = TypeInt::SHORT; break;
1226     case Op_LoadB: // fall through
1227     case Op_LoadS: // fall through
1228     case Op_LoadI: // fall through
1229     case Op_LoadL: return this;
1230     default:
1231       assert(false, &quot;no signed variant: %s&quot;, Name());
1232       return NULL;
1233   }
1234   return LoadNode::make(gvn, in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address),
1235                         raw_adr_type(), rt, bt, _mo, _control_dependency,
1236                         is_unaligned_access(), is_mismatched_access());
1237 }
1238 
1239 // We&#39;re loading from an object which has autobox behaviour.
1240 // If this object is result of a valueOf call we&#39;ll have a phi
1241 // merging a newly allocated object and a load from the cache.
1242 // We want to replace this load with the original incoming
1243 // argument to the valueOf call.
1244 Node* LoadNode::eliminate_autobox(PhaseGVN* phase) {
1245   assert(phase-&gt;C-&gt;eliminate_boxing(), &quot;sanity&quot;);
1246   intptr_t ignore = 0;
1247   Node* base = AddPNode::Ideal_base_and_offset(in(Address), phase, ignore);
1248   if ((base == NULL) || base-&gt;is_Phi()) {
1249     // Push the loads from the phi that comes from valueOf up
1250     // through it to allow elimination of the loads and the recovery
1251     // of the original value. It is done in split_through_phi().
1252     return NULL;
1253   } else if (base-&gt;is_Load() ||
1254              (base-&gt;is_DecodeN() &amp;&amp; base-&gt;in(1)-&gt;is_Load())) {
1255     // Eliminate the load of boxed value for integer types from the cache
1256     // array by deriving the value from the index into the array.
1257     // Capture the offset of the load and then reverse the computation.
1258 
1259     // Get LoadN node which loads a boxing object from &#39;cache&#39; array.
1260     if (base-&gt;is_DecodeN()) {
1261       base = base-&gt;in(1);
1262     }
1263     if (!base-&gt;in(Address)-&gt;is_AddP()) {
1264       return NULL; // Complex address
1265     }
1266     AddPNode* address = base-&gt;in(Address)-&gt;as_AddP();
1267     Node* cache_base = address-&gt;in(AddPNode::Base);
1268     if ((cache_base != NULL) &amp;&amp; cache_base-&gt;is_DecodeN()) {
1269       // Get ConP node which is static &#39;cache&#39; field.
1270       cache_base = cache_base-&gt;in(1);
1271     }
1272     if ((cache_base != NULL) &amp;&amp; cache_base-&gt;is_Con()) {
1273       const TypeAryPtr* base_type = cache_base-&gt;bottom_type()-&gt;isa_aryptr();
1274       if ((base_type != NULL) &amp;&amp; base_type-&gt;is_autobox_cache()) {
1275         Node* elements[4];
1276         int shift = exact_log2(type2aelembytes(T_OBJECT));
1277         int count = address-&gt;unpack_offsets(elements, ARRAY_SIZE(elements));
1278         if (count &gt; 0 &amp;&amp; elements[0]-&gt;is_Con() &amp;&amp;
1279             (count == 1 ||
1280              (count == 2 &amp;&amp; elements[1]-&gt;Opcode() == Op_LShiftX &amp;&amp;
1281                             elements[1]-&gt;in(2) == phase-&gt;intcon(shift)))) {
1282           ciObjArray* array = base_type-&gt;const_oop()-&gt;as_obj_array();
1283           // Fetch the box object cache[0] at the base of the array and get its value
1284           ciInstance* box = array-&gt;obj_at(0)-&gt;as_instance();
1285           ciInstanceKlass* ik = box-&gt;klass()-&gt;as_instance_klass();
1286           assert(ik-&gt;is_box_klass(), &quot;sanity&quot;);
1287           assert(ik-&gt;nof_nonstatic_fields() == 1, &quot;change following code&quot;);
1288           if (ik-&gt;nof_nonstatic_fields() == 1) {
1289             // This should be true nonstatic_field_at requires calling
1290             // nof_nonstatic_fields so check it anyway
1291             ciConstant c = box-&gt;field_value(ik-&gt;nonstatic_field_at(0));
1292             BasicType bt = c.basic_type();
1293             // Only integer types have boxing cache.
1294             assert(bt == T_BOOLEAN || bt == T_CHAR  ||
1295                    bt == T_BYTE    || bt == T_SHORT ||
1296                    bt == T_INT     || bt == T_LONG, &quot;wrong type = %s&quot;, type2name(bt));
1297             jlong cache_low = (bt == T_LONG) ? c.as_long() : c.as_int();
1298             if (cache_low != (int)cache_low) {
1299               return NULL; // should not happen since cache is array indexed by value
1300             }
1301             jlong offset = arrayOopDesc::base_offset_in_bytes(T_OBJECT) - (cache_low &lt;&lt; shift);
1302             if (offset != (int)offset) {
1303               return NULL; // should not happen since cache is array indexed by value
1304             }
1305            // Add up all the offsets making of the address of the load
1306             Node* result = elements[0];
1307             for (int i = 1; i &lt; count; i++) {
1308               result = phase-&gt;transform(new AddXNode(result, elements[i]));
1309             }
1310             // Remove the constant offset from the address and then
1311             result = phase-&gt;transform(new AddXNode(result, phase-&gt;MakeConX(-(int)offset)));
1312             // remove the scaling of the offset to recover the original index.
1313             if (result-&gt;Opcode() == Op_LShiftX &amp;&amp; result-&gt;in(2) == phase-&gt;intcon(shift)) {
1314               // Peel the shift off directly but wrap it in a dummy node
1315               // since Ideal can&#39;t return existing nodes
1316               result = new RShiftXNode(result-&gt;in(1), phase-&gt;intcon(0));
1317             } else if (result-&gt;is_Add() &amp;&amp; result-&gt;in(2)-&gt;is_Con() &amp;&amp;
1318                        result-&gt;in(1)-&gt;Opcode() == Op_LShiftX &amp;&amp;
1319                        result-&gt;in(1)-&gt;in(2) == phase-&gt;intcon(shift)) {
1320               // We can&#39;t do general optimization: ((X&lt;&lt;Z) + Y) &gt;&gt; Z ==&gt; X + (Y&gt;&gt;Z)
1321               // but for boxing cache access we know that X&lt;&lt;Z will not overflow
1322               // (there is range check) so we do this optimizatrion by hand here.
1323               Node* add_con = new RShiftXNode(result-&gt;in(2), phase-&gt;intcon(shift));
1324               result = new AddXNode(result-&gt;in(1)-&gt;in(1), phase-&gt;transform(add_con));
1325             } else {
1326               result = new RShiftXNode(result, phase-&gt;intcon(shift));
1327             }
1328 #ifdef _LP64
1329             if (bt != T_LONG) {
1330               result = new ConvL2INode(phase-&gt;transform(result));
1331             }
1332 #else
1333             if (bt == T_LONG) {
1334               result = new ConvI2LNode(phase-&gt;transform(result));
1335             }
1336 #endif
1337             // Boxing/unboxing can be done from signed &amp; unsigned loads (e.g. LoadUB -&gt; ... -&gt; LoadB pair).
1338             // Need to preserve unboxing load type if it is unsigned.
1339             switch(this-&gt;Opcode()) {
1340               case Op_LoadUB:
1341                 result = new AndINode(phase-&gt;transform(result), phase-&gt;intcon(0xFF));
1342                 break;
1343               case Op_LoadUS:
1344                 result = new AndINode(phase-&gt;transform(result), phase-&gt;intcon(0xFFFF));
1345                 break;
1346             }
1347             return result;
1348           }
1349         }
1350       }
1351     }
1352   }
1353   return NULL;
1354 }
1355 
1356 static bool stable_phi(PhiNode* phi, PhaseGVN *phase) {
1357   Node* region = phi-&gt;in(0);
1358   if (region == NULL) {
1359     return false; // Wait stable graph
1360   }
1361   uint cnt = phi-&gt;req();
1362   for (uint i = 1; i &lt; cnt; i++) {
1363     Node* rc = region-&gt;in(i);
1364     if (rc == NULL || phase-&gt;type(rc) == Type::TOP)
1365       return false; // Wait stable graph
1366     Node* in = phi-&gt;in(i);
1367     if (in == NULL || phase-&gt;type(in) == Type::TOP)
1368       return false; // Wait stable graph
1369   }
1370   return true;
1371 }
1372 //------------------------------split_through_phi------------------------------
1373 // Split instance or boxed field load through Phi.
1374 Node *LoadNode::split_through_phi(PhaseGVN *phase) {
1375   Node* mem     = in(Memory);
1376   Node* address = in(Address);
1377   const TypeOopPtr *t_oop = phase-&gt;type(address)-&gt;isa_oopptr();
1378 
1379   assert((t_oop != NULL) &amp;&amp;
1380          (t_oop-&gt;is_known_instance_field() ||
1381           t_oop-&gt;is_ptr_to_boxed_value()), &quot;invalide conditions&quot;);
1382 
1383   Compile* C = phase-&gt;C;
1384   intptr_t ignore = 0;
1385   Node*    base = AddPNode::Ideal_base_and_offset(address, phase, ignore);
1386   bool base_is_phi = (base != NULL) &amp;&amp; base-&gt;is_Phi();
1387   bool load_boxed_values = t_oop-&gt;is_ptr_to_boxed_value() &amp;&amp; C-&gt;aggressive_unboxing() &amp;&amp;
1388                            (base != NULL) &amp;&amp; (base == address-&gt;in(AddPNode::Base)) &amp;&amp;
1389                            phase-&gt;type(base)-&gt;higher_equal(TypePtr::NOTNULL);
1390 
1391   if (!((mem-&gt;is_Phi() || base_is_phi) &amp;&amp;
1392         (load_boxed_values || t_oop-&gt;is_known_instance_field()))) {
1393     return NULL; // memory is not Phi
1394   }
1395 
1396   if (mem-&gt;is_Phi()) {
1397     if (!stable_phi(mem-&gt;as_Phi(), phase)) {
1398       return NULL; // Wait stable graph
1399     }
1400     uint cnt = mem-&gt;req();
1401     // Check for loop invariant memory.
1402     if (cnt == 3) {
1403       for (uint i = 1; i &lt; cnt; i++) {
1404         Node* in = mem-&gt;in(i);
1405         Node*  m = optimize_memory_chain(in, t_oop, this, phase);
1406         if (m == mem) {
1407           if (i == 1) {
1408             // if the first edge was a loop, check second edge too.
1409             // If both are replaceable - we are in an infinite loop
1410             Node *n = optimize_memory_chain(mem-&gt;in(2), t_oop, this, phase);
1411             if (n == mem) {
1412               break;
1413             }
1414           }
1415           set_req(Memory, mem-&gt;in(cnt - i));
1416           return this; // made change
1417         }
1418       }
1419     }
1420   }
1421   if (base_is_phi) {
1422     if (!stable_phi(base-&gt;as_Phi(), phase)) {
1423       return NULL; // Wait stable graph
1424     }
1425     uint cnt = base-&gt;req();
1426     // Check for loop invariant memory.
1427     if (cnt == 3) {
1428       for (uint i = 1; i &lt; cnt; i++) {
1429         if (base-&gt;in(i) == base) {
1430           return NULL; // Wait stable graph
1431         }
1432       }
1433     }
1434   }
1435 
1436   // Split through Phi (see original code in loopopts.cpp).
1437   assert(C-&gt;have_alias_type(t_oop), &quot;instance should have alias type&quot;);
1438 
1439   // Do nothing here if Identity will find a value
1440   // (to avoid infinite chain of value phis generation).
1441   if (!phase-&gt;eqv(this, this-&gt;Identity(phase))) {
1442     return NULL;
1443   }
1444 
1445   // Select Region to split through.
1446   Node* region;
1447   if (!base_is_phi) {
1448     assert(mem-&gt;is_Phi(), &quot;sanity&quot;);
1449     region = mem-&gt;in(0);
1450     // Skip if the region dominates some control edge of the address.
1451     if (!MemNode::all_controls_dominate(address, region))
1452       return NULL;
1453   } else if (!mem-&gt;is_Phi()) {
1454     assert(base_is_phi, &quot;sanity&quot;);
1455     region = base-&gt;in(0);
1456     // Skip if the region dominates some control edge of the memory.
1457     if (!MemNode::all_controls_dominate(mem, region))
1458       return NULL;
1459   } else if (base-&gt;in(0) != mem-&gt;in(0)) {
1460     assert(base_is_phi &amp;&amp; mem-&gt;is_Phi(), &quot;sanity&quot;);
1461     if (MemNode::all_controls_dominate(mem, base-&gt;in(0))) {
1462       region = base-&gt;in(0);
1463     } else if (MemNode::all_controls_dominate(address, mem-&gt;in(0))) {
1464       region = mem-&gt;in(0);
1465     } else {
1466       return NULL; // complex graph
1467     }
1468   } else {
1469     assert(base-&gt;in(0) == mem-&gt;in(0), &quot;sanity&quot;);
1470     region = mem-&gt;in(0);
1471   }
1472 
1473   const Type* this_type = this-&gt;bottom_type();
1474   int this_index  = C-&gt;get_alias_index(t_oop);
1475   int this_offset = t_oop-&gt;offset();
1476   int this_iid    = t_oop-&gt;instance_id();
1477   if (!t_oop-&gt;is_known_instance() &amp;&amp; load_boxed_values) {
1478     // Use _idx of address base for boxed values.
1479     this_iid = base-&gt;_idx;
1480   }
1481   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1482   Node* phi = new PhiNode(region, this_type, NULL, mem-&gt;_idx, this_iid, this_index, this_offset);
1483   for (uint i = 1; i &lt; region-&gt;req(); i++) {
1484     Node* x;
1485     Node* the_clone = NULL;
1486     if (region-&gt;in(i) == C-&gt;top()) {
1487       x = C-&gt;top();      // Dead path?  Use a dead data op
1488     } else {
1489       x = this-&gt;clone();        // Else clone up the data op
1490       the_clone = x;            // Remember for possible deletion.
1491       // Alter data node to use pre-phi inputs
1492       if (this-&gt;in(0) == region) {
1493         x-&gt;set_req(0, region-&gt;in(i));
1494       } else {
1495         x-&gt;set_req(0, NULL);
1496       }
1497       if (mem-&gt;is_Phi() &amp;&amp; (mem-&gt;in(0) == region)) {
1498         x-&gt;set_req(Memory, mem-&gt;in(i)); // Use pre-Phi input for the clone.
1499       }
1500       if (address-&gt;is_Phi() &amp;&amp; address-&gt;in(0) == region) {
1501         x-&gt;set_req(Address, address-&gt;in(i)); // Use pre-Phi input for the clone
1502       }
1503       if (base_is_phi &amp;&amp; (base-&gt;in(0) == region)) {
1504         Node* base_x = base-&gt;in(i); // Clone address for loads from boxed objects.
1505         Node* adr_x = phase-&gt;transform(new AddPNode(base_x,base_x,address-&gt;in(AddPNode::Offset)));
1506         x-&gt;set_req(Address, adr_x);
1507       }
1508     }
1509     // Check for a &#39;win&#39; on some paths
1510     const Type *t = x-&gt;Value(igvn);
1511 
1512     bool singleton = t-&gt;singleton();
1513 
1514     // See comments in PhaseIdealLoop::split_thru_phi().
1515     if (singleton &amp;&amp; t == Type::TOP) {
1516       singleton &amp;= region-&gt;is_Loop() &amp;&amp; (i != LoopNode::EntryControl);
1517     }
1518 
1519     if (singleton) {
1520       x = igvn-&gt;makecon(t);
1521     } else {
1522       // We now call Identity to try to simplify the cloned node.
1523       // Note that some Identity methods call phase-&gt;type(this).
1524       // Make sure that the type array is big enough for
1525       // our new node, even though we may throw the node away.
1526       // (This tweaking with igvn only works because x is a new node.)
1527       igvn-&gt;set_type(x, t);
1528       // If x is a TypeNode, capture any more-precise type permanently into Node
1529       // otherwise it will be not updated during igvn-&gt;transform since
1530       // igvn-&gt;type(x) is set to x-&gt;Value() already.
1531       x-&gt;raise_bottom_type(t);
1532       Node* y = x-&gt;Identity(igvn);
1533       if (y != x) {
1534         x = y;
1535       } else {
1536         y = igvn-&gt;hash_find_insert(x);
1537         if (y) {
1538           x = y;
1539         } else {
1540           // Else x is a new node we are keeping
1541           // We do not need register_new_node_with_optimizer
1542           // because set_type has already been called.
1543           igvn-&gt;_worklist.push(x);
1544         }
1545       }
1546     }
1547     if (x != the_clone &amp;&amp; the_clone != NULL) {
1548       igvn-&gt;remove_dead_node(the_clone);
1549     }
1550     phi-&gt;set_req(i, x);
1551   }
1552   // Record Phi
1553   igvn-&gt;register_new_node_with_optimizer(phi);
1554   return phi;
1555 }
1556 
1557 AllocateNode* LoadNode::is_new_object_mark_load(PhaseGVN *phase) const {
1558   if (Opcode() == Op_LoadX) {
1559     Node* address = in(MemNode::Address);
1560     AllocateNode* alloc = AllocateNode::Ideal_allocation(address, phase);
1561     Node* mem = in(MemNode::Memory);
1562     if (alloc != NULL &amp;&amp; mem-&gt;is_Proj() &amp;&amp;
1563         mem-&gt;in(0) != NULL &amp;&amp;
1564         mem-&gt;in(0) == alloc-&gt;initialization() &amp;&amp;
1565         alloc-&gt;initialization()-&gt;proj_out_or_null(0) != NULL) {
1566       return alloc;
1567     }
1568   }
1569   return NULL;
1570 }
1571 
1572 
1573 //------------------------------Ideal------------------------------------------
1574 // If the load is from Field memory and the pointer is non-null, it might be possible to
1575 // zero out the control input.
1576 // If the offset is constant and the base is an object allocation,
1577 // try to hook me up to the exact initializing store.
1578 Node *LoadNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1579   Node* p = MemNode::Ideal_common(phase, can_reshape);
1580   if (p)  return (p == NodeSentinel) ? NULL : p;
1581 
1582   Node* ctrl    = in(MemNode::Control);
1583   Node* address = in(MemNode::Address);
1584   bool progress = false;
1585 
1586   bool addr_mark = ((phase-&gt;type(address)-&gt;isa_oopptr() || phase-&gt;type(address)-&gt;isa_narrowoop()) &amp;&amp;
1587          phase-&gt;type(address)-&gt;is_ptr()-&gt;offset() == oopDesc::mark_offset_in_bytes());
1588 
1589   // Skip up past a SafePoint control.  Cannot do this for Stores because
1590   // pointer stores &amp; cardmarks must stay on the same side of a SafePoint.
1591   if( ctrl != NULL &amp;&amp; ctrl-&gt;Opcode() == Op_SafePoint &amp;&amp;
1592       phase-&gt;C-&gt;get_alias_index(phase-&gt;type(address)-&gt;is_ptr()) != Compile::AliasIdxRaw  &amp;&amp;
1593       !addr_mark &amp;&amp;
1594       (depends_only_on_test() || has_unknown_control_dependency())) {
1595     ctrl = ctrl-&gt;in(0);
1596     set_req(MemNode::Control,ctrl);
1597     progress = true;
1598   }
1599 
1600   intptr_t ignore = 0;
1601   Node*    base   = AddPNode::Ideal_base_and_offset(address, phase, ignore);
1602   if (base != NULL
1603       &amp;&amp; phase-&gt;C-&gt;get_alias_index(phase-&gt;type(address)-&gt;is_ptr()) != Compile::AliasIdxRaw) {
1604     // Check for useless control edge in some common special cases
1605     if (in(MemNode::Control) != NULL
1606         &amp;&amp; can_remove_control()
1607         &amp;&amp; phase-&gt;type(base)-&gt;higher_equal(TypePtr::NOTNULL)
1608         &amp;&amp; all_controls_dominate(base, phase-&gt;C-&gt;start())) {
1609       // A method-invariant, non-null address (constant or &#39;this&#39; argument).
1610       set_req(MemNode::Control, NULL);
1611       progress = true;
1612     }
1613   }
1614 
1615   Node* mem = in(MemNode::Memory);
1616   const TypePtr *addr_t = phase-&gt;type(address)-&gt;isa_ptr();
1617 
1618   if (can_reshape &amp;&amp; (addr_t != NULL)) {
1619     // try to optimize our memory input
1620     Node* opt_mem = MemNode::optimize_memory_chain(mem, addr_t, this, phase);
1621     if (opt_mem != mem) {
1622       set_req(MemNode::Memory, opt_mem);
1623       if (phase-&gt;type( opt_mem ) == Type::TOP) return NULL;
1624       return this;
1625     }
1626     const TypeOopPtr *t_oop = addr_t-&gt;isa_oopptr();
1627     if ((t_oop != NULL) &amp;&amp;
1628         (t_oop-&gt;is_known_instance_field() ||
1629          t_oop-&gt;is_ptr_to_boxed_value())) {
1630       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1631       if (igvn != NULL &amp;&amp; igvn-&gt;_worklist.member(opt_mem)) {
1632         // Delay this transformation until memory Phi is processed.
1633         phase-&gt;is_IterGVN()-&gt;_worklist.push(this);
1634         return NULL;
1635       }
1636       // Split instance field load through Phi.
1637       Node* result = split_through_phi(phase);
1638       if (result != NULL) return result;
1639 
1640       if (t_oop-&gt;is_ptr_to_boxed_value()) {
1641         Node* result = eliminate_autobox(phase);
1642         if (result != NULL) return result;
1643       }
1644     }
1645   }
1646 
1647   // Is there a dominating load that loads the same value?  Leave
1648   // anything that is not a load of a field/array element (like
1649   // barriers etc.) alone
1650   if (in(0) != NULL &amp;&amp; !adr_type()-&gt;isa_rawptr() &amp;&amp; can_reshape) {
1651     for (DUIterator_Fast imax, i = mem-&gt;fast_outs(imax); i &lt; imax; i++) {
1652       Node *use = mem-&gt;fast_out(i);
1653       if (use != this &amp;&amp;
1654           use-&gt;Opcode() == Opcode() &amp;&amp;
1655           use-&gt;in(0) != NULL &amp;&amp;
1656           use-&gt;in(0) != in(0) &amp;&amp;
1657           use-&gt;in(Address) == in(Address)) {
1658         Node* ctl = in(0);
1659         for (int i = 0; i &lt; 10 &amp;&amp; ctl != NULL; i++) {
1660           ctl = IfNode::up_one_dom(ctl);
1661           if (ctl == use-&gt;in(0)) {
1662             set_req(0, use-&gt;in(0));
1663             return this;
1664           }
1665         }
1666       }
1667     }
1668   }
1669 
1670   // Check for prior store with a different base or offset; make Load
1671   // independent.  Skip through any number of them.  Bail out if the stores
1672   // are in an endless dead cycle and report no progress.  This is a key
1673   // transform for Reflection.  However, if after skipping through the Stores
1674   // we can&#39;t then fold up against a prior store do NOT do the transform as
1675   // this amounts to using the &#39;Oracle&#39; model of aliasing.  It leaves the same
1676   // array memory alive twice: once for the hoisted Load and again after the
1677   // bypassed Store.  This situation only works if EVERYBODY who does
1678   // anti-dependence work knows how to bypass.  I.e. we need all
1679   // anti-dependence checks to ask the same Oracle.  Right now, that Oracle is
1680   // the alias index stuff.  So instead, peek through Stores and IFF we can
1681   // fold up, do so.
1682   Node* prev_mem = find_previous_store(phase);
1683   if (prev_mem != NULL) {
1684     Node* value = can_see_arraycopy_value(prev_mem, phase);
1685     if (value != NULL) {
1686       return value;
1687     }
1688   }
1689   // Steps (a), (b):  Walk past independent stores to find an exact match.
1690   if (prev_mem != NULL &amp;&amp; prev_mem != in(MemNode::Memory)) {
1691     // (c) See if we can fold up on the spot, but don&#39;t fold up here.
1692     // Fold-up might require truncation (for LoadB/LoadS/LoadUS) or
1693     // just return a prior value, which is done by Identity calls.
1694     if (can_see_stored_value(prev_mem, phase)) {
1695       // Make ready for step (d):
1696       set_req(MemNode::Memory, prev_mem);
1697       return this;
1698     }
1699   }
1700 
1701   AllocateNode* alloc = is_new_object_mark_load(phase);
1702   if (alloc != NULL &amp;&amp; alloc-&gt;Opcode() == Op_Allocate &amp;&amp; UseBiasedLocking) {
1703     InitializeNode* init = alloc-&gt;initialization();
1704     Node* control = init-&gt;proj_out(0);
1705     return alloc-&gt;make_ideal_mark(phase, address, control, mem);
1706   }
1707 
1708   return progress ? this : NULL;
1709 }
1710 
1711 // Helper to recognize certain Klass fields which are invariant across
1712 // some group of array types (e.g., int[] or all T[] where T &lt; Object).
1713 const Type*
1714 LoadNode::load_array_final_field(const TypeKlassPtr *tkls,
1715                                  ciKlass* klass) const {
1716   if (tkls-&gt;offset() == in_bytes(Klass::modifier_flags_offset())) {
1717     // The field is Klass::_modifier_flags.  Return its (constant) value.
1718     // (Folds up the 2nd indirection in aClassConstant.getModifiers().)
1719     assert(this-&gt;Opcode() == Op_LoadI, &quot;must load an int from _modifier_flags&quot;);
1720     return TypeInt::make(klass-&gt;modifier_flags());
1721   }
1722   if (tkls-&gt;offset() == in_bytes(Klass::access_flags_offset())) {
1723     // The field is Klass::_access_flags.  Return its (constant) value.
1724     // (Folds up the 2nd indirection in Reflection.getClassAccessFlags(aClassConstant).)
1725     assert(this-&gt;Opcode() == Op_LoadI, &quot;must load an int from _access_flags&quot;);
1726     return TypeInt::make(klass-&gt;access_flags());
1727   }
1728   if (tkls-&gt;offset() == in_bytes(Klass::layout_helper_offset())) {
1729     // The field is Klass::_layout_helper.  Return its constant value if known.
1730     assert(this-&gt;Opcode() == Op_LoadI, &quot;must load an int from _layout_helper&quot;);
1731     return TypeInt::make(klass-&gt;layout_helper());
1732   }
1733 
1734   // No match.
1735   return NULL;
1736 }
1737 
1738 //------------------------------Value-----------------------------------------
1739 const Type* LoadNode::Value(PhaseGVN* phase) const {
1740   // Either input is TOP ==&gt; the result is TOP
1741   Node* mem = in(MemNode::Memory);
1742   const Type *t1 = phase-&gt;type(mem);
1743   if (t1 == Type::TOP)  return Type::TOP;
1744   Node* adr = in(MemNode::Address);
1745   const TypePtr* tp = phase-&gt;type(adr)-&gt;isa_ptr();
1746   if (tp == NULL || tp-&gt;empty())  return Type::TOP;
1747   int off = tp-&gt;offset();
1748   assert(off != Type::OffsetTop, &quot;case covered by TypePtr::empty&quot;);
1749   Compile* C = phase-&gt;C;
1750 
1751   // Try to guess loaded type from pointer type
1752   if (tp-&gt;isa_aryptr()) {
1753     const TypeAryPtr* ary = tp-&gt;is_aryptr();
1754     const Type* t = ary-&gt;elem();
1755 
1756     // Determine whether the reference is beyond the header or not, by comparing
1757     // the offset against the offset of the start of the array&#39;s data.
1758     // Different array types begin at slightly different offsets (12 vs. 16).
1759     // We choose T_BYTE as an example base type that is least restrictive
1760     // as to alignment, which will therefore produce the smallest
1761     // possible base offset.
1762     const int min_base_off = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1763     const bool off_beyond_header = (off &gt;= min_base_off);
1764 
1765     // Try to constant-fold a stable array element.
1766     if (FoldStableValues &amp;&amp; !is_mismatched_access() &amp;&amp; ary-&gt;is_stable()) {
1767       // Make sure the reference is not into the header and the offset is constant
1768       ciObject* aobj = ary-&gt;const_oop();
1769       if (aobj != NULL &amp;&amp; off_beyond_header &amp;&amp; adr-&gt;is_AddP() &amp;&amp; off != Type::OffsetBot) {
1770         int stable_dimension = (ary-&gt;stable_dimension() &gt; 0 ? ary-&gt;stable_dimension() - 1 : 0);
1771         const Type* con_type = Type::make_constant_from_array_element(aobj-&gt;as_array(), off,
1772                                                                       stable_dimension,
1773                                                                       memory_type(), is_unsigned());
1774         if (con_type != NULL) {
1775           return con_type;
1776         }
1777       }
1778     }
1779 
1780     // Don&#39;t do this for integer types. There is only potential profit if
1781     // the element type t is lower than _type; that is, for int types, if _type is
1782     // more restrictive than t.  This only happens here if one is short and the other
1783     // char (both 16 bits), and in those cases we&#39;ve made an intentional decision
1784     // to use one kind of load over the other. See AndINode::Ideal and 4965907.
1785     // Also, do not try to narrow the type for a LoadKlass, regardless of offset.
1786     //
1787     // Yes, it is possible to encounter an expression like (LoadKlass p1:(AddP x x 8))
1788     // where the _gvn.type of the AddP is wider than 8.  This occurs when an earlier
1789     // copy p0 of (AddP x x 8) has been proven equal to p1, and the p0 has been
1790     // subsumed by p1.  If p1 is on the worklist but has not yet been re-transformed,
1791     // it is possible that p1 will have a type like Foo*[int+]:NotNull*+any.
1792     // In fact, that could have been the original type of p1, and p1 could have
1793     // had an original form like p1:(AddP x x (LShiftL quux 3)), where the
1794     // expression (LShiftL quux 3) independently optimized to the constant 8.
1795     if ((t-&gt;isa_int() == NULL) &amp;&amp; (t-&gt;isa_long() == NULL)
1796         &amp;&amp; (_type-&gt;isa_vect() == NULL)
1797         &amp;&amp; Opcode() != Op_LoadKlass &amp;&amp; Opcode() != Op_LoadNKlass) {
1798       // t might actually be lower than _type, if _type is a unique
1799       // concrete subclass of abstract class t.
1800       if (off_beyond_header || off == Type::OffsetBot) {  // is the offset beyond the header?
1801         const Type* jt = t-&gt;join_speculative(_type);
1802         // In any case, do not allow the join, per se, to empty out the type.
1803         if (jt-&gt;empty() &amp;&amp; !t-&gt;empty()) {
1804           // This can happen if a interface-typed array narrows to a class type.
1805           jt = _type;
1806         }
1807 #ifdef ASSERT
1808         if (phase-&gt;C-&gt;eliminate_boxing() &amp;&amp; adr-&gt;is_AddP()) {
1809           // The pointers in the autobox arrays are always non-null
1810           Node* base = adr-&gt;in(AddPNode::Base);
1811           if ((base != NULL) &amp;&amp; base-&gt;is_DecodeN()) {
1812             // Get LoadN node which loads IntegerCache.cache field
1813             base = base-&gt;in(1);
1814           }
1815           if ((base != NULL) &amp;&amp; base-&gt;is_Con()) {
1816             const TypeAryPtr* base_type = base-&gt;bottom_type()-&gt;isa_aryptr();
1817             if ((base_type != NULL) &amp;&amp; base_type-&gt;is_autobox_cache()) {
1818               // It could be narrow oop
1819               assert(jt-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull,&quot;sanity&quot;);
1820             }
1821           }
1822         }
1823 #endif
1824         return jt;
1825       }
1826     }
1827   } else if (tp-&gt;base() == Type::InstPtr) {
1828     assert( off != Type::OffsetBot ||
1829             // arrays can be cast to Objects
1830             tp-&gt;is_oopptr()-&gt;klass()-&gt;is_java_lang_Object() ||
1831             // unsafe field access may not have a constant offset
1832             C-&gt;has_unsafe_access(),
1833             &quot;Field accesses must be precise&quot; );
1834     // For oop loads, we expect the _type to be precise.
1835 
1836     // Optimize loads from constant fields.
1837     const TypeInstPtr* tinst = tp-&gt;is_instptr();
1838     ciObject* const_oop = tinst-&gt;const_oop();
1839     if (!is_mismatched_access() &amp;&amp; off != Type::OffsetBot &amp;&amp; const_oop != NULL &amp;&amp; const_oop-&gt;is_instance()) {
1840       const Type* con_type = Type::make_constant_from_field(const_oop-&gt;as_instance(), off, is_unsigned(), memory_type());
1841       if (con_type != NULL) {
1842         return con_type;
1843       }
1844     }
1845   } else if (tp-&gt;base() == Type::KlassPtr) {
1846     assert( off != Type::OffsetBot ||
1847             // arrays can be cast to Objects
1848             tp-&gt;is_klassptr()-&gt;klass()-&gt;is_java_lang_Object() ||
1849             // also allow array-loading from the primary supertype
1850             // array during subtype checks
1851             Opcode() == Op_LoadKlass,
1852             &quot;Field accesses must be precise&quot; );
1853     // For klass/static loads, we expect the _type to be precise
1854   } else if (tp-&gt;base() == Type::RawPtr &amp;&amp; adr-&gt;is_Load() &amp;&amp; off == 0) {
1855     /* With mirrors being an indirect in the Klass*
1856      * the VM is now using two loads. LoadKlass(LoadP(LoadP(Klass, mirror_offset), zero_offset))
1857      * The LoadP from the Klass has a RawPtr type (see LibraryCallKit::load_mirror_from_klass).
1858      *
1859      * So check the type and klass of the node before the LoadP.
1860      */
1861     Node* adr2 = adr-&gt;in(MemNode::Address);
1862     const TypeKlassPtr* tkls = phase-&gt;type(adr2)-&gt;isa_klassptr();
1863     if (tkls != NULL &amp;&amp; !StressReflectiveCode) {
1864       ciKlass* klass = tkls-&gt;klass();
1865       if (klass-&gt;is_loaded() &amp;&amp; tkls-&gt;klass_is_exact() &amp;&amp; tkls-&gt;offset() == in_bytes(Klass::java_mirror_offset())) {
1866         assert(adr-&gt;Opcode() == Op_LoadP, &quot;must load an oop from _java_mirror&quot;);
1867         assert(Opcode() == Op_LoadP, &quot;must load an oop from _java_mirror&quot;);
1868         return TypeInstPtr::make(klass-&gt;java_mirror());
1869       }
1870     }
1871   }
1872 
1873   const TypeKlassPtr *tkls = tp-&gt;isa_klassptr();
1874   if (tkls != NULL &amp;&amp; !StressReflectiveCode) {
1875     ciKlass* klass = tkls-&gt;klass();
1876     if (klass-&gt;is_loaded() &amp;&amp; tkls-&gt;klass_is_exact()) {
1877       // We are loading a field from a Klass metaobject whose identity
1878       // is known at compile time (the type is &quot;exact&quot; or &quot;precise&quot;).
1879       // Check for fields we know are maintained as constants by the VM.
1880       if (tkls-&gt;offset() == in_bytes(Klass::super_check_offset_offset())) {
1881         // The field is Klass::_super_check_offset.  Return its (constant) value.
1882         // (Folds up type checking code.)
1883         assert(Opcode() == Op_LoadI, &quot;must load an int from _super_check_offset&quot;);
1884         return TypeInt::make(klass-&gt;super_check_offset());
1885       }
1886       // Compute index into primary_supers array
1887       juint depth = (tkls-&gt;offset() - in_bytes(Klass::primary_supers_offset())) / sizeof(Klass*);
1888       // Check for overflowing; use unsigned compare to handle the negative case.
1889       if( depth &lt; ciKlass::primary_super_limit() ) {
1890         // The field is an element of Klass::_primary_supers.  Return its (constant) value.
1891         // (Folds up type checking code.)
1892         assert(Opcode() == Op_LoadKlass, &quot;must load a klass from _primary_supers&quot;);
1893         ciKlass *ss = klass-&gt;super_of_depth(depth);
1894         return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;
1895       }
1896       const Type* aift = load_array_final_field(tkls, klass);
1897       if (aift != NULL)  return aift;
1898     }
1899 
1900     // We can still check if we are loading from the primary_supers array at a
1901     // shallow enough depth.  Even though the klass is not exact, entries less
1902     // than or equal to its super depth are correct.
1903     if (klass-&gt;is_loaded() ) {
1904       ciType *inner = klass;
1905       while( inner-&gt;is_obj_array_klass() )
1906         inner = inner-&gt;as_obj_array_klass()-&gt;base_element_type();
1907       if( inner-&gt;is_instance_klass() &amp;&amp;
1908           !inner-&gt;as_instance_klass()-&gt;flags().is_interface() ) {
1909         // Compute index into primary_supers array
1910         juint depth = (tkls-&gt;offset() - in_bytes(Klass::primary_supers_offset())) / sizeof(Klass*);
1911         // Check for overflowing; use unsigned compare to handle the negative case.
1912         if( depth &lt; ciKlass::primary_super_limit() &amp;&amp;
1913             depth &lt;= klass-&gt;super_depth() ) { // allow self-depth checks to handle self-check case
1914           // The field is an element of Klass::_primary_supers.  Return its (constant) value.
1915           // (Folds up type checking code.)
1916           assert(Opcode() == Op_LoadKlass, &quot;must load a klass from _primary_supers&quot;);
1917           ciKlass *ss = klass-&gt;super_of_depth(depth);
1918           return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;
1919         }
1920       }
1921     }
1922 
1923     // If the type is enough to determine that the thing is not an array,
1924     // we can give the layout_helper a positive interval type.
1925     // This will help short-circuit some reflective code.
1926     if (tkls-&gt;offset() == in_bytes(Klass::layout_helper_offset())
1927         &amp;&amp; !klass-&gt;is_array_klass() // not directly typed as an array
1928         &amp;&amp; !klass-&gt;is_interface()  // specifically not Serializable &amp; Cloneable
1929         &amp;&amp; !klass-&gt;is_java_lang_Object()   // not the supertype of all T[]
1930         ) {
1931       // Note:  When interfaces are reliable, we can narrow the interface
1932       // test to (klass != Serializable &amp;&amp; klass != Cloneable).
1933       assert(Opcode() == Op_LoadI, &quot;must load an int from _layout_helper&quot;);
1934       jint min_size = Klass::instance_layout_helper(oopDesc::header_size(), false);
1935       // The key property of this type is that it folds up tests
1936       // for array-ness, since it proves that the layout_helper is positive.
1937       // Thus, a generic value like the basic object layout helper works fine.
1938       return TypeInt::make(min_size, max_jint, Type::WidenMin);
1939     }
1940   }
1941 
1942   // If we are loading from a freshly-allocated object, produce a zero,
1943   // if the load is provably beyond the header of the object.
1944   // (Also allow a variable load from a fresh array to produce zero.)
1945   const TypeOopPtr *tinst = tp-&gt;isa_oopptr();
1946   bool is_instance = (tinst != NULL) &amp;&amp; tinst-&gt;is_known_instance_field();
1947   bool is_boxed_value = (tinst != NULL) &amp;&amp; tinst-&gt;is_ptr_to_boxed_value();
1948   if (ReduceFieldZeroing || is_instance || is_boxed_value) {
1949     Node* value = can_see_stored_value(mem,phase);
1950     if (value != NULL &amp;&amp; value-&gt;is_Con()) {
1951       assert(value-&gt;bottom_type()-&gt;higher_equal(_type),&quot;sanity&quot;);
1952       return value-&gt;bottom_type();
1953     }
1954   }
1955 
1956   if (is_instance) {
1957     // If we have an instance type and our memory input is the
1958     // programs&#39;s initial memory state, there is no matching store,
1959     // so just return a zero of the appropriate type
1960     Node *mem = in(MemNode::Memory);
1961     if (mem-&gt;is_Parm() &amp;&amp; mem-&gt;in(0)-&gt;is_Start()) {
1962       assert(mem-&gt;as_Parm()-&gt;_con == TypeFunc::Memory, &quot;must be memory Parm&quot;);
1963       return Type::get_zero_type(_type-&gt;basic_type());
1964     }
1965   }
1966 
1967   Node* alloc = is_new_object_mark_load(phase);
1968   if (alloc != NULL &amp;&amp; !(alloc-&gt;Opcode() == Op_Allocate &amp;&amp; UseBiasedLocking)) {
1969     return TypeX::make(markWord::prototype().value());
1970   }
1971 
1972   return _type;
1973 }
1974 
1975 //------------------------------match_edge-------------------------------------
1976 // Do we Match on this edge index or not?  Match only the address.
1977 uint LoadNode::match_edge(uint idx) const {
1978   return idx == MemNode::Address;
1979 }
1980 
1981 //--------------------------LoadBNode::Ideal--------------------------------------
1982 //
1983 //  If the previous store is to the same address as this load,
1984 //  and the value stored was larger than a byte, replace this load
1985 //  with the value stored truncated to a byte.  If no truncation is
1986 //  needed, the replacement is done in LoadNode::Identity().
1987 //
1988 Node *LoadBNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1989   Node* mem = in(MemNode::Memory);
1990   Node* value = can_see_stored_value(mem,phase);
1991   if( value &amp;&amp; !phase-&gt;type(value)-&gt;higher_equal( _type ) ) {
1992     Node *result = phase-&gt;transform( new LShiftINode(value, phase-&gt;intcon(24)) );
1993     return new RShiftINode(result, phase-&gt;intcon(24));
1994   }
1995   // Identity call will handle the case where truncation is not needed.
1996   return LoadNode::Ideal(phase, can_reshape);
1997 }
1998 
1999 const Type* LoadBNode::Value(PhaseGVN* phase) const {
2000   Node* mem = in(MemNode::Memory);
2001   Node* value = can_see_stored_value(mem,phase);
2002   if (value != NULL &amp;&amp; value-&gt;is_Con() &amp;&amp;
2003       !value-&gt;bottom_type()-&gt;higher_equal(_type)) {
2004     // If the input to the store does not fit with the load&#39;s result type,
2005     // it must be truncated. We can&#39;t delay until Ideal call since
2006     // a singleton Value is needed for split_thru_phi optimization.
2007     int con = value-&gt;get_int();
2008     return TypeInt::make((con &lt;&lt; 24) &gt;&gt; 24);
2009   }
2010   return LoadNode::Value(phase);
2011 }
2012 
2013 //--------------------------LoadUBNode::Ideal-------------------------------------
2014 //
2015 //  If the previous store is to the same address as this load,
2016 //  and the value stored was larger than a byte, replace this load
2017 //  with the value stored truncated to a byte.  If no truncation is
2018 //  needed, the replacement is done in LoadNode::Identity().
2019 //
2020 Node* LoadUBNode::Ideal(PhaseGVN* phase, bool can_reshape) {
2021   Node* mem = in(MemNode::Memory);
2022   Node* value = can_see_stored_value(mem, phase);
2023   if (value &amp;&amp; !phase-&gt;type(value)-&gt;higher_equal(_type))
2024     return new AndINode(value, phase-&gt;intcon(0xFF));
2025   // Identity call will handle the case where truncation is not needed.
2026   return LoadNode::Ideal(phase, can_reshape);
2027 }
2028 
2029 const Type* LoadUBNode::Value(PhaseGVN* phase) const {
2030   Node* mem = in(MemNode::Memory);
2031   Node* value = can_see_stored_value(mem,phase);
2032   if (value != NULL &amp;&amp; value-&gt;is_Con() &amp;&amp;
2033       !value-&gt;bottom_type()-&gt;higher_equal(_type)) {
2034     // If the input to the store does not fit with the load&#39;s result type,
2035     // it must be truncated. We can&#39;t delay until Ideal call since
2036     // a singleton Value is needed for split_thru_phi optimization.
2037     int con = value-&gt;get_int();
2038     return TypeInt::make(con &amp; 0xFF);
2039   }
2040   return LoadNode::Value(phase);
2041 }
2042 
2043 //--------------------------LoadUSNode::Ideal-------------------------------------
2044 //
2045 //  If the previous store is to the same address as this load,
2046 //  and the value stored was larger than a char, replace this load
2047 //  with the value stored truncated to a char.  If no truncation is
2048 //  needed, the replacement is done in LoadNode::Identity().
2049 //
2050 Node *LoadUSNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2051   Node* mem = in(MemNode::Memory);
2052   Node* value = can_see_stored_value(mem,phase);
2053   if( value &amp;&amp; !phase-&gt;type(value)-&gt;higher_equal( _type ) )
2054     return new AndINode(value,phase-&gt;intcon(0xFFFF));
2055   // Identity call will handle the case where truncation is not needed.
2056   return LoadNode::Ideal(phase, can_reshape);
2057 }
2058 
2059 const Type* LoadUSNode::Value(PhaseGVN* phase) const {
2060   Node* mem = in(MemNode::Memory);
2061   Node* value = can_see_stored_value(mem,phase);
2062   if (value != NULL &amp;&amp; value-&gt;is_Con() &amp;&amp;
2063       !value-&gt;bottom_type()-&gt;higher_equal(_type)) {
2064     // If the input to the store does not fit with the load&#39;s result type,
2065     // it must be truncated. We can&#39;t delay until Ideal call since
2066     // a singleton Value is needed for split_thru_phi optimization.
2067     int con = value-&gt;get_int();
2068     return TypeInt::make(con &amp; 0xFFFF);
2069   }
2070   return LoadNode::Value(phase);
2071 }
2072 
2073 //--------------------------LoadSNode::Ideal--------------------------------------
2074 //
2075 //  If the previous store is to the same address as this load,
2076 //  and the value stored was larger than a short, replace this load
2077 //  with the value stored truncated to a short.  If no truncation is
2078 //  needed, the replacement is done in LoadNode::Identity().
2079 //
2080 Node *LoadSNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2081   Node* mem = in(MemNode::Memory);
2082   Node* value = can_see_stored_value(mem,phase);
2083   if( value &amp;&amp; !phase-&gt;type(value)-&gt;higher_equal( _type ) ) {
2084     Node *result = phase-&gt;transform( new LShiftINode(value, phase-&gt;intcon(16)) );
2085     return new RShiftINode(result, phase-&gt;intcon(16));
2086   }
2087   // Identity call will handle the case where truncation is not needed.
2088   return LoadNode::Ideal(phase, can_reshape);
2089 }
2090 
2091 const Type* LoadSNode::Value(PhaseGVN* phase) const {
2092   Node* mem = in(MemNode::Memory);
2093   Node* value = can_see_stored_value(mem,phase);
2094   if (value != NULL &amp;&amp; value-&gt;is_Con() &amp;&amp;
2095       !value-&gt;bottom_type()-&gt;higher_equal(_type)) {
2096     // If the input to the store does not fit with the load&#39;s result type,
2097     // it must be truncated. We can&#39;t delay until Ideal call since
2098     // a singleton Value is needed for split_thru_phi optimization.
2099     int con = value-&gt;get_int();
2100     return TypeInt::make((con &lt;&lt; 16) &gt;&gt; 16);
2101   }
2102   return LoadNode::Value(phase);
2103 }
2104 
2105 //=============================================================================
2106 //----------------------------LoadKlassNode::make------------------------------
2107 // Polymorphic factory method:
2108 Node* LoadKlassNode::make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {
2109   // sanity check the alias category against the created node type
2110   const TypePtr *adr_type = adr-&gt;bottom_type()-&gt;isa_ptr();
2111   assert(adr_type != NULL, &quot;expecting TypeKlassPtr&quot;);
2112 #ifdef _LP64
2113   if (adr_type-&gt;is_ptr_to_narrowklass()) {
2114     assert(UseCompressedClassPointers, &quot;no compressed klasses&quot;);
2115     Node* load_klass = gvn.transform(new LoadNKlassNode(ctl, mem, adr, at, tk-&gt;make_narrowklass(), MemNode::unordered));
2116     return new DecodeNKlassNode(load_klass, load_klass-&gt;bottom_type()-&gt;make_ptr());
2117   }
2118 #endif
2119   assert(!adr_type-&gt;is_ptr_to_narrowklass() &amp;&amp; !adr_type-&gt;is_ptr_to_narrowoop(), &quot;should have got back a narrow oop&quot;);
2120   return new LoadKlassNode(ctl, mem, adr, at, tk, MemNode::unordered);
2121 }
2122 
2123 //------------------------------Value------------------------------------------
2124 const Type* LoadKlassNode::Value(PhaseGVN* phase) const {
2125   return klass_value_common(phase);
2126 }
2127 
2128 // In most cases, LoadKlassNode does not have the control input set. If the control
2129 // input is set, it must not be removed (by LoadNode::Ideal()).
2130 bool LoadKlassNode::can_remove_control() const {
2131   return false;
2132 }
2133 
2134 const Type* LoadNode::klass_value_common(PhaseGVN* phase) const {
2135   // Either input is TOP ==&gt; the result is TOP
2136   const Type *t1 = phase-&gt;type( in(MemNode::Memory) );
2137   if (t1 == Type::TOP)  return Type::TOP;
2138   Node *adr = in(MemNode::Address);
2139   const Type *t2 = phase-&gt;type( adr );
2140   if (t2 == Type::TOP)  return Type::TOP;
2141   const TypePtr *tp = t2-&gt;is_ptr();
2142   if (TypePtr::above_centerline(tp-&gt;ptr()) ||
2143       tp-&gt;ptr() == TypePtr::Null)  return Type::TOP;
2144 
2145   // Return a more precise klass, if possible
2146   const TypeInstPtr *tinst = tp-&gt;isa_instptr();
2147   if (tinst != NULL) {
2148     ciInstanceKlass* ik = tinst-&gt;klass()-&gt;as_instance_klass();
2149     int offset = tinst-&gt;offset();
2150     if (ik == phase-&gt;C-&gt;env()-&gt;Class_klass()
2151         &amp;&amp; (offset == java_lang_Class::klass_offset_in_bytes() ||
2152             offset == java_lang_Class::array_klass_offset_in_bytes())) {
2153       // We are loading a special hidden field from a Class mirror object,
2154       // the field which points to the VM&#39;s Klass metaobject.
2155       ciType* t = tinst-&gt;java_mirror_type();
2156       // java_mirror_type returns non-null for compile-time Class constants.
2157       if (t != NULL) {
2158         // constant oop =&gt; constant klass
2159         if (offset == java_lang_Class::array_klass_offset_in_bytes()) {
2160           if (t-&gt;is_void()) {
2161             // We cannot create a void array.  Since void is a primitive type return null
2162             // klass.  Users of this result need to do a null check on the returned klass.
2163             return TypePtr::NULL_PTR;
2164           }
2165           return TypeKlassPtr::make(ciArrayKlass::make(t));
2166         }
2167         if (!t-&gt;is_klass()) {
2168           // a primitive Class (e.g., int.class) has NULL for a klass field
2169           return TypePtr::NULL_PTR;
2170         }
2171         // (Folds up the 1st indirection in aClassConstant.getModifiers().)
2172         return TypeKlassPtr::make(t-&gt;as_klass());
2173       }
2174       // non-constant mirror, so we can&#39;t tell what&#39;s going on
2175     }
2176     if( !ik-&gt;is_loaded() )
2177       return _type;             // Bail out if not loaded
2178     if (offset == oopDesc::klass_offset_in_bytes()) {
2179       if (tinst-&gt;klass_is_exact()) {
2180         return TypeKlassPtr::make(ik);
2181       }
2182       // See if we can become precise: no subklasses and no interface
2183       // (Note:  We need to support verified interfaces.)
2184       if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
2185         //assert(!UseExactTypes, &quot;this code should be useless with exact types&quot;);
2186         // Add a dependence; if any subclass added we need to recompile
2187         if (!ik-&gt;is_final()) {
2188           // %%% should use stronger assert_unique_concrete_subtype instead
2189           phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
2190         }
2191         // Return precise klass
2192         return TypeKlassPtr::make(ik);
2193       }
2194 
2195       // Return root of possible klass
2196       return TypeKlassPtr::make(TypePtr::NotNull, ik, 0/*offset*/);
2197     }
2198   }
2199 
2200   // Check for loading klass from an array
2201   const TypeAryPtr *tary = tp-&gt;isa_aryptr();
2202   if( tary != NULL ) {
2203     ciKlass *tary_klass = tary-&gt;klass();
2204     if (tary_klass != NULL   // can be NULL when at BOTTOM or TOP
2205         &amp;&amp; tary-&gt;offset() == oopDesc::klass_offset_in_bytes()) {
2206       if (tary-&gt;klass_is_exact()) {
2207         return TypeKlassPtr::make(tary_klass);
2208       }
2209       ciArrayKlass *ak = tary-&gt;klass()-&gt;as_array_klass();
2210       // If the klass is an object array, we defer the question to the
2211       // array component klass.
2212       if( ak-&gt;is_obj_array_klass() ) {
2213         assert( ak-&gt;is_loaded(), &quot;&quot; );
2214         ciKlass *base_k = ak-&gt;as_obj_array_klass()-&gt;base_element_klass();
2215         if( base_k-&gt;is_loaded() &amp;&amp; base_k-&gt;is_instance_klass() ) {
2216           ciInstanceKlass* ik = base_k-&gt;as_instance_klass();
2217           // See if we can become precise: no subklasses and no interface
2218           if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
2219             //assert(!UseExactTypes, &quot;this code should be useless with exact types&quot;);
2220             // Add a dependence; if any subclass added we need to recompile
2221             if (!ik-&gt;is_final()) {
2222               phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
2223             }
2224             // Return precise array klass
2225             return TypeKlassPtr::make(ak);
2226           }
2227         }
2228         return TypeKlassPtr::make(TypePtr::NotNull, ak, 0/*offset*/);
2229       } else {                  // Found a type-array?
2230         //assert(!UseExactTypes, &quot;this code should be useless with exact types&quot;);
2231         assert( ak-&gt;is_type_array_klass(), &quot;&quot; );
2232         return TypeKlassPtr::make(ak); // These are always precise
2233       }
2234     }
2235   }
2236 
2237   // Check for loading klass from an array klass
2238   const TypeKlassPtr *tkls = tp-&gt;isa_klassptr();
2239   if (tkls != NULL &amp;&amp; !StressReflectiveCode) {
2240     ciKlass* klass = tkls-&gt;klass();
2241     if( !klass-&gt;is_loaded() )
2242       return _type;             // Bail out if not loaded
2243     if( klass-&gt;is_obj_array_klass() &amp;&amp;
2244         tkls-&gt;offset() == in_bytes(ObjArrayKlass::element_klass_offset())) {
2245       ciKlass* elem = klass-&gt;as_obj_array_klass()-&gt;element_klass();
2246       // // Always returning precise element type is incorrect,
2247       // // e.g., element type could be object and array may contain strings
2248       // return TypeKlassPtr::make(TypePtr::Constant, elem, 0);
2249 
2250       // The array&#39;s TypeKlassPtr was declared &#39;precise&#39; or &#39;not precise&#39;
2251       // according to the element type&#39;s subclassing.
2252       return TypeKlassPtr::make(tkls-&gt;ptr(), elem, 0/*offset*/);
2253     }
2254     if( klass-&gt;is_instance_klass() &amp;&amp; tkls-&gt;klass_is_exact() &amp;&amp;
2255         tkls-&gt;offset() == in_bytes(Klass::super_offset())) {
2256       ciKlass* sup = klass-&gt;as_instance_klass()-&gt;super();
2257       // The field is Klass::_super.  Return its (constant) value.
2258       // (Folds up the 2nd indirection in aClassConstant.getSuperClass().)
2259       return sup ? TypeKlassPtr::make(sup) : TypePtr::NULL_PTR;
2260     }
2261   }
2262 
2263   // Bailout case
2264   return LoadNode::Value(phase);
2265 }
2266 
2267 //------------------------------Identity---------------------------------------
2268 // To clean up reflective code, simplify k.java_mirror.as_klass to plain k.
2269 // Also feed through the klass in Allocate(...klass...)._klass.
2270 Node* LoadKlassNode::Identity(PhaseGVN* phase) {
2271   return klass_identity_common(phase);
2272 }
2273 
2274 Node* LoadNode::klass_identity_common(PhaseGVN* phase) {
2275   Node* x = LoadNode::Identity(phase);
2276   if (x != this)  return x;
2277 
2278   // Take apart the address into an oop and and offset.
2279   // Return &#39;this&#39; if we cannot.
2280   Node*    adr    = in(MemNode::Address);
2281   intptr_t offset = 0;
2282   Node*    base   = AddPNode::Ideal_base_and_offset(adr, phase, offset);
2283   if (base == NULL)     return this;
2284   const TypeOopPtr* toop = phase-&gt;type(adr)-&gt;isa_oopptr();
2285   if (toop == NULL)     return this;
2286 
2287   // Step over potential GC barrier for OopHandle resolve
2288   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2289   if (bs-&gt;is_gc_barrier_node(base)) {
2290     base = bs-&gt;step_over_gc_barrier(base);
2291   }
2292 
2293   // We can fetch the klass directly through an AllocateNode.
2294   // This works even if the klass is not constant (clone or newArray).
2295   if (offset == oopDesc::klass_offset_in_bytes()) {
2296     Node* allocated_klass = AllocateNode::Ideal_klass(base, phase);
2297     if (allocated_klass != NULL) {
2298       return allocated_klass;
2299     }
2300   }
2301 
2302   // Simplify k.java_mirror.as_klass to plain k, where k is a Klass*.
2303   // See inline_native_Class_query for occurrences of these patterns.
2304   // Java Example:  x.getClass().isAssignableFrom(y)
2305   //
2306   // This improves reflective code, often making the Class
2307   // mirror go completely dead.  (Current exception:  Class
2308   // mirrors may appear in debug info, but we could clean them out by
2309   // introducing a new debug info operator for Klass.java_mirror).
2310 
2311   if (toop-&gt;isa_instptr() &amp;&amp; toop-&gt;klass() == phase-&gt;C-&gt;env()-&gt;Class_klass()
2312       &amp;&amp; offset == java_lang_Class::klass_offset_in_bytes()) {
2313     if (base-&gt;is_Load()) {
2314       Node* base2 = base-&gt;in(MemNode::Address);
2315       if (base2-&gt;is_Load()) { /* direct load of a load which is the OopHandle */
2316         Node* adr2 = base2-&gt;in(MemNode::Address);
2317         const TypeKlassPtr* tkls = phase-&gt;type(adr2)-&gt;isa_klassptr();
2318         if (tkls != NULL &amp;&amp; !tkls-&gt;empty()
2319             &amp;&amp; (tkls-&gt;klass()-&gt;is_instance_klass() ||
2320               tkls-&gt;klass()-&gt;is_array_klass())
2321             &amp;&amp; adr2-&gt;is_AddP()
2322            ) {
2323           int mirror_field = in_bytes(Klass::java_mirror_offset());
2324           if (tkls-&gt;offset() == mirror_field) {
2325             return adr2-&gt;in(AddPNode::Base);
2326           }
2327         }
2328       }
2329     }
2330   }
2331 
2332   return this;
2333 }
2334 
2335 
2336 //------------------------------Value------------------------------------------
2337 const Type* LoadNKlassNode::Value(PhaseGVN* phase) const {
2338   const Type *t = klass_value_common(phase);
2339   if (t == Type::TOP)
2340     return t;
2341 
2342   return t-&gt;make_narrowklass();
2343 }
2344 
2345 //------------------------------Identity---------------------------------------
2346 // To clean up reflective code, simplify k.java_mirror.as_klass to narrow k.
2347 // Also feed through the klass in Allocate(...klass...)._klass.
2348 Node* LoadNKlassNode::Identity(PhaseGVN* phase) {
2349   Node *x = klass_identity_common(phase);
2350 
2351   const Type *t = phase-&gt;type( x );
2352   if( t == Type::TOP ) return x;
2353   if( t-&gt;isa_narrowklass()) return x;
2354   assert (!t-&gt;isa_narrowoop(), &quot;no narrow oop here&quot;);
2355 
2356   return phase-&gt;transform(new EncodePKlassNode(x, t-&gt;make_narrowklass()));
2357 }
2358 
2359 //------------------------------Value-----------------------------------------
2360 const Type* LoadRangeNode::Value(PhaseGVN* phase) const {
2361   // Either input is TOP ==&gt; the result is TOP
2362   const Type *t1 = phase-&gt;type( in(MemNode::Memory) );
2363   if( t1 == Type::TOP ) return Type::TOP;
2364   Node *adr = in(MemNode::Address);
2365   const Type *t2 = phase-&gt;type( adr );
2366   if( t2 == Type::TOP ) return Type::TOP;
2367   const TypePtr *tp = t2-&gt;is_ptr();
2368   if (TypePtr::above_centerline(tp-&gt;ptr()))  return Type::TOP;
2369   const TypeAryPtr *tap = tp-&gt;isa_aryptr();
2370   if( !tap ) return _type;
2371   return tap-&gt;size();
2372 }
2373 
2374 //-------------------------------Ideal---------------------------------------
2375 // Feed through the length in AllocateArray(...length...)._length.
2376 Node *LoadRangeNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2377   Node* p = MemNode::Ideal_common(phase, can_reshape);
2378   if (p)  return (p == NodeSentinel) ? NULL : p;
2379 
2380   // Take apart the address into an oop and and offset.
2381   // Return &#39;this&#39; if we cannot.
2382   Node*    adr    = in(MemNode::Address);
2383   intptr_t offset = 0;
2384   Node*    base   = AddPNode::Ideal_base_and_offset(adr, phase,  offset);
2385   if (base == NULL)     return NULL;
2386   const TypeAryPtr* tary = phase-&gt;type(adr)-&gt;isa_aryptr();
2387   if (tary == NULL)     return NULL;
2388 
2389   // We can fetch the length directly through an AllocateArrayNode.
2390   // This works even if the length is not constant (clone or newArray).
2391   if (offset == arrayOopDesc::length_offset_in_bytes()) {
2392     AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(base, phase);
2393     if (alloc != NULL) {
2394       Node* allocated_length = alloc-&gt;Ideal_length();
2395       Node* len = alloc-&gt;make_ideal_length(tary, phase);
2396       if (allocated_length != len) {
2397         // New CastII improves on this.
2398         return len;
2399       }
2400     }
2401   }
2402 
2403   return NULL;
2404 }
2405 
2406 //------------------------------Identity---------------------------------------
2407 // Feed through the length in AllocateArray(...length...)._length.
2408 Node* LoadRangeNode::Identity(PhaseGVN* phase) {
2409   Node* x = LoadINode::Identity(phase);
2410   if (x != this)  return x;
2411 
2412   // Take apart the address into an oop and and offset.
2413   // Return &#39;this&#39; if we cannot.
2414   Node*    adr    = in(MemNode::Address);
2415   intptr_t offset = 0;
2416   Node*    base   = AddPNode::Ideal_base_and_offset(adr, phase, offset);
2417   if (base == NULL)     return this;
2418   const TypeAryPtr* tary = phase-&gt;type(adr)-&gt;isa_aryptr();
2419   if (tary == NULL)     return this;
2420 
2421   // We can fetch the length directly through an AllocateArrayNode.
2422   // This works even if the length is not constant (clone or newArray).
2423   if (offset == arrayOopDesc::length_offset_in_bytes()) {
2424     AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(base, phase);
2425     if (alloc != NULL) {
2426       Node* allocated_length = alloc-&gt;Ideal_length();
2427       // Do not allow make_ideal_length to allocate a CastII node.
2428       Node* len = alloc-&gt;make_ideal_length(tary, phase, false);
2429       if (allocated_length == len) {
2430         // Return allocated_length only if it would not be improved by a CastII.
2431         return allocated_length;
2432       }
2433     }
2434   }
2435 
2436   return this;
2437 
2438 }
2439 
2440 //=============================================================================
2441 //---------------------------StoreNode::make-----------------------------------
2442 // Polymorphic factory method:
2443 StoreNode* StoreNode::make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, BasicType bt, MemOrd mo) {
2444   assert((mo == unordered || mo == release), &quot;unexpected&quot;);
2445   Compile* C = gvn.C;
2446   assert(C-&gt;get_alias_index(adr_type) != Compile::AliasIdxRaw ||
2447          ctl != NULL, &quot;raw memory operations should have control edge&quot;);
2448 
2449   switch (bt) {
2450   case T_BOOLEAN: val = gvn.transform(new AndINode(val, gvn.intcon(0x1))); // Fall through to T_BYTE case
2451   case T_BYTE:    return new StoreBNode(ctl, mem, adr, adr_type, val, mo);
2452   case T_INT:     return new StoreINode(ctl, mem, adr, adr_type, val, mo);
2453   case T_CHAR:
2454   case T_SHORT:   return new StoreCNode(ctl, mem, adr, adr_type, val, mo);
2455   case T_LONG:    return new StoreLNode(ctl, mem, adr, adr_type, val, mo);
2456   case T_FLOAT:   return new StoreFNode(ctl, mem, adr, adr_type, val, mo);
2457   case T_DOUBLE:  return new StoreDNode(ctl, mem, adr, adr_type, val, mo);
2458   case T_METADATA:
2459   case T_ADDRESS:
2460   case T_OBJECT:
2461 #ifdef _LP64
2462     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
2463       val = gvn.transform(new EncodePNode(val, val-&gt;bottom_type()-&gt;make_narrowoop()));
2464       return new StoreNNode(ctl, mem, adr, adr_type, val, mo);
2465     } else if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowklass() ||
2466                (UseCompressedClassPointers &amp;&amp; val-&gt;bottom_type()-&gt;isa_klassptr() &amp;&amp;
2467                 adr-&gt;bottom_type()-&gt;isa_rawptr())) {
2468       val = gvn.transform(new EncodePKlassNode(val, val-&gt;bottom_type()-&gt;make_narrowklass()));
2469       return new StoreNKlassNode(ctl, mem, adr, adr_type, val, mo);
2470     }
2471 #endif
2472     {
2473       return new StorePNode(ctl, mem, adr, adr_type, val, mo);
2474     }
2475   default:
2476     ShouldNotReachHere();
2477     return (StoreNode*)NULL;
2478   }
2479 }
2480 
2481 StoreLNode* StoreLNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo) {
2482   bool require_atomic = true;
2483   return new StoreLNode(ctl, mem, adr, adr_type, val, mo, require_atomic);
2484 }
2485 
2486 StoreDNode* StoreDNode::make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo) {
2487   bool require_atomic = true;
2488   return new StoreDNode(ctl, mem, adr, adr_type, val, mo, require_atomic);
2489 }
2490 
2491 
2492 //--------------------------bottom_type----------------------------------------
2493 const Type *StoreNode::bottom_type() const {
2494   return Type::MEMORY;
2495 }
2496 
2497 //------------------------------hash-------------------------------------------
2498 uint StoreNode::hash() const {
2499   // unroll addition of interesting fields
2500   //return (uintptr_t)in(Control) + (uintptr_t)in(Memory) + (uintptr_t)in(Address) + (uintptr_t)in(ValueIn);
2501 
2502   // Since they are not commoned, do not hash them:
2503   return NO_HASH;
2504 }
2505 
2506 //------------------------------Ideal------------------------------------------
2507 // Change back-to-back Store(, p, x) -&gt; Store(m, p, y) to Store(m, p, x).
2508 // When a store immediately follows a relevant allocation/initialization,
2509 // try to capture it into the initialization, or hoist it above.
2510 Node *StoreNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2511   Node* p = MemNode::Ideal_common(phase, can_reshape);
2512   if (p)  return (p == NodeSentinel) ? NULL : p;
2513 
2514   Node* mem     = in(MemNode::Memory);
2515   Node* address = in(MemNode::Address);
2516   // Back-to-back stores to same address?  Fold em up.  Generally
2517   // unsafe if I have intervening uses...  Also disallowed for StoreCM
2518   // since they must follow each StoreP operation.  Redundant StoreCMs
2519   // are eliminated just before matching in final_graph_reshape.
2520   {
2521     Node* st = mem;
2522     // If Store &#39;st&#39; has more than one use, we cannot fold &#39;st&#39; away.
2523     // For example, &#39;st&#39; might be the final state at a conditional
2524     // return.  Or, &#39;st&#39; might be used by some node which is live at
2525     // the same time &#39;st&#39; is live, which might be unschedulable.  So,
2526     // require exactly ONE user until such time as we clone &#39;mem&#39; for
2527     // each of &#39;mem&#39;s uses (thus making the exactly-1-user-rule hold
2528     // true).
2529     while (st-&gt;is_Store() &amp;&amp; st-&gt;outcnt() == 1 &amp;&amp; st-&gt;Opcode() != Op_StoreCM) {
2530       // Looking at a dead closed cycle of memory?
2531       assert(st != st-&gt;in(MemNode::Memory), &quot;dead loop in StoreNode::Ideal&quot;);
2532       assert(Opcode() == st-&gt;Opcode() ||
2533              st-&gt;Opcode() == Op_StoreVector ||
2534              Opcode() == Op_StoreVector ||
2535              phase-&gt;C-&gt;get_alias_index(adr_type()) == Compile::AliasIdxRaw ||
2536              (Opcode() == Op_StoreL &amp;&amp; st-&gt;Opcode() == Op_StoreI) || // expanded ClearArrayNode
2537              (Opcode() == Op_StoreI &amp;&amp; st-&gt;Opcode() == Op_StoreL) || // initialization by arraycopy
2538              (is_mismatched_access() || st-&gt;as_Store()-&gt;is_mismatched_access()),
2539              &quot;no mismatched stores, except on raw memory: %s %s&quot;, NodeClassNames[Opcode()], NodeClassNames[st-&gt;Opcode()]);
2540 
2541       if (st-&gt;in(MemNode::Address)-&gt;eqv_uncast(address) &amp;&amp;
2542           st-&gt;as_Store()-&gt;memory_size() &lt;= this-&gt;memory_size()) {
2543         Node* use = st-&gt;raw_out(0);
2544         phase-&gt;igvn_rehash_node_delayed(use);
2545         if (can_reshape) {
2546           use-&gt;set_req_X(MemNode::Memory, st-&gt;in(MemNode::Memory), phase-&gt;is_IterGVN());
2547         } else {
2548           // It&#39;s OK to do this in the parser, since DU info is always accurate,
2549           // and the parser always refers to nodes via SafePointNode maps.
2550           use-&gt;set_req(MemNode::Memory, st-&gt;in(MemNode::Memory));
2551         }
2552         return this;
2553       }
2554       st = st-&gt;in(MemNode::Memory);
2555     }
2556   }
2557 
2558 
2559   // Capture an unaliased, unconditional, simple store into an initializer.
2560   // Or, if it is independent of the allocation, hoist it above the allocation.
2561   if (ReduceFieldZeroing &amp;&amp; /*can_reshape &amp;&amp;*/
2562       mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Initialize()) {
2563     InitializeNode* init = mem-&gt;in(0)-&gt;as_Initialize();
2564     intptr_t offset = init-&gt;can_capture_store(this, phase, can_reshape);
2565     if (offset &gt; 0) {
2566       Node* moved = init-&gt;capture_store(this, offset, phase, can_reshape);
2567       // If the InitializeNode captured me, it made a raw copy of me,
2568       // and I need to disappear.
2569       if (moved != NULL) {
2570         // %%% hack to ensure that Ideal returns a new node:
2571         mem = MergeMemNode::make(mem);
2572         return mem;             // fold me away
2573       }
2574     }
2575   }
2576 
2577   return NULL;                  // No further progress
2578 }
2579 
2580 //------------------------------Value-----------------------------------------
2581 const Type* StoreNode::Value(PhaseGVN* phase) const {
2582   // Either input is TOP ==&gt; the result is TOP
2583   const Type *t1 = phase-&gt;type( in(MemNode::Memory) );
2584   if( t1 == Type::TOP ) return Type::TOP;
2585   const Type *t2 = phase-&gt;type( in(MemNode::Address) );
2586   if( t2 == Type::TOP ) return Type::TOP;
2587   const Type *t3 = phase-&gt;type( in(MemNode::ValueIn) );
2588   if( t3 == Type::TOP ) return Type::TOP;
2589   return Type::MEMORY;
2590 }
2591 
2592 //------------------------------Identity---------------------------------------
2593 // Remove redundant stores:
2594 //   Store(m, p, Load(m, p)) changes to m.
2595 //   Store(, p, x) -&gt; Store(m, p, x) changes to Store(m, p, x).
2596 Node* StoreNode::Identity(PhaseGVN* phase) {
2597   Node* mem = in(MemNode::Memory);
2598   Node* adr = in(MemNode::Address);
2599   Node* val = in(MemNode::ValueIn);
2600 
2601   Node* result = this;
2602 
2603   // Load then Store?  Then the Store is useless
2604   if (val-&gt;is_Load() &amp;&amp;
2605       val-&gt;in(MemNode::Address)-&gt;eqv_uncast(adr) &amp;&amp;
2606       val-&gt;in(MemNode::Memory )-&gt;eqv_uncast(mem) &amp;&amp;
2607       val-&gt;as_Load()-&gt;store_Opcode() == Opcode()) {
2608     result = mem;
2609   }
2610 
2611   // Two stores in a row of the same value?
2612   if (result == this &amp;&amp;
2613       mem-&gt;is_Store() &amp;&amp;
2614       mem-&gt;in(MemNode::Address)-&gt;eqv_uncast(adr) &amp;&amp;
2615       mem-&gt;in(MemNode::ValueIn)-&gt;eqv_uncast(val) &amp;&amp;
2616       mem-&gt;Opcode() == Opcode()) {
2617     result = mem;
2618   }
2619 
2620   // Store of zero anywhere into a freshly-allocated object?
2621   // Then the store is useless.
2622   // (It must already have been captured by the InitializeNode.)
2623   if (result == this &amp;&amp;
2624       ReduceFieldZeroing &amp;&amp; phase-&gt;type(val)-&gt;is_zero_type()) {
2625     // a newly allocated object is already all-zeroes everywhere
2626     if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Allocate()) {
2627       result = mem;
2628     }
2629 
2630     if (result == this) {
2631       // the store may also apply to zero-bits in an earlier object
2632       Node* prev_mem = find_previous_store(phase);
2633       // Steps (a), (b):  Walk past independent stores to find an exact match.
2634       if (prev_mem != NULL) {
2635         Node* prev_val = can_see_stored_value(prev_mem, phase);
2636         if (prev_val != NULL &amp;&amp; phase-&gt;eqv(prev_val, val)) {
2637           // prev_val and val might differ by a cast; it would be good
2638           // to keep the more informative of the two.
2639           result = mem;
2640         }
2641       }
2642     }
2643   }
2644 
2645   if (result != this &amp;&amp; phase-&gt;is_IterGVN() != NULL) {
2646     MemBarNode* trailing = trailing_membar();
2647     if (trailing != NULL) {
2648 #ifdef ASSERT
2649       const TypeOopPtr* t_oop = phase-&gt;type(in(Address))-&gt;isa_oopptr();
2650       assert(t_oop == NULL || t_oop-&gt;is_known_instance_field(), &quot;only for non escaping objects&quot;);
2651 #endif
2652       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
2653       trailing-&gt;remove(igvn);
2654     }
2655   }
2656 
2657   return result;
2658 }
2659 
2660 //------------------------------match_edge-------------------------------------
2661 // Do we Match on this edge index or not?  Match only memory &amp; value
2662 uint StoreNode::match_edge(uint idx) const {
2663   return idx == MemNode::Address || idx == MemNode::ValueIn;
2664 }
2665 
2666 //------------------------------cmp--------------------------------------------
2667 // Do not common stores up together.  They generally have to be split
2668 // back up anyways, so do not bother.
2669 bool StoreNode::cmp( const Node &amp;n ) const {
2670   return (&amp;n == this);          // Always fail except on self
2671 }
2672 
2673 //------------------------------Ideal_masked_input-----------------------------
2674 // Check for a useless mask before a partial-word store
2675 // (StoreB ... (AndI valIn conIa) )
2676 // If (conIa &amp; mask == mask) this simplifies to
2677 // (StoreB ... (valIn) )
2678 Node *StoreNode::Ideal_masked_input(PhaseGVN *phase, uint mask) {
2679   Node *val = in(MemNode::ValueIn);
2680   if( val-&gt;Opcode() == Op_AndI ) {
2681     const TypeInt *t = phase-&gt;type( val-&gt;in(2) )-&gt;isa_int();
2682     if( t &amp;&amp; t-&gt;is_con() &amp;&amp; (t-&gt;get_con() &amp; mask) == mask ) {
2683       set_req(MemNode::ValueIn, val-&gt;in(1));
2684       return this;
2685     }
2686   }
2687   return NULL;
2688 }
2689 
2690 
2691 //------------------------------Ideal_sign_extended_input----------------------
2692 // Check for useless sign-extension before a partial-word store
2693 // (StoreB ... (RShiftI _ (LShiftI _ valIn conIL ) conIR) )
2694 // If (conIL == conIR &amp;&amp; conIR &lt;= num_bits)  this simplifies to
2695 // (StoreB ... (valIn) )
2696 Node *StoreNode::Ideal_sign_extended_input(PhaseGVN *phase, int num_bits) {
2697   Node *val = in(MemNode::ValueIn);
2698   if( val-&gt;Opcode() == Op_RShiftI ) {
2699     const TypeInt *t = phase-&gt;type( val-&gt;in(2) )-&gt;isa_int();
2700     if( t &amp;&amp; t-&gt;is_con() &amp;&amp; (t-&gt;get_con() &lt;= num_bits) ) {
2701       Node *shl = val-&gt;in(1);
2702       if( shl-&gt;Opcode() == Op_LShiftI ) {
2703         const TypeInt *t2 = phase-&gt;type( shl-&gt;in(2) )-&gt;isa_int();
2704         if( t2 &amp;&amp; t2-&gt;is_con() &amp;&amp; (t2-&gt;get_con() == t-&gt;get_con()) ) {
2705           set_req(MemNode::ValueIn, shl-&gt;in(1));
2706           return this;
2707         }
2708       }
2709     }
2710   }
2711   return NULL;
2712 }
2713 
2714 //------------------------------value_never_loaded-----------------------------------
2715 // Determine whether there are any possible loads of the value stored.
2716 // For simplicity, we actually check if there are any loads from the
2717 // address stored to, not just for loads of the value stored by this node.
2718 //
2719 bool StoreNode::value_never_loaded( PhaseTransform *phase) const {
2720   Node *adr = in(Address);
2721   const TypeOopPtr *adr_oop = phase-&gt;type(adr)-&gt;isa_oopptr();
2722   if (adr_oop == NULL)
2723     return false;
2724   if (!adr_oop-&gt;is_known_instance_field())
2725     return false; // if not a distinct instance, there may be aliases of the address
2726   for (DUIterator_Fast imax, i = adr-&gt;fast_outs(imax); i &lt; imax; i++) {
2727     Node *use = adr-&gt;fast_out(i);
2728     if (use-&gt;is_Load() || use-&gt;is_LoadStore()) {
2729       return false;
2730     }
2731   }
2732   return true;
2733 }
2734 
2735 MemBarNode* StoreNode::trailing_membar() const {
2736   if (is_release()) {
2737     MemBarNode* trailing_mb = NULL;
2738     for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
2739       Node* u = fast_out(i);
2740       if (u-&gt;is_MemBar()) {
2741         if (u-&gt;as_MemBar()-&gt;trailing_store()) {
2742           assert(u-&gt;Opcode() == Op_MemBarVolatile, &quot;&quot;);
2743           assert(trailing_mb == NULL, &quot;only one&quot;);
2744           trailing_mb = u-&gt;as_MemBar();
2745 #ifdef ASSERT
2746           Node* leading = u-&gt;as_MemBar()-&gt;leading_membar();
2747           assert(leading-&gt;Opcode() == Op_MemBarRelease, &quot;incorrect membar&quot;);
2748           assert(leading-&gt;as_MemBar()-&gt;leading_store(), &quot;incorrect membar pair&quot;);
2749           assert(leading-&gt;as_MemBar()-&gt;trailing_membar() == u, &quot;incorrect membar pair&quot;);
2750 #endif
2751         } else {
2752           assert(u-&gt;as_MemBar()-&gt;standalone(), &quot;&quot;);
2753         }
2754       }
2755     }
2756     return trailing_mb;
2757   }
2758   return NULL;
2759 }
2760 
2761 
2762 //=============================================================================
2763 //------------------------------Ideal------------------------------------------
2764 // If the store is from an AND mask that leaves the low bits untouched, then
2765 // we can skip the AND operation.  If the store is from a sign-extension
2766 // (a left shift, then right shift) we can skip both.
2767 Node *StoreBNode::Ideal(PhaseGVN *phase, bool can_reshape){
2768   Node *progress = StoreNode::Ideal_masked_input(phase, 0xFF);
2769   if( progress != NULL ) return progress;
2770 
2771   progress = StoreNode::Ideal_sign_extended_input(phase, 24);
2772   if( progress != NULL ) return progress;
2773 
2774   // Finally check the default case
2775   return StoreNode::Ideal(phase, can_reshape);
2776 }
2777 
2778 //=============================================================================
2779 //------------------------------Ideal------------------------------------------
2780 // If the store is from an AND mask that leaves the low bits untouched, then
2781 // we can skip the AND operation
2782 Node *StoreCNode::Ideal(PhaseGVN *phase, bool can_reshape){
2783   Node *progress = StoreNode::Ideal_masked_input(phase, 0xFFFF);
2784   if( progress != NULL ) return progress;
2785 
2786   progress = StoreNode::Ideal_sign_extended_input(phase, 16);
2787   if( progress != NULL ) return progress;
2788 
2789   // Finally check the default case
2790   return StoreNode::Ideal(phase, can_reshape);
2791 }
2792 
2793 //=============================================================================
2794 //------------------------------Identity---------------------------------------
2795 Node* StoreCMNode::Identity(PhaseGVN* phase) {
2796   // No need to card mark when storing a null ptr
2797   Node* my_store = in(MemNode::OopStore);
2798   if (my_store-&gt;is_Store()) {
2799     const Type *t1 = phase-&gt;type( my_store-&gt;in(MemNode::ValueIn) );
2800     if( t1 == TypePtr::NULL_PTR ) {
2801       return in(MemNode::Memory);
2802     }
2803   }
2804   return this;
2805 }
2806 
2807 //=============================================================================
2808 //------------------------------Ideal---------------------------------------
2809 Node *StoreCMNode::Ideal(PhaseGVN *phase, bool can_reshape){
2810   Node* progress = StoreNode::Ideal(phase, can_reshape);
2811   if (progress != NULL) return progress;
2812 
2813   Node* my_store = in(MemNode::OopStore);
2814   if (my_store-&gt;is_MergeMem()) {
2815     Node* mem = my_store-&gt;as_MergeMem()-&gt;memory_at(oop_alias_idx());
2816     set_req(MemNode::OopStore, mem);
2817     return this;
2818   }
2819 
2820   return NULL;
2821 }
2822 
2823 //------------------------------Value-----------------------------------------
2824 const Type* StoreCMNode::Value(PhaseGVN* phase) const {
2825   // Either input is TOP ==&gt; the result is TOP
2826   const Type *t = phase-&gt;type( in(MemNode::Memory) );
2827   if( t == Type::TOP ) return Type::TOP;
2828   t = phase-&gt;type( in(MemNode::Address) );
2829   if( t == Type::TOP ) return Type::TOP;
2830   t = phase-&gt;type( in(MemNode::ValueIn) );
2831   if( t == Type::TOP ) return Type::TOP;
2832   // If extra input is TOP ==&gt; the result is TOP
2833   t = phase-&gt;type( in(MemNode::OopStore) );
2834   if( t == Type::TOP ) return Type::TOP;
2835 
2836   return StoreNode::Value( phase );
2837 }
2838 
2839 
2840 //=============================================================================
2841 //----------------------------------SCMemProjNode------------------------------
2842 const Type* SCMemProjNode::Value(PhaseGVN* phase) const
2843 {
2844   return bottom_type();
2845 }
2846 
2847 //=============================================================================
2848 //----------------------------------LoadStoreNode------------------------------
2849 LoadStoreNode::LoadStoreNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* rt, uint required )
2850   : Node(required),
2851     _type(rt),
2852     _adr_type(at),
2853     _barrier(0)
2854 {
2855   init_req(MemNode::Control, c  );
2856   init_req(MemNode::Memory , mem);
2857   init_req(MemNode::Address, adr);
2858   init_req(MemNode::ValueIn, val);
2859   init_class_id(Class_LoadStore);
2860 }
2861 
2862 uint LoadStoreNode::ideal_reg() const {
2863   return _type-&gt;ideal_reg();
2864 }
2865 
2866 bool LoadStoreNode::result_not_used() const {
2867   for( DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++ ) {
2868     Node *x = fast_out(i);
2869     if (x-&gt;Opcode() == Op_SCMemProj) continue;
2870     return false;
2871   }
2872   return true;
2873 }
2874 
2875 MemBarNode* LoadStoreNode::trailing_membar() const {
2876   MemBarNode* trailing = NULL;
2877   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
2878     Node* u = fast_out(i);
2879     if (u-&gt;is_MemBar()) {
2880       if (u-&gt;as_MemBar()-&gt;trailing_load_store()) {
2881         assert(u-&gt;Opcode() == Op_MemBarAcquire, &quot;&quot;);
2882         assert(trailing == NULL, &quot;only one&quot;);
2883         trailing = u-&gt;as_MemBar();
2884 #ifdef ASSERT
2885         Node* leading = trailing-&gt;leading_membar();
2886         assert(support_IRIW_for_not_multiple_copy_atomic_cpu || leading-&gt;Opcode() == Op_MemBarRelease, &quot;incorrect membar&quot;);
2887         assert(leading-&gt;as_MemBar()-&gt;leading_load_store(), &quot;incorrect membar pair&quot;);
2888         assert(leading-&gt;as_MemBar()-&gt;trailing_membar() == trailing, &quot;incorrect membar pair&quot;);
2889 #endif
2890       } else {
2891         assert(u-&gt;as_MemBar()-&gt;standalone(), &quot;wrong barrier kind&quot;);
2892       }
2893     }
2894   }
2895 
2896   return trailing;
2897 }
2898 
2899 uint LoadStoreNode::size_of() const { return sizeof(*this); }
2900 
2901 //=============================================================================
2902 //----------------------------------LoadStoreConditionalNode--------------------
2903 LoadStoreConditionalNode::LoadStoreConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex ) : LoadStoreNode(c, mem, adr, val, NULL, TypeInt::BOOL, 5) {
2904   init_req(ExpectedIn, ex );
2905 }
2906 
2907 //=============================================================================
2908 //-------------------------------adr_type--------------------------------------
2909 const TypePtr* ClearArrayNode::adr_type() const {
2910   Node *adr = in(3);
2911   if (adr == NULL)  return NULL; // node is dead
2912   return MemNode::calculate_adr_type(adr-&gt;bottom_type());
2913 }
2914 
2915 //------------------------------match_edge-------------------------------------
2916 // Do we Match on this edge index or not?  Do not match memory
2917 uint ClearArrayNode::match_edge(uint idx) const {
2918   return idx &gt; 1;
2919 }
2920 
2921 //------------------------------Identity---------------------------------------
2922 // Clearing a zero length array does nothing
2923 Node* ClearArrayNode::Identity(PhaseGVN* phase) {
2924   return phase-&gt;type(in(2))-&gt;higher_equal(TypeX::ZERO)  ? in(1) : this;
2925 }
2926 
2927 //------------------------------Idealize---------------------------------------
2928 // Clearing a short array is faster with stores
2929 Node *ClearArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2930   // Already know this is a large node, do not try to ideal it
2931   if (!IdealizeClearArrayNode || _is_large) return NULL;
2932 
2933   const int unit = BytesPerLong;
2934   const TypeX* t = phase-&gt;type(in(2))-&gt;isa_intptr_t();
2935   if (!t)  return NULL;
2936   if (!t-&gt;is_con())  return NULL;
2937   intptr_t raw_count = t-&gt;get_con();
2938   intptr_t size = raw_count;
2939   if (!Matcher::init_array_count_is_in_bytes) size *= unit;
2940   // Clearing nothing uses the Identity call.
2941   // Negative clears are possible on dead ClearArrays
2942   // (see jck test stmt114.stmt11402.val).
2943   if (size &lt;= 0 || size % unit != 0)  return NULL;
2944   intptr_t count = size / unit;
2945   // Length too long; communicate this to matchers and assemblers.
2946   // Assemblers are responsible to produce fast hardware clears for it.
2947   if (size &gt; InitArrayShortSize) {
2948     return new ClearArrayNode(in(0), in(1), in(2), in(3), true);
2949   }
2950   Node *mem = in(1);
2951   if( phase-&gt;type(mem)==Type::TOP ) return NULL;
2952   Node *adr = in(3);
2953   const Type* at = phase-&gt;type(adr);
2954   if( at==Type::TOP ) return NULL;
2955   const TypePtr* atp = at-&gt;isa_ptr();
2956   // adjust atp to be the correct array element address type
2957   if (atp == NULL)  atp = TypePtr::BOTTOM;
2958   else              atp = atp-&gt;add_offset(Type::OffsetBot);
2959   // Get base for derived pointer purposes
2960   if( adr-&gt;Opcode() != Op_AddP ) Unimplemented();
2961   Node *base = adr-&gt;in(1);
2962 
2963   Node *zero = phase-&gt;makecon(TypeLong::ZERO);
2964   Node *off  = phase-&gt;MakeConX(BytesPerLong);
2965   mem = new StoreLNode(in(0),mem,adr,atp,zero,MemNode::unordered,false);
2966   count--;
2967   while( count-- ) {
2968     mem = phase-&gt;transform(mem);
2969     adr = phase-&gt;transform(new AddPNode(base,adr,off));
2970     mem = new StoreLNode(in(0),mem,adr,atp,zero,MemNode::unordered,false);
2971   }
2972   return mem;
2973 }
2974 
2975 //----------------------------step_through----------------------------------
2976 // Return allocation input memory edge if it is different instance
2977 // or itself if it is the one we are looking for.
2978 bool ClearArrayNode::step_through(Node** np, uint instance_id, PhaseTransform* phase) {
2979   Node* n = *np;
2980   assert(n-&gt;is_ClearArray(), &quot;sanity&quot;);
2981   intptr_t offset;
2982   AllocateNode* alloc = AllocateNode::Ideal_allocation(n-&gt;in(3), phase, offset);
2983   // This method is called only before Allocate nodes are expanded
2984   // during macro nodes expansion. Before that ClearArray nodes are
2985   // only generated in PhaseMacroExpand::generate_arraycopy() (before
2986   // Allocate nodes are expanded) which follows allocations.
2987   assert(alloc != NULL, &quot;should have allocation&quot;);
2988   if (alloc-&gt;_idx == instance_id) {
2989     // Can not bypass initialization of the instance we are looking for.
2990     return false;
2991   }
2992   // Otherwise skip it.
2993   InitializeNode* init = alloc-&gt;initialization();
2994   if (init != NULL)
2995     *np = init-&gt;in(TypeFunc::Memory);
2996   else
2997     *np = alloc-&gt;in(TypeFunc::Memory);
2998   return true;
2999 }
3000 
3001 //----------------------------clear_memory-------------------------------------
3002 // Generate code to initialize object storage to zero.
3003 Node* ClearArrayNode::clear_memory(Node* ctl, Node* mem, Node* dest,
3004                                    intptr_t start_offset,
3005                                    Node* end_offset,
3006                                    PhaseGVN* phase) {
3007   intptr_t offset = start_offset;
3008 
3009   int unit = BytesPerLong;
3010   if ((offset % unit) != 0) {
3011     Node* adr = new AddPNode(dest, dest, phase-&gt;MakeConX(offset));
3012     adr = phase-&gt;transform(adr);
3013     const TypePtr* atp = TypeRawPtr::BOTTOM;
3014     mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase-&gt;zerocon(T_INT), T_INT, MemNode::unordered);
3015     mem = phase-&gt;transform(mem);
3016     offset += BytesPerInt;
3017   }
3018   assert((offset % unit) == 0, &quot;&quot;);
3019 
3020   // Initialize the remaining stuff, if any, with a ClearArray.
3021   return clear_memory(ctl, mem, dest, phase-&gt;MakeConX(offset), end_offset, phase);
3022 }
3023 
3024 Node* ClearArrayNode::clear_memory(Node* ctl, Node* mem, Node* dest,
3025                                    Node* start_offset,
3026                                    Node* end_offset,
3027                                    PhaseGVN* phase) {
3028   if (start_offset == end_offset) {
3029     // nothing to do
3030     return mem;
3031   }
3032 
3033   int unit = BytesPerLong;
3034   Node* zbase = start_offset;
3035   Node* zend  = end_offset;
3036 
3037   // Scale to the unit required by the CPU:
3038   if (!Matcher::init_array_count_is_in_bytes) {
3039     Node* shift = phase-&gt;intcon(exact_log2(unit));
3040     zbase = phase-&gt;transform(new URShiftXNode(zbase, shift) );
3041     zend  = phase-&gt;transform(new URShiftXNode(zend,  shift) );
3042   }
3043 
3044   // Bulk clear double-words
3045   Node* zsize = phase-&gt;transform(new SubXNode(zend, zbase) );
3046   Node* adr = phase-&gt;transform(new AddPNode(dest, dest, start_offset) );
3047   mem = new ClearArrayNode(ctl, mem, zsize, adr, false);
3048   return phase-&gt;transform(mem);
3049 }
3050 
3051 Node* ClearArrayNode::clear_memory(Node* ctl, Node* mem, Node* dest,
3052                                    intptr_t start_offset,
3053                                    intptr_t end_offset,
3054                                    PhaseGVN* phase) {
3055   if (start_offset == end_offset) {
3056     // nothing to do
3057     return mem;
3058   }
3059 
3060   assert((end_offset % BytesPerInt) == 0, &quot;odd end offset&quot;);
3061   intptr_t done_offset = end_offset;
3062   if ((done_offset % BytesPerLong) != 0) {
3063     done_offset -= BytesPerInt;
3064   }
3065   if (done_offset &gt; start_offset) {
3066     mem = clear_memory(ctl, mem, dest,
3067                        start_offset, phase-&gt;MakeConX(done_offset), phase);
3068   }
3069   if (done_offset &lt; end_offset) { // emit the final 32-bit store
3070     Node* adr = new AddPNode(dest, dest, phase-&gt;MakeConX(done_offset));
3071     adr = phase-&gt;transform(adr);
3072     const TypePtr* atp = TypeRawPtr::BOTTOM;
3073     mem = StoreNode::make(*phase, ctl, mem, adr, atp, phase-&gt;zerocon(T_INT), T_INT, MemNode::unordered);
3074     mem = phase-&gt;transform(mem);
3075     done_offset += BytesPerInt;
3076   }
3077   assert(done_offset == end_offset, &quot;&quot;);
3078   return mem;
3079 }
3080 
3081 //=============================================================================
3082 MemBarNode::MemBarNode(Compile* C, int alias_idx, Node* precedent)
3083   : MultiNode(TypeFunc::Parms + (precedent == NULL? 0: 1)),
3084     _adr_type(C-&gt;get_adr_type(alias_idx)), _kind(Standalone)
3085 #ifdef ASSERT
3086   , _pair_idx(0)
3087 #endif
3088 {
3089   init_class_id(Class_MemBar);
3090   Node* top = C-&gt;top();
3091   init_req(TypeFunc::I_O,top);
3092   init_req(TypeFunc::FramePtr,top);
3093   init_req(TypeFunc::ReturnAdr,top);
3094   if (precedent != NULL)
3095     init_req(TypeFunc::Parms, precedent);
3096 }
3097 
3098 //------------------------------cmp--------------------------------------------
3099 uint MemBarNode::hash() const { return NO_HASH; }
3100 bool MemBarNode::cmp( const Node &amp;n ) const {
3101   return (&amp;n == this);          // Always fail except on self
3102 }
3103 
3104 //------------------------------make-------------------------------------------
3105 MemBarNode* MemBarNode::make(Compile* C, int opcode, int atp, Node* pn) {
3106   switch (opcode) {
3107   case Op_MemBarAcquire:     return new MemBarAcquireNode(C, atp, pn);
3108   case Op_LoadFence:         return new LoadFenceNode(C, atp, pn);
3109   case Op_MemBarRelease:     return new MemBarReleaseNode(C, atp, pn);
3110   case Op_StoreFence:        return new StoreFenceNode(C, atp, pn);
3111   case Op_MemBarAcquireLock: return new MemBarAcquireLockNode(C, atp, pn);
3112   case Op_MemBarReleaseLock: return new MemBarReleaseLockNode(C, atp, pn);
3113   case Op_MemBarVolatile:    return new MemBarVolatileNode(C, atp, pn);
3114   case Op_MemBarCPUOrder:    return new MemBarCPUOrderNode(C, atp, pn);
3115   case Op_OnSpinWait:        return new OnSpinWaitNode(C, atp, pn);
3116   case Op_Initialize:        return new InitializeNode(C, atp, pn);
3117   case Op_MemBarStoreStore:  return new MemBarStoreStoreNode(C, atp, pn);
3118   default: ShouldNotReachHere(); return NULL;
3119   }
3120 }
3121 
3122 void MemBarNode::remove(PhaseIterGVN *igvn) {
3123   if (outcnt() != 2) {
3124     return;
3125   }
3126   if (trailing_store() || trailing_load_store()) {
3127     MemBarNode* leading = leading_membar();
3128     if (leading != NULL) {
3129       assert(leading-&gt;trailing_membar() == this, &quot;inconsistent leading/trailing membars&quot;);
3130       leading-&gt;remove(igvn);
3131     }
3132   }
3133   igvn-&gt;replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));
3134   igvn-&gt;replace_node(proj_out(TypeFunc::Control), in(TypeFunc::Control));
3135 }
3136 
3137 //------------------------------Ideal------------------------------------------
3138 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
3139 // control copies
3140 Node *MemBarNode::Ideal(PhaseGVN *phase, bool can_reshape) {
3141   if (remove_dead_region(phase, can_reshape)) return this;
3142   // Don&#39;t bother trying to transform a dead node
3143   if (in(0) &amp;&amp; in(0)-&gt;is_top()) {
3144     return NULL;
3145   }
3146 
3147   bool progress = false;
3148   // Eliminate volatile MemBars for scalar replaced objects.
3149   if (can_reshape &amp;&amp; req() == (Precedent+1)) {
3150     bool eliminate = false;
3151     int opc = Opcode();
3152     if ((opc == Op_MemBarAcquire || opc == Op_MemBarVolatile)) {
3153       // Volatile field loads and stores.
3154       Node* my_mem = in(MemBarNode::Precedent);
3155       // The MembarAquire may keep an unused LoadNode alive through the Precedent edge
3156       if ((my_mem != NULL) &amp;&amp; (opc == Op_MemBarAcquire) &amp;&amp; (my_mem-&gt;outcnt() == 1)) {
3157         // if the Precedent is a decodeN and its input (a Load) is used at more than one place,
3158         // replace this Precedent (decodeN) with the Load instead.
3159         if ((my_mem-&gt;Opcode() == Op_DecodeN) &amp;&amp; (my_mem-&gt;in(1)-&gt;outcnt() &gt; 1))  {
3160           Node* load_node = my_mem-&gt;in(1);
3161           set_req(MemBarNode::Precedent, load_node);
3162           phase-&gt;is_IterGVN()-&gt;_worklist.push(my_mem);
3163           my_mem = load_node;
3164         } else {
3165           assert(my_mem-&gt;unique_out() == this, &quot;sanity&quot;);
3166           del_req(Precedent);
3167           phase-&gt;is_IterGVN()-&gt;_worklist.push(my_mem); // remove dead node later
3168           my_mem = NULL;
3169         }
3170         progress = true;
3171       }
3172       if (my_mem != NULL &amp;&amp; my_mem-&gt;is_Mem()) {
3173         const TypeOopPtr* t_oop = my_mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_oopptr();
3174         // Check for scalar replaced object reference.
3175         if( t_oop != NULL &amp;&amp; t_oop-&gt;is_known_instance_field() &amp;&amp;
3176             t_oop-&gt;offset() != Type::OffsetBot &amp;&amp;
3177             t_oop-&gt;offset() != Type::OffsetTop) {
3178           eliminate = true;
3179         }
3180       }
3181     } else if (opc == Op_MemBarRelease) {
3182       // Final field stores.
3183       Node* alloc = AllocateNode::Ideal_allocation(in(MemBarNode::Precedent), phase);
3184       if ((alloc != NULL) &amp;&amp; alloc-&gt;is_Allocate() &amp;&amp;
3185           alloc-&gt;as_Allocate()-&gt;does_not_escape_thread()) {
3186         // The allocated object does not escape.
3187         eliminate = true;
3188       }
3189     }
3190     if (eliminate) {
3191       // Replace MemBar projections by its inputs.
3192       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
3193       remove(igvn);
3194       // Must return either the original node (now dead) or a new node
3195       // (Do not return a top here, since that would break the uniqueness of top.)
3196       return new ConINode(TypeInt::ZERO);
3197     }
3198   }
3199   return progress ? this : NULL;
3200 }
3201 
3202 //------------------------------Value------------------------------------------
3203 const Type* MemBarNode::Value(PhaseGVN* phase) const {
3204   if( !in(0) ) return Type::TOP;
3205   if( phase-&gt;type(in(0)) == Type::TOP )
3206     return Type::TOP;
3207   return TypeTuple::MEMBAR;
3208 }
3209 
3210 //------------------------------match------------------------------------------
3211 // Construct projections for memory.
3212 Node *MemBarNode::match( const ProjNode *proj, const Matcher *m ) {
3213   switch (proj-&gt;_con) {
3214   case TypeFunc::Control:
3215   case TypeFunc::Memory:
3216     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
3217   }
3218   ShouldNotReachHere();
3219   return NULL;
3220 }
3221 
3222 void MemBarNode::set_store_pair(MemBarNode* leading, MemBarNode* trailing) {
3223   trailing-&gt;_kind = TrailingStore;
3224   leading-&gt;_kind = LeadingStore;
3225 #ifdef ASSERT
3226   trailing-&gt;_pair_idx = leading-&gt;_idx;
3227   leading-&gt;_pair_idx = leading-&gt;_idx;
3228 #endif
3229 }
3230 
3231 void MemBarNode::set_load_store_pair(MemBarNode* leading, MemBarNode* trailing) {
3232   trailing-&gt;_kind = TrailingLoadStore;
3233   leading-&gt;_kind = LeadingLoadStore;
3234 #ifdef ASSERT
3235   trailing-&gt;_pair_idx = leading-&gt;_idx;
3236   leading-&gt;_pair_idx = leading-&gt;_idx;
3237 #endif
3238 }
3239 
3240 MemBarNode* MemBarNode::trailing_membar() const {
3241   ResourceMark rm;
3242   Node* trailing = (Node*)this;
3243   VectorSet seen(Thread::current()-&gt;resource_area());
3244   Node_Stack multis(0);
3245   do {
3246     Node* c = trailing;
3247     uint i = 0;
3248     do {
3249       trailing = NULL;
3250       for (; i &lt; c-&gt;outcnt(); i++) {
3251         Node* next = c-&gt;raw_out(i);
3252         if (next != c &amp;&amp; next-&gt;is_CFG()) {
3253           if (c-&gt;is_MultiBranch()) {
3254             if (multis.node() == c) {
3255               multis.set_index(i+1);
3256             } else {
3257               multis.push(c, i+1);
3258             }
3259           }
3260           trailing = next;
3261           break;
3262         }
3263       }
3264       if (trailing != NULL &amp;&amp; !seen.test_set(trailing-&gt;_idx)) {
3265         break;
3266       }
3267       while (multis.size() &gt; 0) {
3268         c = multis.node();
3269         i = multis.index();
3270         if (i &lt; c-&gt;req()) {
3271           break;
3272         }
3273         multis.pop();
3274       }
3275     } while (multis.size() &gt; 0);
3276   } while (!trailing-&gt;is_MemBar() || !trailing-&gt;as_MemBar()-&gt;trailing());
3277 
3278   MemBarNode* mb = trailing-&gt;as_MemBar();
3279   assert((mb-&gt;_kind == TrailingStore &amp;&amp; _kind == LeadingStore) ||
3280          (mb-&gt;_kind == TrailingLoadStore &amp;&amp; _kind == LeadingLoadStore), &quot;bad trailing membar&quot;);
3281   assert(mb-&gt;_pair_idx == _pair_idx, &quot;bad trailing membar&quot;);
3282   return mb;
3283 }
3284 
3285 MemBarNode* MemBarNode::leading_membar() const {
3286   ResourceMark rm;
3287   VectorSet seen(Thread::current()-&gt;resource_area());
3288   Node_Stack regions(0);
3289   Node* leading = in(0);
3290   while (leading != NULL &amp;&amp; (!leading-&gt;is_MemBar() || !leading-&gt;as_MemBar()-&gt;leading())) {
3291     while (leading == NULL || leading-&gt;is_top() || seen.test_set(leading-&gt;_idx)) {
3292       leading = NULL;
3293       while (regions.size() &gt; 0 &amp;&amp; leading == NULL) {
3294         Node* r = regions.node();
3295         uint i = regions.index();
3296         if (i &lt; r-&gt;req()) {
3297           leading = r-&gt;in(i);
3298           regions.set_index(i+1);
3299         } else {
3300           regions.pop();
3301         }
3302       }
3303       if (leading == NULL) {
3304         assert(regions.size() == 0, &quot;all paths should have been tried&quot;);
3305         return NULL;
3306       }
3307     }
3308     if (leading-&gt;is_Region()) {
3309       regions.push(leading, 2);
3310       leading = leading-&gt;in(1);
3311     } else {
3312       leading = leading-&gt;in(0);
3313     }
3314   }
3315 #ifdef ASSERT
3316   Unique_Node_List wq;
3317   wq.push((Node*)this);
3318   uint found = 0;
3319   for (uint i = 0; i &lt; wq.size(); i++) {
3320     Node* n = wq.at(i);
3321     if (n-&gt;is_Region()) {
3322       for (uint j = 1; j &lt; n-&gt;req(); j++) {
3323         Node* in = n-&gt;in(j);
3324         if (in != NULL &amp;&amp; !in-&gt;is_top()) {
3325           wq.push(in);
3326         }
3327       }
3328     } else {
3329       if (n-&gt;is_MemBar() &amp;&amp; n-&gt;as_MemBar()-&gt;leading()) {
3330         assert(n == leading, &quot;consistency check failed&quot;);
3331         found++;
3332       } else {
3333         Node* in = n-&gt;in(0);
3334         if (in != NULL &amp;&amp; !in-&gt;is_top()) {
3335           wq.push(in);
3336         }
3337       }
3338     }
3339   }
3340   assert(found == 1 || (found == 0 &amp;&amp; leading == NULL), &quot;consistency check failed&quot;);
3341 #endif
3342   if (leading == NULL) {
3343     return NULL;
3344   }
3345   MemBarNode* mb = leading-&gt;as_MemBar();
3346   assert((mb-&gt;_kind == LeadingStore &amp;&amp; _kind == TrailingStore) ||
3347          (mb-&gt;_kind == LeadingLoadStore &amp;&amp; _kind == TrailingLoadStore), &quot;bad leading membar&quot;);
3348   assert(mb-&gt;_pair_idx == _pair_idx, &quot;bad leading membar&quot;);
3349   return mb;
3350 }
3351 
3352 //===========================InitializeNode====================================
3353 // SUMMARY:
3354 // This node acts as a memory barrier on raw memory, after some raw stores.
3355 // The &#39;cooked&#39; oop value feeds from the Initialize, not the Allocation.
3356 // The Initialize can &#39;capture&#39; suitably constrained stores as raw inits.
3357 // It can coalesce related raw stores into larger units (called &#39;tiles&#39;).
3358 // It can avoid zeroing new storage for memory units which have raw inits.
3359 // At macro-expansion, it is marked &#39;complete&#39;, and does not optimize further.
3360 //
3361 // EXAMPLE:
3362 // The object &#39;new short[2]&#39; occupies 16 bytes in a 32-bit machine.
3363 //   ctl = incoming control; mem* = incoming memory
3364 // (Note:  A star * on a memory edge denotes I/O and other standard edges.)
3365 // First allocate uninitialized memory and fill in the header:
3366 //   alloc = (Allocate ctl mem* 16 #short[].klass ...)
3367 //   ctl := alloc.Control; mem* := alloc.Memory*
3368 //   rawmem = alloc.Memory; rawoop = alloc.RawAddress
3369 // Then initialize to zero the non-header parts of the raw memory block:
3370 //   init = (Initialize alloc.Control alloc.Memory* alloc.RawAddress)
3371 //   ctl := init.Control; mem.SLICE(#short[*]) := init.Memory
3372 // After the initialize node executes, the object is ready for service:
3373 //   oop := (CheckCastPP init.Control alloc.RawAddress #short[])
3374 // Suppose its body is immediately initialized as {1,2}:
3375 //   store1 = (StoreC init.Control init.Memory (+ oop 12) 1)
3376 //   store2 = (StoreC init.Control store1      (+ oop 14) 2)
3377 //   mem.SLICE(#short[*]) := store2
3378 //
3379 // DETAILS:
3380 // An InitializeNode collects and isolates object initialization after
3381 // an AllocateNode and before the next possible safepoint.  As a
3382 // memory barrier (MemBarNode), it keeps critical stores from drifting
3383 // down past any safepoint or any publication of the allocation.
3384 // Before this barrier, a newly-allocated object may have uninitialized bits.
3385 // After this barrier, it may be treated as a real oop, and GC is allowed.
3386 //
3387 // The semantics of the InitializeNode include an implicit zeroing of
3388 // the new object from object header to the end of the object.
3389 // (The object header and end are determined by the AllocateNode.)
3390 //
3391 // Certain stores may be added as direct inputs to the InitializeNode.
3392 // These stores must update raw memory, and they must be to addresses
3393 // derived from the raw address produced by AllocateNode, and with
3394 // a constant offset.  They must be ordered by increasing offset.
3395 // The first one is at in(RawStores), the last at in(req()-1).
3396 // Unlike most memory operations, they are not linked in a chain,
3397 // but are displayed in parallel as users of the rawmem output of
3398 // the allocation.
3399 //
3400 // (See comments in InitializeNode::capture_store, which continue
3401 // the example given above.)
3402 //
3403 // When the associated Allocate is macro-expanded, the InitializeNode
3404 // may be rewritten to optimize collected stores.  A ClearArrayNode
3405 // may also be created at that point to represent any required zeroing.
3406 // The InitializeNode is then marked &#39;complete&#39;, prohibiting further
3407 // capturing of nearby memory operations.
3408 //
3409 // During macro-expansion, all captured initializations which store
3410 // constant values of 32 bits or smaller are coalesced (if advantageous)
3411 // into larger &#39;tiles&#39; 32 or 64 bits.  This allows an object to be
3412 // initialized in fewer memory operations.  Memory words which are
3413 // covered by neither tiles nor non-constant stores are pre-zeroed
3414 // by explicit stores of zero.  (The code shape happens to do all
3415 // zeroing first, then all other stores, with both sequences occurring
3416 // in order of ascending offsets.)
3417 //
3418 // Alternatively, code may be inserted between an AllocateNode and its
3419 // InitializeNode, to perform arbitrary initialization of the new object.
3420 // E.g., the object copying intrinsics insert complex data transfers here.
3421 // The initialization must then be marked as &#39;complete&#39; disable the
3422 // built-in zeroing semantics and the collection of initializing stores.
3423 //
3424 // While an InitializeNode is incomplete, reads from the memory state
3425 // produced by it are optimizable if they match the control edge and
3426 // new oop address associated with the allocation/initialization.
3427 // They return a stored value (if the offset matches) or else zero.
3428 // A write to the memory state, if it matches control and address,
3429 // and if it is to a constant offset, may be &#39;captured&#39; by the
3430 // InitializeNode.  It is cloned as a raw memory operation and rewired
3431 // inside the initialization, to the raw oop produced by the allocation.
3432 // Operations on addresses which are provably distinct (e.g., to
3433 // other AllocateNodes) are allowed to bypass the initialization.
3434 //
3435 // The effect of all this is to consolidate object initialization
3436 // (both arrays and non-arrays, both piecewise and bulk) into a
3437 // single location, where it can be optimized as a unit.
3438 //
3439 // Only stores with an offset less than TrackedInitializationLimit words
3440 // will be considered for capture by an InitializeNode.  This puts a
3441 // reasonable limit on the complexity of optimized initializations.
3442 
3443 //---------------------------InitializeNode------------------------------------
3444 InitializeNode::InitializeNode(Compile* C, int adr_type, Node* rawoop)
3445   : MemBarNode(C, adr_type, rawoop),
3446     _is_complete(Incomplete), _does_not_escape(false)
3447 {
3448   init_class_id(Class_Initialize);
3449 
3450   assert(adr_type == Compile::AliasIdxRaw, &quot;only valid atp&quot;);
3451   assert(in(RawAddress) == rawoop, &quot;proper init&quot;);
3452   // Note:  allocation() can be NULL, for secondary initialization barriers
3453 }
3454 
3455 // Since this node is not matched, it will be processed by the
3456 // register allocator.  Declare that there are no constraints
3457 // on the allocation of the RawAddress edge.
3458 const RegMask &amp;InitializeNode::in_RegMask(uint idx) const {
3459   // This edge should be set to top, by the set_complete.  But be conservative.
3460   if (idx == InitializeNode::RawAddress)
3461     return *(Compile::current()-&gt;matcher()-&gt;idealreg2spillmask[in(idx)-&gt;ideal_reg()]);
3462   return RegMask::Empty;
3463 }
3464 
3465 Node* InitializeNode::memory(uint alias_idx) {
3466   Node* mem = in(Memory);
3467   if (mem-&gt;is_MergeMem()) {
3468     return mem-&gt;as_MergeMem()-&gt;memory_at(alias_idx);
3469   } else {
3470     // incoming raw memory is not split
3471     return mem;
3472   }
3473 }
3474 
3475 bool InitializeNode::is_non_zero() {
3476   if (is_complete())  return false;
3477   remove_extra_zeroes();
3478   return (req() &gt; RawStores);
3479 }
3480 
3481 void InitializeNode::set_complete(PhaseGVN* phase) {
3482   assert(!is_complete(), &quot;caller responsibility&quot;);
3483   _is_complete = Complete;
3484 
3485   // After this node is complete, it contains a bunch of
3486   // raw-memory initializations.  There is no need for
3487   // it to have anything to do with non-raw memory effects.
3488   // Therefore, tell all non-raw users to re-optimize themselves,
3489   // after skipping the memory effects of this initialization.
3490   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
3491   if (igvn)  igvn-&gt;add_users_to_worklist(this);
3492 }
3493 
3494 // convenience function
3495 // return false if the init contains any stores already
3496 bool AllocateNode::maybe_set_complete(PhaseGVN* phase) {
3497   InitializeNode* init = initialization();
3498   if (init == NULL || init-&gt;is_complete())  return false;
3499   init-&gt;remove_extra_zeroes();
3500   // for now, if this allocation has already collected any inits, bail:
3501   if (init-&gt;is_non_zero())  return false;
3502   init-&gt;set_complete(phase);
3503   return true;
3504 }
3505 
3506 void InitializeNode::remove_extra_zeroes() {
3507   if (req() == RawStores)  return;
3508   Node* zmem = zero_memory();
3509   uint fill = RawStores;
3510   for (uint i = fill; i &lt; req(); i++) {
3511     Node* n = in(i);
3512     if (n-&gt;is_top() || n == zmem)  continue;  // skip
3513     if (fill &lt; i)  set_req(fill, n);          // compact
3514     ++fill;
3515   }
3516   // delete any empty spaces created:
3517   while (fill &lt; req()) {
3518     del_req(fill);
3519   }
3520 }
3521 
3522 // Helper for remembering which stores go with which offsets.
3523 intptr_t InitializeNode::get_store_offset(Node* st, PhaseTransform* phase) {
3524   if (!st-&gt;is_Store())  return -1;  // can happen to dead code via subsume_node
3525   intptr_t offset = -1;
3526   Node* base = AddPNode::Ideal_base_and_offset(st-&gt;in(MemNode::Address),
3527                                                phase, offset);
3528   if (base == NULL)     return -1;  // something is dead,
3529   if (offset &lt; 0)       return -1;  //        dead, dead
3530   return offset;
3531 }
3532 
3533 // Helper for proving that an initialization expression is
3534 // &quot;simple enough&quot; to be folded into an object initialization.
3535 // Attempts to prove that a store&#39;s initial value &#39;n&#39; can be captured
3536 // within the initialization without creating a vicious cycle, such as:
3537 //     { Foo p = new Foo(); p.next = p; }
3538 // True for constants and parameters and small combinations thereof.
3539 bool InitializeNode::detect_init_independence(Node* value, PhaseGVN* phase) {
3540   ResourceMark rm;
3541   Unique_Node_List worklist;
3542   worklist.push(value);
3543 
3544   uint complexity_limit = 20;
3545   for (uint j = 0; j &lt; worklist.size(); j++) {
3546     if (j &gt;= complexity_limit) {
3547       return false;  // Bail out if processed too many nodes
3548     }
3549 
3550     Node* n = worklist.at(j);
3551     if (n == NULL)      continue;   // (can this really happen?)
3552     if (n-&gt;is_Proj())   n = n-&gt;in(0);
3553     if (n == this)      return false;  // found a cycle
3554     if (n-&gt;is_Con())    continue;
3555     if (n-&gt;is_Start())  continue;   // params, etc., are OK
3556     if (n-&gt;is_Root())   continue;   // even better
3557 
3558     // There cannot be any dependency if &#39;n&#39; is a CFG node that dominates the current allocation
3559     if (n-&gt;is_CFG() &amp;&amp; phase-&gt;is_dominator(n, allocation())) {
3560       continue;
3561     }
3562 
3563     Node* ctl = n-&gt;in(0);
3564     if (ctl != NULL &amp;&amp; !ctl-&gt;is_top()) {
3565       if (ctl-&gt;is_Proj())  ctl = ctl-&gt;in(0);
3566       if (ctl == this)  return false;
3567 
3568       // If we already know that the enclosing memory op is pinned right after
3569       // the init, then any control flow that the store has picked up
3570       // must have preceded the init, or else be equal to the init.
3571       // Even after loop optimizations (which might change control edges)
3572       // a store is never pinned *before* the availability of its inputs.
3573       if (!MemNode::all_controls_dominate(n, this))
3574         return false;                  // failed to prove a good control
3575     }
3576 
3577     // Check data edges for possible dependencies on &#39;this&#39;.
3578     for (uint i = 1; i &lt; n-&gt;req(); i++) {
3579       Node* m = n-&gt;in(i);
3580       if (m == NULL || m == n || m-&gt;is_top())  continue;
3581 
3582       // Only process data inputs once
3583       worklist.push(m);
3584     }
3585   }
3586 
3587   return true;
3588 }
3589 
3590 // Here are all the checks a Store must pass before it can be moved into
3591 // an initialization.  Returns zero if a check fails.
3592 // On success, returns the (constant) offset to which the store applies,
3593 // within the initialized memory.
3594 intptr_t InitializeNode::can_capture_store(StoreNode* st, PhaseGVN* phase, bool can_reshape) {
3595   const int FAIL = 0;
3596   if (st-&gt;req() != MemNode::ValueIn + 1)
3597     return FAIL;                // an inscrutable StoreNode (card mark?)
3598   Node* ctl = st-&gt;in(MemNode::Control);
3599   if (!(ctl != NULL &amp;&amp; ctl-&gt;is_Proj() &amp;&amp; ctl-&gt;in(0) == this))
3600     return FAIL;                // must be unconditional after the initialization
3601   Node* mem = st-&gt;in(MemNode::Memory);
3602   if (!(mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0) == this))
3603     return FAIL;                // must not be preceded by other stores
3604   Node* adr = st-&gt;in(MemNode::Address);
3605   intptr_t offset;
3606   AllocateNode* alloc = AllocateNode::Ideal_allocation(adr, phase, offset);
3607   if (alloc == NULL)
3608     return FAIL;                // inscrutable address
3609   if (alloc != allocation())
3610     return FAIL;                // wrong allocation!  (store needs to float up)
3611   int size_in_bytes = st-&gt;memory_size();
3612   if ((size_in_bytes != 0) &amp;&amp; (offset % size_in_bytes) != 0) {
3613     return FAIL;                // mismatched access
3614   }
3615   Node* val = st-&gt;in(MemNode::ValueIn);
3616 
3617   if (!detect_init_independence(val, phase))
3618     return FAIL;                // stored value must be &#39;simple enough&#39;
3619 
3620   // The Store can be captured only if nothing after the allocation
3621   // and before the Store is using the memory location that the store
3622   // overwrites.
3623   bool failed = false;
3624   // If is_complete_with_arraycopy() is true the shape of the graph is
3625   // well defined and is safe so no need for extra checks.
3626   if (!is_complete_with_arraycopy()) {
3627     // We are going to look at each use of the memory state following
3628     // the allocation to make sure nothing reads the memory that the
3629     // Store writes.
3630     const TypePtr* t_adr = phase-&gt;type(adr)-&gt;isa_ptr();
3631     int alias_idx = phase-&gt;C-&gt;get_alias_index(t_adr);
3632     ResourceMark rm;
3633     Unique_Node_List mems;
3634     mems.push(mem);
3635     Node* unique_merge = NULL;
3636     for (uint next = 0; next &lt; mems.size(); ++next) {
3637       Node *m  = mems.at(next);
3638       for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3639         Node *n = m-&gt;fast_out(j);
3640         if (n-&gt;outcnt() == 0) {
3641           continue;
3642         }
3643         if (n == st) {
3644           continue;
3645         } else if (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0) != ctl) {
3646           // If the control of this use is different from the control
3647           // of the Store which is right after the InitializeNode then
3648           // this node cannot be between the InitializeNode and the
3649           // Store.
3650           continue;
3651         } else if (n-&gt;is_MergeMem()) {
3652           if (n-&gt;as_MergeMem()-&gt;memory_at(alias_idx) == m) {
3653             // We can hit a MergeMemNode (that will likely go away
3654             // later) that is a direct use of the memory state
3655             // following the InitializeNode on the same slice as the
3656             // store node that we&#39;d like to capture. We need to check
3657             // the uses of the MergeMemNode.
3658             mems.push(n);
3659           }
3660         } else if (n-&gt;is_Mem()) {
3661           Node* other_adr = n-&gt;in(MemNode::Address);
3662           if (other_adr == adr) {
3663             failed = true;
3664             break;
3665           } else {
3666             const TypePtr* other_t_adr = phase-&gt;type(other_adr)-&gt;isa_ptr();
3667             if (other_t_adr != NULL) {
3668               int other_alias_idx = phase-&gt;C-&gt;get_alias_index(other_t_adr);
3669               if (other_alias_idx == alias_idx) {
3670                 // A load from the same memory slice as the store right
3671                 // after the InitializeNode. We check the control of the
3672                 // object/array that is loaded from. If it&#39;s the same as
3673                 // the store control then we cannot capture the store.
3674                 assert(!n-&gt;is_Store(), &quot;2 stores to same slice on same control?&quot;);
3675                 Node* base = other_adr;
3676                 assert(base-&gt;is_AddP(), &quot;should be addp but is %s&quot;, base-&gt;Name());
3677                 base = base-&gt;in(AddPNode::Base);
3678                 if (base != NULL) {
3679                   base = base-&gt;uncast();
3680                   if (base-&gt;is_Proj() &amp;&amp; base-&gt;in(0) == alloc) {
3681                     failed = true;
3682                     break;
3683                   }
3684                 }
3685               }
3686             }
3687           }
3688         } else {
3689           failed = true;
3690           break;
3691         }
3692       }
3693     }
3694   }
3695   if (failed) {
3696     if (!can_reshape) {
3697       // We decided we couldn&#39;t capture the store during parsing. We
3698       // should try again during the next IGVN once the graph is
3699       // cleaner.
3700       phase-&gt;C-&gt;record_for_igvn(st);
3701     }
3702     return FAIL;
3703   }
3704 
3705   return offset;                // success
3706 }
3707 
3708 // Find the captured store in(i) which corresponds to the range
3709 // [start..start+size) in the initialized object.
3710 // If there is one, return its index i.  If there isn&#39;t, return the
3711 // negative of the index where it should be inserted.
3712 // Return 0 if the queried range overlaps an initialization boundary
3713 // or if dead code is encountered.
3714 // If size_in_bytes is zero, do not bother with overlap checks.
3715 int InitializeNode::captured_store_insertion_point(intptr_t start,
3716                                                    int size_in_bytes,
3717                                                    PhaseTransform* phase) {
3718   const int FAIL = 0, MAX_STORE = BytesPerLong;
3719 
3720   if (is_complete())
3721     return FAIL;                // arraycopy got here first; punt
3722 
3723   assert(allocation() != NULL, &quot;must be present&quot;);
3724 
3725   // no negatives, no header fields:
3726   if (start &lt; (intptr_t) allocation()-&gt;minimum_header_size())  return FAIL;
3727 
3728   // after a certain size, we bail out on tracking all the stores:
3729   intptr_t ti_limit = (TrackedInitializationLimit * HeapWordSize);
3730   if (start &gt;= ti_limit)  return FAIL;
3731 
3732   for (uint i = InitializeNode::RawStores, limit = req(); ; ) {
3733     if (i &gt;= limit)  return -(int)i; // not found; here is where to put it
3734 
3735     Node*    st     = in(i);
3736     intptr_t st_off = get_store_offset(st, phase);
3737     if (st_off &lt; 0) {
3738       if (st != zero_memory()) {
3739         return FAIL;            // bail out if there is dead garbage
3740       }
3741     } else if (st_off &gt; start) {
3742       // ...we are done, since stores are ordered
3743       if (st_off &lt; start + size_in_bytes) {
3744         return FAIL;            // the next store overlaps
3745       }
3746       return -(int)i;           // not found; here is where to put it
3747     } else if (st_off &lt; start) {
3748       if (size_in_bytes != 0 &amp;&amp;
3749           start &lt; st_off + MAX_STORE &amp;&amp;
3750           start &lt; st_off + st-&gt;as_Store()-&gt;memory_size()) {
3751         return FAIL;            // the previous store overlaps
3752       }
3753     } else {
3754       if (size_in_bytes != 0 &amp;&amp;
3755           st-&gt;as_Store()-&gt;memory_size() != size_in_bytes) {
3756         return FAIL;            // mismatched store size
3757       }
3758       return i;
3759     }
3760 
3761     ++i;
3762   }
3763 }
3764 
3765 // Look for a captured store which initializes at the offset &#39;start&#39;
3766 // with the given size.  If there is no such store, and no other
3767 // initialization interferes, then return zero_memory (the memory
3768 // projection of the AllocateNode).
3769 Node* InitializeNode::find_captured_store(intptr_t start, int size_in_bytes,
3770                                           PhaseTransform* phase) {
3771   assert(stores_are_sane(phase), &quot;&quot;);
3772   int i = captured_store_insertion_point(start, size_in_bytes, phase);
3773   if (i == 0) {
3774     return NULL;                // something is dead
3775   } else if (i &lt; 0) {
3776     return zero_memory();       // just primordial zero bits here
3777   } else {
3778     Node* st = in(i);           // here is the store at this position
3779     assert(get_store_offset(st-&gt;as_Store(), phase) == start, &quot;sanity&quot;);
3780     return st;
3781   }
3782 }
3783 
3784 // Create, as a raw pointer, an address within my new object at &#39;offset&#39;.
3785 Node* InitializeNode::make_raw_address(intptr_t offset,
3786                                        PhaseTransform* phase) {
3787   Node* addr = in(RawAddress);
3788   if (offset != 0) {
3789     Compile* C = phase-&gt;C;
3790     addr = phase-&gt;transform( new AddPNode(C-&gt;top(), addr,
3791                                                  phase-&gt;MakeConX(offset)) );
3792   }
3793   return addr;
3794 }
3795 
3796 // Clone the given store, converting it into a raw store
3797 // initializing a field or element of my new object.
3798 // Caller is responsible for retiring the original store,
3799 // with subsume_node or the like.
3800 //
3801 // From the example above InitializeNode::InitializeNode,
3802 // here are the old stores to be captured:
3803 //   store1 = (StoreC init.Control init.Memory (+ oop 12) 1)
3804 //   store2 = (StoreC init.Control store1      (+ oop 14) 2)
3805 //
3806 // Here is the changed code; note the extra edges on init:
3807 //   alloc = (Allocate ...)
3808 //   rawoop = alloc.RawAddress
3809 //   rawstore1 = (StoreC alloc.Control alloc.Memory (+ rawoop 12) 1)
3810 //   rawstore2 = (StoreC alloc.Control alloc.Memory (+ rawoop 14) 2)
3811 //   init = (Initialize alloc.Control alloc.Memory rawoop
3812 //                      rawstore1 rawstore2)
3813 //
3814 Node* InitializeNode::capture_store(StoreNode* st, intptr_t start,
3815                                     PhaseGVN* phase, bool can_reshape) {
3816   assert(stores_are_sane(phase), &quot;&quot;);
3817 
3818   if (start &lt; 0)  return NULL;
3819   assert(can_capture_store(st, phase, can_reshape) == start, &quot;sanity&quot;);
3820 
3821   Compile* C = phase-&gt;C;
3822   int size_in_bytes = st-&gt;memory_size();
3823   int i = captured_store_insertion_point(start, size_in_bytes, phase);
3824   if (i == 0)  return NULL;     // bail out
3825   Node* prev_mem = NULL;        // raw memory for the captured store
3826   if (i &gt; 0) {
3827     prev_mem = in(i);           // there is a pre-existing store under this one
3828     set_req(i, C-&gt;top());       // temporarily disconnect it
3829     // See StoreNode::Ideal &#39;st-&gt;outcnt() == 1&#39; for the reason to disconnect.
3830   } else {
3831     i = -i;                     // no pre-existing store
3832     prev_mem = zero_memory();   // a slice of the newly allocated object
3833     if (i &gt; InitializeNode::RawStores &amp;&amp; in(i-1) == prev_mem)
3834       set_req(--i, C-&gt;top());   // reuse this edge; it has been folded away
3835     else
3836       ins_req(i, C-&gt;top());     // build a new edge
3837   }
3838   Node* new_st = st-&gt;clone();
3839   new_st-&gt;set_req(MemNode::Control, in(Control));
3840   new_st-&gt;set_req(MemNode::Memory,  prev_mem);
3841   new_st-&gt;set_req(MemNode::Address, make_raw_address(start, phase));
3842   new_st = phase-&gt;transform(new_st);
3843 
3844   // At this point, new_st might have swallowed a pre-existing store
3845   // at the same offset, or perhaps new_st might have disappeared,
3846   // if it redundantly stored the same value (or zero to fresh memory).
3847 
3848   // In any case, wire it in:
3849   phase-&gt;igvn_rehash_node_delayed(this);
3850   set_req(i, new_st);
3851 
3852   // The caller may now kill the old guy.
3853   DEBUG_ONLY(Node* check_st = find_captured_store(start, size_in_bytes, phase));
3854   assert(check_st == new_st || check_st == NULL, &quot;must be findable&quot;);
3855   assert(!is_complete(), &quot;&quot;);
3856   return new_st;
3857 }
3858 
3859 static bool store_constant(jlong* tiles, int num_tiles,
3860                            intptr_t st_off, int st_size,
3861                            jlong con) {
3862   if ((st_off &amp; (st_size-1)) != 0)
3863     return false;               // strange store offset (assume size==2**N)
3864   address addr = (address)tiles + st_off;
3865   assert(st_off &gt;= 0 &amp;&amp; addr+st_size &lt;= (address)&amp;tiles[num_tiles], &quot;oob&quot;);
3866   switch (st_size) {
3867   case sizeof(jbyte):  *(jbyte*) addr = (jbyte) con; break;
3868   case sizeof(jchar):  *(jchar*) addr = (jchar) con; break;
3869   case sizeof(jint):   *(jint*)  addr = (jint)  con; break;
3870   case sizeof(jlong):  *(jlong*) addr = (jlong) con; break;
3871   default: return false;        // strange store size (detect size!=2**N here)
3872   }
3873   return true;                  // return success to caller
3874 }
3875 
3876 // Coalesce subword constants into int constants and possibly
3877 // into long constants.  The goal, if the CPU permits,
3878 // is to initialize the object with a small number of 64-bit tiles.
3879 // Also, convert floating-point constants to bit patterns.
3880 // Non-constants are not relevant to this pass.
3881 //
3882 // In terms of the running example on InitializeNode::InitializeNode
3883 // and InitializeNode::capture_store, here is the transformation
3884 // of rawstore1 and rawstore2 into rawstore12:
3885 //   alloc = (Allocate ...)
3886 //   rawoop = alloc.RawAddress
3887 //   tile12 = 0x00010002
3888 //   rawstore12 = (StoreI alloc.Control alloc.Memory (+ rawoop 12) tile12)
3889 //   init = (Initialize alloc.Control alloc.Memory rawoop rawstore12)
3890 //
3891 void
3892 InitializeNode::coalesce_subword_stores(intptr_t header_size,
3893                                         Node* size_in_bytes,
3894                                         PhaseGVN* phase) {
3895   Compile* C = phase-&gt;C;
3896 
3897   assert(stores_are_sane(phase), &quot;&quot;);
3898   // Note:  After this pass, they are not completely sane,
3899   // since there may be some overlaps.
3900 
3901   int old_subword = 0, old_long = 0, new_int = 0, new_long = 0;
3902 
3903   intptr_t ti_limit = (TrackedInitializationLimit * HeapWordSize);
3904   intptr_t size_limit = phase-&gt;find_intptr_t_con(size_in_bytes, ti_limit);
3905   size_limit = MIN2(size_limit, ti_limit);
3906   size_limit = align_up(size_limit, BytesPerLong);
3907   int num_tiles = size_limit / BytesPerLong;
3908 
3909   // allocate space for the tile map:
3910   const int small_len = DEBUG_ONLY(true ? 3 :) 30; // keep stack frames small
3911   jlong  tiles_buf[small_len];
3912   Node*  nodes_buf[small_len];
3913   jlong  inits_buf[small_len];
3914   jlong* tiles = ((num_tiles &lt;= small_len) ? &amp;tiles_buf[0]
3915                   : NEW_RESOURCE_ARRAY(jlong, num_tiles));
3916   Node** nodes = ((num_tiles &lt;= small_len) ? &amp;nodes_buf[0]
3917                   : NEW_RESOURCE_ARRAY(Node*, num_tiles));
3918   jlong* inits = ((num_tiles &lt;= small_len) ? &amp;inits_buf[0]
3919                   : NEW_RESOURCE_ARRAY(jlong, num_tiles));
3920   // tiles: exact bitwise model of all primitive constants
3921   // nodes: last constant-storing node subsumed into the tiles model
3922   // inits: which bytes (in each tile) are touched by any initializations
3923 
3924   //// Pass A: Fill in the tile model with any relevant stores.
3925 
3926   Copy::zero_to_bytes(tiles, sizeof(tiles[0]) * num_tiles);
3927   Copy::zero_to_bytes(nodes, sizeof(nodes[0]) * num_tiles);
3928   Copy::zero_to_bytes(inits, sizeof(inits[0]) * num_tiles);
3929   Node* zmem = zero_memory(); // initially zero memory state
3930   for (uint i = InitializeNode::RawStores, limit = req(); i &lt; limit; i++) {
3931     Node* st = in(i);
3932     intptr_t st_off = get_store_offset(st, phase);
3933 
3934     // Figure out the store&#39;s offset and constant value:
3935     if (st_off &lt; header_size)             continue; //skip (ignore header)
3936     if (st-&gt;in(MemNode::Memory) != zmem)  continue; //skip (odd store chain)
3937     int st_size = st-&gt;as_Store()-&gt;memory_size();
3938     if (st_off + st_size &gt; size_limit)    break;
3939 
3940     // Record which bytes are touched, whether by constant or not.
3941     if (!store_constant(inits, num_tiles, st_off, st_size, (jlong) -1))
3942       continue;                 // skip (strange store size)
3943 
3944     const Type* val = phase-&gt;type(st-&gt;in(MemNode::ValueIn));
3945     if (!val-&gt;singleton())                continue; //skip (non-con store)
3946     BasicType type = val-&gt;basic_type();
3947 
3948     jlong con = 0;
3949     switch (type) {
3950     case T_INT:    con = val-&gt;is_int()-&gt;get_con();  break;
3951     case T_LONG:   con = val-&gt;is_long()-&gt;get_con(); break;
3952     case T_FLOAT:  con = jint_cast(val-&gt;getf());    break;
3953     case T_DOUBLE: con = jlong_cast(val-&gt;getd());   break;
3954     default:                              continue; //skip (odd store type)
3955     }
3956 
3957     if (type == T_LONG &amp;&amp; Matcher::isSimpleConstant64(con) &amp;&amp;
3958         st-&gt;Opcode() == Op_StoreL) {
3959       continue;                 // This StoreL is already optimal.
3960     }
3961 
3962     // Store down the constant.
3963     store_constant(tiles, num_tiles, st_off, st_size, con);
3964 
3965     intptr_t j = st_off &gt;&gt; LogBytesPerLong;
3966 
3967     if (type == T_INT &amp;&amp; st_size == BytesPerInt
3968         &amp;&amp; (st_off &amp; BytesPerInt) == BytesPerInt) {
3969       jlong lcon = tiles[j];
3970       if (!Matcher::isSimpleConstant64(lcon) &amp;&amp;
3971           st-&gt;Opcode() == Op_StoreI) {
3972         // This StoreI is already optimal by itself.
3973         jint* intcon = (jint*) &amp;tiles[j];
3974         intcon[1] = 0;  // undo the store_constant()
3975 
3976         // If the previous store is also optimal by itself, back up and
3977         // undo the action of the previous loop iteration... if we can.
3978         // But if we can&#39;t, just let the previous half take care of itself.
3979         st = nodes[j];
3980         st_off -= BytesPerInt;
3981         con = intcon[0];
3982         if (con != 0 &amp;&amp; st != NULL &amp;&amp; st-&gt;Opcode() == Op_StoreI) {
3983           assert(st_off &gt;= header_size, &quot;still ignoring header&quot;);
3984           assert(get_store_offset(st, phase) == st_off, &quot;must be&quot;);
3985           assert(in(i-1) == zmem, &quot;must be&quot;);
3986           DEBUG_ONLY(const Type* tcon = phase-&gt;type(st-&gt;in(MemNode::ValueIn)));
3987           assert(con == tcon-&gt;is_int()-&gt;get_con(), &quot;must be&quot;);
3988           // Undo the effects of the previous loop trip, which swallowed st:
3989           intcon[0] = 0;        // undo store_constant()
3990           set_req(i-1, st);     // undo set_req(i, zmem)
3991           nodes[j] = NULL;      // undo nodes[j] = st
3992           --old_subword;        // undo ++old_subword
3993         }
3994         continue;               // This StoreI is already optimal.
3995       }
3996     }
3997 
3998     // This store is not needed.
3999     set_req(i, zmem);
4000     nodes[j] = st;              // record for the moment
4001     if (st_size &lt; BytesPerLong) // something has changed
4002           ++old_subword;        // includes int/float, but who&#39;s counting...
4003     else  ++old_long;
4004   }
4005 
4006   if ((old_subword + old_long) == 0)
4007     return;                     // nothing more to do
4008 
4009   //// Pass B: Convert any non-zero tiles into optimal constant stores.
4010   // Be sure to insert them before overlapping non-constant stores.
4011   // (E.g., byte[] x = { 1,2,y,4 }  =&gt;  x[int 0] = 0x01020004, x[2]=y.)
4012   for (int j = 0; j &lt; num_tiles; j++) {
4013     jlong con  = tiles[j];
4014     jlong init = inits[j];
4015     if (con == 0)  continue;
4016     jint con0,  con1;           // split the constant, address-wise
4017     jint init0, init1;          // split the init map, address-wise
4018     { union { jlong con; jint intcon[2]; } u;
4019       u.con = con;
4020       con0  = u.intcon[0];
4021       con1  = u.intcon[1];
4022       u.con = init;
4023       init0 = u.intcon[0];
4024       init1 = u.intcon[1];
4025     }
4026 
4027     Node* old = nodes[j];
4028     assert(old != NULL, &quot;need the prior store&quot;);
4029     intptr_t offset = (j * BytesPerLong);
4030 
4031     bool split = !Matcher::isSimpleConstant64(con);
4032 
4033     if (offset &lt; header_size) {
4034       assert(offset + BytesPerInt &gt;= header_size, &quot;second int counts&quot;);
4035       assert(*(jint*)&amp;tiles[j] == 0, &quot;junk in header&quot;);
4036       split = true;             // only the second word counts
4037       // Example:  int a[] = { 42 ... }
4038     } else if (con0 == 0 &amp;&amp; init0 == -1) {
4039       split = true;             // first word is covered by full inits
4040       // Example:  int a[] = { ... foo(), 42 ... }
4041     } else if (con1 == 0 &amp;&amp; init1 == -1) {
4042       split = true;             // second word is covered by full inits
4043       // Example:  int a[] = { ... 42, foo() ... }
4044     }
4045 
4046     // Here&#39;s a case where init0 is neither 0 nor -1:
4047     //   byte a[] = { ... 0,0,foo(),0,  0,0,0,42 ... }
4048     // Assuming big-endian memory, init0, init1 are 0x0000FF00, 0x000000FF.
4049     // In this case the tile is not split; it is (jlong)42.
4050     // The big tile is stored down, and then the foo() value is inserted.
4051     // (If there were foo(),foo() instead of foo(),0, init0 would be -1.)
4052 
4053     Node* ctl = old-&gt;in(MemNode::Control);
4054     Node* adr = make_raw_address(offset, phase);
4055     const TypePtr* atp = TypeRawPtr::BOTTOM;
4056 
4057     // One or two coalesced stores to plop down.
4058     Node*    st[2];
4059     intptr_t off[2];
4060     int  nst = 0;
4061     if (!split) {
4062       ++new_long;
4063       off[nst] = offset;
4064       st[nst++] = StoreNode::make(*phase, ctl, zmem, adr, atp,
4065                                   phase-&gt;longcon(con), T_LONG, MemNode::unordered);
4066     } else {
4067       // Omit either if it is a zero.
4068       if (con0 != 0) {
4069         ++new_int;
4070         off[nst]  = offset;
4071         st[nst++] = StoreNode::make(*phase, ctl, zmem, adr, atp,
4072                                     phase-&gt;intcon(con0), T_INT, MemNode::unordered);
4073       }
4074       if (con1 != 0) {
4075         ++new_int;
4076         offset += BytesPerInt;
4077         adr = make_raw_address(offset, phase);
4078         off[nst]  = offset;
4079         st[nst++] = StoreNode::make(*phase, ctl, zmem, adr, atp,
4080                                     phase-&gt;intcon(con1), T_INT, MemNode::unordered);
4081       }
4082     }
4083 
4084     // Insert second store first, then the first before the second.
4085     // Insert each one just before any overlapping non-constant stores.
4086     while (nst &gt; 0) {
4087       Node* st1 = st[--nst];
4088       C-&gt;copy_node_notes_to(st1, old);
4089       st1 = phase-&gt;transform(st1);
4090       offset = off[nst];
4091       assert(offset &gt;= header_size, &quot;do not smash header&quot;);
4092       int ins_idx = captured_store_insertion_point(offset, /*size:*/0, phase);
4093       guarantee(ins_idx != 0, &quot;must re-insert constant store&quot;);
4094       if (ins_idx &lt; 0)  ins_idx = -ins_idx;  // never overlap
4095       if (ins_idx &gt; InitializeNode::RawStores &amp;&amp; in(ins_idx-1) == zmem)
4096         set_req(--ins_idx, st1);
4097       else
4098         ins_req(ins_idx, st1);
4099     }
4100   }
4101 
4102   if (PrintCompilation &amp;&amp; WizardMode)
4103     tty-&gt;print_cr(&quot;Changed %d/%d subword/long constants into %d/%d int/long&quot;,
4104                   old_subword, old_long, new_int, new_long);
4105   if (C-&gt;log() != NULL)
4106     C-&gt;log()-&gt;elem(&quot;comment that=&#39;%d/%d subword/long to %d/%d int/long&#39;&quot;,
4107                    old_subword, old_long, new_int, new_long);
4108 
4109   // Clean up any remaining occurrences of zmem:
4110   remove_extra_zeroes();
4111 }
4112 
4113 // Explore forward from in(start) to find the first fully initialized
4114 // word, and return its offset.  Skip groups of subword stores which
4115 // together initialize full words.  If in(start) is itself part of a
4116 // fully initialized word, return the offset of in(start).  If there
4117 // are no following full-word stores, or if something is fishy, return
4118 // a negative value.
4119 intptr_t InitializeNode::find_next_fullword_store(uint start, PhaseGVN* phase) {
4120   int       int_map = 0;
4121   intptr_t  int_map_off = 0;
4122   const int FULL_MAP = right_n_bits(BytesPerInt);  // the int_map we hope for
4123 
4124   for (uint i = start, limit = req(); i &lt; limit; i++) {
4125     Node* st = in(i);
4126 
4127     intptr_t st_off = get_store_offset(st, phase);
4128     if (st_off &lt; 0)  break;  // return conservative answer
4129 
4130     int st_size = st-&gt;as_Store()-&gt;memory_size();
4131     if (st_size &gt;= BytesPerInt &amp;&amp; (st_off % BytesPerInt) == 0) {
4132       return st_off;            // we found a complete word init
4133     }
4134 
4135     // update the map:
4136 
4137     intptr_t this_int_off = align_down(st_off, BytesPerInt);
4138     if (this_int_off != int_map_off) {
4139       // reset the map:
4140       int_map = 0;
4141       int_map_off = this_int_off;
4142     }
4143 
4144     int subword_off = st_off - this_int_off;
4145     int_map |= right_n_bits(st_size) &lt;&lt; subword_off;
4146     if ((int_map &amp; FULL_MAP) == FULL_MAP) {
4147       return this_int_off;      // we found a complete word init
4148     }
4149 
4150     // Did this store hit or cross the word boundary?
4151     intptr_t next_int_off = align_down(st_off + st_size, BytesPerInt);
4152     if (next_int_off == this_int_off + BytesPerInt) {
4153       // We passed the current int, without fully initializing it.
4154       int_map_off = next_int_off;
4155       int_map &gt;&gt;= BytesPerInt;
4156     } else if (next_int_off &gt; this_int_off + BytesPerInt) {
4157       // We passed the current and next int.
4158       return this_int_off + BytesPerInt;
4159     }
4160   }
4161 
4162   return -1;
4163 }
4164 
4165 
4166 // Called when the associated AllocateNode is expanded into CFG.
4167 // At this point, we may perform additional optimizations.
4168 // Linearize the stores by ascending offset, to make memory
4169 // activity as coherent as possible.
4170 Node* InitializeNode::complete_stores(Node* rawctl, Node* rawmem, Node* rawptr,
4171                                       intptr_t header_size,
4172                                       Node* size_in_bytes,
4173                                       PhaseIterGVN* phase) {
4174   assert(!is_complete(), &quot;not already complete&quot;);
4175   assert(stores_are_sane(phase), &quot;&quot;);
4176   assert(allocation() != NULL, &quot;must be present&quot;);
4177 
4178   remove_extra_zeroes();
4179 
4180   if (ReduceFieldZeroing || ReduceBulkZeroing)
4181     // reduce instruction count for common initialization patterns
4182     coalesce_subword_stores(header_size, size_in_bytes, phase);
4183 
4184   Node* zmem = zero_memory();   // initially zero memory state
4185   Node* inits = zmem;           // accumulating a linearized chain of inits
4186   #ifdef ASSERT
4187   intptr_t first_offset = allocation()-&gt;minimum_header_size();
4188   intptr_t last_init_off = first_offset;  // previous init offset
4189   intptr_t last_init_end = first_offset;  // previous init offset+size
4190   intptr_t last_tile_end = first_offset;  // previous tile offset+size
4191   #endif
4192   intptr_t zeroes_done = header_size;
4193 
4194   bool do_zeroing = true;       // we might give up if inits are very sparse
4195   int  big_init_gaps = 0;       // how many large gaps have we seen?
4196 
4197   if (UseTLAB &amp;&amp; ZeroTLAB)  do_zeroing = false;
4198   if (!ReduceFieldZeroing &amp;&amp; !ReduceBulkZeroing)  do_zeroing = false;
4199 
4200   for (uint i = InitializeNode::RawStores, limit = req(); i &lt; limit; i++) {
4201     Node* st = in(i);
4202     intptr_t st_off = get_store_offset(st, phase);
4203     if (st_off &lt; 0)
4204       break;                    // unknown junk in the inits
4205     if (st-&gt;in(MemNode::Memory) != zmem)
4206       break;                    // complicated store chains somehow in list
4207 
4208     int st_size = st-&gt;as_Store()-&gt;memory_size();
4209     intptr_t next_init_off = st_off + st_size;
4210 
4211     if (do_zeroing &amp;&amp; zeroes_done &lt; next_init_off) {
4212       // See if this store needs a zero before it or under it.
4213       intptr_t zeroes_needed = st_off;
4214 
4215       if (st_size &lt; BytesPerInt) {
4216         // Look for subword stores which only partially initialize words.
4217         // If we find some, we must lay down some word-level zeroes first,
4218         // underneath the subword stores.
4219         //
4220         // Examples:
4221         //   byte[] a = { p,q,r,s }  =&gt;  a[0]=p,a[1]=q,a[2]=r,a[3]=s
4222         //   byte[] a = { x,y,0,0 }  =&gt;  a[0..3] = 0, a[0]=x,a[1]=y
4223         //   byte[] a = { 0,0,z,0 }  =&gt;  a[0..3] = 0, a[2]=z
4224         //
4225         // Note:  coalesce_subword_stores may have already done this,
4226         // if it was prompted by constant non-zero subword initializers.
4227         // But this case can still arise with non-constant stores.
4228 
4229         intptr_t next_full_store = find_next_fullword_store(i, phase);
4230 
4231         // In the examples above:
4232         //   in(i)          p   q   r   s     x   y     z
4233         //   st_off        12  13  14  15    12  13    14
4234         //   st_size        1   1   1   1     1   1     1
4235         //   next_full_s.  12  16  16  16    16  16    16
4236         //   z&#39;s_done      12  16  16  16    12  16    12
4237         //   z&#39;s_needed    12  16  16  16    16  16    16
4238         //   zsize          0   0   0   0     4   0     4
4239         if (next_full_store &lt; 0) {
4240           // Conservative tack:  Zero to end of current word.
4241           zeroes_needed = align_up(zeroes_needed, BytesPerInt);
4242         } else {
4243           // Zero to beginning of next fully initialized word.
4244           // Or, don&#39;t zero at all, if we are already in that word.
4245           assert(next_full_store &gt;= zeroes_needed, &quot;must go forward&quot;);
4246           assert((next_full_store &amp; (BytesPerInt-1)) == 0, &quot;even boundary&quot;);
4247           zeroes_needed = next_full_store;
4248         }
4249       }
4250 
4251       if (zeroes_needed &gt; zeroes_done) {
4252         intptr_t zsize = zeroes_needed - zeroes_done;
4253         // Do some incremental zeroing on rawmem, in parallel with inits.
4254         zeroes_done = align_down(zeroes_done, BytesPerInt);
4255         rawmem = ClearArrayNode::clear_memory(rawctl, rawmem, rawptr,
4256                                               zeroes_done, zeroes_needed,
4257                                               phase);
4258         zeroes_done = zeroes_needed;
4259         if (zsize &gt; InitArrayShortSize &amp;&amp; ++big_init_gaps &gt; 2)
4260           do_zeroing = false;   // leave the hole, next time
4261       }
4262     }
4263 
4264     // Collect the store and move on:
4265     phase-&gt;replace_input_of(st, MemNode::Memory, inits);
4266     inits = st;                 // put it on the linearized chain
4267     set_req(i, zmem);           // unhook from previous position
4268 
4269     if (zeroes_done == st_off)
4270       zeroes_done = next_init_off;
4271 
4272     assert(!do_zeroing || zeroes_done &gt;= next_init_off, &quot;don&#39;t miss any&quot;);
4273 
4274     #ifdef ASSERT
4275     // Various order invariants.  Weaker than stores_are_sane because
4276     // a large constant tile can be filled in by smaller non-constant stores.
4277     assert(st_off &gt;= last_init_off, &quot;inits do not reverse&quot;);
4278     last_init_off = st_off;
4279     const Type* val = NULL;
4280     if (st_size &gt;= BytesPerInt &amp;&amp;
4281         (val = phase-&gt;type(st-&gt;in(MemNode::ValueIn)))-&gt;singleton() &amp;&amp;
4282         (int)val-&gt;basic_type() &lt; (int)T_OBJECT) {
4283       assert(st_off &gt;= last_tile_end, &quot;tiles do not overlap&quot;);
4284       assert(st_off &gt;= last_init_end, &quot;tiles do not overwrite inits&quot;);
4285       last_tile_end = MAX2(last_tile_end, next_init_off);
4286     } else {
4287       intptr_t st_tile_end = align_up(next_init_off, BytesPerLong);
4288       assert(st_tile_end &gt;= last_tile_end, &quot;inits stay with tiles&quot;);
4289       assert(st_off      &gt;= last_init_end, &quot;inits do not overlap&quot;);
4290       last_init_end = next_init_off;  // it&#39;s a non-tile
4291     }
4292     #endif //ASSERT
4293   }
4294 
4295   remove_extra_zeroes();        // clear out all the zmems left over
4296   add_req(inits);
4297 
4298   if (!(UseTLAB &amp;&amp; ZeroTLAB)) {
4299     // If anything remains to be zeroed, zero it all now.
4300     zeroes_done = align_down(zeroes_done, BytesPerInt);
4301     // if it is the last unused 4 bytes of an instance, forget about it
4302     intptr_t size_limit = phase-&gt;find_intptr_t_con(size_in_bytes, max_jint);
4303     if (zeroes_done + BytesPerLong &gt;= size_limit) {
4304       AllocateNode* alloc = allocation();
4305       assert(alloc != NULL, &quot;must be present&quot;);
4306       if (alloc != NULL &amp;&amp; alloc-&gt;Opcode() == Op_Allocate) {
4307         Node* klass_node = alloc-&gt;in(AllocateNode::KlassNode);
4308         ciKlass* k = phase-&gt;type(klass_node)-&gt;is_klassptr()-&gt;klass();
4309         if (zeroes_done == k-&gt;layout_helper())
4310           zeroes_done = size_limit;
4311       }
4312     }
4313     if (zeroes_done &lt; size_limit) {
4314       rawmem = ClearArrayNode::clear_memory(rawctl, rawmem, rawptr,
4315                                             zeroes_done, size_in_bytes, phase);
4316     }
4317   }
4318 
4319   set_complete(phase);
4320   return rawmem;
4321 }
4322 
4323 
4324 #ifdef ASSERT
4325 bool InitializeNode::stores_are_sane(PhaseTransform* phase) {
4326   if (is_complete())
4327     return true;                // stores could be anything at this point
4328   assert(allocation() != NULL, &quot;must be present&quot;);
4329   intptr_t last_off = allocation()-&gt;minimum_header_size();
4330   for (uint i = InitializeNode::RawStores; i &lt; req(); i++) {
4331     Node* st = in(i);
4332     intptr_t st_off = get_store_offset(st, phase);
4333     if (st_off &lt; 0)  continue;  // ignore dead garbage
4334     if (last_off &gt; st_off) {
4335       tty-&gt;print_cr(&quot;*** bad store offset at %d: &quot; INTX_FORMAT &quot; &gt; &quot; INTX_FORMAT, i, last_off, st_off);
4336       this-&gt;dump(2);
4337       assert(false, &quot;ascending store offsets&quot;);
4338       return false;
4339     }
4340     last_off = st_off + st-&gt;as_Store()-&gt;memory_size();
4341   }
4342   return true;
4343 }
4344 #endif //ASSERT
4345 
4346 
4347 
4348 
4349 //============================MergeMemNode=====================================
4350 //
4351 // SEMANTICS OF MEMORY MERGES:  A MergeMem is a memory state assembled from several
4352 // contributing store or call operations.  Each contributor provides the memory
4353 // state for a particular &quot;alias type&quot; (see Compile::alias_type).  For example,
4354 // if a MergeMem has an input X for alias category #6, then any memory reference
4355 // to alias category #6 may use X as its memory state input, as an exact equivalent
4356 // to using the MergeMem as a whole.
4357 //   Load&lt;6&gt;( MergeMem(&lt;6&gt;: X, ...), p ) &lt;==&gt; Load&lt;6&gt;(X,p)
4358 //
4359 // (Here, the &lt;N&gt; notation gives the index of the relevant adr_type.)
4360 //
4361 // In one special case (and more cases in the future), alias categories overlap.
4362 // The special alias category &quot;Bot&quot; (Compile::AliasIdxBot) includes all memory
4363 // states.  Therefore, if a MergeMem has only one contributing input W for Bot,
4364 // it is exactly equivalent to that state W:
4365 //   MergeMem(&lt;Bot&gt;: W) &lt;==&gt; W
4366 //
4367 // Usually, the merge has more than one input.  In that case, where inputs
4368 // overlap (i.e., one is Bot), the narrower alias type determines the memory
4369 // state for that type, and the wider alias type (Bot) fills in everywhere else:
4370 //   Load&lt;5&gt;( MergeMem(&lt;Bot&gt;: W, &lt;6&gt;: X), p ) &lt;==&gt; Load&lt;5&gt;(W,p)
4371 //   Load&lt;6&gt;( MergeMem(&lt;Bot&gt;: W, &lt;6&gt;: X), p ) &lt;==&gt; Load&lt;6&gt;(X,p)
4372 //
4373 // A merge can take a &quot;wide&quot; memory state as one of its narrow inputs.
4374 // This simply means that the merge observes out only the relevant parts of
4375 // the wide input.  That is, wide memory states arriving at narrow merge inputs
4376 // are implicitly &quot;filtered&quot; or &quot;sliced&quot; as necessary.  (This is rare.)
4377 //
4378 // These rules imply that MergeMem nodes may cascade (via their &lt;Bot&gt; links),
4379 // and that memory slices &quot;leak through&quot;:
4380 //   MergeMem(&lt;Bot&gt;: MergeMem(&lt;Bot&gt;: W, &lt;7&gt;: Y)) &lt;==&gt; MergeMem(&lt;Bot&gt;: W, &lt;7&gt;: Y)
4381 //
4382 // But, in such a cascade, repeated memory slices can &quot;block the leak&quot;:
4383 //   MergeMem(&lt;Bot&gt;: MergeMem(&lt;Bot&gt;: W, &lt;7&gt;: Y), &lt;7&gt;: Y&#39;) &lt;==&gt; MergeMem(&lt;Bot&gt;: W, &lt;7&gt;: Y&#39;)
4384 //
4385 // In the last example, Y is not part of the combined memory state of the
4386 // outermost MergeMem.  The system must, of course, prevent unschedulable
4387 // memory states from arising, so you can be sure that the state Y is somehow
4388 // a precursor to state Y&#39;.
4389 //
4390 //
4391 // REPRESENTATION OF MEMORY MERGES: The indexes used to address the Node::in array
4392 // of each MergeMemNode array are exactly the numerical alias indexes, including
4393 // but not limited to AliasIdxTop, AliasIdxBot, and AliasIdxRaw.  The functions
4394 // Compile::alias_type (and kin) produce and manage these indexes.
4395 //
4396 // By convention, the value of in(AliasIdxTop) (i.e., in(1)) is always the top node.
4397 // (Note that this provides quick access to the top node inside MergeMem methods,
4398 // without the need to reach out via TLS to Compile::current.)
4399 //
4400 // As a consequence of what was just described, a MergeMem that represents a full
4401 // memory state has an edge in(AliasIdxBot) which is a &quot;wide&quot; memory state,
4402 // containing all alias categories.
4403 //
4404 // MergeMem nodes never (?) have control inputs, so in(0) is NULL.
4405 //
4406 // All other edges in(N) (including in(AliasIdxRaw), which is in(3)) are either
4407 // a memory state for the alias type &lt;N&gt;, or else the top node, meaning that
4408 // there is no particular input for that alias type.  Note that the length of
4409 // a MergeMem is variable, and may be extended at any time to accommodate new
4410 // memory states at larger alias indexes.  When merges grow, they are of course
4411 // filled with &quot;top&quot; in the unused in() positions.
4412 //
4413 // This use of top is named &quot;empty_memory()&quot;, or &quot;empty_mem&quot; (no-memory) as a variable.
4414 // (Top was chosen because it works smoothly with passes like GCM.)
4415 //
4416 // For convenience, we hardwire the alias index for TypeRawPtr::BOTTOM.  (It is
4417 // the type of random VM bits like TLS references.)  Since it is always the
4418 // first non-Bot memory slice, some low-level loops use it to initialize an
4419 // index variable:  for (i = AliasIdxRaw; i &lt; req(); i++).
4420 //
4421 //
4422 // ACCESSORS:  There is a special accessor MergeMemNode::base_memory which returns
4423 // the distinguished &quot;wide&quot; state.  The accessor MergeMemNode::memory_at(N) returns
4424 // the memory state for alias type &lt;N&gt;, or (if there is no particular slice at &lt;N&gt;,
4425 // it returns the base memory.  To prevent bugs, memory_at does not accept &lt;Top&gt;
4426 // or &lt;Bot&gt; indexes.  The iterator MergeMemStream provides robust iteration over
4427 // MergeMem nodes or pairs of such nodes, ensuring that the non-top edges are visited.
4428 //
4429 // %%%% We may get rid of base_memory as a separate accessor at some point; it isn&#39;t
4430 // really that different from the other memory inputs.  An abbreviation called
4431 // &quot;bot_memory()&quot; for &quot;memory_at(AliasIdxBot)&quot; would keep code tidy.
4432 //
4433 //
4434 // PARTIAL MEMORY STATES:  During optimization, MergeMem nodes may arise that represent
4435 // partial memory states.  When a Phi splits through a MergeMem, the copy of the Phi
4436 // that &quot;emerges though&quot; the base memory will be marked as excluding the alias types
4437 // of the other (narrow-memory) copies which &quot;emerged through&quot; the narrow edges:
4438 //
4439 //   Phi&lt;Bot&gt;(U, MergeMem(&lt;Bot&gt;: W, &lt;8&gt;: Y))
4440 //     ==Ideal=&gt;  MergeMem(&lt;Bot&gt;: Phi&lt;Bot-8&gt;(U, W), Phi&lt;8&gt;(U, Y))
4441 //
4442 // This strange &quot;subtraction&quot; effect is necessary to ensure IGVN convergence.
4443 // (It is currently unimplemented.)  As you can see, the resulting merge is
4444 // actually a disjoint union of memory states, rather than an overlay.
4445 //
4446 
4447 //------------------------------MergeMemNode-----------------------------------
4448 Node* MergeMemNode::make_empty_memory() {
4449   Node* empty_memory = (Node*) Compile::current()-&gt;top();
4450   assert(empty_memory-&gt;is_top(), &quot;correct sentinel identity&quot;);
4451   return empty_memory;
4452 }
4453 
4454 MergeMemNode::MergeMemNode(Node *new_base) : Node(1+Compile::AliasIdxRaw) {
4455   init_class_id(Class_MergeMem);
4456   // all inputs are nullified in Node::Node(int)
4457   // set_input(0, NULL);  // no control input
4458 
4459   // Initialize the edges uniformly to top, for starters.
4460   Node* empty_mem = make_empty_memory();
4461   for (uint i = Compile::AliasIdxTop; i &lt; req(); i++) {
4462     init_req(i,empty_mem);
4463   }
4464   assert(empty_memory() == empty_mem, &quot;&quot;);
4465 
4466   if( new_base != NULL &amp;&amp; new_base-&gt;is_MergeMem() ) {
4467     MergeMemNode* mdef = new_base-&gt;as_MergeMem();
4468     assert(mdef-&gt;empty_memory() == empty_mem, &quot;consistent sentinels&quot;);
4469     for (MergeMemStream mms(this, mdef); mms.next_non_empty2(); ) {
4470       mms.set_memory(mms.memory2());
4471     }
4472     assert(base_memory() == mdef-&gt;base_memory(), &quot;&quot;);
4473   } else {
4474     set_base_memory(new_base);
4475   }
4476 }
4477 
4478 // Make a new, untransformed MergeMem with the same base as &#39;mem&#39;.
4479 // If mem is itself a MergeMem, populate the result with the same edges.
4480 MergeMemNode* MergeMemNode::make(Node* mem) {
4481   return new MergeMemNode(mem);
4482 }
4483 
4484 //------------------------------cmp--------------------------------------------
4485 uint MergeMemNode::hash() const { return NO_HASH; }
4486 bool MergeMemNode::cmp( const Node &amp;n ) const {
4487   return (&amp;n == this);          // Always fail except on self
4488 }
4489 
4490 //------------------------------Identity---------------------------------------
4491 Node* MergeMemNode::Identity(PhaseGVN* phase) {
4492   // Identity if this merge point does not record any interesting memory
4493   // disambiguations.
4494   Node* base_mem = base_memory();
4495   Node* empty_mem = empty_memory();
4496   if (base_mem != empty_mem) {  // Memory path is not dead?
4497     for (uint i = Compile::AliasIdxRaw; i &lt; req(); i++) {
4498       Node* mem = in(i);
4499       if (mem != empty_mem &amp;&amp; mem != base_mem) {
4500         return this;            // Many memory splits; no change
4501       }
4502     }
4503   }
4504   return base_mem;              // No memory splits; ID on the one true input
4505 }
4506 
4507 //------------------------------Ideal------------------------------------------
4508 // This method is invoked recursively on chains of MergeMem nodes
4509 Node *MergeMemNode::Ideal(PhaseGVN *phase, bool can_reshape) {
4510   // Remove chain&#39;d MergeMems
4511   //
4512   // This is delicate, because the each &quot;in(i)&quot; (i &gt;= Raw) is interpreted
4513   // relative to the &quot;in(Bot)&quot;.  Since we are patching both at the same time,
4514   // we have to be careful to read each &quot;in(i)&quot; relative to the old &quot;in(Bot)&quot;,
4515   // but rewrite each &quot;in(i)&quot; relative to the new &quot;in(Bot)&quot;.
4516   Node *progress = NULL;
4517 
4518 
4519   Node* old_base = base_memory();
4520   Node* empty_mem = empty_memory();
4521   if (old_base == empty_mem)
4522     return NULL; // Dead memory path.
4523 
4524   MergeMemNode* old_mbase;
4525   if (old_base != NULL &amp;&amp; old_base-&gt;is_MergeMem())
4526     old_mbase = old_base-&gt;as_MergeMem();
4527   else
4528     old_mbase = NULL;
4529   Node* new_base = old_base;
4530 
4531   // simplify stacked MergeMems in base memory
4532   if (old_mbase)  new_base = old_mbase-&gt;base_memory();
4533 
4534   // the base memory might contribute new slices beyond my req()
4535   if (old_mbase)  grow_to_match(old_mbase);
4536 
4537   // Look carefully at the base node if it is a phi.
4538   PhiNode* phi_base;
4539   if (new_base != NULL &amp;&amp; new_base-&gt;is_Phi())
4540     phi_base = new_base-&gt;as_Phi();
4541   else
4542     phi_base = NULL;
4543 
4544   Node*    phi_reg = NULL;
4545   uint     phi_len = (uint)-1;
4546   if (phi_base != NULL &amp;&amp; !phi_base-&gt;is_copy()) {
4547     // do not examine phi if degraded to a copy
4548     phi_reg = phi_base-&gt;region();
4549     phi_len = phi_base-&gt;req();
4550     // see if the phi is unfinished
4551     for (uint i = 1; i &lt; phi_len; i++) {
4552       if (phi_base-&gt;in(i) == NULL) {
4553         // incomplete phi; do not look at it yet!
4554         phi_reg = NULL;
4555         phi_len = (uint)-1;
4556         break;
4557       }
4558     }
4559   }
4560 
4561   // Note:  We do not call verify_sparse on entry, because inputs
4562   // can normalize to the base_memory via subsume_node or similar
4563   // mechanisms.  This method repairs that damage.
4564 
4565   assert(!old_mbase || old_mbase-&gt;is_empty_memory(empty_mem), &quot;consistent sentinels&quot;);
4566 
4567   // Look at each slice.
4568   for (uint i = Compile::AliasIdxRaw; i &lt; req(); i++) {
4569     Node* old_in = in(i);
4570     // calculate the old memory value
4571     Node* old_mem = old_in;
4572     if (old_mem == empty_mem)  old_mem = old_base;
4573     assert(old_mem == memory_at(i), &quot;&quot;);
4574 
4575     // maybe update (reslice) the old memory value
4576 
4577     // simplify stacked MergeMems
4578     Node* new_mem = old_mem;
4579     MergeMemNode* old_mmem;
4580     if (old_mem != NULL &amp;&amp; old_mem-&gt;is_MergeMem())
4581       old_mmem = old_mem-&gt;as_MergeMem();
4582     else
4583       old_mmem = NULL;
4584     if (old_mmem == this) {
4585       // This can happen if loops break up and safepoints disappear.
4586       // A merge of BotPtr (default) with a RawPtr memory derived from a
4587       // safepoint can be rewritten to a merge of the same BotPtr with
4588       // the BotPtr phi coming into the loop.  If that phi disappears
4589       // also, we can end up with a self-loop of the mergemem.
4590       // In general, if loops degenerate and memory effects disappear,
4591       // a mergemem can be left looking at itself.  This simply means
4592       // that the mergemem&#39;s default should be used, since there is
4593       // no longer any apparent effect on this slice.
4594       // Note: If a memory slice is a MergeMem cycle, it is unreachable
4595       //       from start.  Update the input to TOP.
4596       new_mem = (new_base == this || new_base == empty_mem)? empty_mem : new_base;
4597     }
4598     else if (old_mmem != NULL) {
4599       new_mem = old_mmem-&gt;memory_at(i);
4600     }
4601     // else preceding memory was not a MergeMem
4602 
4603     // replace equivalent phis (unfortunately, they do not GVN together)
4604     if (new_mem != NULL &amp;&amp; new_mem != new_base &amp;&amp;
4605         new_mem-&gt;req() == phi_len &amp;&amp; new_mem-&gt;in(0) == phi_reg) {
4606       if (new_mem-&gt;is_Phi()) {
4607         PhiNode* phi_mem = new_mem-&gt;as_Phi();
4608         for (uint i = 1; i &lt; phi_len; i++) {
4609           if (phi_base-&gt;in(i) != phi_mem-&gt;in(i)) {
4610             phi_mem = NULL;
4611             break;
4612           }
4613         }
4614         if (phi_mem != NULL) {
4615           // equivalent phi nodes; revert to the def
4616           new_mem = new_base;
4617         }
4618       }
4619     }
4620 
4621     // maybe store down a new value
4622     Node* new_in = new_mem;
4623     if (new_in == new_base)  new_in = empty_mem;
4624 
4625     if (new_in != old_in) {
4626       // Warning:  Do not combine this &quot;if&quot; with the previous &quot;if&quot;
4627       // A memory slice might have be be rewritten even if it is semantically
4628       // unchanged, if the base_memory value has changed.
4629       set_req(i, new_in);
4630       progress = this;          // Report progress
4631     }
4632   }
4633 
4634   if (new_base != old_base) {
4635     set_req(Compile::AliasIdxBot, new_base);
4636     // Don&#39;t use set_base_memory(new_base), because we need to update du.
4637     assert(base_memory() == new_base, &quot;&quot;);
4638     progress = this;
4639   }
4640 
4641   if( base_memory() == this ) {
4642     // a self cycle indicates this memory path is dead
4643     set_req(Compile::AliasIdxBot, empty_mem);
4644   }
4645 
4646   // Resolve external cycles by calling Ideal on a MergeMem base_memory
4647   // Recursion must occur after the self cycle check above
4648   if( base_memory()-&gt;is_MergeMem() ) {
4649     MergeMemNode *new_mbase = base_memory()-&gt;as_MergeMem();
4650     Node *m = phase-&gt;transform(new_mbase);  // Rollup any cycles
4651     if( m != NULL &amp;&amp;
4652         (m-&gt;is_top() ||
4653          (m-&gt;is_MergeMem() &amp;&amp; m-&gt;as_MergeMem()-&gt;base_memory() == empty_mem)) ) {
4654       // propagate rollup of dead cycle to self
4655       set_req(Compile::AliasIdxBot, empty_mem);
4656     }
4657   }
4658 
4659   if( base_memory() == empty_mem ) {
4660     progress = this;
4661     // Cut inputs during Parse phase only.
4662     // During Optimize phase a dead MergeMem node will be subsumed by Top.
4663     if( !can_reshape ) {
4664       for (uint i = Compile::AliasIdxRaw; i &lt; req(); i++) {
4665         if( in(i) != empty_mem ) { set_req(i, empty_mem); }
4666       }
4667     }
4668   }
4669 
4670   if( !progress &amp;&amp; base_memory()-&gt;is_Phi() &amp;&amp; can_reshape ) {
4671     // Check if PhiNode::Ideal&#39;s &quot;Split phis through memory merges&quot;
4672     // transform should be attempted. Look for this-&gt;phi-&gt;this cycle.
4673     uint merge_width = req();
4674     if (merge_width &gt; Compile::AliasIdxRaw) {
4675       PhiNode* phi = base_memory()-&gt;as_Phi();
4676       for( uint i = 1; i &lt; phi-&gt;req(); ++i ) {// For all paths in
4677         if (phi-&gt;in(i) == this) {
4678           phase-&gt;is_IterGVN()-&gt;_worklist.push(phi);
4679           break;
4680         }
4681       }
4682     }
4683   }
4684 
4685   assert(progress || verify_sparse(), &quot;please, no dups of base&quot;);
4686   return progress;
4687 }
4688 
4689 //-------------------------set_base_memory-------------------------------------
4690 void MergeMemNode::set_base_memory(Node *new_base) {
4691   Node* empty_mem = empty_memory();
4692   set_req(Compile::AliasIdxBot, new_base);
4693   assert(memory_at(req()) == new_base, &quot;must set default memory&quot;);
4694   // Clear out other occurrences of new_base:
4695   if (new_base != empty_mem) {
4696     for (uint i = Compile::AliasIdxRaw; i &lt; req(); i++) {
4697       if (in(i) == new_base)  set_req(i, empty_mem);
4698     }
4699   }
4700 }
4701 
4702 //------------------------------out_RegMask------------------------------------
4703 const RegMask &amp;MergeMemNode::out_RegMask() const {
4704   return RegMask::Empty;
4705 }
4706 
4707 //------------------------------dump_spec--------------------------------------
4708 #ifndef PRODUCT
4709 void MergeMemNode::dump_spec(outputStream *st) const {
4710   st-&gt;print(&quot; {&quot;);
4711   Node* base_mem = base_memory();
4712   for( uint i = Compile::AliasIdxRaw; i &lt; req(); i++ ) {
4713     Node* mem = (in(i) != NULL) ? memory_at(i) : base_mem;
4714     if (mem == base_mem) { st-&gt;print(&quot; -&quot;); continue; }
4715     st-&gt;print( &quot; N%d:&quot;, mem-&gt;_idx );
4716     Compile::current()-&gt;get_adr_type(i)-&gt;dump_on(st);
4717   }
4718   st-&gt;print(&quot; }&quot;);
4719 }
4720 #endif // !PRODUCT
4721 
4722 
4723 #ifdef ASSERT
4724 static bool might_be_same(Node* a, Node* b) {
4725   if (a == b)  return true;
4726   if (!(a-&gt;is_Phi() || b-&gt;is_Phi()))  return false;
4727   // phis shift around during optimization
4728   return true;  // pretty stupid...
4729 }
4730 
4731 // verify a narrow slice (either incoming or outgoing)
4732 static void verify_memory_slice(const MergeMemNode* m, int alias_idx, Node* n) {
4733   if (!VerifyAliases)                return;  // don&#39;t bother to verify unless requested
4734   if (VMError::is_error_reported())  return;  // muzzle asserts when debugging an error
4735   if (Node::in_dump())               return;  // muzzle asserts when printing
4736   assert(alias_idx &gt;= Compile::AliasIdxRaw, &quot;must not disturb base_memory or sentinel&quot;);
4737   assert(n != NULL, &quot;&quot;);
4738   // Elide intervening MergeMem&#39;s
4739   while (n-&gt;is_MergeMem()) {
4740     n = n-&gt;as_MergeMem()-&gt;memory_at(alias_idx);
4741   }
4742   Compile* C = Compile::current();
4743   const TypePtr* n_adr_type = n-&gt;adr_type();
4744   if (n == m-&gt;empty_memory()) {
4745     // Implicit copy of base_memory()
4746   } else if (n_adr_type != TypePtr::BOTTOM) {
4747     assert(n_adr_type != NULL, &quot;new memory must have a well-defined adr_type&quot;);
4748     assert(C-&gt;must_alias(n_adr_type, alias_idx), &quot;new memory must match selected slice&quot;);
4749   } else {
4750     // A few places like make_runtime_call &quot;know&quot; that VM calls are narrow,
4751     // and can be used to update only the VM bits stored as TypeRawPtr::BOTTOM.
4752     bool expected_wide_mem = false;
4753     if (n == m-&gt;base_memory()) {
4754       expected_wide_mem = true;
4755     } else if (alias_idx == Compile::AliasIdxRaw ||
4756                n == m-&gt;memory_at(Compile::AliasIdxRaw)) {
4757       expected_wide_mem = true;
4758     } else if (!C-&gt;alias_type(alias_idx)-&gt;is_rewritable()) {
4759       // memory can &quot;leak through&quot; calls on channels that
4760       // are write-once.  Allow this also.
4761       expected_wide_mem = true;
4762     }
4763     assert(expected_wide_mem, &quot;expected narrow slice replacement&quot;);
4764   }
4765 }
4766 #else // !ASSERT
4767 #define verify_memory_slice(m,i,n) (void)(0)  // PRODUCT version is no-op
4768 #endif
4769 
4770 
4771 //-----------------------------memory_at---------------------------------------
4772 Node* MergeMemNode::memory_at(uint alias_idx) const {
4773   assert(alias_idx &gt;= Compile::AliasIdxRaw ||
4774          alias_idx == Compile::AliasIdxBot &amp;&amp; Compile::current()-&gt;AliasLevel() == 0,
4775          &quot;must avoid base_memory and AliasIdxTop&quot;);
4776 
4777   // Otherwise, it is a narrow slice.
4778   Node* n = alias_idx &lt; req() ? in(alias_idx) : empty_memory();
4779   Compile *C = Compile::current();
4780   if (is_empty_memory(n)) {
4781     // the array is sparse; empty slots are the &quot;top&quot; node
4782     n = base_memory();
4783     assert(Node::in_dump()
4784            || n == NULL || n-&gt;bottom_type() == Type::TOP
4785            || n-&gt;adr_type() == NULL // address is TOP
4786            || n-&gt;adr_type() == TypePtr::BOTTOM
4787            || n-&gt;adr_type() == TypeRawPtr::BOTTOM
4788            || Compile::current()-&gt;AliasLevel() == 0,
4789            &quot;must be a wide memory&quot;);
4790     // AliasLevel == 0 if we are organizing the memory states manually.
4791     // See verify_memory_slice for comments on TypeRawPtr::BOTTOM.
4792   } else {
4793     // make sure the stored slice is sane
4794     #ifdef ASSERT
4795     if (VMError::is_error_reported() || Node::in_dump()) {
4796     } else if (might_be_same(n, base_memory())) {
4797       // Give it a pass:  It is a mostly harmless repetition of the base.
4798       // This can arise normally from node subsumption during optimization.
4799     } else {
4800       verify_memory_slice(this, alias_idx, n);
4801     }
4802     #endif
4803   }
4804   return n;
4805 }
4806 
4807 //---------------------------set_memory_at-------------------------------------
4808 void MergeMemNode::set_memory_at(uint alias_idx, Node *n) {
4809   verify_memory_slice(this, alias_idx, n);
4810   Node* empty_mem = empty_memory();
4811   if (n == base_memory())  n = empty_mem;  // collapse default
4812   uint need_req = alias_idx+1;
4813   if (req() &lt; need_req) {
4814     if (n == empty_mem)  return;  // already the default, so do not grow me
4815     // grow the sparse array
4816     do {
4817       add_req(empty_mem);
4818     } while (req() &lt; need_req);
4819   }
4820   set_req( alias_idx, n );
4821 }
4822 
4823 
4824 
4825 //--------------------------iteration_setup------------------------------------
4826 void MergeMemNode::iteration_setup(const MergeMemNode* other) {
4827   if (other != NULL) {
4828     grow_to_match(other);
4829     // invariant:  the finite support of mm2 is within mm-&gt;req()
4830     #ifdef ASSERT
4831     for (uint i = req(); i &lt; other-&gt;req(); i++) {
4832       assert(other-&gt;is_empty_memory(other-&gt;in(i)), &quot;slice left uncovered&quot;);
4833     }
4834     #endif
4835   }
4836   // Replace spurious copies of base_memory by top.
4837   Node* base_mem = base_memory();
4838   if (base_mem != NULL &amp;&amp; !base_mem-&gt;is_top()) {
4839     for (uint i = Compile::AliasIdxBot+1, imax = req(); i &lt; imax; i++) {
4840       if (in(i) == base_mem)
4841         set_req(i, empty_memory());
4842     }
4843   }
4844 }
4845 
4846 //---------------------------grow_to_match-------------------------------------
4847 void MergeMemNode::grow_to_match(const MergeMemNode* other) {
4848   Node* empty_mem = empty_memory();
4849   assert(other-&gt;is_empty_memory(empty_mem), &quot;consistent sentinels&quot;);
4850   // look for the finite support of the other memory
4851   for (uint i = other-&gt;req(); --i &gt;= req(); ) {
4852     if (other-&gt;in(i) != empty_mem) {
4853       uint new_len = i+1;
4854       while (req() &lt; new_len)  add_req(empty_mem);
4855       break;
4856     }
4857   }
4858 }
4859 
4860 //---------------------------verify_sparse-------------------------------------
4861 #ifndef PRODUCT
4862 bool MergeMemNode::verify_sparse() const {
4863   assert(is_empty_memory(make_empty_memory()), &quot;sane sentinel&quot;);
4864   Node* base_mem = base_memory();
4865   // The following can happen in degenerate cases, since empty==top.
4866   if (is_empty_memory(base_mem))  return true;
4867   for (uint i = Compile::AliasIdxRaw; i &lt; req(); i++) {
4868     assert(in(i) != NULL, &quot;sane slice&quot;);
4869     if (in(i) == base_mem)  return false;  // should have been the sentinel value!
4870   }
4871   return true;
4872 }
4873 
4874 bool MergeMemStream::match_memory(Node* mem, const MergeMemNode* mm, int idx) {
4875   Node* n;
4876   n = mm-&gt;in(idx);
4877   if (mem == n)  return true;  // might be empty_memory()
4878   n = (idx == Compile::AliasIdxBot)? mm-&gt;base_memory(): mm-&gt;memory_at(idx);
4879   if (mem == n)  return true;
4880   while (n-&gt;is_Phi() &amp;&amp; (n = n-&gt;as_Phi()-&gt;is_copy()) != NULL) {
4881     if (mem == n)  return true;
4882     if (n == NULL)  break;
4883   }
4884   return false;
4885 }
4886 #endif // !PRODUCT
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/callnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  28 #include &quot;compiler/oopMap.hpp&quot;
  29 #include &quot;gc/shared/barrierSet.hpp&quot;
  30 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;opto/callGenerator.hpp&quot;
  33 #include &quot;opto/callnode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/convertnode.hpp&quot;
  36 #include &quot;opto/escape.hpp&quot;
  37 #include &quot;opto/locknode.hpp&quot;
  38 #include &quot;opto/machnode.hpp&quot;
  39 #include &quot;opto/matcher.hpp&quot;
  40 #include &quot;opto/parse.hpp&quot;
  41 #include &quot;opto/regalloc.hpp&quot;
  42 #include &quot;opto/regmask.hpp&quot;
  43 #include &quot;opto/rootnode.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;
  45 
  46 // Portions of code courtesy of Clifford Click
  47 
  48 // Optimization - Graph Style
  49 
  50 //=============================================================================
  51 uint StartNode::size_of() const { return sizeof(*this); }
  52 bool StartNode::cmp( const Node &amp;n ) const
  53 { return _domain == ((StartNode&amp;)n)._domain; }
  54 const Type *StartNode::bottom_type() const { return _domain; }
  55 const Type* StartNode::Value(PhaseGVN* phase) const { return _domain; }
  56 #ifndef PRODUCT
  57 void StartNode::dump_spec(outputStream *st) const { st-&gt;print(&quot; #&quot;); _domain-&gt;dump_on(st);}
  58 void StartNode::dump_compact_spec(outputStream *st) const { /* empty */ }
  59 #endif
  60 
  61 //------------------------------Ideal------------------------------------------
  62 Node *StartNode::Ideal(PhaseGVN *phase, bool can_reshape){
  63   return remove_dead_region(phase, can_reshape) ? this : NULL;
  64 }
  65 
  66 //------------------------------calling_convention-----------------------------
  67 void StartNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
  68   Matcher::calling_convention( sig_bt, parm_regs, argcnt, false );
  69 }
  70 
  71 //------------------------------Registers--------------------------------------
  72 const RegMask &amp;StartNode::in_RegMask(uint) const {
  73   return RegMask::Empty;
  74 }
  75 
  76 //------------------------------match------------------------------------------
  77 // Construct projections for incoming parameters, and their RegMask info
  78 Node *StartNode::match( const ProjNode *proj, const Matcher *match ) {
  79   switch (proj-&gt;_con) {
  80   case TypeFunc::Control:
  81   case TypeFunc::I_O:
  82   case TypeFunc::Memory:
  83     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
  84   case TypeFunc::FramePtr:
  85     return new MachProjNode(this,proj-&gt;_con,Matcher::c_frame_ptr_mask, Op_RegP);
  86   case TypeFunc::ReturnAdr:
  87     return new MachProjNode(this,proj-&gt;_con,match-&gt;_return_addr_mask,Op_RegP);
  88   case TypeFunc::Parms:
  89   default: {
  90       uint parm_num = proj-&gt;_con - TypeFunc::Parms;
  91       const Type *t = _domain-&gt;field_at(proj-&gt;_con);
  92       if (t-&gt;base() == Type::Half)  // 2nd half of Longs and Doubles
  93         return new ConNode(Type::TOP);
  94       uint ideal_reg = t-&gt;ideal_reg();
  95       RegMask &amp;rm = match-&gt;_calling_convention_mask[parm_num];
  96       return new MachProjNode(this,proj-&gt;_con,rm,ideal_reg);
  97     }
  98   }
  99   return NULL;
 100 }
 101 
 102 //------------------------------StartOSRNode----------------------------------
 103 // The method start node for an on stack replacement adapter
 104 
 105 //------------------------------osr_domain-----------------------------
 106 const TypeTuple *StartOSRNode::osr_domain() {
 107   const Type **fields = TypeTuple::fields(2);
 108   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer
 109 
 110   return TypeTuple::make(TypeFunc::Parms+1, fields);
 111 }
 112 
 113 //=============================================================================
 114 const char * const ParmNode::names[TypeFunc::Parms+1] = {
 115   &quot;Control&quot;, &quot;I_O&quot;, &quot;Memory&quot;, &quot;FramePtr&quot;, &quot;ReturnAdr&quot;, &quot;Parms&quot;
 116 };
 117 
 118 #ifndef PRODUCT
 119 void ParmNode::dump_spec(outputStream *st) const {
 120   if( _con &lt; TypeFunc::Parms ) {
 121     st-&gt;print(&quot;%s&quot;, names[_con]);
 122   } else {
 123     st-&gt;print(&quot;Parm%d: &quot;,_con-TypeFunc::Parms);
 124     // Verbose and WizardMode dump bottom_type for all nodes
 125     if( !Verbose &amp;&amp; !WizardMode )   bottom_type()-&gt;dump_on(st);
 126   }
 127 }
 128 
 129 void ParmNode::dump_compact_spec(outputStream *st) const {
 130   if (_con &lt; TypeFunc::Parms) {
 131     st-&gt;print(&quot;%s&quot;, names[_con]);
 132   } else {
 133     st-&gt;print(&quot;%d:&quot;, _con-TypeFunc::Parms);
 134     // unconditionally dump bottom_type
 135     bottom_type()-&gt;dump_on(st);
 136   }
 137 }
 138 
 139 // For a ParmNode, all immediate inputs and outputs are considered relevant
 140 // both in compact and standard representation.
 141 void ParmNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
 142   this-&gt;collect_nodes(in_rel, 1, false, false);
 143   this-&gt;collect_nodes(out_rel, -1, false, false);
 144 }
 145 #endif
 146 
 147 uint ParmNode::ideal_reg() const {
 148   switch( _con ) {
 149   case TypeFunc::Control  : // fall through
 150   case TypeFunc::I_O      : // fall through
 151   case TypeFunc::Memory   : return 0;
 152   case TypeFunc::FramePtr : // fall through
 153   case TypeFunc::ReturnAdr: return Op_RegP;
 154   default                 : assert( _con &gt; TypeFunc::Parms, &quot;&quot; );
 155     // fall through
 156   case TypeFunc::Parms    : {
 157     // Type of argument being passed
 158     const Type *t = in(0)-&gt;as_Start()-&gt;_domain-&gt;field_at(_con);
 159     return t-&gt;ideal_reg();
 160   }
 161   }
 162   ShouldNotReachHere();
 163   return 0;
 164 }
 165 
 166 //=============================================================================
 167 ReturnNode::ReturnNode(uint edges, Node *cntrl, Node *i_o, Node *memory, Node *frameptr, Node *retadr ) : Node(edges) {
 168   init_req(TypeFunc::Control,cntrl);
 169   init_req(TypeFunc::I_O,i_o);
 170   init_req(TypeFunc::Memory,memory);
 171   init_req(TypeFunc::FramePtr,frameptr);
 172   init_req(TypeFunc::ReturnAdr,retadr);
 173 }
 174 
 175 Node *ReturnNode::Ideal(PhaseGVN *phase, bool can_reshape){
 176   return remove_dead_region(phase, can_reshape) ? this : NULL;
 177 }
 178 
 179 const Type* ReturnNode::Value(PhaseGVN* phase) const {
 180   return ( phase-&gt;type(in(TypeFunc::Control)) == Type::TOP)
 181     ? Type::TOP
 182     : Type::BOTTOM;
 183 }
 184 
 185 // Do we Match on this edge index or not?  No edges on return nodes
 186 uint ReturnNode::match_edge(uint idx) const {
 187   return 0;
 188 }
 189 
 190 
 191 #ifndef PRODUCT
 192 void ReturnNode::dump_req(outputStream *st) const {
 193   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 194   uint i;                       // Exit value of loop
 195   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 196     if (i == TypeFunc::Parms) st-&gt;print(&quot;returns&quot;);
 197     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 198     else st-&gt;print(&quot;_ &quot;);
 199   }
 200 }
 201 #endif
 202 
 203 //=============================================================================
 204 RethrowNode::RethrowNode(
 205   Node* cntrl,
 206   Node* i_o,
 207   Node* memory,
 208   Node* frameptr,
 209   Node* ret_adr,
 210   Node* exception
 211 ) : Node(TypeFunc::Parms + 1) {
 212   init_req(TypeFunc::Control  , cntrl    );
 213   init_req(TypeFunc::I_O      , i_o      );
 214   init_req(TypeFunc::Memory   , memory   );
 215   init_req(TypeFunc::FramePtr , frameptr );
 216   init_req(TypeFunc::ReturnAdr, ret_adr);
 217   init_req(TypeFunc::Parms    , exception);
 218 }
 219 
 220 Node *RethrowNode::Ideal(PhaseGVN *phase, bool can_reshape){
 221   return remove_dead_region(phase, can_reshape) ? this : NULL;
 222 }
 223 
 224 const Type* RethrowNode::Value(PhaseGVN* phase) const {
 225   return (phase-&gt;type(in(TypeFunc::Control)) == Type::TOP)
 226     ? Type::TOP
 227     : Type::BOTTOM;
 228 }
 229 
 230 uint RethrowNode::match_edge(uint idx) const {
 231   return 0;
 232 }
 233 
 234 #ifndef PRODUCT
 235 void RethrowNode::dump_req(outputStream *st) const {
 236   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 237   uint i;                       // Exit value of loop
 238   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 239     if (i == TypeFunc::Parms) st-&gt;print(&quot;exception&quot;);
 240     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 241     else st-&gt;print(&quot;_ &quot;);
 242   }
 243 }
 244 #endif
 245 
 246 //=============================================================================
 247 // Do we Match on this edge index or not?  Match only target address &amp; method
 248 uint TailCallNode::match_edge(uint idx) const {
 249   return TypeFunc::Parms &lt;= idx  &amp;&amp;  idx &lt;= TypeFunc::Parms+1;
 250 }
 251 
 252 //=============================================================================
 253 // Do we Match on this edge index or not?  Match only target address &amp; oop
 254 uint TailJumpNode::match_edge(uint idx) const {
 255   return TypeFunc::Parms &lt;= idx  &amp;&amp;  idx &lt;= TypeFunc::Parms+1;
 256 }
 257 
 258 //=============================================================================
 259 JVMState::JVMState(ciMethod* method, JVMState* caller) :
 260   _method(method) {
 261   assert(method != NULL, &quot;must be valid call site&quot;);
 262   _bci = InvocationEntryBci;
 263   _reexecute = Reexecute_Undefined;
 264   debug_only(_bci = -99);  // random garbage value
 265   debug_only(_map = (SafePointNode*)-1);
 266   _caller = caller;
 267   _depth  = 1 + (caller == NULL ? 0 : caller-&gt;depth());
 268   _locoff = TypeFunc::Parms;
 269   _stkoff = _locoff + _method-&gt;max_locals();
 270   _monoff = _stkoff + _method-&gt;max_stack();
 271   _scloff = _monoff;
 272   _endoff = _monoff;
 273   _sp = 0;
 274 }
 275 JVMState::JVMState(int stack_size) :
 276   _method(NULL) {
 277   _bci = InvocationEntryBci;
 278   _reexecute = Reexecute_Undefined;
 279   debug_only(_map = (SafePointNode*)-1);
 280   _caller = NULL;
 281   _depth  = 1;
 282   _locoff = TypeFunc::Parms;
 283   _stkoff = _locoff;
 284   _monoff = _stkoff + stack_size;
 285   _scloff = _monoff;
 286   _endoff = _monoff;
 287   _sp = 0;
 288 }
 289 
 290 //--------------------------------of_depth-------------------------------------
 291 JVMState* JVMState::of_depth(int d) const {
 292   const JVMState* jvmp = this;
 293   assert(0 &lt; d &amp;&amp; (uint)d &lt;= depth(), &quot;oob&quot;);
 294   for (int skip = depth() - d; skip &gt; 0; skip--) {
 295     jvmp = jvmp-&gt;caller();
 296   }
 297   assert(jvmp-&gt;depth() == (uint)d, &quot;found the right one&quot;);
 298   return (JVMState*)jvmp;
 299 }
 300 
 301 //-----------------------------same_calls_as-----------------------------------
 302 bool JVMState::same_calls_as(const JVMState* that) const {
 303   if (this == that)                    return true;
 304   if (this-&gt;depth() != that-&gt;depth())  return false;
 305   const JVMState* p = this;
 306   const JVMState* q = that;
 307   for (;;) {
 308     if (p-&gt;_method != q-&gt;_method)    return false;
 309     if (p-&gt;_method == NULL)          return true;   // bci is irrelevant
 310     if (p-&gt;_bci    != q-&gt;_bci)       return false;
 311     if (p-&gt;_reexecute != q-&gt;_reexecute)  return false;
 312     p = p-&gt;caller();
 313     q = q-&gt;caller();
 314     if (p == q)                      return true;
 315     assert(p != NULL &amp;&amp; q != NULL, &quot;depth check ensures we don&#39;t run off end&quot;);
 316   }
 317 }
 318 
 319 //------------------------------debug_start------------------------------------
 320 uint JVMState::debug_start()  const {
 321   debug_only(JVMState* jvmroot = of_depth(1));
 322   assert(jvmroot-&gt;locoff() &lt;= this-&gt;locoff(), &quot;youngest JVMState must be last&quot;);
 323   return of_depth(1)-&gt;locoff();
 324 }
 325 
 326 //-------------------------------debug_end-------------------------------------
 327 uint JVMState::debug_end() const {
 328   debug_only(JVMState* jvmroot = of_depth(1));
 329   assert(jvmroot-&gt;endoff() &lt;= this-&gt;endoff(), &quot;youngest JVMState must be last&quot;);
 330   return endoff();
 331 }
 332 
 333 //------------------------------debug_depth------------------------------------
 334 uint JVMState::debug_depth() const {
 335   uint total = 0;
 336   for (const JVMState* jvmp = this; jvmp != NULL; jvmp = jvmp-&gt;caller()) {
 337     total += jvmp-&gt;debug_size();
 338   }
 339   return total;
 340 }
 341 
 342 #ifndef PRODUCT
 343 
 344 //------------------------------format_helper----------------------------------
 345 // Given an allocation (a Chaitin object) and a Node decide if the Node carries
 346 // any defined value or not.  If it does, print out the register or constant.
 347 static void format_helper( PhaseRegAlloc *regalloc, outputStream* st, Node *n, const char *msg, uint i, GrowableArray&lt;SafePointScalarObjectNode*&gt; *scobjs ) {
 348   if (n == NULL) { st-&gt;print(&quot; NULL&quot;); return; }
 349   if (n-&gt;is_SafePointScalarObject()) {
 350     // Scalar replacement.
 351     SafePointScalarObjectNode* spobj = n-&gt;as_SafePointScalarObject();
 352     scobjs-&gt;append_if_missing(spobj);
 353     int sco_n = scobjs-&gt;find(spobj);
 354     assert(sco_n &gt;= 0, &quot;&quot;);
 355     st-&gt;print(&quot; %s%d]=#ScObj&quot; INT32_FORMAT, msg, i, sco_n);
 356     return;
 357   }
 358   if (regalloc-&gt;node_regs_max_index() &gt; 0 &amp;&amp;
 359       OptoReg::is_valid(regalloc-&gt;get_reg_first(n))) { // Check for undefined
 360     char buf[50];
 361     regalloc-&gt;dump_register(n,buf);
 362     st-&gt;print(&quot; %s%d]=%s&quot;,msg,i,buf);
 363   } else {                      // No register, but might be constant
 364     const Type *t = n-&gt;bottom_type();
 365     switch (t-&gt;base()) {
 366     case Type::Int:
 367       st-&gt;print(&quot; %s%d]=#&quot; INT32_FORMAT,msg,i,t-&gt;is_int()-&gt;get_con());
 368       break;
 369     case Type::AnyPtr:
 370       assert( t == TypePtr::NULL_PTR || n-&gt;in_dump(), &quot;&quot; );
 371       st-&gt;print(&quot; %s%d]=#NULL&quot;,msg,i);
 372       break;
 373     case Type::AryPtr:
 374     case Type::InstPtr:
 375       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;isa_oopptr()-&gt;const_oop()));
 376       break;
 377     case Type::KlassPtr:
 378       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_klassptr()-&gt;klass()));
 379       break;
 380     case Type::MetadataPtr:
 381       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_metadataptr()-&gt;metadata()));
 382       break;
 383     case Type::NarrowOop:
 384       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()));
 385       break;
 386     case Type::RawPtr:
 387       st-&gt;print(&quot; %s%d]=#Raw&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;is_rawptr()));
 388       break;
 389     case Type::DoubleCon:
 390       st-&gt;print(&quot; %s%d]=#%fD&quot;,msg,i,t-&gt;is_double_constant()-&gt;_d);
 391       break;
 392     case Type::FloatCon:
 393       st-&gt;print(&quot; %s%d]=#%fF&quot;,msg,i,t-&gt;is_float_constant()-&gt;_f);
 394       break;
 395     case Type::Long:
 396       st-&gt;print(&quot; %s%d]=#&quot; INT64_FORMAT,msg,i,(int64_t)(t-&gt;is_long()-&gt;get_con()));
 397       break;
 398     case Type::Half:
 399     case Type::Top:
 400       st-&gt;print(&quot; %s%d]=_&quot;,msg,i);
 401       break;
 402     default: ShouldNotReachHere();
 403     }
 404   }
 405 }
 406 
 407 //------------------------------format-----------------------------------------
 408 void JVMState::format(PhaseRegAlloc *regalloc, const Node *n, outputStream* st) const {
 409   st-&gt;print(&quot;        #&quot;);
 410   if (_method) {
 411     _method-&gt;print_short_name(st);
 412     st-&gt;print(&quot; @ bci:%d &quot;,_bci);
 413   } else {
 414     st-&gt;print_cr(&quot; runtime stub &quot;);
 415     return;
 416   }
 417   if (n-&gt;is_MachSafePoint()) {
 418     GrowableArray&lt;SafePointScalarObjectNode*&gt; scobjs;
 419     MachSafePointNode *mcall = n-&gt;as_MachSafePoint();
 420     uint i;
 421     // Print locals
 422     for (i = 0; i &lt; (uint)loc_size(); i++)
 423       format_helper(regalloc, st, mcall-&gt;local(this, i), &quot;L[&quot;, i, &amp;scobjs);
 424     // Print stack
 425     for (i = 0; i &lt; (uint)stk_size(); i++) {
 426       if ((uint)(_stkoff + i) &gt;= mcall-&gt;len())
 427         st-&gt;print(&quot; oob &quot;);
 428       else
 429        format_helper(regalloc, st, mcall-&gt;stack(this, i), &quot;STK[&quot;, i, &amp;scobjs);
 430     }
 431     for (i = 0; (int)i &lt; nof_monitors(); i++) {
 432       Node *box = mcall-&gt;monitor_box(this, i);
 433       Node *obj = mcall-&gt;monitor_obj(this, i);
 434       if (regalloc-&gt;node_regs_max_index() &gt; 0 &amp;&amp;
 435           OptoReg::is_valid(regalloc-&gt;get_reg_first(box))) {
 436         box = BoxLockNode::box_node(box);
 437         format_helper(regalloc, st, box, &quot;MON-BOX[&quot;, i, &amp;scobjs);
 438       } else {
 439         OptoReg::Name box_reg = BoxLockNode::reg(box);
 440         st-&gt;print(&quot; MON-BOX%d=%s+%d&quot;,
 441                    i,
 442                    OptoReg::regname(OptoReg::c_frame_pointer),
 443                    regalloc-&gt;reg2offset(box_reg));
 444       }
 445       const char* obj_msg = &quot;MON-OBJ[&quot;;
 446       if (EliminateLocks) {
 447         if (BoxLockNode::box_node(box)-&gt;is_eliminated())
 448           obj_msg = &quot;MON-OBJ(LOCK ELIMINATED)[&quot;;
 449       }
 450       format_helper(regalloc, st, obj, obj_msg, i, &amp;scobjs);
 451     }
 452 
 453     for (i = 0; i &lt; (uint)scobjs.length(); i++) {
 454       // Scalar replaced objects.
 455       st-&gt;cr();
 456       st-&gt;print(&quot;        # ScObj&quot; INT32_FORMAT &quot; &quot;, i);
 457       SafePointScalarObjectNode* spobj = scobjs.at(i);
 458       ciKlass* cik = spobj-&gt;bottom_type()-&gt;is_oopptr()-&gt;klass();
 459       assert(cik-&gt;is_instance_klass() ||
 460              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 461       ciInstanceKlass *iklass = NULL;
 462       if (cik-&gt;is_instance_klass()) {
 463         cik-&gt;print_name_on(st);
 464         iklass = cik-&gt;as_instance_klass();
 465       } else if (cik-&gt;is_type_array_klass()) {
 466         cik-&gt;as_array_klass()-&gt;base_element_type()-&gt;print_name_on(st);
 467         st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());
 468       } else if (cik-&gt;is_obj_array_klass()) {
 469         ciKlass* cie = cik-&gt;as_obj_array_klass()-&gt;base_element_klass();
 470         if (cie-&gt;is_instance_klass()) {
 471           cie-&gt;print_name_on(st);
 472         } else if (cie-&gt;is_type_array_klass()) {
 473           cie-&gt;as_array_klass()-&gt;base_element_type()-&gt;print_name_on(st);
 474         } else {
 475           ShouldNotReachHere();
 476         }
 477         st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());
 478         int ndim = cik-&gt;as_array_klass()-&gt;dimension() - 1;
 479         while (ndim-- &gt; 0) {
 480           st-&gt;print(&quot;[]&quot;);
 481         }
 482       }
 483       st-&gt;print(&quot;={&quot;);
 484       uint nf = spobj-&gt;n_fields();
 485       if (nf &gt; 0) {
 486         uint first_ind = spobj-&gt;first_index(mcall-&gt;jvms());
 487         Node* fld_node = mcall-&gt;in(first_ind);
 488         ciField* cifield;
 489         if (iklass != NULL) {
 490           st-&gt;print(&quot; [&quot;);
 491           cifield = iklass-&gt;nonstatic_field_at(0);
 492           cifield-&gt;print_name_on(st);
 493           format_helper(regalloc, st, fld_node, &quot;:&quot;, 0, &amp;scobjs);
 494         } else {
 495           format_helper(regalloc, st, fld_node, &quot;[&quot;, 0, &amp;scobjs);
 496         }
 497         for (uint j = 1; j &lt; nf; j++) {
 498           fld_node = mcall-&gt;in(first_ind+j);
 499           if (iklass != NULL) {
 500             st-&gt;print(&quot;, [&quot;);
 501             cifield = iklass-&gt;nonstatic_field_at(j);
 502             cifield-&gt;print_name_on(st);
 503             format_helper(regalloc, st, fld_node, &quot;:&quot;, j, &amp;scobjs);
 504           } else {
 505             format_helper(regalloc, st, fld_node, &quot;, [&quot;, j, &amp;scobjs);
 506           }
 507         }
 508       }
 509       st-&gt;print(&quot; }&quot;);
 510     }
 511   }
 512   st-&gt;cr();
 513   if (caller() != NULL) caller()-&gt;format(regalloc, n, st);
 514 }
 515 
 516 
 517 void JVMState::dump_spec(outputStream *st) const {
 518   if (_method != NULL) {
 519     bool printed = false;
 520     if (!Verbose) {
 521       // The JVMS dumps make really, really long lines.
 522       // Take out the most boring parts, which are the package prefixes.
 523       char buf[500];
 524       stringStream namest(buf, sizeof(buf));
 525       _method-&gt;print_short_name(&amp;namest);
 526       if (namest.count() &lt; sizeof(buf)) {
 527         const char* name = namest.base();
 528         if (name[0] == &#39; &#39;)  ++name;
 529         const char* endcn = strchr(name, &#39;:&#39;);  // end of class name
 530         if (endcn == NULL)  endcn = strchr(name, &#39;(&#39;);
 531         if (endcn == NULL)  endcn = name + strlen(name);
 532         while (endcn &gt; name &amp;&amp; endcn[-1] != &#39;.&#39; &amp;&amp; endcn[-1] != &#39;/&#39;)
 533           --endcn;
 534         st-&gt;print(&quot; %s&quot;, endcn);
 535         printed = true;
 536       }
 537     }
 538     if (!printed)
 539       _method-&gt;print_short_name(st);
 540     st-&gt;print(&quot; @ bci:%d&quot;,_bci);
 541     if(_reexecute == Reexecute_True)
 542       st-&gt;print(&quot; reexecute&quot;);
 543   } else {
 544     st-&gt;print(&quot; runtime stub&quot;);
 545   }
 546   if (caller() != NULL)  caller()-&gt;dump_spec(st);
 547 }
 548 
 549 
 550 void JVMState::dump_on(outputStream* st) const {
 551   bool print_map = _map &amp;&amp; !((uintptr_t)_map &amp; 1) &amp;&amp;
 552                   ((caller() == NULL) || (caller()-&gt;map() != _map));
 553   if (print_map) {
 554     if (_map-&gt;len() &gt; _map-&gt;req()) {  // _map-&gt;has_exceptions()
 555       Node* ex = _map-&gt;in(_map-&gt;req());  // _map-&gt;next_exception()
 556       // skip the first one; it&#39;s already being printed
 557       while (ex != NULL &amp;&amp; ex-&gt;len() &gt; ex-&gt;req()) {
 558         ex = ex-&gt;in(ex-&gt;req());  // ex-&gt;next_exception()
 559         ex-&gt;dump(1);
 560       }
 561     }
 562     _map-&gt;dump(Verbose ? 2 : 1);
 563   }
 564   if (caller() != NULL) {
 565     caller()-&gt;dump_on(st);
 566   }
 567   st-&gt;print(&quot;JVMS depth=%d loc=%d stk=%d arg=%d mon=%d scalar=%d end=%d mondepth=%d sp=%d bci=%d reexecute=%s method=&quot;,
 568              depth(), locoff(), stkoff(), argoff(), monoff(), scloff(), endoff(), monitor_depth(), sp(), bci(), should_reexecute()?&quot;true&quot;:&quot;false&quot;);
 569   if (_method == NULL) {
 570     st-&gt;print_cr(&quot;(none)&quot;);
 571   } else {
 572     _method-&gt;print_name(st);
 573     st-&gt;cr();
 574     if (bci() &gt;= 0 &amp;&amp; bci() &lt; _method-&gt;code_size()) {
 575       st-&gt;print(&quot;    bc: &quot;);
 576       _method-&gt;print_codes_on(bci(), bci()+1, st);
 577     }
 578   }
 579 }
 580 
 581 // Extra way to dump a jvms from the debugger,
 582 // to avoid a bug with C++ member function calls.
 583 void dump_jvms(JVMState* jvms) {
 584   jvms-&gt;dump();
 585 }
 586 #endif
 587 
 588 //--------------------------clone_shallow--------------------------------------
 589 JVMState* JVMState::clone_shallow(Compile* C) const {
 590   JVMState* n = has_method() ? new (C) JVMState(_method, _caller) : new (C) JVMState(0);
 591   n-&gt;set_bci(_bci);
 592   n-&gt;_reexecute = _reexecute;
 593   n-&gt;set_locoff(_locoff);
 594   n-&gt;set_stkoff(_stkoff);
 595   n-&gt;set_monoff(_monoff);
 596   n-&gt;set_scloff(_scloff);
 597   n-&gt;set_endoff(_endoff);
 598   n-&gt;set_sp(_sp);
 599   n-&gt;set_map(_map);
 600   return n;
 601 }
 602 
 603 //---------------------------clone_deep----------------------------------------
 604 JVMState* JVMState::clone_deep(Compile* C) const {
 605   JVMState* n = clone_shallow(C);
 606   for (JVMState* p = n; p-&gt;_caller != NULL; p = p-&gt;_caller) {
 607     p-&gt;_caller = p-&gt;_caller-&gt;clone_shallow(C);
 608   }
 609   assert(n-&gt;depth() == depth(), &quot;sanity&quot;);
 610   assert(n-&gt;debug_depth() == debug_depth(), &quot;sanity&quot;);
 611   return n;
 612 }
 613 
 614 /**
 615  * Reset map for all callers
 616  */
 617 void JVMState::set_map_deep(SafePointNode* map) {
 618   for (JVMState* p = this; p-&gt;_caller != NULL; p = p-&gt;_caller) {
 619     p-&gt;set_map(map);
 620   }
 621 }
 622 
 623 // Adapt offsets in in-array after adding or removing an edge.
 624 // Prerequisite is that the JVMState is used by only one node.
 625 void JVMState::adapt_position(int delta) {
 626   for (JVMState* jvms = this; jvms != NULL; jvms = jvms-&gt;caller()) {
 627     jvms-&gt;set_locoff(jvms-&gt;locoff() + delta);
 628     jvms-&gt;set_stkoff(jvms-&gt;stkoff() + delta);
 629     jvms-&gt;set_monoff(jvms-&gt;monoff() + delta);
 630     jvms-&gt;set_scloff(jvms-&gt;scloff() + delta);
 631     jvms-&gt;set_endoff(jvms-&gt;endoff() + delta);
 632   }
 633 }
 634 
 635 // Mirror the stack size calculation in the deopt code
 636 // How much stack space would we need at this point in the program in
 637 // case of deoptimization?
 638 int JVMState::interpreter_frame_size() const {
 639   const JVMState* jvms = this;
 640   int size = 0;
 641   int callee_parameters = 0;
 642   int callee_locals = 0;
 643   int extra_args = method()-&gt;max_stack() - stk_size();
 644 
 645   while (jvms != NULL) {
 646     int locks = jvms-&gt;nof_monitors();
 647     int temps = jvms-&gt;stk_size();
 648     bool is_top_frame = (jvms == this);
 649     ciMethod* method = jvms-&gt;method();
 650 
 651     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
 652                                                                  temps + callee_parameters,
 653                                                                  extra_args,
 654                                                                  locks,
 655                                                                  callee_parameters,
 656                                                                  callee_locals,
 657                                                                  is_top_frame);
 658     size += frame_size;
 659 
 660     callee_parameters = method-&gt;size_of_parameters();
 661     callee_locals = method-&gt;max_locals();
 662     extra_args = 0;
 663     jvms = jvms-&gt;caller();
 664   }
 665   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
 666 }
 667 
 668 //=============================================================================
 669 bool CallNode::cmp( const Node &amp;n ) const
 670 { return _tf == ((CallNode&amp;)n)._tf &amp;&amp; _jvms == ((CallNode&amp;)n)._jvms; }
 671 #ifndef PRODUCT
 672 void CallNode::dump_req(outputStream *st) const {
 673   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 674   uint i;                       // Exit value of loop
 675   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 676     if (i == TypeFunc::Parms) st-&gt;print(&quot;(&quot;);
 677     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 678     else st-&gt;print(&quot;_ &quot;);
 679   }
 680   st-&gt;print(&quot;)&quot;);
 681 }
 682 
 683 void CallNode::dump_spec(outputStream *st) const {
 684   st-&gt;print(&quot; &quot;);
 685   if (tf() != NULL)  tf()-&gt;dump_on(st);
 686   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
 687   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
 688 }
 689 #endif
 690 
 691 const Type *CallNode::bottom_type() const { return tf()-&gt;range(); }
 692 const Type* CallNode::Value(PhaseGVN* phase) const {
 693   if (phase-&gt;type(in(0)) == Type::TOP)  return Type::TOP;
 694   return tf()-&gt;range();
 695 }
 696 
 697 //------------------------------calling_convention-----------------------------
 698 void CallNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
 699   // Use the standard compiler calling convention
 700   Matcher::calling_convention( sig_bt, parm_regs, argcnt, true );
 701 }
 702 
 703 
 704 //------------------------------match------------------------------------------
 705 // Construct projections for control, I/O, memory-fields, ..., and
 706 // return result(s) along with their RegMask info
 707 Node *CallNode::match( const ProjNode *proj, const Matcher *match ) {
 708   switch (proj-&gt;_con) {
 709   case TypeFunc::Control:
 710   case TypeFunc::I_O:
 711   case TypeFunc::Memory:
 712     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
 713 
 714   case TypeFunc::Parms+1:       // For LONG &amp; DOUBLE returns
 715     assert(tf()-&gt;range()-&gt;field_at(TypeFunc::Parms+1) == Type::HALF, &quot;&quot;);
 716     // 2nd half of doubles and longs
 717     return new MachProjNode(this,proj-&gt;_con, RegMask::Empty, (uint)OptoReg::Bad);
 718 
 719   case TypeFunc::Parms: {       // Normal returns
 720     uint ideal_reg = tf()-&gt;range()-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();
 721     OptoRegPair regs = is_CallRuntime()
 722       ? match-&gt;c_return_value(ideal_reg,true)  // Calls into C runtime
 723       : match-&gt;  return_value(ideal_reg,true); // Calls into compiled Java code
 724     RegMask rm = RegMask(regs.first());
 725     if( OptoReg::is_valid(regs.second()) )
 726       rm.Insert( regs.second() );
 727     return new MachProjNode(this,proj-&gt;_con,rm,ideal_reg);
 728   }
 729 
 730   case TypeFunc::ReturnAdr:
 731   case TypeFunc::FramePtr:
 732   default:
 733     ShouldNotReachHere();
 734   }
 735   return NULL;
 736 }
 737 
 738 // Do we Match on this edge index or not?  Match no edges
 739 uint CallNode::match_edge(uint idx) const {
 740   return 0;
 741 }
 742 
 743 //
 744 // Determine whether the call could modify the field of the specified
 745 // instance at the specified offset.
 746 //
 747 bool CallNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {
 748   assert((t_oop != NULL), &quot;sanity&quot;);
 749   if (is_call_to_arraycopystub() &amp;&amp; strcmp(_name, &quot;unsafe_arraycopy&quot;) != 0) {
 750     const TypeTuple* args = _tf-&gt;domain();
 751     Node* dest = NULL;
 752     // Stubs that can be called once an ArrayCopyNode is expanded have
 753     // different signatures. Look for the second pointer argument,
 754     // that is the destination of the copy.
 755     for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
 756       if (args-&gt;field_at(i)-&gt;isa_ptr()) {
 757         j++;
 758         if (j == 2) {
 759           dest = in(i);
 760           break;
 761         }
 762       }
 763     }
 764     guarantee(dest != NULL, &quot;Call had only one ptr in, broken IR!&quot;);
 765     if (!dest-&gt;is_top() &amp;&amp; may_modify_arraycopy_helper(phase-&gt;type(dest)-&gt;is_oopptr(), t_oop, phase)) {
 766       return true;
 767     }
 768     return false;
 769   }
 770   if (t_oop-&gt;is_known_instance()) {
 771     // The instance_id is set only for scalar-replaceable allocations which
 772     // are not passed as arguments according to Escape Analysis.
 773     return false;
 774   }
 775   if (t_oop-&gt;is_ptr_to_boxed_value()) {
 776     ciKlass* boxing_klass = t_oop-&gt;klass();
 777     if (is_CallStaticJava() &amp;&amp; as_CallStaticJava()-&gt;is_boxing_method()) {
 778       // Skip unrelated boxing methods.
 779       Node* proj = proj_out_or_null(TypeFunc::Parms);
 780       if ((proj == NULL) || (phase-&gt;type(proj)-&gt;is_instptr()-&gt;klass() != boxing_klass)) {
 781         return false;
 782       }
 783     }
 784     if (is_CallJava() &amp;&amp; as_CallJava()-&gt;method() != NULL) {
 785       ciMethod* meth = as_CallJava()-&gt;method();
 786       if (meth-&gt;is_getter()) {
 787         return false;
 788       }
 789       // May modify (by reflection) if an boxing object is passed
 790       // as argument or returned.
 791       Node* proj = returns_pointer() ? proj_out_or_null(TypeFunc::Parms) : NULL;
 792       if (proj != NULL) {
 793         const TypeInstPtr* inst_t = phase-&gt;type(proj)-&gt;isa_instptr();
 794         if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
 795                                  (inst_t-&gt;klass() == boxing_klass))) {
 796           return true;
 797         }
 798       }
 799       const TypeTuple* d = tf()-&gt;domain();
 800       for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 801         const TypeInstPtr* inst_t = d-&gt;field_at(i)-&gt;isa_instptr();
 802         if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
 803                                  (inst_t-&gt;klass() == boxing_klass))) {
 804           return true;
 805         }
 806       }
 807       return false;
 808     }
 809   }
 810   return true;
 811 }
 812 
 813 // Does this call have a direct reference to n other than debug information?
 814 bool CallNode::has_non_debug_use(Node *n) {
 815   const TypeTuple * d = tf()-&gt;domain();
 816   for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 817     Node *arg = in(i);
 818     if (arg == n) {
 819       return true;
 820     }
 821   }
 822   return false;
 823 }
 824 
 825 // Returns the unique CheckCastPP of a call
 826 // or &#39;this&#39; if there are several CheckCastPP or unexpected uses
 827 // or returns NULL if there is no one.
 828 Node *CallNode::result_cast() {
 829   Node *cast = NULL;
 830 
 831   Node *p = proj_out_or_null(TypeFunc::Parms);
 832   if (p == NULL)
 833     return NULL;
 834 
 835   for (DUIterator_Fast imax, i = p-&gt;fast_outs(imax); i &lt; imax; i++) {
 836     Node *use = p-&gt;fast_out(i);
 837     if (use-&gt;is_CheckCastPP()) {
 838       if (cast != NULL) {
 839         return this;  // more than 1 CheckCastPP
 840       }
 841       cast = use;
 842     } else if (!use-&gt;is_Initialize() &amp;&amp;
 843                !use-&gt;is_AddP() &amp;&amp;
 844                use-&gt;Opcode() != Op_MemBarStoreStore) {
 845       // Expected uses are restricted to a CheckCastPP, an Initialize
 846       // node, a MemBarStoreStore (clone) and AddP nodes. If we
 847       // encounter any other use (a Phi node can be seen in rare
 848       // cases) return this to prevent incorrect optimizations.
 849       return this;
 850     }
 851   }
 852   return cast;
 853 }
 854 
 855 
 856 void CallNode::extract_projections(CallProjections* projs, bool separate_io_proj, bool do_asserts) {
 857   projs-&gt;fallthrough_proj      = NULL;
 858   projs-&gt;fallthrough_catchproj = NULL;
 859   projs-&gt;fallthrough_ioproj    = NULL;
 860   projs-&gt;catchall_ioproj       = NULL;
 861   projs-&gt;catchall_catchproj    = NULL;
 862   projs-&gt;fallthrough_memproj   = NULL;
 863   projs-&gt;catchall_memproj      = NULL;
 864   projs-&gt;resproj               = NULL;
 865   projs-&gt;exobj                 = NULL;
 866 
 867   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 868     ProjNode *pn = fast_out(i)-&gt;as_Proj();
 869     if (pn-&gt;outcnt() == 0) continue;
 870     switch (pn-&gt;_con) {
 871     case TypeFunc::Control:
 872       {
 873         // For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -&gt; Catch -&gt; Proj
 874         projs-&gt;fallthrough_proj = pn;
 875         DUIterator_Fast jmax, j = pn-&gt;fast_outs(jmax);
 876         const Node *cn = pn-&gt;fast_out(j);
 877         if (cn-&gt;is_Catch()) {
 878           ProjNode *cpn = NULL;
 879           for (DUIterator_Fast kmax, k = cn-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 880             cpn = cn-&gt;fast_out(k)-&gt;as_Proj();
 881             assert(cpn-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
 882             if (cpn-&gt;_con == CatchProjNode::fall_through_index)
 883               projs-&gt;fallthrough_catchproj = cpn;
 884             else {
 885               assert(cpn-&gt;_con == CatchProjNode::catch_all_index, &quot;must be correct index.&quot;);
 886               projs-&gt;catchall_catchproj = cpn;
 887             }
 888           }
 889         }
 890         break;
 891       }
 892     case TypeFunc::I_O:
 893       if (pn-&gt;_is_io_use)
 894         projs-&gt;catchall_ioproj = pn;
 895       else
 896         projs-&gt;fallthrough_ioproj = pn;
 897       for (DUIterator j = pn-&gt;outs(); pn-&gt;has_out(j); j++) {
 898         Node* e = pn-&gt;out(j);
 899         if (e-&gt;Opcode() == Op_CreateEx &amp;&amp; e-&gt;in(0)-&gt;is_CatchProj() &amp;&amp; e-&gt;outcnt() &gt; 0) {
 900           assert(projs-&gt;exobj == NULL, &quot;only one&quot;);
 901           projs-&gt;exobj = e;
 902         }
 903       }
 904       break;
 905     case TypeFunc::Memory:
 906       if (pn-&gt;_is_io_use)
 907         projs-&gt;catchall_memproj = pn;
 908       else
 909         projs-&gt;fallthrough_memproj = pn;
 910       break;
 911     case TypeFunc::Parms:
 912       projs-&gt;resproj = pn;
 913       break;
 914     default:
 915       assert(false, &quot;unexpected projection from allocation node.&quot;);
 916     }
 917   }
 918 
 919   // The resproj may not exist because the result could be ignored
 920   // and the exception object may not exist if an exception handler
 921   // swallows the exception but all the other must exist and be found.
 922   assert(projs-&gt;fallthrough_proj      != NULL, &quot;must be found&quot;);
 923   do_asserts = do_asserts &amp;&amp; !Compile::current()-&gt;inlining_incrementally();
 924   assert(!do_asserts || projs-&gt;fallthrough_catchproj != NULL, &quot;must be found&quot;);
 925   assert(!do_asserts || projs-&gt;fallthrough_memproj   != NULL, &quot;must be found&quot;);
 926   assert(!do_asserts || projs-&gt;fallthrough_ioproj    != NULL, &quot;must be found&quot;);
 927   assert(!do_asserts || projs-&gt;catchall_catchproj    != NULL, &quot;must be found&quot;);
 928   if (separate_io_proj) {
 929     assert(!do_asserts || projs-&gt;catchall_memproj    != NULL, &quot;must be found&quot;);
 930     assert(!do_asserts || projs-&gt;catchall_ioproj     != NULL, &quot;must be found&quot;);
 931   }
 932 }
 933 
 934 Node *CallNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 935   CallGenerator* cg = generator();
 936   if (can_reshape &amp;&amp; cg != NULL &amp;&amp; cg-&gt;is_mh_late_inline() &amp;&amp; !cg-&gt;already_attempted()) {
 937     // Check whether this MH handle call becomes a candidate for inlining
 938     ciMethod* callee = cg-&gt;method();
 939     vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
 940     if (iid == vmIntrinsics::_invokeBasic) {
 941       if (in(TypeFunc::Parms)-&gt;Opcode() == Op_ConP) {
 942         phase-&gt;C-&gt;prepend_late_inline(cg);
 943         set_generator(NULL);
 944       }
 945     } else {
 946       assert(callee-&gt;has_member_arg(), &quot;wrong type of call?&quot;);
 947       if (in(TypeFunc::Parms + callee-&gt;arg_size() - 1)-&gt;Opcode() == Op_ConP) {
 948         phase-&gt;C-&gt;prepend_late_inline(cg);
 949         set_generator(NULL);
 950       }
 951     }
 952   }
 953   return SafePointNode::Ideal(phase, can_reshape);
 954 }
 955 
 956 bool CallNode::is_call_to_arraycopystub() const {
 957   if (_name != NULL &amp;&amp; strstr(_name, &quot;arraycopy&quot;) != 0) {
 958     return true;
 959   }
 960   return false;
 961 }
 962 
 963 //=============================================================================
 964 uint CallJavaNode::size_of() const { return sizeof(*this); }
 965 bool CallJavaNode::cmp( const Node &amp;n ) const {
 966   CallJavaNode &amp;call = (CallJavaNode&amp;)n;
 967   return CallNode::cmp(call) &amp;&amp; _method == call._method &amp;&amp;
 968          _override_symbolic_info == call._override_symbolic_info;
 969 }
 970 #ifdef ASSERT
 971 bool CallJavaNode::validate_symbolic_info() const {
 972   if (method() == NULL) {
 973     return true; // call into runtime or uncommon trap
 974   }
 975   ciMethod* symbolic_info = jvms()-&gt;method()-&gt;get_method_at_bci(_bci);
 976   ciMethod* callee = method();
 977   if (symbolic_info-&gt;is_method_handle_intrinsic() &amp;&amp; !callee-&gt;is_method_handle_intrinsic()) {
 978     assert(override_symbolic_info(), &quot;should be set&quot;);
 979   }
 980   assert(ciMethod::is_consistent_info(symbolic_info, callee), &quot;inconsistent info&quot;);
 981   return true;
 982 }
 983 #endif
 984 
 985 #ifndef PRODUCT
 986 void CallJavaNode::dump_spec(outputStream *st) const {
 987   if( _method ) _method-&gt;print_short_name(st);
 988   CallNode::dump_spec(st);
 989 }
 990 
 991 void CallJavaNode::dump_compact_spec(outputStream* st) const {
 992   if (_method) {
 993     _method-&gt;print_short_name(st);
 994   } else {
 995     st-&gt;print(&quot;&lt;?&gt;&quot;);
 996   }
 997 }
 998 #endif
 999 
1000 //=============================================================================
1001 uint CallStaticJavaNode::size_of() const { return sizeof(*this); }
1002 bool CallStaticJavaNode::cmp( const Node &amp;n ) const {
1003   CallStaticJavaNode &amp;call = (CallStaticJavaNode&amp;)n;
1004   return CallJavaNode::cmp(call);
1005 }
1006 
1007 //----------------------------uncommon_trap_request----------------------------
1008 // If this is an uncommon trap, return the request code, else zero.
1009 int CallStaticJavaNode::uncommon_trap_request() const {
1010   if (_name != NULL &amp;&amp; !strcmp(_name, &quot;uncommon_trap&quot;)) {
1011     return extract_uncommon_trap_request(this);
1012   }
1013   return 0;
1014 }
1015 int CallStaticJavaNode::extract_uncommon_trap_request(const Node* call) {
1016 #ifndef PRODUCT
1017   if (!(call-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
1018         call-&gt;in(TypeFunc::Parms) != NULL &amp;&amp;
1019         call-&gt;in(TypeFunc::Parms)-&gt;is_Con() &amp;&amp;
1020         call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;isa_int())) {
1021     assert(in_dump() != 0, &quot;OK if dumping&quot;);
1022     tty-&gt;print(&quot;[bad uncommon trap]&quot;);
1023     return 0;
1024   }
1025 #endif
1026   return call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
1027 }
1028 
1029 #ifndef PRODUCT
1030 void CallStaticJavaNode::dump_spec(outputStream *st) const {
1031   st-&gt;print(&quot;# Static &quot;);
1032   if (_name != NULL) {
1033     st-&gt;print(&quot;%s&quot;, _name);
1034     int trap_req = uncommon_trap_request();
1035     if (trap_req != 0) {
1036       char buf[100];
1037       st-&gt;print(&quot;(%s)&quot;,
1038                  Deoptimization::format_trap_request(buf, sizeof(buf),
1039                                                      trap_req));
1040     }
1041     st-&gt;print(&quot; &quot;);
1042   }
1043   CallJavaNode::dump_spec(st);
1044 }
1045 
1046 void CallStaticJavaNode::dump_compact_spec(outputStream* st) const {
1047   if (_method) {
1048     _method-&gt;print_short_name(st);
1049   } else if (_name) {
1050     st-&gt;print(&quot;%s&quot;, _name);
1051   } else {
1052     st-&gt;print(&quot;&lt;?&gt;&quot;);
1053   }
1054 }
1055 #endif
1056 
1057 //=============================================================================
1058 uint CallDynamicJavaNode::size_of() const { return sizeof(*this); }
1059 bool CallDynamicJavaNode::cmp( const Node &amp;n ) const {
1060   CallDynamicJavaNode &amp;call = (CallDynamicJavaNode&amp;)n;
1061   return CallJavaNode::cmp(call);
1062 }
1063 #ifndef PRODUCT
1064 void CallDynamicJavaNode::dump_spec(outputStream *st) const {
1065   st-&gt;print(&quot;# Dynamic &quot;);
1066   CallJavaNode::dump_spec(st);
1067 }
1068 #endif
1069 
1070 //=============================================================================
1071 uint CallRuntimeNode::size_of() const { return sizeof(*this); }
1072 bool CallRuntimeNode::cmp( const Node &amp;n ) const {
1073   CallRuntimeNode &amp;call = (CallRuntimeNode&amp;)n;
1074   return CallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
1075 }
1076 #ifndef PRODUCT
1077 void CallRuntimeNode::dump_spec(outputStream *st) const {
1078   st-&gt;print(&quot;# &quot;);
1079   st-&gt;print(&quot;%s&quot;, _name);
1080   CallNode::dump_spec(st);
1081 }
1082 #endif
1083 
1084 //------------------------------calling_convention-----------------------------
1085 void CallRuntimeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
1086   Matcher::c_calling_convention( sig_bt, parm_regs, argcnt );
1087 }
1088 
1089 //=============================================================================
1090 //------------------------------calling_convention-----------------------------
1091 
1092 
1093 //=============================================================================
1094 #ifndef PRODUCT
1095 void CallLeafNode::dump_spec(outputStream *st) const {
1096   st-&gt;print(&quot;# &quot;);
1097   st-&gt;print(&quot;%s&quot;, _name);
1098   CallNode::dump_spec(st);
1099 }
1100 #endif
1101 
1102 //=============================================================================
1103 
1104 void SafePointNode::set_local(JVMState* jvms, uint idx, Node *c) {
1105   assert(verify_jvms(jvms), &quot;jvms must match&quot;);
1106   int loc = jvms-&gt;locoff() + idx;
1107   if (in(loc)-&gt;is_top() &amp;&amp; idx &gt; 0 &amp;&amp; !c-&gt;is_top() ) {
1108     // If current local idx is top then local idx - 1 could
1109     // be a long/double that needs to be killed since top could
1110     // represent the 2nd half ofthe long/double.
1111     uint ideal = in(loc -1)-&gt;ideal_reg();
1112     if (ideal == Op_RegD || ideal == Op_RegL) {
1113       // set other (low index) half to top
1114       set_req(loc - 1, in(loc));
1115     }
1116   }
1117   set_req(loc, c);
1118 }
1119 
1120 uint SafePointNode::size_of() const { return sizeof(*this); }
1121 bool SafePointNode::cmp( const Node &amp;n ) const {
1122   return (&amp;n == this);          // Always fail except on self
1123 }
1124 
1125 //-------------------------set_next_exception----------------------------------
1126 void SafePointNode::set_next_exception(SafePointNode* n) {
1127   assert(n == NULL || n-&gt;Opcode() == Op_SafePoint, &quot;correct value for next_exception&quot;);
1128   if (len() == req()) {
1129     if (n != NULL)  add_prec(n);
1130   } else {
1131     set_prec(req(), n);
1132   }
1133 }
1134 
1135 
1136 //----------------------------next_exception-----------------------------------
1137 SafePointNode* SafePointNode::next_exception() const {
1138   if (len() == req()) {
1139     return NULL;
1140   } else {
1141     Node* n = in(req());
1142     assert(n == NULL || n-&gt;Opcode() == Op_SafePoint, &quot;no other uses of prec edges&quot;);
1143     return (SafePointNode*) n;
1144   }
1145 }
1146 
1147 
1148 //------------------------------Ideal------------------------------------------
1149 // Skip over any collapsed Regions
1150 Node *SafePointNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1151   return remove_dead_region(phase, can_reshape) ? this : NULL;
1152 }
1153 
1154 //------------------------------Identity---------------------------------------
1155 // Remove obviously duplicate safepoints
1156 Node* SafePointNode::Identity(PhaseGVN* phase) {
1157 
1158   // If you have back to back safepoints, remove one
1159   if( in(TypeFunc::Control)-&gt;is_SafePoint() )
1160     return in(TypeFunc::Control);
1161 
1162   if( in(0)-&gt;is_Proj() ) {
1163     Node *n0 = in(0)-&gt;in(0);
1164     // Check if he is a call projection (except Leaf Call)
1165     if( n0-&gt;is_Catch() ) {
1166       n0 = n0-&gt;in(0)-&gt;in(0);
1167       assert( n0-&gt;is_Call(), &quot;expect a call here&quot; );
1168     }
1169     if( n0-&gt;is_Call() &amp;&amp; n0-&gt;as_Call()-&gt;guaranteed_safepoint() ) {
1170       // Don&#39;t remove a safepoint belonging to an OuterStripMinedLoopEndNode.
1171       // If the loop dies, they will be removed together.
1172       if (has_out_with(Op_OuterStripMinedLoopEnd)) {
1173         return this;
1174       }
1175       // Useless Safepoint, so remove it
1176       return in(TypeFunc::Control);
1177     }
1178   }
1179 
1180   return this;
1181 }
1182 
1183 //------------------------------Value------------------------------------------
1184 const Type* SafePointNode::Value(PhaseGVN* phase) const {
1185   if( phase-&gt;type(in(0)) == Type::TOP ) return Type::TOP;
1186   if( phase-&gt;eqv( in(0), this ) ) return Type::TOP; // Dead infinite loop
1187   return Type::CONTROL;
1188 }
1189 
1190 #ifndef PRODUCT
1191 void SafePointNode::dump_spec(outputStream *st) const {
1192   st-&gt;print(&quot; SafePoint &quot;);
1193   _replaced_nodes.dump(st);
1194 }
1195 
1196 // The related nodes of a SafepointNode are all data inputs, excluding the
1197 // control boundary, as well as all outputs till level 2 (to include projection
1198 // nodes and targets). In compact mode, just include inputs till level 1 and
1199 // outputs as before.
1200 void SafePointNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1201   if (compact) {
1202     this-&gt;collect_nodes(in_rel, 1, false, false);
1203   } else {
1204     this-&gt;collect_nodes_in_all_data(in_rel, false);
1205   }
1206   this-&gt;collect_nodes(out_rel, -2, false, false);
1207 }
1208 #endif
1209 
1210 const RegMask &amp;SafePointNode::in_RegMask(uint idx) const {
1211   if( idx &lt; TypeFunc::Parms ) return RegMask::Empty;
1212   // Values outside the domain represent debug info
1213   return *(Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()]);
1214 }
1215 const RegMask &amp;SafePointNode::out_RegMask() const {
1216   return RegMask::Empty;
1217 }
1218 
1219 
1220 void SafePointNode::grow_stack(JVMState* jvms, uint grow_by) {
1221   assert((int)grow_by &gt; 0, &quot;sanity&quot;);
1222   int monoff = jvms-&gt;monoff();
1223   int scloff = jvms-&gt;scloff();
1224   int endoff = jvms-&gt;endoff();
1225   assert(endoff == (int)req(), &quot;no other states or debug info after me&quot;);
1226   Node* top = Compile::current()-&gt;top();
1227   for (uint i = 0; i &lt; grow_by; i++) {
1228     ins_req(monoff, top);
1229   }
1230   jvms-&gt;set_monoff(monoff + grow_by);
1231   jvms-&gt;set_scloff(scloff + grow_by);
1232   jvms-&gt;set_endoff(endoff + grow_by);
1233 }
1234 
1235 void SafePointNode::push_monitor(const FastLockNode *lock) {
1236   // Add a LockNode, which points to both the original BoxLockNode (the
1237   // stack space for the monitor) and the Object being locked.
1238   const int MonitorEdges = 2;
1239   assert(JVMState::logMonitorEdges == exact_log2(MonitorEdges), &quot;correct MonitorEdges&quot;);
1240   assert(req() == jvms()-&gt;endoff(), &quot;correct sizing&quot;);
1241   int nextmon = jvms()-&gt;scloff();
1242   if (GenerateSynchronizationCode) {
1243     ins_req(nextmon,   lock-&gt;box_node());
1244     ins_req(nextmon+1, lock-&gt;obj_node());
1245   } else {
1246     Node* top = Compile::current()-&gt;top();
1247     ins_req(nextmon, top);
1248     ins_req(nextmon, top);
1249   }
1250   jvms()-&gt;set_scloff(nextmon + MonitorEdges);
1251   jvms()-&gt;set_endoff(req());
1252 }
1253 
1254 void SafePointNode::pop_monitor() {
1255   // Delete last monitor from debug info
1256   debug_only(int num_before_pop = jvms()-&gt;nof_monitors());
1257   const int MonitorEdges = 2;
1258   assert(JVMState::logMonitorEdges == exact_log2(MonitorEdges), &quot;correct MonitorEdges&quot;);
1259   int scloff = jvms()-&gt;scloff();
1260   int endoff = jvms()-&gt;endoff();
1261   int new_scloff = scloff - MonitorEdges;
1262   int new_endoff = endoff - MonitorEdges;
1263   jvms()-&gt;set_scloff(new_scloff);
1264   jvms()-&gt;set_endoff(new_endoff);
1265   while (scloff &gt; new_scloff)  del_req_ordered(--scloff);
1266   assert(jvms()-&gt;nof_monitors() == num_before_pop-1, &quot;&quot;);
1267 }
1268 
1269 Node *SafePointNode::peek_monitor_box() const {
1270   int mon = jvms()-&gt;nof_monitors() - 1;
1271   assert(mon &gt;= 0, &quot;must have a monitor&quot;);
1272   return monitor_box(jvms(), mon);
1273 }
1274 
1275 Node *SafePointNode::peek_monitor_obj() const {
1276   int mon = jvms()-&gt;nof_monitors() - 1;
1277   assert(mon &gt;= 0, &quot;must have a monitor&quot;);
1278   return monitor_obj(jvms(), mon);
1279 }
1280 
1281 // Do we Match on this edge index or not?  Match no edges
1282 uint SafePointNode::match_edge(uint idx) const {
1283   if( !needs_polling_address_input() )
1284     return 0;
1285 
1286   return (TypeFunc::Parms == idx);
1287 }
1288 
1289 void SafePointNode::disconnect_from_root(PhaseIterGVN *igvn) {
1290   assert(Opcode() == Op_SafePoint, &quot;only value for safepoint in loops&quot;);
1291   int nb = igvn-&gt;C-&gt;root()-&gt;find_prec_edge(this);
1292   if (nb != -1) {
1293     igvn-&gt;C-&gt;root()-&gt;rm_prec(nb);
1294   }
1295 }
1296 
1297 //==============  SafePointScalarObjectNode  ==============
1298 
1299 SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp,
1300 #ifdef ASSERT
1301                                                      AllocateNode* alloc,
1302 #endif
1303                                                      uint first_index,
1304                                                      uint n_fields) :
1305   TypeNode(tp, 1), // 1 control input -- seems required.  Get from root.
1306   _first_index(first_index),
1307   _n_fields(n_fields)
1308 #ifdef ASSERT
1309   , _alloc(alloc)
1310 #endif
1311 {
1312   init_class_id(Class_SafePointScalarObject);
1313 }
1314 
1315 // Do not allow value-numbering for SafePointScalarObject node.
1316 uint SafePointScalarObjectNode::hash() const { return NO_HASH; }
1317 bool SafePointScalarObjectNode::cmp( const Node &amp;n ) const {
1318   return (&amp;n == this); // Always fail except on self
1319 }
1320 
1321 uint SafePointScalarObjectNode::ideal_reg() const {
1322   return 0; // No matching to machine instruction
1323 }
1324 
1325 const RegMask &amp;SafePointScalarObjectNode::in_RegMask(uint idx) const {
1326   return *(Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()]);
1327 }
1328 
1329 const RegMask &amp;SafePointScalarObjectNode::out_RegMask() const {
1330   return RegMask::Empty;
1331 }
1332 
1333 uint SafePointScalarObjectNode::match_edge(uint idx) const {
1334   return 0;
1335 }
1336 
1337 SafePointScalarObjectNode*
1338 SafePointScalarObjectNode::clone(Dict* sosn_map) const {
1339   void* cached = (*sosn_map)[(void*)this];
1340   if (cached != NULL) {
1341     return (SafePointScalarObjectNode*)cached;
1342   }
1343   SafePointScalarObjectNode* res = (SafePointScalarObjectNode*)Node::clone();
1344   sosn_map-&gt;Insert((void*)this, (void*)res);
1345   return res;
1346 }
1347 
1348 
1349 #ifndef PRODUCT
1350 void SafePointScalarObjectNode::dump_spec(outputStream *st) const {
1351   st-&gt;print(&quot; # fields@[%d..%d]&quot;, first_index(),
1352              first_index() + n_fields() - 1);
1353 }
1354 
1355 #endif
1356 
1357 //=============================================================================
1358 uint AllocateNode::size_of() const { return sizeof(*this); }
1359 
1360 AllocateNode::AllocateNode(Compile* C, const TypeFunc *atype,
1361                            Node *ctrl, Node *mem, Node *abio,
1362                            Node *size, Node *klass_node, Node *initial_test)
1363   : CallNode(atype, NULL, TypeRawPtr::BOTTOM)
1364 {
1365   init_class_id(Class_Allocate);
1366   init_flags(Flag_is_macro);
1367   _is_scalar_replaceable = false;
1368   _is_non_escaping = false;
1369   _is_allocation_MemBar_redundant = false;
1370   Node *topnode = C-&gt;top();
1371 
1372   init_req( TypeFunc::Control  , ctrl );
1373   init_req( TypeFunc::I_O      , abio );
1374   init_req( TypeFunc::Memory   , mem );
1375   init_req( TypeFunc::ReturnAdr, topnode );
1376   init_req( TypeFunc::FramePtr , topnode );
1377   init_req( AllocSize          , size);
1378   init_req( KlassNode          , klass_node);
1379   init_req( InitialTest        , initial_test);
1380   init_req( ALength            , topnode);
1381   C-&gt;add_macro_node(this);
1382 }
1383 
1384 void AllocateNode::compute_MemBar_redundancy(ciMethod* initializer)
1385 {
1386   assert(initializer != NULL &amp;&amp;
1387          initializer-&gt;is_initializer() &amp;&amp;
1388          !initializer-&gt;is_static(),
1389              &quot;unexpected initializer method&quot;);
1390   BCEscapeAnalyzer* analyzer = initializer-&gt;get_bcea();
1391   if (analyzer == NULL) {
1392     return;
1393   }
1394 
1395   // Allocation node is first parameter in its initializer
1396   if (analyzer-&gt;is_arg_stack(0) || analyzer-&gt;is_arg_local(0)) {
1397     _is_allocation_MemBar_redundant = true;
1398   }
1399 }
1400 Node *AllocateNode::make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem) {
1401   Node* mark_node = NULL;
1402   // For now only enable fast locking for non-array types
1403   if (UseBiasedLocking &amp;&amp; Opcode() == Op_Allocate) {
1404     Node* klass_node = in(AllocateNode::KlassNode);
1405     Node* proto_adr = phase-&gt;transform(new AddPNode(klass_node, klass_node, phase-&gt;MakeConX(in_bytes(Klass::prototype_header_offset()))));
1406     mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
1407   } else {
1408     mark_node = phase-&gt;MakeConX(markWord::prototype().value());
1409   }
1410   return mark_node;
1411 }
1412 
1413 //=============================================================================
1414 Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1415   if (remove_dead_region(phase, can_reshape))  return this;
1416   // Don&#39;t bother trying to transform a dead node
1417   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
1418 
1419   const Type* type = phase-&gt;type(Ideal_length());
1420   if (type-&gt;isa_int() &amp;&amp; type-&gt;is_int()-&gt;_hi &lt; 0) {
1421     if (can_reshape) {
1422       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1423       // Unreachable fall through path (negative array length),
1424       // the allocation can only throw so disconnect it.
1425       Node* proj = proj_out_or_null(TypeFunc::Control);
1426       Node* catchproj = NULL;
1427       if (proj != NULL) {
1428         for (DUIterator_Fast imax, i = proj-&gt;fast_outs(imax); i &lt; imax; i++) {
1429           Node *cn = proj-&gt;fast_out(i);
1430           if (cn-&gt;is_Catch()) {
1431             catchproj = cn-&gt;as_Multi()-&gt;proj_out_or_null(CatchProjNode::fall_through_index);
1432             break;
1433           }
1434         }
1435       }
1436       if (catchproj != NULL &amp;&amp; catchproj-&gt;outcnt() &gt; 0 &amp;&amp;
1437           (catchproj-&gt;outcnt() &gt; 1 ||
1438            catchproj-&gt;unique_out()-&gt;Opcode() != Op_Halt)) {
1439         assert(catchproj-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
1440         Node* nproj = catchproj-&gt;clone();
1441         igvn-&gt;register_new_node_with_optimizer(nproj);
1442 
1443         Node *frame = new ParmNode( phase-&gt;C-&gt;start(), TypeFunc::FramePtr );
1444         frame = phase-&gt;transform(frame);
1445         // Halt &amp; Catch Fire
1446         Node* halt = new HaltNode(nproj, frame, &quot;unexpected negative array length&quot;);
1447         phase-&gt;C-&gt;root()-&gt;add_req(halt);
1448         phase-&gt;transform(halt);
1449 
1450         igvn-&gt;replace_node(catchproj, phase-&gt;C-&gt;top());
1451         return this;
1452       }
1453     } else {
1454       // Can&#39;t correct it during regular GVN so register for IGVN
1455       phase-&gt;C-&gt;record_for_igvn(this);
1456     }
1457   }
1458   return NULL;
1459 }
1460 
1461 // Retrieve the length from the AllocateArrayNode. Narrow the type with a
1462 // CastII, if appropriate.  If we are not allowed to create new nodes, and
1463 // a CastII is appropriate, return NULL.
1464 Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseTransform *phase, bool allow_new_nodes) {
1465   Node *length = in(AllocateNode::ALength);
1466   assert(length != NULL, &quot;length is not null&quot;);
1467 
1468   const TypeInt* length_type = phase-&gt;find_int_type(length);
1469   const TypeAryPtr* ary_type = oop_type-&gt;isa_aryptr();
1470 
1471   if (ary_type != NULL &amp;&amp; length_type != NULL) {
1472     const TypeInt* narrow_length_type = ary_type-&gt;narrow_size_type(length_type);
1473     if (narrow_length_type != length_type) {
1474       // Assert one of:
1475       //   - the narrow_length is 0
1476       //   - the narrow_length is not wider than length
1477       assert(narrow_length_type == TypeInt::ZERO ||
1478              length_type-&gt;is_con() &amp;&amp; narrow_length_type-&gt;is_con() &amp;&amp;
1479                 (narrow_length_type-&gt;_hi &lt;= length_type-&gt;_lo) ||
1480              (narrow_length_type-&gt;_hi &lt;= length_type-&gt;_hi &amp;&amp;
1481               narrow_length_type-&gt;_lo &gt;= length_type-&gt;_lo),
1482              &quot;narrow type must be narrower than length type&quot;);
1483 
1484       // Return NULL if new nodes are not allowed
1485       if (!allow_new_nodes) return NULL;
1486       // Create a cast which is control dependent on the initialization to
1487       // propagate the fact that the array length must be positive.
1488       InitializeNode* init = initialization();
1489       assert(init != NULL, &quot;initialization not found&quot;);
1490       length = new CastIINode(length, narrow_length_type);
1491       length-&gt;set_req(0, init-&gt;proj_out_or_null(0));
1492     }
1493   }
1494 
1495   return length;
1496 }
1497 
1498 //=============================================================================
1499 uint LockNode::size_of() const { return sizeof(*this); }
1500 
1501 // Redundant lock elimination
1502 //
1503 // There are various patterns of locking where we release and
1504 // immediately reacquire a lock in a piece of code where no operations
1505 // occur in between that would be observable.  In those cases we can
1506 // skip releasing and reacquiring the lock without violating any
1507 // fairness requirements.  Doing this around a loop could cause a lock
1508 // to be held for a very long time so we concentrate on non-looping
1509 // control flow.  We also require that the operations are fully
1510 // redundant meaning that we don&#39;t introduce new lock operations on
1511 // some paths so to be able to eliminate it on others ala PRE.  This
1512 // would probably require some more extensive graph manipulation to
1513 // guarantee that the memory edges were all handled correctly.
1514 //
1515 // Assuming p is a simple predicate which can&#39;t trap in any way and s
1516 // is a synchronized method consider this code:
1517 //
1518 //   s();
1519 //   if (p)
1520 //     s();
1521 //   else
1522 //     s();
1523 //   s();
1524 //
1525 // 1. The unlocks of the first call to s can be eliminated if the
1526 // locks inside the then and else branches are eliminated.
1527 //
1528 // 2. The unlocks of the then and else branches can be eliminated if
1529 // the lock of the final call to s is eliminated.
1530 //
1531 // Either of these cases subsumes the simple case of sequential control flow
1532 //
1533 // Addtionally we can eliminate versions without the else case:
1534 //
1535 //   s();
1536 //   if (p)
1537 //     s();
1538 //   s();
1539 //
1540 // 3. In this case we eliminate the unlock of the first s, the lock
1541 // and unlock in the then case and the lock in the final s.
1542 //
1543 // Note also that in all these cases the then/else pieces don&#39;t have
1544 // to be trivial as long as they begin and end with synchronization
1545 // operations.
1546 //
1547 //   s();
1548 //   if (p)
1549 //     s();
1550 //     f();
1551 //     s();
1552 //   s();
1553 //
1554 // The code will work properly for this case, leaving in the unlock
1555 // before the call to f and the relock after it.
1556 //
1557 // A potentially interesting case which isn&#39;t handled here is when the
1558 // locking is partially redundant.
1559 //
1560 //   s();
1561 //   if (p)
1562 //     s();
1563 //
1564 // This could be eliminated putting unlocking on the else case and
1565 // eliminating the first unlock and the lock in the then side.
1566 // Alternatively the unlock could be moved out of the then side so it
1567 // was after the merge and the first unlock and second lock
1568 // eliminated.  This might require less manipulation of the memory
1569 // state to get correct.
1570 //
1571 // Additionally we might allow work between a unlock and lock before
1572 // giving up eliminating the locks.  The current code disallows any
1573 // conditional control flow between these operations.  A formulation
1574 // similar to partial redundancy elimination computing the
1575 // availability of unlocking and the anticipatability of locking at a
1576 // program point would allow detection of fully redundant locking with
1577 // some amount of work in between.  I&#39;m not sure how often I really
1578 // think that would occur though.  Most of the cases I&#39;ve seen
1579 // indicate it&#39;s likely non-trivial work would occur in between.
1580 // There may be other more complicated constructs where we could
1581 // eliminate locking but I haven&#39;t seen any others appear as hot or
1582 // interesting.
1583 //
1584 // Locking and unlocking have a canonical form in ideal that looks
1585 // roughly like this:
1586 //
1587 //              &lt;obj&gt;
1588 //                | \\------+
1589 //                |  \       \
1590 //                | BoxLock   \
1591 //                |  |   |     \
1592 //                |  |    \     \
1593 //                |  |   FastLock
1594 //                |  |   /
1595 //                |  |  /
1596 //                |  |  |
1597 //
1598 //               Lock
1599 //                |
1600 //            Proj #0
1601 //                |
1602 //            MembarAcquire
1603 //                |
1604 //            Proj #0
1605 //
1606 //            MembarRelease
1607 //                |
1608 //            Proj #0
1609 //                |
1610 //              Unlock
1611 //                |
1612 //            Proj #0
1613 //
1614 //
1615 // This code proceeds by processing Lock nodes during PhaseIterGVN
1616 // and searching back through its control for the proper code
1617 // patterns.  Once it finds a set of lock and unlock operations to
1618 // eliminate they are marked as eliminatable which causes the
1619 // expansion of the Lock and Unlock macro nodes to make the operation a NOP
1620 //
1621 //=============================================================================
1622 
1623 //
1624 // Utility function to skip over uninteresting control nodes.  Nodes skipped are:
1625 //   - copy regions.  (These may not have been optimized away yet.)
1626 //   - eliminated locking nodes
1627 //
1628 static Node *next_control(Node *ctrl) {
1629   if (ctrl == NULL)
1630     return NULL;
1631   while (1) {
1632     if (ctrl-&gt;is_Region()) {
1633       RegionNode *r = ctrl-&gt;as_Region();
1634       Node *n = r-&gt;is_copy();
1635       if (n == NULL)
1636         break;  // hit a region, return it
1637       else
1638         ctrl = n;
1639     } else if (ctrl-&gt;is_Proj()) {
1640       Node *in0 = ctrl-&gt;in(0);
1641       if (in0-&gt;is_AbstractLock() &amp;&amp; in0-&gt;as_AbstractLock()-&gt;is_eliminated()) {
1642         ctrl = in0-&gt;in(0);
1643       } else {
1644         break;
1645       }
1646     } else {
1647       break; // found an interesting control
1648     }
1649   }
1650   return ctrl;
1651 }
1652 //
1653 // Given a control, see if it&#39;s the control projection of an Unlock which
1654 // operating on the same object as lock.
1655 //
1656 bool AbstractLockNode::find_matching_unlock(const Node* ctrl, LockNode* lock,
1657                                             GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1658   ProjNode *ctrl_proj = (ctrl-&gt;is_Proj()) ? ctrl-&gt;as_Proj() : NULL;
1659   if (ctrl_proj != NULL &amp;&amp; ctrl_proj-&gt;_con == TypeFunc::Control) {
1660     Node *n = ctrl_proj-&gt;in(0);
1661     if (n != NULL &amp;&amp; n-&gt;is_Unlock()) {
1662       UnlockNode *unlock = n-&gt;as_Unlock();
1663       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1664       Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1665       Node* unlock_obj = bs-&gt;step_over_gc_barrier(unlock-&gt;obj_node());
1666       if (lock_obj-&gt;eqv_uncast(unlock_obj) &amp;&amp;
1667           BoxLockNode::same_slot(lock-&gt;box_node(), unlock-&gt;box_node()) &amp;&amp;
1668           !unlock-&gt;is_eliminated()) {
1669         lock_ops.append(unlock);
1670         return true;
1671       }
1672     }
1673   }
1674   return false;
1675 }
1676 
1677 //
1678 // Find the lock matching an unlock.  Returns null if a safepoint
1679 // or complicated control is encountered first.
1680 LockNode *AbstractLockNode::find_matching_lock(UnlockNode* unlock) {
1681   LockNode *lock_result = NULL;
1682   // find the matching lock, or an intervening safepoint
1683   Node *ctrl = next_control(unlock-&gt;in(0));
1684   while (1) {
1685     assert(ctrl != NULL, &quot;invalid control graph&quot;);
1686     assert(!ctrl-&gt;is_Start(), &quot;missing lock for unlock&quot;);
1687     if (ctrl-&gt;is_top()) break;  // dead control path
1688     if (ctrl-&gt;is_Proj()) ctrl = ctrl-&gt;in(0);
1689     if (ctrl-&gt;is_SafePoint()) {
1690         break;  // found a safepoint (may be the lock we are searching for)
1691     } else if (ctrl-&gt;is_Region()) {
1692       // Check for a simple diamond pattern.  Punt on anything more complicated
1693       if (ctrl-&gt;req() == 3 &amp;&amp; ctrl-&gt;in(1) != NULL &amp;&amp; ctrl-&gt;in(2) != NULL) {
1694         Node *in1 = next_control(ctrl-&gt;in(1));
1695         Node *in2 = next_control(ctrl-&gt;in(2));
1696         if (((in1-&gt;is_IfTrue() &amp;&amp; in2-&gt;is_IfFalse()) ||
1697              (in2-&gt;is_IfTrue() &amp;&amp; in1-&gt;is_IfFalse())) &amp;&amp; (in1-&gt;in(0) == in2-&gt;in(0))) {
1698           ctrl = next_control(in1-&gt;in(0)-&gt;in(0));
1699         } else {
1700           break;
1701         }
1702       } else {
1703         break;
1704       }
1705     } else {
1706       ctrl = next_control(ctrl-&gt;in(0));  // keep searching
1707     }
1708   }
1709   if (ctrl-&gt;is_Lock()) {
1710     LockNode *lock = ctrl-&gt;as_Lock();
1711     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1712     Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1713     Node* unlock_obj = bs-&gt;step_over_gc_barrier(unlock-&gt;obj_node());
1714     if (lock_obj-&gt;eqv_uncast(unlock_obj) &amp;&amp;
1715         BoxLockNode::same_slot(lock-&gt;box_node(), unlock-&gt;box_node())) {
1716       lock_result = lock;
1717     }
1718   }
1719   return lock_result;
1720 }
1721 
1722 // This code corresponds to case 3 above.
1723 
1724 bool AbstractLockNode::find_lock_and_unlock_through_if(Node* node, LockNode* lock,
1725                                                        GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1726   Node* if_node = node-&gt;in(0);
1727   bool  if_true = node-&gt;is_IfTrue();
1728 
1729   if (if_node-&gt;is_If() &amp;&amp; if_node-&gt;outcnt() == 2 &amp;&amp; (if_true || node-&gt;is_IfFalse())) {
1730     Node *lock_ctrl = next_control(if_node-&gt;in(0));
1731     if (find_matching_unlock(lock_ctrl, lock, lock_ops)) {
1732       Node* lock1_node = NULL;
1733       ProjNode* proj = if_node-&gt;as_If()-&gt;proj_out(!if_true);
1734       if (if_true) {
1735         if (proj-&gt;is_IfFalse() &amp;&amp; proj-&gt;outcnt() == 1) {
1736           lock1_node = proj-&gt;unique_out();
1737         }
1738       } else {
1739         if (proj-&gt;is_IfTrue() &amp;&amp; proj-&gt;outcnt() == 1) {
1740           lock1_node = proj-&gt;unique_out();
1741         }
1742       }
1743       if (lock1_node != NULL &amp;&amp; lock1_node-&gt;is_Lock()) {
1744         LockNode *lock1 = lock1_node-&gt;as_Lock();
1745         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1746         Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1747         Node* lock1_obj = bs-&gt;step_over_gc_barrier(lock1-&gt;obj_node());
1748         if (lock_obj-&gt;eqv_uncast(lock1_obj) &amp;&amp;
1749             BoxLockNode::same_slot(lock-&gt;box_node(), lock1-&gt;box_node()) &amp;&amp;
1750             !lock1-&gt;is_eliminated()) {
1751           lock_ops.append(lock1);
1752           return true;
1753         }
1754       }
1755     }
1756   }
1757 
1758   lock_ops.trunc_to(0);
1759   return false;
1760 }
1761 
1762 bool AbstractLockNode::find_unlocks_for_region(const RegionNode* region, LockNode* lock,
1763                                GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1764   // check each control merging at this point for a matching unlock.
1765   // in(0) should be self edge so skip it.
1766   for (int i = 1; i &lt; (int)region-&gt;req(); i++) {
1767     Node *in_node = next_control(region-&gt;in(i));
1768     if (in_node != NULL) {
1769       if (find_matching_unlock(in_node, lock, lock_ops)) {
1770         // found a match so keep on checking.
1771         continue;
1772       } else if (find_lock_and_unlock_through_if(in_node, lock, lock_ops)) {
1773         continue;
1774       }
1775 
1776       // If we fall through to here then it was some kind of node we
1777       // don&#39;t understand or there wasn&#39;t a matching unlock, so give
1778       // up trying to merge locks.
1779       lock_ops.trunc_to(0);
1780       return false;
1781     }
1782   }
1783   return true;
1784 
1785 }
1786 
1787 #ifndef PRODUCT
1788 //
1789 // Create a counter which counts the number of times this lock is acquired
1790 //
1791 void AbstractLockNode::create_lock_counter(JVMState* state) {
1792   _counter = OptoRuntime::new_named_counter(state, NamedCounter::LockCounter);
1793 }
1794 
1795 void AbstractLockNode::set_eliminated_lock_counter() {
1796   if (_counter) {
1797     // Update the counter to indicate that this lock was eliminated.
1798     // The counter update code will stay around even though the
1799     // optimizer will eliminate the lock operation itself.
1800     _counter-&gt;set_tag(NamedCounter::EliminatedLockCounter);
1801   }
1802 }
1803 
1804 const char* AbstractLockNode::_kind_names[] = {&quot;Regular&quot;, &quot;NonEscObj&quot;, &quot;Coarsened&quot;, &quot;Nested&quot;};
1805 
1806 void AbstractLockNode::dump_spec(outputStream* st) const {
1807   st-&gt;print(&quot;%s &quot;, _kind_names[_kind]);
1808   CallNode::dump_spec(st);
1809 }
1810 
1811 void AbstractLockNode::dump_compact_spec(outputStream* st) const {
1812   st-&gt;print(&quot;%s&quot;, _kind_names[_kind]);
1813 }
1814 
1815 // The related set of lock nodes includes the control boundary.
1816 void AbstractLockNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1817   if (compact) {
1818       this-&gt;collect_nodes(in_rel, 1, false, false);
1819     } else {
1820       this-&gt;collect_nodes_in_all_data(in_rel, true);
1821     }
1822     this-&gt;collect_nodes(out_rel, -2, false, false);
1823 }
1824 #endif
1825 
1826 //=============================================================================
1827 Node *LockNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1828 
1829   // perform any generic optimizations first (returns &#39;this&#39; or NULL)
1830   Node *result = SafePointNode::Ideal(phase, can_reshape);
1831   if (result != NULL)  return result;
1832   // Don&#39;t bother trying to transform a dead node
1833   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
1834 
1835   // Now see if we can optimize away this lock.  We don&#39;t actually
1836   // remove the locking here, we simply set the _eliminate flag which
1837   // prevents macro expansion from expanding the lock.  Since we don&#39;t
1838   // modify the graph, the value returned from this function is the
1839   // one computed above.
1840   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj()) {
1841     //
1842     // If we are locking an unescaped object, the lock/unlock is unnecessary
1843     //
1844     ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
1845     if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
1846       assert(!is_eliminated() || is_coarsened(), &quot;sanity&quot;);
1847       // The lock could be marked eliminated by lock coarsening
1848       // code during first IGVN before EA. Replace coarsened flag
1849       // to eliminate all associated locks/unlocks.
1850 #ifdef ASSERT
1851       this-&gt;log_lock_optimization(phase-&gt;C,&quot;eliminate_lock_set_non_esc1&quot;);
1852 #endif
1853       this-&gt;set_non_esc_obj();
1854       return result;
1855     }
1856 
1857     //
1858     // Try lock coarsening
1859     //
1860     PhaseIterGVN* iter = phase-&gt;is_IterGVN();
1861     if (iter != NULL &amp;&amp; !is_eliminated()) {
1862 
1863       GrowableArray&lt;AbstractLockNode*&gt;   lock_ops;
1864 
1865       Node *ctrl = next_control(in(0));
1866 
1867       // now search back for a matching Unlock
1868       if (find_matching_unlock(ctrl, this, lock_ops)) {
1869         // found an unlock directly preceding this lock.  This is the
1870         // case of single unlock directly control dependent on a
1871         // single lock which is the trivial version of case 1 or 2.
1872       } else if (ctrl-&gt;is_Region() ) {
1873         if (find_unlocks_for_region(ctrl-&gt;as_Region(), this, lock_ops)) {
1874         // found lock preceded by multiple unlocks along all paths
1875         // joining at this point which is case 3 in description above.
1876         }
1877       } else {
1878         // see if this lock comes from either half of an if and the
1879         // predecessors merges unlocks and the other half of the if
1880         // performs a lock.
1881         if (find_lock_and_unlock_through_if(ctrl, this, lock_ops)) {
1882           // found unlock splitting to an if with locks on both branches.
1883         }
1884       }
1885 
1886       if (lock_ops.length() &gt; 0) {
1887         // add ourselves to the list of locks to be eliminated.
1888         lock_ops.append(this);
1889 
1890   #ifndef PRODUCT
1891         if (PrintEliminateLocks) {
1892           int locks = 0;
1893           int unlocks = 0;
1894           for (int i = 0; i &lt; lock_ops.length(); i++) {
1895             AbstractLockNode* lock = lock_ops.at(i);
1896             if (lock-&gt;Opcode() == Op_Lock)
1897               locks++;
1898             else
1899               unlocks++;
1900             if (Verbose) {
1901               lock-&gt;dump(1);
1902             }
1903           }
1904           tty-&gt;print_cr(&quot;***Eliminated %d unlocks and %d locks&quot;, unlocks, locks);
1905         }
1906   #endif
1907 
1908         // for each of the identified locks, mark them
1909         // as eliminatable
1910         for (int i = 0; i &lt; lock_ops.length(); i++) {
1911           AbstractLockNode* lock = lock_ops.at(i);
1912 
1913           // Mark it eliminated by coarsening and update any counters
1914 #ifdef ASSERT
1915           lock-&gt;log_lock_optimization(phase-&gt;C, &quot;eliminate_lock_set_coarsened&quot;);
1916 #endif
1917           lock-&gt;set_coarsened();
1918         }
1919       } else if (ctrl-&gt;is_Region() &amp;&amp;
1920                  iter-&gt;_worklist.member(ctrl)) {
1921         // We weren&#39;t able to find any opportunities but the region this
1922         // lock is control dependent on hasn&#39;t been processed yet so put
1923         // this lock back on the worklist so we can check again once any
1924         // region simplification has occurred.
1925         iter-&gt;_worklist.push(this);
1926       }
1927     }
1928   }
1929 
1930   return result;
1931 }
1932 
1933 //=============================================================================
1934 bool LockNode::is_nested_lock_region() {
1935   return is_nested_lock_region(NULL);
1936 }
1937 
1938 // p is used for access to compilation log; no logging if NULL
1939 bool LockNode::is_nested_lock_region(Compile * c) {
1940   BoxLockNode* box = box_node()-&gt;as_BoxLock();
1941   int stk_slot = box-&gt;stack_slot();
1942   if (stk_slot &lt;= 0) {
1943 #ifdef ASSERT
1944     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_1&quot;);
1945 #endif
1946     return false; // External lock or it is not Box (Phi node).
1947   }
1948 
1949   // Ignore complex cases: merged locks or multiple locks.
1950   Node* obj = obj_node();
1951   LockNode* unique_lock = NULL;
1952   if (!box-&gt;is_simple_lock_region(&amp;unique_lock, obj)) {
1953 #ifdef ASSERT
1954     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_2a&quot;);
1955 #endif
1956     return false;
1957   }
1958   if (unique_lock != this) {
1959 #ifdef ASSERT
1960     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_2b&quot;);
1961 #endif
1962     return false;
1963   }
1964 
1965   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1966   obj = bs-&gt;step_over_gc_barrier(obj);
1967   // Look for external lock for the same object.
1968   SafePointNode* sfn = this-&gt;as_SafePoint();
1969   JVMState* youngest_jvms = sfn-&gt;jvms();
1970   int max_depth = youngest_jvms-&gt;depth();
1971   for (int depth = 1; depth &lt;= max_depth; depth++) {
1972     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1973     int num_mon  = jvms-&gt;nof_monitors();
1974     // Loop over monitors
1975     for (int idx = 0; idx &lt; num_mon; idx++) {
1976       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
1977       obj_node = bs-&gt;step_over_gc_barrier(obj_node);
1978       BoxLockNode* box_node = sfn-&gt;monitor_box(jvms, idx)-&gt;as_BoxLock();
1979       if ((box_node-&gt;stack_slot() &lt; stk_slot) &amp;&amp; obj_node-&gt;eqv_uncast(obj)) {
1980         return true;
1981       }
1982     }
1983   }
1984 #ifdef ASSERT
1985   this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_3&quot;);
1986 #endif
1987   return false;
1988 }
1989 
1990 //=============================================================================
1991 uint UnlockNode::size_of() const { return sizeof(*this); }
1992 
1993 //=============================================================================
1994 Node *UnlockNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1995 
1996   // perform any generic optimizations first (returns &#39;this&#39; or NULL)
1997   Node *result = SafePointNode::Ideal(phase, can_reshape);
1998   if (result != NULL)  return result;
1999   // Don&#39;t bother trying to transform a dead node
2000   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
2001 
2002   // Now see if we can optimize away this unlock.  We don&#39;t actually
2003   // remove the unlocking here, we simply set the _eliminate flag which
2004   // prevents macro expansion from expanding the unlock.  Since we don&#39;t
2005   // modify the graph, the value returned from this function is the
2006   // one computed above.
2007   // Escape state is defined after Parse phase.
2008   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj()) {
2009     //
2010     // If we are unlocking an unescaped object, the lock/unlock is unnecessary.
2011     //
2012     ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
2013     if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
2014       assert(!is_eliminated() || is_coarsened(), &quot;sanity&quot;);
2015       // The lock could be marked eliminated by lock coarsening
2016       // code during first IGVN before EA. Replace coarsened flag
2017       // to eliminate all associated locks/unlocks.
2018 #ifdef ASSERT
2019       this-&gt;log_lock_optimization(phase-&gt;C, &quot;eliminate_lock_set_non_esc2&quot;);
2020 #endif
2021       this-&gt;set_non_esc_obj();
2022     }
2023   }
2024   return result;
2025 }
2026 
2027 const char * AbstractLockNode::kind_as_string() const {
2028   return is_coarsened()   ? &quot;coarsened&quot; :
2029          is_nested()      ? &quot;nested&quot; :
2030          is_non_esc_obj() ? &quot;non_escaping&quot; :
2031          &quot;?&quot;;
2032 }
2033 
2034 void AbstractLockNode::log_lock_optimization(Compile *C, const char * tag)  const {
2035   if (C == NULL) {
2036     return;
2037   }
2038   CompileLog* log = C-&gt;log();
2039   if (log != NULL) {
2040     log-&gt;begin_head(&quot;%s lock=&#39;%d&#39; compile_id=&#39;%d&#39; class_id=&#39;%s&#39; kind=&#39;%s&#39;&quot;,
2041           tag, is_Lock(), C-&gt;compile_id(),
2042           is_Unlock() ? &quot;unlock&quot; : is_Lock() ? &quot;lock&quot; : &quot;?&quot;,
2043           kind_as_string());
2044     log-&gt;stamp();
2045     log-&gt;end_head();
2046     JVMState* p = is_Unlock() ? (as_Unlock()-&gt;dbg_jvms()) : jvms();
2047     while (p != NULL) {
2048       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
2049       p = p-&gt;caller();
2050     }
2051     log-&gt;tail(tag);
2052   }
2053 }
2054 
2055 bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase) {
2056   if (dest_t-&gt;is_known_instance() &amp;&amp; t_oop-&gt;is_known_instance()) {
2057     return dest_t-&gt;instance_id() == t_oop-&gt;instance_id();
2058   }
2059 
2060   if (dest_t-&gt;isa_instptr() &amp;&amp; !dest_t-&gt;klass()-&gt;equals(phase-&gt;C-&gt;env()-&gt;Object_klass())) {
2061     // clone
2062     if (t_oop-&gt;isa_aryptr()) {
2063       return false;
2064     }
2065     if (!t_oop-&gt;isa_instptr()) {
2066       return true;
2067     }
2068     if (dest_t-&gt;klass()-&gt;is_subtype_of(t_oop-&gt;klass()) || t_oop-&gt;klass()-&gt;is_subtype_of(dest_t-&gt;klass())) {
2069       return true;
2070     }
2071     // unrelated
2072     return false;
2073   }
2074 
2075   if (dest_t-&gt;isa_aryptr()) {
2076     // arraycopy or array clone
2077     if (t_oop-&gt;isa_instptr()) {
2078       return false;
2079     }
2080     if (!t_oop-&gt;isa_aryptr()) {
2081       return true;
2082     }
2083 
2084     const Type* elem = dest_t-&gt;is_aryptr()-&gt;elem();
2085     if (elem == Type::BOTTOM) {
2086       // An array but we don&#39;t know what elements are
2087       return true;
2088     }
2089 
2090     dest_t = dest_t-&gt;add_offset(Type::OffsetBot)-&gt;is_oopptr();
2091     uint dest_alias = phase-&gt;C-&gt;get_alias_index(dest_t);
2092     uint t_oop_alias = phase-&gt;C-&gt;get_alias_index(t_oop);
2093 
2094     return dest_alias == t_oop_alias;
2095   }
2096 
2097   return true;
2098 }
    </pre>
  </body>
</html>
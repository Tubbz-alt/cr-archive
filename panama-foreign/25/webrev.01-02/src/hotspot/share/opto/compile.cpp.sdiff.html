<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="divnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4222     if (subk-&gt;is_subtype_of(superk)) {
4223       return SSC_always_true;   // (1) false path dead; no dynamic test needed
4224     }
4225     if (!(superelem-&gt;is_klass() &amp;&amp; superelem-&gt;as_klass()-&gt;is_interface()) &amp;&amp;
4226         !superk-&gt;is_subtype_of(subk)) {
4227       return SSC_always_false;
4228     }
4229   }
4230 
4231   // If casting to an instance klass, it must have no subtypes
4232   if (superk-&gt;is_interface()) {
4233     // Cannot trust interfaces yet.
4234     // %%% S.B. superk-&gt;nof_implementors() == 1
4235   } else if (superelem-&gt;is_instance_klass()) {
4236     ciInstanceKlass* ik = superelem-&gt;as_instance_klass();
4237     if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
4238       if (!ik-&gt;is_final()) {
4239         // Add a dependency if there is a chance of a later subclass.
4240         dependencies()-&gt;assert_leaf_type(ik);
4241       }



4242       return SSC_easy_test;     // (3) caller can do a simple ptr comparison
4243     }
4244   } else {
4245     // A primitive array type has no subtypes.
4246     return SSC_easy_test;       // (3) caller can do a simple ptr comparison
4247   }
4248 
4249   return SSC_full_test;
4250 }
4251 
4252 Node* Compile::conv_I2X_index(PhaseGVN* phase, Node* idx, const TypeInt* sizetype, Node* ctrl) {
4253 #ifdef _LP64
4254   // The scaled index operand to AddP must be a clean 64-bit value.
4255   // Java allows a 32-bit int to be incremented to a negative
4256   // value, which appears in a 64-bit register as a large
4257   // positive number.  Using that large positive number as an
4258   // operand in pointer arithmetic has bad consequences.
4259   // On the other hand, 32-bit overflow is rare, and the possibility
4260   // can often be excluded, if we annotate the ConvI2L node with
4261   // a type assertion that its value is known to be a small positive
</pre>
</td>
<td>
<hr />
<pre>
4222     if (subk-&gt;is_subtype_of(superk)) {
4223       return SSC_always_true;   // (1) false path dead; no dynamic test needed
4224     }
4225     if (!(superelem-&gt;is_klass() &amp;&amp; superelem-&gt;as_klass()-&gt;is_interface()) &amp;&amp;
4226         !superk-&gt;is_subtype_of(subk)) {
4227       return SSC_always_false;
4228     }
4229   }
4230 
4231   // If casting to an instance klass, it must have no subtypes
4232   if (superk-&gt;is_interface()) {
4233     // Cannot trust interfaces yet.
4234     // %%% S.B. superk-&gt;nof_implementors() == 1
4235   } else if (superelem-&gt;is_instance_klass()) {
4236     ciInstanceKlass* ik = superelem-&gt;as_instance_klass();
4237     if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
4238       if (!ik-&gt;is_final()) {
4239         // Add a dependency if there is a chance of a later subclass.
4240         dependencies()-&gt;assert_leaf_type(ik);
4241       }
<span class="line-added">4242       if (ik-&gt;is_abstract()) {</span>
<span class="line-added">4243         return SSC_always_false;</span>
<span class="line-added">4244       }</span>
4245       return SSC_easy_test;     // (3) caller can do a simple ptr comparison
4246     }
4247   } else {
4248     // A primitive array type has no subtypes.
4249     return SSC_easy_test;       // (3) caller can do a simple ptr comparison
4250   }
4251 
4252   return SSC_full_test;
4253 }
4254 
4255 Node* Compile::conv_I2X_index(PhaseGVN* phase, Node* idx, const TypeInt* sizetype, Node* ctrl) {
4256 #ifdef _LP64
4257   // The scaled index operand to AddP must be a clean 64-bit value.
4258   // Java allows a 32-bit int to be incremented to a negative
4259   // value, which appears in a 64-bit register as a large
4260   // positive number.  Using that large positive number as an
4261   // operand in pointer arithmetic has bad consequences.
4262   // On the other hand, 32-bit overflow is rare, and the possibility
4263   // can often be excluded, if we annotate the ConvI2L node with
4264   // a type assertion that its value is known to be a small positive
</pre>
</td>
</tr>
</table>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="divnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
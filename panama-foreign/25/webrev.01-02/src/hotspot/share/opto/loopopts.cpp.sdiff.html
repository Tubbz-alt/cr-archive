<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopopts.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopopts.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/divnode.hpp&quot;
  36 #include &quot;opto/loopnode.hpp&quot;
  37 #include &quot;opto/matcher.hpp&quot;
  38 #include &quot;opto/mulnode.hpp&quot;
  39 #include &quot;opto/movenode.hpp&quot;
  40 #include &quot;opto/opaquenode.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/subnode.hpp&quot;

  43 #include &quot;utilities/macros.hpp&quot;
  44 
  45 //=============================================================================
  46 //------------------------------split_thru_phi---------------------------------
  47 // Split Node &#39;n&#39; through merge point if there is enough win.
  48 Node *PhaseIdealLoop::split_thru_phi( Node *n, Node *region, int policy ) {
  49   if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; n-&gt;bottom_type() != TypeLong::LONG) {
  50     // ConvI2L may have type information on it which is unsafe to push up
  51     // so disable this for now
  52     return NULL;
  53   }
  54 
  55   // Splitting range check CastIIs through a loop induction Phi can
  56   // cause new Phis to be created that are left unrelated to the loop
  57   // induction Phi and prevent optimizations (vectorization)
  58   if (n-&gt;Opcode() == Op_CastII &amp;&amp; n-&gt;as_CastII()-&gt;has_range_check() &amp;&amp;
  59       region-&gt;is_CountedLoop() &amp;&amp; n-&gt;in(1) == region-&gt;as_CountedLoop()-&gt;phi()) {
  60     return NULL;
  61   }
  62 
</pre>
<hr />
<pre>
 639     for (DUIterator_Fast kmax, k = phi-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 640       Node* use = phi-&gt;fast_out(k);
 641       if (use-&gt;is_Cmp() || use-&gt;is_DecodeNarrowPtr() || use-&gt;is_EncodeNarrowPtr())
 642         cost += ConditionalMoveLimit;
 643       // Is there a use inside the loop?
 644       // Note: check only basic types since CMoveP is pinned.
 645       if (!used_inside_loop &amp;&amp; is_java_primitive(bt)) {
 646         IdealLoopTree* u_loop = get_loop(has_ctrl(use) ? get_ctrl(use) : use);
 647         if (r_loop == u_loop || r_loop-&gt;is_member(u_loop)) {
 648           used_inside_loop = true;
 649         }
 650       }
 651     }
 652   }//for
 653   Node* bol = iff-&gt;in(1);
 654   if (bol-&gt;Opcode() == Op_Opaque4) {
 655     return NULL; // Ignore loop predicate checks (the Opaque4 ensures they will go away)
 656   }
 657   assert(bol-&gt;Opcode() == Op_Bool, &quot;Unexpected node&quot;);
 658   int cmp_op = bol-&gt;in(1)-&gt;Opcode();



 659   // It is expensive to generate flags from a float compare.
 660   // Avoid duplicated float compare.
 661   if (phis &gt; 1 &amp;&amp; (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) return NULL;
 662 
 663   float infrequent_prob = PROB_UNLIKELY_MAG(3);
 664   // Ignore cost and blocks frequency if CMOVE can be moved outside the loop.
 665   if (used_inside_loop) {
 666     if (cost &gt;= ConditionalMoveLimit) return NULL; // Too much goo
 667 
 668     // BlockLayoutByFrequency optimization moves infrequent branch
 669     // from hot path. No point in CMOV&#39;ing in such case (110 is used
 670     // instead of 100 to take into account not exactness of float value).
 671     if (BlockLayoutByFrequency) {
 672       infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage/110.0f);
 673     }
 674   }
 675   // Check for highly predictable branch.  No point in CMOV&#39;ing if
 676   // we are going to predict accurately all the time.
 677   if (C-&gt;use_cmove() &amp;&amp; (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) {
 678     //keep going
</pre>
</td>
<td>
<hr />
<pre>
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/divnode.hpp&quot;
  36 #include &quot;opto/loopnode.hpp&quot;
  37 #include &quot;opto/matcher.hpp&quot;
  38 #include &quot;opto/mulnode.hpp&quot;
  39 #include &quot;opto/movenode.hpp&quot;
  40 #include &quot;opto/opaquenode.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/subnode.hpp&quot;
<span class="line-added">  43 #include &quot;opto/subtypenode.hpp&quot;</span>
  44 #include &quot;utilities/macros.hpp&quot;
  45 
  46 //=============================================================================
  47 //------------------------------split_thru_phi---------------------------------
  48 // Split Node &#39;n&#39; through merge point if there is enough win.
  49 Node *PhaseIdealLoop::split_thru_phi( Node *n, Node *region, int policy ) {
  50   if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; n-&gt;bottom_type() != TypeLong::LONG) {
  51     // ConvI2L may have type information on it which is unsafe to push up
  52     // so disable this for now
  53     return NULL;
  54   }
  55 
  56   // Splitting range check CastIIs through a loop induction Phi can
  57   // cause new Phis to be created that are left unrelated to the loop
  58   // induction Phi and prevent optimizations (vectorization)
  59   if (n-&gt;Opcode() == Op_CastII &amp;&amp; n-&gt;as_CastII()-&gt;has_range_check() &amp;&amp;
  60       region-&gt;is_CountedLoop() &amp;&amp; n-&gt;in(1) == region-&gt;as_CountedLoop()-&gt;phi()) {
  61     return NULL;
  62   }
  63 
</pre>
<hr />
<pre>
 640     for (DUIterator_Fast kmax, k = phi-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 641       Node* use = phi-&gt;fast_out(k);
 642       if (use-&gt;is_Cmp() || use-&gt;is_DecodeNarrowPtr() || use-&gt;is_EncodeNarrowPtr())
 643         cost += ConditionalMoveLimit;
 644       // Is there a use inside the loop?
 645       // Note: check only basic types since CMoveP is pinned.
 646       if (!used_inside_loop &amp;&amp; is_java_primitive(bt)) {
 647         IdealLoopTree* u_loop = get_loop(has_ctrl(use) ? get_ctrl(use) : use);
 648         if (r_loop == u_loop || r_loop-&gt;is_member(u_loop)) {
 649           used_inside_loop = true;
 650         }
 651       }
 652     }
 653   }//for
 654   Node* bol = iff-&gt;in(1);
 655   if (bol-&gt;Opcode() == Op_Opaque4) {
 656     return NULL; // Ignore loop predicate checks (the Opaque4 ensures they will go away)
 657   }
 658   assert(bol-&gt;Opcode() == Op_Bool, &quot;Unexpected node&quot;);
 659   int cmp_op = bol-&gt;in(1)-&gt;Opcode();
<span class="line-added"> 660   if (cmp_op == Op_SubTypeCheck) { // SubTypeCheck expansion expects an IfNode</span>
<span class="line-added"> 661     return NULL;</span>
<span class="line-added"> 662   }</span>
 663   // It is expensive to generate flags from a float compare.
 664   // Avoid duplicated float compare.
 665   if (phis &gt; 1 &amp;&amp; (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) return NULL;
 666 
 667   float infrequent_prob = PROB_UNLIKELY_MAG(3);
 668   // Ignore cost and blocks frequency if CMOVE can be moved outside the loop.
 669   if (used_inside_loop) {
 670     if (cost &gt;= ConditionalMoveLimit) return NULL; // Too much goo
 671 
 672     // BlockLayoutByFrequency optimization moves infrequent branch
 673     // from hot path. No point in CMOV&#39;ing in such case (110 is used
 674     // instead of 100 to take into account not exactness of float value).
 675     if (BlockLayoutByFrequency) {
 676       infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage/110.0f);
 677     }
 678   }
 679   // Check for highly predictable branch.  No point in CMOV&#39;ing if
 680   // we are going to predict accurately all the time.
 681   if (C-&gt;use_cmove() &amp;&amp; (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) {
 682     //keep going
</pre>
</td>
</tr>
</table>
<center><a href="loopnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gcm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciUtilities.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;opto/addnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/convertnode.hpp&quot;
  35 #include &quot;opto/graphKit.hpp&quot;
  36 #include &quot;opto/idealKit.hpp&quot;
  37 #include &quot;opto/intrinsicnode.hpp&quot;
  38 #include &quot;opto/locknode.hpp&quot;
  39 #include &quot;opto/machnode.hpp&quot;
  40 #include &quot;opto/opaquenode.hpp&quot;
  41 #include &quot;opto/parse.hpp&quot;
  42 #include &quot;opto/rootnode.hpp&quot;
  43 #include &quot;opto/runtime.hpp&quot;

  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/sharedRuntime.hpp&quot;
  46 #include &quot;utilities/bitMap.inline.hpp&quot;

  47 
  48 //----------------------------GraphKit-----------------------------------------
  49 // Main utility constructor.
  50 GraphKit::GraphKit(JVMState* jvms)
  51   : Phase(Phase::Parser),
  52     _env(C-&gt;env()),
  53     _gvn(*C-&gt;initial_gvn()),
  54     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
  55 {
  56   _exceptions = jvms-&gt;map()-&gt;next_exception();
  57   if (_exceptions != NULL)  jvms-&gt;map()-&gt;set_next_exception(NULL);
  58   set_jvms(jvms);
  59 }
  60 
  61 // Private constructor for parser.
  62 GraphKit::GraphKit()
  63   : Phase(Phase::Parser),
  64     _env(C-&gt;env()),
  65     _gvn(*C-&gt;initial_gvn()),
  66     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
</pre>
<hr />
<pre>
2605 
2606     if (excp != top()) {
2607       if (deoptimize) {
2608         // Deoptimize if an exception is caught. Don&#39;t construct exception state in this case.
2609         uncommon_trap(Deoptimization::Reason_unhandled,
2610                       Deoptimization::Action_none);
2611       } else {
2612         // Create an exception state also.
2613         // Use an exact type if the caller has a specific exception.
2614         const Type* ex_type = TypeOopPtr::make_from_klass_unique(ex_klass)-&gt;cast_to_ptr_type(TypePtr::NotNull);
2615         Node*       ex_oop  = new CreateExNode(ex_type, control(), i_o);
2616         add_exception_state(make_exception_state(_gvn.transform(ex_oop)));
2617       }
2618     }
2619   }
2620 
2621   // Get the no-exception control from the CatchNode.
2622   set_control(norm);
2623 }
2624 
<span class="line-modified">2625 static IfNode* gen_subtype_check_compare(Node* ctrl, Node* in1, Node* in2, BoolTest::mask test, float p, PhaseGVN* gvn, BasicType bt) {</span>
2626   Node* cmp = NULL;
2627   switch(bt) {
2628   case T_INT: cmp = new CmpINode(in1, in2); break;
2629   case T_ADDRESS: cmp = new CmpPNode(in1, in2); break;
2630   default: fatal(&quot;unexpected comparison type %s&quot;, type2name(bt));
2631   }
<span class="line-modified">2632   gvn-&gt;transform(cmp);</span>
<span class="line-modified">2633   Node* bol = gvn-&gt;transform(new BoolNode(cmp, test));</span>
2634   IfNode* iff = new IfNode(ctrl, bol, p, COUNT_UNKNOWN);
<span class="line-modified">2635   gvn-&gt;transform(iff);</span>
<span class="line-modified">2636   if (!bol-&gt;is_Con()) gvn-&gt;record_for_igvn(iff);</span>
2637   return iff;
2638 }
2639 









































































2640 
2641 //-------------------------------gen_subtype_check-----------------------------
2642 // Generate a subtyping check.  Takes as input the subtype and supertype.
2643 // Returns 2 values: sets the default control() to the true path and returns
2644 // the false path.  Only reads invariant memory; sets no (visible) memory.
2645 // The PartialSubtypeCheckNode sets the hidden 1-word cache in the encoding
2646 // but that&#39;s not exposed to the optimizer.  This call also doesn&#39;t take in an
2647 // Object; if you wish to check an Object you need to load the Object&#39;s class
2648 // prior to coming here.
<span class="line-modified">2649 Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, MergeMemNode* mem, PhaseGVN* gvn) {</span>
<span class="line-modified">2650   Compile* C = gvn-&gt;C;</span>
<span class="line-removed">2651 </span>
2652   if ((*ctrl)-&gt;is_top()) {
2653     return C-&gt;top();
2654   }
2655 
2656   // Fast check for identical types, perhaps identical constants.
2657   // The types can even be identical non-constants, in cases
2658   // involving Array.newInstance, Object.clone, etc.
2659   if (subklass == superklass)
2660     return C-&gt;top();             // false path is dead; no test needed.
2661 
<span class="line-modified">2662   if (gvn-&gt;type(superklass)-&gt;singleton()) {</span>
<span class="line-modified">2663     ciKlass* superk = gvn-&gt;type(superklass)-&gt;is_klassptr()-&gt;klass();</span>
<span class="line-modified">2664     ciKlass* subk   = gvn-&gt;type(subklass)-&gt;is_klassptr()-&gt;klass();</span>
2665 
2666     // In the common case of an exact superklass, try to fold up the
2667     // test before generating code.  You may ask, why not just generate
2668     // the code and then let it fold up?  The answer is that the generated
2669     // code will necessarily include null checks, which do not always
2670     // completely fold away.  If they are also needless, then they turn
2671     // into a performance loss.  Example:
2672     //    Foo[] fa = blah(); Foo x = fa[0]; fa[1] = x;
2673     // Here, the type of &#39;fa&#39; is often exact, so the store check
2674     // of fa[1]=x will fold up, without testing the nullness of x.
2675     switch (C-&gt;static_subtype_check(superk, subk)) {
2676     case Compile::SSC_always_false:
2677       {
2678         Node* always_fail = *ctrl;
<span class="line-modified">2679         *ctrl = gvn-&gt;C-&gt;top();</span>
2680         return always_fail;
2681       }
2682     case Compile::SSC_always_true:
2683       return C-&gt;top();
2684     case Compile::SSC_easy_test:
2685       {
2686         // Just do a direct pointer compare and be done.
2687         IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_STATIC_FREQUENT, gvn, T_ADDRESS);
<span class="line-modified">2688         *ctrl = gvn-&gt;transform(new IfTrueNode(iff));</span>
<span class="line-modified">2689         return gvn-&gt;transform(new IfFalseNode(iff));</span>
2690       }
2691     case Compile::SSC_full_test:
2692       break;
2693     default:
2694       ShouldNotReachHere();
2695     }
2696   }
2697 
2698   // %%% Possible further optimization:  Even if the superklass is not exact,
2699   // if the subklass is the unique subtype of the superklass, the check
2700   // will always succeed.  We could leave a dependency behind to ensure this.
2701 
2702   // First load the super-klass&#39;s check-offset
<span class="line-modified">2703   Node *p1 = gvn-&gt;transform(new AddPNode(superklass, superklass, gvn-&gt;MakeConX(in_bytes(Klass::super_check_offset_offset()))));</span>
<span class="line-modified">2704   Node* m = mem-&gt;memory_at(C-&gt;get_alias_index(gvn-&gt;type(p1)-&gt;is_ptr()));</span>
<span class="line-modified">2705   Node *chk_off = gvn-&gt;transform(new LoadINode(NULL, m, p1, gvn-&gt;type(p1)-&gt;is_ptr(), TypeInt::INT, MemNode::unordered));</span>
2706   int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());
<span class="line-modified">2707   bool might_be_cache = (gvn-&gt;find_int_con(chk_off, cacheoff_con) == cacheoff_con);</span>
2708 
2709   // Load from the sub-klass&#39;s super-class display list, or a 1-word cache of
2710   // the secondary superclass list, or a failing value with a sentinel offset
2711   // if the super-klass is an interface or exceptionally deep in the Java
2712   // hierarchy and we have to scan the secondary superclass list the hard way.
2713   // Worst-case type is a little odd: NULL is allowed as a result (usually
2714   // klass loads can never produce a NULL).
2715   Node *chk_off_X = chk_off;
2716 #ifdef _LP64
<span class="line-modified">2717   chk_off_X = gvn-&gt;transform(new ConvI2LNode(chk_off_X));</span>
2718 #endif
<span class="line-modified">2719   Node *p2 = gvn-&gt;transform(new AddPNode(subklass,subklass,chk_off_X));</span>
2720   // For some types like interfaces the following loadKlass is from a 1-word
2721   // cache which is mutable so can&#39;t use immutable memory.  Other
2722   // types load from the super-class display table which is immutable.
<span class="line-modified">2723   m = mem-&gt;memory_at(C-&gt;get_alias_index(gvn-&gt;type(p2)-&gt;is_ptr()));</span>
<span class="line-modified">2724   Node *kmem = might_be_cache ? m : C-&gt;immutable_memory();</span>
<span class="line-modified">2725   Node *nkls = gvn-&gt;transform(LoadKlassNode::make(*gvn, NULL, kmem, p2, gvn-&gt;type(p2)-&gt;is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));</span>







2726 
2727   // Compile speed common case: ARE a subtype and we canNOT fail
2728   if( superklass == nkls )
2729     return C-&gt;top();             // false path is dead; no test needed.
2730 
2731   // See if we get an immediate positive hit.  Happens roughly 83% of the
2732   // time.  Test to see if the value loaded just previously from the subklass
2733   // is exactly the superklass.
2734   IfNode *iff1 = gen_subtype_check_compare(*ctrl, superklass, nkls, BoolTest::eq, PROB_LIKELY(0.83f), gvn, T_ADDRESS);
<span class="line-modified">2735   Node *iftrue1 = gvn-&gt;transform( new IfTrueNode (iff1));</span>
<span class="line-modified">2736   *ctrl = gvn-&gt;transform(new IfFalseNode(iff1));</span>
2737 
2738   // Compile speed common case: Check for being deterministic right now.  If
2739   // chk_off is a constant and not equal to cacheoff then we are NOT a
2740   // subklass.  In this case we need exactly the 1 test above and we can
2741   // return those results immediately.
2742   if (!might_be_cache) {
2743     Node* not_subtype_ctrl = *ctrl;
2744     *ctrl = iftrue1; // We need exactly the 1 test above
2745     return not_subtype_ctrl;
2746   }
2747 
2748   // Gather the various success &amp; failures here
2749   RegionNode *r_ok_subtype = new RegionNode(4);
<span class="line-modified">2750   gvn-&gt;record_for_igvn(r_ok_subtype);</span>
2751   RegionNode *r_not_subtype = new RegionNode(3);
<span class="line-modified">2752   gvn-&gt;record_for_igvn(r_not_subtype);</span>
2753 
2754   r_ok_subtype-&gt;init_req(1, iftrue1);
2755 
2756   // Check for immediate negative hit.  Happens roughly 11% of the time (which
2757   // is roughly 63% of the remaining cases).  Test to see if the loaded
2758   // check-offset points into the subklass display list or the 1-element
2759   // cache.  If it points to the display (and NOT the cache) and the display
2760   // missed then it&#39;s not a subtype.
<span class="line-modified">2761   Node *cacheoff = gvn-&gt;intcon(cacheoff_con);</span>
2762   IfNode *iff2 = gen_subtype_check_compare(*ctrl, chk_off, cacheoff, BoolTest::ne, PROB_LIKELY(0.63f), gvn, T_INT);
<span class="line-modified">2763   r_not_subtype-&gt;init_req(1, gvn-&gt;transform(new IfTrueNode (iff2)));</span>
<span class="line-modified">2764   *ctrl = gvn-&gt;transform(new IfFalseNode(iff2));</span>
2765 
2766   // Check for self.  Very rare to get here, but it is taken 1/3 the time.
2767   // No performance impact (too rare) but allows sharing of secondary arrays
2768   // which has some footprint reduction.
2769   IfNode *iff3 = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_LIKELY(0.36f), gvn, T_ADDRESS);
<span class="line-modified">2770   r_ok_subtype-&gt;init_req(2, gvn-&gt;transform(new IfTrueNode(iff3)));</span>
<span class="line-modified">2771   *ctrl = gvn-&gt;transform(new IfFalseNode(iff3));</span>
2772 
2773   // -- Roads not taken here: --
2774   // We could also have chosen to perform the self-check at the beginning
2775   // of this code sequence, as the assembler does.  This would not pay off
2776   // the same way, since the optimizer, unlike the assembler, can perform
2777   // static type analysis to fold away many successful self-checks.
2778   // Non-foldable self checks work better here in second position, because
2779   // the initial primary superclass check subsumes a self-check for most
2780   // types.  An exception would be a secondary type like array-of-interface,
2781   // which does not appear in its own primary supertype display.
2782   // Finally, we could have chosen to move the self-check into the
2783   // PartialSubtypeCheckNode, and from there out-of-line in a platform
2784   // dependent manner.  But it is worthwhile to have the check here,
2785   // where it can be perhaps be optimized.  The cost in code space is
2786   // small (register compare, branch).
2787 
2788   // Now do a linear scan of the secondary super-klass array.  Again, no real
2789   // performance impact (too rare) but it&#39;s gotta be done.
2790   // Since the code is rarely used, there is no penalty for moving it
2791   // out of line, and it can only improve I-cache density.
2792   // The decision to inline or out-of-line this final check is platform
2793   // dependent, and is found in the AD file definition of PartialSubtypeCheck.
<span class="line-modified">2794   Node* psc = gvn-&gt;transform(</span>
2795     new PartialSubtypeCheckNode(*ctrl, subklass, superklass));
2796 
<span class="line-modified">2797   IfNode *iff4 = gen_subtype_check_compare(*ctrl, psc, gvn-&gt;zerocon(T_OBJECT), BoolTest::ne, PROB_FAIR, gvn, T_ADDRESS);</span>
<span class="line-modified">2798   r_not_subtype-&gt;init_req(2, gvn-&gt;transform(new IfTrueNode (iff4)));</span>
<span class="line-modified">2799   r_ok_subtype -&gt;init_req(3, gvn-&gt;transform(new IfFalseNode(iff4)));</span>
2800 
2801   // Return false path; set default control to true path.
<span class="line-modified">2802   *ctrl = gvn-&gt;transform(r_ok_subtype);</span>
<span class="line-modified">2803   return gvn-&gt;transform(r_not_subtype);</span>






















2804 }
2805 
2806 // Profile-driven exact type check:
2807 Node* GraphKit::type_check_receiver(Node* receiver, ciKlass* klass,
2808                                     float prob,
2809                                     Node* *casted_receiver) {
2810   const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);
2811   Node* recv_klass = load_object_klass(receiver);
2812   Node* want_klass = makecon(tklass);
2813   Node* cmp = _gvn.transform( new CmpPNode(recv_klass, want_klass) );
2814   Node* bol = _gvn.transform( new BoolNode(cmp, BoolTest::eq) );
2815   IfNode* iff = create_and_xform_if(control(), bol, prob, COUNT_UNKNOWN);
2816   set_control( _gvn.transform( new IfTrueNode (iff) ));
2817   Node* fail = _gvn.transform( new IfFalseNode(iff) );
2818 
2819   const TypeOopPtr* recv_xtype = tklass-&gt;as_instance_type();
2820   assert(recv_xtype-&gt;klass_is_exact(), &quot;&quot;);
2821 
2822   // Subsume downstream occurrences of receiver with a cast to
2823   // recv_xtype, since now we know what the type will be.
2824   Node* cast = new CheckCastPPNode(control(), receiver, recv_xtype);
2825   (*casted_receiver) = _gvn.transform(cast);
2826   // (User must make the replace_in_map call.)
2827 
2828   return fail;
2829 }
2830 
2831 //------------------------------subtype_check_receiver-------------------------
2832 Node* GraphKit::subtype_check_receiver(Node* receiver, ciKlass* klass,
2833                                        Node** casted_receiver) {
2834   const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);
<span class="line-removed">2835   Node* recv_klass = load_object_klass(receiver);</span>
2836   Node* want_klass = makecon(tklass);
2837 
<span class="line-modified">2838   Node* slow_ctl = gen_subtype_check(recv_klass, want_klass);</span>
2839 
2840   // Cast receiver after successful check
2841   const TypeOopPtr* recv_type = tklass-&gt;cast_to_exactness(false)-&gt;is_klassptr()-&gt;as_instance_type();
2842   Node* cast = new CheckCastPPNode(control(), receiver, recv_type);
2843   (*casted_receiver) = _gvn.transform(cast);
2844 
2845   return slow_ctl;
2846 }
2847 
2848 //------------------------------seems_never_null-------------------------------
2849 // Use null_seen information if it is available from the profile.
2850 // If we see an unexpected null at a type check we record it and force a
2851 // recompile; the offending check will be recompiled to handle NULLs.
2852 // If we see several offending BCIs, then all checks in the
2853 // method will be recompiled.
2854 bool GraphKit::seems_never_null(Node* obj, ciProfileData* data, bool&amp; speculating) {
2855   speculating = !_gvn.type(obj)-&gt;speculative_maybe_null();
2856   Deoptimization::DeoptReason reason = Deoptimization::reason_null_check(speculating);
2857   if (UncommonNullCast               // Cutout for this technique
2858       &amp;&amp; obj != null()               // And not the -Xcomp stupid case?
</pre>
<hr />
<pre>
3083     }
3084   }
3085 
3086   if (!known_statically) {
3087     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
3088     // We may not have profiling here or it may not help us. If we
3089     // have a speculative type use it to perform an exact cast.
3090     ciKlass* spec_obj_type = obj_type-&gt;speculative_type();
3091     if (spec_obj_type != NULL || (ProfileDynamicTypes &amp;&amp; data != NULL)) {
3092       Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, NULL, spec_obj_type, safe_for_replace);
3093       if (stopped()) {            // Profile disagrees with this path.
3094         set_control(null_ctl);    // Null is the only remaining possibility.
3095         return intcon(0);
3096       }
3097       if (cast_obj != NULL) {
3098         not_null_obj = cast_obj;
3099       }
3100     }
3101   }
3102 
<span class="line-removed">3103   // Load the object&#39;s klass</span>
<span class="line-removed">3104   Node* obj_klass = load_object_klass(not_null_obj);</span>
<span class="line-removed">3105 </span>
3106   // Generate the subtype check
<span class="line-modified">3107   Node* not_subtype_ctrl = gen_subtype_check(obj_klass, superklass);</span>
3108 
3109   // Plug in the success path to the general merge in slot 1.
3110   region-&gt;init_req(_obj_path, control());
3111   phi   -&gt;init_req(_obj_path, intcon(1));
3112 
3113   // Plug in the failing path to the general merge in slot 2.
3114   region-&gt;init_req(_fail_path, not_subtype_ctrl);
3115   phi   -&gt;init_req(_fail_path, intcon(0));
3116 
3117   // Return final merged results
3118   set_control( _gvn.transform(region) );
3119   record_for_igvn(region);
3120 
3121   // If we know the type check always succeeds then we don&#39;t use the
3122   // profiling data at this bytecode. Don&#39;t lose it, feed it to the
3123   // type system as a speculative type.
3124   if (safe_for_replace) {
3125     Node* casted_obj = record_profiled_receiver_for_speculation(obj);
3126     replace_in_map(obj, casted_obj);
3127   }
</pre>
<hr />
<pre>
3210     // The following optimization tries to statically cast the speculative type of the object
3211     // (for example obtained during profiling) to the type of the superklass and then do a
3212     // dynamic check that the type of the object is what we expect. To work correctly
3213     // for checkcast and aastore the type of superklass should be exact.
3214     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
3215     // We may not have profiling here or it may not help us. If we have
3216     // a speculative type use it to perform an exact cast.
3217     ciKlass* spec_obj_type = obj_type-&gt;speculative_type();
3218     if (spec_obj_type != NULL || data != NULL) {
3219       cast_obj = maybe_cast_profiled_receiver(not_null_obj, tk-&gt;klass(), spec_obj_type, safe_for_replace);
3220       if (cast_obj != NULL) {
3221         if (failure_control != NULL) // failure is now impossible
3222           (*failure_control) = top();
3223         // adjust the type of the phi to the exact klass:
3224         phi-&gt;raise_bottom_type(_gvn.type(cast_obj)-&gt;meet_speculative(TypePtr::NULL_PTR));
3225       }
3226     }
3227   }
3228 
3229   if (cast_obj == NULL) {
<span class="line-removed">3230     // Load the object&#39;s klass</span>
<span class="line-removed">3231     Node* obj_klass = load_object_klass(not_null_obj);</span>
<span class="line-removed">3232 </span>
3233     // Generate the subtype check
<span class="line-modified">3234     Node* not_subtype_ctrl = gen_subtype_check( obj_klass, superklass );</span>
3235 
3236     // Plug in success path into the merge
3237     cast_obj = _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));
3238     // Failure path ends in uncommon trap (or may be dead - failure impossible)
3239     if (failure_control == NULL) {
3240       if (not_subtype_ctrl != top()) { // If failure is possible
3241         PreserveJVMState pjvms(this);
3242         set_control(not_subtype_ctrl);
<span class="line-modified">3243         builtin_throw(Deoptimization::Reason_class_check, obj_klass);</span>
3244       }
3245     } else {
3246       (*failure_control) = not_subtype_ctrl;
3247     }
3248   }
3249 
3250   region-&gt;init_req(_obj_path, control());
3251   phi   -&gt;init_req(_obj_path, cast_obj);
3252 
3253   // A merge of NULL or Casted-NotNull obj
3254   Node* res = _gvn.transform(phi);
3255 
3256   // Note I do NOT always &#39;replace_in_map(obj,result)&#39; here.
3257   //  if( tk-&gt;klass()-&gt;can_be_primary_super()  )
3258     // This means that if I successfully store an Object into an array-of-String
3259     // I &#39;forget&#39; that the Object is really now known to be a String.  I have to
3260     // do this because we don&#39;t have true union types for interfaces - if I store
3261     // a Baz into an array-of-Interface and then tell the optimizer it&#39;s an
3262     // Interface, I forget that it&#39;s also a Baz and cannot do Baz-like field
3263     // references to it.  FIX THIS WHEN UNION TYPES APPEAR!
</pre>
</td>
<td>
<hr />
<pre>
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciUtilities.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;opto/addnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/convertnode.hpp&quot;
  35 #include &quot;opto/graphKit.hpp&quot;
  36 #include &quot;opto/idealKit.hpp&quot;
  37 #include &quot;opto/intrinsicnode.hpp&quot;
  38 #include &quot;opto/locknode.hpp&quot;
  39 #include &quot;opto/machnode.hpp&quot;
  40 #include &quot;opto/opaquenode.hpp&quot;
  41 #include &quot;opto/parse.hpp&quot;
  42 #include &quot;opto/rootnode.hpp&quot;
  43 #include &quot;opto/runtime.hpp&quot;
<span class="line-added">  44 #include &quot;opto/subtypenode.hpp&quot;</span>
  45 #include &quot;runtime/deoptimization.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;utilities/bitMap.inline.hpp&quot;
<span class="line-added">  48 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  49 
  50 //----------------------------GraphKit-----------------------------------------
  51 // Main utility constructor.
  52 GraphKit::GraphKit(JVMState* jvms)
  53   : Phase(Phase::Parser),
  54     _env(C-&gt;env()),
  55     _gvn(*C-&gt;initial_gvn()),
  56     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
  57 {
  58   _exceptions = jvms-&gt;map()-&gt;next_exception();
  59   if (_exceptions != NULL)  jvms-&gt;map()-&gt;set_next_exception(NULL);
  60   set_jvms(jvms);
  61 }
  62 
  63 // Private constructor for parser.
  64 GraphKit::GraphKit()
  65   : Phase(Phase::Parser),
  66     _env(C-&gt;env()),
  67     _gvn(*C-&gt;initial_gvn()),
  68     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
</pre>
<hr />
<pre>
2607 
2608     if (excp != top()) {
2609       if (deoptimize) {
2610         // Deoptimize if an exception is caught. Don&#39;t construct exception state in this case.
2611         uncommon_trap(Deoptimization::Reason_unhandled,
2612                       Deoptimization::Action_none);
2613       } else {
2614         // Create an exception state also.
2615         // Use an exact type if the caller has a specific exception.
2616         const Type* ex_type = TypeOopPtr::make_from_klass_unique(ex_klass)-&gt;cast_to_ptr_type(TypePtr::NotNull);
2617         Node*       ex_oop  = new CreateExNode(ex_type, control(), i_o);
2618         add_exception_state(make_exception_state(_gvn.transform(ex_oop)));
2619       }
2620     }
2621   }
2622 
2623   // Get the no-exception control from the CatchNode.
2624   set_control(norm);
2625 }
2626 
<span class="line-modified">2627 static IfNode* gen_subtype_check_compare(Node* ctrl, Node* in1, Node* in2, BoolTest::mask test, float p, PhaseGVN&amp; gvn, BasicType bt) {</span>
2628   Node* cmp = NULL;
2629   switch(bt) {
2630   case T_INT: cmp = new CmpINode(in1, in2); break;
2631   case T_ADDRESS: cmp = new CmpPNode(in1, in2); break;
2632   default: fatal(&quot;unexpected comparison type %s&quot;, type2name(bt));
2633   }
<span class="line-modified">2634   gvn.transform(cmp);</span>
<span class="line-modified">2635   Node* bol = gvn.transform(new BoolNode(cmp, test));</span>
2636   IfNode* iff = new IfNode(ctrl, bol, p, COUNT_UNKNOWN);
<span class="line-modified">2637   gvn.transform(iff);</span>
<span class="line-modified">2638   if (!bol-&gt;is_Con()) gvn.record_for_igvn(iff);</span>
2639   return iff;
2640 }
2641 
<span class="line-added">2642 // Find the memory state for the secondary super type cache load when</span>
<span class="line-added">2643 // a subtype check is expanded at macro expansion time. That field is</span>
<span class="line-added">2644 // mutable so should not use immutable memory but</span>
<span class="line-added">2645 // PartialSubtypeCheckNode that might modify it doesn&#39;t produce a new</span>
<span class="line-added">2646 // memory state so bottom memory is the most accurate memory state to</span>
<span class="line-added">2647 // hook the load with. This follows the implementation used when the</span>
<span class="line-added">2648 // subtype check is expanded at parse time.</span>
<span class="line-added">2649 static Node* find_bottom_mem(Node* ctrl, Compile* C) {</span>
<span class="line-added">2650   const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::OffsetBot);</span>
<span class="line-added">2651   Node_Stack stack(0);</span>
<span class="line-added">2652   VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="line-added">2653 </span>
<span class="line-added">2654   Node* c = ctrl;</span>
<span class="line-added">2655   Node* mem = NULL;</span>
<span class="line-added">2656   uint iter = 0;</span>
<span class="line-added">2657   do {</span>
<span class="line-added">2658     iter++;</span>
<span class="line-added">2659     assert(iter &lt; C-&gt;live_nodes(), &quot;infinite loop&quot;);</span>
<span class="line-added">2660     if (c-&gt;is_Region()) {</span>
<span class="line-added">2661       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {</span>
<span class="line-added">2662         Node* u = c-&gt;fast_out(i);</span>
<span class="line-added">2663         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-added">2664             (u-&gt;adr_type() == TypePtr::BOTTOM || u-&gt;adr_type() == adr_type)) {</span>
<span class="line-added">2665           mem = u;</span>
<span class="line-added">2666         }</span>
<span class="line-added">2667       }</span>
<span class="line-added">2668       if (mem == NULL) {</span>
<span class="line-added">2669         if (!seen.test_set(c-&gt;_idx)) {</span>
<span class="line-added">2670           stack.push(c, 2);</span>
<span class="line-added">2671           c = c-&gt;in(1);</span>
<span class="line-added">2672         } else {</span>
<span class="line-added">2673           Node* phi = NULL;</span>
<span class="line-added">2674           uint idx = 0;</span>
<span class="line-added">2675           for (;;) {</span>
<span class="line-added">2676             phi = stack.node();</span>
<span class="line-added">2677             idx = stack.index();</span>
<span class="line-added">2678             if (idx &lt; phi-&gt;req()) {</span>
<span class="line-added">2679               break;</span>
<span class="line-added">2680             }</span>
<span class="line-added">2681             stack.pop();</span>
<span class="line-added">2682           }</span>
<span class="line-added">2683           c = phi-&gt;in(idx);</span>
<span class="line-added">2684           stack.set_index(idx+1);</span>
<span class="line-added">2685         }</span>
<span class="line-added">2686       }</span>
<span class="line-added">2687     } else if (c-&gt;is_Proj() &amp;&amp; c-&gt;in(0)-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-added">2688       for (DUIterator_Fast imax, i = c-&gt;in(0)-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">2689         Node* u = c-&gt;in(0)-&gt;fast_out(i);</span>
<span class="line-added">2690         if (u-&gt;bottom_type() == Type::MEMORY &amp;&amp; u-&gt;as_Proj()-&gt;_is_io_use == c-&gt;as_Proj()-&gt;_is_io_use) {</span>
<span class="line-added">2691           assert(mem == NULL, &quot;&quot;);</span>
<span class="line-added">2692           mem = u;</span>
<span class="line-added">2693         }</span>
<span class="line-added">2694       }</span>
<span class="line-added">2695     } else if (c-&gt;is_CatchProj() &amp;&amp; c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-added">2696       Node* call = c-&gt;in(0)-&gt;in(0)-&gt;in(0);</span>
<span class="line-added">2697       assert(call-&gt;is_Call(), &quot;CatchProj with no call?&quot;);</span>
<span class="line-added">2698       CallProjections projs;</span>
<span class="line-added">2699       call-&gt;as_Call()-&gt;extract_projections(&amp;projs, false, false);</span>
<span class="line-added">2700       if (projs.catchall_memproj == NULL) {</span>
<span class="line-added">2701         mem = projs.fallthrough_memproj;</span>
<span class="line-added">2702       } else if (c == projs.fallthrough_catchproj) {</span>
<span class="line-added">2703         mem = projs.fallthrough_memproj;</span>
<span class="line-added">2704       } else {</span>
<span class="line-added">2705         assert(c == projs.catchall_catchproj, &quot;strange control&quot;);</span>
<span class="line-added">2706         mem = projs.catchall_memproj;</span>
<span class="line-added">2707       }</span>
<span class="line-added">2708     } else {</span>
<span class="line-added">2709       assert(!c-&gt;is_Start(), &quot;should stop before start&quot;);</span>
<span class="line-added">2710       c = c-&gt;in(0);</span>
<span class="line-added">2711     }</span>
<span class="line-added">2712   } while (mem == NULL);</span>
<span class="line-added">2713   return mem;</span>
<span class="line-added">2714 }</span>
2715 
2716 //-------------------------------gen_subtype_check-----------------------------
2717 // Generate a subtyping check.  Takes as input the subtype and supertype.
2718 // Returns 2 values: sets the default control() to the true path and returns
2719 // the false path.  Only reads invariant memory; sets no (visible) memory.
2720 // The PartialSubtypeCheckNode sets the hidden 1-word cache in the encoding
2721 // but that&#39;s not exposed to the optimizer.  This call also doesn&#39;t take in an
2722 // Object; if you wish to check an Object you need to load the Object&#39;s class
2723 // prior to coming here.
<span class="line-modified">2724 Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN&amp; gvn) {</span>
<span class="line-modified">2725   Compile* C = gvn.C;</span>

2726   if ((*ctrl)-&gt;is_top()) {
2727     return C-&gt;top();
2728   }
2729 
2730   // Fast check for identical types, perhaps identical constants.
2731   // The types can even be identical non-constants, in cases
2732   // involving Array.newInstance, Object.clone, etc.
2733   if (subklass == superklass)
2734     return C-&gt;top();             // false path is dead; no test needed.
2735 
<span class="line-modified">2736   if (gvn.type(superklass)-&gt;singleton()) {</span>
<span class="line-modified">2737     ciKlass* superk = gvn.type(superklass)-&gt;is_klassptr()-&gt;klass();</span>
<span class="line-modified">2738     ciKlass* subk   = gvn.type(subklass)-&gt;is_klassptr()-&gt;klass();</span>
2739 
2740     // In the common case of an exact superklass, try to fold up the
2741     // test before generating code.  You may ask, why not just generate
2742     // the code and then let it fold up?  The answer is that the generated
2743     // code will necessarily include null checks, which do not always
2744     // completely fold away.  If they are also needless, then they turn
2745     // into a performance loss.  Example:
2746     //    Foo[] fa = blah(); Foo x = fa[0]; fa[1] = x;
2747     // Here, the type of &#39;fa&#39; is often exact, so the store check
2748     // of fa[1]=x will fold up, without testing the nullness of x.
2749     switch (C-&gt;static_subtype_check(superk, subk)) {
2750     case Compile::SSC_always_false:
2751       {
2752         Node* always_fail = *ctrl;
<span class="line-modified">2753         *ctrl = gvn.C-&gt;top();</span>
2754         return always_fail;
2755       }
2756     case Compile::SSC_always_true:
2757       return C-&gt;top();
2758     case Compile::SSC_easy_test:
2759       {
2760         // Just do a direct pointer compare and be done.
2761         IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_STATIC_FREQUENT, gvn, T_ADDRESS);
<span class="line-modified">2762         *ctrl = gvn.transform(new IfTrueNode(iff));</span>
<span class="line-modified">2763         return gvn.transform(new IfFalseNode(iff));</span>
2764       }
2765     case Compile::SSC_full_test:
2766       break;
2767     default:
2768       ShouldNotReachHere();
2769     }
2770   }
2771 
2772   // %%% Possible further optimization:  Even if the superklass is not exact,
2773   // if the subklass is the unique subtype of the superklass, the check
2774   // will always succeed.  We could leave a dependency behind to ensure this.
2775 
2776   // First load the super-klass&#39;s check-offset
<span class="line-modified">2777   Node *p1 = gvn.transform(new AddPNode(superklass, superklass, gvn.MakeConX(in_bytes(Klass::super_check_offset_offset()))));</span>
<span class="line-modified">2778   Node* m = C-&gt;immutable_memory();</span>
<span class="line-modified">2779   Node *chk_off = gvn.transform(new LoadINode(NULL, m, p1, gvn.type(p1)-&gt;is_ptr(), TypeInt::INT, MemNode::unordered));</span>
2780   int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());
<span class="line-modified">2781   bool might_be_cache = (gvn.find_int_con(chk_off, cacheoff_con) == cacheoff_con);</span>
2782 
2783   // Load from the sub-klass&#39;s super-class display list, or a 1-word cache of
2784   // the secondary superclass list, or a failing value with a sentinel offset
2785   // if the super-klass is an interface or exceptionally deep in the Java
2786   // hierarchy and we have to scan the secondary superclass list the hard way.
2787   // Worst-case type is a little odd: NULL is allowed as a result (usually
2788   // klass loads can never produce a NULL).
2789   Node *chk_off_X = chk_off;
2790 #ifdef _LP64
<span class="line-modified">2791   chk_off_X = gvn.transform(new ConvI2LNode(chk_off_X));</span>
2792 #endif
<span class="line-modified">2793   Node *p2 = gvn.transform(new AddPNode(subklass,subklass,chk_off_X));</span>
2794   // For some types like interfaces the following loadKlass is from a 1-word
2795   // cache which is mutable so can&#39;t use immutable memory.  Other
2796   // types load from the super-class display table which is immutable.
<span class="line-modified">2797   Node *kmem = C-&gt;immutable_memory();</span>
<span class="line-modified">2798   if (might_be_cache) {</span>
<span class="line-modified">2799     assert((C-&gt;get_alias_index(TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::OffsetBot)) ==</span>
<span class="line-added">2800             C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())), &quot;&quot;);</span>
<span class="line-added">2801     if (mem == NULL) {</span>
<span class="line-added">2802       mem = find_bottom_mem(*ctrl, C);</span>
<span class="line-added">2803     }</span>
<span class="line-added">2804     kmem = mem-&gt;is_MergeMem() ? mem-&gt;as_MergeMem()-&gt;memory_at(C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())) : mem;</span>
<span class="line-added">2805   }</span>
<span class="line-added">2806   Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)-&gt;is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));</span>
2807 
2808   // Compile speed common case: ARE a subtype and we canNOT fail
2809   if( superklass == nkls )
2810     return C-&gt;top();             // false path is dead; no test needed.
2811 
2812   // See if we get an immediate positive hit.  Happens roughly 83% of the
2813   // time.  Test to see if the value loaded just previously from the subklass
2814   // is exactly the superklass.
2815   IfNode *iff1 = gen_subtype_check_compare(*ctrl, superklass, nkls, BoolTest::eq, PROB_LIKELY(0.83f), gvn, T_ADDRESS);
<span class="line-modified">2816   Node *iftrue1 = gvn.transform( new IfTrueNode (iff1));</span>
<span class="line-modified">2817   *ctrl = gvn.transform(new IfFalseNode(iff1));</span>
2818 
2819   // Compile speed common case: Check for being deterministic right now.  If
2820   // chk_off is a constant and not equal to cacheoff then we are NOT a
2821   // subklass.  In this case we need exactly the 1 test above and we can
2822   // return those results immediately.
2823   if (!might_be_cache) {
2824     Node* not_subtype_ctrl = *ctrl;
2825     *ctrl = iftrue1; // We need exactly the 1 test above
2826     return not_subtype_ctrl;
2827   }
2828 
2829   // Gather the various success &amp; failures here
2830   RegionNode *r_ok_subtype = new RegionNode(4);
<span class="line-modified">2831   gvn.record_for_igvn(r_ok_subtype);</span>
2832   RegionNode *r_not_subtype = new RegionNode(3);
<span class="line-modified">2833   gvn.record_for_igvn(r_not_subtype);</span>
2834 
2835   r_ok_subtype-&gt;init_req(1, iftrue1);
2836 
2837   // Check for immediate negative hit.  Happens roughly 11% of the time (which
2838   // is roughly 63% of the remaining cases).  Test to see if the loaded
2839   // check-offset points into the subklass display list or the 1-element
2840   // cache.  If it points to the display (and NOT the cache) and the display
2841   // missed then it&#39;s not a subtype.
<span class="line-modified">2842   Node *cacheoff = gvn.intcon(cacheoff_con);</span>
2843   IfNode *iff2 = gen_subtype_check_compare(*ctrl, chk_off, cacheoff, BoolTest::ne, PROB_LIKELY(0.63f), gvn, T_INT);
<span class="line-modified">2844   r_not_subtype-&gt;init_req(1, gvn.transform(new IfTrueNode (iff2)));</span>
<span class="line-modified">2845   *ctrl = gvn.transform(new IfFalseNode(iff2));</span>
2846 
2847   // Check for self.  Very rare to get here, but it is taken 1/3 the time.
2848   // No performance impact (too rare) but allows sharing of secondary arrays
2849   // which has some footprint reduction.
2850   IfNode *iff3 = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_LIKELY(0.36f), gvn, T_ADDRESS);
<span class="line-modified">2851   r_ok_subtype-&gt;init_req(2, gvn.transform(new IfTrueNode(iff3)));</span>
<span class="line-modified">2852   *ctrl = gvn.transform(new IfFalseNode(iff3));</span>
2853 
2854   // -- Roads not taken here: --
2855   // We could also have chosen to perform the self-check at the beginning
2856   // of this code sequence, as the assembler does.  This would not pay off
2857   // the same way, since the optimizer, unlike the assembler, can perform
2858   // static type analysis to fold away many successful self-checks.
2859   // Non-foldable self checks work better here in second position, because
2860   // the initial primary superclass check subsumes a self-check for most
2861   // types.  An exception would be a secondary type like array-of-interface,
2862   // which does not appear in its own primary supertype display.
2863   // Finally, we could have chosen to move the self-check into the
2864   // PartialSubtypeCheckNode, and from there out-of-line in a platform
2865   // dependent manner.  But it is worthwhile to have the check here,
2866   // where it can be perhaps be optimized.  The cost in code space is
2867   // small (register compare, branch).
2868 
2869   // Now do a linear scan of the secondary super-klass array.  Again, no real
2870   // performance impact (too rare) but it&#39;s gotta be done.
2871   // Since the code is rarely used, there is no penalty for moving it
2872   // out of line, and it can only improve I-cache density.
2873   // The decision to inline or out-of-line this final check is platform
2874   // dependent, and is found in the AD file definition of PartialSubtypeCheck.
<span class="line-modified">2875   Node* psc = gvn.transform(</span>
2876     new PartialSubtypeCheckNode(*ctrl, subklass, superklass));
2877 
<span class="line-modified">2878   IfNode *iff4 = gen_subtype_check_compare(*ctrl, psc, gvn.zerocon(T_OBJECT), BoolTest::ne, PROB_FAIR, gvn, T_ADDRESS);</span>
<span class="line-modified">2879   r_not_subtype-&gt;init_req(2, gvn.transform(new IfTrueNode (iff4)));</span>
<span class="line-modified">2880   r_ok_subtype -&gt;init_req(3, gvn.transform(new IfFalseNode(iff4)));</span>
2881 
2882   // Return false path; set default control to true path.
<span class="line-modified">2883   *ctrl = gvn.transform(r_ok_subtype);</span>
<span class="line-modified">2884   return gvn.transform(r_not_subtype);</span>
<span class="line-added">2885 }</span>
<span class="line-added">2886 </span>
<span class="line-added">2887 Node* GraphKit::gen_subtype_check(Node* obj_or_subklass, Node* superklass) {</span>
<span class="line-added">2888   if (ExpandSubTypeCheckAtParseTime) {</span>
<span class="line-added">2889     MergeMemNode* mem = merged_memory();</span>
<span class="line-added">2890     Node* ctrl = control();</span>
<span class="line-added">2891     Node* subklass = obj_or_subklass;</span>
<span class="line-added">2892     if (!_gvn.type(obj_or_subklass)-&gt;isa_klassptr()) {</span>
<span class="line-added">2893       subklass = load_object_klass(obj_or_subklass);</span>
<span class="line-added">2894     }</span>
<span class="line-added">2895 </span>
<span class="line-added">2896     Node* n = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, mem, _gvn);</span>
<span class="line-added">2897     set_control(ctrl);</span>
<span class="line-added">2898     return n;</span>
<span class="line-added">2899   }</span>
<span class="line-added">2900 </span>
<span class="line-added">2901   const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::OffsetBot);</span>
<span class="line-added">2902   Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass));</span>
<span class="line-added">2903   Node* bol = _gvn.transform(new BoolNode(check, BoolTest::eq));</span>
<span class="line-added">2904   IfNode* iff = create_and_xform_if(control(), bol, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);</span>
<span class="line-added">2905   set_control(_gvn.transform(new IfTrueNode(iff)));</span>
<span class="line-added">2906   return _gvn.transform(new IfFalseNode(iff));</span>
2907 }
2908 
2909 // Profile-driven exact type check:
2910 Node* GraphKit::type_check_receiver(Node* receiver, ciKlass* klass,
2911                                     float prob,
2912                                     Node* *casted_receiver) {
2913   const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);
2914   Node* recv_klass = load_object_klass(receiver);
2915   Node* want_klass = makecon(tklass);
2916   Node* cmp = _gvn.transform( new CmpPNode(recv_klass, want_klass) );
2917   Node* bol = _gvn.transform( new BoolNode(cmp, BoolTest::eq) );
2918   IfNode* iff = create_and_xform_if(control(), bol, prob, COUNT_UNKNOWN);
2919   set_control( _gvn.transform( new IfTrueNode (iff) ));
2920   Node* fail = _gvn.transform( new IfFalseNode(iff) );
2921 
2922   const TypeOopPtr* recv_xtype = tklass-&gt;as_instance_type();
2923   assert(recv_xtype-&gt;klass_is_exact(), &quot;&quot;);
2924 
2925   // Subsume downstream occurrences of receiver with a cast to
2926   // recv_xtype, since now we know what the type will be.
2927   Node* cast = new CheckCastPPNode(control(), receiver, recv_xtype);
2928   (*casted_receiver) = _gvn.transform(cast);
2929   // (User must make the replace_in_map call.)
2930 
2931   return fail;
2932 }
2933 
2934 //------------------------------subtype_check_receiver-------------------------
2935 Node* GraphKit::subtype_check_receiver(Node* receiver, ciKlass* klass,
2936                                        Node** casted_receiver) {
2937   const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);

2938   Node* want_klass = makecon(tklass);
2939 
<span class="line-modified">2940   Node* slow_ctl = gen_subtype_check(receiver, want_klass);</span>
2941 
2942   // Cast receiver after successful check
2943   const TypeOopPtr* recv_type = tklass-&gt;cast_to_exactness(false)-&gt;is_klassptr()-&gt;as_instance_type();
2944   Node* cast = new CheckCastPPNode(control(), receiver, recv_type);
2945   (*casted_receiver) = _gvn.transform(cast);
2946 
2947   return slow_ctl;
2948 }
2949 
2950 //------------------------------seems_never_null-------------------------------
2951 // Use null_seen information if it is available from the profile.
2952 // If we see an unexpected null at a type check we record it and force a
2953 // recompile; the offending check will be recompiled to handle NULLs.
2954 // If we see several offending BCIs, then all checks in the
2955 // method will be recompiled.
2956 bool GraphKit::seems_never_null(Node* obj, ciProfileData* data, bool&amp; speculating) {
2957   speculating = !_gvn.type(obj)-&gt;speculative_maybe_null();
2958   Deoptimization::DeoptReason reason = Deoptimization::reason_null_check(speculating);
2959   if (UncommonNullCast               // Cutout for this technique
2960       &amp;&amp; obj != null()               // And not the -Xcomp stupid case?
</pre>
<hr />
<pre>
3185     }
3186   }
3187 
3188   if (!known_statically) {
3189     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
3190     // We may not have profiling here or it may not help us. If we
3191     // have a speculative type use it to perform an exact cast.
3192     ciKlass* spec_obj_type = obj_type-&gt;speculative_type();
3193     if (spec_obj_type != NULL || (ProfileDynamicTypes &amp;&amp; data != NULL)) {
3194       Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, NULL, spec_obj_type, safe_for_replace);
3195       if (stopped()) {            // Profile disagrees with this path.
3196         set_control(null_ctl);    // Null is the only remaining possibility.
3197         return intcon(0);
3198       }
3199       if (cast_obj != NULL) {
3200         not_null_obj = cast_obj;
3201       }
3202     }
3203   }
3204 



3205   // Generate the subtype check
<span class="line-modified">3206   Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass);</span>
3207 
3208   // Plug in the success path to the general merge in slot 1.
3209   region-&gt;init_req(_obj_path, control());
3210   phi   -&gt;init_req(_obj_path, intcon(1));
3211 
3212   // Plug in the failing path to the general merge in slot 2.
3213   region-&gt;init_req(_fail_path, not_subtype_ctrl);
3214   phi   -&gt;init_req(_fail_path, intcon(0));
3215 
3216   // Return final merged results
3217   set_control( _gvn.transform(region) );
3218   record_for_igvn(region);
3219 
3220   // If we know the type check always succeeds then we don&#39;t use the
3221   // profiling data at this bytecode. Don&#39;t lose it, feed it to the
3222   // type system as a speculative type.
3223   if (safe_for_replace) {
3224     Node* casted_obj = record_profiled_receiver_for_speculation(obj);
3225     replace_in_map(obj, casted_obj);
3226   }
</pre>
<hr />
<pre>
3309     // The following optimization tries to statically cast the speculative type of the object
3310     // (for example obtained during profiling) to the type of the superklass and then do a
3311     // dynamic check that the type of the object is what we expect. To work correctly
3312     // for checkcast and aastore the type of superklass should be exact.
3313     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
3314     // We may not have profiling here or it may not help us. If we have
3315     // a speculative type use it to perform an exact cast.
3316     ciKlass* spec_obj_type = obj_type-&gt;speculative_type();
3317     if (spec_obj_type != NULL || data != NULL) {
3318       cast_obj = maybe_cast_profiled_receiver(not_null_obj, tk-&gt;klass(), spec_obj_type, safe_for_replace);
3319       if (cast_obj != NULL) {
3320         if (failure_control != NULL) // failure is now impossible
3321           (*failure_control) = top();
3322         // adjust the type of the phi to the exact klass:
3323         phi-&gt;raise_bottom_type(_gvn.type(cast_obj)-&gt;meet_speculative(TypePtr::NULL_PTR));
3324       }
3325     }
3326   }
3327 
3328   if (cast_obj == NULL) {



3329     // Generate the subtype check
<span class="line-modified">3330     Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass );</span>
3331 
3332     // Plug in success path into the merge
3333     cast_obj = _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));
3334     // Failure path ends in uncommon trap (or may be dead - failure impossible)
3335     if (failure_control == NULL) {
3336       if (not_subtype_ctrl != top()) { // If failure is possible
3337         PreserveJVMState pjvms(this);
3338         set_control(not_subtype_ctrl);
<span class="line-modified">3339         builtin_throw(Deoptimization::Reason_class_check, load_object_klass(not_null_obj));</span>
3340       }
3341     } else {
3342       (*failure_control) = not_subtype_ctrl;
3343     }
3344   }
3345 
3346   region-&gt;init_req(_obj_path, control());
3347   phi   -&gt;init_req(_obj_path, cast_obj);
3348 
3349   // A merge of NULL or Casted-NotNull obj
3350   Node* res = _gvn.transform(phi);
3351 
3352   // Note I do NOT always &#39;replace_in_map(obj,result)&#39; here.
3353   //  if( tk-&gt;klass()-&gt;can_be_primary_super()  )
3354     // This means that if I successfully store an Object into an array-of-String
3355     // I &#39;forget&#39; that the Object is really now known to be a String.  I have to
3356     // do this because we don&#39;t have true union types for interfaces - if I store
3357     // a Baz into an array-of-Interface and then tell the optimizer it&#39;s an
3358     // Interface, I forget that it&#39;s also a Baz and cannot do Baz-like field
3359     // references to it.  FIX THIS WHEN UNION TYPES APPEAR!
</pre>
</td>
</tr>
</table>
<center><a href="gcm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
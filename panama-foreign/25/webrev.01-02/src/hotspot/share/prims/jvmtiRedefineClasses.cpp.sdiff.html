<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/verifier.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;interpreter/oopMapCache.hpp&quot;
  37 #include &quot;interpreter/rewriter.hpp&quot;

  38 #include &quot;logging/logStream.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceShared.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;memory/universe.hpp&quot;
  43 #include &quot;oops/annotations.hpp&quot;
  44 #include &quot;oops/constantPool.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/klassVtable.hpp&quot;
  47 #include &quot;oops/oop.inline.hpp&quot;
  48 #include &quot;oops/recordComponent.hpp&quot;
  49 #include &quot;prims/jvmtiImpl.hpp&quot;
  50 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  51 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  52 #include &quot;prims/resolvedMethodTable.hpp&quot;
  53 #include &quot;prims/methodComparator.hpp&quot;

  54 #include &quot;runtime/deoptimization.hpp&quot;
  55 #include &quot;runtime/handles.inline.hpp&quot;
  56 #include &quot;runtime/jniHandles.inline.hpp&quot;
  57 #include &quot;runtime/relocator.hpp&quot;
  58 #include &quot;runtime/safepointVerifiers.hpp&quot;
  59 #include &quot;utilities/bitMap.inline.hpp&quot;
  60 #include &quot;utilities/events.hpp&quot;
  61 
  62 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  63 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  64 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  65 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  66 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  67 Method**  VM_RedefineClasses::_added_methods        = NULL;
  68 int       VM_RedefineClasses::_matching_methods_length = 0;
  69 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  70 int       VM_RedefineClasses::_added_methods_length    = 0;
  71 bool      VM_RedefineClasses::_has_redefined_Object = false;
  72 bool      VM_RedefineClasses::_has_null_class_loader = false;
<span class="line-modified">  73 </span>
  74 
  75 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  76                                        const jvmtiClassDefinition *class_defs,
  77                                        JvmtiClassLoadKind class_load_kind) {
  78   _class_count = class_count;
  79   _class_defs = class_defs;
  80   _class_load_kind = class_load_kind;
  81   _any_class_has_resolved_methods = false;
  82   _res = JVMTI_ERROR_NONE;
  83   _the_class = NULL;
  84   _has_redefined_Object = false;
  85   _has_null_class_loader = false;

  86 }
  87 
  88 static inline InstanceKlass* get_ik(jclass def) {
  89   oop mirror = JNIHandles::resolve_non_null(def);
  90   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  91 }
  92 
  93 // If any of the classes are being redefined, wait
  94 // Parallel constant pool merging leads to indeterminate constant pools.
  95 void VM_RedefineClasses::lock_classes() {
  96   MonitorLocker ml(RedefineClasses_lock);
  97   bool has_redefined;
  98   do {
  99     has_redefined = false;
 100     // Go through classes each time until none are being redefined.
 101     for (int i = 0; i &lt; _class_count; i++) {
 102       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
 103         ml.wait();
 104         has_redefined = true;
 105         break;  // for loop
</pre>
<hr />
<pre>
4277     // Class was already initialized, so AOT has only seen the original version.
4278     // We need to let AOT look at it again.
4279     AOTLoader::load_for_klass(the_class, THREAD);
4280   }
4281 
4282   // keep track of previous versions of this class
4283   the_class-&gt;add_previous_version(scratch_class, emcp_method_count);
4284 
4285   _timer_rsc_phase1.stop();
4286   if (log_is_enabled(Info, redefine, class, timer)) {
4287     _timer_rsc_phase2.start();
4288   }
4289 
4290   if (the_class-&gt;oop_map_cache() != NULL) {
4291     // Flush references to any obsolete methods from the oop map cache
4292     // so that obsolete methods are not pinned.
4293     the_class-&gt;oop_map_cache()-&gt;flush_obsolete_entries();
4294   }
4295 
4296   increment_class_counter((InstanceKlass *)the_class, THREAD);









4297   {
4298     ResourceMark rm(THREAD);
4299     // increment the classRedefinedCount field in the_class and in any
4300     // direct and indirect subclasses of the_class
4301     log_info(redefine, class, load)
4302       (&quot;redefined name=%s, count=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
4303        the_class-&gt;external_name(), java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()), os::available_memory() &gt;&gt; 10);
4304     Events::log_redefinition(THREAD, &quot;redefined class name=%s, count=%d&quot;,
4305                              the_class-&gt;external_name(),
4306                              java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4307 
4308   }
4309   _timer_rsc_phase2.stop();

4310 } // end redefine_single_class()
4311 
4312 
4313 // Increment the classRedefinedCount field in the specific InstanceKlass
4314 // and in all direct and indirect subclasses.
4315 void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik, TRAPS) {
4316   oop class_mirror = ik-&gt;java_mirror();
4317   Klass* class_oop = java_lang_Class::as_Klass(class_mirror);
4318   int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;
4319   java_lang_Class::set_classRedefinedCount(class_mirror, new_count);
4320 
4321   if (class_oop != _the_class) {
4322     // _the_class count is printed at end of redefine_single_class()
4323     log_debug(redefine, class, subclass)(&quot;updated count in subclass=%s to %d&quot;, ik-&gt;external_name(), new_count);
4324   }
4325 
4326   for (Klass *subk = ik-&gt;subklass(); subk != NULL;
4327        subk = subk-&gt;next_sibling()) {
4328     if (subk-&gt;is_instance_klass()) {
4329       // Only update instanceKlasses
</pre>
<hr />
<pre>
4376           (&quot;cp-cache::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4377            ik-&gt;signature_name());
4378         ik-&gt;constants()-&gt;cache()-&gt;dump_cache();
4379       }
4380       no_old_methods = false;
4381     }
4382   }
4383 
4384   // print and fail guarantee if old methods are found.
4385   if (!no_old_methods) {
4386     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4387       dump_methods();
4388     } else {
4389       log_trace(redefine, class)(&quot;Use the &#39;-Xlog:redefine+class*:&#39; option &quot;
4390         &quot;to see more info about the following guarantee() failure.&quot;);
4391     }
4392     guarantee(false, &quot;OLD and/or OBSOLETE method(s) found&quot;);
4393   }
4394 }
4395 










4396 
4397 void VM_RedefineClasses::dump_methods() {
4398   int j;
4399   log_trace(redefine, class, dump)(&quot;_old_methods --&quot;);
4400   for (j = 0; j &lt; _old_methods-&gt;length(); ++j) {
4401     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4402     Method* m = _old_methods-&gt;at(j);
4403     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4404     m-&gt;access_flags().print_on(&amp;log_stream);
4405     log_stream.print(&quot; --  &quot;);
4406     m-&gt;print_name(&amp;log_stream);
4407     log_stream.cr();
4408   }
4409   log_trace(redefine, class, dump)(&quot;_new_methods --&quot;);
4410   for (j = 0; j &lt; _new_methods-&gt;length(); ++j) {
4411     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4412     Method* m = _new_methods-&gt;at(j);
4413     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4414     m-&gt;access_flags().print_on(&amp;log_stream);
4415     log_stream.print(&quot; --  &quot;);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/verifier.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;interpreter/oopMapCache.hpp&quot;
  37 #include &quot;interpreter/rewriter.hpp&quot;
<span class="line-added">  38 #include &quot;jfr/jfrEvents.hpp&quot;</span>
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/metadataFactory.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/annotations.hpp&quot;
  45 #include &quot;oops/constantPool.hpp&quot;
  46 #include &quot;oops/fieldStreams.inline.hpp&quot;
  47 #include &quot;oops/klassVtable.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;oops/recordComponent.hpp&quot;
  50 #include &quot;prims/jvmtiImpl.hpp&quot;
  51 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  52 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  53 #include &quot;prims/resolvedMethodTable.hpp&quot;
  54 #include &quot;prims/methodComparator.hpp&quot;
<span class="line-added">  55 #include &quot;runtime/atomic.hpp&quot;</span>
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/relocator.hpp&quot;
  60 #include &quot;runtime/safepointVerifiers.hpp&quot;
  61 #include &quot;utilities/bitMap.inline.hpp&quot;
  62 #include &quot;utilities/events.hpp&quot;
  63 
  64 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  65 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  66 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  67 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  68 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  69 Method**  VM_RedefineClasses::_added_methods        = NULL;
  70 int       VM_RedefineClasses::_matching_methods_length = 0;
  71 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  72 int       VM_RedefineClasses::_added_methods_length    = 0;
  73 bool      VM_RedefineClasses::_has_redefined_Object = false;
  74 bool      VM_RedefineClasses::_has_null_class_loader = false;
<span class="line-modified">  75 u8        VM_RedefineClasses::_id_counter = 0;</span>
  76 
  77 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  78                                        const jvmtiClassDefinition *class_defs,
  79                                        JvmtiClassLoadKind class_load_kind) {
  80   _class_count = class_count;
  81   _class_defs = class_defs;
  82   _class_load_kind = class_load_kind;
  83   _any_class_has_resolved_methods = false;
  84   _res = JVMTI_ERROR_NONE;
  85   _the_class = NULL;
  86   _has_redefined_Object = false;
  87   _has_null_class_loader = false;
<span class="line-added">  88   _id = next_id();</span>
  89 }
  90 
  91 static inline InstanceKlass* get_ik(jclass def) {
  92   oop mirror = JNIHandles::resolve_non_null(def);
  93   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  94 }
  95 
  96 // If any of the classes are being redefined, wait
  97 // Parallel constant pool merging leads to indeterminate constant pools.
  98 void VM_RedefineClasses::lock_classes() {
  99   MonitorLocker ml(RedefineClasses_lock);
 100   bool has_redefined;
 101   do {
 102     has_redefined = false;
 103     // Go through classes each time until none are being redefined.
 104     for (int i = 0; i &lt; _class_count; i++) {
 105       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
 106         ml.wait();
 107         has_redefined = true;
 108         break;  // for loop
</pre>
<hr />
<pre>
4280     // Class was already initialized, so AOT has only seen the original version.
4281     // We need to let AOT look at it again.
4282     AOTLoader::load_for_klass(the_class, THREAD);
4283   }
4284 
4285   // keep track of previous versions of this class
4286   the_class-&gt;add_previous_version(scratch_class, emcp_method_count);
4287 
4288   _timer_rsc_phase1.stop();
4289   if (log_is_enabled(Info, redefine, class, timer)) {
4290     _timer_rsc_phase2.start();
4291   }
4292 
4293   if (the_class-&gt;oop_map_cache() != NULL) {
4294     // Flush references to any obsolete methods from the oop map cache
4295     // so that obsolete methods are not pinned.
4296     the_class-&gt;oop_map_cache()-&gt;flush_obsolete_entries();
4297   }
4298 
4299   increment_class_counter((InstanceKlass *)the_class, THREAD);
<span class="line-added">4300 </span>
<span class="line-added">4301   if (EventClassRedefinition::is_enabled()) {</span>
<span class="line-added">4302     EventClassRedefinition event;</span>
<span class="line-added">4303     event.set_classModificationCount(java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));</span>
<span class="line-added">4304     event.set_redefinedClass(the_class);</span>
<span class="line-added">4305     event.set_redefinitionId(_id);</span>
<span class="line-added">4306     event.commit();</span>
<span class="line-added">4307   }</span>
<span class="line-added">4308 </span>
4309   {
4310     ResourceMark rm(THREAD);
4311     // increment the classRedefinedCount field in the_class and in any
4312     // direct and indirect subclasses of the_class
4313     log_info(redefine, class, load)
4314       (&quot;redefined name=%s, count=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
4315        the_class-&gt;external_name(), java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()), os::available_memory() &gt;&gt; 10);
4316     Events::log_redefinition(THREAD, &quot;redefined class name=%s, count=%d&quot;,
4317                              the_class-&gt;external_name(),
4318                              java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4319 
4320   }
4321   _timer_rsc_phase2.stop();
<span class="line-added">4322 </span>
4323 } // end redefine_single_class()
4324 
4325 
4326 // Increment the classRedefinedCount field in the specific InstanceKlass
4327 // and in all direct and indirect subclasses.
4328 void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik, TRAPS) {
4329   oop class_mirror = ik-&gt;java_mirror();
4330   Klass* class_oop = java_lang_Class::as_Klass(class_mirror);
4331   int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;
4332   java_lang_Class::set_classRedefinedCount(class_mirror, new_count);
4333 
4334   if (class_oop != _the_class) {
4335     // _the_class count is printed at end of redefine_single_class()
4336     log_debug(redefine, class, subclass)(&quot;updated count in subclass=%s to %d&quot;, ik-&gt;external_name(), new_count);
4337   }
4338 
4339   for (Klass *subk = ik-&gt;subklass(); subk != NULL;
4340        subk = subk-&gt;next_sibling()) {
4341     if (subk-&gt;is_instance_klass()) {
4342       // Only update instanceKlasses
</pre>
<hr />
<pre>
4389           (&quot;cp-cache::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4390            ik-&gt;signature_name());
4391         ik-&gt;constants()-&gt;cache()-&gt;dump_cache();
4392       }
4393       no_old_methods = false;
4394     }
4395   }
4396 
4397   // print and fail guarantee if old methods are found.
4398   if (!no_old_methods) {
4399     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4400       dump_methods();
4401     } else {
4402       log_trace(redefine, class)(&quot;Use the &#39;-Xlog:redefine+class*:&#39; option &quot;
4403         &quot;to see more info about the following guarantee() failure.&quot;);
4404     }
4405     guarantee(false, &quot;OLD and/or OBSOLETE method(s) found&quot;);
4406   }
4407 }
4408 
<span class="line-added">4409 u8 VM_RedefineClasses::next_id() {</span>
<span class="line-added">4410   while (true) {</span>
<span class="line-added">4411     u8 id = _id_counter;</span>
<span class="line-added">4412     u8 next_id = id + 1;</span>
<span class="line-added">4413     u8 result = Atomic::cmpxchg(&amp;_id_counter, id, next_id);</span>
<span class="line-added">4414     if (result == id) {</span>
<span class="line-added">4415       return next_id;</span>
<span class="line-added">4416     }</span>
<span class="line-added">4417   }</span>
<span class="line-added">4418 }</span>
4419 
4420 void VM_RedefineClasses::dump_methods() {
4421   int j;
4422   log_trace(redefine, class, dump)(&quot;_old_methods --&quot;);
4423   for (j = 0; j &lt; _old_methods-&gt;length(); ++j) {
4424     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4425     Method* m = _old_methods-&gt;at(j);
4426     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4427     m-&gt;access_flags().print_on(&amp;log_stream);
4428     log_stream.print(&quot; --  &quot;);
4429     m-&gt;print_name(&amp;log_stream);
4430     log_stream.cr();
4431   }
4432   log_trace(redefine, class, dump)(&quot;_new_methods --&quot;);
4433   for (j = 0; j &lt; _new_methods-&gt;length(); ++j) {
4434     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4435     Method* m = _new_methods-&gt;at(j);
4436     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4437     m-&gt;access_flags().print_on(&amp;log_stream);
4438     log_stream.print(&quot; --  &quot;);
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
--- a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -33,10 +33,11 @@
 #include "classfile/verifier.hpp"
 #include "code/codeCache.hpp"
 #include "compiler/compileBroker.hpp"
 #include "interpreter/oopMapCache.hpp"
 #include "interpreter/rewriter.hpp"
+#include "jfr/jfrEvents.hpp"
 #include "logging/logStream.hpp"
 #include "memory/metadataFactory.hpp"
 #include "memory/metaspaceShared.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
@@ -49,10 +50,11 @@
 #include "prims/jvmtiImpl.hpp"
 #include "prims/jvmtiRedefineClasses.hpp"
 #include "prims/jvmtiThreadState.inline.hpp"
 #include "prims/resolvedMethodTable.hpp"
 #include "prims/methodComparator.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/deoptimization.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/jniHandles.inline.hpp"
 #include "runtime/relocator.hpp"
 #include "runtime/safepointVerifiers.hpp"
@@ -68,11 +70,11 @@
 int       VM_RedefineClasses::_matching_methods_length = 0;
 int       VM_RedefineClasses::_deleted_methods_length  = 0;
 int       VM_RedefineClasses::_added_methods_length    = 0;
 bool      VM_RedefineClasses::_has_redefined_Object = false;
 bool      VM_RedefineClasses::_has_null_class_loader = false;
-
+u8        VM_RedefineClasses::_id_counter = 0;
 
 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
                                        const jvmtiClassDefinition *class_defs,
                                        JvmtiClassLoadKind class_load_kind) {
   _class_count = class_count;
@@ -81,10 +83,11 @@
   _any_class_has_resolved_methods = false;
   _res = JVMTI_ERROR_NONE;
   _the_class = NULL;
   _has_redefined_Object = false;
   _has_null_class_loader = false;
+  _id = next_id();
 }
 
 static inline InstanceKlass* get_ik(jclass def) {
   oop mirror = JNIHandles::resolve_non_null(def);
   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
@@ -4292,10 +4295,19 @@
     // so that obsolete methods are not pinned.
     the_class->oop_map_cache()->flush_obsolete_entries();
   }
 
   increment_class_counter((InstanceKlass *)the_class, THREAD);
+
+  if (EventClassRedefinition::is_enabled()) {
+    EventClassRedefinition event;
+    event.set_classModificationCount(java_lang_Class::classRedefinedCount(the_class->java_mirror()));
+    event.set_redefinedClass(the_class);
+    event.set_redefinitionId(_id);
+    event.commit();
+  }
+
   {
     ResourceMark rm(THREAD);
     // increment the classRedefinedCount field in the_class and in any
     // direct and indirect subclasses of the_class
     log_info(redefine, class, load)
@@ -4305,10 +4317,11 @@
                              the_class->external_name(),
                              java_lang_Class::classRedefinedCount(the_class->java_mirror()));
 
   }
   _timer_rsc_phase2.stop();
+
 } // end redefine_single_class()
 
 
 // Increment the classRedefinedCount field in the specific InstanceKlass
 // and in all direct and indirect subclasses.
@@ -4391,10 +4404,20 @@
     }
     guarantee(false, "OLD and/or OBSOLETE method(s) found");
   }
 }
 
+u8 VM_RedefineClasses::next_id() {
+  while (true) {
+    u8 id = _id_counter;
+    u8 next_id = id + 1;
+    u8 result = Atomic::cmpxchg(&_id_counter, id, next_id);
+    if (result == id) {
+      return next_id;
+    }
+  }
+}
 
 void VM_RedefineClasses::dump_methods() {
   int j;
   log_trace(redefine, class, dump)("_old_methods --");
   for (j = 0; j < _old_methods->length(); ++j) {

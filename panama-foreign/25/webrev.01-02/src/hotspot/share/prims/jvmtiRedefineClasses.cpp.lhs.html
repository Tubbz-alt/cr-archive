<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/verifier.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;interpreter/oopMapCache.hpp&quot;
  37 #include &quot;interpreter/rewriter.hpp&quot;
<a name="2" id="anc2"></a>
  38 #include &quot;logging/logStream.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceShared.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;memory/universe.hpp&quot;
  43 #include &quot;oops/annotations.hpp&quot;
  44 #include &quot;oops/constantPool.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/klassVtable.hpp&quot;
  47 #include &quot;oops/oop.inline.hpp&quot;
  48 #include &quot;oops/recordComponent.hpp&quot;
  49 #include &quot;prims/jvmtiImpl.hpp&quot;
  50 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  51 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  52 #include &quot;prims/resolvedMethodTable.hpp&quot;
  53 #include &quot;prims/methodComparator.hpp&quot;
<a name="3" id="anc3"></a>
  54 #include &quot;runtime/deoptimization.hpp&quot;
  55 #include &quot;runtime/handles.inline.hpp&quot;
  56 #include &quot;runtime/jniHandles.inline.hpp&quot;
  57 #include &quot;runtime/relocator.hpp&quot;
  58 #include &quot;runtime/safepointVerifiers.hpp&quot;
  59 #include &quot;utilities/bitMap.inline.hpp&quot;
  60 #include &quot;utilities/events.hpp&quot;
  61 
  62 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  63 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  64 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  65 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  66 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  67 Method**  VM_RedefineClasses::_added_methods        = NULL;
  68 int       VM_RedefineClasses::_matching_methods_length = 0;
  69 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  70 int       VM_RedefineClasses::_added_methods_length    = 0;
  71 bool      VM_RedefineClasses::_has_redefined_Object = false;
  72 bool      VM_RedefineClasses::_has_null_class_loader = false;
<a name="4" id="anc4"></a><span class="line-modified">  73 </span>
  74 
  75 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  76                                        const jvmtiClassDefinition *class_defs,
  77                                        JvmtiClassLoadKind class_load_kind) {
  78   _class_count = class_count;
  79   _class_defs = class_defs;
  80   _class_load_kind = class_load_kind;
  81   _any_class_has_resolved_methods = false;
  82   _res = JVMTI_ERROR_NONE;
  83   _the_class = NULL;
  84   _has_redefined_Object = false;
  85   _has_null_class_loader = false;
<a name="5" id="anc5"></a>
  86 }
  87 
  88 static inline InstanceKlass* get_ik(jclass def) {
  89   oop mirror = JNIHandles::resolve_non_null(def);
  90   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  91 }
  92 
  93 // If any of the classes are being redefined, wait
  94 // Parallel constant pool merging leads to indeterminate constant pools.
  95 void VM_RedefineClasses::lock_classes() {
  96   MonitorLocker ml(RedefineClasses_lock);
  97   bool has_redefined;
  98   do {
  99     has_redefined = false;
 100     // Go through classes each time until none are being redefined.
 101     for (int i = 0; i &lt; _class_count; i++) {
 102       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
 103         ml.wait();
 104         has_redefined = true;
 105         break;  // for loop
 106       }
 107     }
 108   } while (has_redefined);
 109   for (int i = 0; i &lt; _class_count; i++) {
 110     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(true);
 111   }
 112   ml.notify_all();
 113 }
 114 
 115 void VM_RedefineClasses::unlock_classes() {
 116   MonitorLocker ml(RedefineClasses_lock);
 117   for (int i = 0; i &lt; _class_count; i++) {
 118     assert(get_ik(_class_defs[i].klass)-&gt;is_being_redefined(),
 119            &quot;should be being redefined to get here&quot;);
 120     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(false);
 121   }
 122   ml.notify_all();
 123 }
 124 
 125 bool VM_RedefineClasses::doit_prologue() {
 126   if (_class_count == 0) {
 127     _res = JVMTI_ERROR_NONE;
 128     return false;
 129   }
 130   if (_class_defs == NULL) {
 131     _res = JVMTI_ERROR_NULL_POINTER;
 132     return false;
 133   }
 134 
 135   for (int i = 0; i &lt; _class_count; i++) {
 136     if (_class_defs[i].klass == NULL) {
 137       _res = JVMTI_ERROR_INVALID_CLASS;
 138       return false;
 139     }
 140     if (_class_defs[i].class_byte_count == 0) {
 141       _res = JVMTI_ERROR_INVALID_CLASS_FORMAT;
 142       return false;
 143     }
 144     if (_class_defs[i].class_bytes == NULL) {
 145       _res = JVMTI_ERROR_NULL_POINTER;
 146       return false;
 147     }
 148 
 149     oop mirror = JNIHandles::resolve_non_null(_class_defs[i].klass);
 150     // classes for primitives and arrays and vm unsafe anonymous classes cannot be redefined
 151     // check here so following code can assume these classes are InstanceKlass
 152     if (!is_modifiable_class(mirror)) {
 153       _res = JVMTI_ERROR_UNMODIFIABLE_CLASS;
 154       return false;
 155     }
 156   }
 157 
 158   // Start timer after all the sanity checks; not quite accurate, but
 159   // better than adding a bunch of stop() calls.
 160   if (log_is_enabled(Info, redefine, class, timer)) {
 161     _timer_vm_op_prologue.start();
 162   }
 163 
 164   lock_classes();
 165   // We first load new class versions in the prologue, because somewhere down the
 166   // call chain it is required that the current thread is a Java thread.
 167   _res = load_new_class_versions(Thread::current());
 168   if (_res != JVMTI_ERROR_NONE) {
 169     // free any successfully created classes, since none are redefined
 170     for (int i = 0; i &lt; _class_count; i++) {
 171       if (_scratch_classes[i] != NULL) {
 172         ClassLoaderData* cld = _scratch_classes[i]-&gt;class_loader_data();
 173         // Free the memory for this class at class unloading time.  Not before
 174         // because CMS might think this is still live.
 175         InstanceKlass* ik = get_ik(_class_defs[i].klass);
 176         if (ik-&gt;get_cached_class_file() == _scratch_classes[i]-&gt;get_cached_class_file()) {
 177           // Don&#39;t double-free cached_class_file copied from the original class if error.
 178           _scratch_classes[i]-&gt;set_cached_class_file(NULL);
 179         }
 180         cld-&gt;add_to_deallocate_list(InstanceKlass::cast(_scratch_classes[i]));
 181       }
 182     }
 183     // Free os::malloc allocated memory in load_new_class_version.
 184     os::free(_scratch_classes);
 185     _timer_vm_op_prologue.stop();
 186     unlock_classes();
 187     return false;
 188   }
 189 
 190   _timer_vm_op_prologue.stop();
 191   return true;
 192 }
 193 
 194 void VM_RedefineClasses::doit() {
 195   Thread *thread = Thread::current();
 196 
 197 #if INCLUDE_CDS
 198   if (UseSharedSpaces) {
 199     // Sharing is enabled so we remap the shared readonly space to
 200     // shared readwrite, private just in case we need to redefine
 201     // a shared class. We do the remap during the doit() phase of
 202     // the safepoint to be safer.
 203     if (!MetaspaceShared::remap_shared_readonly_as_readwrite()) {
 204       log_info(redefine, class, load)(&quot;failed to remap shared readonly space to readwrite, private&quot;);
 205       _res = JVMTI_ERROR_INTERNAL;
 206       return;
 207     }
 208   }
 209 #endif
 210 
 211   // Mark methods seen on stack and everywhere else so old methods are not
 212   // cleaned up if they&#39;re on the stack.
 213   MetadataOnStackMark md_on_stack(/*walk_all_metadata*/true, /*redefinition_walk*/true);
 214   HandleMark hm(thread);   // make sure any handles created are deleted
 215                            // before the stack walk again.
 216 
 217   for (int i = 0; i &lt; _class_count; i++) {
 218     redefine_single_class(_class_defs[i].klass, _scratch_classes[i], thread);
 219   }
 220 
 221   // Flush all compiled code that depends on the classes redefined.
 222   flush_dependent_code();
 223 
 224   // Adjust constantpool caches and vtables for all classes
 225   // that reference methods of the evolved classes.
 226   // Have to do this after all classes are redefined and all methods that
 227   // are redefined are marked as old.
 228   AdjustAndCleanMetadata adjust_and_clean_metadata(thread);
 229   ClassLoaderDataGraph::classes_do(&amp;adjust_and_clean_metadata);
 230 
 231   // JSR-292 support
 232   if (_any_class_has_resolved_methods) {
 233     bool trace_name_printed = false;
 234     ResolvedMethodTable::adjust_method_entries(&amp;trace_name_printed);
 235   }
 236 
 237   // Increment flag indicating that some invariants are no longer true.
 238   // See jvmtiExport.hpp for detailed explanation.
 239   JvmtiExport::increment_redefinition_count();
 240 
 241   // check_class() is optionally called for product bits, but is
 242   // always called for non-product bits.
 243 #ifdef PRODUCT
 244   if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
 245 #endif
 246     log_trace(redefine, class, obsolete, metadata)(&quot;calling check_class&quot;);
 247     CheckClass check_class(thread);
 248     ClassLoaderDataGraph::classes_do(&amp;check_class);
 249 #ifdef PRODUCT
 250   }
 251 #endif
 252 
 253   // Clean up any metadata now unreferenced while MetadataOnStackMark is set.
 254   ClassLoaderDataGraph::clean_deallocate_lists(false);
 255 }
 256 
 257 void VM_RedefineClasses::doit_epilogue() {
 258   unlock_classes();
 259 
 260   // Free os::malloc allocated memory.
 261   os::free(_scratch_classes);
 262 
 263   // Reset the_class to null for error printing.
 264   _the_class = NULL;
 265 
 266   if (log_is_enabled(Info, redefine, class, timer)) {
 267     // Used to have separate timers for &quot;doit&quot; and &quot;all&quot;, but the timer
 268     // overhead skewed the measurements.
 269     julong doit_time = _timer_rsc_phase1.milliseconds() +
 270                        _timer_rsc_phase2.milliseconds();
 271     julong all_time = _timer_vm_op_prologue.milliseconds() + doit_time;
 272 
 273     log_info(redefine, class, timer)
 274       (&quot;vm_op: all=&quot; JULONG_FORMAT &quot;  prologue=&quot; JULONG_FORMAT &quot;  doit=&quot; JULONG_FORMAT,
 275        all_time, (julong)_timer_vm_op_prologue.milliseconds(), doit_time);
 276     log_info(redefine, class, timer)
 277       (&quot;redefine_single_class: phase1=&quot; JULONG_FORMAT &quot;  phase2=&quot; JULONG_FORMAT,
 278        (julong)_timer_rsc_phase1.milliseconds(), (julong)_timer_rsc_phase2.milliseconds());
 279   }
 280 }
 281 
 282 bool VM_RedefineClasses::is_modifiable_class(oop klass_mirror) {
 283   // classes for primitives cannot be redefined
 284   if (java_lang_Class::is_primitive(klass_mirror)) {
 285     return false;
 286   }
 287   Klass* k = java_lang_Class::as_Klass(klass_mirror);
 288   // classes for arrays cannot be redefined
 289   if (k == NULL || !k-&gt;is_instance_klass()) {
 290     return false;
 291   }
 292 
 293   // Cannot redefine or retransform an unsafe anonymous class.
 294   if (InstanceKlass::cast(k)-&gt;is_unsafe_anonymous()) {
 295     return false;
 296   }
 297   return true;
 298 }
 299 
 300 // Append the current entry at scratch_i in scratch_cp to *merge_cp_p
 301 // where the end of *merge_cp_p is specified by *merge_cp_length_p. For
 302 // direct CP entries, there is just the current entry to append. For
 303 // indirect and double-indirect CP entries, there are zero or more
 304 // referenced CP entries along with the current entry to append.
 305 // Indirect and double-indirect CP entries are handled by recursive
 306 // calls to append_entry() as needed. The referenced CP entries are
 307 // always appended to *merge_cp_p before the referee CP entry. These
 308 // referenced CP entries may already exist in *merge_cp_p in which case
 309 // there is nothing extra to append and only the current entry is
 310 // appended.
 311 void VM_RedefineClasses::append_entry(const constantPoolHandle&amp; scratch_cp,
 312        int scratch_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p,
 313        TRAPS) {
 314 
 315   // append is different depending on entry tag type
 316   switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
 317 
 318     // The old verifier is implemented outside the VM. It loads classes,
 319     // but does not resolve constant pool entries directly so we never
 320     // see Class entries here with the old verifier. Similarly the old
 321     // verifier does not like Class entries in the input constant pool.
 322     // The split-verifier is implemented in the VM so it can optionally
 323     // and directly resolve constant pool entries to load classes. The
 324     // split-verifier can accept either Class entries or UnresolvedClass
 325     // entries in the input constant pool. We revert the appended copy
 326     // back to UnresolvedClass so that either verifier will be happy
 327     // with the constant pool entry.
 328     //
 329     // this is an indirect CP entry so it needs special handling
 330     case JVM_CONSTANT_Class:
 331     case JVM_CONSTANT_UnresolvedClass:
 332     {
 333       int name_i = scratch_cp-&gt;klass_name_index_at(scratch_i);
 334       int new_name_i = find_or_append_indirect_entry(scratch_cp, name_i, merge_cp_p,
 335                                                      merge_cp_length_p, THREAD);
 336 
 337       if (new_name_i != name_i) {
 338         log_trace(redefine, class, constantpool)
 339           (&quot;Class entry@%d name_index change: %d to %d&quot;,
 340            *merge_cp_length_p, name_i, new_name_i);
 341       }
 342 
 343       (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(*merge_cp_length_p, new_name_i);
 344       if (scratch_i != *merge_cp_length_p) {
 345         // The new entry in *merge_cp_p is at a different index than
 346         // the new entry in scratch_cp so we need to map the index values.
 347         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 348       }
 349       (*merge_cp_length_p)++;
 350     } break;
 351 
 352     // these are direct CP entries so they can be directly appended,
 353     // but double and long take two constant pool entries
 354     case JVM_CONSTANT_Double:  // fall through
 355     case JVM_CONSTANT_Long:
 356     {
 357       ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,
 358         THREAD);
 359 
 360       if (scratch_i != *merge_cp_length_p) {
 361         // The new entry in *merge_cp_p is at a different index than
 362         // the new entry in scratch_cp so we need to map the index values.
 363         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 364       }
 365       (*merge_cp_length_p) += 2;
 366     } break;
 367 
 368     // these are direct CP entries so they can be directly appended
 369     case JVM_CONSTANT_Float:   // fall through
 370     case JVM_CONSTANT_Integer: // fall through
 371     case JVM_CONSTANT_Utf8:    // fall through
 372 
 373     // This was an indirect CP entry, but it has been changed into
 374     // Symbol*s so this entry can be directly appended.
 375     case JVM_CONSTANT_String:      // fall through
 376     {
 377       ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,
 378         THREAD);
 379 
 380       if (scratch_i != *merge_cp_length_p) {
 381         // The new entry in *merge_cp_p is at a different index than
 382         // the new entry in scratch_cp so we need to map the index values.
 383         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 384       }
 385       (*merge_cp_length_p)++;
 386     } break;
 387 
 388     // this is an indirect CP entry so it needs special handling
 389     case JVM_CONSTANT_NameAndType:
 390     {
 391       int name_ref_i = scratch_cp-&gt;name_ref_index_at(scratch_i);
 392       int new_name_ref_i = find_or_append_indirect_entry(scratch_cp, name_ref_i, merge_cp_p,
 393                                                          merge_cp_length_p, THREAD);
 394 
 395       int signature_ref_i = scratch_cp-&gt;signature_ref_index_at(scratch_i);
 396       int new_signature_ref_i = find_or_append_indirect_entry(scratch_cp, signature_ref_i,
 397                                                               merge_cp_p, merge_cp_length_p,
 398                                                               THREAD);
 399 
 400       // If the referenced entries already exist in *merge_cp_p, then
 401       // both new_name_ref_i and new_signature_ref_i will both be 0.
 402       // In that case, all we are appending is the current entry.
 403       if (new_name_ref_i != name_ref_i) {
 404         log_trace(redefine, class, constantpool)
 405           (&quot;NameAndType entry@%d name_ref_index change: %d to %d&quot;,
 406            *merge_cp_length_p, name_ref_i, new_name_ref_i);
 407       }
 408       if (new_signature_ref_i != signature_ref_i) {
 409         log_trace(redefine, class, constantpool)
 410           (&quot;NameAndType entry@%d signature_ref_index change: %d to %d&quot;,
 411            *merge_cp_length_p, signature_ref_i, new_signature_ref_i);
 412       }
 413 
 414       (*merge_cp_p)-&gt;name_and_type_at_put(*merge_cp_length_p,
 415         new_name_ref_i, new_signature_ref_i);
 416       if (scratch_i != *merge_cp_length_p) {
 417         // The new entry in *merge_cp_p is at a different index than
 418         // the new entry in scratch_cp so we need to map the index values.
 419         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 420       }
 421       (*merge_cp_length_p)++;
 422     } break;
 423 
 424     // this is a double-indirect CP entry so it needs special handling
 425     case JVM_CONSTANT_Fieldref:           // fall through
 426     case JVM_CONSTANT_InterfaceMethodref: // fall through
 427     case JVM_CONSTANT_Methodref:
 428     {
 429       int klass_ref_i = scratch_cp-&gt;uncached_klass_ref_index_at(scratch_i);
 430       int new_klass_ref_i = find_or_append_indirect_entry(scratch_cp, klass_ref_i,
 431                                                           merge_cp_p, merge_cp_length_p, THREAD);
 432 
 433       int name_and_type_ref_i = scratch_cp-&gt;uncached_name_and_type_ref_index_at(scratch_i);
 434       int new_name_and_type_ref_i = find_or_append_indirect_entry(scratch_cp, name_and_type_ref_i,
 435                                                           merge_cp_p, merge_cp_length_p, THREAD);
 436 
 437       const char *entry_name = NULL;
 438       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
 439       case JVM_CONSTANT_Fieldref:
 440         entry_name = &quot;Fieldref&quot;;
 441         (*merge_cp_p)-&gt;field_at_put(*merge_cp_length_p, new_klass_ref_i,
 442           new_name_and_type_ref_i);
 443         break;
 444       case JVM_CONSTANT_InterfaceMethodref:
 445         entry_name = &quot;IFMethodref&quot;;
 446         (*merge_cp_p)-&gt;interface_method_at_put(*merge_cp_length_p,
 447           new_klass_ref_i, new_name_and_type_ref_i);
 448         break;
 449       case JVM_CONSTANT_Methodref:
 450         entry_name = &quot;Methodref&quot;;
 451         (*merge_cp_p)-&gt;method_at_put(*merge_cp_length_p, new_klass_ref_i,
 452           new_name_and_type_ref_i);
 453         break;
 454       default:
 455         guarantee(false, &quot;bad switch&quot;);
 456         break;
 457       }
 458 
 459       if (klass_ref_i != new_klass_ref_i) {
 460         log_trace(redefine, class, constantpool)
 461           (&quot;%s entry@%d class_index changed: %d to %d&quot;, entry_name, *merge_cp_length_p, klass_ref_i, new_klass_ref_i);
 462       }
 463       if (name_and_type_ref_i != new_name_and_type_ref_i) {
 464         log_trace(redefine, class, constantpool)
 465           (&quot;%s entry@%d name_and_type_index changed: %d to %d&quot;,
 466            entry_name, *merge_cp_length_p, name_and_type_ref_i, new_name_and_type_ref_i);
 467       }
 468 
 469       if (scratch_i != *merge_cp_length_p) {
 470         // The new entry in *merge_cp_p is at a different index than
 471         // the new entry in scratch_cp so we need to map the index values.
 472         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 473       }
 474       (*merge_cp_length_p)++;
 475     } break;
 476 
 477     // this is an indirect CP entry so it needs special handling
 478     case JVM_CONSTANT_MethodType:
 479     {
 480       int ref_i = scratch_cp-&gt;method_type_index_at(scratch_i);
 481       int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
 482                                                     merge_cp_length_p, THREAD);
 483       if (new_ref_i != ref_i) {
 484         log_trace(redefine, class, constantpool)
 485           (&quot;MethodType entry@%d ref_index change: %d to %d&quot;, *merge_cp_length_p, ref_i, new_ref_i);
 486       }
 487       (*merge_cp_p)-&gt;method_type_index_at_put(*merge_cp_length_p, new_ref_i);
 488       if (scratch_i != *merge_cp_length_p) {
 489         // The new entry in *merge_cp_p is at a different index than
 490         // the new entry in scratch_cp so we need to map the index values.
 491         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 492       }
 493       (*merge_cp_length_p)++;
 494     } break;
 495 
 496     // this is an indirect CP entry so it needs special handling
 497     case JVM_CONSTANT_MethodHandle:
 498     {
 499       int ref_kind = scratch_cp-&gt;method_handle_ref_kind_at(scratch_i);
 500       int ref_i = scratch_cp-&gt;method_handle_index_at(scratch_i);
 501       int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
 502                                                     merge_cp_length_p, THREAD);
 503       if (new_ref_i != ref_i) {
 504         log_trace(redefine, class, constantpool)
 505           (&quot;MethodHandle entry@%d ref_index change: %d to %d&quot;, *merge_cp_length_p, ref_i, new_ref_i);
 506       }
 507       (*merge_cp_p)-&gt;method_handle_index_at_put(*merge_cp_length_p, ref_kind, new_ref_i);
 508       if (scratch_i != *merge_cp_length_p) {
 509         // The new entry in *merge_cp_p is at a different index than
 510         // the new entry in scratch_cp so we need to map the index values.
 511         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 512       }
 513       (*merge_cp_length_p)++;
 514     } break;
 515 
 516     // this is an indirect CP entry so it needs special handling
 517     case JVM_CONSTANT_Dynamic:  // fall through
 518     case JVM_CONSTANT_InvokeDynamic:
 519     {
 520       // Index of the bootstrap specifier in the operands array
 521       int old_bs_i = scratch_cp-&gt;bootstrap_methods_attribute_index(scratch_i);
 522       int new_bs_i = find_or_append_operand(scratch_cp, old_bs_i, merge_cp_p,
 523                                             merge_cp_length_p, THREAD);
 524       // The bootstrap method NameAndType_info index
 525       int old_ref_i = scratch_cp-&gt;bootstrap_name_and_type_ref_index_at(scratch_i);
 526       int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
 527                                                     merge_cp_length_p, THREAD);
 528       if (new_bs_i != old_bs_i) {
 529         log_trace(redefine, class, constantpool)
 530           (&quot;Dynamic entry@%d bootstrap_method_attr_index change: %d to %d&quot;,
 531            *merge_cp_length_p, old_bs_i, new_bs_i);
 532       }
 533       if (new_ref_i != old_ref_i) {
 534         log_trace(redefine, class, constantpool)
 535           (&quot;Dynamic entry@%d name_and_type_index change: %d to %d&quot;, *merge_cp_length_p, old_ref_i, new_ref_i);
 536       }
 537 
 538       if (scratch_cp-&gt;tag_at(scratch_i).is_dynamic_constant())
 539         (*merge_cp_p)-&gt;dynamic_constant_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
 540       else
 541         (*merge_cp_p)-&gt;invoke_dynamic_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
 542       if (scratch_i != *merge_cp_length_p) {
 543         // The new entry in *merge_cp_p is at a different index than
 544         // the new entry in scratch_cp so we need to map the index values.
 545         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 546       }
 547       (*merge_cp_length_p)++;
 548     } break;
 549 
 550     // At this stage, Class or UnresolvedClass could be in scratch_cp, but not
 551     // ClassIndex
 552     case JVM_CONSTANT_ClassIndex: // fall through
 553 
 554     // Invalid is used as the tag for the second constant pool entry
 555     // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
 556     // not be seen by itself.
 557     case JVM_CONSTANT_Invalid: // fall through
 558 
 559     // At this stage, String could be here, but not StringIndex
 560     case JVM_CONSTANT_StringIndex: // fall through
 561 
 562     // At this stage JVM_CONSTANT_UnresolvedClassInError should not be
 563     // here
 564     case JVM_CONSTANT_UnresolvedClassInError: // fall through
 565 
 566     default:
 567     {
 568       // leave a breadcrumb
 569       jbyte bad_value = scratch_cp-&gt;tag_at(scratch_i).value();
 570       ShouldNotReachHere();
 571     } break;
 572   } // end switch tag value
 573 } // end append_entry()
 574 
 575 
 576 int VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle&amp; scratch_cp,
 577       int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 578 
 579   int new_ref_i = ref_i;
 580   bool match = (ref_i &lt; *merge_cp_length_p) &amp;&amp;
 581                scratch_cp-&gt;compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);
 582 
 583   if (!match) {
 584     // forward reference in *merge_cp_p or not a direct match
 585     int found_i = scratch_cp-&gt;find_matching_entry(ref_i, *merge_cp_p, THREAD);
 586     if (found_i != 0) {
 587       guarantee(found_i != ref_i, &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
 588       // Found a matching entry somewhere else in *merge_cp_p so just need a mapping entry.
 589       new_ref_i = found_i;
 590       map_index(scratch_cp, ref_i, found_i);
 591     } else {
 592       // no match found so we have to append this entry to *merge_cp_p
 593       append_entry(scratch_cp, ref_i, merge_cp_p, merge_cp_length_p, THREAD);
 594       // The above call to append_entry() can only append one entry
 595       // so the post call query of *merge_cp_length_p is only for
 596       // the sake of consistency.
 597       new_ref_i = *merge_cp_length_p - 1;
 598     }
 599   }
 600 
 601   return new_ref_i;
 602 } // end find_or_append_indirect_entry()
 603 
 604 
 605 // Append a bootstrap specifier into the merge_cp operands that is semantically equal
 606 // to the scratch_cp operands bootstrap specifier passed by the old_bs_i index.
 607 // Recursively append new merge_cp entries referenced by the new bootstrap specifier.
 608 void VM_RedefineClasses::append_operand(const constantPoolHandle&amp; scratch_cp, int old_bs_i,
 609        constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 610 
 611   int old_ref_i = scratch_cp-&gt;operand_bootstrap_method_ref_index_at(old_bs_i);
 612   int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
 613                                                 merge_cp_length_p, THREAD);
 614   if (new_ref_i != old_ref_i) {
 615     log_trace(redefine, class, constantpool)
 616       (&quot;operands entry@%d bootstrap method ref_index change: %d to %d&quot;, _operands_cur_length, old_ref_i, new_ref_i);
 617   }
 618 
 619   Array&lt;u2&gt;* merge_ops = (*merge_cp_p)-&gt;operands();
 620   int new_bs_i = _operands_cur_length;
 621   // We have _operands_cur_length == 0 when the merge_cp operands is empty yet.
 622   // However, the operand_offset_at(0) was set in the extend_operands() call.
 623   int new_base = (new_bs_i == 0) ? (*merge_cp_p)-&gt;operand_offset_at(0)
 624                                  : (*merge_cp_p)-&gt;operand_next_offset_at(new_bs_i - 1);
 625   int argc     = scratch_cp-&gt;operand_argument_count_at(old_bs_i);
 626 
 627   ConstantPool::operand_offset_at_put(merge_ops, _operands_cur_length, new_base);
 628   merge_ops-&gt;at_put(new_base++, new_ref_i);
 629   merge_ops-&gt;at_put(new_base++, argc);
 630 
 631   for (int i = 0; i &lt; argc; i++) {
 632     int old_arg_ref_i = scratch_cp-&gt;operand_argument_index_at(old_bs_i, i);
 633     int new_arg_ref_i = find_or_append_indirect_entry(scratch_cp, old_arg_ref_i, merge_cp_p,
 634                                                       merge_cp_length_p, THREAD);
 635     merge_ops-&gt;at_put(new_base++, new_arg_ref_i);
 636     if (new_arg_ref_i != old_arg_ref_i) {
 637       log_trace(redefine, class, constantpool)
 638         (&quot;operands entry@%d bootstrap method argument ref_index change: %d to %d&quot;,
 639          _operands_cur_length, old_arg_ref_i, new_arg_ref_i);
 640     }
 641   }
 642   if (old_bs_i != _operands_cur_length) {
 643     // The bootstrap specifier in *merge_cp_p is at a different index than
 644     // that in scratch_cp so we need to map the index values.
 645     map_operand_index(old_bs_i, new_bs_i);
 646   }
 647   _operands_cur_length++;
 648 } // end append_operand()
 649 
 650 
 651 int VM_RedefineClasses::find_or_append_operand(const constantPoolHandle&amp; scratch_cp,
 652       int old_bs_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 653 
 654   int new_bs_i = old_bs_i; // bootstrap specifier index
 655   bool match = (old_bs_i &lt; _operands_cur_length) &amp;&amp;
 656                scratch_cp-&gt;compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i, THREAD);
 657 
 658   if (!match) {
 659     // forward reference in *merge_cp_p or not a direct match
 660     int found_i = scratch_cp-&gt;find_matching_operand(old_bs_i, *merge_cp_p,
 661                                                     _operands_cur_length, THREAD);
 662     if (found_i != -1) {
 663       guarantee(found_i != old_bs_i, &quot;compare_operand_to() and find_matching_operand() disagree&quot;);
 664       // found a matching operand somewhere else in *merge_cp_p so just need a mapping
 665       new_bs_i = found_i;
 666       map_operand_index(old_bs_i, found_i);
 667     } else {
 668       // no match found so we have to append this bootstrap specifier to *merge_cp_p
 669       append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p, THREAD);
 670       new_bs_i = _operands_cur_length - 1;
 671     }
 672   }
 673   return new_bs_i;
 674 } // end find_or_append_operand()
 675 
 676 
 677 void VM_RedefineClasses::finalize_operands_merge(const constantPoolHandle&amp; merge_cp, TRAPS) {
 678   if (merge_cp-&gt;operands() == NULL) {
 679     return;
 680   }
 681   // Shrink the merge_cp operands
 682   merge_cp-&gt;shrink_operands(_operands_cur_length, CHECK);
 683 
 684   if (log_is_enabled(Trace, redefine, class, constantpool)) {
 685     // don&#39;t want to loop unless we are tracing
 686     int count = 0;
 687     for (int i = 1; i &lt; _operands_index_map_p-&gt;length(); i++) {
 688       int value = _operands_index_map_p-&gt;at(i);
 689       if (value != -1) {
 690         log_trace(redefine, class, constantpool)(&quot;operands_index_map[%d]: old=%d new=%d&quot;, count, i, value);
 691         count++;
 692       }
 693     }
 694   }
 695   // Clean-up
 696   _operands_index_map_p = NULL;
 697   _operands_cur_length = 0;
 698   _operands_index_map_count = 0;
 699 } // end finalize_operands_merge()
 700 
 701 // Symbol* comparator for qsort
 702 // The caller must have an active ResourceMark.
 703 static int symcmp(const void* a, const void* b) {
 704   char* astr = (*(Symbol**)a)-&gt;as_C_string();
 705   char* bstr = (*(Symbol**)b)-&gt;as_C_string();
 706   return strcmp(astr, bstr);
 707 }
 708 
 709 static jvmtiError check_nest_attributes(InstanceKlass* the_class,
 710                                         InstanceKlass* scratch_class) {
 711   // Check whether the class NestHost attribute has been changed.
 712   Thread* thread = Thread::current();
 713   ResourceMark rm(thread);
 714   u2 the_nest_host_idx = the_class-&gt;nest_host_index();
 715   u2 scr_nest_host_idx = scratch_class-&gt;nest_host_index();
 716 
 717   if (the_nest_host_idx != 0 &amp;&amp; scr_nest_host_idx != 0) {
 718     Symbol* the_sym = the_class-&gt;constants()-&gt;klass_name_at(the_nest_host_idx);
 719     Symbol* scr_sym = scratch_class-&gt;constants()-&gt;klass_name_at(scr_nest_host_idx);
 720     if (the_sym != scr_sym) {
 721       log_trace(redefine, class, nestmates)
 722         (&quot;redefined class %s attribute change error: NestHost class: %s replaced with: %s&quot;,
 723          the_class-&gt;external_name(), the_sym-&gt;as_C_string(), scr_sym-&gt;as_C_string());
 724       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 725     }
 726   } else if ((the_nest_host_idx == 0) ^ (scr_nest_host_idx == 0)) {
 727     const char* action_str = (the_nest_host_idx != 0) ? &quot;removed&quot; : &quot;added&quot;;
 728     log_trace(redefine, class, nestmates)
 729       (&quot;redefined class %s attribute change error: NestHost attribute %s&quot;,
 730        the_class-&gt;external_name(), action_str);
 731     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 732   }
 733 
 734   // Check whether the class NestMembers attribute has been changed.
 735   Array&lt;u2&gt;* the_nest_members = the_class-&gt;nest_members();
 736   Array&lt;u2&gt;* scr_nest_members = scratch_class-&gt;nest_members();
 737   bool the_members_exists = the_nest_members != Universe::the_empty_short_array();
 738   bool scr_members_exists = scr_nest_members != Universe::the_empty_short_array();
 739 
 740   int members_len = the_nest_members-&gt;length();
 741   if (the_members_exists &amp;&amp; scr_members_exists) {
 742     if (members_len != scr_nest_members-&gt;length()) {
 743       log_trace(redefine, class, nestmates)
 744         (&quot;redefined class %s attribute change error: NestMember len=%d changed to len=%d&quot;,
 745          the_class-&gt;external_name(), members_len, scr_nest_members-&gt;length());
 746       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 747     }
 748 
 749     // The order of entries in the NestMembers array is not specified so we
 750     // have to explicitly check for the same contents. We do this by copying
 751     // the referenced symbols into their own arrays, sorting them and then
 752     // comparing each element pair.
 753 
 754     Symbol** the_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, members_len);
 755     Symbol** scr_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, members_len);
 756 
 757     if (the_syms == NULL || scr_syms == NULL) {
 758       return JVMTI_ERROR_OUT_OF_MEMORY;
 759     }
 760 
 761     for (int i = 0; i &lt; members_len; i++) {
 762       int the_cp_index = the_nest_members-&gt;at(i);
 763       int scr_cp_index = scr_nest_members-&gt;at(i);
 764       the_syms[i] = the_class-&gt;constants()-&gt;klass_name_at(the_cp_index);
 765       scr_syms[i] = scratch_class-&gt;constants()-&gt;klass_name_at(scr_cp_index);
 766     }
 767 
 768     qsort(the_syms, members_len, sizeof(Symbol*), symcmp);
 769     qsort(scr_syms, members_len, sizeof(Symbol*), symcmp);
 770 
 771     for (int i = 0; i &lt; members_len; i++) {
 772       if (the_syms[i] != scr_syms[i]) {
 773         log_trace(redefine, class, nestmates)
 774           (&quot;redefined class %s attribute change error: NestMembers[%d]: %s changed to %s&quot;,
 775            the_class-&gt;external_name(), i, the_syms[i]-&gt;as_C_string(), scr_syms[i]-&gt;as_C_string());
 776         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 777       }
 778     }
 779   } else if (the_members_exists ^ scr_members_exists) {
 780     const char* action_str = (the_members_exists) ? &quot;removed&quot; : &quot;added&quot;;
 781     log_trace(redefine, class, nestmates)
 782       (&quot;redefined class %s attribute change error: NestMembers attribute %s&quot;,
 783        the_class-&gt;external_name(), action_str);
 784     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 785   }
 786 
 787   return JVMTI_ERROR_NONE;
 788 }
 789 
 790 // Return an error status if the class Record attribute was changed.
 791 static jvmtiError check_record_attribute(InstanceKlass* the_class, InstanceKlass* scratch_class) {
 792   // Get lists of record components.
 793   Array&lt;RecordComponent*&gt;* the_record = the_class-&gt;record_components();
 794   Array&lt;RecordComponent*&gt;* scr_record = scratch_class-&gt;record_components();
 795   bool the_record_exists = the_record != NULL;
 796   bool scr_record_exists = scr_record != NULL;
 797 
 798   if (the_record_exists &amp;&amp; scr_record_exists) {
 799     int the_num_components = the_record-&gt;length();
 800     int scr_num_components = scr_record-&gt;length();
 801     if (the_num_components != scr_num_components) {
 802       log_trace(redefine, class, record)
 803         (&quot;redefined class %s attribute change error: Record num_components=%d changed to num_components=%d&quot;,
 804          the_class-&gt;external_name(), the_num_components, scr_num_components);
 805       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 806     }
 807 
 808     // Compare each field in each record component.
 809     ConstantPool* the_cp =  the_class-&gt;constants();
 810     ConstantPool* scr_cp =  scratch_class-&gt;constants();
 811     for (int x = 0; x &lt; the_num_components; x++) {
 812       RecordComponent* the_component = the_record-&gt;at(x);
 813       RecordComponent* scr_component = scr_record-&gt;at(x);
 814       const Symbol* const the_name = the_cp-&gt;symbol_at(the_component-&gt;name_index());
 815       const Symbol* const scr_name = scr_cp-&gt;symbol_at(scr_component-&gt;name_index());
 816       const Symbol* const the_descr = the_cp-&gt;symbol_at(the_component-&gt;descriptor_index());
 817       const Symbol* const scr_descr = scr_cp-&gt;symbol_at(scr_component-&gt;descriptor_index());
 818       if (the_name != scr_name || the_descr != scr_descr) {
 819         log_trace(redefine, class, record)
 820           (&quot;redefined class %s attribute change error: Record name_index, descriptor_index, and/or attributes_count changed&quot;,
 821            the_class-&gt;external_name());
 822         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 823       }
 824 
 825       int the_gen_sig = the_component-&gt;generic_signature_index();
 826       int scr_gen_sig = scr_component-&gt;generic_signature_index();
 827       const Symbol* const the_gen_sig_sym = (the_gen_sig == 0 ? NULL :
 828         the_cp-&gt;symbol_at(the_component-&gt;generic_signature_index()));
 829       const Symbol* const scr_gen_sig_sym = (scr_gen_sig == 0 ? NULL :
 830         scr_cp-&gt;symbol_at(scr_component-&gt;generic_signature_index()));
 831       if (the_gen_sig_sym != scr_gen_sig_sym) {
 832         log_trace(redefine, class, record)
 833           (&quot;redefined class %s attribute change error: Record generic_signature attribute changed&quot;,
 834            the_class-&gt;external_name());
 835         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 836       }
 837 
 838       // It&#39;s okay if a record component&#39;s annotations were changed.
 839     }
 840 
 841   } else if (the_record_exists ^ scr_record_exists) {
 842     const char* action_str = (the_record_exists) ? &quot;removed&quot; : &quot;added&quot;;
 843     log_trace(redefine, class, record)
 844       (&quot;redefined class %s attribute change error: Record attribute %s&quot;,
 845        the_class-&gt;external_name(), action_str);
 846     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 847   }
 848 
 849   return JVMTI_ERROR_NONE;
 850 }
 851 
 852 
 853 static bool can_add_or_delete(Method* m) {
 854       // Compatibility mode
 855   return (AllowRedefinitionToAddDeleteMethods &amp;&amp;
 856           (m-&gt;is_private() &amp;&amp; (m-&gt;is_static() || m-&gt;is_final())));
 857 }
 858 
 859 jvmtiError VM_RedefineClasses::compare_and_normalize_class_versions(
 860              InstanceKlass* the_class,
 861              InstanceKlass* scratch_class) {
 862   int i;
 863 
 864   // Check superclasses, or rather their names, since superclasses themselves can be
 865   // requested to replace.
 866   // Check for NULL superclass first since this might be java.lang.Object
 867   if (the_class-&gt;super() != scratch_class-&gt;super() &amp;&amp;
 868       (the_class-&gt;super() == NULL || scratch_class-&gt;super() == NULL ||
 869        the_class-&gt;super()-&gt;name() !=
 870        scratch_class-&gt;super()-&gt;name())) {
 871     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 872   }
 873 
 874   // Check if the number, names and order of directly implemented interfaces are the same.
 875   // I think in principle we should just check if the sets of names of directly implemented
 876   // interfaces are the same, i.e. the order of declaration (which, however, if changed in the
 877   // .java file, also changes in .class file) should not matter. However, comparing sets is
 878   // technically a bit more difficult, and, more importantly, I am not sure at present that the
 879   // order of interfaces does not matter on the implementation level, i.e. that the VM does not
 880   // rely on it somewhere.
 881   Array&lt;InstanceKlass*&gt;* k_interfaces = the_class-&gt;local_interfaces();
 882   Array&lt;InstanceKlass*&gt;* k_new_interfaces = scratch_class-&gt;local_interfaces();
 883   int n_intfs = k_interfaces-&gt;length();
 884   if (n_intfs != k_new_interfaces-&gt;length()) {
 885     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 886   }
 887   for (i = 0; i &lt; n_intfs; i++) {
 888     if (k_interfaces-&gt;at(i)-&gt;name() !=
 889         k_new_interfaces-&gt;at(i)-&gt;name()) {
 890       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 891     }
 892   }
 893 
 894   // Check whether class is in the error init state.
 895   if (the_class-&gt;is_in_error_state()) {
 896     // TBD #5057930: special error code is needed in 1.6
 897     return JVMTI_ERROR_INVALID_CLASS;
 898   }
 899 
 900   // Check whether the nest-related attributes have been changed.
 901   jvmtiError err = check_nest_attributes(the_class, scratch_class);
 902   if (err != JVMTI_ERROR_NONE) {
 903     return err;
 904   }
 905 
 906   // Check whether the Record attribute has been changed.
 907   err = check_record_attribute(the_class, scratch_class);
 908   if (err != JVMTI_ERROR_NONE) {
 909     return err;
 910   }
 911 
 912   // Check whether class modifiers are the same.
 913   jushort old_flags = (jushort) the_class-&gt;access_flags().get_flags();
 914   jushort new_flags = (jushort) scratch_class-&gt;access_flags().get_flags();
 915   if (old_flags != new_flags) {
 916     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
 917   }
 918 
 919   // Check if the number, names, types and order of fields declared in these classes
 920   // are the same.
 921   JavaFieldStream old_fs(the_class);
 922   JavaFieldStream new_fs(scratch_class);
 923   for (; !old_fs.done() &amp;&amp; !new_fs.done(); old_fs.next(), new_fs.next()) {
 924     // access
 925     old_flags = old_fs.access_flags().as_short();
 926     new_flags = new_fs.access_flags().as_short();
 927     if ((old_flags ^ new_flags) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS) {
 928       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 929     }
 930     // offset
 931     if (old_fs.offset() != new_fs.offset()) {
 932       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 933     }
 934     // name and signature
 935     Symbol* name_sym1 = the_class-&gt;constants()-&gt;symbol_at(old_fs.name_index());
 936     Symbol* sig_sym1 = the_class-&gt;constants()-&gt;symbol_at(old_fs.signature_index());
 937     Symbol* name_sym2 = scratch_class-&gt;constants()-&gt;symbol_at(new_fs.name_index());
 938     Symbol* sig_sym2 = scratch_class-&gt;constants()-&gt;symbol_at(new_fs.signature_index());
 939     if (name_sym1 != name_sym2 || sig_sym1 != sig_sym2) {
 940       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 941     }
 942   }
 943 
 944   // If both streams aren&#39;t done then we have a differing number of
 945   // fields.
 946   if (!old_fs.done() || !new_fs.done()) {
 947     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 948   }
 949 
 950   // Do a parallel walk through the old and new methods. Detect
 951   // cases where they match (exist in both), have been added in
 952   // the new methods, or have been deleted (exist only in the
 953   // old methods).  The class file parser places methods in order
 954   // by method name, but does not order overloaded methods by
 955   // signature.  In order to determine what fate befell the methods,
 956   // this code places the overloaded new methods that have matching
 957   // old methods in the same order as the old methods and places
 958   // new overloaded methods at the end of overloaded methods of
 959   // that name. The code for this order normalization is adapted
 960   // from the algorithm used in InstanceKlass::find_method().
 961   // Since we are swapping out of order entries as we find them,
 962   // we only have to search forward through the overloaded methods.
 963   // Methods which are added and have the same name as an existing
 964   // method (but different signature) will be put at the end of
 965   // the methods with that name, and the name mismatch code will
 966   // handle them.
 967   Array&lt;Method*&gt;* k_old_methods(the_class-&gt;methods());
 968   Array&lt;Method*&gt;* k_new_methods(scratch_class-&gt;methods());
 969   int n_old_methods = k_old_methods-&gt;length();
 970   int n_new_methods = k_new_methods-&gt;length();
 971   Thread* thread = Thread::current();
 972 
 973   int ni = 0;
 974   int oi = 0;
 975   while (true) {
 976     Method* k_old_method;
 977     Method* k_new_method;
 978     enum { matched, added, deleted, undetermined } method_was = undetermined;
 979 
 980     if (oi &gt;= n_old_methods) {
 981       if (ni &gt;= n_new_methods) {
 982         break; // we&#39;ve looked at everything, done
 983       }
 984       // New method at the end
 985       k_new_method = k_new_methods-&gt;at(ni);
 986       method_was = added;
 987     } else if (ni &gt;= n_new_methods) {
 988       // Old method, at the end, is deleted
 989       k_old_method = k_old_methods-&gt;at(oi);
 990       method_was = deleted;
 991     } else {
 992       // There are more methods in both the old and new lists
 993       k_old_method = k_old_methods-&gt;at(oi);
 994       k_new_method = k_new_methods-&gt;at(ni);
 995       if (k_old_method-&gt;name() != k_new_method-&gt;name()) {
 996         // Methods are sorted by method name, so a mismatch means added
 997         // or deleted
 998         if (k_old_method-&gt;name()-&gt;fast_compare(k_new_method-&gt;name()) &gt; 0) {
 999           method_was = added;
1000         } else {
1001           method_was = deleted;
1002         }
1003       } else if (k_old_method-&gt;signature() == k_new_method-&gt;signature()) {
1004         // Both the name and signature match
1005         method_was = matched;
1006       } else {
1007         // The name matches, but the signature doesn&#39;t, which means we have to
1008         // search forward through the new overloaded methods.
1009         int nj;  // outside the loop for post-loop check
1010         for (nj = ni + 1; nj &lt; n_new_methods; nj++) {
1011           Method* m = k_new_methods-&gt;at(nj);
1012           if (k_old_method-&gt;name() != m-&gt;name()) {
1013             // reached another method name so no more overloaded methods
1014             method_was = deleted;
1015             break;
1016           }
1017           if (k_old_method-&gt;signature() == m-&gt;signature()) {
1018             // found a match so swap the methods
1019             k_new_methods-&gt;at_put(ni, m);
1020             k_new_methods-&gt;at_put(nj, k_new_method);
1021             k_new_method = m;
1022             method_was = matched;
1023             break;
1024           }
1025         }
1026 
1027         if (nj &gt;= n_new_methods) {
1028           // reached the end without a match; so method was deleted
1029           method_was = deleted;
1030         }
1031       }
1032     }
1033 
1034     switch (method_was) {
1035     case matched:
1036       // methods match, be sure modifiers do too
1037       old_flags = (jushort) k_old_method-&gt;access_flags().get_flags();
1038       new_flags = (jushort) k_new_method-&gt;access_flags().get_flags();
1039       if ((old_flags ^ new_flags) &amp; ~(JVM_ACC_NATIVE)) {
1040         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED;
1041       }
1042       {
1043         u2 new_num = k_new_method-&gt;method_idnum();
1044         u2 old_num = k_old_method-&gt;method_idnum();
1045         if (new_num != old_num) {
1046           Method* idnum_owner = scratch_class-&gt;method_with_idnum(old_num);
1047           if (idnum_owner != NULL) {
1048             // There is already a method assigned this idnum -- switch them
1049             // Take current and original idnum from the new_method
1050             idnum_owner-&gt;set_method_idnum(new_num);
1051             idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1052           }
1053           // Take current and original idnum from the old_method
1054           k_new_method-&gt;set_method_idnum(old_num);
1055           k_new_method-&gt;set_orig_method_idnum(k_old_method-&gt;orig_method_idnum());
1056           if (thread-&gt;has_pending_exception()) {
1057             return JVMTI_ERROR_OUT_OF_MEMORY;
1058           }
1059         }
1060       }
1061       log_trace(redefine, class, normalize)
1062         (&quot;Method matched: new: %s [%d] == old: %s [%d]&quot;,
1063          k_new_method-&gt;name_and_sig_as_C_string(), ni, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1064       // advance to next pair of methods
1065       ++oi;
1066       ++ni;
1067       break;
1068     case added:
1069       // method added, see if it is OK
1070       if (!can_add_or_delete(k_new_method)) {
1071         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1072       }
1073       {
1074         u2 num = the_class-&gt;next_method_idnum();
1075         if (num == ConstMethod::UNSET_IDNUM) {
1076           // cannot add any more methods
1077           return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1078         }
1079         u2 new_num = k_new_method-&gt;method_idnum();
1080         Method* idnum_owner = scratch_class-&gt;method_with_idnum(num);
1081         if (idnum_owner != NULL) {
1082           // There is already a method assigned this idnum -- switch them
1083           // Take current and original idnum from the new_method
1084           idnum_owner-&gt;set_method_idnum(new_num);
1085           idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1086         }
1087         k_new_method-&gt;set_method_idnum(num);
1088         k_new_method-&gt;set_orig_method_idnum(num);
1089         if (thread-&gt;has_pending_exception()) {
1090           return JVMTI_ERROR_OUT_OF_MEMORY;
1091         }
1092       }
1093       log_trace(redefine, class, normalize)
1094         (&quot;Method added: new: %s [%d]&quot;, k_new_method-&gt;name_and_sig_as_C_string(), ni);
1095       ++ni; // advance to next new method
1096       break;
1097     case deleted:
1098       // method deleted, see if it is OK
1099       if (!can_add_or_delete(k_old_method)) {
1100         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1101       }
1102       log_trace(redefine, class, normalize)
1103         (&quot;Method deleted: old: %s [%d]&quot;, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1104       ++oi; // advance to next old method
1105       break;
1106     default:
1107       ShouldNotReachHere();
1108     }
1109   }
1110 
1111   return JVMTI_ERROR_NONE;
1112 }
1113 
1114 
1115 // Find new constant pool index value for old constant pool index value
1116 // by seaching the index map. Returns zero (0) if there is no mapped
1117 // value for the old constant pool index.
1118 int VM_RedefineClasses::find_new_index(int old_index) {
1119   if (_index_map_count == 0) {
1120     // map is empty so nothing can be found
1121     return 0;
1122   }
1123 
1124   if (old_index &lt; 1 || old_index &gt;= _index_map_p-&gt;length()) {
1125     // The old_index is out of range so it is not mapped. This should
1126     // not happen in regular constant pool merging use, but it can
1127     // happen if a corrupt annotation is processed.
1128     return 0;
1129   }
1130 
1131   int value = _index_map_p-&gt;at(old_index);
1132   if (value == -1) {
1133     // the old_index is not mapped
1134     return 0;
1135   }
1136 
1137   return value;
1138 } // end find_new_index()
1139 
1140 
1141 // Find new bootstrap specifier index value for old bootstrap specifier index
1142 // value by seaching the index map. Returns unused index (-1) if there is
1143 // no mapped value for the old bootstrap specifier index.
1144 int VM_RedefineClasses::find_new_operand_index(int old_index) {
1145   if (_operands_index_map_count == 0) {
1146     // map is empty so nothing can be found
1147     return -1;
1148   }
1149 
1150   if (old_index == -1 || old_index &gt;= _operands_index_map_p-&gt;length()) {
1151     // The old_index is out of range so it is not mapped.
1152     // This should not happen in regular constant pool merging use.
1153     return -1;
1154   }
1155 
1156   int value = _operands_index_map_p-&gt;at(old_index);
1157   if (value == -1) {
1158     // the old_index is not mapped
1159     return -1;
1160   }
1161 
1162   return value;
1163 } // end find_new_operand_index()
1164 
1165 
1166 // Returns true if the current mismatch is due to a resolved/unresolved
1167 // class pair. Otherwise, returns false.
1168 bool VM_RedefineClasses::is_unresolved_class_mismatch(const constantPoolHandle&amp; cp1,
1169        int index1, const constantPoolHandle&amp; cp2, int index2) {
1170 
1171   jbyte t1 = cp1-&gt;tag_at(index1).value();
1172   if (t1 != JVM_CONSTANT_Class &amp;&amp; t1 != JVM_CONSTANT_UnresolvedClass) {
1173     return false;  // wrong entry type; not our special case
1174   }
1175 
1176   jbyte t2 = cp2-&gt;tag_at(index2).value();
1177   if (t2 != JVM_CONSTANT_Class &amp;&amp; t2 != JVM_CONSTANT_UnresolvedClass) {
1178     return false;  // wrong entry type; not our special case
1179   }
1180 
1181   if (t1 == t2) {
1182     return false;  // not a mismatch; not our special case
1183   }
1184 
1185   char *s1 = cp1-&gt;klass_name_at(index1)-&gt;as_C_string();
1186   char *s2 = cp2-&gt;klass_name_at(index2)-&gt;as_C_string();
1187   if (strcmp(s1, s2) != 0) {
1188     return false;  // strings don&#39;t match; not our special case
1189   }
1190 
1191   return true;  // made it through the gauntlet; this is our special case
1192 } // end is_unresolved_class_mismatch()
1193 
1194 
1195 jvmtiError VM_RedefineClasses::load_new_class_versions(TRAPS) {
1196 
1197   // For consistency allocate memory using os::malloc wrapper.
1198   _scratch_classes = (InstanceKlass**)
1199     os::malloc(sizeof(InstanceKlass*) * _class_count, mtClass);
1200   if (_scratch_classes == NULL) {
1201     return JVMTI_ERROR_OUT_OF_MEMORY;
1202   }
1203   // Zero initialize the _scratch_classes array.
1204   for (int i = 0; i &lt; _class_count; i++) {
1205     _scratch_classes[i] = NULL;
1206   }
1207 
1208   ResourceMark rm(THREAD);
1209 
1210   JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());
1211   // state can only be NULL if the current thread is exiting which
1212   // should not happen since we&#39;re trying to do a RedefineClasses
1213   guarantee(state != NULL, &quot;exiting thread calling load_new_class_versions&quot;);
1214   for (int i = 0; i &lt; _class_count; i++) {
1215     // Create HandleMark so that any handles created while loading new class
1216     // versions are deleted. Constant pools are deallocated while merging
1217     // constant pools
1218     HandleMark hm(THREAD);
1219     InstanceKlass* the_class = get_ik(_class_defs[i].klass);
1220     Symbol*  the_class_sym = the_class-&gt;name();
1221 
1222     log_debug(redefine, class, load)
1223       (&quot;loading name=%s kind=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
1224        the_class-&gt;external_name(), _class_load_kind, os::available_memory() &gt;&gt; 10);
1225 
1226     ClassFileStream st((u1*)_class_defs[i].class_bytes,
1227                        _class_defs[i].class_byte_count,
1228                        &quot;__VM_RedefineClasses__&quot;,
1229                        ClassFileStream::verify);
1230 
1231     // Parse the stream.
1232     Handle the_class_loader(THREAD, the_class-&gt;class_loader());
1233     Handle protection_domain(THREAD, the_class-&gt;protection_domain());
1234     // Set redefined class handle in JvmtiThreadState class.
1235     // This redefined class is sent to agent event handler for class file
1236     // load hook event.
1237     state-&gt;set_class_being_redefined(the_class, _class_load_kind);
1238 
1239     InstanceKlass* scratch_class = SystemDictionary::parse_stream(
1240                                                       the_class_sym,
1241                                                       the_class_loader,
1242                                                       protection_domain,
1243                                                       &amp;st,
1244                                                       THREAD);
1245     // Clear class_being_redefined just to be sure.
1246     state-&gt;clear_class_being_redefined();
1247 
1248     // TODO: if this is retransform, and nothing changed we can skip it
1249 
1250     // Need to clean up allocated InstanceKlass if there&#39;s an error so assign
1251     // the result here. Caller deallocates all the scratch classes in case of
1252     // an error.
1253     _scratch_classes[i] = scratch_class;
1254 
1255     if (HAS_PENDING_EXCEPTION) {
1256       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1257       log_info(redefine, class, load, exceptions)(&quot;parse_stream exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1258       CLEAR_PENDING_EXCEPTION;
1259 
1260       if (ex_name == vmSymbols::java_lang_UnsupportedClassVersionError()) {
1261         return JVMTI_ERROR_UNSUPPORTED_VERSION;
1262       } else if (ex_name == vmSymbols::java_lang_ClassFormatError()) {
1263         return JVMTI_ERROR_INVALID_CLASS_FORMAT;
1264       } else if (ex_name == vmSymbols::java_lang_ClassCircularityError()) {
1265         return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
1266       } else if (ex_name == vmSymbols::java_lang_NoClassDefFoundError()) {
1267         // The message will be &quot;XXX (wrong name: YYY)&quot;
1268         return JVMTI_ERROR_NAMES_DONT_MATCH;
1269       } else if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1270         return JVMTI_ERROR_OUT_OF_MEMORY;
1271       } else {  // Just in case more exceptions can be thrown..
1272         return JVMTI_ERROR_FAILS_VERIFICATION;
1273       }
1274     }
1275 
1276     // Ensure class is linked before redefine
1277     if (!the_class-&gt;is_linked()) {
1278       the_class-&gt;link_class(THREAD);
1279       if (HAS_PENDING_EXCEPTION) {
1280         Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1281         log_info(redefine, class, load, exceptions)(&quot;link_class exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1282         CLEAR_PENDING_EXCEPTION;
1283         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1284           return JVMTI_ERROR_OUT_OF_MEMORY;
1285         } else {
1286           return JVMTI_ERROR_INTERNAL;
1287         }
1288       }
1289     }
1290 
1291     // Do the validity checks in compare_and_normalize_class_versions()
1292     // before verifying the byte codes. By doing these checks first, we
1293     // limit the number of functions that require redirection from
1294     // the_class to scratch_class. In particular, we don&#39;t have to
1295     // modify JNI GetSuperclass() and thus won&#39;t change its performance.
1296     jvmtiError res = compare_and_normalize_class_versions(the_class,
1297                        scratch_class);
1298     if (res != JVMTI_ERROR_NONE) {
1299       return res;
1300     }
1301 
1302     // verify what the caller passed us
1303     {
1304       // The bug 6214132 caused the verification to fail.
1305       // Information about the_class and scratch_class is temporarily
1306       // recorded into jvmtiThreadState. This data is used to redirect
1307       // the_class to scratch_class in the JVM_* functions called by the
1308       // verifier. Please, refer to jvmtiThreadState.hpp for the detailed
1309       // description.
1310       RedefineVerifyMark rvm(the_class, scratch_class, state);
1311       Verifier::verify(scratch_class, true, THREAD);
1312     }
1313 
1314     if (HAS_PENDING_EXCEPTION) {
1315       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1316       log_info(redefine, class, load, exceptions)(&quot;verify_byte_codes exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1317       CLEAR_PENDING_EXCEPTION;
1318       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1319         return JVMTI_ERROR_OUT_OF_MEMORY;
1320       } else {
1321         // tell the caller the bytecodes are bad
1322         return JVMTI_ERROR_FAILS_VERIFICATION;
1323       }
1324     }
1325 
1326     res = merge_cp_and_rewrite(the_class, scratch_class, THREAD);
1327     if (HAS_PENDING_EXCEPTION) {
1328       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1329       log_info(redefine, class, load, exceptions)(&quot;merge_cp_and_rewrite exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1330       CLEAR_PENDING_EXCEPTION;
1331       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1332         return JVMTI_ERROR_OUT_OF_MEMORY;
1333       } else {
1334         return JVMTI_ERROR_INTERNAL;
1335       }
1336     }
1337 
1338     if (VerifyMergedCPBytecodes) {
1339       // verify what we have done during constant pool merging
1340       {
1341         RedefineVerifyMark rvm(the_class, scratch_class, state);
1342         Verifier::verify(scratch_class, true, THREAD);
1343       }
1344 
1345       if (HAS_PENDING_EXCEPTION) {
1346         Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1347         log_info(redefine, class, load, exceptions)
1348           (&quot;verify_byte_codes post merge-CP exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1349         CLEAR_PENDING_EXCEPTION;
1350         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1351           return JVMTI_ERROR_OUT_OF_MEMORY;
1352         } else {
1353           // tell the caller that constant pool merging screwed up
1354           return JVMTI_ERROR_INTERNAL;
1355         }
1356       }
1357     }
1358 
1359     Rewriter::rewrite(scratch_class, THREAD);
1360     if (!HAS_PENDING_EXCEPTION) {
1361       scratch_class-&gt;link_methods(THREAD);
1362     }
1363     if (HAS_PENDING_EXCEPTION) {
1364       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1365       log_info(redefine, class, load, exceptions)
1366         (&quot;Rewriter::rewrite or link_methods exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1367       CLEAR_PENDING_EXCEPTION;
1368       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1369         return JVMTI_ERROR_OUT_OF_MEMORY;
1370       } else {
1371         return JVMTI_ERROR_INTERNAL;
1372       }
1373     }
1374 
1375     log_debug(redefine, class, load)
1376       (&quot;loaded name=%s (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;, the_class-&gt;external_name(), os::available_memory() &gt;&gt; 10);
1377   }
1378 
1379   return JVMTI_ERROR_NONE;
1380 }
1381 
1382 
1383 // Map old_index to new_index as needed. scratch_cp is only needed
1384 // for log calls.
1385 void VM_RedefineClasses::map_index(const constantPoolHandle&amp; scratch_cp,
1386        int old_index, int new_index) {
1387   if (find_new_index(old_index) != 0) {
1388     // old_index is already mapped
1389     return;
1390   }
1391 
1392   if (old_index == new_index) {
1393     // no mapping is needed
1394     return;
1395   }
1396 
1397   _index_map_p-&gt;at_put(old_index, new_index);
1398   _index_map_count++;
1399 
1400   log_trace(redefine, class, constantpool)
1401     (&quot;mapped tag %d at index %d to %d&quot;, scratch_cp-&gt;tag_at(old_index).value(), old_index, new_index);
1402 } // end map_index()
1403 
1404 
1405 // Map old_index to new_index as needed.
1406 void VM_RedefineClasses::map_operand_index(int old_index, int new_index) {
1407   if (find_new_operand_index(old_index) != -1) {
1408     // old_index is already mapped
1409     return;
1410   }
1411 
1412   if (old_index == new_index) {
1413     // no mapping is needed
1414     return;
1415   }
1416 
1417   _operands_index_map_p-&gt;at_put(old_index, new_index);
1418   _operands_index_map_count++;
1419 
1420   log_trace(redefine, class, constantpool)(&quot;mapped bootstrap specifier at index %d to %d&quot;, old_index, new_index);
1421 } // end map_index()
1422 
1423 
1424 // Merge old_cp and scratch_cp and return the results of the merge via
1425 // merge_cp_p. The number of entries in *merge_cp_p is returned via
1426 // merge_cp_length_p. The entries in old_cp occupy the same locations
1427 // in *merge_cp_p. Also creates a map of indices from entries in
1428 // scratch_cp to the corresponding entry in *merge_cp_p. Index map
1429 // entries are only created for entries in scratch_cp that occupy a
1430 // different location in *merged_cp_p.
1431 bool VM_RedefineClasses::merge_constant_pools(const constantPoolHandle&amp; old_cp,
1432        const constantPoolHandle&amp; scratch_cp, constantPoolHandle *merge_cp_p,
1433        int *merge_cp_length_p, TRAPS) {
1434 
1435   if (merge_cp_p == NULL) {
1436     assert(false, &quot;caller must provide scratch constantPool&quot;);
1437     return false; // robustness
1438   }
1439   if (merge_cp_length_p == NULL) {
1440     assert(false, &quot;caller must provide scratch CP length&quot;);
1441     return false; // robustness
1442   }
1443   // Worst case we need old_cp-&gt;length() + scratch_cp()-&gt;length(),
1444   // but the caller might be smart so make sure we have at least
1445   // the minimum.
1446   if ((*merge_cp_p)-&gt;length() &lt; old_cp-&gt;length()) {
1447     assert(false, &quot;merge area too small&quot;);
1448     return false; // robustness
1449   }
1450 
1451   log_info(redefine, class, constantpool)(&quot;old_cp_len=%d, scratch_cp_len=%d&quot;, old_cp-&gt;length(), scratch_cp-&gt;length());
1452 
1453   {
1454     // Pass 0:
1455     // The old_cp is copied to *merge_cp_p; this means that any code
1456     // using old_cp does not have to change. This work looks like a
1457     // perfect fit for ConstantPool*::copy_cp_to(), but we need to
1458     // handle one special case:
1459     // - revert JVM_CONSTANT_Class to JVM_CONSTANT_UnresolvedClass
1460     // This will make verification happy.
1461 
1462     int old_i;  // index into old_cp
1463 
1464     // index zero (0) is not used in constantPools
1465     for (old_i = 1; old_i &lt; old_cp-&gt;length(); old_i++) {
1466       // leave debugging crumb
1467       jbyte old_tag = old_cp-&gt;tag_at(old_i).value();
1468       switch (old_tag) {
1469       case JVM_CONSTANT_Class:
1470       case JVM_CONSTANT_UnresolvedClass:
1471         // revert the copy to JVM_CONSTANT_UnresolvedClass
1472         // May be resolving while calling this so do the same for
1473         // JVM_CONSTANT_UnresolvedClass (klass_name_at() deals with transition)
1474         (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(old_i,
1475           old_cp-&gt;klass_name_index_at(old_i));
1476         break;
1477 
1478       case JVM_CONSTANT_Double:
1479       case JVM_CONSTANT_Long:
1480         // just copy the entry to *merge_cp_p, but double and long take
1481         // two constant pool entries
1482         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_0);
1483         old_i++;
1484         break;
1485 
1486       default:
1487         // just copy the entry to *merge_cp_p
1488         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_0);
1489         break;
1490       }
1491     } // end for each old_cp entry
1492 
1493     ConstantPool::copy_operands(old_cp, *merge_cp_p, CHECK_0);
1494     (*merge_cp_p)-&gt;extend_operands(scratch_cp, CHECK_0);
1495 
1496     // We don&#39;t need to sanity check that *merge_cp_length_p is within
1497     // *merge_cp_p bounds since we have the minimum on-entry check above.
1498     (*merge_cp_length_p) = old_i;
1499   }
1500 
1501   // merge_cp_len should be the same as old_cp-&gt;length() at this point
1502   // so this trace message is really a &quot;warm-and-breathing&quot; message.
1503   log_debug(redefine, class, constantpool)(&quot;after pass 0: merge_cp_len=%d&quot;, *merge_cp_length_p);
1504 
1505   int scratch_i;  // index into scratch_cp
1506   {
1507     // Pass 1a:
1508     // Compare scratch_cp entries to the old_cp entries that we have
1509     // already copied to *merge_cp_p. In this pass, we are eliminating
1510     // exact duplicates (matching entry at same index) so we only
1511     // compare entries in the common indice range.
1512     int increment = 1;
1513     int pass1a_length = MIN2(old_cp-&gt;length(), scratch_cp-&gt;length());
1514     for (scratch_i = 1; scratch_i &lt; pass1a_length; scratch_i += increment) {
1515       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1516       case JVM_CONSTANT_Double:
1517       case JVM_CONSTANT_Long:
1518         // double and long take two constant pool entries
1519         increment = 2;
1520         break;
1521 
1522       default:
1523         increment = 1;
1524         break;
1525       }
1526 
1527       bool match = scratch_cp-&gt;compare_entry_to(scratch_i, *merge_cp_p,
1528         scratch_i, CHECK_0);
1529       if (match) {
1530         // found a match at the same index so nothing more to do
1531         continue;
1532       } else if (is_unresolved_class_mismatch(scratch_cp, scratch_i,
1533                                               *merge_cp_p, scratch_i)) {
1534         // The mismatch in compare_entry_to() above is because of a
1535         // resolved versus unresolved class entry at the same index
1536         // with the same string value. Since Pass 0 reverted any
1537         // class entries to unresolved class entries in *merge_cp_p,
1538         // we go with the unresolved class entry.
1539         continue;
1540       }
1541 
1542       int found_i = scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p,
1543         CHECK_0);
1544       if (found_i != 0) {
1545         guarantee(found_i != scratch_i,
1546           &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
1547 
1548         // Found a matching entry somewhere else in *merge_cp_p so
1549         // just need a mapping entry.
1550         map_index(scratch_cp, scratch_i, found_i);
1551         continue;
1552       }
1553 
1554       // The find_matching_entry() call above could fail to find a match
1555       // due to a resolved versus unresolved class or string entry situation
1556       // like we solved above with the is_unresolved_*_mismatch() calls.
1557       // However, we would have to call is_unresolved_*_mismatch() over
1558       // all of *merge_cp_p (potentially) and that doesn&#39;t seem to be
1559       // worth the time.
1560 
1561       // No match found so we have to append this entry and any unique
1562       // referenced entries to *merge_cp_p.
1563       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
1564         CHECK_0);
1565     }
1566   }
1567 
1568   log_debug(redefine, class, constantpool)
1569     (&quot;after pass 1a: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1570      *merge_cp_length_p, scratch_i, _index_map_count);
1571 
1572   if (scratch_i &lt; scratch_cp-&gt;length()) {
1573     // Pass 1b:
1574     // old_cp is smaller than scratch_cp so there are entries in
1575     // scratch_cp that we have not yet processed. We take care of
1576     // those now.
1577     int increment = 1;
1578     for (; scratch_i &lt; scratch_cp-&gt;length(); scratch_i += increment) {
1579       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1580       case JVM_CONSTANT_Double:
1581       case JVM_CONSTANT_Long:
1582         // double and long take two constant pool entries
1583         increment = 2;
1584         break;
1585 
1586       default:
1587         increment = 1;
1588         break;
1589       }
1590 
1591       int found_i =
1592         scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p, CHECK_0);
1593       if (found_i != 0) {
1594         // Found a matching entry somewhere else in *merge_cp_p so
1595         // just need a mapping entry.
1596         map_index(scratch_cp, scratch_i, found_i);
1597         continue;
1598       }
1599 
1600       // No match found so we have to append this entry and any unique
1601       // referenced entries to *merge_cp_p.
1602       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
1603         CHECK_0);
1604     }
1605 
1606     log_debug(redefine, class, constantpool)
1607       (&quot;after pass 1b: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1608        *merge_cp_length_p, scratch_i, _index_map_count);
1609   }
1610   finalize_operands_merge(*merge_cp_p, THREAD);
1611 
1612   return true;
1613 } // end merge_constant_pools()
1614 
1615 
1616 // Scoped object to clean up the constant pool(s) created for merging
1617 class MergeCPCleaner {
1618   ClassLoaderData*   _loader_data;
1619   ConstantPool*      _cp;
1620   ConstantPool*      _scratch_cp;
1621  public:
1622   MergeCPCleaner(ClassLoaderData* loader_data, ConstantPool* merge_cp) :
1623                  _loader_data(loader_data), _cp(merge_cp), _scratch_cp(NULL) {}
1624   ~MergeCPCleaner() {
1625     _loader_data-&gt;add_to_deallocate_list(_cp);
1626     if (_scratch_cp != NULL) {
1627       _loader_data-&gt;add_to_deallocate_list(_scratch_cp);
1628     }
1629   }
1630   void add_scratch_cp(ConstantPool* scratch_cp) { _scratch_cp = scratch_cp; }
1631 };
1632 
1633 // Merge constant pools between the_class and scratch_class and
1634 // potentially rewrite bytecodes in scratch_class to use the merged
1635 // constant pool.
1636 jvmtiError VM_RedefineClasses::merge_cp_and_rewrite(
1637              InstanceKlass* the_class, InstanceKlass* scratch_class,
1638              TRAPS) {
1639   // worst case merged constant pool length is old and new combined
1640   int merge_cp_length = the_class-&gt;constants()-&gt;length()
1641         + scratch_class-&gt;constants()-&gt;length();
1642 
1643   // Constant pools are not easily reused so we allocate a new one
1644   // each time.
1645   // merge_cp is created unsafe for concurrent GC processing.  It
1646   // should be marked safe before discarding it. Even though
1647   // garbage,  if it crosses a card boundary, it may be scanned
1648   // in order to find the start of the first complete object on the card.
1649   ClassLoaderData* loader_data = the_class-&gt;class_loader_data();
1650   ConstantPool* merge_cp_oop =
1651     ConstantPool::allocate(loader_data,
1652                            merge_cp_length,
1653                            CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1654   MergeCPCleaner cp_cleaner(loader_data, merge_cp_oop);
1655 
1656   HandleMark hm(THREAD);  // make sure handles are cleared before
1657                           // MergeCPCleaner clears out merge_cp_oop
1658   constantPoolHandle merge_cp(THREAD, merge_cp_oop);
1659 
1660   // Get constants() from the old class because it could have been rewritten
1661   // while we were at a safepoint allocating a new constant pool.
1662   constantPoolHandle old_cp(THREAD, the_class-&gt;constants());
1663   constantPoolHandle scratch_cp(THREAD, scratch_class-&gt;constants());
1664 
1665   // If the length changed, the class was redefined out from under us. Return
1666   // an error.
1667   if (merge_cp_length != the_class-&gt;constants()-&gt;length()
1668          + scratch_class-&gt;constants()-&gt;length()) {
1669     return JVMTI_ERROR_INTERNAL;
1670   }
1671 
1672   // Update the version number of the constant pools (may keep scratch_cp)
1673   merge_cp-&gt;increment_and_save_version(old_cp-&gt;version());
1674   scratch_cp-&gt;increment_and_save_version(old_cp-&gt;version());
1675 
1676   ResourceMark rm(THREAD);
1677   _index_map_count = 0;
1678   _index_map_p = new intArray(scratch_cp-&gt;length(), scratch_cp-&gt;length(), -1);
1679 
1680   _operands_cur_length = ConstantPool::operand_array_length(old_cp-&gt;operands());
1681   _operands_index_map_count = 0;
1682   int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp-&gt;operands());
1683   _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);
1684 
1685   // reference to the cp holder is needed for copy_operands()
1686   merge_cp-&gt;set_pool_holder(scratch_class);
1687   bool result = merge_constant_pools(old_cp, scratch_cp, &amp;merge_cp,
1688                   &amp;merge_cp_length, THREAD);
1689   merge_cp-&gt;set_pool_holder(NULL);
1690 
1691   if (!result) {
1692     // The merge can fail due to memory allocation failure or due
1693     // to robustness checks.
1694     return JVMTI_ERROR_INTERNAL;
1695   }
1696 
1697   if (old_cp-&gt;has_dynamic_constant()) {
1698     merge_cp-&gt;set_has_dynamic_constant();
1699     scratch_cp-&gt;set_has_dynamic_constant();
1700   }
1701 
1702   log_info(redefine, class, constantpool)(&quot;merge_cp_len=%d, index_map_len=%d&quot;, merge_cp_length, _index_map_count);
1703 
1704   if (_index_map_count == 0) {
1705     // there is nothing to map between the new and merged constant pools
1706 
1707     if (old_cp-&gt;length() == scratch_cp-&gt;length()) {
1708       // The old and new constant pools are the same length and the
1709       // index map is empty. This means that the three constant pools
1710       // are equivalent (but not the same). Unfortunately, the new
1711       // constant pool has not gone through link resolution nor have
1712       // the new class bytecodes gone through constant pool cache
1713       // rewriting so we can&#39;t use the old constant pool with the new
1714       // class.
1715 
1716       // toss the merged constant pool at return
1717     } else if (old_cp-&gt;length() &lt; scratch_cp-&gt;length()) {
1718       // The old constant pool has fewer entries than the new constant
1719       // pool and the index map is empty. This means the new constant
1720       // pool is a superset of the old constant pool. However, the old
1721       // class bytecodes have already gone through constant pool cache
1722       // rewriting so we can&#39;t use the new constant pool with the old
1723       // class.
1724 
1725       // toss the merged constant pool at return
1726     } else {
1727       // The old constant pool has more entries than the new constant
1728       // pool and the index map is empty. This means that both the old
1729       // and merged constant pools are supersets of the new constant
1730       // pool.
1731 
1732       // Replace the new constant pool with a shrunken copy of the
1733       // merged constant pool
1734       set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1735                             CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1736       // The new constant pool replaces scratch_cp so have cleaner clean it up.
1737       // It can&#39;t be cleaned up while there are handles to it.
1738       cp_cleaner.add_scratch_cp(scratch_cp());
1739     }
1740   } else {
1741     if (log_is_enabled(Trace, redefine, class, constantpool)) {
1742       // don&#39;t want to loop unless we are tracing
1743       int count = 0;
1744       for (int i = 1; i &lt; _index_map_p-&gt;length(); i++) {
1745         int value = _index_map_p-&gt;at(i);
1746 
1747         if (value != -1) {
1748           log_trace(redefine, class, constantpool)(&quot;index_map[%d]: old=%d new=%d&quot;, count, i, value);
1749           count++;
1750         }
1751       }
1752     }
1753 
1754     // We have entries mapped between the new and merged constant pools
1755     // so we have to rewrite some constant pool references.
1756     if (!rewrite_cp_refs(scratch_class, THREAD)) {
1757       return JVMTI_ERROR_INTERNAL;
1758     }
1759 
1760     // Replace the new constant pool with a shrunken copy of the
1761     // merged constant pool so now the rewritten bytecodes have
1762     // valid references; the previous new constant pool will get
1763     // GCed.
1764     set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1765                           CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1766     // The new constant pool replaces scratch_cp so have cleaner clean it up.
1767     // It can&#39;t be cleaned up while there are handles to it.
1768     cp_cleaner.add_scratch_cp(scratch_cp());
1769   }
1770 
1771   return JVMTI_ERROR_NONE;
1772 } // end merge_cp_and_rewrite()
1773 
1774 
1775 // Rewrite constant pool references in klass scratch_class.
1776 bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class,
1777        TRAPS) {
1778 
1779   // rewrite constant pool references in the nest attributes:
1780   if (!rewrite_cp_refs_in_nest_attributes(scratch_class)) {
1781     // propagate failure back to caller
1782     return false;
1783   }
1784 
1785   // rewrite constant pool references in the Record attribute:
1786   if (!rewrite_cp_refs_in_record_attribute(scratch_class, THREAD)) {
1787     // propagate failure back to caller
1788     return false;
1789   }
1790 
1791   // rewrite constant pool references in the methods:
1792   if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {
1793     // propagate failure back to caller
1794     return false;
1795   }
1796 
1797   // rewrite constant pool references in the class_annotations:
1798   if (!rewrite_cp_refs_in_class_annotations(scratch_class, THREAD)) {
1799     // propagate failure back to caller
1800     return false;
1801   }
1802 
1803   // rewrite constant pool references in the fields_annotations:
1804   if (!rewrite_cp_refs_in_fields_annotations(scratch_class, THREAD)) {
1805     // propagate failure back to caller
1806     return false;
1807   }
1808 
1809   // rewrite constant pool references in the methods_annotations:
1810   if (!rewrite_cp_refs_in_methods_annotations(scratch_class, THREAD)) {
1811     // propagate failure back to caller
1812     return false;
1813   }
1814 
1815   // rewrite constant pool references in the methods_parameter_annotations:
1816   if (!rewrite_cp_refs_in_methods_parameter_annotations(scratch_class,
1817          THREAD)) {
1818     // propagate failure back to caller
1819     return false;
1820   }
1821 
1822   // rewrite constant pool references in the methods_default_annotations:
1823   if (!rewrite_cp_refs_in_methods_default_annotations(scratch_class,
1824          THREAD)) {
1825     // propagate failure back to caller
1826     return false;
1827   }
1828 
1829   // rewrite constant pool references in the class_type_annotations:
1830   if (!rewrite_cp_refs_in_class_type_annotations(scratch_class, THREAD)) {
1831     // propagate failure back to caller
1832     return false;
1833   }
1834 
1835   // rewrite constant pool references in the fields_type_annotations:
1836   if (!rewrite_cp_refs_in_fields_type_annotations(scratch_class, THREAD)) {
1837     // propagate failure back to caller
1838     return false;
1839   }
1840 
1841   // rewrite constant pool references in the methods_type_annotations:
1842   if (!rewrite_cp_refs_in_methods_type_annotations(scratch_class, THREAD)) {
1843     // propagate failure back to caller
1844     return false;
1845   }
1846 
1847   // There can be type annotations in the Code part of a method_info attribute.
1848   // These annotations are not accessible, even by reflection.
1849   // Currently they are not even parsed by the ClassFileParser.
1850   // If runtime access is added they will also need to be rewritten.
1851 
1852   // rewrite source file name index:
1853   u2 source_file_name_idx = scratch_class-&gt;source_file_name_index();
1854   if (source_file_name_idx != 0) {
1855     u2 new_source_file_name_idx = find_new_index(source_file_name_idx);
1856     if (new_source_file_name_idx != 0) {
1857       scratch_class-&gt;set_source_file_name_index(new_source_file_name_idx);
1858     }
1859   }
1860 
1861   // rewrite class generic signature index:
1862   u2 generic_signature_index = scratch_class-&gt;generic_signature_index();
1863   if (generic_signature_index != 0) {
1864     u2 new_generic_signature_index = find_new_index(generic_signature_index);
1865     if (new_generic_signature_index != 0) {
1866       scratch_class-&gt;set_generic_signature_index(new_generic_signature_index);
1867     }
1868   }
1869 
1870   return true;
1871 } // end rewrite_cp_refs()
1872 
1873 // Rewrite constant pool references in the NestHost and NestMembers attributes.
1874 bool VM_RedefineClasses::rewrite_cp_refs_in_nest_attributes(
1875        InstanceKlass* scratch_class) {
1876 
1877   u2 cp_index = scratch_class-&gt;nest_host_index();
1878   if (cp_index != 0) {
1879     scratch_class-&gt;set_nest_host_index(find_new_index(cp_index));
1880   }
1881   Array&lt;u2&gt;* nest_members = scratch_class-&gt;nest_members();
1882   for (int i = 0; i &lt; nest_members-&gt;length(); i++) {
1883     u2 cp_index = nest_members-&gt;at(i);
1884     nest_members-&gt;at_put(i, find_new_index(cp_index));
1885   }
1886   return true;
1887 }
1888 
1889 // Rewrite constant pool references in the Record attribute.
1890 bool VM_RedefineClasses::rewrite_cp_refs_in_record_attribute(
1891        InstanceKlass* scratch_class, TRAPS) {
1892   Array&lt;RecordComponent*&gt;* components = scratch_class-&gt;record_components();
1893   if (components != NULL) {
1894     for (int i = 0; i &lt; components-&gt;length(); i++) {
1895       RecordComponent* component = components-&gt;at(i);
1896       u2 cp_index = component-&gt;name_index();
1897       component-&gt;set_name_index(find_new_index(cp_index));
1898       cp_index = component-&gt;descriptor_index();
1899       component-&gt;set_descriptor_index(find_new_index(cp_index));
1900       cp_index = component-&gt;generic_signature_index();
1901       if (cp_index != 0) {
1902         component-&gt;set_generic_signature_index(find_new_index(cp_index));
1903       }
1904 
1905       AnnotationArray* annotations = component-&gt;annotations();
1906       if (annotations != NULL &amp;&amp; annotations-&gt;length() != 0) {
1907         int byte_i = 0;  // byte index into annotations
1908         if (!rewrite_cp_refs_in_annotations_typeArray(annotations, byte_i, THREAD)) {
1909           log_debug(redefine, class, annotation)(&quot;bad record_component_annotations at %d&quot;, i);
1910           // propagate failure back to caller
1911           return false;
1912         }
1913       }
1914 
1915       AnnotationArray* type_annotations = component-&gt;type_annotations();
1916       if (type_annotations != NULL &amp;&amp; type_annotations-&gt;length() != 0) {
1917         int byte_i = 0;  // byte index into annotations
1918         if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i, THREAD)) {
1919           log_debug(redefine, class, annotation)(&quot;bad record_component_type_annotations at %d&quot;, i);
1920           // propagate failure back to caller
1921           return false;
1922         }
1923       }
1924     }
1925   }
1926   return true;
1927 }
1928 
1929 // Rewrite constant pool references in the methods.
1930 bool VM_RedefineClasses::rewrite_cp_refs_in_methods(
1931        InstanceKlass* scratch_class, TRAPS) {
1932 
1933   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
1934 
1935   if (methods == NULL || methods-&gt;length() == 0) {
1936     // no methods so nothing to do
1937     return true;
1938   }
1939 
1940   // rewrite constant pool references in the methods:
1941   for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
1942     methodHandle method(THREAD, methods-&gt;at(i));
1943     methodHandle new_method;
1944     rewrite_cp_refs_in_method(method, &amp;new_method, THREAD);
1945     if (!new_method.is_null()) {
1946       // the method has been replaced so save the new method version
1947       // even in the case of an exception.  original method is on the
1948       // deallocation list.
1949       methods-&gt;at_put(i, new_method());
1950     }
1951     if (HAS_PENDING_EXCEPTION) {
1952       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1953       log_info(redefine, class, load, exceptions)(&quot;rewrite_cp_refs_in_method exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1954       // Need to clear pending exception here as the super caller sets
1955       // the JVMTI_ERROR_INTERNAL if the returned value is false.
1956       CLEAR_PENDING_EXCEPTION;
1957       return false;
1958     }
1959   }
1960 
1961   return true;
1962 }
1963 
1964 
1965 // Rewrite constant pool references in the specific method. This code
1966 // was adapted from Rewriter::rewrite_method().
1967 void VM_RedefineClasses::rewrite_cp_refs_in_method(methodHandle method,
1968        methodHandle *new_method_p, TRAPS) {
1969 
1970   *new_method_p = methodHandle();  // default is no new method
1971 
1972   // We cache a pointer to the bytecodes here in code_base. If GC
1973   // moves the Method*, then the bytecodes will also move which
1974   // will likely cause a crash. We create a NoSafepointVerifier
1975   // object to detect whether we pass a possible safepoint in this
1976   // code block.
1977   NoSafepointVerifier nsv;
1978 
1979   // Bytecodes and their length
1980   address code_base = method-&gt;code_base();
1981   int code_length = method-&gt;code_size();
1982 
1983   int bc_length;
1984   for (int bci = 0; bci &lt; code_length; bci += bc_length) {
1985     address bcp = code_base + bci;
1986     Bytecodes::Code c = (Bytecodes::Code)(*bcp);
1987 
1988     bc_length = Bytecodes::length_for(c);
1989     if (bc_length == 0) {
1990       // More complicated bytecodes report a length of zero so
1991       // we have to try again a slightly different way.
1992       bc_length = Bytecodes::length_at(method(), bcp);
1993     }
1994 
1995     assert(bc_length != 0, &quot;impossible bytecode length&quot;);
1996 
1997     switch (c) {
1998       case Bytecodes::_ldc:
1999       {
2000         int cp_index = *(bcp + 1);
2001         int new_index = find_new_index(cp_index);
2002 
2003         if (StressLdcRewrite &amp;&amp; new_index == 0) {
2004           // If we are stressing ldc -&gt; ldc_w rewriting, then we
2005           // always need a new_index value.
2006           new_index = cp_index;
2007         }
2008         if (new_index != 0) {
2009           // the original index is mapped so we have more work to do
2010           if (!StressLdcRewrite &amp;&amp; new_index &lt;= max_jubyte) {
2011             // The new value can still use ldc instead of ldc_w
2012             // unless we are trying to stress ldc -&gt; ldc_w rewriting
2013             log_trace(redefine, class, constantpool)
2014               (&quot;%s@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c), p2i(bcp), cp_index, new_index);
2015             *(bcp + 1) = new_index;
2016           } else {
2017             log_trace(redefine, class, constantpool)
2018               (&quot;%s-&gt;ldc_w@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c), p2i(bcp), cp_index, new_index);
2019             // the new value needs ldc_w instead of ldc
2020             u_char inst_buffer[4]; // max instruction size is 4 bytes
2021             bcp = (address)inst_buffer;
2022             // construct new instruction sequence
2023             *bcp = Bytecodes::_ldc_w;
2024             bcp++;
2025             // Rewriter::rewrite_method() does not rewrite ldc -&gt; ldc_w.
2026             // See comment below for difference between put_Java_u2()
2027             // and put_native_u2().
2028             Bytes::put_Java_u2(bcp, new_index);
2029 
2030             Relocator rc(method, NULL /* no RelocatorListener needed */);
2031             methodHandle m;
2032             {
2033               PauseNoSafepointVerifier pnsv(&amp;nsv);
2034 
2035               // ldc is 2 bytes and ldc_w is 3 bytes
2036               m = rc.insert_space_at(bci, 3, inst_buffer, CHECK);
2037             }
2038 
2039             // return the new method so that the caller can update
2040             // the containing class
2041             *new_method_p = method = m;
2042             // switch our bytecode processing loop from the old method
2043             // to the new method
2044             code_base = method-&gt;code_base();
2045             code_length = method-&gt;code_size();
2046             bcp = code_base + bci;
2047             c = (Bytecodes::Code)(*bcp);
2048             bc_length = Bytecodes::length_for(c);
2049             assert(bc_length != 0, &quot;sanity check&quot;);
2050           } // end we need ldc_w instead of ldc
2051         } // end if there is a mapped index
2052       } break;
2053 
2054       // these bytecodes have a two-byte constant pool index
2055       case Bytecodes::_anewarray      : // fall through
2056       case Bytecodes::_checkcast      : // fall through
2057       case Bytecodes::_getfield       : // fall through
2058       case Bytecodes::_getstatic      : // fall through
2059       case Bytecodes::_instanceof     : // fall through
2060       case Bytecodes::_invokedynamic  : // fall through
2061       case Bytecodes::_invokeinterface: // fall through
2062       case Bytecodes::_invokespecial  : // fall through
2063       case Bytecodes::_invokestatic   : // fall through
2064       case Bytecodes::_invokevirtual  : // fall through
2065       case Bytecodes::_ldc_w          : // fall through
2066       case Bytecodes::_ldc2_w         : // fall through
2067       case Bytecodes::_multianewarray : // fall through
2068       case Bytecodes::_new            : // fall through
2069       case Bytecodes::_putfield       : // fall through
2070       case Bytecodes::_putstatic      :
2071       {
2072         address p = bcp + 1;
2073         int cp_index = Bytes::get_Java_u2(p);
2074         int new_index = find_new_index(cp_index);
2075         if (new_index != 0) {
2076           // the original index is mapped so update w/ new value
2077           log_trace(redefine, class, constantpool)
2078             (&quot;%s@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c),p2i(bcp), cp_index, new_index);
2079           // Rewriter::rewrite_method() uses put_native_u2() in this
2080           // situation because it is reusing the constant pool index
2081           // location for a native index into the ConstantPoolCache.
2082           // Since we are updating the constant pool index prior to
2083           // verification and ConstantPoolCache initialization, we
2084           // need to keep the new index in Java byte order.
2085           Bytes::put_Java_u2(p, new_index);
2086         }
2087       } break;
2088       default:
2089         break;
2090     }
2091   } // end for each bytecode
2092 
2093   // We also need to rewrite the parameter name indexes, if there is
2094   // method parameter data present
2095   if(method-&gt;has_method_parameters()) {
2096     const int len = method-&gt;method_parameters_length();
2097     MethodParametersElement* elem = method-&gt;method_parameters_start();
2098 
2099     for (int i = 0; i &lt; len; i++) {
2100       const u2 cp_index = elem[i].name_cp_index;
2101       const u2 new_cp_index = find_new_index(cp_index);
2102       if (new_cp_index != 0) {
2103         elem[i].name_cp_index = new_cp_index;
2104       }
2105     }
2106   }
2107 } // end rewrite_cp_refs_in_method()
2108 
2109 
2110 // Rewrite constant pool references in the class_annotations field.
2111 bool VM_RedefineClasses::rewrite_cp_refs_in_class_annotations(
2112        InstanceKlass* scratch_class, TRAPS) {
2113 
2114   AnnotationArray* class_annotations = scratch_class-&gt;class_annotations();
2115   if (class_annotations == NULL || class_annotations-&gt;length() == 0) {
2116     // no class_annotations so nothing to do
2117     return true;
2118   }
2119 
2120   log_debug(redefine, class, annotation)(&quot;class_annotations length=%d&quot;, class_annotations-&gt;length());
2121 
2122   int byte_i = 0;  // byte index into class_annotations
2123   return rewrite_cp_refs_in_annotations_typeArray(class_annotations, byte_i,
2124            THREAD);
2125 }
2126 
2127 
2128 // Rewrite constant pool references in an annotations typeArray. This
2129 // &quot;structure&quot; is adapted from the RuntimeVisibleAnnotations_attribute
2130 // that is described in section 4.8.15 of the 2nd-edition of the VM spec:
2131 //
2132 // annotations_typeArray {
2133 //   u2 num_annotations;
2134 //   annotation annotations[num_annotations];
2135 // }
2136 //
2137 bool VM_RedefineClasses::rewrite_cp_refs_in_annotations_typeArray(
2138        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2139 
2140   if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2141     // not enough room for num_annotations field
2142     log_debug(redefine, class, annotation)(&quot;length() is too small for num_annotations field&quot;);
2143     return false;
2144   }
2145 
2146   u2 num_annotations = Bytes::get_Java_u2((address)
2147                          annotations_typeArray-&gt;adr_at(byte_i_ref));
2148   byte_i_ref += 2;
2149 
2150   log_debug(redefine, class, annotation)(&quot;num_annotations=%d&quot;, num_annotations);
2151 
2152   int calc_num_annotations = 0;
2153   for (; calc_num_annotations &lt; num_annotations; calc_num_annotations++) {
2154     if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2155            byte_i_ref, THREAD)) {
2156       log_debug(redefine, class, annotation)(&quot;bad annotation_struct at %d&quot;, calc_num_annotations);
2157       // propagate failure back to caller
2158       return false;
2159     }
2160   }
2161   assert(num_annotations == calc_num_annotations, &quot;sanity check&quot;);
2162 
2163   return true;
2164 } // end rewrite_cp_refs_in_annotations_typeArray()
2165 
2166 
2167 // Rewrite constant pool references in the annotation struct portion of
2168 // an annotations_typeArray. This &quot;structure&quot; is from section 4.8.15 of
2169 // the 2nd-edition of the VM spec:
2170 //
2171 // struct annotation {
2172 //   u2 type_index;
2173 //   u2 num_element_value_pairs;
2174 //   {
2175 //     u2 element_name_index;
2176 //     element_value value;
2177 //   } element_value_pairs[num_element_value_pairs];
2178 // }
2179 //
2180 bool VM_RedefineClasses::rewrite_cp_refs_in_annotation_struct(
2181        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2182   if ((byte_i_ref + 2 + 2) &gt; annotations_typeArray-&gt;length()) {
2183     // not enough room for smallest annotation_struct
2184     log_debug(redefine, class, annotation)(&quot;length() is too small for annotation_struct&quot;);
2185     return false;
2186   }
2187 
2188   u2 type_index = rewrite_cp_ref_in_annotation_data(annotations_typeArray,
2189                     byte_i_ref, &quot;type_index&quot;, THREAD);
2190 
2191   u2 num_element_value_pairs = Bytes::get_Java_u2((address)
2192                                  annotations_typeArray-&gt;adr_at(byte_i_ref));
2193   byte_i_ref += 2;
2194 
2195   log_debug(redefine, class, annotation)
2196     (&quot;type_index=%d  num_element_value_pairs=%d&quot;, type_index, num_element_value_pairs);
2197 
2198   int calc_num_element_value_pairs = 0;
2199   for (; calc_num_element_value_pairs &lt; num_element_value_pairs;
2200        calc_num_element_value_pairs++) {
2201     if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2202       // not enough room for another element_name_index, let alone
2203       // the rest of another component
2204       log_debug(redefine, class, annotation)(&quot;length() is too small for element_name_index&quot;);
2205       return false;
2206     }
2207 
2208     u2 element_name_index = rewrite_cp_ref_in_annotation_data(
2209                               annotations_typeArray, byte_i_ref,
2210                               &quot;element_name_index&quot;, THREAD);
2211 
2212     log_debug(redefine, class, annotation)(&quot;element_name_index=%d&quot;, element_name_index);
2213 
2214     if (!rewrite_cp_refs_in_element_value(annotations_typeArray,
2215            byte_i_ref, THREAD)) {
2216       log_debug(redefine, class, annotation)(&quot;bad element_value at %d&quot;, calc_num_element_value_pairs);
2217       // propagate failure back to caller
2218       return false;
2219     }
2220   } // end for each component
2221   assert(num_element_value_pairs == calc_num_element_value_pairs,
2222     &quot;sanity check&quot;);
2223 
2224   return true;
2225 } // end rewrite_cp_refs_in_annotation_struct()
2226 
2227 
2228 // Rewrite a constant pool reference at the current position in
2229 // annotations_typeArray if needed. Returns the original constant
2230 // pool reference if a rewrite was not needed or the new constant
2231 // pool reference if a rewrite was needed.
2232 u2 VM_RedefineClasses::rewrite_cp_ref_in_annotation_data(
2233      AnnotationArray* annotations_typeArray, int &amp;byte_i_ref,
2234      const char * trace_mesg, TRAPS) {
2235 
2236   address cp_index_addr = (address)
2237     annotations_typeArray-&gt;adr_at(byte_i_ref);
2238   u2 old_cp_index = Bytes::get_Java_u2(cp_index_addr);
2239   u2 new_cp_index = find_new_index(old_cp_index);
2240   if (new_cp_index != 0) {
2241     log_debug(redefine, class, annotation)(&quot;mapped old %s=%d&quot;, trace_mesg, old_cp_index);
2242     Bytes::put_Java_u2(cp_index_addr, new_cp_index);
2243     old_cp_index = new_cp_index;
2244   }
2245   byte_i_ref += 2;
2246   return old_cp_index;
2247 }
2248 
2249 
2250 // Rewrite constant pool references in the element_value portion of an
2251 // annotations_typeArray. This &quot;structure&quot; is from section 4.8.15.1 of
2252 // the 2nd-edition of the VM spec:
2253 //
2254 // struct element_value {
2255 //   u1 tag;
2256 //   union {
2257 //     u2 const_value_index;
2258 //     {
2259 //       u2 type_name_index;
2260 //       u2 const_name_index;
2261 //     } enum_const_value;
2262 //     u2 class_info_index;
2263 //     annotation annotation_value;
2264 //     struct {
2265 //       u2 num_values;
2266 //       element_value values[num_values];
2267 //     } array_value;
2268 //   } value;
2269 // }
2270 //
2271 bool VM_RedefineClasses::rewrite_cp_refs_in_element_value(
2272        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2273 
2274   if ((byte_i_ref + 1) &gt; annotations_typeArray-&gt;length()) {
2275     // not enough room for a tag let alone the rest of an element_value
2276     log_debug(redefine, class, annotation)(&quot;length() is too small for a tag&quot;);
2277     return false;
2278   }
2279 
2280   u1 tag = annotations_typeArray-&gt;at(byte_i_ref);
2281   byte_i_ref++;
2282   log_debug(redefine, class, annotation)(&quot;tag=&#39;%c&#39;&quot;, tag);
2283 
2284   switch (tag) {
2285     // These BaseType tag values are from Table 4.2 in VM spec:
2286     case JVM_SIGNATURE_BYTE:
2287     case JVM_SIGNATURE_CHAR:
2288     case JVM_SIGNATURE_DOUBLE:
2289     case JVM_SIGNATURE_FLOAT:
2290     case JVM_SIGNATURE_INT:
2291     case JVM_SIGNATURE_LONG:
2292     case JVM_SIGNATURE_SHORT:
2293     case JVM_SIGNATURE_BOOLEAN:
2294 
2295     // The remaining tag values are from Table 4.8 in the 2nd-edition of
2296     // the VM spec:
2297     case &#39;s&#39;:
2298     {
2299       // For the above tag values (including the BaseType values),
2300       // value.const_value_index is right union field.
2301 
2302       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2303         // not enough room for a const_value_index
2304         log_debug(redefine, class, annotation)(&quot;length() is too small for a const_value_index&quot;);
2305         return false;
2306       }
2307 
2308       u2 const_value_index = rewrite_cp_ref_in_annotation_data(
2309                                annotations_typeArray, byte_i_ref,
2310                                &quot;const_value_index&quot;, THREAD);
2311 
2312       log_debug(redefine, class, annotation)(&quot;const_value_index=%d&quot;, const_value_index);
2313     } break;
2314 
2315     case &#39;e&#39;:
2316     {
2317       // for the above tag value, value.enum_const_value is right union field
2318 
2319       if ((byte_i_ref + 4) &gt; annotations_typeArray-&gt;length()) {
2320         // not enough room for a enum_const_value
2321         log_debug(redefine, class, annotation)(&quot;length() is too small for a enum_const_value&quot;);
2322         return false;
2323       }
2324 
2325       u2 type_name_index = rewrite_cp_ref_in_annotation_data(
2326                              annotations_typeArray, byte_i_ref,
2327                              &quot;type_name_index&quot;, THREAD);
2328 
2329       u2 const_name_index = rewrite_cp_ref_in_annotation_data(
2330                               annotations_typeArray, byte_i_ref,
2331                               &quot;const_name_index&quot;, THREAD);
2332 
2333       log_debug(redefine, class, annotation)
2334         (&quot;type_name_index=%d  const_name_index=%d&quot;, type_name_index, const_name_index);
2335     } break;
2336 
2337     case &#39;c&#39;:
2338     {
2339       // for the above tag value, value.class_info_index is right union field
2340 
2341       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2342         // not enough room for a class_info_index
2343         log_debug(redefine, class, annotation)(&quot;length() is too small for a class_info_index&quot;);
2344         return false;
2345       }
2346 
2347       u2 class_info_index = rewrite_cp_ref_in_annotation_data(
2348                               annotations_typeArray, byte_i_ref,
2349                               &quot;class_info_index&quot;, THREAD);
2350 
2351       log_debug(redefine, class, annotation)(&quot;class_info_index=%d&quot;, class_info_index);
2352     } break;
2353 
2354     case &#39;@&#39;:
2355       // For the above tag value, value.attr_value is the right union
2356       // field. This is a nested annotation.
2357       if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2358              byte_i_ref, THREAD)) {
2359         // propagate failure back to caller
2360         return false;
2361       }
2362       break;
2363 
2364     case JVM_SIGNATURE_ARRAY:
2365     {
2366       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2367         // not enough room for a num_values field
2368         log_debug(redefine, class, annotation)(&quot;length() is too small for a num_values field&quot;);
2369         return false;
2370       }
2371 
2372       // For the above tag value, value.array_value is the right union
2373       // field. This is an array of nested element_value.
2374       u2 num_values = Bytes::get_Java_u2((address)
2375                         annotations_typeArray-&gt;adr_at(byte_i_ref));
2376       byte_i_ref += 2;
2377       log_debug(redefine, class, annotation)(&quot;num_values=%d&quot;, num_values);
2378 
2379       int calc_num_values = 0;
2380       for (; calc_num_values &lt; num_values; calc_num_values++) {
2381         if (!rewrite_cp_refs_in_element_value(
2382                annotations_typeArray, byte_i_ref, THREAD)) {
2383           log_debug(redefine, class, annotation)(&quot;bad nested element_value at %d&quot;, calc_num_values);
2384           // propagate failure back to caller
2385           return false;
2386         }
2387       }
2388       assert(num_values == calc_num_values, &quot;sanity check&quot;);
2389     } break;
2390 
2391     default:
2392       log_debug(redefine, class, annotation)(&quot;bad tag=0x%x&quot;, tag);
2393       return false;
2394   } // end decode tag field
2395 
2396   return true;
2397 } // end rewrite_cp_refs_in_element_value()
2398 
2399 
2400 // Rewrite constant pool references in a fields_annotations field.
2401 bool VM_RedefineClasses::rewrite_cp_refs_in_fields_annotations(
2402        InstanceKlass* scratch_class, TRAPS) {
2403 
2404   Array&lt;AnnotationArray*&gt;* fields_annotations = scratch_class-&gt;fields_annotations();
2405 
2406   if (fields_annotations == NULL || fields_annotations-&gt;length() == 0) {
2407     // no fields_annotations so nothing to do
2408     return true;
2409   }
2410 
2411   log_debug(redefine, class, annotation)(&quot;fields_annotations length=%d&quot;, fields_annotations-&gt;length());
2412 
2413   for (int i = 0; i &lt; fields_annotations-&gt;length(); i++) {
2414     AnnotationArray* field_annotations = fields_annotations-&gt;at(i);
2415     if (field_annotations == NULL || field_annotations-&gt;length() == 0) {
2416       // this field does not have any annotations so skip it
2417       continue;
2418     }
2419 
2420     int byte_i = 0;  // byte index into field_annotations
2421     if (!rewrite_cp_refs_in_annotations_typeArray(field_annotations, byte_i,
2422            THREAD)) {
2423       log_debug(redefine, class, annotation)(&quot;bad field_annotations at %d&quot;, i);
2424       // propagate failure back to caller
2425       return false;
2426     }
2427   }
2428 
2429   return true;
2430 } // end rewrite_cp_refs_in_fields_annotations()
2431 
2432 
2433 // Rewrite constant pool references in a methods_annotations field.
2434 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_annotations(
2435        InstanceKlass* scratch_class, TRAPS) {
2436 
2437   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2438     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2439     AnnotationArray* method_annotations = m-&gt;constMethod()-&gt;method_annotations();
2440 
2441     if (method_annotations == NULL || method_annotations-&gt;length() == 0) {
2442       // this method does not have any annotations so skip it
2443       continue;
2444     }
2445 
2446     int byte_i = 0;  // byte index into method_annotations
2447     if (!rewrite_cp_refs_in_annotations_typeArray(method_annotations, byte_i,
2448            THREAD)) {
2449       log_debug(redefine, class, annotation)(&quot;bad method_annotations at %d&quot;, i);
2450       // propagate failure back to caller
2451       return false;
2452     }
2453   }
2454 
2455   return true;
2456 } // end rewrite_cp_refs_in_methods_annotations()
2457 
2458 
2459 // Rewrite constant pool references in a methods_parameter_annotations
2460 // field. This &quot;structure&quot; is adapted from the
2461 // RuntimeVisibleParameterAnnotations_attribute described in section
2462 // 4.8.17 of the 2nd-edition of the VM spec:
2463 //
2464 // methods_parameter_annotations_typeArray {
2465 //   u1 num_parameters;
2466 //   {
2467 //     u2 num_annotations;
2468 //     annotation annotations[num_annotations];
2469 //   } parameter_annotations[num_parameters];
2470 // }
2471 //
2472 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_parameter_annotations(
2473        InstanceKlass* scratch_class, TRAPS) {
2474 
2475   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2476     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2477     AnnotationArray* method_parameter_annotations = m-&gt;constMethod()-&gt;parameter_annotations();
2478     if (method_parameter_annotations == NULL
2479         || method_parameter_annotations-&gt;length() == 0) {
2480       // this method does not have any parameter annotations so skip it
2481       continue;
2482     }
2483 
2484     if (method_parameter_annotations-&gt;length() &lt; 1) {
2485       // not enough room for a num_parameters field
2486       log_debug(redefine, class, annotation)(&quot;length() is too small for a num_parameters field at %d&quot;, i);
2487       return false;
2488     }
2489 
2490     int byte_i = 0;  // byte index into method_parameter_annotations
2491 
2492     u1 num_parameters = method_parameter_annotations-&gt;at(byte_i);
2493     byte_i++;
2494 
2495     log_debug(redefine, class, annotation)(&quot;num_parameters=%d&quot;, num_parameters);
2496 
2497     int calc_num_parameters = 0;
2498     for (; calc_num_parameters &lt; num_parameters; calc_num_parameters++) {
2499       if (!rewrite_cp_refs_in_annotations_typeArray(
2500              method_parameter_annotations, byte_i, THREAD)) {
2501         log_debug(redefine, class, annotation)(&quot;bad method_parameter_annotations at %d&quot;, calc_num_parameters);
2502         // propagate failure back to caller
2503         return false;
2504       }
2505     }
2506     assert(num_parameters == calc_num_parameters, &quot;sanity check&quot;);
2507   }
2508 
2509   return true;
2510 } // end rewrite_cp_refs_in_methods_parameter_annotations()
2511 
2512 
2513 // Rewrite constant pool references in a methods_default_annotations
2514 // field. This &quot;structure&quot; is adapted from the AnnotationDefault_attribute
2515 // that is described in section 4.8.19 of the 2nd-edition of the VM spec:
2516 //
2517 // methods_default_annotations_typeArray {
2518 //   element_value default_value;
2519 // }
2520 //
2521 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_default_annotations(
2522        InstanceKlass* scratch_class, TRAPS) {
2523 
2524   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2525     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2526     AnnotationArray* method_default_annotations = m-&gt;constMethod()-&gt;default_annotations();
2527     if (method_default_annotations == NULL
2528         || method_default_annotations-&gt;length() == 0) {
2529       // this method does not have any default annotations so skip it
2530       continue;
2531     }
2532 
2533     int byte_i = 0;  // byte index into method_default_annotations
2534 
2535     if (!rewrite_cp_refs_in_element_value(
2536            method_default_annotations, byte_i, THREAD)) {
2537       log_debug(redefine, class, annotation)(&quot;bad default element_value at %d&quot;, i);
2538       // propagate failure back to caller
2539       return false;
2540     }
2541   }
2542 
2543   return true;
2544 } // end rewrite_cp_refs_in_methods_default_annotations()
2545 
2546 
2547 // Rewrite constant pool references in a class_type_annotations field.
2548 bool VM_RedefineClasses::rewrite_cp_refs_in_class_type_annotations(
2549        InstanceKlass* scratch_class, TRAPS) {
2550 
2551   AnnotationArray* class_type_annotations = scratch_class-&gt;class_type_annotations();
2552   if (class_type_annotations == NULL || class_type_annotations-&gt;length() == 0) {
2553     // no class_type_annotations so nothing to do
2554     return true;
2555   }
2556 
2557   log_debug(redefine, class, annotation)(&quot;class_type_annotations length=%d&quot;, class_type_annotations-&gt;length());
2558 
2559   int byte_i = 0;  // byte index into class_type_annotations
2560   return rewrite_cp_refs_in_type_annotations_typeArray(class_type_annotations,
2561       byte_i, &quot;ClassFile&quot;, THREAD);
2562 } // end rewrite_cp_refs_in_class_type_annotations()
2563 
2564 
2565 // Rewrite constant pool references in a fields_type_annotations field.
2566 bool VM_RedefineClasses::rewrite_cp_refs_in_fields_type_annotations(
2567        InstanceKlass* scratch_class, TRAPS) {
2568 
2569   Array&lt;AnnotationArray*&gt;* fields_type_annotations = scratch_class-&gt;fields_type_annotations();
2570   if (fields_type_annotations == NULL || fields_type_annotations-&gt;length() == 0) {
2571     // no fields_type_annotations so nothing to do
2572     return true;
2573   }
2574 
2575   log_debug(redefine, class, annotation)(&quot;fields_type_annotations length=%d&quot;, fields_type_annotations-&gt;length());
2576 
2577   for (int i = 0; i &lt; fields_type_annotations-&gt;length(); i++) {
2578     AnnotationArray* field_type_annotations = fields_type_annotations-&gt;at(i);
2579     if (field_type_annotations == NULL || field_type_annotations-&gt;length() == 0) {
2580       // this field does not have any annotations so skip it
2581       continue;
2582     }
2583 
2584     int byte_i = 0;  // byte index into field_type_annotations
2585     if (!rewrite_cp_refs_in_type_annotations_typeArray(field_type_annotations,
2586            byte_i, &quot;field_info&quot;, THREAD)) {
2587       log_debug(redefine, class, annotation)(&quot;bad field_type_annotations at %d&quot;, i);
2588       // propagate failure back to caller
2589       return false;
2590     }
2591   }
2592 
2593   return true;
2594 } // end rewrite_cp_refs_in_fields_type_annotations()
2595 
2596 
2597 // Rewrite constant pool references in a methods_type_annotations field.
2598 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_type_annotations(
2599        InstanceKlass* scratch_class, TRAPS) {
2600 
2601   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2602     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2603     AnnotationArray* method_type_annotations = m-&gt;constMethod()-&gt;type_annotations();
2604 
2605     if (method_type_annotations == NULL || method_type_annotations-&gt;length() == 0) {
2606       // this method does not have any annotations so skip it
2607       continue;
2608     }
2609 
2610     log_debug(redefine, class, annotation)(&quot;methods type_annotations length=%d&quot;, method_type_annotations-&gt;length());
2611 
2612     int byte_i = 0;  // byte index into method_type_annotations
2613     if (!rewrite_cp_refs_in_type_annotations_typeArray(method_type_annotations,
2614            byte_i, &quot;method_info&quot;, THREAD)) {
2615       log_debug(redefine, class, annotation)(&quot;bad method_type_annotations at %d&quot;, i);
2616       // propagate failure back to caller
2617       return false;
2618     }
2619   }
2620 
2621   return true;
2622 } // end rewrite_cp_refs_in_methods_type_annotations()
2623 
2624 
2625 // Rewrite constant pool references in a type_annotations
2626 // field. This &quot;structure&quot; is adapted from the
2627 // RuntimeVisibleTypeAnnotations_attribute described in
2628 // section 4.7.20 of the Java SE 8 Edition of the VM spec:
2629 //
2630 // type_annotations_typeArray {
2631 //   u2              num_annotations;
2632 //   type_annotation annotations[num_annotations];
2633 // }
2634 //
2635 bool VM_RedefineClasses::rewrite_cp_refs_in_type_annotations_typeArray(
2636        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2637        const char * location_mesg, TRAPS) {
2638 
2639   if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2640     // not enough room for num_annotations field
2641     log_debug(redefine, class, annotation)(&quot;length() is too small for num_annotations field&quot;);
2642     return false;
2643   }
2644 
2645   u2 num_annotations = Bytes::get_Java_u2((address)
2646                          type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2647   byte_i_ref += 2;
2648 
2649   log_debug(redefine, class, annotation)(&quot;num_type_annotations=%d&quot;, num_annotations);
2650 
2651   int calc_num_annotations = 0;
2652   for (; calc_num_annotations &lt; num_annotations; calc_num_annotations++) {
2653     if (!rewrite_cp_refs_in_type_annotation_struct(type_annotations_typeArray,
2654            byte_i_ref, location_mesg, THREAD)) {
2655       log_debug(redefine, class, annotation)(&quot;bad type_annotation_struct at %d&quot;, calc_num_annotations);
2656       // propagate failure back to caller
2657       return false;
2658     }
2659   }
2660   assert(num_annotations == calc_num_annotations, &quot;sanity check&quot;);
2661 
2662   if (byte_i_ref != type_annotations_typeArray-&gt;length()) {
2663     log_debug(redefine, class, annotation)
2664       (&quot;read wrong amount of bytes at end of processing type_annotations_typeArray (%d of %d bytes were read)&quot;,
2665        byte_i_ref, type_annotations_typeArray-&gt;length());
2666     return false;
2667   }
2668 
2669   return true;
2670 } // end rewrite_cp_refs_in_type_annotations_typeArray()
2671 
2672 
2673 // Rewrite constant pool references in a type_annotation
2674 // field. This &quot;structure&quot; is adapted from the
2675 // RuntimeVisibleTypeAnnotations_attribute described in
2676 // section 4.7.20 of the Java SE 8 Edition of the VM spec:
2677 //
2678 // type_annotation {
2679 //   u1 target_type;
2680 //   union {
2681 //     type_parameter_target;
2682 //     supertype_target;
2683 //     type_parameter_bound_target;
2684 //     empty_target;
2685 //     method_formal_parameter_target;
2686 //     throws_target;
2687 //     localvar_target;
2688 //     catch_target;
2689 //     offset_target;
2690 //     type_argument_target;
2691 //   } target_info;
2692 //   type_path target_path;
2693 //   annotation anno;
2694 // }
2695 //
2696 bool VM_RedefineClasses::rewrite_cp_refs_in_type_annotation_struct(
2697        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2698        const char * location_mesg, TRAPS) {
2699 
2700   if (!skip_type_annotation_target(type_annotations_typeArray,
2701          byte_i_ref, location_mesg, THREAD)) {
2702     return false;
2703   }
2704 
2705   if (!skip_type_annotation_type_path(type_annotations_typeArray,
2706          byte_i_ref, THREAD)) {
2707     return false;
2708   }
2709 
2710   if (!rewrite_cp_refs_in_annotation_struct(type_annotations_typeArray,
2711          byte_i_ref, THREAD)) {
2712     return false;
2713   }
2714 
2715   return true;
2716 } // end rewrite_cp_refs_in_type_annotation_struct()
2717 
2718 
2719 // Read, verify and skip over the target_type and target_info part
2720 // so that rewriting can continue in the later parts of the struct.
2721 //
2722 // u1 target_type;
2723 // union {
2724 //   type_parameter_target;
2725 //   supertype_target;
2726 //   type_parameter_bound_target;
2727 //   empty_target;
2728 //   method_formal_parameter_target;
2729 //   throws_target;
2730 //   localvar_target;
2731 //   catch_target;
2732 //   offset_target;
2733 //   type_argument_target;
2734 // } target_info;
2735 //
2736 bool VM_RedefineClasses::skip_type_annotation_target(
2737        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2738        const char * location_mesg, TRAPS) {
2739 
2740   if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2741     // not enough room for a target_type let alone the rest of a type_annotation
2742     log_debug(redefine, class, annotation)(&quot;length() is too small for a target_type&quot;);
2743     return false;
2744   }
2745 
2746   u1 target_type = type_annotations_typeArray-&gt;at(byte_i_ref);
2747   byte_i_ref += 1;
2748   log_debug(redefine, class, annotation)(&quot;target_type=0x%.2x&quot;, target_type);
2749   log_debug(redefine, class, annotation)(&quot;location=%s&quot;, location_mesg);
2750 
2751   // Skip over target_info
2752   switch (target_type) {
2753     case 0x00:
2754     // kind: type parameter declaration of generic class or interface
2755     // location: ClassFile
2756     case 0x01:
2757     // kind: type parameter declaration of generic method or constructor
2758     // location: method_info
2759 
2760     {
2761       // struct:
2762       // type_parameter_target {
2763       //   u1 type_parameter_index;
2764       // }
2765       //
2766       if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2767         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_parameter_target&quot;);
2768         return false;
2769       }
2770 
2771       u1 type_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2772       byte_i_ref += 1;
2773 
2774       log_debug(redefine, class, annotation)(&quot;type_parameter_target: type_parameter_index=%d&quot;, type_parameter_index);
2775     } break;
2776 
2777     case 0x10:
2778     // kind: type in extends clause of class or interface declaration
2779     //       (including the direct superclass of an unsafe anonymous class declaration),
2780     //       or in implements clause of interface declaration
2781     // location: ClassFile
2782 
2783     {
2784       // struct:
2785       // supertype_target {
2786       //   u2 supertype_index;
2787       // }
2788       //
2789       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2790         log_debug(redefine, class, annotation)(&quot;length() is too small for a supertype_target&quot;);
2791         return false;
2792       }
2793 
2794       u2 supertype_index = Bytes::get_Java_u2((address)
2795                              type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2796       byte_i_ref += 2;
2797 
2798       log_debug(redefine, class, annotation)(&quot;supertype_target: supertype_index=%d&quot;, supertype_index);
2799     } break;
2800 
2801     case 0x11:
2802     // kind: type in bound of type parameter declaration of generic class or interface
2803     // location: ClassFile
2804     case 0x12:
2805     // kind: type in bound of type parameter declaration of generic method or constructor
2806     // location: method_info
2807 
2808     {
2809       // struct:
2810       // type_parameter_bound_target {
2811       //   u1 type_parameter_index;
2812       //   u1 bound_index;
2813       // }
2814       //
2815       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2816         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_parameter_bound_target&quot;);
2817         return false;
2818       }
2819 
2820       u1 type_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2821       byte_i_ref += 1;
2822       u1 bound_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2823       byte_i_ref += 1;
2824 
2825       log_debug(redefine, class, annotation)
2826         (&quot;type_parameter_bound_target: type_parameter_index=%d, bound_index=%d&quot;, type_parameter_index, bound_index);
2827     } break;
2828 
2829     case 0x13:
2830     // kind: type in field declaration
2831     // location: field_info
2832     case 0x14:
2833     // kind: return type of method, or type of newly constructed object
2834     // location: method_info
2835     case 0x15:
2836     // kind: receiver type of method or constructor
2837     // location: method_info
2838 
2839     {
2840       // struct:
2841       // empty_target {
2842       // }
2843       //
2844       log_debug(redefine, class, annotation)(&quot;empty_target&quot;);
2845     } break;
2846 
2847     case 0x16:
2848     // kind: type in formal parameter declaration of method, constructor, or lambda expression
2849     // location: method_info
2850 
2851     {
2852       // struct:
2853       // formal_parameter_target {
2854       //   u1 formal_parameter_index;
2855       // }
2856       //
2857       if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2858         log_debug(redefine, class, annotation)(&quot;length() is too small for a formal_parameter_target&quot;);
2859         return false;
2860       }
2861 
2862       u1 formal_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2863       byte_i_ref += 1;
2864 
2865       log_debug(redefine, class, annotation)
2866         (&quot;formal_parameter_target: formal_parameter_index=%d&quot;, formal_parameter_index);
2867     } break;
2868 
2869     case 0x17:
2870     // kind: type in throws clause of method or constructor
2871     // location: method_info
2872 
2873     {
2874       // struct:
2875       // throws_target {
2876       //   u2 throws_type_index
2877       // }
2878       //
2879       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2880         log_debug(redefine, class, annotation)(&quot;length() is too small for a throws_target&quot;);
2881         return false;
2882       }
2883 
2884       u2 throws_type_index = Bytes::get_Java_u2((address)
2885                                type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2886       byte_i_ref += 2;
2887 
2888       log_debug(redefine, class, annotation)(&quot;throws_target: throws_type_index=%d&quot;, throws_type_index);
2889     } break;
2890 
2891     case 0x40:
2892     // kind: type in local variable declaration
2893     // location: Code
2894     case 0x41:
2895     // kind: type in resource variable declaration
2896     // location: Code
2897 
2898     {
2899       // struct:
2900       // localvar_target {
2901       //   u2 table_length;
2902       //   struct {
2903       //     u2 start_pc;
2904       //     u2 length;
2905       //     u2 index;
2906       //   } table[table_length];
2907       // }
2908       //
2909       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2910         // not enough room for a table_length let alone the rest of a localvar_target
2911         log_debug(redefine, class, annotation)(&quot;length() is too small for a localvar_target table_length&quot;);
2912         return false;
2913       }
2914 
2915       u2 table_length = Bytes::get_Java_u2((address)
2916                           type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2917       byte_i_ref += 2;
2918 
2919       log_debug(redefine, class, annotation)(&quot;localvar_target: table_length=%d&quot;, table_length);
2920 
2921       int table_struct_size = 2 + 2 + 2; // 3 u2 variables per table entry
2922       int table_size = table_length * table_struct_size;
2923 
2924       if ((byte_i_ref + table_size) &gt; type_annotations_typeArray-&gt;length()) {
2925         // not enough room for a table
2926         log_debug(redefine, class, annotation)(&quot;length() is too small for a table array of length %d&quot;, table_length);
2927         return false;
2928       }
2929 
2930       // Skip over table
2931       byte_i_ref += table_size;
2932     } break;
2933 
2934     case 0x42:
2935     // kind: type in exception parameter declaration
2936     // location: Code
2937 
2938     {
2939       // struct:
2940       // catch_target {
2941       //   u2 exception_table_index;
2942       // }
2943       //
2944       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2945         log_debug(redefine, class, annotation)(&quot;length() is too small for a catch_target&quot;);
2946         return false;
2947       }
2948 
2949       u2 exception_table_index = Bytes::get_Java_u2((address)
2950                                    type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2951       byte_i_ref += 2;
2952 
2953       log_debug(redefine, class, annotation)(&quot;catch_target: exception_table_index=%d&quot;, exception_table_index);
2954     } break;
2955 
2956     case 0x43:
2957     // kind: type in instanceof expression
2958     // location: Code
2959     case 0x44:
2960     // kind: type in new expression
2961     // location: Code
2962     case 0x45:
2963     // kind: type in method reference expression using ::new
2964     // location: Code
2965     case 0x46:
2966     // kind: type in method reference expression using ::Identifier
2967     // location: Code
2968 
2969     {
2970       // struct:
2971       // offset_target {
2972       //   u2 offset;
2973       // }
2974       //
2975       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2976         log_debug(redefine, class, annotation)(&quot;length() is too small for a offset_target&quot;);
2977         return false;
2978       }
2979 
2980       u2 offset = Bytes::get_Java_u2((address)
2981                     type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2982       byte_i_ref += 2;
2983 
2984       log_debug(redefine, class, annotation)(&quot;offset_target: offset=%d&quot;, offset);
2985     } break;
2986 
2987     case 0x47:
2988     // kind: type in cast expression
2989     // location: Code
2990     case 0x48:
2991     // kind: type argument for generic constructor in new expression or
2992     //       explicit constructor invocation statement
2993     // location: Code
2994     case 0x49:
2995     // kind: type argument for generic method in method invocation expression
2996     // location: Code
2997     case 0x4A:
2998     // kind: type argument for generic constructor in method reference expression using ::new
2999     // location: Code
3000     case 0x4B:
3001     // kind: type argument for generic method in method reference expression using ::Identifier
3002     // location: Code
3003 
3004     {
3005       // struct:
3006       // type_argument_target {
3007       //   u2 offset;
3008       //   u1 type_argument_index;
3009       // }
3010       //
3011       if ((byte_i_ref + 3) &gt; type_annotations_typeArray-&gt;length()) {
3012         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_argument_target&quot;);
3013         return false;
3014       }
3015 
3016       u2 offset = Bytes::get_Java_u2((address)
3017                     type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3018       byte_i_ref += 2;
3019       u1 type_argument_index = type_annotations_typeArray-&gt;at(byte_i_ref);
3020       byte_i_ref += 1;
3021 
3022       log_debug(redefine, class, annotation)
3023         (&quot;type_argument_target: offset=%d, type_argument_index=%d&quot;, offset, type_argument_index);
3024     } break;
3025 
3026     default:
3027       log_debug(redefine, class, annotation)(&quot;unknown target_type&quot;);
3028 #ifdef ASSERT
3029       ShouldNotReachHere();
3030 #endif
3031       return false;
3032   }
3033 
3034   return true;
3035 } // end skip_type_annotation_target()
3036 
3037 
3038 // Read, verify and skip over the type_path part so that rewriting
3039 // can continue in the later parts of the struct.
3040 //
3041 // type_path {
3042 //   u1 path_length;
3043 //   {
3044 //     u1 type_path_kind;
3045 //     u1 type_argument_index;
3046 //   } path[path_length];
3047 // }
3048 //
3049 bool VM_RedefineClasses::skip_type_annotation_type_path(
3050        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
3051 
3052   if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
3053     // not enough room for a path_length let alone the rest of the type_path
3054     log_debug(redefine, class, annotation)(&quot;length() is too small for a type_path&quot;);
3055     return false;
3056   }
3057 
3058   u1 path_length = type_annotations_typeArray-&gt;at(byte_i_ref);
3059   byte_i_ref += 1;
3060 
3061   log_debug(redefine, class, annotation)(&quot;type_path: path_length=%d&quot;, path_length);
3062 
3063   int calc_path_length = 0;
3064   for (; calc_path_length &lt; path_length; calc_path_length++) {
3065     if ((byte_i_ref + 1 + 1) &gt; type_annotations_typeArray-&gt;length()) {
3066       // not enough room for a path
3067       log_debug(redefine, class, annotation)
3068         (&quot;length() is too small for path entry %d of %d&quot;, calc_path_length, path_length);
3069       return false;
3070     }
3071 
3072     u1 type_path_kind = type_annotations_typeArray-&gt;at(byte_i_ref);
3073     byte_i_ref += 1;
3074     u1 type_argument_index = type_annotations_typeArray-&gt;at(byte_i_ref);
3075     byte_i_ref += 1;
3076 
3077     log_debug(redefine, class, annotation)
3078       (&quot;type_path: path[%d]: type_path_kind=%d, type_argument_index=%d&quot;,
3079        calc_path_length, type_path_kind, type_argument_index);
3080 
3081     if (type_path_kind &gt; 3 || (type_path_kind != 3 &amp;&amp; type_argument_index != 0)) {
3082       // not enough room for a path
3083       log_debug(redefine, class, annotation)(&quot;inconsistent type_path values&quot;);
3084       return false;
3085     }
3086   }
3087   assert(path_length == calc_path_length, &quot;sanity check&quot;);
3088 
3089   return true;
3090 } // end skip_type_annotation_type_path()
3091 
3092 
3093 // Rewrite constant pool references in the method&#39;s stackmap table.
3094 // These &quot;structures&quot; are adapted from the StackMapTable_attribute that
3095 // is described in section 4.8.4 of the 6.0 version of the VM spec
3096 // (dated 2005.10.26):
3097 // file:///net/quincunx.sfbay/export/gbracha/ClassFile-Java6.pdf
3098 //
3099 // stack_map {
3100 //   u2 number_of_entries;
3101 //   stack_map_frame entries[number_of_entries];
3102 // }
3103 //
3104 void VM_RedefineClasses::rewrite_cp_refs_in_stack_map_table(
3105        const methodHandle&amp; method, TRAPS) {
3106 
3107   if (!method-&gt;has_stackmap_table()) {
3108     return;
3109   }
3110 
3111   AnnotationArray* stackmap_data = method-&gt;stackmap_data();
3112   address stackmap_p = (address)stackmap_data-&gt;adr_at(0);
3113   address stackmap_end = stackmap_p + stackmap_data-&gt;length();
3114 
3115   assert(stackmap_p + 2 &lt;= stackmap_end, &quot;no room for number_of_entries&quot;);
3116   u2 number_of_entries = Bytes::get_Java_u2(stackmap_p);
3117   stackmap_p += 2;
3118 
3119   log_debug(redefine, class, stackmap)(&quot;number_of_entries=%u&quot;, number_of_entries);
3120 
3121   // walk through each stack_map_frame
3122   u2 calc_number_of_entries = 0;
3123   for (; calc_number_of_entries &lt; number_of_entries; calc_number_of_entries++) {
3124     // The stack_map_frame structure is a u1 frame_type followed by
3125     // 0 or more bytes of data:
3126     //
3127     // union stack_map_frame {
3128     //   same_frame;
3129     //   same_locals_1_stack_item_frame;
3130     //   same_locals_1_stack_item_frame_extended;
3131     //   chop_frame;
3132     //   same_frame_extended;
3133     //   append_frame;
3134     //   full_frame;
3135     // }
3136 
3137     assert(stackmap_p + 1 &lt;= stackmap_end, &quot;no room for frame_type&quot;);
3138     u1 frame_type = *stackmap_p;
3139     stackmap_p++;
3140 
3141     // same_frame {
3142     //   u1 frame_type = SAME; /* 0-63 */
3143     // }
3144     if (frame_type &lt;= 63) {
3145       // nothing more to do for same_frame
3146     }
3147 
3148     // same_locals_1_stack_item_frame {
3149     //   u1 frame_type = SAME_LOCALS_1_STACK_ITEM; /* 64-127 */
3150     //   verification_type_info stack[1];
3151     // }
3152     else if (frame_type &gt;= 64 &amp;&amp; frame_type &lt;= 127) {
3153       rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3154         calc_number_of_entries, frame_type, THREAD);
3155     }
3156 
3157     // reserved for future use
3158     else if (frame_type &gt;= 128 &amp;&amp; frame_type &lt;= 246) {
3159       // nothing more to do for reserved frame_types
3160     }
3161 
3162     // same_locals_1_stack_item_frame_extended {
3163     //   u1 frame_type = SAME_LOCALS_1_STACK_ITEM_EXTENDED; /* 247 */
3164     //   u2 offset_delta;
3165     //   verification_type_info stack[1];
3166     // }
3167     else if (frame_type == 247) {
3168       stackmap_p += 2;
3169       rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3170         calc_number_of_entries, frame_type, THREAD);
3171     }
3172 
3173     // chop_frame {
3174     //   u1 frame_type = CHOP; /* 248-250 */
3175     //   u2 offset_delta;
3176     // }
3177     else if (frame_type &gt;= 248 &amp;&amp; frame_type &lt;= 250) {
3178       stackmap_p += 2;
3179     }
3180 
3181     // same_frame_extended {
3182     //   u1 frame_type = SAME_FRAME_EXTENDED; /* 251*/
3183     //   u2 offset_delta;
3184     // }
3185     else if (frame_type == 251) {
3186       stackmap_p += 2;
3187     }
3188 
3189     // append_frame {
3190     //   u1 frame_type = APPEND; /* 252-254 */
3191     //   u2 offset_delta;
3192     //   verification_type_info locals[frame_type - 251];
3193     // }
3194     else if (frame_type &gt;= 252 &amp;&amp; frame_type &lt;= 254) {
3195       assert(stackmap_p + 2 &lt;= stackmap_end,
3196         &quot;no room for offset_delta&quot;);
3197       stackmap_p += 2;
3198       u1 len = frame_type - 251;
3199       for (u1 i = 0; i &lt; len; i++) {
3200         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3201           calc_number_of_entries, frame_type, THREAD);
3202       }
3203     }
3204 
3205     // full_frame {
3206     //   u1 frame_type = FULL_FRAME; /* 255 */
3207     //   u2 offset_delta;
3208     //   u2 number_of_locals;
3209     //   verification_type_info locals[number_of_locals];
3210     //   u2 number_of_stack_items;
3211     //   verification_type_info stack[number_of_stack_items];
3212     // }
3213     else if (frame_type == 255) {
3214       assert(stackmap_p + 2 + 2 &lt;= stackmap_end,
3215         &quot;no room for smallest full_frame&quot;);
3216       stackmap_p += 2;
3217 
3218       u2 number_of_locals = Bytes::get_Java_u2(stackmap_p);
3219       stackmap_p += 2;
3220 
3221       for (u2 locals_i = 0; locals_i &lt; number_of_locals; locals_i++) {
3222         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3223           calc_number_of_entries, frame_type, THREAD);
3224       }
3225 
3226       // Use the largest size for the number_of_stack_items, but only get
3227       // the right number of bytes.
3228       u2 number_of_stack_items = Bytes::get_Java_u2(stackmap_p);
3229       stackmap_p += 2;
3230 
3231       for (u2 stack_i = 0; stack_i &lt; number_of_stack_items; stack_i++) {
3232         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3233           calc_number_of_entries, frame_type, THREAD);
3234       }
3235     }
3236   } // end while there is a stack_map_frame
3237   assert(number_of_entries == calc_number_of_entries, &quot;sanity check&quot;);
3238 } // end rewrite_cp_refs_in_stack_map_table()
3239 
3240 
3241 // Rewrite constant pool references in the verification type info
3242 // portion of the method&#39;s stackmap table. These &quot;structures&quot; are
3243 // adapted from the StackMapTable_attribute that is described in
3244 // section 4.8.4 of the 6.0 version of the VM spec (dated 2005.10.26):
3245 // file:///net/quincunx.sfbay/export/gbracha/ClassFile-Java6.pdf
3246 //
3247 // The verification_type_info structure is a u1 tag followed by 0 or
3248 // more bytes of data:
3249 //
3250 // union verification_type_info {
3251 //   Top_variable_info;
3252 //   Integer_variable_info;
3253 //   Float_variable_info;
3254 //   Long_variable_info;
3255 //   Double_variable_info;
3256 //   Null_variable_info;
3257 //   UninitializedThis_variable_info;
3258 //   Object_variable_info;
3259 //   Uninitialized_variable_info;
3260 // }
3261 //
3262 void VM_RedefineClasses::rewrite_cp_refs_in_verification_type_info(
3263        address&amp; stackmap_p_ref, address stackmap_end, u2 frame_i,
3264        u1 frame_type, TRAPS) {
3265 
3266   assert(stackmap_p_ref + 1 &lt;= stackmap_end, &quot;no room for tag&quot;);
3267   u1 tag = *stackmap_p_ref;
3268   stackmap_p_ref++;
3269 
3270   switch (tag) {
3271   // Top_variable_info {
3272   //   u1 tag = ITEM_Top; /* 0 */
3273   // }
3274   // verificationType.hpp has zero as ITEM_Bogus instead of ITEM_Top
3275   case 0:  // fall through
3276 
3277   // Integer_variable_info {
3278   //   u1 tag = ITEM_Integer; /* 1 */
3279   // }
3280   case ITEM_Integer:  // fall through
3281 
3282   // Float_variable_info {
3283   //   u1 tag = ITEM_Float; /* 2 */
3284   // }
3285   case ITEM_Float:  // fall through
3286 
3287   // Double_variable_info {
3288   //   u1 tag = ITEM_Double; /* 3 */
3289   // }
3290   case ITEM_Double:  // fall through
3291 
3292   // Long_variable_info {
3293   //   u1 tag = ITEM_Long; /* 4 */
3294   // }
3295   case ITEM_Long:  // fall through
3296 
3297   // Null_variable_info {
3298   //   u1 tag = ITEM_Null; /* 5 */
3299   // }
3300   case ITEM_Null:  // fall through
3301 
3302   // UninitializedThis_variable_info {
3303   //   u1 tag = ITEM_UninitializedThis; /* 6 */
3304   // }
3305   case ITEM_UninitializedThis:
3306     // nothing more to do for the above tag types
3307     break;
3308 
3309   // Object_variable_info {
3310   //   u1 tag = ITEM_Object; /* 7 */
3311   //   u2 cpool_index;
3312   // }
3313   case ITEM_Object:
3314   {
3315     assert(stackmap_p_ref + 2 &lt;= stackmap_end, &quot;no room for cpool_index&quot;);
3316     u2 cpool_index = Bytes::get_Java_u2(stackmap_p_ref);
3317     u2 new_cp_index = find_new_index(cpool_index);
3318     if (new_cp_index != 0) {
3319       log_debug(redefine, class, stackmap)(&quot;mapped old cpool_index=%d&quot;, cpool_index);
3320       Bytes::put_Java_u2(stackmap_p_ref, new_cp_index);
3321       cpool_index = new_cp_index;
3322     }
3323     stackmap_p_ref += 2;
3324 
3325     log_debug(redefine, class, stackmap)
3326       (&quot;frame_i=%u, frame_type=%u, cpool_index=%d&quot;, frame_i, frame_type, cpool_index);
3327   } break;
3328 
3329   // Uninitialized_variable_info {
3330   //   u1 tag = ITEM_Uninitialized; /* 8 */
3331   //   u2 offset;
3332   // }
3333   case ITEM_Uninitialized:
3334     assert(stackmap_p_ref + 2 &lt;= stackmap_end, &quot;no room for offset&quot;);
3335     stackmap_p_ref += 2;
3336     break;
3337 
3338   default:
3339     log_debug(redefine, class, stackmap)(&quot;frame_i=%u, frame_type=%u, bad tag=0x%x&quot;, frame_i, frame_type, tag);
3340     ShouldNotReachHere();
3341     break;
3342   } // end switch (tag)
3343 } // end rewrite_cp_refs_in_verification_type_info()
3344 
3345 
3346 // Change the constant pool associated with klass scratch_class to
3347 // scratch_cp. If shrink is true, then scratch_cp_length elements
3348 // are copied from scratch_cp to a smaller constant pool and the
3349 // smaller constant pool is associated with scratch_class.
3350 void VM_RedefineClasses::set_new_constant_pool(
3351        ClassLoaderData* loader_data,
3352        InstanceKlass* scratch_class, constantPoolHandle scratch_cp,
3353        int scratch_cp_length, TRAPS) {
3354   assert(scratch_cp-&gt;length() &gt;= scratch_cp_length, &quot;sanity check&quot;);
3355 
3356   // scratch_cp is a merged constant pool and has enough space for a
3357   // worst case merge situation. We want to associate the minimum
3358   // sized constant pool with the klass to save space.
3359   ConstantPool* cp = ConstantPool::allocate(loader_data, scratch_cp_length, CHECK);
3360   constantPoolHandle smaller_cp(THREAD, cp);
3361 
3362   // preserve version() value in the smaller copy
3363   int version = scratch_cp-&gt;version();
3364   assert(version != 0, &quot;sanity check&quot;);
3365   smaller_cp-&gt;set_version(version);
3366 
3367   // attach klass to new constant pool
3368   // reference to the cp holder is needed for copy_operands()
3369   smaller_cp-&gt;set_pool_holder(scratch_class);
3370 
3371   if (scratch_cp-&gt;has_dynamic_constant()) {
3372     smaller_cp-&gt;set_has_dynamic_constant();
3373   }
3374 
3375   scratch_cp-&gt;copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
3376   if (HAS_PENDING_EXCEPTION) {
3377     // Exception is handled in the caller
3378     loader_data-&gt;add_to_deallocate_list(smaller_cp());
3379     return;
3380   }
3381   scratch_cp = smaller_cp;
3382 
3383   // attach new constant pool to klass
3384   scratch_class-&gt;set_constants(scratch_cp());
3385   scratch_cp-&gt;initialize_unresolved_klasses(loader_data, CHECK);
3386 
3387   int i;  // for portability
3388 
3389   // update each field in klass to use new constant pool indices as needed
3390   for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {
3391     jshort cur_index = fs.name_index();
3392     jshort new_index = find_new_index(cur_index);
3393     if (new_index != 0) {
3394       log_trace(redefine, class, constantpool)(&quot;field-name_index change: %d to %d&quot;, cur_index, new_index);
3395       fs.set_name_index(new_index);
3396     }
3397     cur_index = fs.signature_index();
3398     new_index = find_new_index(cur_index);
3399     if (new_index != 0) {
3400       log_trace(redefine, class, constantpool)(&quot;field-signature_index change: %d to %d&quot;, cur_index, new_index);
3401       fs.set_signature_index(new_index);
3402     }
3403     cur_index = fs.initval_index();
3404     new_index = find_new_index(cur_index);
3405     if (new_index != 0) {
3406       log_trace(redefine, class, constantpool)(&quot;field-initval_index change: %d to %d&quot;, cur_index, new_index);
3407       fs.set_initval_index(new_index);
3408     }
3409     cur_index = fs.generic_signature_index();
3410     new_index = find_new_index(cur_index);
3411     if (new_index != 0) {
3412       log_trace(redefine, class, constantpool)(&quot;field-generic_signature change: %d to %d&quot;, cur_index, new_index);
3413       fs.set_generic_signature_index(new_index);
3414     }
3415   } // end for each field
3416 
3417   // Update constant pool indices in the inner classes info to use
3418   // new constant indices as needed. The inner classes info is a
3419   // quadruple:
3420   // (inner_class_info, outer_class_info, inner_name, inner_access_flags)
3421   InnerClassesIterator iter(scratch_class);
3422   for (; !iter.done(); iter.next()) {
3423     int cur_index = iter.inner_class_info_index();
3424     if (cur_index == 0) {
3425       continue;  // JVM spec. allows null inner class refs so skip it
3426     }
3427     int new_index = find_new_index(cur_index);
3428     if (new_index != 0) {
3429       log_trace(redefine, class, constantpool)(&quot;inner_class_info change: %d to %d&quot;, cur_index, new_index);
3430       iter.set_inner_class_info_index(new_index);
3431     }
3432     cur_index = iter.outer_class_info_index();
3433     new_index = find_new_index(cur_index);
3434     if (new_index != 0) {
3435       log_trace(redefine, class, constantpool)(&quot;outer_class_info change: %d to %d&quot;, cur_index, new_index);
3436       iter.set_outer_class_info_index(new_index);
3437     }
3438     cur_index = iter.inner_name_index();
3439     new_index = find_new_index(cur_index);
3440     if (new_index != 0) {
3441       log_trace(redefine, class, constantpool)(&quot;inner_name change: %d to %d&quot;, cur_index, new_index);
3442       iter.set_inner_name_index(new_index);
3443     }
3444   } // end for each inner class
3445 
3446   // Attach each method in klass to the new constant pool and update
3447   // to use new constant pool indices as needed:
3448   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
3449   for (i = methods-&gt;length() - 1; i &gt;= 0; i--) {
3450     methodHandle method(THREAD, methods-&gt;at(i));
3451     method-&gt;set_constants(scratch_cp());
3452 
3453     int new_index = find_new_index(method-&gt;name_index());
3454     if (new_index != 0) {
3455       log_trace(redefine, class, constantpool)
3456         (&quot;method-name_index change: %d to %d&quot;, method-&gt;name_index(), new_index);
3457       method-&gt;set_name_index(new_index);
3458     }
3459     new_index = find_new_index(method-&gt;signature_index());
3460     if (new_index != 0) {
3461       log_trace(redefine, class, constantpool)
3462         (&quot;method-signature_index change: %d to %d&quot;, method-&gt;signature_index(), new_index);
3463       method-&gt;set_signature_index(new_index);
3464     }
3465     new_index = find_new_index(method-&gt;generic_signature_index());
3466     if (new_index != 0) {
3467       log_trace(redefine, class, constantpool)
3468         (&quot;method-generic_signature_index change: %d to %d&quot;, method-&gt;generic_signature_index(), new_index);
3469       method-&gt;set_generic_signature_index(new_index);
3470     }
3471 
3472     // Update constant pool indices in the method&#39;s checked exception
3473     // table to use new constant indices as needed.
3474     int cext_length = method-&gt;checked_exceptions_length();
3475     if (cext_length &gt; 0) {
3476       CheckedExceptionElement * cext_table =
3477         method-&gt;checked_exceptions_start();
3478       for (int j = 0; j &lt; cext_length; j++) {
3479         int cur_index = cext_table[j].class_cp_index;
3480         int new_index = find_new_index(cur_index);
3481         if (new_index != 0) {
3482           log_trace(redefine, class, constantpool)(&quot;cext-class_cp_index change: %d to %d&quot;, cur_index, new_index);
3483           cext_table[j].class_cp_index = (u2)new_index;
3484         }
3485       } // end for each checked exception table entry
3486     } // end if there are checked exception table entries
3487 
3488     // Update each catch type index in the method&#39;s exception table
3489     // to use new constant pool indices as needed. The exception table
3490     // holds quadruple entries of the form:
3491     //   (beg_bci, end_bci, handler_bci, klass_index)
3492 
3493     ExceptionTable ex_table(method());
3494     int ext_length = ex_table.length();
3495 
3496     for (int j = 0; j &lt; ext_length; j ++) {
3497       int cur_index = ex_table.catch_type_index(j);
3498       int new_index = find_new_index(cur_index);
3499       if (new_index != 0) {
3500         log_trace(redefine, class, constantpool)(&quot;ext-klass_index change: %d to %d&quot;, cur_index, new_index);
3501         ex_table.set_catch_type_index(j, new_index);
3502       }
3503     } // end for each exception table entry
3504 
3505     // Update constant pool indices in the method&#39;s local variable
3506     // table to use new constant indices as needed. The local variable
3507     // table hold sextuple entries of the form:
3508     // (start_pc, length, name_index, descriptor_index, signature_index, slot)
3509     int lvt_length = method-&gt;localvariable_table_length();
3510     if (lvt_length &gt; 0) {
3511       LocalVariableTableElement * lv_table =
3512         method-&gt;localvariable_table_start();
3513       for (int j = 0; j &lt; lvt_length; j++) {
3514         int cur_index = lv_table[j].name_cp_index;
3515         int new_index = find_new_index(cur_index);
3516         if (new_index != 0) {
3517           log_trace(redefine, class, constantpool)(&quot;lvt-name_cp_index change: %d to %d&quot;, cur_index, new_index);
3518           lv_table[j].name_cp_index = (u2)new_index;
3519         }
3520         cur_index = lv_table[j].descriptor_cp_index;
3521         new_index = find_new_index(cur_index);
3522         if (new_index != 0) {
3523           log_trace(redefine, class, constantpool)(&quot;lvt-descriptor_cp_index change: %d to %d&quot;, cur_index, new_index);
3524           lv_table[j].descriptor_cp_index = (u2)new_index;
3525         }
3526         cur_index = lv_table[j].signature_cp_index;
3527         new_index = find_new_index(cur_index);
3528         if (new_index != 0) {
3529           log_trace(redefine, class, constantpool)(&quot;lvt-signature_cp_index change: %d to %d&quot;, cur_index, new_index);
3530           lv_table[j].signature_cp_index = (u2)new_index;
3531         }
3532       } // end for each local variable table entry
3533     } // end if there are local variable table entries
3534 
3535     rewrite_cp_refs_in_stack_map_table(method, THREAD);
3536   } // end for each method
3537 } // end set_new_constant_pool()
3538 
3539 
3540 // Unevolving classes may point to methods of the_class directly
3541 // from their constant pool caches, itables, and/or vtables. We
3542 // use the ClassLoaderDataGraph::classes_do() facility and this helper
3543 // to fix up these pointers.  MethodData also points to old methods and
3544 // must be cleaned.
3545 
3546 // Adjust cpools and vtables closure
3547 void VM_RedefineClasses::AdjustAndCleanMetadata::do_klass(Klass* k) {
3548 
3549   // This is a very busy routine. We don&#39;t want too much tracing
3550   // printed out.
3551   bool trace_name_printed = false;
3552 
3553   // If the class being redefined is java.lang.Object, we need to fix all
3554   // array class vtables also
3555   if (k-&gt;is_array_klass() &amp;&amp; _has_redefined_Object) {
3556     k-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3557 
3558   } else if (k-&gt;is_instance_klass()) {
3559     HandleMark hm(_thread);
3560     InstanceKlass *ik = InstanceKlass::cast(k);
3561 
3562     // Clean MethodData of this class&#39;s methods so they don&#39;t refer to
3563     // old methods that are no longer running.
3564     Array&lt;Method*&gt;* methods = ik-&gt;methods();
3565     int num_methods = methods-&gt;length();
3566     for (int index = 0; index &lt; num_methods; ++index) {
3567       if (methods-&gt;at(index)-&gt;method_data() != NULL) {
3568         methods-&gt;at(index)-&gt;method_data()-&gt;clean_weak_method_links();
3569       }
3570     }
3571 
3572     // HotSpot specific optimization! HotSpot does not currently
3573     // support delegation from the bootstrap class loader to a
3574     // user-defined class loader. This means that if the bootstrap
3575     // class loader is the initiating class loader, then it will also
3576     // be the defining class loader. This also means that classes
3577     // loaded by the bootstrap class loader cannot refer to classes
3578     // loaded by a user-defined class loader. Note: a user-defined
3579     // class loader can delegate to the bootstrap class loader.
3580     //
3581     // If the current class being redefined has a user-defined class
3582     // loader as its defining class loader, then we can skip all
3583     // classes loaded by the bootstrap class loader.
3584     if (!_has_null_class_loader &amp;&amp; ik-&gt;class_loader() == NULL) {
3585       return;
3586     }
3587 
3588     // Adjust all vtables, default methods and itables, to clean out old methods.
3589     ResourceMark rm(_thread);
3590     if (ik-&gt;vtable_length() &gt; 0) {
3591       ik-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3592       ik-&gt;adjust_default_methods(&amp;trace_name_printed);
3593     }
3594 
3595     if (ik-&gt;itable_length() &gt; 0) {
3596       ik-&gt;itable().adjust_method_entries(&amp;trace_name_printed);
3597     }
3598 
3599     // The constant pools in other classes (other_cp) can refer to
3600     // old methods.  We have to update method information in
3601     // other_cp&#39;s cache. If other_cp has a previous version, then we
3602     // have to repeat the process for each previous version. The
3603     // constant pool cache holds the Method*s for non-virtual
3604     // methods and for virtual, final methods.
3605     //
3606     // Special case: if the current class being redefined, then new_cp
3607     // has already been attached to the_class and old_cp has already
3608     // been added as a previous version. The new_cp doesn&#39;t have any
3609     // cached references to old methods so it doesn&#39;t need to be
3610     // updated. We can simply start with the previous version(s) in
3611     // that case.
3612     ConstantPoolCache* cp_cache;
3613 
3614     if (!ik-&gt;is_being_redefined()) {
3615       // this klass&#39; constant pool cache may need adjustment
3616       ConstantPool* other_cp = ik-&gt;constants();
3617       cp_cache = other_cp-&gt;cache();
3618       if (cp_cache != NULL) {
3619         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3620       }
3621     }
3622 
3623     // the previous versions&#39; constant pool caches may need adjustment
3624     for (InstanceKlass* pv_node = ik-&gt;previous_versions();
3625          pv_node != NULL;
3626          pv_node = pv_node-&gt;previous_versions()) {
3627       cp_cache = pv_node-&gt;constants()-&gt;cache();
3628       if (cp_cache != NULL) {
3629         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3630       }
3631     }
3632   }
3633 }
3634 
3635 void VM_RedefineClasses::update_jmethod_ids(Thread* thread) {
3636   for (int j = 0; j &lt; _matching_methods_length; ++j) {
3637     Method* old_method = _matching_old_methods[j];
3638     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
3639     if (jmid != NULL) {
3640       // There is a jmethodID, change it to point to the new method
3641       methodHandle new_method_h(thread, _matching_new_methods[j]);
3642       Method::change_method_associated_with_jmethod_id(jmid, new_method_h());
3643       assert(Method::resolve_jmethod_id(jmid) == _matching_new_methods[j],
3644              &quot;should be replaced&quot;);
3645     }
3646   }
3647 }
3648 
3649 int VM_RedefineClasses::check_methods_and_mark_as_obsolete() {
3650   int emcp_method_count = 0;
3651   int obsolete_count = 0;
3652   int old_index = 0;
3653   for (int j = 0; j &lt; _matching_methods_length; ++j, ++old_index) {
3654     Method* old_method = _matching_old_methods[j];
3655     Method* new_method = _matching_new_methods[j];
3656     Method* old_array_method;
3657 
3658     // Maintain an old_index into the _old_methods array by skipping
3659     // deleted methods
3660     while ((old_array_method = _old_methods-&gt;at(old_index)) != old_method) {
3661       ++old_index;
3662     }
3663 
3664     if (MethodComparator::methods_EMCP(old_method, new_method)) {
3665       // The EMCP definition from JSR-163 requires the bytecodes to be
3666       // the same with the exception of constant pool indices which may
3667       // differ. However, the constants referred to by those indices
3668       // must be the same.
3669       //
3670       // We use methods_EMCP() for comparison since constant pool
3671       // merging can remove duplicate constant pool entries that were
3672       // present in the old method and removed from the rewritten new
3673       // method. A faster binary comparison function would consider the
3674       // old and new methods to be different when they are actually
3675       // EMCP.
3676       //
3677       // The old and new methods are EMCP and you would think that we
3678       // could get rid of one of them here and now and save some space.
3679       // However, the concept of EMCP only considers the bytecodes and
3680       // the constant pool entries in the comparison. Other things,
3681       // e.g., the line number table (LNT) or the local variable table
3682       // (LVT) don&#39;t count in the comparison. So the new (and EMCP)
3683       // method can have a new LNT that we need so we can&#39;t just
3684       // overwrite the new method with the old method.
3685       //
3686       // When this routine is called, we have already attached the new
3687       // methods to the_class so the old methods are effectively
3688       // overwritten. However, if an old method is still executing,
3689       // then the old method cannot be collected until sometime after
3690       // the old method call has returned. So the overwriting of old
3691       // methods by new methods will save us space except for those
3692       // (hopefully few) old methods that are still executing.
3693       //
3694       // A method refers to a ConstMethod* and this presents another
3695       // possible avenue to space savings. The ConstMethod* in the
3696       // new method contains possibly new attributes (LNT, LVT, etc).
3697       // At first glance, it seems possible to save space by replacing
3698       // the ConstMethod* in the old method with the ConstMethod*
3699       // from the new method. The old and new methods would share the
3700       // same ConstMethod* and we would save the space occupied by
3701       // the old ConstMethod*. However, the ConstMethod* contains
3702       // a back reference to the containing method. Sharing the
3703       // ConstMethod* between two methods could lead to confusion in
3704       // the code that uses the back reference. This would lead to
3705       // brittle code that could be broken in non-obvious ways now or
3706       // in the future.
3707       //
3708       // Another possibility is to copy the ConstMethod* from the new
3709       // method to the old method and then overwrite the new method with
3710       // the old method. Since the ConstMethod* contains the bytecodes
3711       // for the method embedded in the oop, this option would change
3712       // the bytecodes out from under any threads executing the old
3713       // method and make the thread&#39;s bcp invalid. Since EMCP requires
3714       // that the bytecodes be the same modulo constant pool indices, it
3715       // is straight forward to compute the correct new bcp in the new
3716       // ConstMethod* from the old bcp in the old ConstMethod*. The
3717       // time consuming part would be searching all the frames in all
3718       // of the threads to find all of the calls to the old method.
3719       //
3720       // It looks like we will have to live with the limited savings
3721       // that we get from effectively overwriting the old methods
3722       // when the new methods are attached to the_class.
3723 
3724       // Count number of methods that are EMCP.  The method will be marked
3725       // old but not obsolete if it is EMCP.
3726       emcp_method_count++;
3727 
3728       // An EMCP method is _not_ obsolete. An obsolete method has a
3729       // different jmethodID than the current method. An EMCP method
3730       // has the same jmethodID as the current method. Having the
3731       // same jmethodID for all EMCP versions of a method allows for
3732       // a consistent view of the EMCP methods regardless of which
3733       // EMCP method you happen to have in hand. For example, a
3734       // breakpoint set in one EMCP method will work for all EMCP
3735       // versions of the method including the current one.
3736     } else {
3737       // mark obsolete methods as such
3738       old_method-&gt;set_is_obsolete();
3739       obsolete_count++;
3740 
3741       // obsolete methods need a unique idnum so they become new entries in
3742       // the jmethodID cache in InstanceKlass
3743       assert(old_method-&gt;method_idnum() == new_method-&gt;method_idnum(), &quot;must match&quot;);
3744       u2 num = InstanceKlass::cast(_the_class)-&gt;next_method_idnum();
3745       if (num != ConstMethod::UNSET_IDNUM) {
3746         old_method-&gt;set_method_idnum(num);
3747       }
3748 
3749       // With tracing we try not to &quot;yack&quot; too much. The position of
3750       // this trace assumes there are fewer obsolete methods than
3751       // EMCP methods.
3752       if (log_is_enabled(Trace, redefine, class, obsolete, mark)) {
3753         ResourceMark rm;
3754         log_trace(redefine, class, obsolete, mark)
3755           (&quot;mark %s(%s) as obsolete&quot;, old_method-&gt;name()-&gt;as_C_string(), old_method-&gt;signature()-&gt;as_C_string());
3756       }
3757     }
3758     old_method-&gt;set_is_old();
3759   }
3760   for (int i = 0; i &lt; _deleted_methods_length; ++i) {
3761     Method* old_method = _deleted_methods[i];
3762 
3763     assert(!old_method-&gt;has_vtable_index(),
3764            &quot;cannot delete methods with vtable entries&quot;);;
3765 
3766     // Mark all deleted methods as old, obsolete and deleted
3767     old_method-&gt;set_is_deleted();
3768     old_method-&gt;set_is_old();
3769     old_method-&gt;set_is_obsolete();
3770     ++obsolete_count;
3771     // With tracing we try not to &quot;yack&quot; too much. The position of
3772     // this trace assumes there are fewer obsolete methods than
3773     // EMCP methods.
3774     if (log_is_enabled(Trace, redefine, class, obsolete, mark)) {
3775       ResourceMark rm;
3776       log_trace(redefine, class, obsolete, mark)
3777         (&quot;mark deleted %s(%s) as obsolete&quot;, old_method-&gt;name()-&gt;as_C_string(), old_method-&gt;signature()-&gt;as_C_string());
3778     }
3779   }
3780   assert((emcp_method_count + obsolete_count) == _old_methods-&gt;length(),
3781     &quot;sanity check&quot;);
3782   log_trace(redefine, class, obsolete, mark)(&quot;EMCP_cnt=%d, obsolete_cnt=%d&quot;, emcp_method_count, obsolete_count);
3783   return emcp_method_count;
3784 }
3785 
3786 // This internal class transfers the native function registration from old methods
3787 // to new methods.  It is designed to handle both the simple case of unchanged
3788 // native methods and the complex cases of native method prefixes being added and/or
3789 // removed.
3790 // It expects only to be used during the VM_RedefineClasses op (a safepoint).
3791 //
3792 // This class is used after the new methods have been installed in &quot;the_class&quot;.
3793 //
3794 // So, for example, the following must be handled.  Where &#39;m&#39; is a method and
3795 // a number followed by an underscore is a prefix.
3796 //
3797 //                                      Old Name    New Name
3798 // Simple transfer to new method        m       -&gt;  m
3799 // Add prefix                           m       -&gt;  1_m
3800 // Remove prefix                        1_m     -&gt;  m
3801 // Simultaneous add of prefixes         m       -&gt;  3_2_1_m
3802 // Simultaneous removal of prefixes     3_2_1_m -&gt;  m
3803 // Simultaneous add and remove          1_m     -&gt;  2_m
3804 // Same, caused by prefix removal only  3_2_1_m -&gt;  3_2_m
3805 //
3806 class TransferNativeFunctionRegistration {
3807  private:
3808   InstanceKlass* the_class;
3809   int prefix_count;
3810   char** prefixes;
3811 
3812   // Recursively search the binary tree of possibly prefixed method names.
3813   // Iteration could be used if all agents were well behaved. Full tree walk is
3814   // more resilent to agents not cleaning up intermediate methods.
3815   // Branch at each depth in the binary tree is:
3816   //    (1) without the prefix.
3817   //    (2) with the prefix.
3818   // where &#39;prefix&#39; is the prefix at that &#39;depth&#39; (first prefix, second prefix,...)
3819   Method* search_prefix_name_space(int depth, char* name_str, size_t name_len,
3820                                      Symbol* signature) {
3821     TempNewSymbol name_symbol = SymbolTable::probe(name_str, (int)name_len);
3822     if (name_symbol != NULL) {
3823       Method* method = the_class-&gt;lookup_method(name_symbol, signature);
3824       if (method != NULL) {
3825         // Even if prefixed, intermediate methods must exist.
3826         if (method-&gt;is_native()) {
3827           // Wahoo, we found a (possibly prefixed) version of the method, return it.
3828           return method;
3829         }
3830         if (depth &lt; prefix_count) {
3831           // Try applying further prefixes (other than this one).
3832           method = search_prefix_name_space(depth+1, name_str, name_len, signature);
3833           if (method != NULL) {
3834             return method; // found
3835           }
3836 
3837           // Try adding this prefix to the method name and see if it matches
3838           // another method name.
3839           char* prefix = prefixes[depth];
3840           size_t prefix_len = strlen(prefix);
3841           size_t trial_len = name_len + prefix_len;
3842           char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);
3843           strcpy(trial_name_str, prefix);
3844           strcat(trial_name_str, name_str);
3845           method = search_prefix_name_space(depth+1, trial_name_str, trial_len,
3846                                             signature);
3847           if (method != NULL) {
3848             // If found along this branch, it was prefixed, mark as such
3849             method-&gt;set_is_prefixed_native();
3850             return method; // found
3851           }
3852         }
3853       }
3854     }
3855     return NULL;  // This whole branch bore nothing
3856   }
3857 
3858   // Return the method name with old prefixes stripped away.
3859   char* method_name_without_prefixes(Method* method) {
3860     Symbol* name = method-&gt;name();
3861     char* name_str = name-&gt;as_utf8();
3862 
3863     // Old prefixing may be defunct, strip prefixes, if any.
3864     for (int i = prefix_count-1; i &gt;= 0; i--) {
3865       char* prefix = prefixes[i];
3866       size_t prefix_len = strlen(prefix);
3867       if (strncmp(prefix, name_str, prefix_len) == 0) {
3868         name_str += prefix_len;
3869       }
3870     }
3871     return name_str;
3872   }
3873 
3874   // Strip any prefixes off the old native method, then try to find a
3875   // (possibly prefixed) new native that matches it.
3876   Method* strip_and_search_for_new_native(Method* method) {
3877     ResourceMark rm;
3878     char* name_str = method_name_without_prefixes(method);
3879     return search_prefix_name_space(0, name_str, strlen(name_str),
3880                                     method-&gt;signature());
3881   }
3882 
3883  public:
3884 
3885   // Construct a native method transfer processor for this class.
3886   TransferNativeFunctionRegistration(InstanceKlass* _the_class) {
3887     assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
3888 
3889     the_class = _the_class;
3890     prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
3891   }
3892 
3893   // Attempt to transfer any of the old or deleted methods that are native
3894   void transfer_registrations(Method** old_methods, int methods_length) {
3895     for (int j = 0; j &lt; methods_length; j++) {
3896       Method* old_method = old_methods[j];
3897 
3898       if (old_method-&gt;is_native() &amp;&amp; old_method-&gt;has_native_function()) {
3899         Method* new_method = strip_and_search_for_new_native(old_method);
3900         if (new_method != NULL) {
3901           // Actually set the native function in the new method.
3902           // Redefine does not send events (except CFLH), certainly not this
3903           // behind the scenes re-registration.
3904           new_method-&gt;set_native_function(old_method-&gt;native_function(),
3905                               !Method::native_bind_event_is_interesting);
3906         }
3907       }
3908     }
3909   }
3910 };
3911 
3912 // Don&#39;t lose the association between a native method and its JNI function.
3913 void VM_RedefineClasses::transfer_old_native_function_registrations(InstanceKlass* the_class) {
3914   TransferNativeFunctionRegistration transfer(the_class);
3915   transfer.transfer_registrations(_deleted_methods, _deleted_methods_length);
3916   transfer.transfer_registrations(_matching_old_methods, _matching_methods_length);
3917 }
3918 
3919 // Deoptimize all compiled code that depends on this class.
3920 //
3921 // If the can_redefine_classes capability is obtained in the onload
3922 // phase then the compiler has recorded all dependencies from startup.
3923 // In that case we need only deoptimize and throw away all compiled code
3924 // that depends on the class.
3925 //
3926 // If can_redefine_classes is obtained sometime after the onload
3927 // phase then the dependency information may be incomplete. In that case
3928 // the first call to RedefineClasses causes all compiled code to be
3929 // thrown away. As can_redefine_classes has been obtained then
3930 // all future compilations will record dependencies so second and
3931 // subsequent calls to RedefineClasses need only throw away code
3932 // that depends on the class.
3933 //
3934 
3935 // First step is to walk the code cache for each class redefined and mark
3936 // dependent methods.  Wait until all classes are processed to deoptimize everything.
3937 void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {
3938   assert_locked_or_safepoint(Compile_lock);
3939 
3940   // All dependencies have been recorded from startup or this is a second or
3941   // subsequent use of RedefineClasses
3942   if (JvmtiExport::all_dependencies_are_recorded()) {
3943     CodeCache::mark_for_evol_deoptimization(ik);
3944   }
3945 }
3946 
3947 void VM_RedefineClasses::flush_dependent_code() {
3948   assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
3949 
3950   bool deopt_needed;
3951 
3952   // This is the first redefinition, mark all the nmethods for deoptimization
3953   if (!JvmtiExport::all_dependencies_are_recorded()) {
3954     log_debug(redefine, class, nmethod)(&quot;Marked all nmethods for deopt&quot;);
3955     CodeCache::mark_all_nmethods_for_evol_deoptimization();
3956     deopt_needed = true;
3957   } else {
3958     int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
3959     log_debug(redefine, class, nmethod)(&quot;Marked %d dependent nmethods for deopt&quot;, deopt);
3960     deopt_needed = (deopt != 0);
3961   }
3962 
3963   if (deopt_needed) {
3964     CodeCache::flush_evol_dependents();
3965   }
3966 
3967   // From now on we know that the dependency information is complete
3968   JvmtiExport::set_all_dependencies_are_recorded(true);
3969 }
3970 
3971 void VM_RedefineClasses::compute_added_deleted_matching_methods() {
3972   Method* old_method;
3973   Method* new_method;
3974 
3975   _matching_old_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
3976   _matching_new_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
3977   _added_methods        = NEW_RESOURCE_ARRAY(Method*, _new_methods-&gt;length());
3978   _deleted_methods      = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
3979 
3980   _matching_methods_length = 0;
3981   _deleted_methods_length  = 0;
3982   _added_methods_length    = 0;
3983 
3984   int nj = 0;
3985   int oj = 0;
3986   while (true) {
3987     if (oj &gt;= _old_methods-&gt;length()) {
3988       if (nj &gt;= _new_methods-&gt;length()) {
3989         break; // we&#39;ve looked at everything, done
3990       }
3991       // New method at the end
3992       new_method = _new_methods-&gt;at(nj);
3993       _added_methods[_added_methods_length++] = new_method;
3994       ++nj;
3995     } else if (nj &gt;= _new_methods-&gt;length()) {
3996       // Old method, at the end, is deleted
3997       old_method = _old_methods-&gt;at(oj);
3998       _deleted_methods[_deleted_methods_length++] = old_method;
3999       ++oj;
4000     } else {
4001       old_method = _old_methods-&gt;at(oj);
4002       new_method = _new_methods-&gt;at(nj);
4003       if (old_method-&gt;name() == new_method-&gt;name()) {
4004         if (old_method-&gt;signature() == new_method-&gt;signature()) {
4005           _matching_old_methods[_matching_methods_length  ] = old_method;
4006           _matching_new_methods[_matching_methods_length++] = new_method;
4007           ++nj;
4008           ++oj;
4009         } else {
4010           // added overloaded have already been moved to the end,
4011           // so this is a deleted overloaded method
4012           _deleted_methods[_deleted_methods_length++] = old_method;
4013           ++oj;
4014         }
4015       } else { // names don&#39;t match
4016         if (old_method-&gt;name()-&gt;fast_compare(new_method-&gt;name()) &gt; 0) {
4017           // new method
4018           _added_methods[_added_methods_length++] = new_method;
4019           ++nj;
4020         } else {
4021           // deleted method
4022           _deleted_methods[_deleted_methods_length++] = old_method;
4023           ++oj;
4024         }
4025       }
4026     }
4027   }
4028   assert(_matching_methods_length + _deleted_methods_length == _old_methods-&gt;length(), &quot;sanity&quot;);
4029   assert(_matching_methods_length + _added_methods_length == _new_methods-&gt;length(), &quot;sanity&quot;);
4030 }
4031 
4032 
4033 void VM_RedefineClasses::swap_annotations(InstanceKlass* the_class,
4034                                           InstanceKlass* scratch_class) {
4035   // Swap annotation fields values
4036   Annotations* old_annotations = the_class-&gt;annotations();
4037   the_class-&gt;set_annotations(scratch_class-&gt;annotations());
4038   scratch_class-&gt;set_annotations(old_annotations);
4039 }
4040 
4041 
4042 // Install the redefinition of a class:
4043 //    - house keeping (flushing breakpoints and caches, deoptimizing
4044 //      dependent compiled code)
4045 //    - replacing parts in the_class with parts from scratch_class
4046 //    - adding a weak reference to track the obsolete but interesting
4047 //      parts of the_class
4048 //    - adjusting constant pool caches and vtables in other classes
4049 //      that refer to methods in the_class. These adjustments use the
4050 //      ClassLoaderDataGraph::classes_do() facility which only allows
4051 //      a helper method to be specified. The interesting parameters
4052 //      that we would like to pass to the helper method are saved in
4053 //      static global fields in the VM operation.
4054 void VM_RedefineClasses::redefine_single_class(jclass the_jclass,
4055        InstanceKlass* scratch_class, TRAPS) {
4056 
4057   HandleMark hm(THREAD);   // make sure handles from this call are freed
4058 
4059   if (log_is_enabled(Info, redefine, class, timer)) {
4060     _timer_rsc_phase1.start();
4061   }
4062 
4063   InstanceKlass* the_class = get_ik(the_jclass);
4064 
4065   // Set some flags to control and optimize adjusting method entries
4066   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
4067   _has_null_class_loader |= the_class-&gt;class_loader() == NULL;
4068 
4069   // Remove all breakpoints in methods of this class
4070   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
4071   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
4072 
4073   // Mark all compiled code that depends on this class
4074   mark_dependent_code(the_class);
4075 
4076   _old_methods = the_class-&gt;methods();
4077   _new_methods = scratch_class-&gt;methods();
4078   _the_class = the_class;
4079   compute_added_deleted_matching_methods();
4080   update_jmethod_ids(THREAD);
4081 
4082   _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
4083 
4084   // Attach new constant pool to the original klass. The original
4085   // klass still refers to the old constant pool (for now).
4086   scratch_class-&gt;constants()-&gt;set_pool_holder(the_class);
4087 
4088 #if 0
4089   // In theory, with constant pool merging in place we should be able
4090   // to save space by using the new, merged constant pool in place of
4091   // the old constant pool(s). By &quot;pool(s)&quot; I mean the constant pool in
4092   // the klass version we are replacing now and any constant pool(s) in
4093   // previous versions of klass. Nice theory, doesn&#39;t work in practice.
4094   // When this code is enabled, even simple programs throw NullPointer
4095   // exceptions. I&#39;m guessing that this is caused by some constant pool
4096   // cache difference between the new, merged constant pool and the
4097   // constant pool that was just being used by the klass. I&#39;m keeping
4098   // this code around to archive the idea, but the code has to remain
4099   // disabled for now.
4100 
4101   // Attach each old method to the new constant pool. This can be
4102   // done here since we are past the bytecode verification and
4103   // constant pool optimization phases.
4104   for (int i = _old_methods-&gt;length() - 1; i &gt;= 0; i--) {
4105     Method* method = _old_methods-&gt;at(i);
4106     method-&gt;set_constants(scratch_class-&gt;constants());
4107   }
4108 
4109   // NOTE: this doesn&#39;t work because you can redefine the same class in two
4110   // threads, each getting their own constant pool data appended to the
4111   // original constant pool.  In order for the new methods to work when they
4112   // become old methods, they need to keep their updated copy of the constant pool.
4113 
4114   {
4115     // walk all previous versions of the klass
4116     InstanceKlass *ik = the_class;
4117     PreviousVersionWalker pvw(ik);
4118     do {
4119       ik = pvw.next_previous_version();
4120       if (ik != NULL) {
4121 
4122         // attach previous version of klass to the new constant pool
4123         ik-&gt;set_constants(scratch_class-&gt;constants());
4124 
4125         // Attach each method in the previous version of klass to the
4126         // new constant pool
4127         Array&lt;Method*&gt;* prev_methods = ik-&gt;methods();
4128         for (int i = prev_methods-&gt;length() - 1; i &gt;= 0; i--) {
4129           Method* method = prev_methods-&gt;at(i);
4130           method-&gt;set_constants(scratch_class-&gt;constants());
4131         }
4132       }
4133     } while (ik != NULL);
4134   }
4135 #endif
4136 
4137   // Replace methods and constantpool
4138   the_class-&gt;set_methods(_new_methods);
4139   scratch_class-&gt;set_methods(_old_methods);     // To prevent potential GCing of the old methods,
4140                                           // and to be able to undo operation easily.
4141 
4142   Array&lt;int&gt;* old_ordering = the_class-&gt;method_ordering();
4143   the_class-&gt;set_method_ordering(scratch_class-&gt;method_ordering());
4144   scratch_class-&gt;set_method_ordering(old_ordering);
4145 
4146   ConstantPool* old_constants = the_class-&gt;constants();
4147   the_class-&gt;set_constants(scratch_class-&gt;constants());
4148   scratch_class-&gt;set_constants(old_constants);  // See the previous comment.
4149 #if 0
4150   // We are swapping the guts of &quot;the new class&quot; with the guts of &quot;the
4151   // class&quot;. Since the old constant pool has just been attached to &quot;the
4152   // new class&quot;, it seems logical to set the pool holder in the old
4153   // constant pool also. However, doing this will change the observable
4154   // class hierarchy for any old methods that are still executing. A
4155   // method can query the identity of its &quot;holder&quot; and this query uses
4156   // the method&#39;s constant pool link to find the holder. The change in
4157   // holding class from &quot;the class&quot; to &quot;the new class&quot; can confuse
4158   // things.
4159   //
4160   // Setting the old constant pool&#39;s holder will also cause
4161   // verification done during vtable initialization below to fail.
4162   // During vtable initialization, the vtable&#39;s class is verified to be
4163   // a subtype of the method&#39;s holder. The vtable&#39;s class is &quot;the
4164   // class&quot; and the method&#39;s holder is gotten from the constant pool
4165   // link in the method itself. For &quot;the class&quot;&#39;s directly implemented
4166   // methods, the method holder is &quot;the class&quot; itself (as gotten from
4167   // the new constant pool). The check works fine in this case. The
4168   // check also works fine for methods inherited from super classes.
4169   //
4170   // Miranda methods are a little more complicated. A miranda method is
4171   // provided by an interface when the class implementing the interface
4172   // does not provide its own method.  These interfaces are implemented
4173   // internally as an InstanceKlass. These special instanceKlasses
4174   // share the constant pool of the class that &quot;implements&quot; the
4175   // interface. By sharing the constant pool, the method holder of a
4176   // miranda method is the class that &quot;implements&quot; the interface. In a
4177   // non-redefine situation, the subtype check works fine. However, if
4178   // the old constant pool&#39;s pool holder is modified, then the check
4179   // fails because there is no class hierarchy relationship between the
4180   // vtable&#39;s class and &quot;the new class&quot;.
4181 
4182   old_constants-&gt;set_pool_holder(scratch_class());
4183 #endif
4184 
4185   // track number of methods that are EMCP for add_previous_version() call below
4186   int emcp_method_count = check_methods_and_mark_as_obsolete();
4187   transfer_old_native_function_registrations(the_class);
4188 
4189   // The class file bytes from before any retransformable agents mucked
4190   // with them was cached on the scratch class, move to the_class.
4191   // Note: we still want to do this if nothing needed caching since it
4192   // should get cleared in the_class too.
4193   if (the_class-&gt;get_cached_class_file() == 0) {
4194     // the_class doesn&#39;t have a cache yet so copy it
4195     the_class-&gt;set_cached_class_file(scratch_class-&gt;get_cached_class_file());
4196   }
4197   else if (scratch_class-&gt;get_cached_class_file() !=
4198            the_class-&gt;get_cached_class_file()) {
4199     // The same class can be present twice in the scratch classes list or there
4200     // are multiple concurrent RetransformClasses calls on different threads.
4201     // In such cases we have to deallocate scratch_class cached_class_file.
4202     os::free(scratch_class-&gt;get_cached_class_file());
4203   }
4204 
4205   // NULL out in scratch class to not delete twice.  The class to be redefined
4206   // always owns these bytes.
4207   scratch_class-&gt;set_cached_class_file(NULL);
4208 
4209   // Replace inner_classes
4210   Array&lt;u2&gt;* old_inner_classes = the_class-&gt;inner_classes();
4211   the_class-&gt;set_inner_classes(scratch_class-&gt;inner_classes());
4212   scratch_class-&gt;set_inner_classes(old_inner_classes);
4213 
4214   // Initialize the vtable and interface table after
4215   // methods have been rewritten
4216   // no exception should happen here since we explicitly
4217   // do not check loader constraints.
4218   // compare_and_normalize_class_versions has already checked:
4219   //  - classloaders unchanged, signatures unchanged
4220   //  - all instanceKlasses for redefined classes reused &amp; contents updated
4221   the_class-&gt;vtable().initialize_vtable(false, THREAD);
4222   the_class-&gt;itable().initialize_itable(false, THREAD);
4223   assert(!HAS_PENDING_EXCEPTION || (THREAD-&gt;pending_exception()-&gt;is_a(SystemDictionary::ThreadDeath_klass())), &quot;redefine exception&quot;);
4224 
4225   // Leave arrays of jmethodIDs and itable index cache unchanged
4226 
4227   // Copy the &quot;source file name&quot; attribute from new class version
4228   the_class-&gt;set_source_file_name_index(
4229     scratch_class-&gt;source_file_name_index());
4230 
4231   // Copy the &quot;source debug extension&quot; attribute from new class version
4232   the_class-&gt;set_source_debug_extension(
4233     scratch_class-&gt;source_debug_extension(),
4234     scratch_class-&gt;source_debug_extension() == NULL ? 0 :
4235     (int)strlen(scratch_class-&gt;source_debug_extension()));
4236 
4237   // Use of javac -g could be different in the old and the new
4238   if (scratch_class-&gt;access_flags().has_localvariable_table() !=
4239       the_class-&gt;access_flags().has_localvariable_table()) {
4240 
4241     AccessFlags flags = the_class-&gt;access_flags();
4242     if (scratch_class-&gt;access_flags().has_localvariable_table()) {
4243       flags.set_has_localvariable_table();
4244     } else {
4245       flags.clear_has_localvariable_table();
4246     }
4247     the_class-&gt;set_access_flags(flags);
4248   }
4249 
4250   swap_annotations(the_class, scratch_class);
4251 
4252   // Replace minor version number of class file
4253   u2 old_minor_version = the_class-&gt;minor_version();
4254   the_class-&gt;set_minor_version(scratch_class-&gt;minor_version());
4255   scratch_class-&gt;set_minor_version(old_minor_version);
4256 
4257   // Replace major version number of class file
4258   u2 old_major_version = the_class-&gt;major_version();
4259   the_class-&gt;set_major_version(scratch_class-&gt;major_version());
4260   scratch_class-&gt;set_major_version(old_major_version);
4261 
4262   // Replace CP indexes for class and name+type of enclosing method
4263   u2 old_class_idx  = the_class-&gt;enclosing_method_class_index();
4264   u2 old_method_idx = the_class-&gt;enclosing_method_method_index();
4265   the_class-&gt;set_enclosing_method_indices(
4266     scratch_class-&gt;enclosing_method_class_index(),
4267     scratch_class-&gt;enclosing_method_method_index());
4268   scratch_class-&gt;set_enclosing_method_indices(old_class_idx, old_method_idx);
4269 
4270   // Replace fingerprint data
4271   the_class-&gt;set_has_passed_fingerprint_check(scratch_class-&gt;has_passed_fingerprint_check());
4272   the_class-&gt;store_fingerprint(scratch_class-&gt;get_stored_fingerprint());
4273 
4274   the_class-&gt;set_has_been_redefined();
4275 
4276   if (!the_class-&gt;should_be_initialized()) {
4277     // Class was already initialized, so AOT has only seen the original version.
4278     // We need to let AOT look at it again.
4279     AOTLoader::load_for_klass(the_class, THREAD);
4280   }
4281 
4282   // keep track of previous versions of this class
4283   the_class-&gt;add_previous_version(scratch_class, emcp_method_count);
4284 
4285   _timer_rsc_phase1.stop();
4286   if (log_is_enabled(Info, redefine, class, timer)) {
4287     _timer_rsc_phase2.start();
4288   }
4289 
4290   if (the_class-&gt;oop_map_cache() != NULL) {
4291     // Flush references to any obsolete methods from the oop map cache
4292     // so that obsolete methods are not pinned.
4293     the_class-&gt;oop_map_cache()-&gt;flush_obsolete_entries();
4294   }
4295 
4296   increment_class_counter((InstanceKlass *)the_class, THREAD);
<a name="6" id="anc6"></a>








4297   {
4298     ResourceMark rm(THREAD);
4299     // increment the classRedefinedCount field in the_class and in any
4300     // direct and indirect subclasses of the_class
4301     log_info(redefine, class, load)
4302       (&quot;redefined name=%s, count=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
4303        the_class-&gt;external_name(), java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()), os::available_memory() &gt;&gt; 10);
4304     Events::log_redefinition(THREAD, &quot;redefined class name=%s, count=%d&quot;,
4305                              the_class-&gt;external_name(),
4306                              java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4307 
4308   }
4309   _timer_rsc_phase2.stop();
<a name="7" id="anc7"></a>
4310 } // end redefine_single_class()
4311 
4312 
4313 // Increment the classRedefinedCount field in the specific InstanceKlass
4314 // and in all direct and indirect subclasses.
4315 void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik, TRAPS) {
4316   oop class_mirror = ik-&gt;java_mirror();
4317   Klass* class_oop = java_lang_Class::as_Klass(class_mirror);
4318   int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;
4319   java_lang_Class::set_classRedefinedCount(class_mirror, new_count);
4320 
4321   if (class_oop != _the_class) {
4322     // _the_class count is printed at end of redefine_single_class()
4323     log_debug(redefine, class, subclass)(&quot;updated count in subclass=%s to %d&quot;, ik-&gt;external_name(), new_count);
4324   }
4325 
4326   for (Klass *subk = ik-&gt;subklass(); subk != NULL;
4327        subk = subk-&gt;next_sibling()) {
4328     if (subk-&gt;is_instance_klass()) {
4329       // Only update instanceKlasses
4330       InstanceKlass *subik = InstanceKlass::cast(subk);
4331       // recursively do subclasses of the current subclass
4332       increment_class_counter(subik, THREAD);
4333     }
4334   }
4335 }
4336 
4337 void VM_RedefineClasses::CheckClass::do_klass(Klass* k) {
4338   bool no_old_methods = true;  // be optimistic
4339 
4340   // Both array and instance classes have vtables.
4341   // a vtable should never contain old or obsolete methods
4342   ResourceMark rm(_thread);
4343   if (k-&gt;vtable_length() &gt; 0 &amp;&amp;
4344       !k-&gt;vtable().check_no_old_or_obsolete_entries()) {
4345     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4346       log_trace(redefine, class, obsolete, metadata)
4347         (&quot;klassVtable::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4348          k-&gt;signature_name());
4349       k-&gt;vtable().dump_vtable();
4350     }
4351     no_old_methods = false;
4352   }
4353 
4354   if (k-&gt;is_instance_klass()) {
4355     HandleMark hm(_thread);
4356     InstanceKlass *ik = InstanceKlass::cast(k);
4357 
4358     // an itable should never contain old or obsolete methods
4359     if (ik-&gt;itable_length() &gt; 0 &amp;&amp;
4360         !ik-&gt;itable().check_no_old_or_obsolete_entries()) {
4361       if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4362         log_trace(redefine, class, obsolete, metadata)
4363           (&quot;klassItable::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4364            ik-&gt;signature_name());
4365         ik-&gt;itable().dump_itable();
4366       }
4367       no_old_methods = false;
4368     }
4369 
4370     // the constant pool cache should never contain non-deleted old or obsolete methods
4371     if (ik-&gt;constants() != NULL &amp;&amp;
4372         ik-&gt;constants()-&gt;cache() != NULL &amp;&amp;
4373         !ik-&gt;constants()-&gt;cache()-&gt;check_no_old_or_obsolete_entries()) {
4374       if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4375         log_trace(redefine, class, obsolete, metadata)
4376           (&quot;cp-cache::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4377            ik-&gt;signature_name());
4378         ik-&gt;constants()-&gt;cache()-&gt;dump_cache();
4379       }
4380       no_old_methods = false;
4381     }
4382   }
4383 
4384   // print and fail guarantee if old methods are found.
4385   if (!no_old_methods) {
4386     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4387       dump_methods();
4388     } else {
4389       log_trace(redefine, class)(&quot;Use the &#39;-Xlog:redefine+class*:&#39; option &quot;
4390         &quot;to see more info about the following guarantee() failure.&quot;);
4391     }
4392     guarantee(false, &quot;OLD and/or OBSOLETE method(s) found&quot;);
4393   }
4394 }
4395 
<a name="8" id="anc8"></a>









4396 
4397 void VM_RedefineClasses::dump_methods() {
4398   int j;
4399   log_trace(redefine, class, dump)(&quot;_old_methods --&quot;);
4400   for (j = 0; j &lt; _old_methods-&gt;length(); ++j) {
4401     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4402     Method* m = _old_methods-&gt;at(j);
4403     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4404     m-&gt;access_flags().print_on(&amp;log_stream);
4405     log_stream.print(&quot; --  &quot;);
4406     m-&gt;print_name(&amp;log_stream);
4407     log_stream.cr();
4408   }
4409   log_trace(redefine, class, dump)(&quot;_new_methods --&quot;);
4410   for (j = 0; j &lt; _new_methods-&gt;length(); ++j) {
4411     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4412     Method* m = _new_methods-&gt;at(j);
4413     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4414     m-&gt;access_flags().print_on(&amp;log_stream);
4415     log_stream.print(&quot; --  &quot;);
4416     m-&gt;print_name(&amp;log_stream);
4417     log_stream.cr();
4418   }
4419   log_trace(redefine, class, dump)(&quot;_matching_methods --&quot;);
4420   for (j = 0; j &lt; _matching_methods_length; ++j) {
4421     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4422     Method* m = _matching_old_methods[j];
4423     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4424     m-&gt;access_flags().print_on(&amp;log_stream);
4425     log_stream.print(&quot; --  &quot;);
4426     m-&gt;print_name();
4427     log_stream.cr();
4428 
4429     m = _matching_new_methods[j];
4430     log_stream.print(&quot;      (%5d)  &quot;, m-&gt;vtable_index());
4431     m-&gt;access_flags().print_on(&amp;log_stream);
4432     log_stream.cr();
4433   }
4434   log_trace(redefine, class, dump)(&quot;_deleted_methods --&quot;);
4435   for (j = 0; j &lt; _deleted_methods_length; ++j) {
4436     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4437     Method* m = _deleted_methods[j];
4438     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4439     m-&gt;access_flags().print_on(&amp;log_stream);
4440     log_stream.print(&quot; --  &quot;);
4441     m-&gt;print_name(&amp;log_stream);
4442     log_stream.cr();
4443   }
4444   log_trace(redefine, class, dump)(&quot;_added_methods --&quot;);
4445   for (j = 0; j &lt; _added_methods_length; ++j) {
4446     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4447     Method* m = _added_methods[j];
4448     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4449     m-&gt;access_flags().print_on(&amp;log_stream);
4450     log_stream.print(&quot; --  &quot;);
4451     m-&gt;print_name(&amp;log_stream);
4452     log_stream.cr();
4453   }
4454 }
4455 
4456 void VM_RedefineClasses::print_on_error(outputStream* st) const {
4457   VM_Operation::print_on_error(st);
4458   if (_the_class != NULL) {
4459     ResourceMark rm;
4460     st-&gt;print_cr(&quot;, redefining class %s&quot;, _the_class-&gt;external_name());
4461   }
4462 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
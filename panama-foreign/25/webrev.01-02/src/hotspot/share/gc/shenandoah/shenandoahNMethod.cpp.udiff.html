<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../z/zAddress.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -235,19 +235,41 @@</span>
    ShenandoahNMethodOopDetector detector;
    nm()-&gt;oops_do(&amp;detector, allow_dead);
  
    GrowableArray&lt;oop*&gt;* oops = detector.oops();
  
<span class="udiff-line-modified-removed">-   assert(oops-&gt;length() == oop_count(), &quot;Must match&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   int count = _oops_count;</span>
    for (int index = 0; index &lt; _oops_count; index ++) {
      assert(oops-&gt;contains(_oops[index]), &quot;Must contain this oop&quot;);
    }
  
    for (oop* p = nm()-&gt;oops_begin(); p &lt; nm()-&gt;oops_end(); p ++) {
<span class="udiff-line-added">+     if (*p == Universe::non_oop_word()) continue;</span>
<span class="udiff-line-added">+     count++;</span>
      assert(oops-&gt;contains(p), &quot;Must contain this oop&quot;);
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (oops-&gt;length() &lt; count) {</span>
<span class="udiff-line-added">+     stringStream debug_stream;</span>
<span class="udiff-line-added">+     debug_stream.print_cr(&quot;detected locs: %d&quot;, oops-&gt;length());</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; oops-&gt;length(); i++) {</span>
<span class="udiff-line-added">+       debug_stream.print_cr(&quot;-&gt; &quot; PTR_FORMAT, p2i(oops-&gt;at(i)));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     debug_stream.print_cr(&quot;recorded oops: %d&quot;, _oops_count);</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; _oops_count; i++) {</span>
<span class="udiff-line-added">+       debug_stream.print_cr(&quot;-&gt; &quot; PTR_FORMAT, p2i(_oops[i]));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     GrowableArray&lt;oop*&gt; check;</span>
<span class="udiff-line-added">+     bool non_immed;</span>
<span class="udiff-line-added">+     detect_reloc_oops(nm(), check, non_immed);</span>
<span class="udiff-line-added">+     debug_stream.print_cr(&quot;check oops: %d&quot;, check.length());</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; check.length(); i++) {</span>
<span class="udiff-line-added">+       debug_stream.print_cr(&quot;-&gt; &quot; PTR_FORMAT, p2i(check.at(i)));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     fatal(&quot;Must match #detected: %d, #recorded: %d, #total: %d, begin: &quot; PTR_FORMAT &quot;, end: &quot; PTR_FORMAT &quot;\n%s&quot;,</span>
<span class="udiff-line-added">+           oops-&gt;length(), _oops_count, count, p2i(nm()-&gt;oops_begin()), p2i(nm()-&gt;oops_end()), debug_stream.as_string());</span>
<span class="udiff-line-added">+   }</span>
  }
  
  void ShenandoahNMethod::assert_no_oops(nmethod* nm, bool allow_dead) {
    ShenandoahNMethodOopDetector detector;
    nm-&gt;oops_do(&amp;detector, allow_dead);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -275,10 +297,11 @@</span>
    ShenandoahNMethod* data = ShenandoahNMethod::gc_data(nm);
    ShenandoahReentrantLocker data_locker(data != NULL ? data-&gt;lock() : NULL);
  
    if (data != NULL) {
      assert(contain(nm), &quot;Must have been registered&quot;);
<span class="udiff-line-added">+     assert(nm == data-&gt;nm(), &quot;Must be same nmethod&quot;);</span>
      data-&gt;update();
    } else {
      data = ShenandoahNMethod::for_nmethod(nm);
      if (data == NULL) {
        assert(!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading(),
</pre>
<center><a href="shenandoahHeap.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../z/zAddress.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;
  33 #include &quot;ci/ciKlass.hpp&quot;
  34 #include &quot;ci/ciMemberName.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;
  36 #include &quot;compiler/compilationPolicy.hpp&quot;
  37 #include &quot;compiler/compileBroker.hpp&quot;
  38 #include &quot;interpreter/bytecode.hpp&quot;
  39 #include &quot;jfr/jfrEvents.hpp&quot;
  40 #include &quot;memory/resourceArea.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;runtime/vm_version.hpp&quot;
  44 #include &quot;utilities/bitMap.inline.hpp&quot;
<a name="1" id="anc1"></a>
  45 
  46 class BlockListBuilder {
  47  private:
  48   Compilation* _compilation;
  49   IRScope*     _scope;
  50 
  51   BlockList    _blocks;                // internal list of all blocks
  52   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  53 
  54   // fields used by mark_loops
  55   ResourceBitMap _active;              // for iteration of control flow graph
  56   ResourceBitMap _visited;             // for iteration of control flow graph
  57   intArray       _loop_map;            // caches the information if a block is contained in a loop
  58   int            _next_loop_index;     // next free loop number
  59   int            _next_block_number;   // for reverse postorder numbering of blocks
  60 
  61   // accessors
  62   Compilation*  compilation() const              { return _compilation; }
  63   IRScope*      scope() const                    { return _scope; }
  64   ciMethod*     method() const                   { return scope()-&gt;method(); }
  65   XHandlers*    xhandlers() const                { return scope()-&gt;xhandlers(); }
  66 
  67   // unified bailout support
  68   void          bailout(const char* msg) const   { compilation()-&gt;bailout(msg); }
  69   bool          bailed_out() const               { return compilation()-&gt;bailed_out(); }
  70 
  71   // helper functions
  72   BlockBegin* make_block_at(int bci, BlockBegin* predecessor);
  73   void handle_exceptions(BlockBegin* current, int cur_bci);
  74   void handle_jsr(BlockBegin* current, int sr_bci, int next_bci);
  75   void store_one(BlockBegin* current, int local);
  76   void store_two(BlockBegin* current, int local);
  77   void set_entries(int osr_bci);
  78   void set_leaders();
  79 
  80   void make_loop_header(BlockBegin* block);
  81   void mark_loops();
  82   int  mark_loops(BlockBegin* b, bool in_subroutine);
  83 
  84   // debugging
  85 #ifndef PRODUCT
  86   void print();
  87 #endif
  88 
  89  public:
  90   // creation
  91   BlockListBuilder(Compilation* compilation, IRScope* scope, int osr_bci);
  92 
  93   // accessors for GraphBuilder
  94   BlockList*    bci2block() const                { return _bci2block; }
  95 };
  96 
  97 
  98 // Implementation of BlockListBuilder
  99 
 100 BlockListBuilder::BlockListBuilder(Compilation* compilation, IRScope* scope, int osr_bci)
 101  : _compilation(compilation)
 102  , _scope(scope)
 103  , _blocks(16)
 104  , _bci2block(new BlockList(scope-&gt;method()-&gt;code_size(), NULL))
 105  , _active()         // size not known yet
 106  , _visited()        // size not known yet
 107  , _loop_map() // size not known yet
 108  , _next_loop_index(0)
 109  , _next_block_number(0)
 110 {
 111   set_entries(osr_bci);
 112   set_leaders();
 113   CHECK_BAILOUT();
 114 
 115   mark_loops();
 116   NOT_PRODUCT(if (PrintInitialBlockList) print());
 117 
 118 #ifndef PRODUCT
 119   if (PrintCFGToFile) {
 120     stringStream title;
 121     title.print(&quot;BlockListBuilder &quot;);
 122     scope-&gt;method()-&gt;print_name(&amp;title);
 123     CFGPrinter::print_cfg(_bci2block, title.as_string(), false, false);
 124   }
 125 #endif
 126 }
 127 
 128 
 129 void BlockListBuilder::set_entries(int osr_bci) {
 130   // generate start blocks
 131   BlockBegin* std_entry = make_block_at(0, NULL);
 132   if (scope()-&gt;caller() == NULL) {
 133     std_entry-&gt;set(BlockBegin::std_entry_flag);
 134   }
 135   if (osr_bci != -1) {
 136     BlockBegin* osr_entry = make_block_at(osr_bci, NULL);
 137     osr_entry-&gt;set(BlockBegin::osr_entry_flag);
 138   }
 139 
 140   // generate exception entry blocks
 141   XHandlers* list = xhandlers();
 142   const int n = list-&gt;length();
 143   for (int i = 0; i &lt; n; i++) {
 144     XHandler* h = list-&gt;handler_at(i);
 145     BlockBegin* entry = make_block_at(h-&gt;handler_bci(), NULL);
 146     entry-&gt;set(BlockBegin::exception_entry_flag);
 147     h-&gt;set_entry_block(entry);
 148   }
 149 }
 150 
 151 
 152 BlockBegin* BlockListBuilder::make_block_at(int cur_bci, BlockBegin* predecessor) {
 153   assert(method()-&gt;bci_block_start().at(cur_bci), &quot;wrong block starts of MethodLivenessAnalyzer&quot;);
 154 
 155   BlockBegin* block = _bci2block-&gt;at(cur_bci);
 156   if (block == NULL) {
 157     block = new BlockBegin(cur_bci);
 158     block-&gt;init_stores_to_locals(method()-&gt;max_locals());
 159     _bci2block-&gt;at_put(cur_bci, block);
 160     _blocks.append(block);
 161 
 162     assert(predecessor == NULL || predecessor-&gt;bci() &lt; cur_bci, &quot;targets for backward branches must already exist&quot;);
 163   }
 164 
 165   if (predecessor != NULL) {
 166     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 167       BAILOUT_(&quot;Exception handler can be reached by both normal and exceptional control flow&quot;, block);
 168     }
 169 
 170     predecessor-&gt;add_successor(block);
 171     block-&gt;increment_total_preds();
 172   }
 173 
 174   return block;
 175 }
 176 
 177 
 178 inline void BlockListBuilder::store_one(BlockBegin* current, int local) {
 179   current-&gt;stores_to_locals().set_bit(local);
 180 }
 181 inline void BlockListBuilder::store_two(BlockBegin* current, int local) {
 182   store_one(current, local);
 183   store_one(current, local + 1);
 184 }
 185 
 186 
 187 void BlockListBuilder::handle_exceptions(BlockBegin* current, int cur_bci) {
 188   // Draws edges from a block to its exception handlers
 189   XHandlers* list = xhandlers();
 190   const int n = list-&gt;length();
 191 
 192   for (int i = 0; i &lt; n; i++) {
 193     XHandler* h = list-&gt;handler_at(i);
 194 
 195     if (h-&gt;covers(cur_bci)) {
 196       BlockBegin* entry = h-&gt;entry_block();
 197       assert(entry != NULL &amp;&amp; entry == _bci2block-&gt;at(h-&gt;handler_bci()), &quot;entry must be set&quot;);
 198       assert(entry-&gt;is_set(BlockBegin::exception_entry_flag), &quot;flag must be set&quot;);
 199 
 200       // add each exception handler only once
 201       if (!current-&gt;is_successor(entry)) {
 202         current-&gt;add_successor(entry);
 203         entry-&gt;increment_total_preds();
 204       }
 205 
 206       // stop when reaching catchall
 207       if (h-&gt;catch_type() == 0) break;
 208     }
 209   }
 210 }
 211 
 212 void BlockListBuilder::handle_jsr(BlockBegin* current, int sr_bci, int next_bci) {
 213   // start a new block after jsr-bytecode and link this block into cfg
 214   make_block_at(next_bci, current);
 215 
 216   // start a new block at the subroutine entry at mark it with special flag
 217   BlockBegin* sr_block = make_block_at(sr_bci, current);
 218   if (!sr_block-&gt;is_set(BlockBegin::subroutine_entry_flag)) {
 219     sr_block-&gt;set(BlockBegin::subroutine_entry_flag);
 220   }
 221 }
 222 
 223 
 224 void BlockListBuilder::set_leaders() {
 225   bool has_xhandlers = xhandlers()-&gt;has_handlers();
 226   BlockBegin* current = NULL;
 227 
 228   // The information which bci starts a new block simplifies the analysis
 229   // Without it, backward branches could jump to a bci where no block was created
 230   // during bytecode iteration. This would require the creation of a new block at the
 231   // branch target and a modification of the successor lists.
 232   const BitMap&amp; bci_block_start = method()-&gt;bci_block_start();
 233 
 234   ciBytecodeStream s(method());
 235   while (s.next() != ciBytecodeStream::EOBC()) {
 236     int cur_bci = s.cur_bci();
 237 
 238     if (bci_block_start.at(cur_bci)) {
 239       current = make_block_at(cur_bci, current);
 240     }
 241     assert(current != NULL, &quot;must have current block&quot;);
 242 
 243     if (has_xhandlers &amp;&amp; GraphBuilder::can_trap(method(), s.cur_bc())) {
 244       handle_exceptions(current, cur_bci);
 245     }
 246 
 247     switch (s.cur_bc()) {
 248       // track stores to local variables for selective creation of phi functions
 249       case Bytecodes::_iinc:     store_one(current, s.get_index()); break;
 250       case Bytecodes::_istore:   store_one(current, s.get_index()); break;
 251       case Bytecodes::_lstore:   store_two(current, s.get_index()); break;
 252       case Bytecodes::_fstore:   store_one(current, s.get_index()); break;
 253       case Bytecodes::_dstore:   store_two(current, s.get_index()); break;
 254       case Bytecodes::_astore:   store_one(current, s.get_index()); break;
 255       case Bytecodes::_istore_0: store_one(current, 0); break;
 256       case Bytecodes::_istore_1: store_one(current, 1); break;
 257       case Bytecodes::_istore_2: store_one(current, 2); break;
 258       case Bytecodes::_istore_3: store_one(current, 3); break;
 259       case Bytecodes::_lstore_0: store_two(current, 0); break;
 260       case Bytecodes::_lstore_1: store_two(current, 1); break;
 261       case Bytecodes::_lstore_2: store_two(current, 2); break;
 262       case Bytecodes::_lstore_3: store_two(current, 3); break;
 263       case Bytecodes::_fstore_0: store_one(current, 0); break;
 264       case Bytecodes::_fstore_1: store_one(current, 1); break;
 265       case Bytecodes::_fstore_2: store_one(current, 2); break;
 266       case Bytecodes::_fstore_3: store_one(current, 3); break;
 267       case Bytecodes::_dstore_0: store_two(current, 0); break;
 268       case Bytecodes::_dstore_1: store_two(current, 1); break;
 269       case Bytecodes::_dstore_2: store_two(current, 2); break;
 270       case Bytecodes::_dstore_3: store_two(current, 3); break;
 271       case Bytecodes::_astore_0: store_one(current, 0); break;
 272       case Bytecodes::_astore_1: store_one(current, 1); break;
 273       case Bytecodes::_astore_2: store_one(current, 2); break;
 274       case Bytecodes::_astore_3: store_one(current, 3); break;
 275 
 276       // track bytecodes that affect the control flow
 277       case Bytecodes::_athrow:  // fall through
 278       case Bytecodes::_ret:     // fall through
 279       case Bytecodes::_ireturn: // fall through
 280       case Bytecodes::_lreturn: // fall through
 281       case Bytecodes::_freturn: // fall through
 282       case Bytecodes::_dreturn: // fall through
 283       case Bytecodes::_areturn: // fall through
 284       case Bytecodes::_return:
 285         current = NULL;
 286         break;
 287 
 288       case Bytecodes::_ifeq:      // fall through
 289       case Bytecodes::_ifne:      // fall through
 290       case Bytecodes::_iflt:      // fall through
 291       case Bytecodes::_ifge:      // fall through
 292       case Bytecodes::_ifgt:      // fall through
 293       case Bytecodes::_ifle:      // fall through
 294       case Bytecodes::_if_icmpeq: // fall through
 295       case Bytecodes::_if_icmpne: // fall through
 296       case Bytecodes::_if_icmplt: // fall through
 297       case Bytecodes::_if_icmpge: // fall through
 298       case Bytecodes::_if_icmpgt: // fall through
 299       case Bytecodes::_if_icmple: // fall through
 300       case Bytecodes::_if_acmpeq: // fall through
 301       case Bytecodes::_if_acmpne: // fall through
 302       case Bytecodes::_ifnull:    // fall through
 303       case Bytecodes::_ifnonnull:
 304         make_block_at(s.next_bci(), current);
 305         make_block_at(s.get_dest(), current);
 306         current = NULL;
 307         break;
 308 
 309       case Bytecodes::_goto:
 310         make_block_at(s.get_dest(), current);
 311         current = NULL;
 312         break;
 313 
 314       case Bytecodes::_goto_w:
 315         make_block_at(s.get_far_dest(), current);
 316         current = NULL;
 317         break;
 318 
 319       case Bytecodes::_jsr:
 320         handle_jsr(current, s.get_dest(), s.next_bci());
 321         current = NULL;
 322         break;
 323 
 324       case Bytecodes::_jsr_w:
 325         handle_jsr(current, s.get_far_dest(), s.next_bci());
 326         current = NULL;
 327         break;
 328 
 329       case Bytecodes::_tableswitch: {
 330         // set block for each case
 331         Bytecode_tableswitch sw(&amp;s);
 332         int l = sw.length();
 333         for (int i = 0; i &lt; l; i++) {
 334           make_block_at(cur_bci + sw.dest_offset_at(i), current);
 335         }
 336         make_block_at(cur_bci + sw.default_offset(), current);
 337         current = NULL;
 338         break;
 339       }
 340 
 341       case Bytecodes::_lookupswitch: {
 342         // set block for each case
 343         Bytecode_lookupswitch sw(&amp;s);
 344         int l = sw.number_of_pairs();
 345         for (int i = 0; i &lt; l; i++) {
 346           make_block_at(cur_bci + sw.pair_at(i).offset(), current);
 347         }
 348         make_block_at(cur_bci + sw.default_offset(), current);
 349         current = NULL;
 350         break;
 351       }
 352 
 353       default:
 354         break;
 355     }
 356   }
 357 }
 358 
 359 
 360 void BlockListBuilder::mark_loops() {
 361   ResourceMark rm;
 362 
 363   _active.initialize(BlockBegin::number_of_blocks());
 364   _visited.initialize(BlockBegin::number_of_blocks());
 365   _loop_map = intArray(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), 0);
 366   _next_loop_index = 0;
 367   _next_block_number = _blocks.length();
 368 
 369   // recursively iterate the control flow graph
 370   mark_loops(_bci2block-&gt;at(0), false);
 371   assert(_next_block_number &gt;= 0, &quot;invalid block numbers&quot;);
 372 
 373   // Remove dangling Resource pointers before the ResourceMark goes out-of-scope.
 374   _active.resize(0);
 375   _visited.resize(0);
 376 }
 377 
 378 void BlockListBuilder::make_loop_header(BlockBegin* block) {
 379   if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 380     // exception edges may look like loops but don&#39;t mark them as such
 381     // since it screws up block ordering.
 382     return;
 383   }
 384   if (!block-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
 385     block-&gt;set(BlockBegin::parser_loop_header_flag);
 386 
 387     assert(_loop_map.at(block-&gt;block_id()) == 0, &quot;must not be set yet&quot;);
 388     assert(0 &lt;= _next_loop_index &amp;&amp; _next_loop_index &lt; BitsPerInt, &quot;_next_loop_index is used as a bit-index in integer&quot;);
 389     _loop_map.at_put(block-&gt;block_id(), 1 &lt;&lt; _next_loop_index);
 390     if (_next_loop_index &lt; 31) _next_loop_index++;
 391   } else {
 392     // block already marked as loop header
 393     assert(is_power_of_2((unsigned int)_loop_map.at(block-&gt;block_id())), &quot;exactly one bit must be set&quot;);
 394   }
 395 }
 396 
 397 int BlockListBuilder::mark_loops(BlockBegin* block, bool in_subroutine) {
 398   int block_id = block-&gt;block_id();
 399 
 400   if (_visited.at(block_id)) {
 401     if (_active.at(block_id)) {
 402       // reached block via backward branch
 403       make_loop_header(block);
 404     }
 405     // return cached loop information for this block
 406     return _loop_map.at(block_id);
 407   }
 408 
 409   if (block-&gt;is_set(BlockBegin::subroutine_entry_flag)) {
 410     in_subroutine = true;
 411   }
 412 
 413   // set active and visited bits before successors are processed
 414   _visited.set_bit(block_id);
 415   _active.set_bit(block_id);
 416 
 417   intptr_t loop_state = 0;
 418   for (int i = block-&gt;number_of_sux() - 1; i &gt;= 0; i--) {
 419     // recursively process all successors
 420     loop_state |= mark_loops(block-&gt;sux_at(i), in_subroutine);
 421   }
 422 
 423   // clear active-bit after all successors are processed
 424   _active.clear_bit(block_id);
 425 
 426   // reverse-post-order numbering of all blocks
 427   block-&gt;set_depth_first_number(_next_block_number);
 428   _next_block_number--;
 429 
 430   if (loop_state != 0 || in_subroutine ) {
 431     // block is contained at least in one loop, so phi functions are necessary
 432     // phi functions are also necessary for all locals stored in a subroutine
 433     scope()-&gt;requires_phi_function().set_union(block-&gt;stores_to_locals());
 434   }
 435 
 436   if (block-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
 437     int header_loop_state = _loop_map.at(block_id);
 438     assert(is_power_of_2((unsigned)header_loop_state), &quot;exactly one bit must be set&quot;);
 439 
 440     // If the highest bit is set (i.e. when integer value is negative), the method
 441     // has 32 or more loops. This bit is never cleared because it is used for multiple loops
 442     if (header_loop_state &gt;= 0) {
 443       clear_bits(loop_state, header_loop_state);
 444     }
 445   }
 446 
 447   // cache and return loop information for this block
 448   _loop_map.at_put(block_id, loop_state);
 449   return loop_state;
 450 }
 451 
 452 
 453 #ifndef PRODUCT
 454 
 455 int compare_depth_first(BlockBegin** a, BlockBegin** b) {
 456   return (*a)-&gt;depth_first_number() - (*b)-&gt;depth_first_number();
 457 }
 458 
 459 void BlockListBuilder::print() {
 460   tty-&gt;print(&quot;----- initial block list of BlockListBuilder for method &quot;);
 461   method()-&gt;print_short_name();
 462   tty-&gt;cr();
 463 
 464   // better readability if blocks are sorted in processing order
 465   _blocks.sort(compare_depth_first);
 466 
 467   for (int i = 0; i &lt; _blocks.length(); i++) {
 468     BlockBegin* cur = _blocks.at(i);
 469     tty-&gt;print(&quot;%4d: B%-4d bci: %-4d  preds: %-4d &quot;, cur-&gt;depth_first_number(), cur-&gt;block_id(), cur-&gt;bci(), cur-&gt;total_preds());
 470 
 471     tty-&gt;print(cur-&gt;is_set(BlockBegin::std_entry_flag)               ? &quot; std&quot; : &quot;    &quot;);
 472     tty-&gt;print(cur-&gt;is_set(BlockBegin::osr_entry_flag)               ? &quot; osr&quot; : &quot;    &quot;);
 473     tty-&gt;print(cur-&gt;is_set(BlockBegin::exception_entry_flag)         ? &quot; ex&quot; : &quot;   &quot;);
 474     tty-&gt;print(cur-&gt;is_set(BlockBegin::subroutine_entry_flag)        ? &quot; sr&quot; : &quot;   &quot;);
 475     tty-&gt;print(cur-&gt;is_set(BlockBegin::parser_loop_header_flag)      ? &quot; lh&quot; : &quot;   &quot;);
 476 
 477     if (cur-&gt;number_of_sux() &gt; 0) {
 478       tty-&gt;print(&quot;    sux: &quot;);
 479       for (int j = 0; j &lt; cur-&gt;number_of_sux(); j++) {
 480         BlockBegin* sux = cur-&gt;sux_at(j);
 481         tty-&gt;print(&quot;B%d &quot;, sux-&gt;block_id());
 482       }
 483     }
 484     tty-&gt;cr();
 485   }
 486 }
 487 
 488 #endif
 489 
 490 
 491 // A simple growable array of Values indexed by ciFields
 492 class FieldBuffer: public CompilationResourceObj {
 493  private:
 494   GrowableArray&lt;Value&gt; _values;
 495 
 496  public:
 497   FieldBuffer() {}
 498 
 499   void kill() {
 500     _values.trunc_to(0);
 501   }
 502 
 503   Value at(ciField* field) {
 504     assert(field-&gt;holder()-&gt;is_loaded(), &quot;must be a loaded field&quot;);
 505     int offset = field-&gt;offset();
 506     if (offset &lt; _values.length()) {
 507       return _values.at(offset);
 508     } else {
 509       return NULL;
 510     }
 511   }
 512 
 513   void at_put(ciField* field, Value value) {
 514     assert(field-&gt;holder()-&gt;is_loaded(), &quot;must be a loaded field&quot;);
 515     int offset = field-&gt;offset();
 516     _values.at_put_grow(offset, value, NULL);
 517   }
 518 
 519 };
 520 
 521 
 522 // MemoryBuffer is fairly simple model of the current state of memory.
 523 // It partitions memory into several pieces.  The first piece is
 524 // generic memory where little is known about the owner of the memory.
 525 // This is conceptually represented by the tuple &lt;O, F, V&gt; which says
 526 // that the field F of object O has value V.  This is flattened so
 527 // that F is represented by the offset of the field and the parallel
 528 // arrays _objects and _values are used for O and V.  Loads of O.F can
 529 // simply use V.  Newly allocated objects are kept in a separate list
 530 // along with a parallel array for each object which represents the
 531 // current value of its fields.  Stores of the default value to fields
 532 // which have never been stored to before are eliminated since they
 533 // are redundant.  Once newly allocated objects are stored into
 534 // another object or they are passed out of the current compile they
 535 // are treated like generic memory.
 536 
 537 class MemoryBuffer: public CompilationResourceObj {
 538  private:
 539   FieldBuffer                 _values;
 540   GrowableArray&lt;Value&gt;        _objects;
 541   GrowableArray&lt;Value&gt;        _newobjects;
 542   GrowableArray&lt;FieldBuffer*&gt; _fields;
 543 
 544  public:
 545   MemoryBuffer() {}
 546 
 547   StoreField* store(StoreField* st) {
 548     if (!EliminateFieldAccess) {
 549       return st;
 550     }
 551 
 552     Value object = st-&gt;obj();
 553     Value value = st-&gt;value();
 554     ciField* field = st-&gt;field();
 555     if (field-&gt;holder()-&gt;is_loaded()) {
 556       int offset = field-&gt;offset();
 557       int index = _newobjects.find(object);
 558       if (index != -1) {
 559         // newly allocated object with no other stores performed on this field
 560         FieldBuffer* buf = _fields.at(index);
 561         if (buf-&gt;at(field) == NULL &amp;&amp; is_default_value(value)) {
 562 #ifndef PRODUCT
 563           if (PrintIRDuringConstruction &amp;&amp; Verbose) {
 564             tty-&gt;print_cr(&quot;Eliminated store for object %d:&quot;, index);
 565             st-&gt;print_line();
 566           }
 567 #endif
 568           return NULL;
 569         } else {
 570           buf-&gt;at_put(field, value);
 571         }
 572       } else {
 573         _objects.at_put_grow(offset, object, NULL);
 574         _values.at_put(field, value);
 575       }
 576 
 577       store_value(value);
 578     } else {
 579       // if we held onto field names we could alias based on names but
 580       // we don&#39;t know what&#39;s being stored to so kill it all.
 581       kill();
 582     }
 583     return st;
 584   }
 585 
 586 
 587   // return true if this value correspond to the default value of a field.
 588   bool is_default_value(Value value) {
 589     Constant* con = value-&gt;as_Constant();
 590     if (con) {
 591       switch (con-&gt;type()-&gt;tag()) {
 592         case intTag:    return con-&gt;type()-&gt;as_IntConstant()-&gt;value() == 0;
 593         case longTag:   return con-&gt;type()-&gt;as_LongConstant()-&gt;value() == 0;
 594         case floatTag:  return jint_cast(con-&gt;type()-&gt;as_FloatConstant()-&gt;value()) == 0;
 595         case doubleTag: return jlong_cast(con-&gt;type()-&gt;as_DoubleConstant()-&gt;value()) == jlong_cast(0);
 596         case objectTag: return con-&gt;type() == objectNull;
 597         default:  ShouldNotReachHere();
 598       }
 599     }
 600     return false;
 601   }
 602 
 603 
 604   // return either the actual value of a load or the load itself
 605   Value load(LoadField* load) {
 606     if (!EliminateFieldAccess) {
 607       return load;
 608     }
 609 
 610     if (strict_fp_requires_explicit_rounding &amp;&amp; load-&gt;type()-&gt;is_float_kind()) {
 611 #ifdef IA32
 612       if (UseSSE &lt; 2) {
 613         // can&#39;t skip load since value might get rounded as a side effect
 614         return load;
 615       }
 616 #else
 617       Unimplemented();
 618 #endif // IA32
 619     }
 620 
 621     ciField* field = load-&gt;field();
 622     Value object   = load-&gt;obj();
 623     if (field-&gt;holder()-&gt;is_loaded() &amp;&amp; !field-&gt;is_volatile()) {
 624       int offset = field-&gt;offset();
 625       Value result = NULL;
 626       int index = _newobjects.find(object);
 627       if (index != -1) {
 628         result = _fields.at(index)-&gt;at(field);
 629       } else if (_objects.at_grow(offset, NULL) == object) {
 630         result = _values.at(field);
 631       }
 632       if (result != NULL) {
 633 #ifndef PRODUCT
 634         if (PrintIRDuringConstruction &amp;&amp; Verbose) {
 635           tty-&gt;print_cr(&quot;Eliminated load: &quot;);
 636           load-&gt;print_line();
 637         }
 638 #endif
 639         assert(result-&gt;type()-&gt;tag() == load-&gt;type()-&gt;tag(), &quot;wrong types&quot;);
 640         return result;
 641       }
 642     }
 643     return load;
 644   }
 645 
 646   // Record this newly allocated object
 647   void new_instance(NewInstance* object) {
 648     int index = _newobjects.length();
 649     _newobjects.append(object);
 650     if (_fields.at_grow(index, NULL) == NULL) {
 651       _fields.at_put(index, new FieldBuffer());
 652     } else {
 653       _fields.at(index)-&gt;kill();
 654     }
 655   }
 656 
 657   void store_value(Value value) {
 658     int index = _newobjects.find(value);
 659     if (index != -1) {
 660       // stored a newly allocated object into another object.
 661       // Assume we&#39;ve lost track of it as separate slice of memory.
 662       // We could do better by keeping track of whether individual
 663       // fields could alias each other.
 664       _newobjects.remove_at(index);
 665       // pull out the field info and store it at the end up the list
 666       // of field info list to be reused later.
 667       _fields.append(_fields.at(index));
 668       _fields.remove_at(index);
 669     }
 670   }
 671 
 672   void kill() {
 673     _newobjects.trunc_to(0);
 674     _objects.trunc_to(0);
 675     _values.kill();
 676   }
 677 };
 678 
 679 
 680 // Implementation of GraphBuilder&#39;s ScopeData
 681 
 682 GraphBuilder::ScopeData::ScopeData(ScopeData* parent)
 683   : _parent(parent)
 684   , _bci2block(NULL)
 685   , _scope(NULL)
 686   , _has_handler(false)
 687   , _stream(NULL)
 688   , _work_list(NULL)
 689   , _caller_stack_size(-1)
 690   , _continuation(NULL)
 691   , _parsing_jsr(false)
 692   , _jsr_xhandlers(NULL)
 693   , _num_returns(0)
 694   , _cleanup_block(NULL)
 695   , _cleanup_return_prev(NULL)
 696   , _cleanup_state(NULL)
 697   , _ignore_return(false)
 698 {
 699   if (parent != NULL) {
 700     _max_inline_size = (intx) ((float) NestedInliningSizeRatio * (float) parent-&gt;max_inline_size() / 100.0f);
 701   } else {
 702     _max_inline_size = MaxInlineSize;
 703   }
 704   if (_max_inline_size &lt; MaxTrivialSize) {
 705     _max_inline_size = MaxTrivialSize;
 706   }
 707 }
 708 
 709 
 710 void GraphBuilder::kill_all() {
 711   if (UseLocalValueNumbering) {
 712     vmap()-&gt;kill_all();
 713   }
 714   _memory-&gt;kill();
 715 }
 716 
 717 
 718 BlockBegin* GraphBuilder::ScopeData::block_at(int bci) {
 719   if (parsing_jsr()) {
 720     // It is necessary to clone all blocks associated with a
 721     // subroutine, including those for exception handlers in the scope
 722     // of the method containing the jsr (because those exception
 723     // handlers may contain ret instructions in some cases).
 724     BlockBegin* block = bci2block()-&gt;at(bci);
 725     if (block != NULL &amp;&amp; block == parent()-&gt;bci2block()-&gt;at(bci)) {
 726       BlockBegin* new_block = new BlockBegin(block-&gt;bci());
 727       if (PrintInitialBlockList) {
 728         tty-&gt;print_cr(&quot;CFG: cloned block %d (bci %d) as block %d for jsr&quot;,
 729                       block-&gt;block_id(), block-&gt;bci(), new_block-&gt;block_id());
 730       }
 731       // copy data from cloned blocked
 732       new_block-&gt;set_depth_first_number(block-&gt;depth_first_number());
 733       if (block-&gt;is_set(BlockBegin::parser_loop_header_flag)) new_block-&gt;set(BlockBegin::parser_loop_header_flag);
 734       // Preserve certain flags for assertion checking
 735       if (block-&gt;is_set(BlockBegin::subroutine_entry_flag)) new_block-&gt;set(BlockBegin::subroutine_entry_flag);
 736       if (block-&gt;is_set(BlockBegin::exception_entry_flag))  new_block-&gt;set(BlockBegin::exception_entry_flag);
 737 
 738       // copy was_visited_flag to allow early detection of bailouts
 739       // if a block that is used in a jsr has already been visited before,
 740       // it is shared between the normal control flow and a subroutine
 741       // BlockBegin::try_merge returns false when the flag is set, this leads
 742       // to a compilation bailout
 743       if (block-&gt;is_set(BlockBegin::was_visited_flag))  new_block-&gt;set(BlockBegin::was_visited_flag);
 744 
 745       bci2block()-&gt;at_put(bci, new_block);
 746       block = new_block;
 747     }
 748     return block;
 749   } else {
 750     return bci2block()-&gt;at(bci);
 751   }
 752 }
 753 
 754 
 755 XHandlers* GraphBuilder::ScopeData::xhandlers() const {
 756   if (_jsr_xhandlers == NULL) {
 757     assert(!parsing_jsr(), &quot;&quot;);
 758     return scope()-&gt;xhandlers();
 759   }
 760   assert(parsing_jsr(), &quot;&quot;);
 761   return _jsr_xhandlers;
 762 }
 763 
 764 
 765 void GraphBuilder::ScopeData::set_scope(IRScope* scope) {
 766   _scope = scope;
 767   bool parent_has_handler = false;
 768   if (parent() != NULL) {
 769     parent_has_handler = parent()-&gt;has_handler();
 770   }
 771   _has_handler = parent_has_handler || scope-&gt;xhandlers()-&gt;has_handlers();
 772 }
 773 
 774 
 775 void GraphBuilder::ScopeData::set_inline_cleanup_info(BlockBegin* block,
 776                                                       Instruction* return_prev,
 777                                                       ValueStack* return_state) {
 778   _cleanup_block       = block;
 779   _cleanup_return_prev = return_prev;
 780   _cleanup_state       = return_state;
 781 }
 782 
 783 
 784 void GraphBuilder::ScopeData::add_to_work_list(BlockBegin* block) {
 785   if (_work_list == NULL) {
 786     _work_list = new BlockList();
 787   }
 788 
 789   if (!block-&gt;is_set(BlockBegin::is_on_work_list_flag)) {
 790     // Do not start parsing the continuation block while in a
 791     // sub-scope
 792     if (parsing_jsr()) {
 793       if (block == jsr_continuation()) {
 794         return;
 795       }
 796     } else {
 797       if (block == continuation()) {
 798         return;
 799       }
 800     }
 801     block-&gt;set(BlockBegin::is_on_work_list_flag);
 802     _work_list-&gt;push(block);
 803 
 804     sort_top_into_worklist(_work_list, block);
 805   }
 806 }
 807 
 808 
 809 void GraphBuilder::sort_top_into_worklist(BlockList* worklist, BlockBegin* top) {
 810   assert(worklist-&gt;top() == top, &quot;&quot;);
 811   // sort block descending into work list
 812   const int dfn = top-&gt;depth_first_number();
 813   assert(dfn != -1, &quot;unknown depth first number&quot;);
 814   int i = worklist-&gt;length()-2;
 815   while (i &gt;= 0) {
 816     BlockBegin* b = worklist-&gt;at(i);
 817     if (b-&gt;depth_first_number() &lt; dfn) {
 818       worklist-&gt;at_put(i+1, b);
 819     } else {
 820       break;
 821     }
 822     i --;
 823   }
 824   if (i &gt;= -1) worklist-&gt;at_put(i + 1, top);
 825 }
 826 
 827 
 828 BlockBegin* GraphBuilder::ScopeData::remove_from_work_list() {
 829   if (is_work_list_empty()) {
 830     return NULL;
 831   }
 832   return _work_list-&gt;pop();
 833 }
 834 
 835 
 836 bool GraphBuilder::ScopeData::is_work_list_empty() const {
 837   return (_work_list == NULL || _work_list-&gt;length() == 0);
 838 }
 839 
 840 
 841 void GraphBuilder::ScopeData::setup_jsr_xhandlers() {
 842   assert(parsing_jsr(), &quot;&quot;);
 843   // clone all the exception handlers from the scope
 844   XHandlers* handlers = new XHandlers(scope()-&gt;xhandlers());
 845   const int n = handlers-&gt;length();
 846   for (int i = 0; i &lt; n; i++) {
 847     // The XHandlers need to be adjusted to dispatch to the cloned
 848     // handler block instead of the default one but the synthetic
 849     // unlocker needs to be handled specially.  The synthetic unlocker
 850     // should be left alone since there can be only one and all code
 851     // should dispatch to the same one.
 852     XHandler* h = handlers-&gt;handler_at(i);
 853     assert(h-&gt;handler_bci() != SynchronizationEntryBCI, &quot;must be real&quot;);
 854     h-&gt;set_entry_block(block_at(h-&gt;handler_bci()));
 855   }
 856   _jsr_xhandlers = handlers;
 857 }
 858 
 859 
 860 int GraphBuilder::ScopeData::num_returns() {
 861   if (parsing_jsr()) {
 862     return parent()-&gt;num_returns();
 863   }
 864   return _num_returns;
 865 }
 866 
 867 
 868 void GraphBuilder::ScopeData::incr_num_returns() {
 869   if (parsing_jsr()) {
 870     parent()-&gt;incr_num_returns();
 871   } else {
 872     ++_num_returns;
 873   }
 874 }
 875 
 876 
 877 // Implementation of GraphBuilder
 878 
 879 #define INLINE_BAILOUT(msg)        { inline_bailout(msg); return false; }
 880 
 881 
 882 void GraphBuilder::load_constant() {
 883   ciConstant con = stream()-&gt;get_constant();
 884   if (con.basic_type() == T_ILLEGAL) {
 885     // FIXME: an unresolved Dynamic constant can get here,
 886     // and that should not terminate the whole compilation.
 887     BAILOUT(&quot;could not resolve a constant&quot;);
 888   } else {
 889     ValueType* t = illegalType;
 890     ValueStack* patch_state = NULL;
 891     switch (con.basic_type()) {
 892       case T_BOOLEAN: t = new IntConstant     (con.as_boolean()); break;
 893       case T_BYTE   : t = new IntConstant     (con.as_byte   ()); break;
 894       case T_CHAR   : t = new IntConstant     (con.as_char   ()); break;
 895       case T_SHORT  : t = new IntConstant     (con.as_short  ()); break;
 896       case T_INT    : t = new IntConstant     (con.as_int    ()); break;
 897       case T_LONG   : t = new LongConstant    (con.as_long   ()); break;
 898       case T_FLOAT  : t = new FloatConstant   (con.as_float  ()); break;
 899       case T_DOUBLE : t = new DoubleConstant  (con.as_double ()); break;
 900       case T_ARRAY  : t = new ArrayConstant   (con.as_object ()-&gt;as_array   ()); break;
 901       case T_OBJECT :
 902        {
 903         ciObject* obj = con.as_object();
 904         if (!obj-&gt;is_loaded()
 905             || (PatchALot &amp;&amp; obj-&gt;klass() != ciEnv::current()-&gt;String_klass())) {
 906           // A Class, MethodType, MethodHandle, or String.
 907           // Unloaded condy nodes show up as T_ILLEGAL, above.
 908           patch_state = copy_state_before();
 909           t = new ObjectConstant(obj);
 910         } else {
 911           // Might be a Class, MethodType, MethodHandle, or Dynamic constant
 912           // result, which might turn out to be an array.
 913           if (obj-&gt;is_null_object())
 914             t = objectNull;
 915           else if (obj-&gt;is_array())
 916             t = new ArrayConstant(obj-&gt;as_array());
 917           else
 918             t = new InstanceConstant(obj-&gt;as_instance());
 919         }
 920         break;
 921        }
 922       default       : ShouldNotReachHere();
 923     }
 924     Value x;
 925     if (patch_state != NULL) {
 926       x = new Constant(t, patch_state);
 927     } else {
 928       x = new Constant(t);
 929     }
 930     push(t, append(x));
 931   }
 932 }
 933 
 934 
 935 void GraphBuilder::load_local(ValueType* type, int index) {
 936   Value x = state()-&gt;local_at(index);
 937   assert(x != NULL &amp;&amp; !x-&gt;type()-&gt;is_illegal(), &quot;access of illegal local variable&quot;);
 938   push(type, x);
 939 }
 940 
 941 
 942 void GraphBuilder::store_local(ValueType* type, int index) {
 943   Value x = pop(type);
 944   store_local(state(), x, index);
 945 }
 946 
 947 
 948 void GraphBuilder::store_local(ValueStack* state, Value x, int index) {
 949   if (parsing_jsr()) {
 950     // We need to do additional tracking of the location of the return
 951     // address for jsrs since we don&#39;t handle arbitrary jsr/ret
 952     // constructs. Here we are figuring out in which circumstances we
 953     // need to bail out.
 954     if (x-&gt;type()-&gt;is_address()) {
 955       scope_data()-&gt;set_jsr_return_address_local(index);
 956 
 957       // Also check parent jsrs (if any) at this time to see whether
 958       // they are using this local. We don&#39;t handle skipping over a
 959       // ret.
 960       for (ScopeData* cur_scope_data = scope_data()-&gt;parent();
 961            cur_scope_data != NULL &amp;&amp; cur_scope_data-&gt;parsing_jsr() &amp;&amp; cur_scope_data-&gt;scope() == scope();
 962            cur_scope_data = cur_scope_data-&gt;parent()) {
 963         if (cur_scope_data-&gt;jsr_return_address_local() == index) {
 964           BAILOUT(&quot;subroutine overwrites return address from previous subroutine&quot;);
 965         }
 966       }
 967     } else if (index == scope_data()-&gt;jsr_return_address_local()) {
 968       scope_data()-&gt;set_jsr_return_address_local(-1);
 969     }
 970   }
 971 
 972   state-&gt;store_local(index, round_fp(x));
 973 }
 974 
 975 
 976 void GraphBuilder::load_indexed(BasicType type) {
 977   // In case of in block code motion in range check elimination
 978   ValueStack* state_before = copy_state_indexed_access();
 979   compilation()-&gt;set_has_access_indexed(true);
 980   Value index = ipop();
 981   Value array = apop();
 982   Value length = NULL;
 983   if (CSEArrayLength ||
 984       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
 985       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
 986     length = append(new ArrayLength(array, state_before));
 987   }
 988   push(as_ValueType(type), append(new LoadIndexed(array, index, length, type, state_before)));
 989 }
 990 
 991 
 992 void GraphBuilder::store_indexed(BasicType type) {
 993   // In case of in block code motion in range check elimination
 994   ValueStack* state_before = copy_state_indexed_access();
 995   compilation()-&gt;set_has_access_indexed(true);
 996   Value value = pop(as_ValueType(type));
 997   Value index = ipop();
 998   Value array = apop();
 999   Value length = NULL;
1000   if (CSEArrayLength ||
1001       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1002       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1003     length = append(new ArrayLength(array, state_before));
1004   }
1005   ciType* array_type = array-&gt;declared_type();
1006   bool check_boolean = false;
1007   if (array_type != NULL) {
1008     if (array_type-&gt;is_loaded() &amp;&amp;
1009       array_type-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type() == T_BOOLEAN) {
1010       assert(type == T_BYTE, &quot;boolean store uses bastore&quot;);
1011       Value mask = append(new Constant(new IntConstant(1)));
1012       value = append(new LogicOp(Bytecodes::_iand, value, mask));
1013     }
1014   } else if (type == T_BYTE) {
1015     check_boolean = true;
1016   }
1017   StoreIndexed* result = new StoreIndexed(array, index, length, type, value, state_before, check_boolean);
1018   append(result);
1019   _memory-&gt;store_value(value);
1020 
1021   if (type == T_OBJECT &amp;&amp; is_profiling()) {
1022     // Note that we&#39;d collect profile data in this method if we wanted it.
1023     compilation()-&gt;set_would_profile(true);
1024 
1025     if (profile_checkcasts()) {
1026       result-&gt;set_profiled_method(method());
1027       result-&gt;set_profiled_bci(bci());
1028       result-&gt;set_should_profile(true);
1029     }
1030   }
1031 }
1032 
1033 
1034 void GraphBuilder::stack_op(Bytecodes::Code code) {
1035   switch (code) {
1036     case Bytecodes::_pop:
1037       { state()-&gt;raw_pop();
1038       }
1039       break;
1040     case Bytecodes::_pop2:
1041       { state()-&gt;raw_pop();
1042         state()-&gt;raw_pop();
1043       }
1044       break;
1045     case Bytecodes::_dup:
1046       { Value w = state()-&gt;raw_pop();
1047         state()-&gt;raw_push(w);
1048         state()-&gt;raw_push(w);
1049       }
1050       break;
1051     case Bytecodes::_dup_x1:
1052       { Value w1 = state()-&gt;raw_pop();
1053         Value w2 = state()-&gt;raw_pop();
1054         state()-&gt;raw_push(w1);
1055         state()-&gt;raw_push(w2);
1056         state()-&gt;raw_push(w1);
1057       }
1058       break;
1059     case Bytecodes::_dup_x2:
1060       { Value w1 = state()-&gt;raw_pop();
1061         Value w2 = state()-&gt;raw_pop();
1062         Value w3 = state()-&gt;raw_pop();
1063         state()-&gt;raw_push(w1);
1064         state()-&gt;raw_push(w3);
1065         state()-&gt;raw_push(w2);
1066         state()-&gt;raw_push(w1);
1067       }
1068       break;
1069     case Bytecodes::_dup2:
1070       { Value w1 = state()-&gt;raw_pop();
1071         Value w2 = state()-&gt;raw_pop();
1072         state()-&gt;raw_push(w2);
1073         state()-&gt;raw_push(w1);
1074         state()-&gt;raw_push(w2);
1075         state()-&gt;raw_push(w1);
1076       }
1077       break;
1078     case Bytecodes::_dup2_x1:
1079       { Value w1 = state()-&gt;raw_pop();
1080         Value w2 = state()-&gt;raw_pop();
1081         Value w3 = state()-&gt;raw_pop();
1082         state()-&gt;raw_push(w2);
1083         state()-&gt;raw_push(w1);
1084         state()-&gt;raw_push(w3);
1085         state()-&gt;raw_push(w2);
1086         state()-&gt;raw_push(w1);
1087       }
1088       break;
1089     case Bytecodes::_dup2_x2:
1090       { Value w1 = state()-&gt;raw_pop();
1091         Value w2 = state()-&gt;raw_pop();
1092         Value w3 = state()-&gt;raw_pop();
1093         Value w4 = state()-&gt;raw_pop();
1094         state()-&gt;raw_push(w2);
1095         state()-&gt;raw_push(w1);
1096         state()-&gt;raw_push(w4);
1097         state()-&gt;raw_push(w3);
1098         state()-&gt;raw_push(w2);
1099         state()-&gt;raw_push(w1);
1100       }
1101       break;
1102     case Bytecodes::_swap:
1103       { Value w1 = state()-&gt;raw_pop();
1104         Value w2 = state()-&gt;raw_pop();
1105         state()-&gt;raw_push(w1);
1106         state()-&gt;raw_push(w2);
1107       }
1108       break;
1109     default:
1110       ShouldNotReachHere();
1111       break;
1112   }
1113 }
1114 
1115 
1116 void GraphBuilder::arithmetic_op(ValueType* type, Bytecodes::Code code, ValueStack* state_before) {
1117   Value y = pop(type);
1118   Value x = pop(type);
1119   // NOTE: strictfp can be queried from current method since we don&#39;t
1120   // inline methods with differing strictfp bits
1121   Value res = new ArithmeticOp(code, x, y, method()-&gt;is_strict(), state_before);
1122   // Note: currently single-precision floating-point rounding on Intel is handled at the LIRGenerator level
1123   res = append(res);
1124   if (method()-&gt;is_strict()) {
1125     res = round_fp(res);
1126   }
1127   push(type, res);
1128 }
1129 
1130 
1131 void GraphBuilder::negate_op(ValueType* type) {
1132   push(type, append(new NegateOp(pop(type))));
1133 }
1134 
1135 
1136 void GraphBuilder::shift_op(ValueType* type, Bytecodes::Code code) {
1137   Value s = ipop();
1138   Value x = pop(type);
1139   // try to simplify
1140   // Note: This code should go into the canonicalizer as soon as it can
1141   //       can handle canonicalized forms that contain more than one node.
1142   if (CanonicalizeNodes &amp;&amp; code == Bytecodes::_iushr) {
1143     // pattern: x &gt;&gt;&gt; s
1144     IntConstant* s1 = s-&gt;type()-&gt;as_IntConstant();
1145     if (s1 != NULL) {
1146       // pattern: x &gt;&gt;&gt; s1, with s1 constant
1147       ShiftOp* l = x-&gt;as_ShiftOp();
1148       if (l != NULL &amp;&amp; l-&gt;op() == Bytecodes::_ishl) {
1149         // pattern: (a &lt;&lt; b) &gt;&gt;&gt; s1
1150         IntConstant* s0 = l-&gt;y()-&gt;type()-&gt;as_IntConstant();
1151         if (s0 != NULL) {
1152           // pattern: (a &lt;&lt; s0) &gt;&gt;&gt; s1
1153           const int s0c = s0-&gt;value() &amp; 0x1F; // only the low 5 bits are significant for shifts
1154           const int s1c = s1-&gt;value() &amp; 0x1F; // only the low 5 bits are significant for shifts
1155           if (s0c == s1c) {
1156             if (s0c == 0) {
1157               // pattern: (a &lt;&lt; 0) &gt;&gt;&gt; 0 =&gt; simplify to: a
1158               ipush(l-&gt;x());
1159             } else {
1160               // pattern: (a &lt;&lt; s0c) &gt;&gt;&gt; s0c =&gt; simplify to: a &amp; m, with m constant
1161               assert(0 &lt; s0c &amp;&amp; s0c &lt; BitsPerInt, &quot;adjust code below to handle corner cases&quot;);
1162               const int m = (1 &lt;&lt; (BitsPerInt - s0c)) - 1;
1163               Value s = append(new Constant(new IntConstant(m)));
1164               ipush(append(new LogicOp(Bytecodes::_iand, l-&gt;x(), s)));
1165             }
1166             return;
1167           }
1168         }
1169       }
1170     }
1171   }
1172   // could not simplify
1173   push(type, append(new ShiftOp(code, x, s)));
1174 }
1175 
1176 
1177 void GraphBuilder::logic_op(ValueType* type, Bytecodes::Code code) {
1178   Value y = pop(type);
1179   Value x = pop(type);
1180   push(type, append(new LogicOp(code, x, y)));
1181 }
1182 
1183 
1184 void GraphBuilder::compare_op(ValueType* type, Bytecodes::Code code) {
1185   ValueStack* state_before = copy_state_before();
1186   Value y = pop(type);
1187   Value x = pop(type);
1188   ipush(append(new CompareOp(code, x, y, state_before)));
1189 }
1190 
1191 
1192 void GraphBuilder::convert(Bytecodes::Code op, BasicType from, BasicType to) {
1193   push(as_ValueType(to), append(new Convert(op, pop(as_ValueType(from)), as_ValueType(to))));
1194 }
1195 
1196 
1197 void GraphBuilder::increment() {
1198   int index = stream()-&gt;get_index();
1199   int delta = stream()-&gt;is_wide() ? (signed short)Bytes::get_Java_u2(stream()-&gt;cur_bcp() + 4) : (signed char)(stream()-&gt;cur_bcp()[2]);
1200   load_local(intType, index);
1201   ipush(append(new Constant(new IntConstant(delta))));
1202   arithmetic_op(intType, Bytecodes::_iadd);
1203   store_local(intType, index);
1204 }
1205 
1206 
1207 void GraphBuilder::_goto(int from_bci, int to_bci) {
1208   Goto *x = new Goto(block_at(to_bci), to_bci &lt;= from_bci);
1209   if (is_profiling()) {
1210     compilation()-&gt;set_would_profile(true);
1211     x-&gt;set_profiled_bci(bci());
1212     if (profile_branches()) {
1213       x-&gt;set_profiled_method(method());
1214       x-&gt;set_should_profile(true);
1215     }
1216   }
1217   append(x);
1218 }
1219 
1220 
1221 void GraphBuilder::if_node(Value x, If::Condition cond, Value y, ValueStack* state_before) {
1222   BlockBegin* tsux = block_at(stream()-&gt;get_dest());
1223   BlockBegin* fsux = block_at(stream()-&gt;next_bci());
1224   bool is_bb = tsux-&gt;bci() &lt; stream()-&gt;cur_bci() || fsux-&gt;bci() &lt; stream()-&gt;cur_bci();
1225   // In case of loop invariant code motion or predicate insertion
1226   // before the body of a loop the state is needed
1227   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic()) ? state_before : NULL, is_bb));
1228 
1229   assert(i-&gt;as_Goto() == NULL ||
1230          (i-&gt;as_Goto()-&gt;sux_at(0) == tsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == tsux-&gt;bci() &lt; stream()-&gt;cur_bci()) ||
1231          (i-&gt;as_Goto()-&gt;sux_at(0) == fsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == fsux-&gt;bci() &lt; stream()-&gt;cur_bci()),
1232          &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1233 
1234   if (is_profiling()) {
1235     If* if_node = i-&gt;as_If();
1236     if (if_node != NULL) {
1237       // Note that we&#39;d collect profile data in this method if we wanted it.
1238       compilation()-&gt;set_would_profile(true);
1239       // At level 2 we need the proper bci to count backedges
1240       if_node-&gt;set_profiled_bci(bci());
1241       if (profile_branches()) {
1242         // Successors can be rotated by the canonicalizer, check for this case.
1243         if_node-&gt;set_profiled_method(method());
1244         if_node-&gt;set_should_profile(true);
1245         if (if_node-&gt;tsux() == fsux) {
1246           if_node-&gt;set_swapped(true);
1247         }
1248       }
1249       return;
1250     }
1251 
1252     // Check if this If was reduced to Goto.
1253     Goto *goto_node = i-&gt;as_Goto();
1254     if (goto_node != NULL) {
1255       compilation()-&gt;set_would_profile(true);
1256       goto_node-&gt;set_profiled_bci(bci());
1257       if (profile_branches()) {
1258         goto_node-&gt;set_profiled_method(method());
1259         goto_node-&gt;set_should_profile(true);
1260         // Find out which successor is used.
1261         if (goto_node-&gt;default_sux() == tsux) {
1262           goto_node-&gt;set_direction(Goto::taken);
1263         } else if (goto_node-&gt;default_sux() == fsux) {
1264           goto_node-&gt;set_direction(Goto::not_taken);
1265         } else {
1266           ShouldNotReachHere();
1267         }
1268       }
1269       return;
1270     }
1271   }
1272 }
1273 
1274 
1275 void GraphBuilder::if_zero(ValueType* type, If::Condition cond) {
1276   Value y = append(new Constant(intZero));
1277   ValueStack* state_before = copy_state_before();
1278   Value x = ipop();
1279   if_node(x, cond, y, state_before);
1280 }
1281 
1282 
1283 void GraphBuilder::if_null(ValueType* type, If::Condition cond) {
1284   Value y = append(new Constant(objectNull));
1285   ValueStack* state_before = copy_state_before();
1286   Value x = apop();
1287   if_node(x, cond, y, state_before);
1288 }
1289 
1290 
1291 void GraphBuilder::if_same(ValueType* type, If::Condition cond) {
1292   ValueStack* state_before = copy_state_before();
1293   Value y = pop(type);
1294   Value x = pop(type);
1295   if_node(x, cond, y, state_before);
1296 }
1297 
1298 
1299 void GraphBuilder::jsr(int dest) {
1300   // We only handle well-formed jsrs (those which are &quot;block-structured&quot;).
1301   // If the bytecodes are strange (jumping out of a jsr block) then we
1302   // might end up trying to re-parse a block containing a jsr which
1303   // has already been activated. Watch for this case and bail out.
1304   for (ScopeData* cur_scope_data = scope_data();
1305        cur_scope_data != NULL &amp;&amp; cur_scope_data-&gt;parsing_jsr() &amp;&amp; cur_scope_data-&gt;scope() == scope();
1306        cur_scope_data = cur_scope_data-&gt;parent()) {
1307     if (cur_scope_data-&gt;jsr_entry_bci() == dest) {
1308       BAILOUT(&quot;too-complicated jsr/ret structure&quot;);
1309     }
1310   }
1311 
1312   push(addressType, append(new Constant(new AddressConstant(next_bci()))));
1313   if (!try_inline_jsr(dest)) {
1314     return; // bailed out while parsing and inlining subroutine
1315   }
1316 }
1317 
1318 
1319 void GraphBuilder::ret(int local_index) {
1320   if (!parsing_jsr()) BAILOUT(&quot;ret encountered while not parsing subroutine&quot;);
1321 
1322   if (local_index != scope_data()-&gt;jsr_return_address_local()) {
1323     BAILOUT(&quot;can not handle complicated jsr/ret constructs&quot;);
1324   }
1325 
1326   // Rets simply become (NON-SAFEPOINT) gotos to the jsr continuation
1327   append(new Goto(scope_data()-&gt;jsr_continuation(), false));
1328 }
1329 
1330 
1331 void GraphBuilder::table_switch() {
1332   Bytecode_tableswitch sw(stream());
1333   const int l = sw.length();
1334   if (CanonicalizeNodes &amp;&amp; l == 1 &amp;&amp; compilation()-&gt;env()-&gt;comp_level() != CompLevel_full_profile) {
1335     // total of 2 successors =&gt; use If instead of switch
1336     // Note: This code should go into the canonicalizer as soon as it can
1337     //       can handle canonicalized forms that contain more than one node.
1338     Value key = append(new Constant(new IntConstant(sw.low_key())));
1339     BlockBegin* tsux = block_at(bci() + sw.dest_offset_at(0));
1340     BlockBegin* fsux = block_at(bci() + sw.default_offset());
1341     bool is_bb = tsux-&gt;bci() &lt; bci() || fsux-&gt;bci() &lt; bci();
1342     // In case of loop invariant code motion or predicate insertion
1343     // before the body of a loop the state is needed
1344     ValueStack* state_before = copy_state_if_bb(is_bb);
1345     append(new If(ipop(), If::eql, true, key, tsux, fsux, state_before, is_bb));
1346   } else {
1347     // collect successors
1348     BlockList* sux = new BlockList(l + 1, NULL);
1349     int i;
1350     bool has_bb = false;
1351     for (i = 0; i &lt; l; i++) {
1352       sux-&gt;at_put(i, block_at(bci() + sw.dest_offset_at(i)));
1353       if (sw.dest_offset_at(i) &lt; 0) has_bb = true;
1354     }
1355     // add default successor
1356     if (sw.default_offset() &lt; 0) has_bb = true;
1357     sux-&gt;at_put(i, block_at(bci() + sw.default_offset()));
1358     // In case of loop invariant code motion or predicate insertion
1359     // before the body of a loop the state is needed
1360     ValueStack* state_before = copy_state_if_bb(has_bb);
1361     Instruction* res = append(new TableSwitch(ipop(), sux, sw.low_key(), state_before, has_bb));
1362 #ifdef ASSERT
1363     if (res-&gt;as_Goto()) {
1364       for (i = 0; i &lt; l; i++) {
1365         if (sux-&gt;at(i) == res-&gt;as_Goto()-&gt;sux_at(0)) {
1366           assert(res-&gt;as_Goto()-&gt;is_safepoint() == sw.dest_offset_at(i) &lt; 0, &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1367         }
1368       }
1369     }
1370 #endif
1371   }
1372 }
1373 
1374 
1375 void GraphBuilder::lookup_switch() {
1376   Bytecode_lookupswitch sw(stream());
1377   const int l = sw.number_of_pairs();
1378   if (CanonicalizeNodes &amp;&amp; l == 1 &amp;&amp; compilation()-&gt;env()-&gt;comp_level() != CompLevel_full_profile) {
1379     // total of 2 successors =&gt; use If instead of switch
1380     // Note: This code should go into the canonicalizer as soon as it can
1381     //       can handle canonicalized forms that contain more than one node.
1382     // simplify to If
1383     LookupswitchPair pair = sw.pair_at(0);
1384     Value key = append(new Constant(new IntConstant(pair.match())));
1385     BlockBegin* tsux = block_at(bci() + pair.offset());
1386     BlockBegin* fsux = block_at(bci() + sw.default_offset());
1387     bool is_bb = tsux-&gt;bci() &lt; bci() || fsux-&gt;bci() &lt; bci();
1388     // In case of loop invariant code motion or predicate insertion
1389     // before the body of a loop the state is needed
1390     ValueStack* state_before = copy_state_if_bb(is_bb);;
1391     append(new If(ipop(), If::eql, true, key, tsux, fsux, state_before, is_bb));
1392   } else {
1393     // collect successors &amp; keys
1394     BlockList* sux = new BlockList(l + 1, NULL);
1395     intArray* keys = new intArray(l, l, 0);
1396     int i;
1397     bool has_bb = false;
1398     for (i = 0; i &lt; l; i++) {
1399       LookupswitchPair pair = sw.pair_at(i);
1400       if (pair.offset() &lt; 0) has_bb = true;
1401       sux-&gt;at_put(i, block_at(bci() + pair.offset()));
1402       keys-&gt;at_put(i, pair.match());
1403     }
1404     // add default successor
1405     if (sw.default_offset() &lt; 0) has_bb = true;
1406     sux-&gt;at_put(i, block_at(bci() + sw.default_offset()));
1407     // In case of loop invariant code motion or predicate insertion
1408     // before the body of a loop the state is needed
1409     ValueStack* state_before = copy_state_if_bb(has_bb);
1410     Instruction* res = append(new LookupSwitch(ipop(), sux, keys, state_before, has_bb));
1411 #ifdef ASSERT
1412     if (res-&gt;as_Goto()) {
1413       for (i = 0; i &lt; l; i++) {
1414         if (sux-&gt;at(i) == res-&gt;as_Goto()-&gt;sux_at(0)) {
1415           assert(res-&gt;as_Goto()-&gt;is_safepoint() == sw.pair_at(i).offset() &lt; 0, &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1416         }
1417       }
1418     }
1419 #endif
1420   }
1421 }
1422 
1423 void GraphBuilder::call_register_finalizer() {
1424   // If the receiver requires finalization then emit code to perform
1425   // the registration on return.
1426 
1427   // Gather some type information about the receiver
1428   Value receiver = state()-&gt;local_at(0);
1429   assert(receiver != NULL, &quot;must have a receiver&quot;);
1430   ciType* declared_type = receiver-&gt;declared_type();
1431   ciType* exact_type = receiver-&gt;exact_type();
1432   if (exact_type == NULL &amp;&amp;
1433       receiver-&gt;as_Local() &amp;&amp;
1434       receiver-&gt;as_Local()-&gt;java_index() == 0) {
1435     ciInstanceKlass* ik = compilation()-&gt;method()-&gt;holder();
1436     if (ik-&gt;is_final()) {
1437       exact_type = ik;
1438     } else if (UseCHA &amp;&amp; !(ik-&gt;has_subklass() || ik-&gt;is_interface())) {
1439       // test class is leaf class
1440       compilation()-&gt;dependency_recorder()-&gt;assert_leaf_type(ik);
1441       exact_type = ik;
1442     } else {
1443       declared_type = ik;
1444     }
1445   }
1446 
1447   // see if we know statically that registration isn&#39;t required
1448   bool needs_check = true;
1449   if (exact_type != NULL) {
1450     needs_check = exact_type-&gt;as_instance_klass()-&gt;has_finalizer();
1451   } else if (declared_type != NULL) {
1452     ciInstanceKlass* ik = declared_type-&gt;as_instance_klass();
1453     if (!Dependencies::has_finalizable_subclass(ik)) {
1454       compilation()-&gt;dependency_recorder()-&gt;assert_has_no_finalizable_subclasses(ik);
1455       needs_check = false;
1456     }
1457   }
1458 
1459   if (needs_check) {
1460     // Perform the registration of finalizable objects.
1461     ValueStack* state_before = copy_state_for_exception();
1462     load_local(objectType, 0);
1463     append_split(new Intrinsic(voidType, vmIntrinsics::_Object_init,
1464                                state()-&gt;pop_arguments(1),
1465                                true, state_before, true));
1466   }
1467 }
1468 
1469 
1470 void GraphBuilder::method_return(Value x, bool ignore_return) {
1471   if (RegisterFinalizersAtInit &amp;&amp;
1472       method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
1473     call_register_finalizer();
1474   }
1475 
1476   // The conditions for a memory barrier are described in Parse::do_exits().
1477   bool need_mem_bar = false;
1478   if (method()-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
1479        (scope()-&gt;wrote_final() ||
1480          (AlwaysSafeConstructors &amp;&amp; scope()-&gt;wrote_fields()) ||
1481          (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; scope()-&gt;wrote_volatile()))) {
1482     need_mem_bar = true;
1483   }
1484 
1485   BasicType bt = method()-&gt;return_type()-&gt;basic_type();
1486   switch (bt) {
1487     case T_BYTE:
1488     {
1489       Value shift = append(new Constant(new IntConstant(24)));
1490       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1491       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1492       break;
1493     }
1494     case T_SHORT:
1495     {
1496       Value shift = append(new Constant(new IntConstant(16)));
1497       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1498       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1499       break;
1500     }
1501     case T_CHAR:
1502     {
1503       Value mask = append(new Constant(new IntConstant(0xFFFF)));
1504       x = append(new LogicOp(Bytecodes::_iand, x, mask));
1505       break;
1506     }
1507     case T_BOOLEAN:
1508     {
1509       Value mask = append(new Constant(new IntConstant(1)));
1510       x = append(new LogicOp(Bytecodes::_iand, x, mask));
1511       break;
1512     }
1513     default:
1514       break;
1515   }
1516 
1517   // Check to see whether we are inlining. If so, Return
1518   // instructions become Gotos to the continuation point.
1519   if (continuation() != NULL) {
1520 
1521     int invoke_bci = state()-&gt;caller_state()-&gt;bci();
1522 
1523     if (x != NULL  &amp;&amp; !ignore_return) {
1524       ciMethod* caller = state()-&gt;scope()-&gt;caller()-&gt;method();
1525       Bytecodes::Code invoke_raw_bc = caller-&gt;raw_code_at_bci(invoke_bci);
1526       if (invoke_raw_bc == Bytecodes::_invokehandle || invoke_raw_bc == Bytecodes::_invokedynamic) {
1527         ciType* declared_ret_type = caller-&gt;get_declared_signature_at_bci(invoke_bci)-&gt;return_type();
1528         if (declared_ret_type-&gt;is_klass() &amp;&amp; x-&gt;exact_type() == NULL &amp;&amp;
1529             x-&gt;declared_type() != declared_ret_type &amp;&amp; declared_ret_type != compilation()-&gt;env()-&gt;Object_klass()) {
1530           x = append(new TypeCast(declared_ret_type-&gt;as_klass(), x, copy_state_before()));
1531         }
1532       }
1533     }
1534 
1535     assert(!method()-&gt;is_synchronized() || InlineSynchronizedMethods, &quot;can not inline synchronized methods yet&quot;);
1536 
1537     if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
1538       // Report exit from inline methods
1539       Values* args = new Values(1);
1540       args-&gt;push(append(new Constant(new MethodConstant(method()))));
1541       append(new RuntimeCall(voidType, &quot;dtrace_method_exit&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), args));
1542     }
1543 
1544     // If the inlined method is synchronized, the monitor must be
1545     // released before we jump to the continuation block.
1546     if (method()-&gt;is_synchronized()) {
1547       assert(state()-&gt;locks_size() == 1, &quot;receiver must be locked here&quot;);
1548       monitorexit(state()-&gt;lock_at(0), SynchronizationEntryBCI);
1549     }
1550 
1551     if (need_mem_bar) {
1552       append(new MemBar(lir_membar_storestore));
1553     }
1554 
1555     // State at end of inlined method is the state of the caller
1556     // without the method parameters on stack, including the
1557     // return value, if any, of the inlined method on operand stack.
1558     set_state(state()-&gt;caller_state()-&gt;copy_for_parsing());
1559     if (x != NULL) {
1560       if (!ignore_return) {
1561         state()-&gt;push(x-&gt;type(), x);
1562       }
1563       if (profile_return() &amp;&amp; x-&gt;type()-&gt;is_object_kind()) {
1564         ciMethod* caller = state()-&gt;scope()-&gt;method();
1565         profile_return_type(x, method(), caller, invoke_bci);
1566       }
1567     }
1568     Goto* goto_callee = new Goto(continuation(), false);
1569 
1570     // See whether this is the first return; if so, store off some
1571     // of the state for later examination
1572     if (num_returns() == 0) {
1573       set_inline_cleanup_info();
1574     }
1575 
1576     // The current bci() is in the wrong scope, so use the bci() of
1577     // the continuation point.
1578     append_with_bci(goto_callee, scope_data()-&gt;continuation()-&gt;bci());
1579     incr_num_returns();
1580     return;
1581   }
1582 
1583   state()-&gt;truncate_stack(0);
1584   if (method()-&gt;is_synchronized()) {
1585     // perform the unlocking before exiting the method
1586     Value receiver;
1587     if (!method()-&gt;is_static()) {
1588       receiver = _initial_state-&gt;local_at(0);
1589     } else {
1590       receiver = append(new Constant(new ClassConstant(method()-&gt;holder())));
1591     }
1592     append_split(new MonitorExit(receiver, state()-&gt;unlock()));
1593   }
1594 
1595   if (need_mem_bar) {
1596       append(new MemBar(lir_membar_storestore));
1597   }
1598 
1599   assert(!ignore_return, &quot;Ignoring return value works only for inlining&quot;);
1600   append(new Return(x));
1601 }
1602 
1603 Value GraphBuilder::make_constant(ciConstant field_value, ciField* field) {
1604   if (!field_value.is_valid())  return NULL;
1605 
1606   BasicType field_type = field_value.basic_type();
1607   ValueType* value = as_ValueType(field_value);
1608 
1609   // Attach dimension info to stable arrays.
1610   if (FoldStableValues &amp;&amp;
1611       field-&gt;is_stable() &amp;&amp; field_type == T_ARRAY &amp;&amp; !field_value.is_null_or_zero()) {
1612     ciArray* array = field_value.as_object()-&gt;as_array();
1613     jint dimension = field-&gt;type()-&gt;as_array_klass()-&gt;dimension();
1614     value = new StableArrayConstant(array, dimension);
1615   }
1616 
1617   switch (field_type) {
1618     case T_ARRAY:
1619     case T_OBJECT:
1620       if (field_value.as_object()-&gt;should_be_constant()) {
1621         return new Constant(value);
1622       }
1623       return NULL; // Not a constant.
1624     default:
1625       return new Constant(value);
1626   }
1627 }
1628 
1629 void GraphBuilder::access_field(Bytecodes::Code code) {
1630   bool will_link;
1631   ciField* field = stream()-&gt;get_field(will_link);
1632   ciInstanceKlass* holder = field-&gt;holder();
1633   BasicType field_type = field-&gt;type()-&gt;basic_type();
1634   ValueType* type = as_ValueType(field_type);
1635   // call will_link again to determine if the field is valid.
1636   const bool needs_patching = !holder-&gt;is_loaded() ||
1637                               !field-&gt;will_link(method(), code) ||
1638                               PatchALot;
1639 
1640   ValueStack* state_before = NULL;
1641   if (!holder-&gt;is_initialized() || needs_patching) {
1642     // save state before instruction for debug info when
1643     // deoptimization happens during patching
1644     state_before = copy_state_before();
1645   }
1646 
1647   Value obj = NULL;
1648   if (code == Bytecodes::_getstatic || code == Bytecodes::_putstatic) {
1649     if (state_before != NULL) {
1650       // build a patching constant
1651       obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()), state_before);
1652     } else {
1653       obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()));
1654     }
1655   }
1656 
1657   if (field-&gt;is_final() &amp;&amp; (code == Bytecodes::_putfield)) {
1658     scope()-&gt;set_wrote_final();
1659   }
1660 
1661   if (code == Bytecodes::_putfield) {
1662     scope()-&gt;set_wrote_fields();
1663     if (field-&gt;is_volatile()) {
1664       scope()-&gt;set_wrote_volatile();
1665     }
1666   }
1667 
1668   const int offset = !needs_patching ? field-&gt;offset() : -1;
1669   switch (code) {
1670     case Bytecodes::_getstatic: {
1671       // check for compile-time constants, i.e., initialized static final fields
1672       Value constant = NULL;
1673       if (field-&gt;is_static_constant() &amp;&amp; !PatchALot) {
1674         ciConstant field_value = field-&gt;constant_value();
1675         assert(!field-&gt;is_stable() || !field_value.is_null_or_zero(),
1676                &quot;stable static w/ default value shouldn&#39;t be a constant&quot;);
1677         constant = make_constant(field_value, field);
1678       }
1679       if (constant != NULL) {
1680         push(type, append(constant));
1681       } else {
1682         if (state_before == NULL) {
1683           state_before = copy_state_for_exception();
1684         }
1685         push(type, append(new LoadField(append(obj), offset, field, true,
1686                                         state_before, needs_patching)));
1687       }
1688       break;
1689     }
1690     case Bytecodes::_putstatic: {
1691       Value val = pop(type);
1692       if (state_before == NULL) {
1693         state_before = copy_state_for_exception();
1694       }
1695       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1696         Value mask = append(new Constant(new IntConstant(1)));
1697         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1698       }
1699       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1700       break;
1701     }
1702     case Bytecodes::_getfield: {
1703       // Check for compile-time constants, i.e., trusted final non-static fields.
1704       Value constant = NULL;
1705       obj = apop();
1706       ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
1707       if (field-&gt;is_constant() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {
1708         ciObject* const_oop = obj_type-&gt;constant_value();
1709         if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
1710           ciConstant field_value = field-&gt;constant_value_of(const_oop);
1711           if (field_value.is_valid()) {
1712             constant = make_constant(field_value, field);
1713             // For CallSite objects add a dependency for invalidation of the optimization.
1714             if (field-&gt;is_call_site_target()) {
1715               ciCallSite* call_site = const_oop-&gt;as_call_site();
1716               if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
1717                 ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
1718                 dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
1719               }
1720             }
1721           }
1722         }
1723       }
1724       if (constant != NULL) {
1725         push(type, append(constant));
1726       } else {
1727         if (state_before == NULL) {
1728           state_before = copy_state_for_exception();
1729         }
1730         LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);
1731         Value replacement = !needs_patching ? _memory-&gt;load(load) : load;
1732         if (replacement != load) {
1733           assert(replacement-&gt;is_linked() || !replacement-&gt;can_be_linked(), &quot;should already by linked&quot;);
1734           // Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing
1735           // conversion. Emit an explicit conversion here to get the correct field value after the write.
1736           BasicType bt = field-&gt;type()-&gt;basic_type();
1737           switch (bt) {
1738           case T_BOOLEAN:
1739           case T_BYTE:
1740             replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));
1741             break;
1742           case T_CHAR:
1743             replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));
1744             break;
1745           case T_SHORT:
1746             replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));
1747             break;
1748           default:
1749             break;
1750           }
1751           push(type, replacement);
1752         } else {
1753           push(type, append(load));
1754         }
1755       }
1756       break;
1757     }
1758     case Bytecodes::_putfield: {
1759       Value val = pop(type);
1760       obj = apop();
1761       if (state_before == NULL) {
1762         state_before = copy_state_for_exception();
1763       }
1764       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1765         Value mask = append(new Constant(new IntConstant(1)));
1766         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1767       }
1768       StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);
1769       if (!needs_patching) store = _memory-&gt;store(store);
1770       if (store != NULL) {
1771         append(store);
1772       }
1773       break;
1774     }
1775     default:
1776       ShouldNotReachHere();
1777       break;
1778   }
1779 }
1780 
1781 
1782 Dependencies* GraphBuilder::dependency_recorder() const {
1783   assert(DeoptC1, &quot;need debug information&quot;);
1784   return compilation()-&gt;dependency_recorder();
1785 }
1786 
1787 // How many arguments do we want to profile?
1788 Values* GraphBuilder::args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver) {
1789   int n = 0;
1790   bool has_receiver = may_have_receiver &amp;&amp; Bytecodes::has_receiver(method()-&gt;java_code_at_bci(bci()));
1791   start = has_receiver ? 1 : 0;
1792   if (profile_arguments()) {
1793     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
1794     if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
1795       n = data-&gt;is_CallTypeData() ? data-&gt;as_CallTypeData()-&gt;number_of_arguments() : data-&gt;as_VirtualCallTypeData()-&gt;number_of_arguments();
1796     }
1797   }
1798   // If we are inlining then we need to collect arguments to profile parameters for the target
1799   if (profile_parameters() &amp;&amp; target != NULL) {
1800     if (target-&gt;method_data() != NULL &amp;&amp; target-&gt;method_data()-&gt;parameters_type_data() != NULL) {
1801       // The receiver is profiled on method entry so it&#39;s included in
1802       // the number of parameters but here we&#39;re only interested in
1803       // actual arguments.
1804       n = MAX2(n, target-&gt;method_data()-&gt;parameters_type_data()-&gt;number_of_parameters() - start);
1805     }
1806   }
1807   if (n &gt; 0) {
1808     return new Values(n);
1809   }
1810   return NULL;
1811 }
1812 
1813 void GraphBuilder::check_args_for_profiling(Values* obj_args, int expected) {
1814 #ifdef ASSERT
1815   bool ignored_will_link;
1816   ciSignature* declared_signature = NULL;
1817   ciMethod* real_target = method()-&gt;get_method_at_bci(bci(), ignored_will_link, &amp;declared_signature);
1818   assert(expected == obj_args-&gt;max_length() || real_target-&gt;is_method_handle_intrinsic(), &quot;missed on arg?&quot;);
1819 #endif
1820 }
1821 
1822 // Collect arguments that we want to profile in a list
1823 Values* GraphBuilder::collect_args_for_profiling(Values* args, ciMethod* target, bool may_have_receiver) {
1824   int start = 0;
1825   Values* obj_args = args_list_for_profiling(target, start, may_have_receiver);
1826   if (obj_args == NULL) {
1827     return NULL;
1828   }
1829   int s = obj_args-&gt;max_length();
1830   // if called through method handle invoke, some arguments may have been popped
1831   for (int i = start, j = 0; j &lt; s &amp;&amp; i &lt; args-&gt;length(); i++) {
1832     if (args-&gt;at(i)-&gt;type()-&gt;is_object_kind()) {
1833       obj_args-&gt;push(args-&gt;at(i));
1834       j++;
1835     }
1836   }
1837   check_args_for_profiling(obj_args, s);
1838   return obj_args;
1839 }
1840 
1841 
1842 void GraphBuilder::invoke(Bytecodes::Code code) {
1843   bool will_link;
1844   ciSignature* declared_signature = NULL;
1845   ciMethod*             target = stream()-&gt;get_method(will_link, &amp;declared_signature);
1846   ciKlass*              holder = stream()-&gt;get_declared_method_holder();
1847   const Bytecodes::Code bc_raw = stream()-&gt;cur_bc_raw();
1848   assert(declared_signature != NULL, &quot;cannot be null&quot;);
1849   assert(will_link == target-&gt;is_loaded(), &quot;&quot;);
1850 
1851   ciInstanceKlass* klass = target-&gt;holder();
1852   assert(!target-&gt;is_loaded() || klass-&gt;is_loaded(), &quot;loaded target must imply loaded klass&quot;);
1853 
1854   // check if CHA possible: if so, change the code to invoke_special
1855   ciInstanceKlass* calling_klass = method()-&gt;holder();
1856   ciInstanceKlass* callee_holder = ciEnv::get_instance_klass_for_declared_method_holder(holder);
1857   ciInstanceKlass* actual_recv = callee_holder;
1858 
1859   CompileLog* log = compilation()-&gt;log();
1860   if (log != NULL)
1861       log-&gt;elem(&quot;call method=&#39;%d&#39; instr=&#39;%s&#39;&quot;,
1862                 log-&gt;identify(target),
1863                 Bytecodes::name(code));
1864 
1865   // invoke-special-super
1866   if (bc_raw == Bytecodes::_invokespecial &amp;&amp; !target-&gt;is_object_initializer()) {
1867     ciInstanceKlass* sender_klass =
1868           calling_klass-&gt;is_unsafe_anonymous() ? calling_klass-&gt;unsafe_anonymous_host() :
1869                                                  calling_klass;
1870     if (sender_klass-&gt;is_interface()) {
1871       int index = state()-&gt;stack_size() - (target-&gt;arg_size_no_receiver() + 1);
1872       Value receiver = state()-&gt;stack_at(index);
1873       CheckCast* c = new CheckCast(sender_klass, receiver, copy_state_before());
1874       c-&gt;set_invokespecial_receiver_check();
1875       state()-&gt;stack_at_put(index, append_split(c));
1876     }
1877   }
1878 
1879   // Some methods are obviously bindable without any type checks so
1880   // convert them directly to an invokespecial or invokestatic.
1881   if (target-&gt;is_loaded() &amp;&amp; !target-&gt;is_abstract() &amp;&amp; target-&gt;can_be_statically_bound()) {
1882     switch (bc_raw) {
1883     case Bytecodes::_invokevirtual:
1884       code = Bytecodes::_invokespecial;
1885       break;
1886     case Bytecodes::_invokehandle:
1887       code = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokespecial;
1888       break;
1889     default:
1890       break;
1891     }
1892   } else {
1893     if (bc_raw == Bytecodes::_invokehandle) {
1894       assert(!will_link, &quot;should come here only for unlinked call&quot;);
1895       code = Bytecodes::_invokespecial;
1896     }
1897   }
1898 
1899   // Push appendix argument (MethodType, CallSite, etc.), if one.
1900   bool patch_for_appendix = false;
1901   int patching_appendix_arg = 0;
1902   if (Bytecodes::has_optional_appendix(bc_raw) &amp;&amp; (!will_link || PatchALot)) {
1903     Value arg = append(new Constant(new ObjectConstant(compilation()-&gt;env()-&gt;unloaded_ciinstance()), copy_state_before()));
1904     apush(arg);
1905     patch_for_appendix = true;
1906     patching_appendix_arg = (will_link &amp;&amp; stream()-&gt;has_appendix()) ? 0 : 1;
1907   } else if (stream()-&gt;has_appendix()) {
1908     ciObject* appendix = stream()-&gt;get_appendix();
1909     Value arg = append(new Constant(new ObjectConstant(appendix)));
1910     apush(arg);
1911   }
1912 
1913   ciMethod* cha_monomorphic_target = NULL;
1914   ciMethod* exact_target = NULL;
1915   Value better_receiver = NULL;
1916   if (UseCHA &amp;&amp; DeoptC1 &amp;&amp; target-&gt;is_loaded() &amp;&amp;
1917       !(// %%% FIXME: Are both of these relevant?
1918         target-&gt;is_method_handle_intrinsic() ||
1919         target-&gt;is_compiled_lambda_form()) &amp;&amp;
1920       !patch_for_appendix) {
1921     Value receiver = NULL;
1922     ciInstanceKlass* receiver_klass = NULL;
1923     bool type_is_exact = false;
1924     // try to find a precise receiver type
1925     if (will_link &amp;&amp; !target-&gt;is_static()) {
1926       int index = state()-&gt;stack_size() - (target-&gt;arg_size_no_receiver() + 1);
1927       receiver = state()-&gt;stack_at(index);
1928       ciType* type = receiver-&gt;exact_type();
1929       if (type != NULL &amp;&amp; type-&gt;is_loaded() &amp;&amp;
1930           type-&gt;is_instance_klass() &amp;&amp; !type-&gt;as_instance_klass()-&gt;is_interface()) {
1931         receiver_klass = (ciInstanceKlass*) type;
1932         type_is_exact = true;
1933       }
1934       if (type == NULL) {
1935         type = receiver-&gt;declared_type();
1936         if (type != NULL &amp;&amp; type-&gt;is_loaded() &amp;&amp;
1937             type-&gt;is_instance_klass() &amp;&amp; !type-&gt;as_instance_klass()-&gt;is_interface()) {
1938           receiver_klass = (ciInstanceKlass*) type;
1939           if (receiver_klass-&gt;is_leaf_type() &amp;&amp; !receiver_klass-&gt;is_final()) {
1940             // Insert a dependency on this type since
1941             // find_monomorphic_target may assume it&#39;s already done.
1942             dependency_recorder()-&gt;assert_leaf_type(receiver_klass);
1943             type_is_exact = true;
1944           }
1945         }
1946       }
1947     }
1948     if (receiver_klass != NULL &amp;&amp; type_is_exact &amp;&amp;
1949         receiver_klass-&gt;is_loaded() &amp;&amp; code != Bytecodes::_invokespecial) {
1950       // If we have the exact receiver type we can bind directly to
1951       // the method to call.
1952       exact_target = target-&gt;resolve_invoke(calling_klass, receiver_klass);
1953       if (exact_target != NULL) {
1954         target = exact_target;
1955         code = Bytecodes::_invokespecial;
1956       }
1957     }
1958     if (receiver_klass != NULL &amp;&amp;
1959         receiver_klass-&gt;is_subtype_of(actual_recv) &amp;&amp;
1960         actual_recv-&gt;is_initialized()) {
1961       actual_recv = receiver_klass;
1962     }
1963 
1964     if ((code == Bytecodes::_invokevirtual &amp;&amp; callee_holder-&gt;is_initialized()) ||
1965         (code == Bytecodes::_invokeinterface &amp;&amp; callee_holder-&gt;is_initialized() &amp;&amp; !actual_recv-&gt;is_interface())) {
1966       // Use CHA on the receiver to select a more precise method.
1967       cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, callee_holder, actual_recv);
1968     } else if (code == Bytecodes::_invokeinterface &amp;&amp; callee_holder-&gt;is_loaded() &amp;&amp; receiver != NULL) {
1969       assert(callee_holder-&gt;is_interface(), &quot;invokeinterface to non interface?&quot;);
1970       // If there is only one implementor of this interface then we
1971       // may be able bind this invoke directly to the implementing
1972       // klass but we need both a dependence on the single interface
1973       // and on the method we bind to.  Additionally since all we know
1974       // about the receiver type is the it&#39;s supposed to implement the
1975       // interface we have to insert a check that it&#39;s the class we
1976       // expect.  Interface types are not checked by the verifier so
1977       // they are roughly equivalent to Object.
1978       // The number of implementors for declared_interface is less or
1979       // equal to the number of implementors for target-&gt;holder() so
1980       // if number of implementors of target-&gt;holder() == 1 then
1981       // number of implementors for decl_interface is 0 or 1. If
1982       // it&#39;s 0 then no class implements decl_interface and there&#39;s
1983       // no point in inlining.
1984       ciInstanceKlass* declared_interface = callee_holder;
1985       ciInstanceKlass* singleton = declared_interface-&gt;unique_implementor();
1986       if (singleton != NULL &amp;&amp;
1987           (!target-&gt;is_default_method() || target-&gt;is_overpass()) /* CHA doesn&#39;t support default methods yet. */ ) {
1988         assert(singleton != declared_interface, &quot;not a unique implementor&quot;);
1989         cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, declared_interface, singleton);
1990         if (cha_monomorphic_target != NULL) {
1991           if (cha_monomorphic_target-&gt;holder() != compilation()-&gt;env()-&gt;Object_klass()) {
1992             // If CHA is able to bind this invoke then update the class
1993             // to match that class, otherwise klass will refer to the
1994             // interface.
1995             klass = cha_monomorphic_target-&gt;holder();
1996             actual_recv = declared_interface;
1997 
1998             // insert a check it&#39;s really the expected class.
1999             CheckCast* c = new CheckCast(klass, receiver, copy_state_for_exception());
2000             c-&gt;set_incompatible_class_change_check();
2001             c-&gt;set_direct_compare(klass-&gt;is_final());
2002             // pass the result of the checkcast so that the compiler has
2003             // more accurate type info in the inlinee
2004             better_receiver = append_split(c);
2005           } else {
2006             cha_monomorphic_target = NULL; // subtype check against Object is useless
2007           }
2008         }
2009       }
2010     }
2011   }
2012 
2013   if (cha_monomorphic_target != NULL) {
2014     assert(!target-&gt;can_be_statically_bound() || target == cha_monomorphic_target, &quot;&quot;);
2015     assert(!cha_monomorphic_target-&gt;is_abstract(), &quot;&quot;);
2016     if (!cha_monomorphic_target-&gt;can_be_statically_bound(actual_recv)) {
2017       // If we inlined because CHA revealed only a single target method,
2018       // then we are dependent on that target method not getting overridden
2019       // by dynamic class loading.  Be sure to test the &quot;static&quot; receiver
2020       // dest_method here, as opposed to the actual receiver, which may
2021       // falsely lead us to believe that the receiver is final or private.
2022       dependency_recorder()-&gt;assert_unique_concrete_method(actual_recv, cha_monomorphic_target);
2023     }
2024     code = Bytecodes::_invokespecial;
2025   }
2026 
2027   // check if we could do inlining
2028   if (!PatchALot &amp;&amp; Inline &amp;&amp; target-&gt;is_loaded() &amp;&amp;
2029       (klass-&gt;is_initialized() || (klass-&gt;is_interface() &amp;&amp; target-&gt;holder()-&gt;is_initialized()))
2030       &amp;&amp; !patch_for_appendix) {
2031     // callee is known =&gt; check if we have static binding
2032     if (code == Bytecodes::_invokestatic  ||
2033         code == Bytecodes::_invokespecial ||
2034         (code == Bytecodes::_invokevirtual &amp;&amp; target-&gt;is_final_method()) ||
2035         code == Bytecodes::_invokedynamic) {
2036       ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;
2037       // static binding =&gt; check if callee is ok
2038       bool success = try_inline(inline_target, (cha_monomorphic_target != NULL) || (exact_target != NULL), false, code, better_receiver);
2039 
2040       CHECK_BAILOUT();
2041       clear_inline_bailout();
2042 
2043       if (success) {
2044         // Register dependence if JVMTI has either breakpoint
2045         // setting or hotswapping of methods capabilities since they may
2046         // cause deoptimization.
2047         if (compilation()-&gt;env()-&gt;jvmti_can_hotswap_or_post_breakpoint()) {
2048           dependency_recorder()-&gt;assert_evol_method(inline_target);
2049         }
2050         return;
2051       }
2052     } else {
2053       print_inlining(target, &quot;no static binding&quot;, /*success*/ false);
2054     }
2055   } else {
2056     print_inlining(target, &quot;not inlineable&quot;, /*success*/ false);
2057   }
2058 
2059   // If we attempted an inline which did not succeed because of a
2060   // bailout during construction of the callee graph, the entire
2061   // compilation has to be aborted. This is fairly rare and currently
2062   // seems to only occur for jasm-generated classes which contain
2063   // jsr/ret pairs which are not associated with finally clauses and
2064   // do not have exception handlers in the containing method, and are
2065   // therefore not caught early enough to abort the inlining without
2066   // corrupting the graph. (We currently bail out with a non-empty
2067   // stack at a ret in these situations.)
2068   CHECK_BAILOUT();
2069 
2070   // inlining not successful =&gt; standard invoke
2071   ValueType* result_type = as_ValueType(declared_signature-&gt;return_type());
2072   ValueStack* state_before = copy_state_exhandling();
2073 
2074   // The bytecode (code) might change in this method so we are checking this very late.
2075   const bool has_receiver =
2076     code == Bytecodes::_invokespecial   ||
2077     code == Bytecodes::_invokevirtual   ||
2078     code == Bytecodes::_invokeinterface;
2079   Values* args = state()-&gt;pop_arguments(target-&gt;arg_size_no_receiver() + patching_appendix_arg);
2080   Value recv = has_receiver ? apop() : NULL;
2081   int vtable_index = Method::invalid_vtable_index;
2082 
2083 #ifdef SPARC
2084   // Currently only supported on Sparc.
2085   // The UseInlineCaches only controls dispatch to invokevirtuals for
2086   // loaded classes which we weren&#39;t able to statically bind.
2087   if (!UseInlineCaches &amp;&amp; target-&gt;is_loaded() &amp;&amp; code == Bytecodes::_invokevirtual
2088       &amp;&amp; !target-&gt;can_be_statically_bound()) {
2089     // Find a vtable index if one is available
2090     // For arrays, callee_holder is Object. Resolving the call with
2091     // Object would allow an illegal call to finalize() on an
2092     // array. We use holder instead: illegal calls to finalize() won&#39;t
2093     // be compiled as vtable calls (IC call resolution will catch the
2094     // illegal call) and the few legal calls on array types won&#39;t be
2095     // either.
2096     vtable_index = target-&gt;resolve_vtable_index(calling_klass, holder);
2097   }
2098 #endif
2099 
2100   // A null check is required here (when there is a receiver) for any of the following cases
2101   // - invokespecial, always need a null check.
2102   // - invokevirtual, when the target is final and loaded. Calls to final targets will become optimized
2103   //   and require null checking. If the target is loaded a null check is emitted here.
2104   //   If the target isn&#39;t loaded the null check must happen after the call resolution. We achieve that
2105   //   by using the target methods unverified entry point (see CompiledIC::compute_monomorphic_entry).
2106   //   (The JVM specification requires that LinkageError must be thrown before a NPE. An unloaded target may
2107   //   potentially fail, and can&#39;t have the null check before the resolution.)
2108   // - A call that will be profiled. (But we can&#39;t add a null check when the target is unloaded, by the same
2109   //   reason as above, so calls with a receiver to unloaded targets can&#39;t be profiled.)
2110   //
2111   // Normal invokevirtual will perform the null check during lookup
2112 
2113   bool need_null_check = (code == Bytecodes::_invokespecial) ||
2114       (target-&gt;is_loaded() &amp;&amp; (target-&gt;is_final_method() || (is_profiling() &amp;&amp; profile_calls())));
2115 
2116   if (need_null_check) {
2117     if (recv != NULL) {
2118       null_check(recv);
2119     }
2120 
2121     if (is_profiling()) {
2122       // Note that we&#39;d collect profile data in this method if we wanted it.
2123       compilation()-&gt;set_would_profile(true);
2124 
2125       if (profile_calls()) {
2126         assert(cha_monomorphic_target == NULL || exact_target == NULL, &quot;both can not be set&quot;);
2127         ciKlass* target_klass = NULL;
2128         if (cha_monomorphic_target != NULL) {
2129           target_klass = cha_monomorphic_target-&gt;holder();
2130         } else if (exact_target != NULL) {
2131           target_klass = exact_target-&gt;holder();
2132         }
2133         profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);
2134       }
2135     }
2136   }
2137 
2138   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before);
2139   // push result
2140   append_split(result);
2141 
2142   if (result_type != voidType) {
2143     if (method()-&gt;is_strict()) {
2144       push(result_type, round_fp(result));
2145     } else {
2146       push(result_type, result);
2147     }
2148   }
2149   if (profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
2150     profile_return_type(result, target);
2151   }
2152 }
2153 
2154 
2155 void GraphBuilder::new_instance(int klass_index) {
2156   ValueStack* state_before = copy_state_exhandling();
2157   bool will_link;
2158   ciKlass* klass = stream()-&gt;get_klass(will_link);
2159   assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2160   NewInstance* new_instance = new NewInstance(klass-&gt;as_instance_klass(), state_before, stream()-&gt;is_unresolved_klass());
2161   _memory-&gt;new_instance(new_instance);
2162   apush(append_split(new_instance));
2163 }
2164 
2165 
2166 void GraphBuilder::new_type_array() {
2167   ValueStack* state_before = copy_state_exhandling();
2168   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2169 }
2170 
2171 
2172 void GraphBuilder::new_object_array() {
2173   bool will_link;
2174   ciKlass* klass = stream()-&gt;get_klass(will_link);
2175   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2176   NewArray* n = new NewObjectArray(klass, ipop(), state_before);
2177   apush(append_split(n));
2178 }
2179 
2180 
2181 bool GraphBuilder::direct_compare(ciKlass* k) {
2182   if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_instance_klass() &amp;&amp; !UseSlowPath) {
2183     ciInstanceKlass* ik = k-&gt;as_instance_klass();
2184     if (ik-&gt;is_final()) {
2185       return true;
2186     } else {
2187       if (DeoptC1 &amp;&amp; UseCHA &amp;&amp; !(ik-&gt;has_subklass() || ik-&gt;is_interface())) {
2188         // test class is leaf class
2189         dependency_recorder()-&gt;assert_leaf_type(ik);
2190         return true;
2191       }
2192     }
2193   }
2194   return false;
2195 }
2196 
2197 
2198 void GraphBuilder::check_cast(int klass_index) {
2199   bool will_link;
2200   ciKlass* klass = stream()-&gt;get_klass(will_link);
2201   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_for_exception();
2202   CheckCast* c = new CheckCast(klass, apop(), state_before);
2203   apush(append_split(c));
2204   c-&gt;set_direct_compare(direct_compare(klass));
2205 
2206   if (is_profiling()) {
2207     // Note that we&#39;d collect profile data in this method if we wanted it.
2208     compilation()-&gt;set_would_profile(true);
2209 
2210     if (profile_checkcasts()) {
2211       c-&gt;set_profiled_method(method());
2212       c-&gt;set_profiled_bci(bci());
2213       c-&gt;set_should_profile(true);
2214     }
2215   }
2216 }
2217 
2218 
2219 void GraphBuilder::instance_of(int klass_index) {
2220   bool will_link;
2221   ciKlass* klass = stream()-&gt;get_klass(will_link);
2222   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2223   InstanceOf* i = new InstanceOf(klass, apop(), state_before);
2224   ipush(append_split(i));
2225   i-&gt;set_direct_compare(direct_compare(klass));
2226 
2227   if (is_profiling()) {
2228     // Note that we&#39;d collect profile data in this method if we wanted it.
2229     compilation()-&gt;set_would_profile(true);
2230 
2231     if (profile_checkcasts()) {
2232       i-&gt;set_profiled_method(method());
2233       i-&gt;set_profiled_bci(bci());
2234       i-&gt;set_should_profile(true);
2235     }
2236   }
2237 }
2238 
2239 
2240 void GraphBuilder::monitorenter(Value x, int bci) {
2241   // save state before locking in case of deoptimization after a NullPointerException
2242   ValueStack* state_before = copy_state_for_exception_with_bci(bci);
2243   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before), bci);
2244   kill_all();
2245 }
2246 
2247 
2248 void GraphBuilder::monitorexit(Value x, int bci) {
2249   append_with_bci(new MonitorExit(x, state()-&gt;unlock()), bci);
2250   kill_all();
2251 }
2252 
2253 
2254 void GraphBuilder::new_multi_array(int dimensions) {
2255   bool will_link;
2256   ciKlass* klass = stream()-&gt;get_klass(will_link);
2257   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2258 
2259   Values* dims = new Values(dimensions, dimensions, NULL);
2260   // fill in all dimensions
2261   int i = dimensions;
2262   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2263   // create array
2264   NewArray* n = new NewMultiArray(klass, dims, state_before);
2265   apush(append_split(n));
2266 }
2267 
2268 
2269 void GraphBuilder::throw_op(int bci) {
2270   // We require that the debug info for a Throw be the &quot;state before&quot;
2271   // the Throw (i.e., exception oop is still on TOS)
2272   ValueStack* state_before = copy_state_before_with_bci(bci);
2273   Throw* t = new Throw(apop(), state_before);
2274   // operand stack not needed after a throw
2275   state()-&gt;truncate_stack(0);
2276   append_with_bci(t, bci);
2277 }
2278 
2279 
2280 Value GraphBuilder::round_fp(Value fp_value) {
2281   if (strict_fp_requires_explicit_rounding) {
2282 #ifdef IA32
2283     // no rounding needed if SSE2 is used
2284     if (UseSSE &lt; 2) {
2285       // Must currently insert rounding node for doubleword values that
2286       // are results of expressions (i.e., not loads from memory or
2287       // constants)
2288       if (fp_value-&gt;type()-&gt;tag() == doubleTag &amp;&amp;
2289           fp_value-&gt;as_Constant() == NULL &amp;&amp;
2290           fp_value-&gt;as_Local() == NULL &amp;&amp;       // method parameters need no rounding
2291           fp_value-&gt;as_RoundFP() == NULL) {
2292         return append(new RoundFP(fp_value));
2293       }
2294     }
2295 #else
2296     Unimplemented();
2297 #endif // IA32
2298   }
2299   return fp_value;
2300 }
2301 
2302 
2303 Instruction* GraphBuilder::append_with_bci(Instruction* instr, int bci) {
2304   Canonicalizer canon(compilation(), instr, bci);
2305   Instruction* i1 = canon.canonical();
2306   if (i1-&gt;is_linked() || !i1-&gt;can_be_linked()) {
2307     // Canonicalizer returned an instruction which was already
2308     // appended so simply return it.
2309     return i1;
2310   }
2311 
2312   if (UseLocalValueNumbering) {
2313     // Lookup the instruction in the ValueMap and add it to the map if
2314     // it&#39;s not found.
2315     Instruction* i2 = vmap()-&gt;find_insert(i1);
2316     if (i2 != i1) {
2317       // found an entry in the value map, so just return it.
2318       assert(i2-&gt;is_linked(), &quot;should already be linked&quot;);
2319       return i2;
2320     }
2321     ValueNumberingEffects vne(vmap());
2322     i1-&gt;visit(&amp;vne);
2323   }
2324 
2325   // i1 was not eliminated =&gt; append it
2326   assert(i1-&gt;next() == NULL, &quot;shouldn&#39;t already be linked&quot;);
2327   _last = _last-&gt;set_next(i1, canon.bci());
2328 
2329   if (++_instruction_count &gt;= InstructionCountCutoff &amp;&amp; !bailed_out()) {
2330     // set the bailout state but complete normal processing.  We
2331     // might do a little more work before noticing the bailout so we
2332     // want processing to continue normally until it&#39;s noticed.
2333     bailout(&quot;Method and/or inlining is too large&quot;);
2334   }
2335 
2336 #ifndef PRODUCT
2337   if (PrintIRDuringConstruction) {
2338     InstructionPrinter ip;
2339     ip.print_line(i1);
2340     if (Verbose) {
2341       state()-&gt;print();
2342     }
2343   }
2344 #endif
2345 
2346   // save state after modification of operand stack for StateSplit instructions
2347   StateSplit* s = i1-&gt;as_StateSplit();
2348   if (s != NULL) {
2349     if (EliminateFieldAccess) {
2350       Intrinsic* intrinsic = s-&gt;as_Intrinsic();
2351       if (s-&gt;as_Invoke() != NULL || (intrinsic &amp;&amp; !intrinsic-&gt;preserves_state())) {
2352         _memory-&gt;kill();
2353       }
2354     }
2355     s-&gt;set_state(state()-&gt;copy(ValueStack::StateAfter, canon.bci()));
2356   }
2357 
2358   // set up exception handlers for this instruction if necessary
2359   if (i1-&gt;can_trap()) {
2360     i1-&gt;set_exception_handlers(handle_exception(i1));
2361     assert(i1-&gt;exception_state() != NULL || !i1-&gt;needs_exception_state() || bailed_out(), &quot;handle_exception must set exception state&quot;);
2362   }
2363   return i1;
2364 }
2365 
2366 
2367 Instruction* GraphBuilder::append(Instruction* instr) {
2368   assert(instr-&gt;as_StateSplit() == NULL || instr-&gt;as_BlockEnd() != NULL, &quot;wrong append used&quot;);
2369   return append_with_bci(instr, bci());
2370 }
2371 
2372 
2373 Instruction* GraphBuilder::append_split(StateSplit* instr) {
2374   return append_with_bci(instr, bci());
2375 }
2376 
2377 
2378 void GraphBuilder::null_check(Value value) {
2379   if (value-&gt;as_NewArray() != NULL || value-&gt;as_NewInstance() != NULL) {
2380     return;
2381   } else {
2382     Constant* con = value-&gt;as_Constant();
2383     if (con) {
2384       ObjectType* c = con-&gt;type()-&gt;as_ObjectType();
2385       if (c &amp;&amp; c-&gt;is_loaded()) {
2386         ObjectConstant* oc = c-&gt;as_ObjectConstant();
2387         if (!oc || !oc-&gt;value()-&gt;is_null_object()) {
2388           return;
2389         }
2390       }
2391     }
2392   }
2393   append(new NullCheck(value, copy_state_for_exception()));
2394 }
2395 
2396 
2397 
2398 XHandlers* GraphBuilder::handle_exception(Instruction* instruction) {
2399   if (!has_handler() &amp;&amp; (!instruction-&gt;needs_exception_state() || instruction-&gt;exception_state() != NULL)) {
2400     assert(instruction-&gt;exception_state() == NULL
2401            || instruction-&gt;exception_state()-&gt;kind() == ValueStack::EmptyExceptionState
2402            || (instruction-&gt;exception_state()-&gt;kind() == ValueStack::ExceptionState &amp;&amp; _compilation-&gt;env()-&gt;should_retain_local_variables()),
2403            &quot;exception_state should be of exception kind&quot;);
2404     return new XHandlers();
2405   }
2406 
2407   XHandlers*  exception_handlers = new XHandlers();
2408   ScopeData*  cur_scope_data = scope_data();
2409   ValueStack* cur_state = instruction-&gt;state_before();
2410   ValueStack* prev_state = NULL;
2411   int scope_count = 0;
2412 
2413   assert(cur_state != NULL, &quot;state_before must be set&quot;);
2414   do {
2415     int cur_bci = cur_state-&gt;bci();
2416     assert(cur_scope_data-&gt;scope() == cur_state-&gt;scope(), &quot;scopes do not match&quot;);
2417     assert(cur_bci == SynchronizationEntryBCI || cur_bci == cur_scope_data-&gt;stream()-&gt;cur_bci(), &quot;invalid bci&quot;);
2418 
2419     // join with all potential exception handlers
2420     XHandlers* list = cur_scope_data-&gt;xhandlers();
2421     const int n = list-&gt;length();
2422     for (int i = 0; i &lt; n; i++) {
2423       XHandler* h = list-&gt;handler_at(i);
2424       if (h-&gt;covers(cur_bci)) {
2425         // h is a potential exception handler =&gt; join it
2426         compilation()-&gt;set_has_exception_handlers(true);
2427 
2428         BlockBegin* entry = h-&gt;entry_block();
2429         if (entry == block()) {
2430           // It&#39;s acceptable for an exception handler to cover itself
2431           // but we don&#39;t handle that in the parser currently.  It&#39;s
2432           // very rare so we bailout instead of trying to handle it.
2433           BAILOUT_(&quot;exception handler covers itself&quot;, exception_handlers);
2434         }
2435         assert(entry-&gt;bci() == h-&gt;handler_bci(), &quot;must match&quot;);
2436         assert(entry-&gt;bci() == -1 || entry == cur_scope_data-&gt;block_at(entry-&gt;bci()), &quot;blocks must correspond&quot;);
2437 
2438         // previously this was a BAILOUT, but this is not necessary
2439         // now because asynchronous exceptions are not handled this way.
2440         assert(entry-&gt;state() == NULL || cur_state-&gt;total_locks_size() == entry-&gt;state()-&gt;total_locks_size(), &quot;locks do not match&quot;);
2441 
2442         // xhandler start with an empty expression stack
2443         if (cur_state-&gt;stack_size() != 0) {
2444           cur_state = cur_state-&gt;copy(ValueStack::ExceptionState, cur_state-&gt;bci());
2445         }
2446         if (instruction-&gt;exception_state() == NULL) {
2447           instruction-&gt;set_exception_state(cur_state);
2448         }
2449 
2450         // Note: Usually this join must work. However, very
2451         // complicated jsr-ret structures where we don&#39;t ret from
2452         // the subroutine can cause the objects on the monitor
2453         // stacks to not match because blocks can be parsed twice.
2454         // The only test case we&#39;ve seen so far which exhibits this
2455         // problem is caught by the infinite recursion test in
2456         // GraphBuilder::jsr() if the join doesn&#39;t work.
2457         if (!entry-&gt;try_merge(cur_state)) {
2458           BAILOUT_(&quot;error while joining with exception handler, prob. due to complicated jsr/rets&quot;, exception_handlers);
2459         }
2460 
2461         // add current state for correct handling of phi functions at begin of xhandler
2462         int phi_operand = entry-&gt;add_exception_state(cur_state);
2463 
2464         // add entry to the list of xhandlers of this block
2465         _block-&gt;add_exception_handler(entry);
2466 
2467         // add back-edge from xhandler entry to this block
2468         if (!entry-&gt;is_predecessor(_block)) {
2469           entry-&gt;add_predecessor(_block);
2470         }
2471 
2472         // clone XHandler because phi_operand and scope_count can not be shared
2473         XHandler* new_xhandler = new XHandler(h);
2474         new_xhandler-&gt;set_phi_operand(phi_operand);
2475         new_xhandler-&gt;set_scope_count(scope_count);
2476         exception_handlers-&gt;append(new_xhandler);
2477 
2478         // fill in exception handler subgraph lazily
2479         assert(!entry-&gt;is_set(BlockBegin::was_visited_flag), &quot;entry must not be visited yet&quot;);
2480         cur_scope_data-&gt;add_to_work_list(entry);
2481 
2482         // stop when reaching catchall
2483         if (h-&gt;catch_type() == 0) {
2484           return exception_handlers;
2485         }
2486       }
2487     }
2488 
2489     if (exception_handlers-&gt;length() == 0) {
2490       // This scope and all callees do not handle exceptions, so the local
2491       // variables of this scope are not needed. However, the scope itself is
2492       // required for a correct exception stack trace -&gt; clear out the locals.
2493       if (_compilation-&gt;env()-&gt;should_retain_local_variables()) {
2494         cur_state = cur_state-&gt;copy(ValueStack::ExceptionState, cur_state-&gt;bci());
2495       } else {
2496         cur_state = cur_state-&gt;copy(ValueStack::EmptyExceptionState, cur_state-&gt;bci());
2497       }
2498       if (prev_state != NULL) {
2499         prev_state-&gt;set_caller_state(cur_state);
2500       }
2501       if (instruction-&gt;exception_state() == NULL) {
2502         instruction-&gt;set_exception_state(cur_state);
2503       }
2504     }
2505 
2506     // Set up iteration for next time.
2507     // If parsing a jsr, do not grab exception handlers from the
2508     // parent scopes for this method (already got them, and they
2509     // needed to be cloned)
2510 
2511     while (cur_scope_data-&gt;parsing_jsr()) {
2512       cur_scope_data = cur_scope_data-&gt;parent();
2513     }
2514 
2515     assert(cur_scope_data-&gt;scope() == cur_state-&gt;scope(), &quot;scopes do not match&quot;);
2516     assert(cur_state-&gt;locks_size() == 0 || cur_state-&gt;locks_size() == 1, &quot;unlocking must be done in a catchall exception handler&quot;);
2517 
2518     prev_state = cur_state;
2519     cur_state = cur_state-&gt;caller_state();
2520     cur_scope_data = cur_scope_data-&gt;parent();
2521     scope_count++;
2522   } while (cur_scope_data != NULL);
2523 
2524   return exception_handlers;
2525 }
2526 
2527 
2528 // Helper class for simplifying Phis.
2529 class PhiSimplifier : public BlockClosure {
2530  private:
2531   bool _has_substitutions;
2532   Value simplify(Value v);
2533 
2534  public:
2535   PhiSimplifier(BlockBegin* start) : _has_substitutions(false) {
2536     start-&gt;iterate_preorder(this);
2537     if (_has_substitutions) {
2538       SubstitutionResolver sr(start);
2539     }
2540   }
2541   void block_do(BlockBegin* b);
2542   bool has_substitutions() const { return _has_substitutions; }
2543 };
2544 
2545 
2546 Value PhiSimplifier::simplify(Value v) {
2547   Phi* phi = v-&gt;as_Phi();
2548 
2549   if (phi == NULL) {
2550     // no phi function
2551     return v;
2552   } else if (v-&gt;has_subst()) {
2553     // already substituted; subst can be phi itself -&gt; simplify
2554     return simplify(v-&gt;subst());
2555   } else if (phi-&gt;is_set(Phi::cannot_simplify)) {
2556     // already tried to simplify phi before
2557     return phi;
2558   } else if (phi-&gt;is_set(Phi::visited)) {
2559     // break cycles in phi functions
2560     return phi;
2561   } else if (phi-&gt;type()-&gt;is_illegal()) {
2562     // illegal phi functions are ignored anyway
2563     return phi;
2564 
2565   } else {
2566     // mark phi function as processed to break cycles in phi functions
2567     phi-&gt;set(Phi::visited);
2568 
2569     // simplify x = [y, x] and x = [y, y] to y
2570     Value subst = NULL;
2571     int opd_count = phi-&gt;operand_count();
2572     for (int i = 0; i &lt; opd_count; i++) {
2573       Value opd = phi-&gt;operand_at(i);
2574       assert(opd != NULL, &quot;Operand must exist!&quot;);
2575 
2576       if (opd-&gt;type()-&gt;is_illegal()) {
2577         // if one operand is illegal, the entire phi function is illegal
2578         phi-&gt;make_illegal();
2579         phi-&gt;clear(Phi::visited);
2580         return phi;
2581       }
2582 
2583       Value new_opd = simplify(opd);
2584       assert(new_opd != NULL, &quot;Simplified operand must exist!&quot;);
2585 
2586       if (new_opd != phi &amp;&amp; new_opd != subst) {
2587         if (subst == NULL) {
2588           subst = new_opd;
2589         } else {
2590           // no simplification possible
2591           phi-&gt;set(Phi::cannot_simplify);
2592           phi-&gt;clear(Phi::visited);
2593           return phi;
2594         }
2595       }
2596     }
2597 
2598     // sucessfully simplified phi function
2599     assert(subst != NULL, &quot;illegal phi function&quot;);
2600     _has_substitutions = true;
2601     phi-&gt;clear(Phi::visited);
2602     phi-&gt;set_subst(subst);
2603 
2604 #ifndef PRODUCT
2605     if (PrintPhiFunctions) {
2606       tty-&gt;print_cr(&quot;simplified phi function %c%d to %c%d (Block B%d)&quot;, phi-&gt;type()-&gt;tchar(), phi-&gt;id(), subst-&gt;type()-&gt;tchar(), subst-&gt;id(), phi-&gt;block()-&gt;block_id());
2607     }
2608 #endif
2609 
2610     return subst;
2611   }
2612 }
2613 
2614 
2615 void PhiSimplifier::block_do(BlockBegin* b) {
2616   for_each_phi_fun(b, phi,
2617     simplify(phi);
2618   );
2619 
2620 #ifdef ASSERT
2621   for_each_phi_fun(b, phi,
2622                    assert(phi-&gt;operand_count() != 1 || phi-&gt;subst() != phi || phi-&gt;is_illegal(), &quot;missed trivial simplification&quot;);
2623   );
2624 
2625   ValueStack* state = b-&gt;state()-&gt;caller_state();
2626   for_each_state_value(state, value,
2627     Phi* phi = value-&gt;as_Phi();
2628     assert(phi == NULL || phi-&gt;block() != b, &quot;must not have phi function to simplify in caller state&quot;);
2629   );
2630 #endif
2631 }
2632 
2633 // This method is called after all blocks are filled with HIR instructions
2634 // It eliminates all Phi functions of the form x = [y, y] and x = [y, x]
2635 void GraphBuilder::eliminate_redundant_phis(BlockBegin* start) {
2636   PhiSimplifier simplifier(start);
2637 }
2638 
2639 
2640 void GraphBuilder::connect_to_end(BlockBegin* beg) {
2641   // setup iteration
2642   kill_all();
2643   _block = beg;
2644   _state = beg-&gt;state()-&gt;copy_for_parsing();
2645   _last  = beg;
2646   iterate_bytecodes_for_block(beg-&gt;bci());
2647 }
2648 
2649 
2650 BlockEnd* GraphBuilder::iterate_bytecodes_for_block(int bci) {
2651 #ifndef PRODUCT
2652   if (PrintIRDuringConstruction) {
2653     tty-&gt;cr();
2654     InstructionPrinter ip;
2655     ip.print_instr(_block); tty-&gt;cr();
2656     ip.print_stack(_block-&gt;state()); tty-&gt;cr();
2657     ip.print_inline_level(_block);
2658     ip.print_head();
2659     tty-&gt;print_cr(&quot;locals size: %d stack size: %d&quot;, state()-&gt;locals_size(), state()-&gt;stack_size());
2660   }
2661 #endif
2662   _skip_block = false;
2663   assert(state() != NULL, &quot;ValueStack missing!&quot;);
2664   CompileLog* log = compilation()-&gt;log();
2665   ciBytecodeStream s(method());
2666   s.reset_to_bci(bci);
2667   int prev_bci = bci;
2668   scope_data()-&gt;set_stream(&amp;s);
2669   // iterate
2670   Bytecodes::Code code = Bytecodes::_illegal;
2671   bool push_exception = false;
2672 
2673   if (block()-&gt;is_set(BlockBegin::exception_entry_flag) &amp;&amp; block()-&gt;next() == NULL) {
2674     // first thing in the exception entry block should be the exception object.
2675     push_exception = true;
2676   }
2677 
2678   bool ignore_return = scope_data()-&gt;ignore_return();
2679 
2680   while (!bailed_out() &amp;&amp; last()-&gt;as_BlockEnd() == NULL &amp;&amp;
2681          (code = stream()-&gt;next()) != ciBytecodeStream::EOBC() &amp;&amp;
2682          (block_at(s.cur_bci()) == NULL || block_at(s.cur_bci()) == block())) {
2683     assert(state()-&gt;kind() == ValueStack::Parsing, &quot;invalid state kind&quot;);
2684 
2685     if (log != NULL)
2686       log-&gt;set_context(&quot;bc code=&#39;%d&#39; bci=&#39;%d&#39;&quot;, (int)code, s.cur_bci());
2687 
2688     // Check for active jsr during OSR compilation
2689     if (compilation()-&gt;is_osr_compile()
2690         &amp;&amp; scope()-&gt;is_top_scope()
2691         &amp;&amp; parsing_jsr()
2692         &amp;&amp; s.cur_bci() == compilation()-&gt;osr_bci()) {
2693       bailout(&quot;OSR not supported while a jsr is active&quot;);
2694     }
2695 
2696     if (push_exception) {
2697       apush(append(new ExceptionObject()));
2698       push_exception = false;
2699     }
2700 
2701     // handle bytecode
2702     switch (code) {
2703       case Bytecodes::_nop            : /* nothing to do */ break;
2704       case Bytecodes::_aconst_null    : apush(append(new Constant(objectNull            ))); break;
2705       case Bytecodes::_iconst_m1      : ipush(append(new Constant(new IntConstant   (-1)))); break;
2706       case Bytecodes::_iconst_0       : ipush(append(new Constant(intZero               ))); break;
2707       case Bytecodes::_iconst_1       : ipush(append(new Constant(intOne                ))); break;
2708       case Bytecodes::_iconst_2       : ipush(append(new Constant(new IntConstant   ( 2)))); break;
2709       case Bytecodes::_iconst_3       : ipush(append(new Constant(new IntConstant   ( 3)))); break;
2710       case Bytecodes::_iconst_4       : ipush(append(new Constant(new IntConstant   ( 4)))); break;
2711       case Bytecodes::_iconst_5       : ipush(append(new Constant(new IntConstant   ( 5)))); break;
2712       case Bytecodes::_lconst_0       : lpush(append(new Constant(new LongConstant  ( 0)))); break;
2713       case Bytecodes::_lconst_1       : lpush(append(new Constant(new LongConstant  ( 1)))); break;
2714       case Bytecodes::_fconst_0       : fpush(append(new Constant(new FloatConstant ( 0)))); break;
2715       case Bytecodes::_fconst_1       : fpush(append(new Constant(new FloatConstant ( 1)))); break;
2716       case Bytecodes::_fconst_2       : fpush(append(new Constant(new FloatConstant ( 2)))); break;
2717       case Bytecodes::_dconst_0       : dpush(append(new Constant(new DoubleConstant( 0)))); break;
2718       case Bytecodes::_dconst_1       : dpush(append(new Constant(new DoubleConstant( 1)))); break;
2719       case Bytecodes::_bipush         : ipush(append(new Constant(new IntConstant(((signed char*)s.cur_bcp())[1])))); break;
2720       case Bytecodes::_sipush         : ipush(append(new Constant(new IntConstant((short)Bytes::get_Java_u2(s.cur_bcp()+1))))); break;
2721       case Bytecodes::_ldc            : // fall through
2722       case Bytecodes::_ldc_w          : // fall through
2723       case Bytecodes::_ldc2_w         : load_constant(); break;
2724       case Bytecodes::_iload          : load_local(intType     , s.get_index()); break;
2725       case Bytecodes::_lload          : load_local(longType    , s.get_index()); break;
2726       case Bytecodes::_fload          : load_local(floatType   , s.get_index()); break;
2727       case Bytecodes::_dload          : load_local(doubleType  , s.get_index()); break;
2728       case Bytecodes::_aload          : load_local(instanceType, s.get_index()); break;
2729       case Bytecodes::_iload_0        : load_local(intType   , 0); break;
2730       case Bytecodes::_iload_1        : load_local(intType   , 1); break;
2731       case Bytecodes::_iload_2        : load_local(intType   , 2); break;
2732       case Bytecodes::_iload_3        : load_local(intType   , 3); break;
2733       case Bytecodes::_lload_0        : load_local(longType  , 0); break;
2734       case Bytecodes::_lload_1        : load_local(longType  , 1); break;
2735       case Bytecodes::_lload_2        : load_local(longType  , 2); break;
2736       case Bytecodes::_lload_3        : load_local(longType  , 3); break;
2737       case Bytecodes::_fload_0        : load_local(floatType , 0); break;
2738       case Bytecodes::_fload_1        : load_local(floatType , 1); break;
2739       case Bytecodes::_fload_2        : load_local(floatType , 2); break;
2740       case Bytecodes::_fload_3        : load_local(floatType , 3); break;
2741       case Bytecodes::_dload_0        : load_local(doubleType, 0); break;
2742       case Bytecodes::_dload_1        : load_local(doubleType, 1); break;
2743       case Bytecodes::_dload_2        : load_local(doubleType, 2); break;
2744       case Bytecodes::_dload_3        : load_local(doubleType, 3); break;
2745       case Bytecodes::_aload_0        : load_local(objectType, 0); break;
2746       case Bytecodes::_aload_1        : load_local(objectType, 1); break;
2747       case Bytecodes::_aload_2        : load_local(objectType, 2); break;
2748       case Bytecodes::_aload_3        : load_local(objectType, 3); break;
2749       case Bytecodes::_iaload         : load_indexed(T_INT   ); break;
2750       case Bytecodes::_laload         : load_indexed(T_LONG  ); break;
2751       case Bytecodes::_faload         : load_indexed(T_FLOAT ); break;
2752       case Bytecodes::_daload         : load_indexed(T_DOUBLE); break;
2753       case Bytecodes::_aaload         : load_indexed(T_OBJECT); break;
2754       case Bytecodes::_baload         : load_indexed(T_BYTE  ); break;
2755       case Bytecodes::_caload         : load_indexed(T_CHAR  ); break;
2756       case Bytecodes::_saload         : load_indexed(T_SHORT ); break;
2757       case Bytecodes::_istore         : store_local(intType   , s.get_index()); break;
2758       case Bytecodes::_lstore         : store_local(longType  , s.get_index()); break;
2759       case Bytecodes::_fstore         : store_local(floatType , s.get_index()); break;
2760       case Bytecodes::_dstore         : store_local(doubleType, s.get_index()); break;
2761       case Bytecodes::_astore         : store_local(objectType, s.get_index()); break;
2762       case Bytecodes::_istore_0       : store_local(intType   , 0); break;
2763       case Bytecodes::_istore_1       : store_local(intType   , 1); break;
2764       case Bytecodes::_istore_2       : store_local(intType   , 2); break;
2765       case Bytecodes::_istore_3       : store_local(intType   , 3); break;
2766       case Bytecodes::_lstore_0       : store_local(longType  , 0); break;
2767       case Bytecodes::_lstore_1       : store_local(longType  , 1); break;
2768       case Bytecodes::_lstore_2       : store_local(longType  , 2); break;
2769       case Bytecodes::_lstore_3       : store_local(longType  , 3); break;
2770       case Bytecodes::_fstore_0       : store_local(floatType , 0); break;
2771       case Bytecodes::_fstore_1       : store_local(floatType , 1); break;
2772       case Bytecodes::_fstore_2       : store_local(floatType , 2); break;
2773       case Bytecodes::_fstore_3       : store_local(floatType , 3); break;
2774       case Bytecodes::_dstore_0       : store_local(doubleType, 0); break;
2775       case Bytecodes::_dstore_1       : store_local(doubleType, 1); break;
2776       case Bytecodes::_dstore_2       : store_local(doubleType, 2); break;
2777       case Bytecodes::_dstore_3       : store_local(doubleType, 3); break;
2778       case Bytecodes::_astore_0       : store_local(objectType, 0); break;
2779       case Bytecodes::_astore_1       : store_local(objectType, 1); break;
2780       case Bytecodes::_astore_2       : store_local(objectType, 2); break;
2781       case Bytecodes::_astore_3       : store_local(objectType, 3); break;
2782       case Bytecodes::_iastore        : store_indexed(T_INT   ); break;
2783       case Bytecodes::_lastore        : store_indexed(T_LONG  ); break;
2784       case Bytecodes::_fastore        : store_indexed(T_FLOAT ); break;
2785       case Bytecodes::_dastore        : store_indexed(T_DOUBLE); break;
2786       case Bytecodes::_aastore        : store_indexed(T_OBJECT); break;
2787       case Bytecodes::_bastore        : store_indexed(T_BYTE  ); break;
2788       case Bytecodes::_castore        : store_indexed(T_CHAR  ); break;
2789       case Bytecodes::_sastore        : store_indexed(T_SHORT ); break;
2790       case Bytecodes::_pop            : // fall through
2791       case Bytecodes::_pop2           : // fall through
2792       case Bytecodes::_dup            : // fall through
2793       case Bytecodes::_dup_x1         : // fall through
2794       case Bytecodes::_dup_x2         : // fall through
2795       case Bytecodes::_dup2           : // fall through
2796       case Bytecodes::_dup2_x1        : // fall through
2797       case Bytecodes::_dup2_x2        : // fall through
2798       case Bytecodes::_swap           : stack_op(code); break;
2799       case Bytecodes::_iadd           : arithmetic_op(intType   , code); break;
2800       case Bytecodes::_ladd           : arithmetic_op(longType  , code); break;
2801       case Bytecodes::_fadd           : arithmetic_op(floatType , code); break;
2802       case Bytecodes::_dadd           : arithmetic_op(doubleType, code); break;
2803       case Bytecodes::_isub           : arithmetic_op(intType   , code); break;
2804       case Bytecodes::_lsub           : arithmetic_op(longType  , code); break;
2805       case Bytecodes::_fsub           : arithmetic_op(floatType , code); break;
2806       case Bytecodes::_dsub           : arithmetic_op(doubleType, code); break;
2807       case Bytecodes::_imul           : arithmetic_op(intType   , code); break;
2808       case Bytecodes::_lmul           : arithmetic_op(longType  , code); break;
2809       case Bytecodes::_fmul           : arithmetic_op(floatType , code); break;
2810       case Bytecodes::_dmul           : arithmetic_op(doubleType, code); break;
2811       case Bytecodes::_idiv           : arithmetic_op(intType   , code, copy_state_for_exception()); break;
2812       case Bytecodes::_ldiv           : arithmetic_op(longType  , code, copy_state_for_exception()); break;
2813       case Bytecodes::_fdiv           : arithmetic_op(floatType , code); break;
2814       case Bytecodes::_ddiv           : arithmetic_op(doubleType, code); break;
2815       case Bytecodes::_irem           : arithmetic_op(intType   , code, copy_state_for_exception()); break;
2816       case Bytecodes::_lrem           : arithmetic_op(longType  , code, copy_state_for_exception()); break;
2817       case Bytecodes::_frem           : arithmetic_op(floatType , code); break;
2818       case Bytecodes::_drem           : arithmetic_op(doubleType, code); break;
2819       case Bytecodes::_ineg           : negate_op(intType   ); break;
2820       case Bytecodes::_lneg           : negate_op(longType  ); break;
2821       case Bytecodes::_fneg           : negate_op(floatType ); break;
2822       case Bytecodes::_dneg           : negate_op(doubleType); break;
2823       case Bytecodes::_ishl           : shift_op(intType , code); break;
2824       case Bytecodes::_lshl           : shift_op(longType, code); break;
2825       case Bytecodes::_ishr           : shift_op(intType , code); break;
2826       case Bytecodes::_lshr           : shift_op(longType, code); break;
2827       case Bytecodes::_iushr          : shift_op(intType , code); break;
2828       case Bytecodes::_lushr          : shift_op(longType, code); break;
2829       case Bytecodes::_iand           : logic_op(intType , code); break;
2830       case Bytecodes::_land           : logic_op(longType, code); break;
2831       case Bytecodes::_ior            : logic_op(intType , code); break;
2832       case Bytecodes::_lor            : logic_op(longType, code); break;
2833       case Bytecodes::_ixor           : logic_op(intType , code); break;
2834       case Bytecodes::_lxor           : logic_op(longType, code); break;
2835       case Bytecodes::_iinc           : increment(); break;
2836       case Bytecodes::_i2l            : convert(code, T_INT   , T_LONG  ); break;
2837       case Bytecodes::_i2f            : convert(code, T_INT   , T_FLOAT ); break;
2838       case Bytecodes::_i2d            : convert(code, T_INT   , T_DOUBLE); break;
2839       case Bytecodes::_l2i            : convert(code, T_LONG  , T_INT   ); break;
2840       case Bytecodes::_l2f            : convert(code, T_LONG  , T_FLOAT ); break;
2841       case Bytecodes::_l2d            : convert(code, T_LONG  , T_DOUBLE); break;
2842       case Bytecodes::_f2i            : convert(code, T_FLOAT , T_INT   ); break;
2843       case Bytecodes::_f2l            : convert(code, T_FLOAT , T_LONG  ); break;
2844       case Bytecodes::_f2d            : convert(code, T_FLOAT , T_DOUBLE); break;
2845       case Bytecodes::_d2i            : convert(code, T_DOUBLE, T_INT   ); break;
2846       case Bytecodes::_d2l            : convert(code, T_DOUBLE, T_LONG  ); break;
2847       case Bytecodes::_d2f            : convert(code, T_DOUBLE, T_FLOAT ); break;
2848       case Bytecodes::_i2b            : convert(code, T_INT   , T_BYTE  ); break;
2849       case Bytecodes::_i2c            : convert(code, T_INT   , T_CHAR  ); break;
2850       case Bytecodes::_i2s            : convert(code, T_INT   , T_SHORT ); break;
2851       case Bytecodes::_lcmp           : compare_op(longType  , code); break;
2852       case Bytecodes::_fcmpl          : compare_op(floatType , code); break;
2853       case Bytecodes::_fcmpg          : compare_op(floatType , code); break;
2854       case Bytecodes::_dcmpl          : compare_op(doubleType, code); break;
2855       case Bytecodes::_dcmpg          : compare_op(doubleType, code); break;
2856       case Bytecodes::_ifeq           : if_zero(intType   , If::eql); break;
2857       case Bytecodes::_ifne           : if_zero(intType   , If::neq); break;
2858       case Bytecodes::_iflt           : if_zero(intType   , If::lss); break;
2859       case Bytecodes::_ifge           : if_zero(intType   , If::geq); break;
2860       case Bytecodes::_ifgt           : if_zero(intType   , If::gtr); break;
2861       case Bytecodes::_ifle           : if_zero(intType   , If::leq); break;
2862       case Bytecodes::_if_icmpeq      : if_same(intType   , If::eql); break;
2863       case Bytecodes::_if_icmpne      : if_same(intType   , If::neq); break;
2864       case Bytecodes::_if_icmplt      : if_same(intType   , If::lss); break;
2865       case Bytecodes::_if_icmpge      : if_same(intType   , If::geq); break;
2866       case Bytecodes::_if_icmpgt      : if_same(intType   , If::gtr); break;
2867       case Bytecodes::_if_icmple      : if_same(intType   , If::leq); break;
2868       case Bytecodes::_if_acmpeq      : if_same(objectType, If::eql); break;
2869       case Bytecodes::_if_acmpne      : if_same(objectType, If::neq); break;
2870       case Bytecodes::_goto           : _goto(s.cur_bci(), s.get_dest()); break;
2871       case Bytecodes::_jsr            : jsr(s.get_dest()); break;
2872       case Bytecodes::_ret            : ret(s.get_index()); break;
2873       case Bytecodes::_tableswitch    : table_switch(); break;
2874       case Bytecodes::_lookupswitch   : lookup_switch(); break;
2875       case Bytecodes::_ireturn        : method_return(ipop(), ignore_return); break;
2876       case Bytecodes::_lreturn        : method_return(lpop(), ignore_return); break;
2877       case Bytecodes::_freturn        : method_return(fpop(), ignore_return); break;
2878       case Bytecodes::_dreturn        : method_return(dpop(), ignore_return); break;
2879       case Bytecodes::_areturn        : method_return(apop(), ignore_return); break;
2880       case Bytecodes::_return         : method_return(NULL  , ignore_return); break;
2881       case Bytecodes::_getstatic      : // fall through
2882       case Bytecodes::_putstatic      : // fall through
2883       case Bytecodes::_getfield       : // fall through
2884       case Bytecodes::_putfield       : access_field(code); break;
2885       case Bytecodes::_invokevirtual  : // fall through
2886       case Bytecodes::_invokespecial  : // fall through
2887       case Bytecodes::_invokestatic   : // fall through
2888       case Bytecodes::_invokedynamic  : // fall through
2889       case Bytecodes::_invokeinterface: invoke(code); break;
2890       case Bytecodes::_new            : new_instance(s.get_index_u2()); break;
2891       case Bytecodes::_newarray       : new_type_array(); break;
2892       case Bytecodes::_anewarray      : new_object_array(); break;
2893       case Bytecodes::_arraylength    : { ValueStack* state_before = copy_state_for_exception(); ipush(append(new ArrayLength(apop(), state_before))); break; }
2894       case Bytecodes::_athrow         : throw_op(s.cur_bci()); break;
2895       case Bytecodes::_checkcast      : check_cast(s.get_index_u2()); break;
2896       case Bytecodes::_instanceof     : instance_of(s.get_index_u2()); break;
2897       case Bytecodes::_monitorenter   : monitorenter(apop(), s.cur_bci()); break;
2898       case Bytecodes::_monitorexit    : monitorexit (apop(), s.cur_bci()); break;
2899       case Bytecodes::_wide           : ShouldNotReachHere(); break;
2900       case Bytecodes::_multianewarray : new_multi_array(s.cur_bcp()[3]); break;
2901       case Bytecodes::_ifnull         : if_null(objectType, If::eql); break;
2902       case Bytecodes::_ifnonnull      : if_null(objectType, If::neq); break;
2903       case Bytecodes::_goto_w         : _goto(s.cur_bci(), s.get_far_dest()); break;
2904       case Bytecodes::_jsr_w          : jsr(s.get_far_dest()); break;
2905       case Bytecodes::_breakpoint     : BAILOUT_(&quot;concurrent setting of breakpoint&quot;, NULL);
2906       default                         : ShouldNotReachHere(); break;
2907     }
2908 
2909     if (log != NULL)
2910       log-&gt;clear_context(); // skip marker if nothing was printed
2911 
2912     // save current bci to setup Goto at the end
2913     prev_bci = s.cur_bci();
2914 
2915   }
2916   CHECK_BAILOUT_(NULL);
2917   // stop processing of this block (see try_inline_full)
2918   if (_skip_block) {
2919     _skip_block = false;
2920     assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
2921     return _last-&gt;as_BlockEnd();
2922   }
2923   // if there are any, check if last instruction is a BlockEnd instruction
2924   BlockEnd* end = last()-&gt;as_BlockEnd();
2925   if (end == NULL) {
2926     // all blocks must end with a BlockEnd instruction =&gt; add a Goto
2927     end = new Goto(block_at(s.cur_bci()), false);
2928     append(end);
2929   }
2930   assert(end == last()-&gt;as_BlockEnd(), &quot;inconsistency&quot;);
2931 
2932   assert(end-&gt;state() != NULL, &quot;state must already be present&quot;);
2933   assert(end-&gt;as_Return() == NULL || end-&gt;as_Throw() == NULL || end-&gt;state()-&gt;stack_size() == 0, &quot;stack not needed for return and throw&quot;);
2934 
2935   // connect to begin &amp; set state
2936   // NOTE that inlining may have changed the block we are parsing
2937   block()-&gt;set_end(end);
2938   // propagate state
2939   for (int i = end-&gt;number_of_sux() - 1; i &gt;= 0; i--) {
2940     BlockBegin* sux = end-&gt;sux_at(i);
2941     assert(sux-&gt;is_predecessor(block()), &quot;predecessor missing&quot;);
2942     // be careful, bailout if bytecodes are strange
2943     if (!sux-&gt;try_merge(end-&gt;state())) BAILOUT_(&quot;block join failed&quot;, NULL);
2944     scope_data()-&gt;add_to_work_list(end-&gt;sux_at(i));
2945   }
2946 
2947   scope_data()-&gt;set_stream(NULL);
2948 
2949   // done
2950   return end;
2951 }
2952 
2953 
2954 void GraphBuilder::iterate_all_blocks(bool start_in_current_block_for_inlining) {
2955   do {
2956     if (start_in_current_block_for_inlining &amp;&amp; !bailed_out()) {
2957       iterate_bytecodes_for_block(0);
2958       start_in_current_block_for_inlining = false;
2959     } else {
2960       BlockBegin* b;
2961       while ((b = scope_data()-&gt;remove_from_work_list()) != NULL) {
2962         if (!b-&gt;is_set(BlockBegin::was_visited_flag)) {
2963           if (b-&gt;is_set(BlockBegin::osr_entry_flag)) {
2964             // we&#39;re about to parse the osr entry block, so make sure
2965             // we setup the OSR edge leading into this block so that
2966             // Phis get setup correctly.
2967             setup_osr_entry_block();
2968             // this is no longer the osr entry block, so clear it.
2969             b-&gt;clear(BlockBegin::osr_entry_flag);
2970           }
2971           b-&gt;set(BlockBegin::was_visited_flag);
2972           connect_to_end(b);
2973         }
2974       }
2975     }
2976   } while (!bailed_out() &amp;&amp; !scope_data()-&gt;is_work_list_empty());
2977 }
2978 
2979 
2980 bool GraphBuilder::_can_trap      [Bytecodes::number_of_java_codes];
2981 
2982 void GraphBuilder::initialize() {
2983   // the following bytecodes are assumed to potentially
2984   // throw exceptions in compiled code - note that e.g.
2985   // monitorexit &amp; the return bytecodes do not throw
2986   // exceptions since monitor pairing proved that they
2987   // succeed (if monitor pairing succeeded)
2988   Bytecodes::Code can_trap_list[] =
2989     { Bytecodes::_ldc
2990     , Bytecodes::_ldc_w
2991     , Bytecodes::_ldc2_w
2992     , Bytecodes::_iaload
2993     , Bytecodes::_laload
2994     , Bytecodes::_faload
2995     , Bytecodes::_daload
2996     , Bytecodes::_aaload
2997     , Bytecodes::_baload
2998     , Bytecodes::_caload
2999     , Bytecodes::_saload
3000     , Bytecodes::_iastore
3001     , Bytecodes::_lastore
3002     , Bytecodes::_fastore
3003     , Bytecodes::_dastore
3004     , Bytecodes::_aastore
3005     , Bytecodes::_bastore
3006     , Bytecodes::_castore
3007     , Bytecodes::_sastore
3008     , Bytecodes::_idiv
3009     , Bytecodes::_ldiv
3010     , Bytecodes::_irem
3011     , Bytecodes::_lrem
3012     , Bytecodes::_getstatic
3013     , Bytecodes::_putstatic
3014     , Bytecodes::_getfield
3015     , Bytecodes::_putfield
3016     , Bytecodes::_invokevirtual
3017     , Bytecodes::_invokespecial
3018     , Bytecodes::_invokestatic
3019     , Bytecodes::_invokedynamic
3020     , Bytecodes::_invokeinterface
3021     , Bytecodes::_new
3022     , Bytecodes::_newarray
3023     , Bytecodes::_anewarray
3024     , Bytecodes::_arraylength
3025     , Bytecodes::_athrow
3026     , Bytecodes::_checkcast
3027     , Bytecodes::_instanceof
3028     , Bytecodes::_monitorenter
3029     , Bytecodes::_multianewarray
3030     };
3031 
3032   // inititialize trap tables
3033   for (int i = 0; i &lt; Bytecodes::number_of_java_codes; i++) {
3034     _can_trap[i] = false;
3035   }
3036   // set standard trap info
3037   for (uint j = 0; j &lt; ARRAY_SIZE(can_trap_list); j++) {
3038     _can_trap[can_trap_list[j]] = true;
3039   }
3040 }
3041 
3042 
3043 BlockBegin* GraphBuilder::header_block(BlockBegin* entry, BlockBegin::Flag f, ValueStack* state) {
3044   assert(entry-&gt;is_set(f), &quot;entry/flag mismatch&quot;);
3045   // create header block
3046   BlockBegin* h = new BlockBegin(entry-&gt;bci());
3047   h-&gt;set_depth_first_number(0);
3048 
3049   Value l = h;
3050   BlockEnd* g = new Goto(entry, false);
3051   l-&gt;set_next(g, entry-&gt;bci());
3052   h-&gt;set_end(g);
3053   h-&gt;set(f);
3054   // setup header block end state
3055   ValueStack* s = state-&gt;copy(ValueStack::StateAfter, entry-&gt;bci()); // can use copy since stack is empty (=&gt; no phis)
3056   assert(s-&gt;stack_is_empty(), &quot;must have empty stack at entry point&quot;);
3057   g-&gt;set_state(s);
3058   return h;
3059 }
3060 
3061 
3062 
3063 BlockBegin* GraphBuilder::setup_start_block(int osr_bci, BlockBegin* std_entry, BlockBegin* osr_entry, ValueStack* state) {
3064   BlockBegin* start = new BlockBegin(0);
3065 
3066   // This code eliminates the empty start block at the beginning of
3067   // each method.  Previously, each method started with the
3068   // start-block created below, and this block was followed by the
3069   // header block that was always empty.  This header block is only
3070   // necesary if std_entry is also a backward branch target because
3071   // then phi functions may be necessary in the header block.  It&#39;s
3072   // also necessary when profiling so that there&#39;s a single block that
3073   // can increment the interpreter_invocation_count.
3074   BlockBegin* new_header_block;
3075   if (std_entry-&gt;number_of_preds() &gt; 0 || count_invocations() || count_backedges()) {
3076     new_header_block = header_block(std_entry, BlockBegin::std_entry_flag, state);
3077   } else {
3078     new_header_block = std_entry;
3079   }
3080 
3081   // setup start block (root for the IR graph)
3082   Base* base =
3083     new Base(
3084       new_header_block,
3085       osr_entry
3086     );
3087   start-&gt;set_next(base, 0);
3088   start-&gt;set_end(base);
3089   // create &amp; setup state for start block
3090   start-&gt;set_state(state-&gt;copy(ValueStack::StateAfter, std_entry-&gt;bci()));
3091   base-&gt;set_state(state-&gt;copy(ValueStack::StateAfter, std_entry-&gt;bci()));
3092 
3093   if (base-&gt;std_entry()-&gt;state() == NULL) {
3094     // setup states for header blocks
3095     base-&gt;std_entry()-&gt;merge(state);
3096   }
3097 
3098   assert(base-&gt;std_entry()-&gt;state() != NULL, &quot;&quot;);
3099   return start;
3100 }
3101 
3102 
3103 void GraphBuilder::setup_osr_entry_block() {
3104   assert(compilation()-&gt;is_osr_compile(), &quot;only for osrs&quot;);
3105 
3106   int osr_bci = compilation()-&gt;osr_bci();
3107   ciBytecodeStream s(method());
3108   s.reset_to_bci(osr_bci);
3109   s.next();
3110   scope_data()-&gt;set_stream(&amp;s);
3111 
3112   // create a new block to be the osr setup code
3113   _osr_entry = new BlockBegin(osr_bci);
3114   _osr_entry-&gt;set(BlockBegin::osr_entry_flag);
3115   _osr_entry-&gt;set_depth_first_number(0);
3116   BlockBegin* target = bci2block()-&gt;at(osr_bci);
3117   assert(target != NULL &amp;&amp; target-&gt;is_set(BlockBegin::osr_entry_flag), &quot;must be there&quot;);
3118   // the osr entry has no values for locals
3119   ValueStack* state = target-&gt;state()-&gt;copy();
3120   _osr_entry-&gt;set_state(state);
3121 
3122   kill_all();
3123   _block = _osr_entry;
3124   _state = _osr_entry-&gt;state()-&gt;copy();
3125   assert(_state-&gt;bci() == osr_bci, &quot;mismatch&quot;);
3126   _last  = _osr_entry;
3127   Value e = append(new OsrEntry());
3128   e-&gt;set_needs_null_check(false);
3129 
3130   // OSR buffer is
3131   //
3132   // locals[nlocals-1..0]
3133   // monitors[number_of_locks-1..0]
3134   //
3135   // locals is a direct copy of the interpreter frame so in the osr buffer
3136   // so first slot in the local array is the last local from the interpreter
3137   // and last slot is local[0] (receiver) from the interpreter
3138   //
3139   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
3140   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
3141   // in the interpreter frame (the method lock if a sync method)
3142 
3143   // Initialize monitors in the compiled activation.
3144 
3145   int index;
3146   Value local;
3147 
3148   // find all the locals that the interpreter thinks contain live oops
3149   const ResourceBitMap live_oops = method()-&gt;live_local_oops_at_bci(osr_bci);
3150 
3151   // compute the offset into the locals so that we can treat the buffer
3152   // as if the locals were still in the interpreter frame
3153   int locals_offset = BytesPerWord * (method()-&gt;max_locals() - 1);
3154   for_each_local_value(state, index, local) {
3155     int offset = locals_offset - (index + local-&gt;type()-&gt;size() - 1) * BytesPerWord;
3156     Value get;
3157     if (local-&gt;type()-&gt;is_object_kind() &amp;&amp; !live_oops.at(index)) {
3158       // The interpreter thinks this local is dead but the compiler
3159       // doesn&#39;t so pretend that the interpreter passed in null.
3160       get = append(new Constant(objectNull));
3161     } else {
3162       get = append(new UnsafeGetRaw(as_BasicType(local-&gt;type()), e,
3163                                     append(new Constant(new IntConstant(offset))),
3164                                     0,
3165                                     true /*unaligned*/, true /*wide*/));
3166     }
3167     _state-&gt;store_local(index, get);
3168   }
3169 
3170   // the storage for the OSR buffer is freed manually in the LIRGenerator.
3171 
3172   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3173   state-&gt;clear_locals();
3174   Goto* g = new Goto(target, false);
3175   append(g);
3176   _osr_entry-&gt;set_end(g);
3177   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3178 
3179   scope_data()-&gt;set_stream(NULL);
3180 }
3181 
3182 
3183 ValueStack* GraphBuilder::state_at_entry() {
3184   ValueStack* state = new ValueStack(scope(), NULL);
3185 
3186   // Set up locals for receiver
3187   int idx = 0;
3188   if (!method()-&gt;is_static()) {
3189     // we should always see the receiver
3190     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx, true));
3191     idx = 1;
3192   }
3193 
3194   // Set up locals for incoming arguments
3195   ciSignature* sig = method()-&gt;signature();
3196   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3197     ciType* type = sig-&gt;type_at(i);
3198     BasicType basic_type = type-&gt;basic_type();
3199     // don&#39;t allow T_ARRAY to propagate into locals types
3200     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3201     ValueType* vt = as_ValueType(basic_type);
3202     state-&gt;store_local(idx, new Local(type, vt, idx, false));
3203     idx += type-&gt;size();
3204   }
3205 
3206   // lock synchronized method
3207   if (method()-&gt;is_synchronized()) {
3208     state-&gt;lock(NULL);
3209   }
3210 
3211   return state;
3212 }
3213 
3214 
3215 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3216   : _scope_data(NULL)
3217   , _compilation(compilation)
3218   , _memory(new MemoryBuffer())
3219   , _inline_bailout_msg(NULL)
3220   , _instruction_count(0)
3221   , _osr_entry(NULL)
3222 {
3223   int osr_bci = compilation-&gt;osr_bci();
3224 
3225   // determine entry points and bci2block mapping
3226   BlockListBuilder blm(compilation, scope, osr_bci);
3227   CHECK_BAILOUT();
3228 
3229   BlockList* bci2block = blm.bci2block();
3230   BlockBegin* start_block = bci2block-&gt;at(0);
3231 
3232   push_root_scope(scope, bci2block, start_block);
3233 
3234   // setup state for std entry
3235   _initial_state = state_at_entry();
3236   start_block-&gt;merge(_initial_state);
3237 
3238   // complete graph
3239   _vmap        = new ValueMap();
3240   switch (scope-&gt;method()-&gt;intrinsic_id()) {
3241   case vmIntrinsics::_dabs          : // fall through
3242   case vmIntrinsics::_dsqrt         : // fall through
3243   case vmIntrinsics::_dsin          : // fall through
3244   case vmIntrinsics::_dcos          : // fall through
3245   case vmIntrinsics::_dtan          : // fall through
3246   case vmIntrinsics::_dlog          : // fall through
3247   case vmIntrinsics::_dlog10        : // fall through
3248   case vmIntrinsics::_dexp          : // fall through
3249   case vmIntrinsics::_dpow          : // fall through
3250     {
3251       // Compiles where the root method is an intrinsic need a special
3252       // compilation environment because the bytecodes for the method
3253       // shouldn&#39;t be parsed during the compilation, only the special
3254       // Intrinsic node should be emitted.  If this isn&#39;t done the the
3255       // code for the inlined version will be different than the root
3256       // compiled version which could lead to monotonicity problems on
3257       // intel.
3258       if (CheckIntrinsics &amp;&amp; !scope-&gt;method()-&gt;intrinsic_candidate()) {
3259         BAILOUT(&quot;failed to inline intrinsic, method not annotated&quot;);
3260       }
3261 
3262       // Set up a stream so that appending instructions works properly.
3263       ciBytecodeStream s(scope-&gt;method());
3264       s.reset_to_bci(0);
3265       scope_data()-&gt;set_stream(&amp;s);
3266       s.next();
3267 
3268       // setup the initial block state
3269       _block = start_block;
3270       _state = start_block-&gt;state()-&gt;copy_for_parsing();
3271       _last  = start_block;
3272       load_local(doubleType, 0);
3273       if (scope-&gt;method()-&gt;intrinsic_id() == vmIntrinsics::_dpow) {
3274         load_local(doubleType, 2);
3275       }
3276 
3277       // Emit the intrinsic node.
3278       bool result = try_inline_intrinsics(scope-&gt;method());
3279       if (!result) BAILOUT(&quot;failed to inline intrinsic&quot;);
3280       method_return(dpop());
3281 
3282       // connect the begin and end blocks and we&#39;re all done.
3283       BlockEnd* end = last()-&gt;as_BlockEnd();
3284       block()-&gt;set_end(end);
3285       break;
3286     }
3287 
3288   case vmIntrinsics::_Reference_get:
3289     {
3290       {
3291         // With java.lang.ref.reference.get() we must go through the
3292         // intrinsic - when G1 is enabled - even when get() is the root
3293         // method of the compile so that, if necessary, the value in
3294         // the referent field of the reference object gets recorded by
3295         // the pre-barrier code.
3296         // Specifically, if G1 is enabled, the value in the referent
3297         // field is recorded by the G1 SATB pre barrier. This will
3298         // result in the referent being marked live and the reference
3299         // object removed from the list of discovered references during
3300         // reference processing.
3301         if (CheckIntrinsics &amp;&amp; !scope-&gt;method()-&gt;intrinsic_candidate()) {
3302           BAILOUT(&quot;failed to inline intrinsic, method not annotated&quot;);
3303         }
3304 
3305         // Also we need intrinsic to prevent commoning reads from this field
3306         // across safepoint since GC can change its value.
3307 
3308         // Set up a stream so that appending instructions works properly.
3309         ciBytecodeStream s(scope-&gt;method());
3310         s.reset_to_bci(0);
3311         scope_data()-&gt;set_stream(&amp;s);
3312         s.next();
3313 
3314         // setup the initial block state
3315         _block = start_block;
3316         _state = start_block-&gt;state()-&gt;copy_for_parsing();
3317         _last  = start_block;
3318         load_local(objectType, 0);
3319 
3320         // Emit the intrinsic node.
3321         bool result = try_inline_intrinsics(scope-&gt;method());
3322         if (!result) BAILOUT(&quot;failed to inline intrinsic&quot;);
3323         method_return(apop());
3324 
3325         // connect the begin and end blocks and we&#39;re all done.
3326         BlockEnd* end = last()-&gt;as_BlockEnd();
3327         block()-&gt;set_end(end);
3328         break;
3329       }
3330       // Otherwise, fall thru
3331     }
3332 
3333   default:
3334     scope_data()-&gt;add_to_work_list(start_block);
3335     iterate_all_blocks();
3336     break;
3337   }
3338   CHECK_BAILOUT();
3339 
3340   _start = setup_start_block(osr_bci, start_block, _osr_entry, _initial_state);
3341 
3342   eliminate_redundant_phis(_start);
3343 
3344   NOT_PRODUCT(if (PrintValueNumbering &amp;&amp; Verbose) print_stats());
3345   // for osr compile, bailout if some requirements are not fulfilled
3346   if (osr_bci != -1) {
3347     BlockBegin* osr_block = blm.bci2block()-&gt;at(osr_bci);
3348     if (!osr_block-&gt;is_set(BlockBegin::was_visited_flag)) {
3349       BAILOUT(&quot;osr entry must have been visited for osr compile&quot;);
3350     }
3351 
3352     // check if osr entry point has empty stack - we cannot handle non-empty stacks at osr entry points
3353     if (!osr_block-&gt;state()-&gt;stack_is_empty()) {
3354       BAILOUT(&quot;stack not empty at OSR entry point&quot;);
3355     }
3356   }
3357 #ifndef PRODUCT
3358   if (PrintCompilation &amp;&amp; Verbose) tty-&gt;print_cr(&quot;Created %d Instructions&quot;, _instruction_count);
3359 #endif
3360 }
3361 
3362 
3363 ValueStack* GraphBuilder::copy_state_before() {
3364   return copy_state_before_with_bci(bci());
3365 }
3366 
3367 ValueStack* GraphBuilder::copy_state_exhandling() {
3368   return copy_state_exhandling_with_bci(bci());
3369 }
3370 
3371 ValueStack* GraphBuilder::copy_state_for_exception() {
3372   return copy_state_for_exception_with_bci(bci());
3373 }
3374 
3375 ValueStack* GraphBuilder::copy_state_before_with_bci(int bci) {
3376   return state()-&gt;copy(ValueStack::StateBefore, bci);
3377 }
3378 
3379 ValueStack* GraphBuilder::copy_state_exhandling_with_bci(int bci) {
3380   if (!has_handler()) return NULL;
3381   return state()-&gt;copy(ValueStack::StateBefore, bci);
3382 }
3383 
3384 ValueStack* GraphBuilder::copy_state_for_exception_with_bci(int bci) {
3385   ValueStack* s = copy_state_exhandling_with_bci(bci);
3386   if (s == NULL) {
3387     if (_compilation-&gt;env()-&gt;should_retain_local_variables()) {
3388       s = state()-&gt;copy(ValueStack::ExceptionState, bci);
3389     } else {
3390       s = state()-&gt;copy(ValueStack::EmptyExceptionState, bci);
3391     }
3392   }
3393   return s;
3394 }
3395 
3396 int GraphBuilder::recursive_inline_level(ciMethod* cur_callee) const {
3397   int recur_level = 0;
3398   for (IRScope* s = scope(); s != NULL; s = s-&gt;caller()) {
3399     if (s-&gt;method() == cur_callee) {
3400       ++recur_level;
3401     }
3402   }
3403   return recur_level;
3404 }
3405 
3406 
3407 bool GraphBuilder::try_inline(ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc, Value receiver) {
3408   const char* msg = NULL;
3409 
3410   // clear out any existing inline bailout condition
3411   clear_inline_bailout();
3412 
3413   // exclude methods we don&#39;t want to inline
3414   msg = should_not_inline(callee);
3415   if (msg != NULL) {
3416     print_inlining(callee, msg, /*success*/ false);
3417     return false;
3418   }
3419 
3420   // method handle invokes
3421   if (callee-&gt;is_method_handle_intrinsic()) {
3422     if (try_method_handle_inline(callee, ignore_return)) {
3423       if (callee-&gt;has_reserved_stack_access()) {
3424         compilation()-&gt;set_has_reserved_stack_access(true);
3425       }
3426       return true;
3427     }
3428     return false;
3429   }
3430 
3431   // handle intrinsics
3432   if (callee-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
3433       (CheckIntrinsics ? callee-&gt;intrinsic_candidate() : true)) {
3434     if (try_inline_intrinsics(callee, ignore_return)) {
3435       print_inlining(callee, &quot;intrinsic&quot;);
3436       if (callee-&gt;has_reserved_stack_access()) {
3437         compilation()-&gt;set_has_reserved_stack_access(true);
3438       }
3439       return true;
3440     }
3441     // try normal inlining
3442   }
3443 
3444   // certain methods cannot be parsed at all
3445   msg = check_can_parse(callee);
3446   if (msg != NULL) {
3447     print_inlining(callee, msg, /*success*/ false);
3448     return false;
3449   }
3450 
3451   // If bytecode not set use the current one.
3452   if (bc == Bytecodes::_illegal) {
3453     bc = code();
3454   }
3455   if (try_inline_full(callee, holder_known, ignore_return, bc, receiver)) {
3456     if (callee-&gt;has_reserved_stack_access()) {
3457       compilation()-&gt;set_has_reserved_stack_access(true);
3458     }
3459     return true;
3460   }
3461 
3462   // Entire compilation could fail during try_inline_full call.
3463   // In that case printing inlining decision info is useless.
3464   if (!bailed_out())
3465     print_inlining(callee, _inline_bailout_msg, /*success*/ false);
3466 
3467   return false;
3468 }
3469 
3470 
3471 const char* GraphBuilder::check_can_parse(ciMethod* callee) const {
3472   // Certain methods cannot be parsed at all:
3473   if ( callee-&gt;is_native())            return &quot;native method&quot;;
3474   if ( callee-&gt;is_abstract())          return &quot;abstract method&quot;;
3475   if (!callee-&gt;can_be_compiled())      return &quot;not compilable (disabled)&quot;;
3476   if (!callee-&gt;can_be_parsed())        return &quot;cannot be parsed&quot;;
3477   return NULL;
3478 }
3479 
3480 // negative filter: should callee NOT be inlined?  returns NULL, ok to inline, or rejection msg
3481 const char* GraphBuilder::should_not_inline(ciMethod* callee) const {
3482   if ( compilation()-&gt;directive()-&gt;should_not_inline(callee)) return &quot;disallowed by CompileCommand&quot;;
3483   if ( callee-&gt;dont_inline())          return &quot;don&#39;t inline by annotation&quot;;
3484   return NULL;
3485 }
3486 
3487 void GraphBuilder::build_graph_for_intrinsic(ciMethod* callee, bool ignore_return) {
3488   vmIntrinsics::ID id = callee-&gt;intrinsic_id();
3489   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
3490 
3491   // Some intrinsics need special IR nodes.
3492   switch(id) {
3493   case vmIntrinsics::_getReference       : append_unsafe_get_obj(callee, T_OBJECT,  false); return;
3494   case vmIntrinsics::_getBoolean         : append_unsafe_get_obj(callee, T_BOOLEAN, false); return;
3495   case vmIntrinsics::_getByte            : append_unsafe_get_obj(callee, T_BYTE,    false); return;
3496   case vmIntrinsics::_getShort           : append_unsafe_get_obj(callee, T_SHORT,   false); return;
3497   case vmIntrinsics::_getChar            : append_unsafe_get_obj(callee, T_CHAR,    false); return;
3498   case vmIntrinsics::_getInt             : append_unsafe_get_obj(callee, T_INT,     false); return;
3499   case vmIntrinsics::_getLong            : append_unsafe_get_obj(callee, T_LONG,    false); return;
3500   case vmIntrinsics::_getFloat           : append_unsafe_get_obj(callee, T_FLOAT,   false); return;
3501   case vmIntrinsics::_getDouble          : append_unsafe_get_obj(callee, T_DOUBLE,  false); return;
3502   case vmIntrinsics::_putReference       : append_unsafe_put_obj(callee, T_OBJECT,  false); return;
3503   case vmIntrinsics::_putBoolean         : append_unsafe_put_obj(callee, T_BOOLEAN, false); return;
3504   case vmIntrinsics::_putByte            : append_unsafe_put_obj(callee, T_BYTE,    false); return;
3505   case vmIntrinsics::_putShort           : append_unsafe_put_obj(callee, T_SHORT,   false); return;
3506   case vmIntrinsics::_putChar            : append_unsafe_put_obj(callee, T_CHAR,    false); return;
3507   case vmIntrinsics::_putInt             : append_unsafe_put_obj(callee, T_INT,     false); return;
3508   case vmIntrinsics::_putLong            : append_unsafe_put_obj(callee, T_LONG,    false); return;
3509   case vmIntrinsics::_putFloat           : append_unsafe_put_obj(callee, T_FLOAT,   false); return;
3510   case vmIntrinsics::_putDouble          : append_unsafe_put_obj(callee, T_DOUBLE,  false); return;
3511   case vmIntrinsics::_getShortUnaligned  : append_unsafe_get_obj(callee, T_SHORT,   false); return;
3512   case vmIntrinsics::_getCharUnaligned   : append_unsafe_get_obj(callee, T_CHAR,    false); return;
3513   case vmIntrinsics::_getIntUnaligned    : append_unsafe_get_obj(callee, T_INT,     false); return;
3514   case vmIntrinsics::_getLongUnaligned   : append_unsafe_get_obj(callee, T_LONG,    false); return;
3515   case vmIntrinsics::_putShortUnaligned  : append_unsafe_put_obj(callee, T_SHORT,   false); return;
3516   case vmIntrinsics::_putCharUnaligned   : append_unsafe_put_obj(callee, T_CHAR,    false); return;
3517   case vmIntrinsics::_putIntUnaligned    : append_unsafe_put_obj(callee, T_INT,     false); return;
3518   case vmIntrinsics::_putLongUnaligned   : append_unsafe_put_obj(callee, T_LONG,    false); return;
3519   case vmIntrinsics::_getReferenceVolatile  : append_unsafe_get_obj(callee, T_OBJECT,  true); return;
3520   case vmIntrinsics::_getBooleanVolatile : append_unsafe_get_obj(callee, T_BOOLEAN, true); return;
3521   case vmIntrinsics::_getByteVolatile    : append_unsafe_get_obj(callee, T_BYTE,    true); return;
3522   case vmIntrinsics::_getShortVolatile   : append_unsafe_get_obj(callee, T_SHORT,   true); return;
3523   case vmIntrinsics::_getCharVolatile    : append_unsafe_get_obj(callee, T_CHAR,    true); return;
3524   case vmIntrinsics::_getIntVolatile     : append_unsafe_get_obj(callee, T_INT,     true); return;
3525   case vmIntrinsics::_getLongVolatile    : append_unsafe_get_obj(callee, T_LONG,    true); return;
3526   case vmIntrinsics::_getFloatVolatile   : append_unsafe_get_obj(callee, T_FLOAT,   true); return;
3527   case vmIntrinsics::_getDoubleVolatile  : append_unsafe_get_obj(callee, T_DOUBLE,  true); return;
3528   case vmIntrinsics::_putReferenceVolatile : append_unsafe_put_obj(callee, T_OBJECT,  true); return;
3529   case vmIntrinsics::_putBooleanVolatile : append_unsafe_put_obj(callee, T_BOOLEAN, true); return;
3530   case vmIntrinsics::_putByteVolatile    : append_unsafe_put_obj(callee, T_BYTE,    true); return;
3531   case vmIntrinsics::_putShortVolatile   : append_unsafe_put_obj(callee, T_SHORT,   true); return;
3532   case vmIntrinsics::_putCharVolatile    : append_unsafe_put_obj(callee, T_CHAR,    true); return;
3533   case vmIntrinsics::_putIntVolatile     : append_unsafe_put_obj(callee, T_INT,     true); return;
3534   case vmIntrinsics::_putLongVolatile    : append_unsafe_put_obj(callee, T_LONG,    true); return;
3535   case vmIntrinsics::_putFloatVolatile   : append_unsafe_put_obj(callee, T_FLOAT,   true); return;
3536   case vmIntrinsics::_putDoubleVolatile  : append_unsafe_put_obj(callee, T_DOUBLE,  true); return;
3537   case vmIntrinsics::_compareAndSetLong:
3538   case vmIntrinsics::_compareAndSetInt:
3539   case vmIntrinsics::_compareAndSetReference : append_unsafe_CAS(callee); return;
3540   case vmIntrinsics::_getAndAddInt:
3541   case vmIntrinsics::_getAndAddLong      : append_unsafe_get_and_set_obj(callee, true); return;
3542   case vmIntrinsics::_getAndSetInt       :
3543   case vmIntrinsics::_getAndSetLong      :
3544   case vmIntrinsics::_getAndSetReference : append_unsafe_get_and_set_obj(callee, false); return;
3545   case vmIntrinsics::_getCharStringU     : append_char_access(callee, false); return;
3546   case vmIntrinsics::_putCharStringU     : append_char_access(callee, true); return;
3547   default:
3548     break;
3549   }
3550 
3551   // create intrinsic node
3552   const bool has_receiver = !callee-&gt;is_static();
3553   ValueType* result_type = as_ValueType(callee-&gt;return_type());
3554   ValueStack* state_before = copy_state_for_exception();
3555 
3556   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
3557 
3558   if (is_profiling()) {
3559     // Don&#39;t profile in the special case where the root method
3560     // is the intrinsic
3561     if (callee != method()) {
3562       // Note that we&#39;d collect profile data in this method if we wanted it.
3563       compilation()-&gt;set_would_profile(true);
3564       if (profile_calls()) {
3565         Value recv = NULL;
3566         if (has_receiver) {
3567           recv = args-&gt;at(0);
3568           null_check(recv);
3569         }
3570         profile_call(callee, recv, NULL, collect_args_for_profiling(args, callee, true), true);
3571       }
3572     }
3573   }
3574 
3575   Intrinsic* result = new Intrinsic(result_type, callee-&gt;intrinsic_id(),
3576                                     args, has_receiver, state_before,
3577                                     vmIntrinsics::preserves_state(id),
3578                                     vmIntrinsics::can_trap(id));
3579   // append instruction &amp; push result
3580   Value value = append_split(result);
3581   if (result_type != voidType &amp;&amp; !ignore_return) {
3582     push(result_type, value);
3583   }
3584 
3585   if (callee != method() &amp;&amp; profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
3586     profile_return_type(result, callee);
3587   }
3588 }
3589 
3590 bool GraphBuilder::try_inline_intrinsics(ciMethod* callee, bool ignore_return) {
3591   // For calling is_intrinsic_available we need to transition to
3592   // the &#39;_thread_in_vm&#39; state because is_intrinsic_available()
3593   // accesses critical VM-internal data.
3594   bool is_available = false;
3595   {
3596     VM_ENTRY_MARK;
3597     methodHandle mh(THREAD, callee-&gt;get_Method());
3598     is_available = _compilation-&gt;compiler()-&gt;is_intrinsic_available(mh, _compilation-&gt;directive());
3599   }
3600 
3601   if (!is_available) {
3602     if (!InlineNatives) {
3603       // Return false and also set message that the inlining of
3604       // intrinsics has been disabled in general.
3605       INLINE_BAILOUT(&quot;intrinsic method inlining disabled&quot;);
3606     } else {
3607       return false;
3608     }
3609   }
3610   build_graph_for_intrinsic(callee, ignore_return);
3611   return true;
3612 }
3613 
3614 
3615 bool GraphBuilder::try_inline_jsr(int jsr_dest_bci) {
3616   // Introduce a new callee continuation point - all Ret instructions
3617   // will be replaced with Gotos to this point.
3618   BlockBegin* cont = block_at(next_bci());
3619   assert(cont != NULL, &quot;continuation must exist (BlockListBuilder starts a new block after a jsr&quot;);
3620 
3621   // Note: can not assign state to continuation yet, as we have to
3622   // pick up the state from the Ret instructions.
3623 
3624   // Push callee scope
3625   push_scope_for_jsr(cont, jsr_dest_bci);
3626 
3627   // Temporarily set up bytecode stream so we can append instructions
3628   // (only using the bci of this stream)
3629   scope_data()-&gt;set_stream(scope_data()-&gt;parent()-&gt;stream());
3630 
3631   BlockBegin* jsr_start_block = block_at(jsr_dest_bci);
3632   assert(jsr_start_block != NULL, &quot;jsr start block must exist&quot;);
3633   assert(!jsr_start_block-&gt;is_set(BlockBegin::was_visited_flag), &quot;should not have visited jsr yet&quot;);
3634   Goto* goto_sub = new Goto(jsr_start_block, false);
3635   // Must copy state to avoid wrong sharing when parsing bytecodes
3636   assert(jsr_start_block-&gt;state() == NULL, &quot;should have fresh jsr starting block&quot;);
3637   jsr_start_block-&gt;set_state(copy_state_before_with_bci(jsr_dest_bci));
3638   append(goto_sub);
3639   _block-&gt;set_end(goto_sub);
3640   _last = _block = jsr_start_block;
3641 
3642   // Clear out bytecode stream
3643   scope_data()-&gt;set_stream(NULL);
3644 
3645   scope_data()-&gt;add_to_work_list(jsr_start_block);
3646 
3647   // Ready to resume parsing in subroutine
3648   iterate_all_blocks();
3649 
3650   // If we bailed out during parsing, return immediately (this is bad news)
3651   CHECK_BAILOUT_(false);
3652 
3653   // Detect whether the continuation can actually be reached. If not,
3654   // it has not had state set by the join() operations in
3655   // iterate_bytecodes_for_block()/ret() and we should not touch the
3656   // iteration state. The calling activation of
3657   // iterate_bytecodes_for_block will then complete normally.
3658   if (cont-&gt;state() != NULL) {
3659     if (!cont-&gt;is_set(BlockBegin::was_visited_flag)) {
3660       // add continuation to work list instead of parsing it immediately
3661       scope_data()-&gt;parent()-&gt;add_to_work_list(cont);
3662     }
3663   }
3664 
3665   assert(jsr_continuation() == cont, &quot;continuation must not have changed&quot;);
3666   assert(!jsr_continuation()-&gt;is_set(BlockBegin::was_visited_flag) ||
3667          jsr_continuation()-&gt;is_set(BlockBegin::parser_loop_header_flag),
3668          &quot;continuation can only be visited in case of backward branches&quot;);
3669   assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;block must have end&quot;);
3670 
3671   // continuation is in work list, so end iteration of current block
3672   _skip_block = true;
3673   pop_scope_for_jsr();
3674 
3675   return true;
3676 }
3677 
3678 
3679 // Inline the entry of a synchronized method as a monitor enter and
3680 // register the exception handler which releases the monitor if an
3681 // exception is thrown within the callee. Note that the monitor enter
3682 // cannot throw an exception itself, because the receiver is
3683 // guaranteed to be non-null by the explicit null check at the
3684 // beginning of inlining.
3685 void GraphBuilder::inline_sync_entry(Value lock, BlockBegin* sync_handler) {
3686   assert(lock != NULL &amp;&amp; sync_handler != NULL, &quot;lock or handler missing&quot;);
3687 
3688   monitorenter(lock, SynchronizationEntryBCI);
3689   assert(_last-&gt;as_MonitorEnter() != NULL, &quot;monitor enter expected&quot;);
3690   _last-&gt;set_needs_null_check(false);
3691 
3692   sync_handler-&gt;set(BlockBegin::exception_entry_flag);
3693   sync_handler-&gt;set(BlockBegin::is_on_work_list_flag);
3694 
3695   ciExceptionHandler* desc = new ciExceptionHandler(method()-&gt;holder(), 0, method()-&gt;code_size(), -1, 0);
3696   XHandler* h = new XHandler(desc);
3697   h-&gt;set_entry_block(sync_handler);
3698   scope_data()-&gt;xhandlers()-&gt;append(h);
3699   scope_data()-&gt;set_has_handler();
3700 }
3701 
3702 
3703 // If an exception is thrown and not handled within an inlined
3704 // synchronized method, the monitor must be released before the
3705 // exception is rethrown in the outer scope. Generate the appropriate
3706 // instructions here.
3707 void GraphBuilder::fill_sync_handler(Value lock, BlockBegin* sync_handler, bool default_handler) {
3708   BlockBegin* orig_block = _block;
3709   ValueStack* orig_state = _state;
3710   Instruction* orig_last = _last;
3711   _last = _block = sync_handler;
3712   _state = sync_handler-&gt;state()-&gt;copy();
3713 
3714   assert(sync_handler != NULL, &quot;handler missing&quot;);
3715   assert(!sync_handler-&gt;is_set(BlockBegin::was_visited_flag), &quot;is visited here&quot;);
3716 
3717   assert(lock != NULL || default_handler, &quot;lock or handler missing&quot;);
3718 
3719   XHandler* h = scope_data()-&gt;xhandlers()-&gt;remove_last();
3720   assert(h-&gt;entry_block() == sync_handler, &quot;corrupt list of handlers&quot;);
3721 
3722   block()-&gt;set(BlockBegin::was_visited_flag);
3723   Value exception = append_with_bci(new ExceptionObject(), SynchronizationEntryBCI);
3724   assert(exception-&gt;is_pinned(), &quot;must be&quot;);
3725 
3726   int bci = SynchronizationEntryBCI;
3727   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
3728     // Report exit from inline methods.  We don&#39;t have a stream here
3729     // so pass an explicit bci of SynchronizationEntryBCI.
3730     Values* args = new Values(1);
3731     args-&gt;push(append_with_bci(new Constant(new MethodConstant(method())), bci));
3732     append_with_bci(new RuntimeCall(voidType, &quot;dtrace_method_exit&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), args), bci);
3733   }
3734 
3735   if (lock) {
3736     assert(state()-&gt;locks_size() &gt; 0 &amp;&amp; state()-&gt;lock_at(state()-&gt;locks_size() - 1) == lock, &quot;lock is missing&quot;);
3737     if (!lock-&gt;is_linked()) {
3738       lock = append_with_bci(lock, bci);
3739     }
3740 
3741     // exit the monitor in the context of the synchronized method
3742     monitorexit(lock, bci);
3743 
3744     // exit the context of the synchronized method
3745     if (!default_handler) {
3746       pop_scope();
3747       bci = _state-&gt;caller_state()-&gt;bci();
3748       _state = _state-&gt;caller_state()-&gt;copy_for_parsing();
3749     }
3750   }
3751 
3752   // perform the throw as if at the the call site
3753   apush(exception);
3754   throw_op(bci);
3755 
3756   BlockEnd* end = last()-&gt;as_BlockEnd();
3757   block()-&gt;set_end(end);
3758 
3759   _block = orig_block;
3760   _state = orig_state;
3761   _last = orig_last;
3762 }
3763 
3764 
3765 bool GraphBuilder::try_inline_full(ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc, Value receiver) {
3766   assert(!callee-&gt;is_native(), &quot;callee must not be native&quot;);
3767   if (CompilationPolicy::policy()-&gt;should_not_inline(compilation()-&gt;env(), callee)) {
3768     INLINE_BAILOUT(&quot;inlining prohibited by policy&quot;);
3769   }
3770   // first perform tests of things it&#39;s not possible to inline
3771   if (callee-&gt;has_exception_handlers() &amp;&amp;
3772       !InlineMethodsWithExceptionHandlers) INLINE_BAILOUT(&quot;callee has exception handlers&quot;);
3773   if (callee-&gt;is_synchronized() &amp;&amp;
3774       !InlineSynchronizedMethods         ) INLINE_BAILOUT(&quot;callee is synchronized&quot;);
3775   if (!callee-&gt;holder()-&gt;is_initialized()) INLINE_BAILOUT(&quot;callee&#39;s klass not initialized yet&quot;);
3776   if (!callee-&gt;has_balanced_monitors())    INLINE_BAILOUT(&quot;callee&#39;s monitors do not match&quot;);
3777 
3778   // Proper inlining of methods with jsrs requires a little more work.
3779   if (callee-&gt;has_jsrs()                 ) INLINE_BAILOUT(&quot;jsrs not handled properly by inliner yet&quot;);
3780 
3781   if (strict_fp_requires_explicit_rounding &amp;&amp;
3782       method()-&gt;is_strict() != callee-&gt;is_strict()) {
3783 #ifdef IA32
3784     // If explicit rounding is required, do not inline strict code into non-strict code (or the reverse).
3785     // When SSE2 is present, no special handling is needed.
3786     if (UseSSE &lt; 2) {
3787       INLINE_BAILOUT(&quot;caller and callee have different strict fp requirements&quot;);
3788     }
3789 #else
3790     Unimplemented();
3791 #endif // IA32
3792   }
3793 
3794   if (is_profiling() &amp;&amp; !callee-&gt;ensure_method_data()) {
3795     INLINE_BAILOUT(&quot;mdo allocation failed&quot;);
3796   }
3797 
3798   // now perform tests that are based on flag settings
3799   bool inlinee_by_directive = compilation()-&gt;directive()-&gt;should_inline(callee);
3800   if (callee-&gt;force_inline() || inlinee_by_directive) {
3801     if (inline_level() &gt; MaxForceInlineLevel                    ) INLINE_BAILOUT(&quot;MaxForceInlineLevel&quot;);
3802     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
3803 
3804     const char* msg = &quot;&quot;;
3805     if (callee-&gt;force_inline())  msg = &quot;force inline by annotation&quot;;
3806     if (inlinee_by_directive)    msg = &quot;force inline by CompileCommand&quot;;
3807     print_inlining(callee, msg);
3808   } else {
3809     // use heuristic controls on inlining
3810     if (inline_level() &gt; MaxInlineLevel                         ) INLINE_BAILOUT(&quot;inlining too deep&quot;);
3811     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
3812     if (callee-&gt;code_size_for_inlining() &gt; max_inline_size()    ) INLINE_BAILOUT(&quot;callee is too large&quot;);
3813 
3814     // don&#39;t inline throwable methods unless the inlining tree is rooted in a throwable class
3815     if (callee-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
3816         callee-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
3817       // Throwable constructor call
3818       IRScope* top = scope();
3819       while (top-&gt;caller() != NULL) {
3820         top = top-&gt;caller();
3821       }
3822       if (!top-&gt;method()-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
3823         INLINE_BAILOUT(&quot;don&#39;t inline Throwable constructors&quot;);
3824       }
3825     }
3826 
3827     if (compilation()-&gt;env()-&gt;num_inlined_bytecodes() &gt; DesiredMethodLimit) {
3828       INLINE_BAILOUT(&quot;total inlining greater than DesiredMethodLimit&quot;);
3829     }
3830     // printing
3831     print_inlining(callee, &quot;inline&quot;, /*success*/ true);
3832   }
3833 
3834   // NOTE: Bailouts from this point on, which occur at the
3835   // GraphBuilder level, do not cause bailout just of the inlining but
3836   // in fact of the entire compilation.
3837 
3838   BlockBegin* orig_block = block();
3839 
3840   const bool is_invokedynamic = bc == Bytecodes::_invokedynamic;
3841   const bool has_receiver = (bc != Bytecodes::_invokestatic &amp;&amp; !is_invokedynamic);
3842 
3843   const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
3844   assert(args_base &gt;= 0, &quot;stack underflow during inlining&quot;);
3845 
3846   // Insert null check if necessary
3847   Value recv = NULL;
3848   if (has_receiver) {
3849     // note: null check must happen even if first instruction of callee does
3850     //       an implicit null check since the callee is in a different scope
3851     //       and we must make sure exception handling does the right thing
3852     assert(!callee-&gt;is_static(), &quot;callee must not be static&quot;);
3853     assert(callee-&gt;arg_size() &gt; 0, &quot;must have at least a receiver&quot;);
3854     recv = state()-&gt;stack_at(args_base);
3855     null_check(recv);
3856   }
3857 
3858   if (is_profiling()) {
3859     // Note that we&#39;d collect profile data in this method if we wanted it.
3860     // this may be redundant here...
3861     compilation()-&gt;set_would_profile(true);
3862 
3863     if (profile_calls()) {
3864       int start = 0;
3865       Values* obj_args = args_list_for_profiling(callee, start, has_receiver);
3866       if (obj_args != NULL) {
3867         int s = obj_args-&gt;max_length();
3868         // if called through method handle invoke, some arguments may have been popped
3869         for (int i = args_base+start, j = 0; j &lt; obj_args-&gt;max_length() &amp;&amp; i &lt; state()-&gt;stack_size(); ) {
3870           Value v = state()-&gt;stack_at_inc(i);
3871           if (v-&gt;type()-&gt;is_object_kind()) {
3872             obj_args-&gt;push(v);
3873             j++;
3874           }
3875         }
3876         check_args_for_profiling(obj_args, s);
3877       }
3878       profile_call(callee, recv, holder_known ? callee-&gt;holder() : NULL, obj_args, true);
3879     }
3880   }
3881 
3882   // Introduce a new callee continuation point - if the callee has
3883   // more than one return instruction or the return does not allow
3884   // fall-through of control flow, all return instructions of the
3885   // callee will need to be replaced by Goto&#39;s pointing to this
3886   // continuation point.
3887   BlockBegin* cont = block_at(next_bci());
3888   bool continuation_existed = true;
3889   if (cont == NULL) {
3890     cont = new BlockBegin(next_bci());
3891     // low number so that continuation gets parsed as early as possible
3892     cont-&gt;set_depth_first_number(0);
3893     if (PrintInitialBlockList) {
3894       tty-&gt;print_cr(&quot;CFG: created block %d (bci %d) as continuation for inline at bci %d&quot;,
3895                     cont-&gt;block_id(), cont-&gt;bci(), bci());
3896     }
3897     continuation_existed = false;
3898   }
3899   // Record number of predecessors of continuation block before
3900   // inlining, to detect if inlined method has edges to its
3901   // continuation after inlining.
3902   int continuation_preds = cont-&gt;number_of_preds();
3903 
3904   // Push callee scope
3905   push_scope(callee, cont);
3906 
3907   // the BlockListBuilder for the callee could have bailed out
3908   if (bailed_out())
3909       return false;
3910 
3911   // Temporarily set up bytecode stream so we can append instructions
3912   // (only using the bci of this stream)
3913   scope_data()-&gt;set_stream(scope_data()-&gt;parent()-&gt;stream());
3914 
3915   // Pass parameters into callee state: add assignments
3916   // note: this will also ensure that all arguments are computed before being passed
3917   ValueStack* callee_state = state();
3918   ValueStack* caller_state = state()-&gt;caller_state();
3919   for (int i = args_base; i &lt; caller_state-&gt;stack_size(); ) {
3920     const int arg_no = i - args_base;
3921     Value arg = caller_state-&gt;stack_at_inc(i);
3922     store_local(callee_state, arg, arg_no);
3923   }
3924 
3925   // Remove args from stack.
3926   // Note that we preserve locals state in case we can use it later
3927   // (see use of pop_scope() below)
3928   caller_state-&gt;truncate_stack(args_base);
3929   assert(callee_state-&gt;stack_size() == 0, &quot;callee stack must be empty&quot;);
3930 
3931   Value lock = NULL;
3932   BlockBegin* sync_handler = NULL;
3933 
3934   // Inline the locking of the receiver if the callee is synchronized
3935   if (callee-&gt;is_synchronized()) {
3936     lock = callee-&gt;is_static() ? append(new Constant(new InstanceConstant(callee-&gt;holder()-&gt;java_mirror())))
3937                                : state()-&gt;local_at(0);
3938     sync_handler = new BlockBegin(SynchronizationEntryBCI);
3939     inline_sync_entry(lock, sync_handler);
3940   }
3941 
3942   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
3943     Values* args = new Values(1);
3944     args-&gt;push(append(new Constant(new MethodConstant(method()))));
3945     append(new RuntimeCall(voidType, &quot;dtrace_method_entry&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry), args));
3946   }
3947 
3948   if (profile_inlined_calls()) {
3949     profile_invocation(callee, copy_state_before_with_bci(SynchronizationEntryBCI));
3950   }
3951 
3952   BlockBegin* callee_start_block = block_at(0);
3953   if (callee_start_block != NULL) {
3954     assert(callee_start_block-&gt;is_set(BlockBegin::parser_loop_header_flag), &quot;must be loop header&quot;);
3955     Goto* goto_callee = new Goto(callee_start_block, false);
3956     // The state for this goto is in the scope of the callee, so use
3957     // the entry bci for the callee instead of the call site bci.
3958     append_with_bci(goto_callee, 0);
3959     _block-&gt;set_end(goto_callee);
3960     callee_start_block-&gt;merge(callee_state);
3961 
3962     _last = _block = callee_start_block;
3963 
3964     scope_data()-&gt;add_to_work_list(callee_start_block);
3965   }
3966 
3967   // Clear out bytecode stream
3968   scope_data()-&gt;set_stream(NULL);
3969   scope_data()-&gt;set_ignore_return(ignore_return);
3970 
3971   CompileLog* log = compilation()-&gt;log();
3972   if (log != NULL) log-&gt;head(&quot;parse method=&#39;%d&#39;&quot;, log-&gt;identify(callee));
3973 
3974   // Ready to resume parsing in callee (either in the same block we
3975   // were in before or in the callee&#39;s start block)
3976   iterate_all_blocks(callee_start_block == NULL);
3977 
3978   if (log != NULL) log-&gt;done(&quot;parse&quot;);
3979 
3980   // If we bailed out during parsing, return immediately (this is bad news)
3981   if (bailed_out())
3982       return false;
3983 
3984   // iterate_all_blocks theoretically traverses in random order; in
3985   // practice, we have only traversed the continuation if we are
3986   // inlining into a subroutine
3987   assert(continuation_existed ||
3988          !continuation()-&gt;is_set(BlockBegin::was_visited_flag),
3989          &quot;continuation should not have been parsed yet if we created it&quot;);
3990 
3991   // At this point we are almost ready to return and resume parsing of
3992   // the caller back in the GraphBuilder. The only thing we want to do
3993   // first is an optimization: during parsing of the callee we
3994   // generated at least one Goto to the continuation block. If we
3995   // generated exactly one, and if the inlined method spanned exactly
3996   // one block (and we didn&#39;t have to Goto its entry), then we snip
3997   // off the Goto to the continuation, allowing control to fall
3998   // through back into the caller block and effectively performing
3999   // block merging. This allows load elimination and CSE to take place
4000   // across multiple callee scopes if they are relatively simple, and
4001   // is currently essential to making inlining profitable.
4002   if (num_returns() == 1
4003       &amp;&amp; block() == orig_block
4004       &amp;&amp; block() == inline_cleanup_block()) {
4005     _last  = inline_cleanup_return_prev();
4006     _state = inline_cleanup_state();
4007   } else if (continuation_preds == cont-&gt;number_of_preds()) {
4008     // Inlining caused that the instructions after the invoke in the
4009     // caller are not reachable any more. So skip filling this block
4010     // with instructions!
4011     assert(cont == continuation(), &quot;&quot;);
4012     assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
4013     _skip_block = true;
4014   } else {
4015     // Resume parsing in continuation block unless it was already parsed.
4016     // Note that if we don&#39;t change _last here, iteration in
4017     // iterate_bytecodes_for_block will stop when we return.
4018     if (!continuation()-&gt;is_set(BlockBegin::was_visited_flag)) {
4019       // add continuation to work list instead of parsing it immediately
4020       assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
4021       scope_data()-&gt;parent()-&gt;add_to_work_list(continuation());
4022       _skip_block = true;
4023     }
4024   }
4025 
4026   // Fill the exception handler for synchronized methods with instructions
4027   if (callee-&gt;is_synchronized() &amp;&amp; sync_handler-&gt;state() != NULL) {
4028     fill_sync_handler(lock, sync_handler);
4029   } else {
4030     pop_scope();
4031   }
4032 
4033   compilation()-&gt;notice_inlined_method(callee);
4034 
4035   return true;
4036 }
4037 
4038 
4039 bool GraphBuilder::try_method_handle_inline(ciMethod* callee, bool ignore_return) {
4040   ValueStack* state_before = copy_state_before();
4041   vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
4042   switch (iid) {
4043   case vmIntrinsics::_invokeBasic:
4044     {
4045       // get MethodHandle receiver
4046       const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
4047       ValueType* type = state()-&gt;stack_at(args_base)-&gt;type();
4048       if (type-&gt;is_constant()) {
4049         ciMethod* target = type-&gt;as_ObjectType()-&gt;constant_value()-&gt;as_method_handle()-&gt;get_vmtarget();
4050         // We don&#39;t do CHA here so only inline static and statically bindable methods.
4051         if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4052           if (ciMethod::is_consistent_info(callee, target)) {
4053             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
4054             ignore_return = ignore_return || (callee-&gt;return_type()-&gt;is_void() &amp;&amp; !target-&gt;return_type()-&gt;is_void());
4055             if (try_inline(target, /*holder_known*/ true, ignore_return, bc)) {
4056               return true;
4057             }
4058           } else {
4059             print_inlining(target, &quot;signatures mismatch&quot;, /*success*/ false);
4060           }
4061         } else {
4062           print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4063         }
4064       } else {
4065         print_inlining(callee, &quot;receiver not constant&quot;, /*success*/ false);
4066       }
4067     }
4068     break;
4069 
4070   case vmIntrinsics::_linkToVirtual:
4071   case vmIntrinsics::_linkToStatic:
4072   case vmIntrinsics::_linkToSpecial:
4073   case vmIntrinsics::_linkToInterface:
4074     {
4075       // pop MemberName argument
4076       const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
4077       ValueType* type = apop()-&gt;type();
4078       if (type-&gt;is_constant()) {
4079         ciMethod* target = type-&gt;as_ObjectType()-&gt;constant_value()-&gt;as_member_name()-&gt;get_vmtarget();
4080         ignore_return = ignore_return || (callee-&gt;return_type()-&gt;is_void() &amp;&amp; !target-&gt;return_type()-&gt;is_void());
4081         // If the target is another method handle invoke, try to recursively get
4082         // a better target.
4083         if (target-&gt;is_method_handle_intrinsic()) {
4084           if (try_method_handle_inline(target, ignore_return)) {
4085             return true;
4086           }
4087         } else if (!ciMethod::is_consistent_info(callee, target)) {
4088           print_inlining(target, &quot;signatures mismatch&quot;, /*success*/ false);
4089         } else {
4090           ciSignature* signature = target-&gt;signature();
4091           const int receiver_skip = target-&gt;is_static() ? 0 : 1;
4092           // Cast receiver to its type.
4093           if (!target-&gt;is_static()) {
4094             ciKlass* tk = signature-&gt;accessing_klass();
4095             Value obj = state()-&gt;stack_at(args_base);
4096             if (obj-&gt;exact_type() == NULL &amp;&amp;
4097                 obj-&gt;declared_type() != tk &amp;&amp; tk != compilation()-&gt;env()-&gt;Object_klass()) {
4098               TypeCast* c = new TypeCast(tk, obj, state_before);
4099               append(c);
4100               state()-&gt;stack_at_put(args_base, c);
4101             }
4102           }
4103           // Cast reference arguments to its type.
4104           for (int i = 0, j = 0; i &lt; signature-&gt;count(); i++) {
4105             ciType* t = signature-&gt;type_at(i);
4106             if (t-&gt;is_klass()) {
4107               ciKlass* tk = t-&gt;as_klass();
4108               Value obj = state()-&gt;stack_at(args_base + receiver_skip + j);
4109               if (obj-&gt;exact_type() == NULL &amp;&amp;
4110                   obj-&gt;declared_type() != tk &amp;&amp; tk != compilation()-&gt;env()-&gt;Object_klass()) {
4111                 TypeCast* c = new TypeCast(t, obj, state_before);
4112                 append(c);
4113                 state()-&gt;stack_at_put(args_base + receiver_skip + j, c);
4114               }
4115             }
4116             j += t-&gt;size();  // long and double take two slots
4117           }
4118           // We don&#39;t do CHA here so only inline static and statically bindable methods.
4119           if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4120             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
4121             if (try_inline(target, /*holder_known*/ true, ignore_return, bc)) {
4122               return true;
4123             }
4124           } else {
4125             print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4126           }
4127         }
4128       } else {
4129         print_inlining(callee, &quot;MemberName not constant&quot;, /*success*/ false);
4130       }
4131     }
4132     break;
4133 
4134   default:
4135     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
4136     break;
4137   }
4138   set_state(state_before-&gt;copy_for_parsing());
4139   return false;
4140 }
4141 
4142 
4143 void GraphBuilder::inline_bailout(const char* msg) {
4144   assert(msg != NULL, &quot;inline bailout msg must exist&quot;);
4145   _inline_bailout_msg = msg;
4146 }
4147 
4148 
4149 void GraphBuilder::clear_inline_bailout() {
4150   _inline_bailout_msg = NULL;
4151 }
4152 
4153 
4154 void GraphBuilder::push_root_scope(IRScope* scope, BlockList* bci2block, BlockBegin* start) {
4155   ScopeData* data = new ScopeData(NULL);
4156   data-&gt;set_scope(scope);
4157   data-&gt;set_bci2block(bci2block);
4158   _scope_data = data;
4159   _block = start;
4160 }
4161 
4162 
4163 void GraphBuilder::push_scope(ciMethod* callee, BlockBegin* continuation) {
4164   IRScope* callee_scope = new IRScope(compilation(), scope(), bci(), callee, -1, false);
4165   scope()-&gt;add_callee(callee_scope);
4166 
4167   BlockListBuilder blb(compilation(), callee_scope, -1);
4168   CHECK_BAILOUT();
4169 
4170   if (!blb.bci2block()-&gt;at(0)-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
4171     // this scope can be inlined directly into the caller so remove
4172     // the block at bci 0.
4173     blb.bci2block()-&gt;at_put(0, NULL);
4174   }
4175 
4176   set_state(new ValueStack(callee_scope, state()-&gt;copy(ValueStack::CallerState, bci())));
4177 
4178   ScopeData* data = new ScopeData(scope_data());
4179   data-&gt;set_scope(callee_scope);
4180   data-&gt;set_bci2block(blb.bci2block());
4181   data-&gt;set_continuation(continuation);
4182   _scope_data = data;
4183 }
4184 
4185 
4186 void GraphBuilder::push_scope_for_jsr(BlockBegin* jsr_continuation, int jsr_dest_bci) {
4187   ScopeData* data = new ScopeData(scope_data());
4188   data-&gt;set_parsing_jsr();
4189   data-&gt;set_jsr_entry_bci(jsr_dest_bci);
4190   data-&gt;set_jsr_return_address_local(-1);
4191   // Must clone bci2block list as we will be mutating it in order to
4192   // properly clone all blocks in jsr region as well as exception
4193   // handlers containing rets
4194   BlockList* new_bci2block = new BlockList(bci2block()-&gt;length());
4195   new_bci2block-&gt;appendAll(bci2block());
4196   data-&gt;set_bci2block(new_bci2block);
4197   data-&gt;set_scope(scope());
4198   data-&gt;setup_jsr_xhandlers();
4199   data-&gt;set_continuation(continuation());
4200   data-&gt;set_jsr_continuation(jsr_continuation);
4201   _scope_data = data;
4202 }
4203 
4204 
4205 void GraphBuilder::pop_scope() {
4206   int number_of_locks = scope()-&gt;number_of_locks();
4207   _scope_data = scope_data()-&gt;parent();
4208   // accumulate minimum number of monitor slots to be reserved
4209   scope()-&gt;set_min_number_of_locks(number_of_locks);
4210 }
4211 
4212 
4213 void GraphBuilder::pop_scope_for_jsr() {
4214   _scope_data = scope_data()-&gt;parent();
4215 }
4216 
4217 void GraphBuilder::append_unsafe_get_obj(ciMethod* callee, BasicType t, bool is_volatile) {
4218   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4219   null_check(args-&gt;at(0));
4220   Instruction* offset = args-&gt;at(2);
4221 #ifndef _LP64
4222   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4223 #endif
4224   Instruction* op = append(new UnsafeGetObject(t, args-&gt;at(1), offset, is_volatile));
4225   push(op-&gt;type(), op);
4226   compilation()-&gt;set_has_unsafe_access(true);
4227 }
4228 
4229 
4230 void GraphBuilder::append_unsafe_put_obj(ciMethod* callee, BasicType t, bool is_volatile) {
4231   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4232   null_check(args-&gt;at(0));
4233   Instruction* offset = args-&gt;at(2);
4234 #ifndef _LP64
4235   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4236 #endif
4237   Value val = args-&gt;at(3);
4238   if (t == T_BOOLEAN) {
4239     Value mask = append(new Constant(new IntConstant(1)));
4240     val = append(new LogicOp(Bytecodes::_iand, val, mask));
4241   }
4242   Instruction* op = append(new UnsafePutObject(t, args-&gt;at(1), offset, val, is_volatile));
4243   compilation()-&gt;set_has_unsafe_access(true);
4244   kill_all();
4245 }
4246 
4247 
4248 void GraphBuilder::append_unsafe_get_raw(ciMethod* callee, BasicType t) {
4249   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4250   null_check(args-&gt;at(0));
4251   Instruction* op = append(new UnsafeGetRaw(t, args-&gt;at(1), false));
4252   push(op-&gt;type(), op);
4253   compilation()-&gt;set_has_unsafe_access(true);
4254 }
4255 
4256 
4257 void GraphBuilder::append_unsafe_put_raw(ciMethod* callee, BasicType t) {
4258   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4259   null_check(args-&gt;at(0));
4260   Instruction* op = append(new UnsafePutRaw(t, args-&gt;at(1), args-&gt;at(2)));
4261   compilation()-&gt;set_has_unsafe_access(true);
4262 }
4263 
4264 
4265 void GraphBuilder::append_unsafe_CAS(ciMethod* callee) {
4266   ValueStack* state_before = copy_state_for_exception();
4267   ValueType* result_type = as_ValueType(callee-&gt;return_type());
4268   assert(result_type-&gt;is_int(), &quot;int result&quot;);
4269   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4270 
4271   // Pop off some args to specially handle, then push back
4272   Value newval = args-&gt;pop();
4273   Value cmpval = args-&gt;pop();
4274   Value offset = args-&gt;pop();
4275   Value src = args-&gt;pop();
4276   Value unsafe_obj = args-&gt;pop();
4277 
4278   // Separately handle the unsafe arg. It is not needed for code
4279   // generation, but must be null checked
4280   null_check(unsafe_obj);
4281 
4282 #ifndef _LP64
4283   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4284 #endif
4285 
4286   args-&gt;push(src);
4287   args-&gt;push(offset);
4288   args-&gt;push(cmpval);
4289   args-&gt;push(newval);
4290 
4291   // An unsafe CAS can alias with other field accesses, but we don&#39;t
4292   // know which ones so mark the state as no preserved.  This will
4293   // cause CSE to invalidate memory across it.
4294   bool preserves_state = false;
4295   Intrinsic* result = new Intrinsic(result_type, callee-&gt;intrinsic_id(), args, false, state_before, preserves_state);
4296   append_split(result);
4297   push(result_type, result);
4298   compilation()-&gt;set_has_unsafe_access(true);
4299 }
4300 
4301 void GraphBuilder::append_char_access(ciMethod* callee, bool is_store) {
4302   // This intrinsic accesses byte[] array as char[] array. Computing the offsets
4303   // correctly requires matched array shapes.
4304   assert (arrayOopDesc::base_offset_in_bytes(T_CHAR) == arrayOopDesc::base_offset_in_bytes(T_BYTE),
4305           &quot;sanity: byte[] and char[] bases agree&quot;);
4306   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
4307           &quot;sanity: byte[] and char[] scales agree&quot;);
4308 
4309   ValueStack* state_before = copy_state_indexed_access();
4310   compilation()-&gt;set_has_access_indexed(true);
4311   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4312   Value array = args-&gt;at(0);
4313   Value index = args-&gt;at(1);
4314   if (is_store) {
4315     Value value = args-&gt;at(2);
4316     Instruction* store = append(new StoreIndexed(array, index, NULL, T_CHAR, value, state_before, false, true));
4317     store-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
4318     _memory-&gt;store_value(value);
4319   } else {
4320     Instruction* load = append(new LoadIndexed(array, index, NULL, T_CHAR, state_before, true));
4321     load-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
4322     push(load-&gt;type(), load);
4323   }
4324 }
4325 
4326 static void post_inlining_event(EventCompilerInlining* event,
4327                                 int compile_id,
4328                                 const char* msg,
4329                                 bool success,
4330                                 int bci,
4331                                 ciMethod* caller,
4332                                 ciMethod* callee) {
4333   assert(caller != NULL, &quot;invariant&quot;);
4334   assert(callee != NULL, &quot;invariant&quot;);
4335   assert(event != NULL, &quot;invariant&quot;);
4336   assert(event-&gt;should_commit(), &quot;invariant&quot;);
4337   JfrStructCalleeMethod callee_struct;
4338   callee_struct.set_type(callee-&gt;holder()-&gt;name()-&gt;as_utf8());
4339   callee_struct.set_name(callee-&gt;name()-&gt;as_utf8());
4340   callee_struct.set_descriptor(callee-&gt;signature()-&gt;as_symbol()-&gt;as_utf8());
4341   event-&gt;set_compileId(compile_id);
4342   event-&gt;set_message(msg);
4343   event-&gt;set_succeeded(success);
4344   event-&gt;set_bci(bci);
4345   event-&gt;set_caller(caller-&gt;get_Method());
4346   event-&gt;set_callee(callee_struct);
4347   event-&gt;commit();
4348 }
4349 
4350 void GraphBuilder::print_inlining(ciMethod* callee, const char* msg, bool success) {
4351   CompileLog* log = compilation()-&gt;log();
4352   if (log != NULL) {
4353     assert(msg != NULL, &quot;inlining msg should not be null!&quot;);
4354     if (success) {
4355       log-&gt;inline_success(msg);
4356     } else {
4357       log-&gt;inline_fail(msg);
4358     }
4359   }
4360   EventCompilerInlining event;
4361   if (event.should_commit()) {
4362     post_inlining_event(&amp;event, compilation()-&gt;env()-&gt;task()-&gt;compile_id(), msg, success, bci(), method(), callee);
4363   }
4364 
4365   CompileTask::print_inlining_ul(callee, scope()-&gt;level(), bci(), msg);
4366 
4367   if (!compilation()-&gt;directive()-&gt;PrintInliningOption) {
4368     return;
4369   }
4370   CompileTask::print_inlining_tty(callee, scope()-&gt;level(), bci(), msg);
4371   if (success &amp;&amp; CIPrintMethodCodes) {
4372     callee-&gt;print_codes();
4373   }
4374 }
4375 
4376 void GraphBuilder::append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add) {
4377   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4378   BasicType t = callee-&gt;return_type()-&gt;basic_type();
4379   null_check(args-&gt;at(0));
4380   Instruction* offset = args-&gt;at(2);
4381 #ifndef _LP64
4382   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4383 #endif
4384   Instruction* op = append(new UnsafeGetAndSetObject(t, args-&gt;at(1), offset, args-&gt;at(3), is_add));
4385   compilation()-&gt;set_has_unsafe_access(true);
4386   kill_all();
4387   push(op-&gt;type(), op);
4388 }
4389 
4390 #ifndef PRODUCT
4391 void GraphBuilder::print_stats() {
4392   vmap()-&gt;print();
4393 }
4394 #endif // PRODUCT
4395 
4396 void GraphBuilder::profile_call(ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined) {
4397   assert(known_holder == NULL || (known_holder-&gt;is_instance_klass() &amp;&amp;
4398                                   (!known_holder-&gt;is_interface() ||
4399                                    ((ciInstanceKlass*)known_holder)-&gt;has_nonstatic_concrete_methods())), &quot;should be non-static concrete method&quot;);
4400   if (known_holder != NULL) {
4401     if (known_holder-&gt;exact_klass() == NULL) {
4402       known_holder = compilation()-&gt;cha_exact_type(known_holder);
4403     }
4404   }
4405 
4406   append(new ProfileCall(method(), bci(), callee, recv, known_holder, obj_args, inlined));
4407 }
4408 
4409 void GraphBuilder::profile_return_type(Value ret, ciMethod* callee, ciMethod* m, int invoke_bci) {
4410   assert((m == NULL) == (invoke_bci &lt; 0), &quot;invalid method and invalid bci together&quot;);
4411   if (m == NULL) {
4412     m = method();
4413   }
4414   if (invoke_bci &lt; 0) {
4415     invoke_bci = bci();
4416   }
4417   ciMethodData* md = m-&gt;method_data_or_null();
4418   ciProfileData* data = md-&gt;bci_to_data(invoke_bci);
4419   if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
4420     bool has_return = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;has_return() : ((ciVirtualCallTypeData*)data)-&gt;has_return();
4421     if (has_return) {
4422       append(new ProfileReturnType(m , invoke_bci, callee, ret));
4423     }
4424   }
4425 }
4426 
4427 void GraphBuilder::profile_invocation(ciMethod* callee, ValueStack* state) {
4428   append(new ProfileInvoke(callee, state));
4429 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
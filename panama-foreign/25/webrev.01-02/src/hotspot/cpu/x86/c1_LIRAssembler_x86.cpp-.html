<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;nativeInst_x86.hpp&quot;
  37 #include &quot;oops/objArrayKlass.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;vmreg_x86.inline.hpp&quot;
  42 
  43 
  44 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  45 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  46 // fast versions of NegF/NegD and AbsF/AbsD.
  47 
  48 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  49 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  50   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  51   // of 128-bits operands for SSE instructions.
  52   jlong *operand = (jlong*)(((intptr_t)adr) &amp; ((intptr_t)(~0xF)));
  53   // Store the value to a 128-bits operand.
  54   operand[0] = lo;
  55   operand[1] = hi;
  56   return operand;
  57 }
  58 
  59 // Buffer for 128-bits masks used by SSE instructions.
  60 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  61 
  62 // Static initialization during VM startup.
  63 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2],         CONST64(0x7FFFFFFF7FFFFFFF),         CONST64(0x7FFFFFFF7FFFFFFF));
  64 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2],         CONST64(0x7FFFFFFFFFFFFFFF),         CONST64(0x7FFFFFFFFFFFFFFF));
  65 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], (jlong)UCONST64(0x8000000080000000), (jlong)UCONST64(0x8000000080000000));
  66 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], (jlong)UCONST64(0x8000000000000000), (jlong)UCONST64(0x8000000000000000));
  67 
  68 
  69 NEEDS_CLEANUP // remove this definitions ?
  70 const Register IC_Klass    = rax;   // where the IC klass is cached
  71 const Register SYNC_header = rax;   // synchronization header
  72 const Register SHIFT_count = rcx;   // where count for shift operations must be
  73 
  74 #define __ _masm-&gt;
  75 
  76 
  77 static void select_different_registers(Register preserve,
  78                                        Register extra,
  79                                        Register &amp;tmp1,
  80                                        Register &amp;tmp2) {
  81   if (tmp1 == preserve) {
  82     assert_different_registers(tmp1, tmp2, extra);
  83     tmp1 = extra;
  84   } else if (tmp2 == preserve) {
  85     assert_different_registers(tmp1, tmp2, extra);
  86     tmp2 = extra;
  87   }
  88   assert_different_registers(preserve, tmp1, tmp2);
  89 }
  90 
  91 
  92 
  93 static void select_different_registers(Register preserve,
  94                                        Register extra,
  95                                        Register &amp;tmp1,
  96                                        Register &amp;tmp2,
  97                                        Register &amp;tmp3) {
  98   if (tmp1 == preserve) {
  99     assert_different_registers(tmp1, tmp2, tmp3, extra);
 100     tmp1 = extra;
 101   } else if (tmp2 == preserve) {
 102     assert_different_registers(tmp1, tmp2, tmp3, extra);
 103     tmp2 = extra;
 104   } else if (tmp3 == preserve) {
 105     assert_different_registers(tmp1, tmp2, tmp3, extra);
 106     tmp3 = extra;
 107   }
 108   assert_different_registers(preserve, tmp1, tmp2, tmp3);
 109 }
 110 
 111 
 112 
 113 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
 114   if (opr-&gt;is_constant()) {
 115     LIR_Const* constant = opr-&gt;as_constant_ptr();
 116     switch (constant-&gt;type()) {
 117       case T_INT: {
 118         return true;
 119       }
 120 
 121       default:
 122         return false;
 123     }
 124   }
 125   return false;
 126 }
 127 
 128 
 129 LIR_Opr LIR_Assembler::receiverOpr() {
 130   return FrameMap::receiver_opr;
 131 }
 132 
 133 LIR_Opr LIR_Assembler::osrBufferPointer() {
 134   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 135 }
 136 
 137 //--------------fpu register translations-----------------------
 138 
 139 
 140 address LIR_Assembler::float_constant(float f) {
 141   address const_addr = __ float_constant(f);
 142   if (const_addr == NULL) {
 143     bailout(&quot;const section overflow&quot;);
 144     return __ code()-&gt;consts()-&gt;start();
 145   } else {
 146     return const_addr;
 147   }
 148 }
 149 
 150 
 151 address LIR_Assembler::double_constant(double d) {
 152   address const_addr = __ double_constant(d);
 153   if (const_addr == NULL) {
 154     bailout(&quot;const section overflow&quot;);
 155     return __ code()-&gt;consts()-&gt;start();
 156   } else {
 157     return const_addr;
 158   }
 159 }
 160 
 161 #ifndef _LP64
 162 void LIR_Assembler::fpop() {
 163   __ fpop();
 164 }
 165 
 166 void LIR_Assembler::fxch(int i) {
 167   __ fxch(i);
 168 }
 169 
 170 void LIR_Assembler::fld(int i) {
 171   __ fld_s(i);
 172 }
 173 
 174 void LIR_Assembler::ffree(int i) {
 175   __ ffree(i);
 176 }
 177 #endif // !_LP64
 178 
 179 void LIR_Assembler::breakpoint() {
 180   __ int3();
 181 }
 182 
 183 void LIR_Assembler::push(LIR_Opr opr) {
 184   if (opr-&gt;is_single_cpu()) {
 185     __ push_reg(opr-&gt;as_register());
 186   } else if (opr-&gt;is_double_cpu()) {
 187     NOT_LP64(__ push_reg(opr-&gt;as_register_hi()));
 188     __ push_reg(opr-&gt;as_register_lo());
 189   } else if (opr-&gt;is_stack()) {
 190     __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
 191   } else if (opr-&gt;is_constant()) {
 192     LIR_Const* const_opr = opr-&gt;as_constant_ptr();
 193     if (const_opr-&gt;type() == T_OBJECT) {
 194       __ push_oop(const_opr-&gt;as_jobject());
 195     } else if (const_opr-&gt;type() == T_INT) {
 196       __ push_jint(const_opr-&gt;as_jint());
 197     } else {
 198       ShouldNotReachHere();
 199     }
 200 
 201   } else {
 202     ShouldNotReachHere();
 203   }
 204 }
 205 
 206 void LIR_Assembler::pop(LIR_Opr opr) {
 207   if (opr-&gt;is_single_cpu()) {
 208     __ pop_reg(opr-&gt;as_register());
 209   } else {
 210     ShouldNotReachHere();
 211   }
 212 }
 213 
 214 bool LIR_Assembler::is_literal_address(LIR_Address* addr) {
 215   return addr-&gt;base()-&gt;is_illegal() &amp;&amp; addr-&gt;index()-&gt;is_illegal();
 216 }
 217 
 218 //-------------------------------------------
 219 
 220 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 221   return as_Address(addr, rscratch1);
 222 }
 223 
 224 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 225   if (addr-&gt;base()-&gt;is_illegal()) {
 226     assert(addr-&gt;index()-&gt;is_illegal(), &quot;must be illegal too&quot;);
 227     AddressLiteral laddr((address)addr-&gt;disp(), relocInfo::none);
 228     if (! __ reachable(laddr)) {
 229       __ movptr(tmp, laddr.addr());
 230       Address res(tmp, 0);
 231       return res;
 232     } else {
 233       return __ as_Address(laddr);
 234     }
 235   }
 236 
 237   Register base = addr-&gt;base()-&gt;as_pointer_register();
 238 
 239   if (addr-&gt;index()-&gt;is_illegal()) {
 240     return Address( base, addr-&gt;disp());
 241   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 242     Register index = addr-&gt;index()-&gt;as_pointer_register();
 243     return Address(base, index, (Address::ScaleFactor) addr-&gt;scale(), addr-&gt;disp());
 244   } else if (addr-&gt;index()-&gt;is_constant()) {
 245     intptr_t addr_offset = (addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; addr-&gt;scale()) + addr-&gt;disp();
 246     assert(Assembler::is_simm32(addr_offset), &quot;must be&quot;);
 247 
 248     return Address(base, addr_offset);
 249   } else {
 250     Unimplemented();
 251     return Address();
 252   }
 253 }
 254 
 255 
 256 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 257   Address base = as_Address(addr);
 258   return Address(base._base, base._index, base._scale, base._disp + BytesPerWord);
 259 }
 260 
 261 
 262 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 263   return as_Address(addr);
 264 }
 265 
 266 
 267 void LIR_Assembler::osr_entry() {
 268   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 269   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 270   ValueStack* entry_state = osr_entry-&gt;state();
 271   int number_of_locks = entry_state-&gt;locks_size();
 272 
 273   // we jump here if osr happens with the interpreter
 274   // state set up to continue at the beginning of the
 275   // loop that triggered osr - in particular, we have
 276   // the following registers setup:
 277   //
 278   // rcx: osr buffer
 279   //
 280 
 281   // build frame
 282   ciMethod* m = compilation()-&gt;method();
 283   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 284 
 285   // OSR buffer is
 286   //
 287   // locals[nlocals-1..0]
 288   // monitors[0..number_of_locks]
 289   //
 290   // locals is a direct copy of the interpreter frame so in the osr buffer
 291   // so first slot in the local array is the last local from the interpreter
 292   // and last slot is local[0] (receiver) from the interpreter
 293   //
 294   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 295   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 296   // in the interpreter frame (the method lock if a sync method)
 297 
 298   // Initialize monitors in the compiled activation.
 299   //   rcx: pointer to osr buffer
 300   //
 301   // All other registers are dead at this point and the locals will be
 302   // copied into place by code emitted in the IR.
 303 
 304   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 305   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 306     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 307       (BasicObjectLock::size() * BytesPerWord) * (number_of_locks - 1);
 308     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 309     // the OSR buffer using 2 word entries: first the lock and then
 310     // the oop.
 311     for (int i = 0; i &lt; number_of_locks; i++) {
 312       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 313 #ifdef ASSERT
 314       // verify the interpreter&#39;s monitor has a non-null object
 315       {
 316         Label L;
 317         __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);
 318         __ jcc(Assembler::notZero, L);
 319         __ stop(&quot;locked object is NULL&quot;);
 320         __ bind(L);
 321       }
 322 #endif
 323       __ movptr(rbx, Address(OSR_buf, slot_offset + 0));
 324       __ movptr(frame_map()-&gt;address_for_monitor_lock(i), rbx);
 325       __ movptr(rbx, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 326       __ movptr(frame_map()-&gt;address_for_monitor_object(i), rbx);
 327     }
 328   }
 329 }
 330 
 331 
 332 // inline cache check; done before the frame is built.
 333 int LIR_Assembler::check_icache() {
 334   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 335   Register ic_klass = IC_Klass;
 336   const int ic_cmp_size = LP64_ONLY(10) NOT_LP64(9);
 337   const bool do_post_padding = VerifyOops || UseCompressedClassPointers;
 338   if (!do_post_padding) {
 339     // insert some nops so that the verified entry point is aligned on CodeEntryAlignment
 340     __ align(CodeEntryAlignment, __ offset() + ic_cmp_size);
 341   }
 342   int offset = __ offset();
 343   __ inline_cache_check(receiver, IC_Klass);
 344   assert(__ offset() % CodeEntryAlignment == 0 || do_post_padding, &quot;alignment must be correct&quot;);
 345   if (do_post_padding) {
 346     // force alignment after the cache check.
 347     // It&#39;s been verified to be aligned if !VerifyOops
 348     __ align(CodeEntryAlignment);
 349   }
 350   return offset;
 351 }
 352 
 353 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 354   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 355   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 356 
 357   Label L_skip_barrier;
 358   Register klass = rscratch1;
 359   Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );
 360   assert(thread != noreg, &quot;x86_32 not implemented&quot;);
 361 
 362   __ mov_metadata(klass, method-&gt;holder()-&gt;constant_encoding());
 363   __ clinit_barrier(klass, thread, &amp;L_skip_barrier /*L_fast_path*/);
 364 
 365   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 366 
 367   __ bind(L_skip_barrier);
 368 }
 369 
 370 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 371   jobject o = NULL;
 372   PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
 373   __ movoop(reg, o);
 374   patching_epilog(patch, lir_patch_normal, reg, info);
 375 }
 376 
 377 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 378   Metadata* o = NULL;
 379   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id);
 380   __ mov_metadata(reg, o);
 381   patching_epilog(patch, lir_patch_normal, reg, info);
 382 }
 383 
 384 // This specifies the rsp decrement needed to build the frame
 385 int LIR_Assembler::initial_frame_size_in_bytes() const {
 386   // if rounding, must let FrameMap know!
 387 
 388   // The frame_map records size in slots (32bit word)
 389 
 390   // subtract two words to account for return address and link
 391   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 392 }
 393 
 394 
 395 int LIR_Assembler::emit_exception_handler() {
 396   // if the last instruction is a call (typically to do a throw which
 397   // is coming at the end after block reordering) the return address
 398   // must still point into the code area in order to avoid assertion
 399   // failures when searching for the corresponding bci =&gt; add a nop
 400   // (was bug 5/14/1999 - gri)
 401   __ nop();
 402 
 403   // generate code for exception handler
 404   address handler_base = __ start_a_stub(exception_handler_size());
 405   if (handler_base == NULL) {
 406     // not enough space left for the handler
 407     bailout(&quot;exception handler overflow&quot;);
 408     return -1;
 409   }
 410 
 411   int offset = code_offset();
 412 
 413   // the exception oop and pc are in rax, and rdx
 414   // no other registers need to be preserved, so invalidate them
 415   __ invalidate_registers(false, true, true, false, true, true);
 416 
 417   // check that there is really an exception
 418   __ verify_not_null_oop(rax);
 419 
 420   // search an exception handler (rax: exception oop, rdx: throwing pc)
 421   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));
 422   __ should_not_reach_here();
 423   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 424   __ end_a_stub();
 425 
 426   return offset;
 427 }
 428 
 429 
 430 // Emit the code to remove the frame from the stack in the exception
 431 // unwind path.
 432 int LIR_Assembler::emit_unwind_handler() {
 433 #ifndef PRODUCT
 434   if (CommentedAssembly) {
 435     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 436   }
 437 #endif
 438 
 439   int offset = code_offset();
 440 
 441   // Fetch the exception from TLS and clear out exception related thread state
 442   Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 443   NOT_LP64(__ get_thread(rsi));
 444   __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));
 445   __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
 446   __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 447 
 448   __ bind(_unwind_handler_entry);
 449   __ verify_not_null_oop(rax);
 450   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 451     __ mov(rbx, rax);  // Preserve the exception (rbx is always callee-saved)
 452   }
 453 
 454   // Preform needed unlocking
 455   MonitorExitStub* stub = NULL;
 456   if (method()-&gt;is_synchronized()) {
 457     monitor_address(0, FrameMap::rax_opr);
 458     stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);
 459     __ unlock_object(rdi, rsi, rax, *stub-&gt;entry());
 460     __ bind(*stub-&gt;continuation());
 461   }
 462 
 463   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 464 #ifdef _LP64
 465     __ mov(rdi, r15_thread);
 466     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 467 #else
 468     __ get_thread(rax);
 469     __ movptr(Address(rsp, 0), rax);
 470     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 471 #endif
 472     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 473   }
 474 
 475   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 476     __ mov(rax, rbx);  // Restore the exception
 477   }
 478 
 479   // remove the activation and dispatch to the unwind handler
 480   __ remove_frame(initial_frame_size_in_bytes());
 481   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 482 
 483   // Emit the slow path assembly
 484   if (stub != NULL) {
 485     stub-&gt;emit_code(this);
 486   }
 487 
 488   return offset;
 489 }
 490 
 491 
 492 int LIR_Assembler::emit_deopt_handler() {
 493   // if the last instruction is a call (typically to do a throw which
 494   // is coming at the end after block reordering) the return address
 495   // must still point into the code area in order to avoid assertion
 496   // failures when searching for the corresponding bci =&gt; add a nop
 497   // (was bug 5/14/1999 - gri)
 498   __ nop();
 499 
 500   // generate code for exception handler
 501   address handler_base = __ start_a_stub(deopt_handler_size());
 502   if (handler_base == NULL) {
 503     // not enough space left for the handler
 504     bailout(&quot;deopt handler overflow&quot;);
 505     return -1;
 506   }
 507 
 508   int offset = code_offset();
 509   InternalAddress here(__ pc());
 510 
 511   __ pushptr(here.addr());
 512   __ jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 513   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 514   __ end_a_stub();
 515 
 516   return offset;
 517 }
 518 
 519 
 520 void LIR_Assembler::return_op(LIR_Opr result) {
 521   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 522   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 523     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 524   }
 525 
 526   // Pop the stack before the safepoint code
 527   __ remove_frame(initial_frame_size_in_bytes());
 528 
 529   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 530     __ reserved_stack_check();
 531   }
 532 
 533   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 534 
 535   // Note: we do not need to round double result; float result has the right precision
 536   // the poll sets the condition code, but no data registers
 537 
 538   if (SafepointMechanism::uses_thread_local_poll()) {
 539 #ifdef _LP64
 540     const Register poll_addr = rscratch1;
 541     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 542 #else
 543     const Register poll_addr = rbx;
 544     assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 545     __ get_thread(poll_addr);
 546     __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 547 #endif
 548     __ relocate(relocInfo::poll_return_type);
 549     __ testl(rax, Address(poll_addr, 0));
 550   } else {
 551     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 552 
 553     if (Assembler::is_polling_page_far()) {
 554       __ lea(rscratch1, polling_page);
 555       __ relocate(relocInfo::poll_return_type);
 556       __ testl(rax, Address(rscratch1, 0));
 557     } else {
 558       __ testl(rax, polling_page);
 559     }
 560   }
 561   __ ret(0);
 562 }
 563 
 564 
 565 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 566   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 567   int offset = __ offset();
 568   if (SafepointMechanism::uses_thread_local_poll()) {
 569 #ifdef _LP64
 570     const Register poll_addr = rscratch1;
 571     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 572 #else
 573     assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);
 574     const Register poll_addr = tmp-&gt;as_register();
 575     __ get_thread(poll_addr);
 576     __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));
 577 #endif
 578     add_debug_info_for_branch(info);
 579     __ relocate(relocInfo::poll_type);
 580     address pre_pc = __ pc();
 581     __ testl(rax, Address(poll_addr, 0));
 582     address post_pc = __ pc();
 583     guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);
 584   } else {
 585     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_type);
 586     if (Assembler::is_polling_page_far()) {
 587       __ lea(rscratch1, polling_page);
 588       offset = __ offset();
 589       add_debug_info_for_branch(info);
 590       __ relocate(relocInfo::poll_type);
 591       __ testl(rax, Address(rscratch1, 0));
 592     } else {
 593       add_debug_info_for_branch(info);
 594       __ testl(rax, polling_page);
 595     }
 596   }
 597   return offset;
 598 }
 599 
 600 
 601 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 602   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 603 }
 604 
 605 void LIR_Assembler::swap_reg(Register a, Register b) {
 606   __ xchgptr(a, b);
 607 }
 608 
 609 
 610 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 611   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 612   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 613   LIR_Const* c = src-&gt;as_constant_ptr();
 614 
 615   switch (c-&gt;type()) {
 616     case T_INT: {
 617       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 618       __ movl(dest-&gt;as_register(), c-&gt;as_jint());
 619       break;
 620     }
 621 
 622     case T_ADDRESS: {
 623       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 624       __ movptr(dest-&gt;as_register(), c-&gt;as_jint());
 625       break;
 626     }
 627 
 628     case T_LONG: {
 629       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 630 #ifdef _LP64
 631       __ movptr(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 632 #else
 633       __ movptr(dest-&gt;as_register_lo(), c-&gt;as_jint_lo());
 634       __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
 635 #endif // _LP64
 636       break;
 637     }
 638 
 639     case T_OBJECT: {
 640       if (patch_code != lir_patch_none) {
 641         jobject2reg_with_patching(dest-&gt;as_register(), info);
 642       } else {
 643         __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
 644       }
 645       break;
 646     }
 647 
 648     case T_METADATA: {
 649       if (patch_code != lir_patch_none) {
 650         klass2reg_with_patching(dest-&gt;as_register(), info);
 651       } else {
 652         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 653       }
 654       break;
 655     }
 656 
 657     case T_FLOAT: {
 658       if (dest-&gt;is_single_xmm()) {
 659         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_float()) {
 660           __ xorps(dest-&gt;as_xmm_float_reg(), dest-&gt;as_xmm_float_reg());
 661         } else {
 662           __ movflt(dest-&gt;as_xmm_float_reg(),
 663                    InternalAddress(float_constant(c-&gt;as_jfloat())));
 664         }
 665       } else {
 666 #ifndef _LP64
 667         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
 668         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
 669         if (c-&gt;is_zero_float()) {
 670           __ fldz();
 671         } else if (c-&gt;is_one_float()) {
 672           __ fld1();
 673         } else {
 674           __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
 675         }
 676 #else
 677         ShouldNotReachHere();
 678 #endif // !_LP64
 679       }
 680       break;
 681     }
 682 
 683     case T_DOUBLE: {
 684       if (dest-&gt;is_double_xmm()) {
 685         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_double()) {
 686           __ xorpd(dest-&gt;as_xmm_double_reg(), dest-&gt;as_xmm_double_reg());
 687         } else {
 688           __ movdbl(dest-&gt;as_xmm_double_reg(),
 689                     InternalAddress(double_constant(c-&gt;as_jdouble())));
 690         }
 691       } else {
 692 #ifndef _LP64
 693         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
 694         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
 695         if (c-&gt;is_zero_double()) {
 696           __ fldz();
 697         } else if (c-&gt;is_one_double()) {
 698           __ fld1();
 699         } else {
 700           __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
 701         }
 702 #else
 703         ShouldNotReachHere();
 704 #endif // !_LP64
 705       }
 706       break;
 707     }
 708 
 709     default:
 710       ShouldNotReachHere();
 711   }
 712 }
 713 
 714 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 715   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 716   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 717   LIR_Const* c = src-&gt;as_constant_ptr();
 718 
 719   switch (c-&gt;type()) {
 720     case T_INT:  // fall through
 721     case T_FLOAT:
 722       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 723       break;
 724 
 725     case T_ADDRESS:
 726       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 727       break;
 728 
 729     case T_OBJECT:
 730       __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
 731       break;
 732 
 733     case T_LONG:  // fall through
 734     case T_DOUBLE:
 735 #ifdef _LP64
 736       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 737                                             lo_word_offset_in_bytes), (intptr_t)c-&gt;as_jlong_bits());
 738 #else
 739       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 740                                               lo_word_offset_in_bytes), c-&gt;as_jint_lo_bits());
 741       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 742                                               hi_word_offset_in_bytes), c-&gt;as_jint_hi_bits());
 743 #endif // _LP64
 744       break;
 745 
 746     default:
 747       ShouldNotReachHere();
 748   }
 749 }
 750 
 751 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 752   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 753   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 754   LIR_Const* c = src-&gt;as_constant_ptr();
 755   LIR_Address* addr = dest-&gt;as_address_ptr();
 756 
 757   int null_check_here = code_offset();
 758   switch (type) {
 759     case T_INT:    // fall through
 760     case T_FLOAT:
 761       __ movl(as_Address(addr), c-&gt;as_jint_bits());
 762       break;
 763 
 764     case T_ADDRESS:
 765       __ movptr(as_Address(addr), c-&gt;as_jint_bits());
 766       break;
 767 
 768     case T_OBJECT:  // fall through
 769     case T_ARRAY:
 770       if (c-&gt;as_jobject() == NULL) {
 771         if (UseCompressedOops &amp;&amp; !wide) {
 772           __ movl(as_Address(addr), (int32_t)NULL_WORD);
 773         } else {
 774 #ifdef _LP64
 775           __ xorptr(rscratch1, rscratch1);
 776           null_check_here = code_offset();
 777           __ movptr(as_Address(addr), rscratch1);
 778 #else
 779           __ movptr(as_Address(addr), NULL_WORD);
 780 #endif
 781         }
 782       } else {
 783         if (is_literal_address(addr)) {
 784           ShouldNotReachHere();
 785           __ movoop(as_Address(addr, noreg), c-&gt;as_jobject());
 786         } else {
 787 #ifdef _LP64
 788           __ movoop(rscratch1, c-&gt;as_jobject());
 789           if (UseCompressedOops &amp;&amp; !wide) {
 790             __ encode_heap_oop(rscratch1);
 791             null_check_here = code_offset();
 792             __ movl(as_Address_lo(addr), rscratch1);
 793           } else {
 794             null_check_here = code_offset();
 795             __ movptr(as_Address_lo(addr), rscratch1);
 796           }
 797 #else
 798           __ movoop(as_Address(addr), c-&gt;as_jobject());
 799 #endif
 800         }
 801       }
 802       break;
 803 
 804     case T_LONG:    // fall through
 805     case T_DOUBLE:
 806 #ifdef _LP64
 807       if (is_literal_address(addr)) {
 808         ShouldNotReachHere();
 809         __ movptr(as_Address(addr, r15_thread), (intptr_t)c-&gt;as_jlong_bits());
 810       } else {
 811         __ movptr(r10, (intptr_t)c-&gt;as_jlong_bits());
 812         null_check_here = code_offset();
 813         __ movptr(as_Address_lo(addr), r10);
 814       }
 815 #else
 816       // Always reachable in 32bit so this doesn&#39;t produce useless move literal
 817       __ movptr(as_Address_hi(addr), c-&gt;as_jint_hi_bits());
 818       __ movptr(as_Address_lo(addr), c-&gt;as_jint_lo_bits());
 819 #endif // _LP64
 820       break;
 821 
 822     case T_BOOLEAN: // fall through
 823     case T_BYTE:
 824       __ movb(as_Address(addr), c-&gt;as_jint() &amp; 0xFF);
 825       break;
 826 
 827     case T_CHAR:    // fall through
 828     case T_SHORT:
 829       __ movw(as_Address(addr), c-&gt;as_jint() &amp; 0xFFFF);
 830       break;
 831 
 832     default:
 833       ShouldNotReachHere();
 834   };
 835 
 836   if (info != NULL) {
 837     add_debug_info_for_null_check(null_check_here, info);
 838   }
 839 }
 840 
 841 
 842 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 843   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 844   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 845 
 846   // move between cpu-registers
 847   if (dest-&gt;is_single_cpu()) {
 848 #ifdef _LP64
 849     if (src-&gt;type() == T_LONG) {
 850       // Can do LONG -&gt; OBJECT
 851       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 852       return;
 853     }
 854 #endif
 855     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 856     if (src-&gt;type() == T_OBJECT) {
 857       __ verify_oop(src-&gt;as_register());
 858     }
 859     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 860 
 861   } else if (dest-&gt;is_double_cpu()) {
 862 #ifdef _LP64
 863     if (is_reference_type(src-&gt;type())) {
 864       // Surprising to me but we can see move of a long to t_object
 865       __ verify_oop(src-&gt;as_register());
 866       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 867       return;
 868     }
 869 #endif
 870     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 871     Register f_lo = src-&gt;as_register_lo();
 872     Register f_hi = src-&gt;as_register_hi();
 873     Register t_lo = dest-&gt;as_register_lo();
 874     Register t_hi = dest-&gt;as_register_hi();
 875 #ifdef _LP64
 876     assert(f_hi == f_lo, &quot;must be same&quot;);
 877     assert(t_hi == t_lo, &quot;must be same&quot;);
 878     move_regs(f_lo, t_lo);
 879 #else
 880     assert(f_lo != f_hi &amp;&amp; t_lo != t_hi, &quot;invalid register allocation&quot;);
 881 
 882 
 883     if (f_lo == t_hi &amp;&amp; f_hi == t_lo) {
 884       swap_reg(f_lo, f_hi);
 885     } else if (f_hi == t_lo) {
 886       assert(f_lo != t_hi, &quot;overwriting register&quot;);
 887       move_regs(f_hi, t_hi);
 888       move_regs(f_lo, t_lo);
 889     } else {
 890       assert(f_hi != t_lo, &quot;overwriting register&quot;);
 891       move_regs(f_lo, t_lo);
 892       move_regs(f_hi, t_hi);
 893     }
 894 #endif // LP64
 895 
 896 #ifndef _LP64
 897     // special moves from fpu-register to xmm-register
 898     // necessary for method results
 899   } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
 900     __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
 901     __ fld_s(Address(rsp, 0));
 902   } else if (src-&gt;is_double_xmm() &amp;&amp; !dest-&gt;is_double_xmm()) {
 903     __ movdbl(Address(rsp, 0), src-&gt;as_xmm_double_reg());
 904     __ fld_d(Address(rsp, 0));
 905   } else if (dest-&gt;is_single_xmm() &amp;&amp; !src-&gt;is_single_xmm()) {
 906     __ fstp_s(Address(rsp, 0));
 907     __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
 908   } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
 909     __ fstp_d(Address(rsp, 0));
 910     __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
 911 #endif // !_LP64
 912 
 913     // move between xmm-registers
 914   } else if (dest-&gt;is_single_xmm()) {
 915     assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
 916     __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
 917   } else if (dest-&gt;is_double_xmm()) {
 918     assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
 919     __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
 920 
 921 #ifndef _LP64
 922     // move between fpu-registers (no instruction necessary because of fpu-stack)
 923   } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 924     assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
 925     assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
 926 #endif // !_LP64
 927 
 928   } else {
 929     ShouldNotReachHere();
 930   }
 931 }
 932 
 933 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 934   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 935   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 936 
 937   if (src-&gt;is_single_cpu()) {
 938     Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 939     if (is_reference_type(type)) {
 940       __ verify_oop(src-&gt;as_register());
 941       __ movptr (dst, src-&gt;as_register());
 942     } else if (type == T_METADATA || type == T_ADDRESS) {
 943       __ movptr (dst, src-&gt;as_register());
 944     } else {
 945       __ movl (dst, src-&gt;as_register());
 946     }
 947 
 948   } else if (src-&gt;is_double_cpu()) {
 949     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 950     Address dstHI = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), hi_word_offset_in_bytes);
 951     __ movptr (dstLO, src-&gt;as_register_lo());
 952     NOT_LP64(__ movptr (dstHI, src-&gt;as_register_hi()));
 953 
 954   } else if (src-&gt;is_single_xmm()) {
 955     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 956     __ movflt(dst_addr, src-&gt;as_xmm_float_reg());
 957 
 958   } else if (src-&gt;is_double_xmm()) {
 959     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 960     __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
 961 
 962 #ifndef _LP64
 963   } else if (src-&gt;is_single_fpu()) {
 964     assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 965     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 966     if (pop_fpu_stack)     __ fstp_s (dst_addr);
 967     else                   __ fst_s  (dst_addr);
 968 
 969   } else if (src-&gt;is_double_fpu()) {
 970     assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
 971     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 972     if (pop_fpu_stack)     __ fstp_d (dst_addr);
 973     else                   __ fst_d  (dst_addr);
 974 #endif // !_LP64
 975 
 976   } else {
 977     ShouldNotReachHere();
 978   }
 979 }
 980 
 981 
 982 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 983   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 984   PatchingStub* patch = NULL;
 985   Register compressed_src = rscratch1;
 986 
 987   if (is_reference_type(type)) {
 988     __ verify_oop(src-&gt;as_register());
 989 #ifdef _LP64
 990     if (UseCompressedOops &amp;&amp; !wide) {
 991       __ movptr(compressed_src, src-&gt;as_register());
 992       __ encode_heap_oop(compressed_src);
 993       if (patch_code != lir_patch_none) {
 994         info-&gt;oop_map()-&gt;set_narrowoop(compressed_src-&gt;as_VMReg());
 995       }
 996     }
 997 #endif
 998   }
 999 
1000   if (patch_code != lir_patch_none) {
1001     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1002     Address toa = as_Address(to_addr);
1003     assert(toa.disp() != 0, &quot;must have&quot;);
1004   }
1005 
1006   int null_check_here = code_offset();
1007   switch (type) {
1008     case T_FLOAT: {
1009 #ifdef _LP64
1010       assert(src-&gt;is_single_xmm(), &quot;not a float&quot;);
1011       __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1012 #else
1013       if (src-&gt;is_single_xmm()) {
1014         __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1015       } else {
1016         assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
1017         assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
1018         if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
1019         else                    __ fst_s (as_Address(to_addr));
1020       }
1021 #endif // _LP64
1022       break;
1023     }
1024 
1025     case T_DOUBLE: {
1026 #ifdef _LP64
1027       assert(src-&gt;is_double_xmm(), &quot;not a double&quot;);
1028       __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1029 #else
1030       if (src-&gt;is_double_xmm()) {
1031         __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1032       } else {
1033         assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
1034         assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1035         if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
1036         else                    __ fst_d (as_Address(to_addr));
1037       }
1038 #endif // _LP64
1039       break;
1040     }
1041 
1042     case T_ARRAY:   // fall through
1043     case T_OBJECT:  // fall through
1044       if (UseCompressedOops &amp;&amp; !wide) {
1045         __ movl(as_Address(to_addr), compressed_src);
1046       } else {
1047         __ movptr(as_Address(to_addr), src-&gt;as_register());
1048       }
1049       break;
1050     case T_METADATA:
1051       // We get here to store a method pointer to the stack to pass to
1052       // a dtrace runtime call. This can&#39;t work on 64 bit with
1053       // compressed klass ptrs: T_METADATA can be a compressed klass
1054       // ptr or a 64 bit method pointer.
1055       LP64_ONLY(ShouldNotReachHere());
1056       __ movptr(as_Address(to_addr), src-&gt;as_register());
1057       break;
1058     case T_ADDRESS:
1059       __ movptr(as_Address(to_addr), src-&gt;as_register());
1060       break;
1061     case T_INT:
1062       __ movl(as_Address(to_addr), src-&gt;as_register());
1063       break;
1064 
1065     case T_LONG: {
1066       Register from_lo = src-&gt;as_register_lo();
1067       Register from_hi = src-&gt;as_register_hi();
1068 #ifdef _LP64
1069       __ movptr(as_Address_lo(to_addr), from_lo);
1070 #else
1071       Register base = to_addr-&gt;base()-&gt;as_register();
1072       Register index = noreg;
1073       if (to_addr-&gt;index()-&gt;is_register()) {
1074         index = to_addr-&gt;index()-&gt;as_register();
1075       }
1076       if (base == from_lo || index == from_lo) {
1077         assert(base != from_hi, &quot;can&#39;t be&quot;);
1078         assert(index == noreg || (index != base &amp;&amp; index != from_hi), &quot;can&#39;t handle this&quot;);
1079         __ movl(as_Address_hi(to_addr), from_hi);
1080         if (patch != NULL) {
1081           patching_epilog(patch, lir_patch_high, base, info);
1082           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1083           patch_code = lir_patch_low;
1084         }
1085         __ movl(as_Address_lo(to_addr), from_lo);
1086       } else {
1087         assert(index == noreg || (index != base &amp;&amp; index != from_lo), &quot;can&#39;t handle this&quot;);
1088         __ movl(as_Address_lo(to_addr), from_lo);
1089         if (patch != NULL) {
1090           patching_epilog(patch, lir_patch_low, base, info);
1091           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1092           patch_code = lir_patch_high;
1093         }
1094         __ movl(as_Address_hi(to_addr), from_hi);
1095       }
1096 #endif // _LP64
1097       break;
1098     }
1099 
1100     case T_BYTE:    // fall through
1101     case T_BOOLEAN: {
1102       Register src_reg = src-&gt;as_register();
1103       Address dst_addr = as_Address(to_addr);
1104       assert(VM_Version::is_P6() || src_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1105       __ movb(dst_addr, src_reg);
1106       break;
1107     }
1108 
1109     case T_CHAR:    // fall through
1110     case T_SHORT:
1111       __ movw(as_Address(to_addr), src-&gt;as_register());
1112       break;
1113 
1114     default:
1115       ShouldNotReachHere();
1116   }
1117   if (info != NULL) {
1118     add_debug_info_for_null_check(null_check_here, info);
1119   }
1120 
1121   if (patch_code != lir_patch_none) {
1122     patching_epilog(patch, patch_code, to_addr-&gt;base()-&gt;as_register(), info);
1123   }
1124 }
1125 
1126 
1127 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1128   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1129   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1130 
1131   if (dest-&gt;is_single_cpu()) {
1132     if (is_reference_type(type)) {
1133       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1134       __ verify_oop(dest-&gt;as_register());
1135     } else if (type == T_METADATA || type == T_ADDRESS) {
1136       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1137     } else {
1138       __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1139     }
1140 
1141   } else if (dest-&gt;is_double_cpu()) {
1142     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
1143     Address src_addr_HI = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), hi_word_offset_in_bytes);
1144     __ movptr(dest-&gt;as_register_lo(), src_addr_LO);
1145     NOT_LP64(__ movptr(dest-&gt;as_register_hi(), src_addr_HI));
1146 
1147   } else if (dest-&gt;is_single_xmm()) {
1148     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1149     __ movflt(dest-&gt;as_xmm_float_reg(), src_addr);
1150 
1151   } else if (dest-&gt;is_double_xmm()) {
1152     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1153     __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
1154 
1155 #ifndef _LP64
1156   } else if (dest-&gt;is_single_fpu()) {
1157     assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1158     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1159     __ fld_s(src_addr);
1160 
1161   } else if (dest-&gt;is_double_fpu()) {
1162     assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1163     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1164     __ fld_d(src_addr);
1165 #endif // _LP64
1166 
1167   } else {
1168     ShouldNotReachHere();
1169   }
1170 }
1171 
1172 
1173 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1174   if (src-&gt;is_single_stack()) {
1175     if (is_reference_type(type)) {
1176       __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1177       __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1178     } else {
1179 #ifndef _LP64
1180       __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1181       __ popl (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1182 #else
1183       //no pushl on 64bits
1184       __ movl(rscratch1, frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1185       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), rscratch1);
1186 #endif
1187     }
1188 
1189   } else if (src-&gt;is_double_stack()) {
1190 #ifdef _LP64
1191     __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix()));
1192     __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
1193 #else
1194     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 0));
1195     // push and pop the part at src + wordSize, adding wordSize for the previous push
1196     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 2 * wordSize));
1197     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 2 * wordSize));
1198     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 0));
1199 #endif // _LP64
1200 
1201   } else {
1202     ShouldNotReachHere();
1203   }
1204 }
1205 
1206 
1207 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
1208   assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
1209   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1210 
1211   LIR_Address* addr = src-&gt;as_address_ptr();
1212   Address from_addr = as_Address(addr);
1213 
1214   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1215     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
1216   }
1217 
1218   switch (type) {
1219     case T_BOOLEAN: // fall through
1220     case T_BYTE:    // fall through
1221     case T_CHAR:    // fall through
1222     case T_SHORT:
1223       if (!VM_Version::is_P6() &amp;&amp; !from_addr.uses(dest-&gt;as_register())) {
1224         // on pre P6 processors we may get partial register stalls
1225         // so blow away the value of to_rinfo before loading a
1226         // partial word into it.  Do it here so that it precedes
1227         // the potential patch point below.
1228         __ xorptr(dest-&gt;as_register(), dest-&gt;as_register());
1229       }
1230       break;
1231    default:
1232      break;
1233   }
1234 
1235   PatchingStub* patch = NULL;
1236   if (patch_code != lir_patch_none) {
1237     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1238     assert(from_addr.disp() != 0, &quot;must have&quot;);
1239   }
1240   if (info != NULL) {
1241     add_debug_info_for_null_check_here(info);
1242   }
1243 
1244   switch (type) {
1245     case T_FLOAT: {
1246       if (dest-&gt;is_single_xmm()) {
1247         __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
1248       } else {
1249 #ifndef _LP64
1250         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
1251         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1252         __ fld_s(from_addr);
1253 #else
1254         ShouldNotReachHere();
1255 #endif // !LP64
1256       }
1257       break;
1258     }
1259 
1260     case T_DOUBLE: {
1261       if (dest-&gt;is_double_xmm()) {
1262         __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
1263       } else {
1264 #ifndef _LP64
1265         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
1266         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1267         __ fld_d(from_addr);
1268 #else
1269         ShouldNotReachHere();
1270 #endif // !LP64
1271       }
1272       break;
1273     }
1274 
1275     case T_OBJECT:  // fall through
1276     case T_ARRAY:   // fall through
1277       if (UseCompressedOops &amp;&amp; !wide) {
1278         __ movl(dest-&gt;as_register(), from_addr);
1279       } else {
1280         __ movptr(dest-&gt;as_register(), from_addr);
1281       }
1282       break;
1283 
1284     case T_ADDRESS:
1285       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1286         __ movl(dest-&gt;as_register(), from_addr);
1287       } else {
1288         __ movptr(dest-&gt;as_register(), from_addr);
1289       }
1290       break;
1291     case T_INT:
1292       __ movl(dest-&gt;as_register(), from_addr);
1293       break;
1294 
1295     case T_LONG: {
1296       Register to_lo = dest-&gt;as_register_lo();
1297       Register to_hi = dest-&gt;as_register_hi();
1298 #ifdef _LP64
1299       __ movptr(to_lo, as_Address_lo(addr));
1300 #else
1301       Register base = addr-&gt;base()-&gt;as_register();
1302       Register index = noreg;
1303       if (addr-&gt;index()-&gt;is_register()) {
1304         index = addr-&gt;index()-&gt;as_register();
1305       }
1306       if ((base == to_lo &amp;&amp; index == to_hi) ||
1307           (base == to_hi &amp;&amp; index == to_lo)) {
1308         // addresses with 2 registers are only formed as a result of
1309         // array access so this code will never have to deal with
1310         // patches or null checks.
1311         assert(info == NULL &amp;&amp; patch == NULL, &quot;must be&quot;);
1312         __ lea(to_hi, as_Address(addr));
1313         __ movl(to_lo, Address(to_hi, 0));
1314         __ movl(to_hi, Address(to_hi, BytesPerWord));
1315       } else if (base == to_lo || index == to_lo) {
1316         assert(base != to_hi, &quot;can&#39;t be&quot;);
1317         assert(index == noreg || (index != base &amp;&amp; index != to_hi), &quot;can&#39;t handle this&quot;);
1318         __ movl(to_hi, as_Address_hi(addr));
1319         if (patch != NULL) {
1320           patching_epilog(patch, lir_patch_high, base, info);
1321           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1322           patch_code = lir_patch_low;
1323         }
1324         __ movl(to_lo, as_Address_lo(addr));
1325       } else {
1326         assert(index == noreg || (index != base &amp;&amp; index != to_lo), &quot;can&#39;t handle this&quot;);
1327         __ movl(to_lo, as_Address_lo(addr));
1328         if (patch != NULL) {
1329           patching_epilog(patch, lir_patch_low, base, info);
1330           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1331           patch_code = lir_patch_high;
1332         }
1333         __ movl(to_hi, as_Address_hi(addr));
1334       }
1335 #endif // _LP64
1336       break;
1337     }
1338 
1339     case T_BOOLEAN: // fall through
1340     case T_BYTE: {
1341       Register dest_reg = dest-&gt;as_register();
1342       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1343       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1344         __ movsbl(dest_reg, from_addr);
1345       } else {
1346         __ movb(dest_reg, from_addr);
1347         __ shll(dest_reg, 24);
1348         __ sarl(dest_reg, 24);
1349       }
1350       break;
1351     }
1352 
1353     case T_CHAR: {
1354       Register dest_reg = dest-&gt;as_register();
1355       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1356       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1357         __ movzwl(dest_reg, from_addr);
1358       } else {
1359         __ movw(dest_reg, from_addr);
1360       }
1361       break;
1362     }
1363 
1364     case T_SHORT: {
1365       Register dest_reg = dest-&gt;as_register();
1366       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1367         __ movswl(dest_reg, from_addr);
1368       } else {
1369         __ movw(dest_reg, from_addr);
1370         __ shll(dest_reg, 16);
1371         __ sarl(dest_reg, 16);
1372       }
1373       break;
1374     }
1375 
1376     default:
1377       ShouldNotReachHere();
1378   }
1379 
1380   if (patch != NULL) {
1381     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
1382   }
1383 
1384   if (is_reference_type(type)) {
1385 #ifdef _LP64
1386     if (UseCompressedOops &amp;&amp; !wide) {
1387       __ decode_heap_oop(dest-&gt;as_register());
1388     }
1389 #endif
1390 
1391     // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1392     if (!UseZGC) {
1393       __ verify_oop(dest-&gt;as_register());
1394     }
1395   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1396 #ifdef _LP64
1397     if (UseCompressedClassPointers) {
1398       __ decode_klass_not_null(dest-&gt;as_register());
1399     }
1400 #endif
1401   }
1402 }
1403 
1404 
1405 NEEDS_CLEANUP; // This could be static?
1406 Address::ScaleFactor LIR_Assembler::array_element_size(BasicType type) const {
1407   int elem_size = type2aelembytes(type);
1408   switch (elem_size) {
1409     case 1: return Address::times_1;
1410     case 2: return Address::times_2;
1411     case 4: return Address::times_4;
1412     case 8: return Address::times_8;
1413   }
1414   ShouldNotReachHere();
1415   return Address::no_scale;
1416 }
1417 
1418 
1419 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1420   switch (op-&gt;code()) {
1421     case lir_idiv:
1422     case lir_irem:
1423       arithmetic_idiv(op-&gt;code(),
1424                       op-&gt;in_opr1(),
1425                       op-&gt;in_opr2(),
1426                       op-&gt;in_opr3(),
1427                       op-&gt;result_opr(),
1428                       op-&gt;info());
1429       break;
1430     case lir_fmad:
1431       __ fmad(op-&gt;result_opr()-&gt;as_xmm_double_reg(),
1432               op-&gt;in_opr1()-&gt;as_xmm_double_reg(),
1433               op-&gt;in_opr2()-&gt;as_xmm_double_reg(),
1434               op-&gt;in_opr3()-&gt;as_xmm_double_reg());
1435       break;
1436     case lir_fmaf:
1437       __ fmaf(op-&gt;result_opr()-&gt;as_xmm_float_reg(),
1438               op-&gt;in_opr1()-&gt;as_xmm_float_reg(),
1439               op-&gt;in_opr2()-&gt;as_xmm_float_reg(),
1440               op-&gt;in_opr3()-&gt;as_xmm_float_reg());
1441       break;
1442     default:      ShouldNotReachHere(); break;
1443   }
1444 }
1445 
1446 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1447 #ifdef ASSERT
1448   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1449   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1450   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1451 #endif
1452 
1453   if (op-&gt;cond() == lir_cond_always) {
1454     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1455     __ jmp (*(op-&gt;label()));
1456   } else {
1457     Assembler::Condition acond = Assembler::zero;
1458     if (op-&gt;code() == lir_cond_float_branch) {
1459       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
1460       __ jcc(Assembler::parity, *(op-&gt;ublock()-&gt;label()));
1461       switch(op-&gt;cond()) {
1462         case lir_cond_equal:        acond = Assembler::equal;      break;
1463         case lir_cond_notEqual:     acond = Assembler::notEqual;   break;
1464         case lir_cond_less:         acond = Assembler::below;      break;
1465         case lir_cond_lessEqual:    acond = Assembler::belowEqual; break;
1466         case lir_cond_greaterEqual: acond = Assembler::aboveEqual; break;
1467         case lir_cond_greater:      acond = Assembler::above;      break;
1468         default:                         ShouldNotReachHere();
1469       }
1470     } else {
1471       switch (op-&gt;cond()) {
1472         case lir_cond_equal:        acond = Assembler::equal;       break;
1473         case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
1474         case lir_cond_less:         acond = Assembler::less;        break;
1475         case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
1476         case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
1477         case lir_cond_greater:      acond = Assembler::greater;     break;
1478         case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
1479         case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
1480         default:                         ShouldNotReachHere();
1481       }
1482     }
1483     __ jcc(acond,*(op-&gt;label()));
1484   }
1485 }
1486 
1487 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1488   LIR_Opr src  = op-&gt;in_opr();
1489   LIR_Opr dest = op-&gt;result_opr();
1490 
1491   switch (op-&gt;bytecode()) {
1492     case Bytecodes::_i2l:
1493 #ifdef _LP64
1494       __ movl2ptr(dest-&gt;as_register_lo(), src-&gt;as_register());
1495 #else
1496       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
1497       move_regs(src-&gt;as_register(), dest-&gt;as_register_hi());
1498       __ sarl(dest-&gt;as_register_hi(), 31);
1499 #endif // LP64
1500       break;
1501 
1502     case Bytecodes::_l2i:
1503 #ifdef _LP64
1504       __ movl(dest-&gt;as_register(), src-&gt;as_register_lo());
1505 #else
1506       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
1507 #endif
1508       break;
1509 
1510     case Bytecodes::_i2b:
1511       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1512       __ sign_extend_byte(dest-&gt;as_register());
1513       break;
1514 
1515     case Bytecodes::_i2c:
1516       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1517       __ andl(dest-&gt;as_register(), 0xFFFF);
1518       break;
1519 
1520     case Bytecodes::_i2s:
1521       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1522       __ sign_extend_short(dest-&gt;as_register());
1523       break;
1524 
1525 
1526 #ifdef _LP64
1527     case Bytecodes::_f2d:
1528       __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1529       break;
1530 
1531     case Bytecodes::_d2f:
1532       __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1533       break;
1534 
1535     case Bytecodes::_i2f:
1536       __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1537       break;
1538 
1539     case Bytecodes::_i2d:
1540       __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1541       break;
1542 
1543     case Bytecodes::_l2f:
1544       __ cvtsi2ssq(dest-&gt;as_xmm_float_reg(), src-&gt;as_register_lo());
1545       break;
1546 
1547     case Bytecodes::_l2d:
1548       __ cvtsi2sdq(dest-&gt;as_xmm_double_reg(), src-&gt;as_register_lo());
1549       break;
1550 
1551     case Bytecodes::_f2i:
1552       __ convert_f2i(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1553       break;
1554 
1555     case Bytecodes::_d2i:
1556       __ convert_d2i(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1557       break;
1558 
1559     case Bytecodes::_f2l:
1560       __ convert_f2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_float_reg());
1561       break;
1562 
1563     case Bytecodes::_d2l:
1564       __ convert_d2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
1565       break;
1566 #else
1567     case Bytecodes::_f2d:
1568     case Bytecodes::_d2f:
1569       if (dest-&gt;is_single_xmm()) {
1570         __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1571       } else if (dest-&gt;is_double_xmm()) {
1572         __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1573       } else {
1574         assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;register must be equal&quot;);
1575         // do nothing (float result is rounded later through spilling)
1576       }
1577       break;
1578 
1579     case Bytecodes::_i2f:
1580     case Bytecodes::_i2d:
1581       if (dest-&gt;is_single_xmm()) {
1582         __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1583       } else if (dest-&gt;is_double_xmm()) {
1584         __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1585       } else {
1586         assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1587         __ movl(Address(rsp, 0), src-&gt;as_register());
1588         __ fild_s(Address(rsp, 0));
1589       }
1590       break;
1591 
1592     case Bytecodes::_l2f:
1593     case Bytecodes::_l2d:
1594       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);
1595       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1596       __ movptr(Address(rsp, 0),          src-&gt;as_register_lo());
1597       __ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi());
1598       __ fild_d(Address(rsp, 0));
1599       // float result is rounded later through spilling
1600       break;
1601 
1602     case Bytecodes::_f2i:
1603     case Bytecodes::_d2i:
1604       if (src-&gt;is_single_xmm()) {
1605         __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1606       } else if (src-&gt;is_double_xmm()) {
1607         __ cvttsd2sil(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1608       } else {
1609         assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1610         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
1611         __ fist_s(Address(rsp, 0));
1612         __ movl(dest-&gt;as_register(), Address(rsp, 0));
1613         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
1614       }
1615       // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
1616       assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
1617       __ cmpl(dest-&gt;as_register(), 0x80000000);
1618       __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
1619       __ bind(*op-&gt;stub()-&gt;continuation());
1620       break;
1621 
1622     case Bytecodes::_f2l:
1623     case Bytecodes::_d2l:
1624       assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
1625       assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1626       assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
1627 
1628       // instruction sequence too long to inline it here
1629       {
1630         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
1631       }
1632       break;
1633 #endif // _LP64
1634 
1635     default: ShouldNotReachHere();
1636   }
1637 }
1638 
1639 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1640   if (op-&gt;init_check()) {
1641     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1642     __ cmpb(Address(op-&gt;klass()-&gt;as_register(),
1643                     InstanceKlass::init_state_offset()),
1644                     InstanceKlass::fully_initialized);
1645     __ jcc(Assembler::notEqual, *op-&gt;stub()-&gt;entry());
1646   }
1647   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1648                      op-&gt;tmp1()-&gt;as_register(),
1649                      op-&gt;tmp2()-&gt;as_register(),
1650                      op-&gt;header_size(),
1651                      op-&gt;object_size(),
1652                      op-&gt;klass()-&gt;as_register(),
1653                      *op-&gt;stub()-&gt;entry());
1654   __ bind(*op-&gt;stub()-&gt;continuation());
1655 }
1656 
1657 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1658   Register len =  op-&gt;len()-&gt;as_register();
1659   LP64_ONLY( __ movslq(len, len); )
1660 
1661   if (UseSlowPath ||
1662       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1663       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1664     __ jmp(*op-&gt;stub()-&gt;entry());
1665   } else {
1666     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1667     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1668     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1669     if (len == tmp1) {
1670       tmp1 = tmp3;
1671     } else if (len == tmp2) {
1672       tmp2 = tmp3;
1673     } else if (len == tmp3) {
1674       // everything is ok
1675     } else {
1676       __ mov(tmp3, len);
1677     }
1678     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1679                       len,
1680                       tmp1,
1681                       tmp2,
1682                       arrayOopDesc::header_size(op-&gt;type()),
1683                       array_element_size(op-&gt;type()),
1684                       op-&gt;klass()-&gt;as_register(),
1685                       *op-&gt;stub()-&gt;entry());
1686   }
1687   __ bind(*op-&gt;stub()-&gt;continuation());
1688 }
1689 
1690 void LIR_Assembler::type_profile_helper(Register mdo,
1691                                         ciMethodData *md, ciProfileData *data,
1692                                         Register recv, Label* update_done) {
1693   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1694     Label next_test;
1695     // See if the receiver is receiver[n].
1696     __ cmpptr(recv, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1697     __ jccb(Assembler::notEqual, next_test);
1698     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1699     __ addptr(data_addr, DataLayout::counter_increment);
1700     __ jmp(*update_done);
1701     __ bind(next_test);
1702   }
1703 
1704   // Didn&#39;t find receiver; find next empty slot and fill it in
1705   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1706     Label next_test;
1707     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
1708     __ cmpptr(recv_addr, (intptr_t)NULL_WORD);
1709     __ jccb(Assembler::notEqual, next_test);
1710     __ movptr(recv_addr, recv);
1711     __ movptr(Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);
1712     __ jmp(*update_done);
1713     __ bind(next_test);
1714   }
1715 }
1716 
1717 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1718   // we always need a stub for the failure case.
1719   CodeStub* stub = op-&gt;stub();
1720   Register obj = op-&gt;object()-&gt;as_register();
1721   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1722   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1723   Register dst = op-&gt;result_opr()-&gt;as_register();
1724   ciKlass* k = op-&gt;klass();
1725   Register Rtmp1 = noreg;
1726 
1727   // check if it needs to be profiled
1728   ciMethodData* md = NULL;
1729   ciProfileData* data = NULL;
1730 
1731   if (op-&gt;should_profile()) {
1732     ciMethod* method = op-&gt;profiled_method();
1733     assert(method != NULL, &quot;Should have method&quot;);
1734     int bci = op-&gt;profiled_bci();
1735     md = method-&gt;method_data_or_null();
1736     assert(md != NULL, &quot;Sanity&quot;);
1737     data = md-&gt;bci_to_data(bci);
1738     assert(data != NULL,                &quot;need data for type check&quot;);
1739     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1740   }
1741   Label profile_cast_success, profile_cast_failure;
1742   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
1743   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
1744 
1745   if (obj == k_RInfo) {
1746     k_RInfo = dst;
1747   } else if (obj == klass_RInfo) {
1748     klass_RInfo = dst;
1749   }
1750   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1751     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1752   } else {
1753     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1754     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1755   }
1756 
1757   assert_different_registers(obj, k_RInfo, klass_RInfo);
1758 
1759   __ cmpptr(obj, (int32_t)NULL_WORD);
1760   if (op-&gt;should_profile()) {
1761     Label not_null;
1762     __ jccb(Assembler::notEqual, not_null);
1763     // Object is null; update MDO and exit
1764     Register mdo  = klass_RInfo;
1765     __ mov_metadata(mdo, md-&gt;constant_encoding());
1766     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1767     int header_bits = BitData::null_seen_byte_constant();
1768     __ orb(data_addr, header_bits);
1769     __ jmp(*obj_is_null);
1770     __ bind(not_null);
1771   } else {
1772     __ jcc(Assembler::equal, *obj_is_null);
1773   }
1774 
1775   if (!k-&gt;is_loaded()) {
1776     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1777   } else {
1778 #ifdef _LP64
1779     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1780 #endif // _LP64
1781   }
1782   __ verify_oop(obj);
1783 
1784   if (op-&gt;fast_check()) {
1785     // get object class
1786     // not a safepoint as obj null check happens earlier
1787 #ifdef _LP64
1788     if (UseCompressedClassPointers) {
1789       __ load_klass(Rtmp1, obj);
1790       __ cmpptr(k_RInfo, Rtmp1);
1791     } else {
1792       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1793     }
1794 #else
1795     if (k-&gt;is_loaded()) {
1796       __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k-&gt;constant_encoding());
1797     } else {
1798       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1799     }
1800 #endif
1801     __ jcc(Assembler::notEqual, *failure_target);
1802     // successful cast, fall through to profile or jump
1803   } else {
1804     // get object class
1805     // not a safepoint as obj null check happens earlier
1806     __ load_klass(klass_RInfo, obj);
1807     if (k-&gt;is_loaded()) {
1808       // See if we get an immediate positive hit
1809 #ifdef _LP64
1810       __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
1811 #else
1812       __ cmpklass(Address(klass_RInfo, k-&gt;super_check_offset()), k-&gt;constant_encoding());
1813 #endif // _LP64
1814       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1815         __ jcc(Assembler::notEqual, *failure_target);
1816         // successful cast, fall through to profile or jump
1817       } else {
1818         // See if we get an immediate positive hit
1819         __ jcc(Assembler::equal, *success_target);
1820         // check for self
1821 #ifdef _LP64
1822         __ cmpptr(klass_RInfo, k_RInfo);
1823 #else
1824         __ cmpklass(klass_RInfo, k-&gt;constant_encoding());
1825 #endif // _LP64
1826         __ jcc(Assembler::equal, *success_target);
1827 
1828         __ push(klass_RInfo);
1829 #ifdef _LP64
1830         __ push(k_RInfo);
1831 #else
1832         __ pushklass(k-&gt;constant_encoding());
1833 #endif // _LP64
1834         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1835         __ pop(klass_RInfo);
1836         __ pop(klass_RInfo);
1837         // result is a boolean
1838         __ cmpl(klass_RInfo, 0);
1839         __ jcc(Assembler::equal, *failure_target);
1840         // successful cast, fall through to profile or jump
1841       }
1842     } else {
1843       // perform the fast part of the checking logic
1844       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1845       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1846       __ push(klass_RInfo);
1847       __ push(k_RInfo);
1848       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1849       __ pop(klass_RInfo);
1850       __ pop(k_RInfo);
1851       // result is a boolean
1852       __ cmpl(k_RInfo, 0);
1853       __ jcc(Assembler::equal, *failure_target);
1854       // successful cast, fall through to profile or jump
1855     }
1856   }
1857   if (op-&gt;should_profile()) {
1858     Register mdo  = klass_RInfo, recv = k_RInfo;
1859     __ bind(profile_cast_success);
1860     __ mov_metadata(mdo, md-&gt;constant_encoding());
1861     __ load_klass(recv, obj);
1862     type_profile_helper(mdo, md, data, recv, success);
1863     __ jmp(*success);
1864 
1865     __ bind(profile_cast_failure);
1866     __ mov_metadata(mdo, md-&gt;constant_encoding());
1867     Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1868     __ subptr(counter_addr, DataLayout::counter_increment);
1869     __ jmp(*failure);
1870   }
1871   __ jmp(*success);
1872 }
1873 
1874 
1875 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1876   LIR_Code code = op-&gt;code();
1877   if (code == lir_store_check) {
1878     Register value = op-&gt;object()-&gt;as_register();
1879     Register array = op-&gt;array()-&gt;as_register();
1880     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1881     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1882     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1883 
1884     CodeStub* stub = op-&gt;stub();
1885 
1886     // check if it needs to be profiled
1887     ciMethodData* md = NULL;
1888     ciProfileData* data = NULL;
1889 
1890     if (op-&gt;should_profile()) {
1891       ciMethod* method = op-&gt;profiled_method();
1892       assert(method != NULL, &quot;Should have method&quot;);
1893       int bci = op-&gt;profiled_bci();
1894       md = method-&gt;method_data_or_null();
1895       assert(md != NULL, &quot;Sanity&quot;);
1896       data = md-&gt;bci_to_data(bci);
1897       assert(data != NULL,                &quot;need data for type check&quot;);
1898       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1899     }
1900     Label profile_cast_success, profile_cast_failure, done;
1901     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
1902     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
1903 
1904     __ cmpptr(value, (int32_t)NULL_WORD);
1905     if (op-&gt;should_profile()) {
1906       Label not_null;
1907       __ jccb(Assembler::notEqual, not_null);
1908       // Object is null; update MDO and exit
1909       Register mdo  = klass_RInfo;
1910       __ mov_metadata(mdo, md-&gt;constant_encoding());
1911       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1912       int header_bits = BitData::null_seen_byte_constant();
1913       __ orb(data_addr, header_bits);
1914       __ jmp(done);
1915       __ bind(not_null);
1916     } else {
1917       __ jcc(Assembler::equal, done);
1918     }
1919 
1920     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1921     __ load_klass(k_RInfo, array);
1922     __ load_klass(klass_RInfo, value);
1923 
1924     // get instance klass (it&#39;s already uncompressed)
1925     __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1926     // perform the fast part of the checking logic
1927     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1928     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1929     __ push(klass_RInfo);
1930     __ push(k_RInfo);
1931     __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1932     __ pop(klass_RInfo);
1933     __ pop(k_RInfo);
1934     // result is a boolean
1935     __ cmpl(k_RInfo, 0);
1936     __ jcc(Assembler::equal, *failure_target);
1937     // fall through to the success case
1938 
1939     if (op-&gt;should_profile()) {
1940       Register mdo  = klass_RInfo, recv = k_RInfo;
1941       __ bind(profile_cast_success);
1942       __ mov_metadata(mdo, md-&gt;constant_encoding());
1943       __ load_klass(recv, value);
1944       type_profile_helper(mdo, md, data, recv, &amp;done);
1945       __ jmpb(done);
1946 
1947       __ bind(profile_cast_failure);
1948       __ mov_metadata(mdo, md-&gt;constant_encoding());
1949       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1950       __ subptr(counter_addr, DataLayout::counter_increment);
1951       __ jmp(*stub-&gt;entry());
1952     }
1953 
1954     __ bind(done);
1955   } else
1956     if (code == lir_checkcast) {
1957       Register obj = op-&gt;object()-&gt;as_register();
1958       Register dst = op-&gt;result_opr()-&gt;as_register();
1959       Label success;
1960       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1961       __ bind(success);
1962       if (dst != obj) {
1963         __ mov(dst, obj);
1964       }
1965     } else
1966       if (code == lir_instanceof) {
1967         Register obj = op-&gt;object()-&gt;as_register();
1968         Register dst = op-&gt;result_opr()-&gt;as_register();
1969         Label success, failure, done;
1970         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1971         __ bind(failure);
1972         __ xorptr(dst, dst);
1973         __ jmpb(done);
1974         __ bind(success);
1975         __ movptr(dst, 1);
1976         __ bind(done);
1977       } else {
1978         ShouldNotReachHere();
1979       }
1980 
1981 }
1982 
1983 
1984 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1985   if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
1986     assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
1987     assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
1988     assert(op-&gt;new_value()-&gt;as_register_lo() == rbx, &quot;wrong register&quot;);
1989     assert(op-&gt;new_value()-&gt;as_register_hi() == rcx, &quot;wrong register&quot;);
1990     Register addr = op-&gt;addr()-&gt;as_register();
1991     __ lock();
1992     NOT_LP64(__ cmpxchg8(Address(addr, 0)));
1993 
1994   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj ) {
1995     NOT_LP64(assert(op-&gt;addr()-&gt;is_single_cpu(), &quot;must be single&quot;);)
1996     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
1997     Register newval = op-&gt;new_value()-&gt;as_register();
1998     Register cmpval = op-&gt;cmp_value()-&gt;as_register();
1999     assert(cmpval == rax, &quot;wrong register&quot;);
2000     assert(newval != NULL, &quot;new val must be register&quot;);
2001     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2002     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2003     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2004 
2005     if ( op-&gt;code() == lir_cas_obj) {
2006 #ifdef _LP64
2007       if (UseCompressedOops) {
2008         __ encode_heap_oop(cmpval);
2009         __ mov(rscratch1, newval);
2010         __ encode_heap_oop(rscratch1);
2011         __ lock();
2012         // cmpval (rax) is implicitly used by this instruction
2013         __ cmpxchgl(rscratch1, Address(addr, 0));
2014       } else
2015 #endif
2016       {
2017         __ lock();
2018         __ cmpxchgptr(newval, Address(addr, 0));
2019       }
2020     } else {
2021       assert(op-&gt;code() == lir_cas_int, &quot;lir_cas_int expected&quot;);
2022       __ lock();
2023       __ cmpxchgl(newval, Address(addr, 0));
2024     }
2025 #ifdef _LP64
2026   } else if (op-&gt;code() == lir_cas_long) {
2027     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2028     Register newval = op-&gt;new_value()-&gt;as_register_lo();
2029     Register cmpval = op-&gt;cmp_value()-&gt;as_register_lo();
2030     assert(cmpval == rax, &quot;wrong register&quot;);
2031     assert(newval != NULL, &quot;new val must be register&quot;);
2032     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2033     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2034     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2035     __ lock();
2036     __ cmpxchgq(newval, Address(addr, 0));
2037 #endif // _LP64
2038   } else {
2039     Unimplemented();
2040   }
2041 }
2042 
2043 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
2044   Assembler::Condition acond, ncond;
2045   switch (condition) {
2046     case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
2047     case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
2048     case lir_cond_less:         acond = Assembler::less;         ncond = Assembler::greaterEqual; break;
2049     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    ncond = Assembler::greater;      break;
2050     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; ncond = Assembler::less;         break;
2051     case lir_cond_greater:      acond = Assembler::greater;      ncond = Assembler::lessEqual;    break;
2052     case lir_cond_belowEqual:   acond = Assembler::belowEqual;   ncond = Assembler::above;        break;
2053     case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;   ncond = Assembler::below;        break;
2054     default:                    acond = Assembler::equal;        ncond = Assembler::notEqual;
2055                                 ShouldNotReachHere();
2056   }
2057 
2058   if (opr1-&gt;is_cpu_register()) {
2059     reg2reg(opr1, result);
2060   } else if (opr1-&gt;is_stack()) {
2061     stack2reg(opr1, result, result-&gt;type());
2062   } else if (opr1-&gt;is_constant()) {
2063     const2reg(opr1, result, lir_patch_none, NULL);
2064   } else {
2065     ShouldNotReachHere();
2066   }
2067 
2068   if (VM_Version::supports_cmov() &amp;&amp; !opr2-&gt;is_constant()) {
2069     // optimized version that does not require a branch
2070     if (opr2-&gt;is_single_cpu()) {
2071       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
2072       __ cmov(ncond, result-&gt;as_register(), opr2-&gt;as_register());
2073     } else if (opr2-&gt;is_double_cpu()) {
2074       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2075       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2076       __ cmovptr(ncond, result-&gt;as_register_lo(), opr2-&gt;as_register_lo());
2077       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), opr2-&gt;as_register_hi());)
2078     } else if (opr2-&gt;is_single_stack()) {
2079       __ cmovl(ncond, result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2080     } else if (opr2-&gt;is_double_stack()) {
2081       __ cmovptr(ncond, result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), lo_word_offset_in_bytes));
2082       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), hi_word_offset_in_bytes));)
2083     } else {
2084       ShouldNotReachHere();
2085     }
2086 
2087   } else {
2088     Label skip;
2089     __ jcc (acond, skip);
2090     if (opr2-&gt;is_cpu_register()) {
2091       reg2reg(opr2, result);
2092     } else if (opr2-&gt;is_stack()) {
2093       stack2reg(opr2, result, result-&gt;type());
2094     } else if (opr2-&gt;is_constant()) {
2095       const2reg(opr2, result, lir_patch_none, NULL);
2096     } else {
2097       ShouldNotReachHere();
2098     }
2099     __ bind(skip);
2100   }
2101 }
2102 
2103 
2104 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
2105   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
2106 
2107   if (left-&gt;is_single_cpu()) {
2108     assert(left == dest, &quot;left and dest must be equal&quot;);
2109     Register lreg = left-&gt;as_register();
2110 
2111     if (right-&gt;is_single_cpu()) {
2112       // cpu register - cpu register
2113       Register rreg = right-&gt;as_register();
2114       switch (code) {
2115         case lir_add: __ addl (lreg, rreg); break;
2116         case lir_sub: __ subl (lreg, rreg); break;
2117         case lir_mul: __ imull(lreg, rreg); break;
2118         default:      ShouldNotReachHere();
2119       }
2120 
2121     } else if (right-&gt;is_stack()) {
2122       // cpu register - stack
2123       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2124       switch (code) {
2125         case lir_add: __ addl(lreg, raddr); break;
2126         case lir_sub: __ subl(lreg, raddr); break;
2127         default:      ShouldNotReachHere();
2128       }
2129 
2130     } else if (right-&gt;is_constant()) {
2131       // cpu register - constant
2132       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2133       switch (code) {
2134         case lir_add: {
2135           __ incrementl(lreg, c);
2136           break;
2137         }
2138         case lir_sub: {
2139           __ decrementl(lreg, c);
2140           break;
2141         }
2142         default: ShouldNotReachHere();
2143       }
2144 
2145     } else {
2146       ShouldNotReachHere();
2147     }
2148 
2149   } else if (left-&gt;is_double_cpu()) {
2150     assert(left == dest, &quot;left and dest must be equal&quot;);
2151     Register lreg_lo = left-&gt;as_register_lo();
2152     Register lreg_hi = left-&gt;as_register_hi();
2153 
2154     if (right-&gt;is_double_cpu()) {
2155       // cpu register - cpu register
2156       Register rreg_lo = right-&gt;as_register_lo();
2157       Register rreg_hi = right-&gt;as_register_hi();
2158       NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));
2159       LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));
2160       switch (code) {
2161         case lir_add:
2162           __ addptr(lreg_lo, rreg_lo);
2163           NOT_LP64(__ adcl(lreg_hi, rreg_hi));
2164           break;
2165         case lir_sub:
2166           __ subptr(lreg_lo, rreg_lo);
2167           NOT_LP64(__ sbbl(lreg_hi, rreg_hi));
2168           break;
2169         case lir_mul:
2170 #ifdef _LP64
2171           __ imulq(lreg_lo, rreg_lo);
2172 #else
2173           assert(lreg_lo == rax &amp;&amp; lreg_hi == rdx, &quot;must be&quot;);
2174           __ imull(lreg_hi, rreg_lo);
2175           __ imull(rreg_hi, lreg_lo);
2176           __ addl (rreg_hi, lreg_hi);
2177           __ mull (rreg_lo);
2178           __ addl (lreg_hi, rreg_hi);
2179 #endif // _LP64
2180           break;
2181         default:
2182           ShouldNotReachHere();
2183       }
2184 
2185     } else if (right-&gt;is_constant()) {
2186       // cpu register - constant
2187 #ifdef _LP64
2188       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
2189       __ movptr(r10, (intptr_t) c);
2190       switch (code) {
2191         case lir_add:
2192           __ addptr(lreg_lo, r10);
2193           break;
2194         case lir_sub:
2195           __ subptr(lreg_lo, r10);
2196           break;
2197         default:
2198           ShouldNotReachHere();
2199       }
2200 #else
2201       jint c_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2202       jint c_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2203       switch (code) {
2204         case lir_add:
2205           __ addptr(lreg_lo, c_lo);
2206           __ adcl(lreg_hi, c_hi);
2207           break;
2208         case lir_sub:
2209           __ subptr(lreg_lo, c_lo);
2210           __ sbbl(lreg_hi, c_hi);
2211           break;
2212         default:
2213           ShouldNotReachHere();
2214       }
2215 #endif // _LP64
2216 
2217     } else {
2218       ShouldNotReachHere();
2219     }
2220 
2221   } else if (left-&gt;is_single_xmm()) {
2222     assert(left == dest, &quot;left and dest must be equal&quot;);
2223     XMMRegister lreg = left-&gt;as_xmm_float_reg();
2224 
2225     if (right-&gt;is_single_xmm()) {
2226       XMMRegister rreg = right-&gt;as_xmm_float_reg();
2227       switch (code) {
2228         case lir_add: __ addss(lreg, rreg);  break;
2229         case lir_sub: __ subss(lreg, rreg);  break;
2230         case lir_mul_strictfp: // fall through
2231         case lir_mul: __ mulss(lreg, rreg);  break;
2232         case lir_div_strictfp: // fall through
2233         case lir_div: __ divss(lreg, rreg);  break;
2234         default: ShouldNotReachHere();
2235       }
2236     } else {
2237       Address raddr;
2238       if (right-&gt;is_single_stack()) {
2239         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2240       } else if (right-&gt;is_constant()) {
2241         // hack for now
2242         raddr = __ as_Address(InternalAddress(float_constant(right-&gt;as_jfloat())));
2243       } else {
2244         ShouldNotReachHere();
2245       }
2246       switch (code) {
2247         case lir_add: __ addss(lreg, raddr);  break;
2248         case lir_sub: __ subss(lreg, raddr);  break;
2249         case lir_mul_strictfp: // fall through
2250         case lir_mul: __ mulss(lreg, raddr);  break;
2251         case lir_div_strictfp: // fall through
2252         case lir_div: __ divss(lreg, raddr);  break;
2253         default: ShouldNotReachHere();
2254       }
2255     }
2256 
2257   } else if (left-&gt;is_double_xmm()) {
2258     assert(left == dest, &quot;left and dest must be equal&quot;);
2259 
2260     XMMRegister lreg = left-&gt;as_xmm_double_reg();
2261     if (right-&gt;is_double_xmm()) {
2262       XMMRegister rreg = right-&gt;as_xmm_double_reg();
2263       switch (code) {
2264         case lir_add: __ addsd(lreg, rreg);  break;
2265         case lir_sub: __ subsd(lreg, rreg);  break;
2266         case lir_mul_strictfp: // fall through
2267         case lir_mul: __ mulsd(lreg, rreg);  break;
2268         case lir_div_strictfp: // fall through
2269         case lir_div: __ divsd(lreg, rreg);  break;
2270         default: ShouldNotReachHere();
2271       }
2272     } else {
2273       Address raddr;
2274       if (right-&gt;is_double_stack()) {
2275         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2276       } else if (right-&gt;is_constant()) {
2277         // hack for now
2278         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2279       } else {
2280         ShouldNotReachHere();
2281       }
2282       switch (code) {
2283         case lir_add: __ addsd(lreg, raddr);  break;
2284         case lir_sub: __ subsd(lreg, raddr);  break;
2285         case lir_mul_strictfp: // fall through
2286         case lir_mul: __ mulsd(lreg, raddr);  break;
2287         case lir_div_strictfp: // fall through
2288         case lir_div: __ divsd(lreg, raddr);  break;
2289         default: ShouldNotReachHere();
2290       }
2291     }
2292 
2293 #ifndef _LP64
2294   } else if (left-&gt;is_single_fpu()) {
2295     assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
2296 
2297     if (right-&gt;is_single_fpu()) {
2298       arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
2299 
2300     } else {
2301       assert(left-&gt;fpu_regnr() == 0, &quot;left must be on TOS&quot;);
2302       assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be on TOS&quot;);
2303 
2304       Address raddr;
2305       if (right-&gt;is_single_stack()) {
2306         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2307       } else if (right-&gt;is_constant()) {
2308         address const_addr = float_constant(right-&gt;as_jfloat());
2309         assert(const_addr != NULL, &quot;incorrect float/double constant maintainance&quot;);
2310         // hack for now
2311         raddr = __ as_Address(InternalAddress(const_addr));
2312       } else {
2313         ShouldNotReachHere();
2314       }
2315 
2316       switch (code) {
2317         case lir_add: __ fadd_s(raddr); break;
2318         case lir_sub: __ fsub_s(raddr); break;
2319         case lir_mul_strictfp: // fall through
2320         case lir_mul: __ fmul_s(raddr); break;
2321         case lir_div_strictfp: // fall through
2322         case lir_div: __ fdiv_s(raddr); break;
2323         default:      ShouldNotReachHere();
2324       }
2325     }
2326 
2327   } else if (left-&gt;is_double_fpu()) {
2328     assert(dest-&gt;is_double_fpu(),  &quot;fpu stack allocation required&quot;);
2329 
2330     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2331       // Double values require special handling for strictfp mul/div on x86
2332       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
2333       __ fmulp(left-&gt;fpu_regnrLo() + 1);
2334     }
2335 
2336     if (right-&gt;is_double_fpu()) {
2337       arith_fpu_implementation(code, left-&gt;fpu_regnrLo(), right-&gt;fpu_regnrLo(), dest-&gt;fpu_regnrLo(), pop_fpu_stack);
2338 
2339     } else {
2340       assert(left-&gt;fpu_regnrLo() == 0, &quot;left must be on TOS&quot;);
2341       assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be on TOS&quot;);
2342 
2343       Address raddr;
2344       if (right-&gt;is_double_stack()) {
2345         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2346       } else if (right-&gt;is_constant()) {
2347         // hack for now
2348         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2349       } else {
2350         ShouldNotReachHere();
2351       }
2352 
2353       switch (code) {
2354         case lir_add: __ fadd_d(raddr); break;
2355         case lir_sub: __ fsub_d(raddr); break;
2356         case lir_mul_strictfp: // fall through
2357         case lir_mul: __ fmul_d(raddr); break;
2358         case lir_div_strictfp: // fall through
2359         case lir_div: __ fdiv_d(raddr); break;
2360         default: ShouldNotReachHere();
2361       }
2362     }
2363 
2364     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2365       // Double values require special handling for strictfp mul/div on x86
2366       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
2367       __ fmulp(dest-&gt;fpu_regnrLo() + 1);
2368     }
2369 #endif // !_LP64
2370 
2371   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
2372     assert(left == dest, &quot;left and dest must be equal&quot;);
2373 
2374     Address laddr;
2375     if (left-&gt;is_single_stack()) {
2376       laddr = frame_map()-&gt;address_for_slot(left-&gt;single_stack_ix());
2377     } else if (left-&gt;is_address()) {
2378       laddr = as_Address(left-&gt;as_address_ptr());
2379     } else {
2380       ShouldNotReachHere();
2381     }
2382 
2383     if (right-&gt;is_single_cpu()) {
2384       Register rreg = right-&gt;as_register();
2385       switch (code) {
2386         case lir_add: __ addl(laddr, rreg); break;
2387         case lir_sub: __ subl(laddr, rreg); break;
2388         default:      ShouldNotReachHere();
2389       }
2390     } else if (right-&gt;is_constant()) {
2391       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2392       switch (code) {
2393         case lir_add: {
2394           __ incrementl(laddr, c);
2395           break;
2396         }
2397         case lir_sub: {
2398           __ decrementl(laddr, c);
2399           break;
2400         }
2401         default: ShouldNotReachHere();
2402       }
2403     } else {
2404       ShouldNotReachHere();
2405     }
2406 
2407   } else {
2408     ShouldNotReachHere();
2409   }
2410 }
2411 
2412 #ifndef _LP64
2413 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
2414   assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
2415   assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
2416   assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
2417 
2418   bool left_is_tos = (left_index == 0);
2419   bool dest_is_tos = (dest_index == 0);
2420   int non_tos_index = (left_is_tos ? right_index : left_index);
2421 
2422   switch (code) {
2423     case lir_add:
2424       if (pop_fpu_stack)       __ faddp(non_tos_index);
2425       else if (dest_is_tos)    __ fadd (non_tos_index);
2426       else                     __ fadda(non_tos_index);
2427       break;
2428 
2429     case lir_sub:
2430       if (left_is_tos) {
2431         if (pop_fpu_stack)     __ fsubrp(non_tos_index);
2432         else if (dest_is_tos)  __ fsub  (non_tos_index);
2433         else                   __ fsubra(non_tos_index);
2434       } else {
2435         if (pop_fpu_stack)     __ fsubp (non_tos_index);
2436         else if (dest_is_tos)  __ fsubr (non_tos_index);
2437         else                   __ fsuba (non_tos_index);
2438       }
2439       break;
2440 
2441     case lir_mul_strictfp: // fall through
2442     case lir_mul:
2443       if (pop_fpu_stack)       __ fmulp(non_tos_index);
2444       else if (dest_is_tos)    __ fmul (non_tos_index);
2445       else                     __ fmula(non_tos_index);
2446       break;
2447 
2448     case lir_div_strictfp: // fall through
2449     case lir_div:
2450       if (left_is_tos) {
2451         if (pop_fpu_stack)     __ fdivrp(non_tos_index);
2452         else if (dest_is_tos)  __ fdiv  (non_tos_index);
2453         else                   __ fdivra(non_tos_index);
2454       } else {
2455         if (pop_fpu_stack)     __ fdivp (non_tos_index);
2456         else if (dest_is_tos)  __ fdivr (non_tos_index);
2457         else                   __ fdiva (non_tos_index);
2458       }
2459       break;
2460 
2461     case lir_rem:
2462       assert(left_is_tos &amp;&amp; dest_is_tos &amp;&amp; right_index == 1, &quot;must be guaranteed by FPU stack allocation&quot;);
2463       __ fremr(noreg);
2464       break;
2465 
2466     default:
2467       ShouldNotReachHere();
2468   }
2469 }
2470 #endif // _LP64
2471 
2472 
2473 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
2474   if (value-&gt;is_double_xmm()) {
2475     switch(code) {
2476       case lir_abs :
2477         {
2478 #ifdef _LP64
2479           if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
2480             assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
2481             __ vpandn(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg(), 2);
2482           } else
2483 #endif
2484           {
2485             if (dest-&gt;as_xmm_double_reg() != value-&gt;as_xmm_double_reg()) {
2486               __ movdbl(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg());
2487             }
2488             assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
2489             __ andpd(dest-&gt;as_xmm_double_reg(),
2490                      ExternalAddress((address)double_signmask_pool));
2491           }
2492         }
2493         break;
2494 
2495       case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
2496       // all other intrinsics are not available in the SSE instruction set, so FPU is used
2497       default      : ShouldNotReachHere();
2498     }
2499 
2500 #ifndef _LP64
2501   } else if (value-&gt;is_double_fpu()) {
2502     assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
2503     switch(code) {
2504       case lir_abs   : __ fabs() ; break;
2505       case lir_sqrt  : __ fsqrt(); break;
2506       default      : ShouldNotReachHere();
2507     }
2508 #endif // !_LP64
2509   } else {
2510     Unimplemented();
2511   }
2512 }
2513 
2514 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
2515   // assert(left-&gt;destroys_register(), &quot;check&quot;);
2516   if (left-&gt;is_single_cpu()) {
2517     Register reg = left-&gt;as_register();
2518     if (right-&gt;is_constant()) {
2519       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
2520       switch (code) {
2521         case lir_logic_and: __ andl (reg, val); break;
2522         case lir_logic_or:  __ orl  (reg, val); break;
2523         case lir_logic_xor: __ xorl (reg, val); break;
2524         default: ShouldNotReachHere();
2525       }
2526     } else if (right-&gt;is_stack()) {
2527       // added support for stack operands
2528       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2529       switch (code) {
2530         case lir_logic_and: __ andl (reg, raddr); break;
2531         case lir_logic_or:  __ orl  (reg, raddr); break;
2532         case lir_logic_xor: __ xorl (reg, raddr); break;
2533         default: ShouldNotReachHere();
2534       }
2535     } else {
2536       Register rright = right-&gt;as_register();
2537       switch (code) {
2538         case lir_logic_and: __ andptr (reg, rright); break;
2539         case lir_logic_or : __ orptr  (reg, rright); break;
2540         case lir_logic_xor: __ xorptr (reg, rright); break;
2541         default: ShouldNotReachHere();
2542       }
2543     }
2544     move_regs(reg, dst-&gt;as_register());
2545   } else {
2546     Register l_lo = left-&gt;as_register_lo();
2547     Register l_hi = left-&gt;as_register_hi();
2548     if (right-&gt;is_constant()) {
2549 #ifdef _LP64
2550       __ mov64(rscratch1, right-&gt;as_constant_ptr()-&gt;as_jlong());
2551       switch (code) {
2552         case lir_logic_and:
2553           __ andq(l_lo, rscratch1);
2554           break;
2555         case lir_logic_or:
2556           __ orq(l_lo, rscratch1);
2557           break;
2558         case lir_logic_xor:
2559           __ xorq(l_lo, rscratch1);
2560           break;
2561         default: ShouldNotReachHere();
2562       }
2563 #else
2564       int r_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2565       int r_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2566       switch (code) {
2567         case lir_logic_and:
2568           __ andl(l_lo, r_lo);
2569           __ andl(l_hi, r_hi);
2570           break;
2571         case lir_logic_or:
2572           __ orl(l_lo, r_lo);
2573           __ orl(l_hi, r_hi);
2574           break;
2575         case lir_logic_xor:
2576           __ xorl(l_lo, r_lo);
2577           __ xorl(l_hi, r_hi);
2578           break;
2579         default: ShouldNotReachHere();
2580       }
2581 #endif // _LP64
2582     } else {
2583 #ifdef _LP64
2584       Register r_lo;
2585       if (is_reference_type(right-&gt;type())) {
2586         r_lo = right-&gt;as_register();
2587       } else {
2588         r_lo = right-&gt;as_register_lo();
2589       }
2590 #else
2591       Register r_lo = right-&gt;as_register_lo();
2592       Register r_hi = right-&gt;as_register_hi();
2593       assert(l_lo != r_hi, &quot;overwriting registers&quot;);
2594 #endif
2595       switch (code) {
2596         case lir_logic_and:
2597           __ andptr(l_lo, r_lo);
2598           NOT_LP64(__ andptr(l_hi, r_hi);)
2599           break;
2600         case lir_logic_or:
2601           __ orptr(l_lo, r_lo);
2602           NOT_LP64(__ orptr(l_hi, r_hi);)
2603           break;
2604         case lir_logic_xor:
2605           __ xorptr(l_lo, r_lo);
2606           NOT_LP64(__ xorptr(l_hi, r_hi);)
2607           break;
2608         default: ShouldNotReachHere();
2609       }
2610     }
2611 
2612     Register dst_lo = dst-&gt;as_register_lo();
2613     Register dst_hi = dst-&gt;as_register_hi();
2614 
2615 #ifdef _LP64
2616     move_regs(l_lo, dst_lo);
2617 #else
2618     if (dst_lo == l_hi) {
2619       assert(dst_hi != l_lo, &quot;overwriting registers&quot;);
2620       move_regs(l_hi, dst_hi);
2621       move_regs(l_lo, dst_lo);
2622     } else {
2623       assert(dst_lo != l_hi, &quot;overwriting registers&quot;);
2624       move_regs(l_lo, dst_lo);
2625       move_regs(l_hi, dst_hi);
2626     }
2627 #endif // _LP64
2628   }
2629 }
2630 
2631 
2632 // we assume that rax, and rdx can be overwritten
2633 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
2634 
2635   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2636   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2637   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2638 
2639   //  assert(left-&gt;destroys_register(), &quot;check&quot;);
2640   //  assert(right-&gt;destroys_register(), &quot;check&quot;);
2641 
2642   Register lreg = left-&gt;as_register();
2643   Register dreg = result-&gt;as_register();
2644 
2645   if (right-&gt;is_constant()) {
2646     jint divisor = right-&gt;as_constant_ptr()-&gt;as_jint();
2647     assert(divisor &gt; 0 &amp;&amp; is_power_of_2(divisor), &quot;must be&quot;);
2648     if (code == lir_idiv) {
2649       assert(lreg == rax, &quot;must be rax,&quot;);
2650       assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2651       __ cdql(); // sign extend into rdx:rax
2652       if (divisor == 2) {
2653         __ subl(lreg, rdx);
2654       } else {
2655         __ andl(rdx, divisor - 1);
2656         __ addl(lreg, rdx);
2657       }
2658       __ sarl(lreg, log2_jint(divisor));
2659       move_regs(lreg, dreg);
2660     } else if (code == lir_irem) {
2661       Label done;
2662       __ mov(dreg, lreg);
2663       __ andl(dreg, 0x80000000 | (divisor - 1));
2664       __ jcc(Assembler::positive, done);
2665       __ decrement(dreg);
2666       __ orl(dreg, ~(divisor - 1));
2667       __ increment(dreg);
2668       __ bind(done);
2669     } else {
2670       ShouldNotReachHere();
2671     }
2672   } else {
2673     Register rreg = right-&gt;as_register();
2674     assert(lreg == rax, &quot;left register must be rax,&quot;);
2675     assert(rreg != rdx, &quot;right register must not be rdx&quot;);
2676     assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2677 
2678     move_regs(lreg, rax);
2679 
2680     int idivl_offset = __ corrected_idivl(rreg);
2681     if (ImplicitDiv0Checks) {
2682       add_debug_info_for_div0(idivl_offset, info);
2683     }
2684     if (code == lir_irem) {
2685       move_regs(rdx, dreg); // result is in rdx
2686     } else {
2687       move_regs(rax, dreg);
2688     }
2689   }
2690 }
2691 
2692 
2693 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2694   if (opr1-&gt;is_single_cpu()) {
2695     Register reg1 = opr1-&gt;as_register();
2696     if (opr2-&gt;is_single_cpu()) {
2697       // cpu register - cpu register
2698       if (is_reference_type(opr1-&gt;type())) {
2699         __ cmpoop(reg1, opr2-&gt;as_register());
2700       } else {
2701         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2702         __ cmpl(reg1, opr2-&gt;as_register());
2703       }
2704     } else if (opr2-&gt;is_stack()) {
2705       // cpu register - stack
2706       if (is_reference_type(opr1-&gt;type())) {
2707         __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2708       } else {
2709         __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2710       }
2711     } else if (opr2-&gt;is_constant()) {
2712       // cpu register - constant
2713       LIR_Const* c = opr2-&gt;as_constant_ptr();
2714       if (c-&gt;type() == T_INT) {
2715         __ cmpl(reg1, c-&gt;as_jint());
2716       } else if (c-&gt;type() == T_METADATA) {
2717         // All we need for now is a comparison with NULL for equality.
2718         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
2719         Metadata* m = c-&gt;as_metadata();
2720         if (m == NULL) {
2721           __ cmpptr(reg1, (int32_t)0);
2722         } else {
2723           ShouldNotReachHere();
2724         }
2725       } else if (is_reference_type(c-&gt;type())) {
2726         // In 64bit oops are single register
2727         jobject o = c-&gt;as_jobject();
2728         if (o == NULL) {
2729           __ cmpptr(reg1, (int32_t)NULL_WORD);
2730         } else {
2731           __ cmpoop(reg1, o);
2732         }
2733       } else {
2734         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
2735       }
2736       // cpu register - address
2737     } else if (opr2-&gt;is_address()) {
2738       if (op-&gt;info() != NULL) {
2739         add_debug_info_for_null_check_here(op-&gt;info());
2740       }
2741       __ cmpl(reg1, as_Address(opr2-&gt;as_address_ptr()));
2742     } else {
2743       ShouldNotReachHere();
2744     }
2745 
2746   } else if(opr1-&gt;is_double_cpu()) {
2747     Register xlo = opr1-&gt;as_register_lo();
2748     Register xhi = opr1-&gt;as_register_hi();
2749     if (opr2-&gt;is_double_cpu()) {
2750 #ifdef _LP64
2751       __ cmpptr(xlo, opr2-&gt;as_register_lo());
2752 #else
2753       // cpu register - cpu register
2754       Register ylo = opr2-&gt;as_register_lo();
2755       Register yhi = opr2-&gt;as_register_hi();
2756       __ subl(xlo, ylo);
2757       __ sbbl(xhi, yhi);
2758       if (condition == lir_cond_equal || condition == lir_cond_notEqual) {
2759         __ orl(xhi, xlo);
2760       }
2761 #endif // _LP64
2762     } else if (opr2-&gt;is_constant()) {
2763       // cpu register - constant 0
2764       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
2765 #ifdef _LP64
2766       __ cmpptr(xlo, (int32_t)opr2-&gt;as_jlong());
2767 #else
2768       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles equals case&quot;);
2769       __ orl(xhi, xlo);
2770 #endif // _LP64
2771     } else {
2772       ShouldNotReachHere();
2773     }
2774 
2775   } else if (opr1-&gt;is_single_xmm()) {
2776     XMMRegister reg1 = opr1-&gt;as_xmm_float_reg();
2777     if (opr2-&gt;is_single_xmm()) {
2778       // xmm register - xmm register
2779       __ ucomiss(reg1, opr2-&gt;as_xmm_float_reg());
2780     } else if (opr2-&gt;is_stack()) {
2781       // xmm register - stack
2782       __ ucomiss(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2783     } else if (opr2-&gt;is_constant()) {
2784       // xmm register - constant
2785       __ ucomiss(reg1, InternalAddress(float_constant(opr2-&gt;as_jfloat())));
2786     } else if (opr2-&gt;is_address()) {
2787       // xmm register - address
2788       if (op-&gt;info() != NULL) {
2789         add_debug_info_for_null_check_here(op-&gt;info());
2790       }
2791       __ ucomiss(reg1, as_Address(opr2-&gt;as_address_ptr()));
2792     } else {
2793       ShouldNotReachHere();
2794     }
2795 
2796   } else if (opr1-&gt;is_double_xmm()) {
2797     XMMRegister reg1 = opr1-&gt;as_xmm_double_reg();
2798     if (opr2-&gt;is_double_xmm()) {
2799       // xmm register - xmm register
2800       __ ucomisd(reg1, opr2-&gt;as_xmm_double_reg());
2801     } else if (opr2-&gt;is_stack()) {
2802       // xmm register - stack
2803       __ ucomisd(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()));
2804     } else if (opr2-&gt;is_constant()) {
2805       // xmm register - constant
2806       __ ucomisd(reg1, InternalAddress(double_constant(opr2-&gt;as_jdouble())));
2807     } else if (opr2-&gt;is_address()) {
2808       // xmm register - address
2809       if (op-&gt;info() != NULL) {
2810         add_debug_info_for_null_check_here(op-&gt;info());
2811       }
2812       __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
2813     } else {
2814       ShouldNotReachHere();
2815     }
2816 
2817 #ifndef _LP64
2818   } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
2819     assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
2820     assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
2821     __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2822 #endif // LP64
2823 
2824   } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
2825     LIR_Const* c = opr2-&gt;as_constant_ptr();
2826 #ifdef _LP64
2827     if (is_reference_type(c-&gt;type())) {
2828       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
2829       __ movoop(rscratch1, c-&gt;as_jobject());
2830     }
2831 #endif // LP64
2832     if (op-&gt;info() != NULL) {
2833       add_debug_info_for_null_check_here(op-&gt;info());
2834     }
2835     // special case: address - constant
2836     LIR_Address* addr = opr1-&gt;as_address_ptr();
2837     if (c-&gt;type() == T_INT) {
2838       __ cmpl(as_Address(addr), c-&gt;as_jint());
2839     } else if (is_reference_type(c-&gt;type())) {
2840 #ifdef _LP64
2841       // %%% Make this explode if addr isn&#39;t reachable until we figure out a
2842       // better strategy by giving noreg as the temp for as_Address
2843       __ cmpoop(rscratch1, as_Address(addr, noreg));
2844 #else
2845       __ cmpoop(as_Address(addr), c-&gt;as_jobject());
2846 #endif // _LP64
2847     } else {
2848       ShouldNotReachHere();
2849     }
2850 
2851   } else {
2852     ShouldNotReachHere();
2853   }
2854 }
2855 
2856 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
2857   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2858     if (left-&gt;is_single_xmm()) {
2859       assert(right-&gt;is_single_xmm(), &quot;must match&quot;);
2860       __ cmpss2int(left-&gt;as_xmm_float_reg(), right-&gt;as_xmm_float_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2861     } else if (left-&gt;is_double_xmm()) {
2862       assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
2863       __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2864 
2865     } else {
2866 #ifdef _LP64
2867       ShouldNotReachHere();
2868 #else
2869       assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
2870       assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
2871 
2872       assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
2873       __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
2874                   op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2875 #endif // LP64
2876     }
2877   } else {
2878     assert(code == lir_cmp_l2i, &quot;check&quot;);
2879 #ifdef _LP64
2880     Label done;
2881     Register dest = dst-&gt;as_register();
2882     __ cmpptr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2883     __ movl(dest, -1);
2884     __ jccb(Assembler::less, done);
2885     __ set_byte_if_not_zero(dest);
2886     __ movzbl(dest, dest);
2887     __ bind(done);
2888 #else
2889     __ lcmp2int(left-&gt;as_register_hi(),
2890                 left-&gt;as_register_lo(),
2891                 right-&gt;as_register_hi(),
2892                 right-&gt;as_register_lo());
2893     move_regs(left-&gt;as_register_hi(), dst-&gt;as_register());
2894 #endif // _LP64
2895   }
2896 }
2897 
2898 
2899 void LIR_Assembler::align_call(LIR_Code code) {
2900   // make sure that the displacement word of the call ends up word aligned
2901   int offset = __ offset();
2902   switch (code) {
2903   case lir_static_call:
2904   case lir_optvirtual_call:
2905   case lir_dynamic_call:
2906     offset += NativeCall::displacement_offset;
2907     break;
2908   case lir_icvirtual_call:
2909     offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;
2910     break;
2911   case lir_virtual_call:  // currently, sparc-specific for niagara
2912   default: ShouldNotReachHere();
2913   }
2914   __ align(BytesPerWord, offset);
2915 }
2916 
2917 
2918 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2919   assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
2920          &quot;must be aligned&quot;);
2921   __ call(AddressLiteral(op-&gt;addr(), rtype));
2922   add_call_info(code_offset(), op-&gt;info());
2923 }
2924 
2925 
2926 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2927   __ ic_call(op-&gt;addr());
2928   add_call_info(code_offset(), op-&gt;info());
2929   assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
2930          &quot;must be aligned&quot;);
2931 }
2932 
2933 
2934 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2935 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2936   ShouldNotReachHere();
2937 }
2938 
2939 
2940 void LIR_Assembler::emit_static_call_stub() {
2941   address call_pc = __ pc();
2942   address stub = __ start_a_stub(call_stub_size());
2943   if (stub == NULL) {
2944     bailout(&quot;static call stub overflow&quot;);
2945     return;
2946   }
2947 
2948   int start = __ offset();
2949 
2950   // make sure that the displacement word of the call ends up word aligned
2951   __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);
2952   __ relocate(static_stub_Relocation::spec(call_pc, false /* is_aot */));
2953   __ mov_metadata(rbx, (Metadata*)NULL);
2954   // must be set to -1 at code generation time
2955   assert(((__ offset() + 1) % BytesPerWord) == 0, &quot;must be aligned&quot;);
2956   // On 64bit this will die since it will take a movq &amp; jmp, must be only a jmp
2957   __ jump(RuntimeAddress(__ pc()));
2958 
2959   if (UseAOT) {
2960     // Trampoline to aot code
2961     __ relocate(static_stub_Relocation::spec(call_pc, true /* is_aot */));
2962 #ifdef _LP64
2963     __ mov64(rax, CONST64(0));  // address is zapped till fixup time.
2964 #else
2965     __ movl(rax, 0xdeadffff);  // address is zapped till fixup time.
2966 #endif
2967     __ jmp(rax);
2968   }
2969   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
2970   __ end_a_stub();
2971 }
2972 
2973 
2974 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2975   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
2976   assert(exceptionPC-&gt;as_register() == rdx, &quot;must match&quot;);
2977 
2978   // exception object is not added to oop map by LinearScan
2979   // (LinearScan assumes that no oops are in fixed registers)
2980   info-&gt;add_register_oop(exceptionOop);
2981   Runtime1::StubID unwind_id;
2982 
2983   // get current pc information
2984   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2985   int pc_for_athrow_offset = __ offset();
2986   InternalAddress pc_for_athrow(__ pc());
2987   __ lea(exceptionPC-&gt;as_register(), pc_for_athrow);
2988   add_call_info(pc_for_athrow_offset, info); // for exception handler
2989 
2990   __ verify_not_null_oop(rax);
2991   // search an exception handler (rax: exception oop, rdx: throwing pc)
2992   if (compilation()-&gt;has_fpu_code()) {
2993     unwind_id = Runtime1::handle_exception_id;
2994   } else {
2995     unwind_id = Runtime1::handle_exception_nofpu_id;
2996   }
2997   __ call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2998 
2999   // enough room for two byte trap
3000   __ nop();
3001 }
3002 
3003 
3004 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
3005   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3006 
3007   __ jmp(_unwind_handler_entry);
3008 }
3009 
3010 
3011 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
3012 
3013   // optimized version for linear scan:
3014   // * count must be already in ECX (guaranteed by LinearScan)
3015   // * left and dest must be equal
3016   // * tmp must be unused
3017   assert(count-&gt;as_register() == SHIFT_count, &quot;count must be in ECX&quot;);
3018   assert(left == dest, &quot;left and dest must be equal&quot;);
3019   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3020 
3021   if (left-&gt;is_single_cpu()) {
3022     Register value = left-&gt;as_register();
3023     assert(value != SHIFT_count, &quot;left cannot be ECX&quot;);
3024 
3025     switch (code) {
3026       case lir_shl:  __ shll(value); break;
3027       case lir_shr:  __ sarl(value); break;
3028       case lir_ushr: __ shrl(value); break;
3029       default: ShouldNotReachHere();
3030     }
3031   } else if (left-&gt;is_double_cpu()) {
3032     Register lo = left-&gt;as_register_lo();
3033     Register hi = left-&gt;as_register_hi();
3034     assert(lo != SHIFT_count &amp;&amp; hi != SHIFT_count, &quot;left cannot be ECX&quot;);
3035 #ifdef _LP64
3036     switch (code) {
3037       case lir_shl:  __ shlptr(lo);        break;
3038       case lir_shr:  __ sarptr(lo);        break;
3039       case lir_ushr: __ shrptr(lo);        break;
3040       default: ShouldNotReachHere();
3041     }
3042 #else
3043 
3044     switch (code) {
3045       case lir_shl:  __ lshl(hi, lo);        break;
3046       case lir_shr:  __ lshr(hi, lo, true);  break;
3047       case lir_ushr: __ lshr(hi, lo, false); break;
3048       default: ShouldNotReachHere();
3049     }
3050 #endif // LP64
3051   } else {
3052     ShouldNotReachHere();
3053   }
3054 }
3055 
3056 
3057 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
3058   if (dest-&gt;is_single_cpu()) {
3059     // first move left into dest so that left is not destroyed by the shift
3060     Register value = dest-&gt;as_register();
3061     count = count &amp; 0x1F; // Java spec
3062 
3063     move_regs(left-&gt;as_register(), value);
3064     switch (code) {
3065       case lir_shl:  __ shll(value, count); break;
3066       case lir_shr:  __ sarl(value, count); break;
3067       case lir_ushr: __ shrl(value, count); break;
3068       default: ShouldNotReachHere();
3069     }
3070   } else if (dest-&gt;is_double_cpu()) {
3071 #ifndef _LP64
3072     Unimplemented();
3073 #else
3074     // first move left into dest so that left is not destroyed by the shift
3075     Register value = dest-&gt;as_register_lo();
3076     count = count &amp; 0x1F; // Java spec
3077 
3078     move_regs(left-&gt;as_register_lo(), value);
3079     switch (code) {
3080       case lir_shl:  __ shlptr(value, count); break;
3081       case lir_shr:  __ sarptr(value, count); break;
3082       case lir_ushr: __ shrptr(value, count); break;
3083       default: ShouldNotReachHere();
3084     }
3085 #endif // _LP64
3086   } else {
3087     ShouldNotReachHere();
3088   }
3089 }
3090 
3091 
3092 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
3093   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3094   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3095   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3096   __ movptr (Address(rsp, offset_from_rsp_in_bytes), r);
3097 }
3098 
3099 
3100 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
3101   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3102   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3103   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3104   __ movptr (Address(rsp, offset_from_rsp_in_bytes), c);
3105 }
3106 
3107 
3108 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
3109   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3110   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3111   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3112   __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);
3113 }
3114 
3115 
3116 void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {
3117   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3118   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3119   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3120   __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
3121 }
3122 
3123 
3124 // This code replaces a call to arraycopy; no exception may
3125 // be thrown in this code, they must be thrown in the System.arraycopy
3126 // activation frame; we could save some checks if this would not be the case
3127 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
3128   ciArrayKlass* default_type = op-&gt;expected_type();
3129   Register src = op-&gt;src()-&gt;as_register();
3130   Register dst = op-&gt;dst()-&gt;as_register();
3131   Register src_pos = op-&gt;src_pos()-&gt;as_register();
3132   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
3133   Register length  = op-&gt;length()-&gt;as_register();
3134   Register tmp = op-&gt;tmp()-&gt;as_register();
3135 
3136   __ resolve(ACCESS_READ, src);
3137   __ resolve(ACCESS_WRITE, dst);
3138 
3139   CodeStub* stub = op-&gt;stub();
3140   int flags = op-&gt;flags();
3141   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
3142   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3143 
3144   // if we don&#39;t know anything, just go through the generic arraycopy
3145   if (default_type == NULL) {
3146     // save outgoing arguments on stack in case call to System.arraycopy is needed
3147     // HACK ALERT. This code used to push the parameters in a hardwired fashion
3148     // for interpreter calling conventions. Now we have to do it in new style conventions.
3149     // For the moment until C1 gets the new register allocator I just force all the
3150     // args to the right place (except the register args) and then on the back side
3151     // reload the register args properly if we go slow path. Yuck
3152 
3153     // These are proper for the calling convention
3154     store_parameter(length, 2);
3155     store_parameter(dst_pos, 1);
3156     store_parameter(dst, 0);
3157 
3158     // these are just temporary placements until we need to reload
3159     store_parameter(src_pos, 3);
3160     store_parameter(src, 4);
3161     NOT_LP64(assert(src == rcx &amp;&amp; src_pos == rdx, &quot;mismatch in calling convention&quot;);)
3162 
3163     address copyfunc_addr = StubRoutines::generic_arraycopy();
3164     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
3165 
3166     // pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint
3167 #ifdef _LP64
3168     // The arguments are in java calling convention so we can trivially shift them to C
3169     // convention
3170     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
3171     __ mov(c_rarg0, j_rarg0);
3172     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
3173     __ mov(c_rarg1, j_rarg1);
3174     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
3175     __ mov(c_rarg2, j_rarg2);
3176     assert_different_registers(c_rarg3, j_rarg4);
3177     __ mov(c_rarg3, j_rarg3);
3178 #ifdef _WIN64
3179     // Allocate abi space for args but be sure to keep stack aligned
3180     __ subptr(rsp, 6*wordSize);
3181     store_parameter(j_rarg4, 4);
3182 #ifndef PRODUCT
3183     if (PrintC1Statistics) {
3184       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3185     }
3186 #endif
3187     __ call(RuntimeAddress(copyfunc_addr));
3188     __ addptr(rsp, 6*wordSize);
3189 #else
3190     __ mov(c_rarg4, j_rarg4);
3191 #ifndef PRODUCT
3192     if (PrintC1Statistics) {
3193       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3194     }
3195 #endif
3196     __ call(RuntimeAddress(copyfunc_addr));
3197 #endif // _WIN64
3198 #else
3199     __ push(length);
3200     __ push(dst_pos);
3201     __ push(dst);
3202     __ push(src_pos);
3203     __ push(src);
3204 
3205 #ifndef PRODUCT
3206     if (PrintC1Statistics) {
3207       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3208     }
3209 #endif
3210     __ call_VM_leaf(copyfunc_addr, 5); // removes pushed parameter from the stack
3211 
3212 #endif // _LP64
3213 
3214     __ cmpl(rax, 0);
3215     __ jcc(Assembler::equal, *stub-&gt;continuation());
3216 
3217     __ mov(tmp, rax);
3218     __ xorl(tmp, -1);
3219 
3220     // Reload values from the stack so they are where the stub
3221     // expects them.
3222     __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3223     __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3224     __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3225     __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3226     __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3227 
3228     __ subl(length, tmp);
3229     __ addl(src_pos, tmp);
3230     __ addl(dst_pos, tmp);
3231     __ jmp(*stub-&gt;entry());
3232 
3233     __ bind(*stub-&gt;continuation());
3234     return;
3235   }
3236 
3237   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
3238 
3239   int elem_size = type2aelembytes(basic_type);
3240   Address::ScaleFactor scale;
3241 
3242   switch (elem_size) {
3243     case 1 :
3244       scale = Address::times_1;
3245       break;
3246     case 2 :
3247       scale = Address::times_2;
3248       break;
3249     case 4 :
3250       scale = Address::times_4;
3251       break;
3252     case 8 :
3253       scale = Address::times_8;
3254       break;
3255     default:
3256       scale = Address::no_scale;
3257       ShouldNotReachHere();
3258   }
3259 
3260   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
3261   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
3262   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
3263   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
3264 
3265   // length and pos&#39;s are all sign extended at this point on 64bit
3266 
3267   // test for NULL
3268   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
3269     __ testptr(src, src);
3270     __ jcc(Assembler::zero, *stub-&gt;entry());
3271   }
3272   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
3273     __ testptr(dst, dst);
3274     __ jcc(Assembler::zero, *stub-&gt;entry());
3275   }
3276 
3277   // If the compiler was not able to prove that exact type of the source or the destination
3278   // of the arraycopy is an array type, check at runtime if the source or the destination is
3279   // an instance type.
3280   if (flags &amp; LIR_OpArrayCopy::type_check) {
3281     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3282       __ load_klass(tmp, dst);
3283       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3284       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3285     }
3286 
3287     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3288       __ load_klass(tmp, src);
3289       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3290       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3291     }
3292   }
3293 
3294   // check if negative
3295   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
3296     __ testl(src_pos, src_pos);
3297     __ jcc(Assembler::less, *stub-&gt;entry());
3298   }
3299   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
3300     __ testl(dst_pos, dst_pos);
3301     __ jcc(Assembler::less, *stub-&gt;entry());
3302   }
3303 
3304   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
3305     __ lea(tmp, Address(src_pos, length, Address::times_1, 0));
3306     __ cmpl(tmp, src_length_addr);
3307     __ jcc(Assembler::above, *stub-&gt;entry());
3308   }
3309   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
3310     __ lea(tmp, Address(dst_pos, length, Address::times_1, 0));
3311     __ cmpl(tmp, dst_length_addr);
3312     __ jcc(Assembler::above, *stub-&gt;entry());
3313   }
3314 
3315   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
3316     __ testl(length, length);
3317     __ jcc(Assembler::less, *stub-&gt;entry());
3318   }
3319 
3320 #ifdef _LP64
3321   __ movl2ptr(src_pos, src_pos); //higher 32bits must be null
3322   __ movl2ptr(dst_pos, dst_pos); //higher 32bits must be null
3323 #endif
3324 
3325   if (flags &amp; LIR_OpArrayCopy::type_check) {
3326     // We don&#39;t know the array types are compatible
3327     if (basic_type != T_OBJECT) {
3328       // Simple test for basic type arrays
3329       if (UseCompressedClassPointers) {
3330         __ movl(tmp, src_klass_addr);
3331         __ cmpl(tmp, dst_klass_addr);
3332       } else {
3333         __ movptr(tmp, src_klass_addr);
3334         __ cmpptr(tmp, dst_klass_addr);
3335       }
3336       __ jcc(Assembler::notEqual, *stub-&gt;entry());
3337     } else {
3338       // For object arrays, if src is a sub class of dst then we can
3339       // safely do the copy.
3340       Label cont, slow;
3341 
3342       __ push(src);
3343       __ push(dst);
3344 
3345       __ load_klass(src, src);
3346       __ load_klass(dst, dst);
3347 
3348       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
3349 
3350       __ push(src);
3351       __ push(dst);
3352       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
3353       __ pop(dst);
3354       __ pop(src);
3355 
3356       __ cmpl(src, 0);
3357       __ jcc(Assembler::notEqual, cont);
3358 
3359       __ bind(slow);
3360       __ pop(dst);
3361       __ pop(src);
3362 
3363       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
3364       if (copyfunc_addr != NULL) { // use stub if available
3365         // src is not a sub class of dst so we have to do a
3366         // per-element check.
3367 
3368         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
3369         if ((flags &amp; mask) != mask) {
3370           // Check that at least both of them object arrays.
3371           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
3372 
3373           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3374             __ load_klass(tmp, src);
3375           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3376             __ load_klass(tmp, dst);
3377           }
3378           int lh_offset = in_bytes(Klass::layout_helper_offset());
3379           Address klass_lh_addr(tmp, lh_offset);
3380           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
3381           __ cmpl(klass_lh_addr, objArray_lh);
3382           __ jcc(Assembler::notEqual, *stub-&gt;entry());
3383         }
3384 
3385        // Spill because stubs can use any register they like and it&#39;s
3386        // easier to restore just those that we care about.
3387        store_parameter(dst, 0);
3388        store_parameter(dst_pos, 1);
3389        store_parameter(length, 2);
3390        store_parameter(src_pos, 3);
3391        store_parameter(src, 4);
3392 
3393 #ifndef _LP64
3394         __ movptr(tmp, dst_klass_addr);
3395         __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));
3396         __ push(tmp);
3397         __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));
3398         __ push(tmp);
3399         __ push(length);
3400         __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3401         __ push(tmp);
3402         __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3403         __ push(tmp);
3404 
3405         __ call_VM_leaf(copyfunc_addr, 5);
3406 #else
3407         __ movl2ptr(length, length); //higher 32bits must be null
3408 
3409         __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3410         assert_different_registers(c_rarg0, dst, dst_pos, length);
3411         __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3412         assert_different_registers(c_rarg1, dst, length);
3413 
3414         __ mov(c_rarg2, length);
3415         assert_different_registers(c_rarg2, dst);
3416 
3417 #ifdef _WIN64
3418         // Allocate abi space for args but be sure to keep stack aligned
3419         __ subptr(rsp, 6*wordSize);
3420         __ load_klass(c_rarg3, dst);
3421         __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
3422         store_parameter(c_rarg3, 4);
3423         __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
3424         __ call(RuntimeAddress(copyfunc_addr));
3425         __ addptr(rsp, 6*wordSize);
3426 #else
3427         __ load_klass(c_rarg4, dst);
3428         __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
3429         __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
3430         __ call(RuntimeAddress(copyfunc_addr));
3431 #endif
3432 
3433 #endif
3434 
3435 #ifndef PRODUCT
3436         if (PrintC1Statistics) {
3437           Label failed;
3438           __ testl(rax, rax);
3439           __ jcc(Assembler::notZero, failed);
3440           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
3441           __ bind(failed);
3442         }
3443 #endif
3444 
3445         __ testl(rax, rax);
3446         __ jcc(Assembler::zero, *stub-&gt;continuation());
3447 
3448 #ifndef PRODUCT
3449         if (PrintC1Statistics) {
3450           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
3451         }
3452 #endif
3453 
3454         __ mov(tmp, rax);
3455 
3456         __ xorl(tmp, -1);
3457 
3458         // Restore previously spilled arguments
3459         __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3460         __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3461         __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3462         __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3463         __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3464 
3465 
3466         __ subl(length, tmp);
3467         __ addl(src_pos, tmp);
3468         __ addl(dst_pos, tmp);
3469       }
3470 
3471       __ jmp(*stub-&gt;entry());
3472 
3473       __ bind(cont);
3474       __ pop(dst);
3475       __ pop(src);
3476     }
3477   }
3478 
3479 #ifdef ASSERT
3480   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
3481     // Sanity check the known type with the incoming class.  For the
3482     // primitive case the types must match exactly with src.klass and
3483     // dst.klass each exactly matching the default type.  For the
3484     // object array case, if no type check is needed then either the
3485     // dst type is exactly the expected type and the src type is a
3486     // subtype which we can&#39;t check or src is the same array as dst
3487     // but not necessarily exactly of type default_type.
3488     Label known_ok, halt;
3489     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
3490 #ifdef _LP64
3491     if (UseCompressedClassPointers) {
3492       __ encode_klass_not_null(tmp);
3493     }
3494 #endif
3495 
3496     if (basic_type != T_OBJECT) {
3497 
3498       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3499       else                   __ cmpptr(tmp, dst_klass_addr);
3500       __ jcc(Assembler::notEqual, halt);
3501       if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);
3502       else                   __ cmpptr(tmp, src_klass_addr);
3503       __ jcc(Assembler::equal, known_ok);
3504     } else {
3505       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3506       else                   __ cmpptr(tmp, dst_klass_addr);
3507       __ jcc(Assembler::equal, known_ok);
3508       __ cmpptr(src, dst);
3509       __ jcc(Assembler::equal, known_ok);
3510     }
3511     __ bind(halt);
3512     __ stop(&quot;incorrect type information in arraycopy&quot;);
3513     __ bind(known_ok);
3514   }
3515 #endif
3516 
3517 #ifndef PRODUCT
3518   if (PrintC1Statistics) {
3519     __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
3520   }
3521 #endif
3522 
3523 #ifdef _LP64
3524   assert_different_registers(c_rarg0, dst, dst_pos, length);
3525   __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3526   assert_different_registers(c_rarg1, length);
3527   __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3528   __ mov(c_rarg2, length);
3529 
3530 #else
3531   __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3532   store_parameter(tmp, 0);
3533   __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3534   store_parameter(tmp, 1);
3535   store_parameter(length, 2);
3536 #endif // _LP64
3537 
3538   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
3539   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
3540   const char *name;
3541   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
3542   __ call_VM_leaf(entry, 0);
3543 
3544   __ bind(*stub-&gt;continuation());
3545 }
3546 
3547 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3548   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
3549   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
3550   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3551   Register crc = op-&gt;crc()-&gt;as_register();
3552   Register val = op-&gt;val()-&gt;as_register();
3553   Register res = op-&gt;result_opr()-&gt;as_register();
3554 
3555   assert_different_registers(val, crc, res);
3556 
3557   __ lea(res, ExternalAddress(StubRoutines::crc_table_addr()));
3558   __ notl(crc); // ~crc
3559   __ update_byte_crc32(crc, val, res);
3560   __ notl(crc); // ~crc
3561   __ mov(res, crc);
3562 }
3563 
3564 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
3565   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
3566   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
3567   Register lock = op-&gt;lock_opr()-&gt;as_register();
3568   if (!UseFastLocking) {
3569     __ jmp(*op-&gt;stub()-&gt;entry());
3570   } else if (op-&gt;code() == lir_lock) {
3571     Register scratch = noreg;
3572     if (UseBiasedLocking) {
3573       scratch = op-&gt;scratch_opr()-&gt;as_register();
3574     }
3575     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3576     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
3577     // add debug info for NullPointerException only if one is possible
3578     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
3579     if (op-&gt;info() != NULL) {
3580       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
3581     }
3582     // done
3583   } else if (op-&gt;code() == lir_unlock) {
3584     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3585     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
3586   } else {
3587     Unimplemented();
3588   }
3589   __ bind(*op-&gt;stub()-&gt;continuation());
3590 }
3591 
3592 
3593 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
3594   ciMethod* method = op-&gt;profiled_method();
3595   int bci          = op-&gt;profiled_bci();
3596   ciMethod* callee = op-&gt;profiled_callee();
3597 
3598   // Update counter for all call types
3599   ciMethodData* md = method-&gt;method_data_or_null();
3600   assert(md != NULL, &quot;Sanity&quot;);
3601   ciProfileData* data = md-&gt;bci_to_data(bci);
3602   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
3603   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
3604   Register mdo  = op-&gt;mdo()-&gt;as_register();
3605   __ mov_metadata(mdo, md-&gt;constant_encoding());
3606   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
3607   // Perform additional virtual call profiling for invokevirtual and
3608   // invokeinterface bytecodes
3609   if (op-&gt;should_profile_receiver_type()) {
3610     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
3611     Register recv = op-&gt;recv()-&gt;as_register();
3612     assert_different_registers(mdo, recv);
3613     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
3614     ciKlass* known_klass = op-&gt;known_holder();
3615     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
3616       // We know the type that will be seen at this call site; we can
3617       // statically update the MethodData* rather than needing to do
3618       // dynamic tests on the receiver type
3619 
3620       // NOTE: we should probably put a lock around this search to
3621       // avoid collisions by concurrent compilations
3622       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
3623       uint i;
3624       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3625         ciKlass* receiver = vc_data-&gt;receiver(i);
3626         if (known_klass-&gt;equals(receiver)) {
3627           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3628           __ addptr(data_addr, DataLayout::counter_increment);
3629           return;
3630         }
3631       }
3632 
3633       // Receiver type not found in profile data; select an empty slot
3634 
3635       // Note that this is less efficient than it should be because it
3636       // always does a write to the receiver part of the
3637       // VirtualCallData rather than just the first time
3638       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3639         ciKlass* receiver = vc_data-&gt;receiver(i);
3640         if (receiver == NULL) {
3641           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
3642           __ mov_metadata(recv_addr, known_klass-&gt;constant_encoding());
3643           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3644           __ addptr(data_addr, DataLayout::counter_increment);
3645           return;
3646         }
3647       }
3648     } else {
3649       __ load_klass(recv, recv);
3650       Label update_done;
3651       type_profile_helper(mdo, md, data, recv, &amp;update_done);
3652       // Receiver did not match any saved receiver and there is no empty row for it.
3653       // Increment total counter to indicate polymorphic case.
3654       __ addptr(counter_addr, DataLayout::counter_increment);
3655 
3656       __ bind(update_done);
3657     }
3658   } else {
3659     // Static call
3660     __ addptr(counter_addr, DataLayout::counter_increment);
3661   }
3662 }
3663 
3664 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3665   Register obj = op-&gt;obj()-&gt;as_register();
3666   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3667   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
3668   ciKlass* exact_klass = op-&gt;exact_klass();
3669   intptr_t current_klass = op-&gt;current_klass();
3670   bool not_null = op-&gt;not_null();
3671   bool no_conflict = op-&gt;no_conflict();
3672 
3673   Label update, next, none;
3674 
3675   bool do_null = !not_null;
3676   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3677   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3678 
3679   assert(do_null || do_update, &quot;why are we here?&quot;);
3680   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3681 
3682   __ verify_oop(obj);
3683 
3684   if (tmp != obj) {
3685     __ mov(tmp, obj);
3686   }
3687   if (do_null) {
3688     __ testptr(tmp, tmp);
3689     __ jccb(Assembler::notZero, update);
3690     if (!TypeEntries::was_null_seen(current_klass)) {
3691       __ orptr(mdo_addr, TypeEntries::null_seen);
3692     }
3693     if (do_update) {
3694 #ifndef ASSERT
3695       __ jmpb(next);
3696     }
3697 #else
3698       __ jmp(next);
3699     }
3700   } else {
3701     __ testptr(tmp, tmp);
3702     __ jcc(Assembler::notZero, update);
3703     __ stop(&quot;unexpect null obj&quot;);
3704 #endif
3705   }
3706 
3707   __ bind(update);
3708 
3709   if (do_update) {
3710 #ifdef ASSERT
3711     if (exact_klass != NULL) {
3712       Label ok;
3713       __ load_klass(tmp, tmp);
3714       __ push(tmp);
3715       __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3716       __ cmpptr(tmp, Address(rsp, 0));
3717       __ jcc(Assembler::equal, ok);
3718       __ stop(&quot;exact klass and actual klass differ&quot;);
3719       __ bind(ok);
3720       __ pop(tmp);
3721     }
3722 #endif
3723     if (!no_conflict) {
3724       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3725         if (exact_klass != NULL) {
3726           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3727         } else {
3728           __ load_klass(tmp, tmp);
3729         }
3730 
3731         __ xorptr(tmp, mdo_addr);
3732         __ testptr(tmp, TypeEntries::type_klass_mask);
3733         // klass seen before, nothing to do. The unknown bit may have been
3734         // set already but no need to check.
3735         __ jccb(Assembler::zero, next);
3736 
3737         __ testptr(tmp, TypeEntries::type_unknown);
3738         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3739 
3740         if (TypeEntries::is_type_none(current_klass)) {
3741           __ cmpptr(mdo_addr, 0);
3742           __ jccb(Assembler::equal, none);
3743           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3744           __ jccb(Assembler::equal, none);
3745           // There is a chance that the checks above (re-reading profiling
3746           // data from memory) fail if another thread has just set the
3747           // profiling to this obj&#39;s klass
3748           __ xorptr(tmp, mdo_addr);
3749           __ testptr(tmp, TypeEntries::type_klass_mask);
3750           __ jccb(Assembler::zero, next);
3751         }
3752       } else {
3753         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3754                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3755 
3756         __ movptr(tmp, mdo_addr);
3757         __ testptr(tmp, TypeEntries::type_unknown);
3758         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3759       }
3760 
3761       // different than before. Cannot keep accurate profile.
3762       __ orptr(mdo_addr, TypeEntries::type_unknown);
3763 
3764       if (TypeEntries::is_type_none(current_klass)) {
3765         __ jmpb(next);
3766 
3767         __ bind(none);
3768         // first time here. Set profile type.
3769         __ movptr(mdo_addr, tmp);
3770       }
3771     } else {
3772       // There&#39;s a single possible klass at this profile point
3773       assert(exact_klass != NULL, &quot;should be&quot;);
3774       if (TypeEntries::is_type_none(current_klass)) {
3775         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3776         __ xorptr(tmp, mdo_addr);
3777         __ testptr(tmp, TypeEntries::type_klass_mask);
3778 #ifdef ASSERT
3779         __ jcc(Assembler::zero, next);
3780 
3781         {
3782           Label ok;
3783           __ push(tmp);
3784           __ cmpptr(mdo_addr, 0);
3785           __ jcc(Assembler::equal, ok);
3786           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3787           __ jcc(Assembler::equal, ok);
3788           // may have been set by another thread
3789           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3790           __ xorptr(tmp, mdo_addr);
3791           __ testptr(tmp, TypeEntries::type_mask);
3792           __ jcc(Assembler::zero, ok);
3793 
3794           __ stop(&quot;unexpected profiling mismatch&quot;);
3795           __ bind(ok);
3796           __ pop(tmp);
3797         }
3798 #else
3799         __ jccb(Assembler::zero, next);
3800 #endif
3801         // first time here. Set profile type.
3802         __ movptr(mdo_addr, tmp);
3803       } else {
3804         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3805                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3806 
3807         __ movptr(tmp, mdo_addr);
3808         __ testptr(tmp, TypeEntries::type_unknown);
3809         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3810 
3811         __ orptr(mdo_addr, TypeEntries::type_unknown);
3812       }
3813     }
3814 
3815     __ bind(next);
3816   }
3817 }
3818 
3819 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
3820   Unimplemented();
3821 }
3822 
3823 
3824 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
3825   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
3826 }
3827 
3828 
3829 void LIR_Assembler::align_backward_branch_target() {
3830   __ align(BytesPerWord);
3831 }
3832 
3833 
3834 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3835   if (left-&gt;is_single_cpu()) {
3836     __ negl(left-&gt;as_register());
3837     move_regs(left-&gt;as_register(), dest-&gt;as_register());
3838 
3839   } else if (left-&gt;is_double_cpu()) {
3840     Register lo = left-&gt;as_register_lo();
3841 #ifdef _LP64
3842     Register dst = dest-&gt;as_register_lo();
3843     __ movptr(dst, lo);
3844     __ negptr(dst);
3845 #else
3846     Register hi = left-&gt;as_register_hi();
3847     __ lneg(hi, lo);
3848     if (dest-&gt;as_register_lo() == hi) {
3849       assert(dest-&gt;as_register_hi() != lo, &quot;destroying register&quot;);
3850       move_regs(hi, dest-&gt;as_register_hi());
3851       move_regs(lo, dest-&gt;as_register_lo());
3852     } else {
3853       move_regs(lo, dest-&gt;as_register_lo());
3854       move_regs(hi, dest-&gt;as_register_hi());
3855     }
3856 #endif // _LP64
3857 
3858   } else if (dest-&gt;is_single_xmm()) {
3859 #ifdef _LP64
3860     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3861       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3862       assert_different_registers(left-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg());
3863       __ vpxor(dest-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg(), 2);
3864     }
3865     else
3866 #endif
3867     {
3868       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3869       if (left-&gt;as_xmm_float_reg() != dest-&gt;as_xmm_float_reg()) {
3870         __ movflt(dest-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg());
3871       }
3872       __ xorps(dest-&gt;as_xmm_float_reg(),
3873                ExternalAddress((address)float_signflip_pool));
3874     }
3875   } else if (dest-&gt;is_double_xmm()) {
3876 #ifdef _LP64
3877     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3878       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3879       assert_different_registers(left-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg());
3880       __ vpxor(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg(), 2);
3881     }
3882     else
3883 #endif
3884     {
3885       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3886       if (left-&gt;as_xmm_double_reg() != dest-&gt;as_xmm_double_reg()) {
3887         __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
3888       }
3889       __ xorpd(dest-&gt;as_xmm_double_reg(),
3890                ExternalAddress((address)double_signflip_pool));
3891     }
3892 #ifndef _LP64
3893   } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
3894     assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
3895     assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
3896     __ fchs();
3897 #endif // !_LP64
3898 
3899   } else {
3900     ShouldNotReachHere();
3901   }
3902 }
3903 
3904 
3905 void LIR_Assembler::leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3906   assert(src-&gt;is_address(), &quot;must be an address&quot;);
3907   assert(dest-&gt;is_register(), &quot;must be a register&quot;);
3908 
3909   PatchingStub* patch = NULL;
3910   if (patch_code != lir_patch_none) {
3911     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
3912   }
3913 
3914   Register reg = dest-&gt;as_pointer_register();
3915   LIR_Address* addr = src-&gt;as_address_ptr();
3916   __ lea(reg, as_Address(addr));
3917 
3918   if (patch != NULL) {
3919     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
3920   }
3921 }
3922 
3923 
3924 
3925 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3926   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
3927   __ call(RuntimeAddress(dest));
3928   if (info != NULL) {
3929     add_call_info_here(info);
3930   }
3931 }
3932 
3933 
3934 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3935   assert(type == T_LONG, &quot;only for volatile long fields&quot;);
3936 
3937   if (info != NULL) {
3938     add_debug_info_for_null_check_here(info);
3939   }
3940 
3941   if (src-&gt;is_double_xmm()) {
3942     if (dest-&gt;is_double_cpu()) {
3943 #ifdef _LP64
3944       __ movdq(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3945 #else
3946       __ movdl(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3947       __ psrlq(src-&gt;as_xmm_double_reg(), 32);
3948       __ movdl(dest-&gt;as_register_hi(), src-&gt;as_xmm_double_reg());
3949 #endif // _LP64
3950     } else if (dest-&gt;is_double_stack()) {
3951       __ movdbl(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()), src-&gt;as_xmm_double_reg());
3952     } else if (dest-&gt;is_address()) {
3953       __ movdbl(as_Address(dest-&gt;as_address_ptr()), src-&gt;as_xmm_double_reg());
3954     } else {
3955       ShouldNotReachHere();
3956     }
3957 
3958   } else if (dest-&gt;is_double_xmm()) {
3959     if (src-&gt;is_double_stack()) {
3960       __ movdbl(dest-&gt;as_xmm_double_reg(), frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3961     } else if (src-&gt;is_address()) {
3962       __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
3963     } else {
3964       ShouldNotReachHere();
3965     }
3966 
3967 #ifndef _LP64
3968   } else if (src-&gt;is_double_fpu()) {
3969     assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3970     if (dest-&gt;is_double_stack()) {
3971       __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
3972     } else if (dest-&gt;is_address()) {
3973       __ fistp_d(as_Address(dest-&gt;as_address_ptr()));
3974     } else {
3975       ShouldNotReachHere();
3976     }
3977 
3978   } else if (dest-&gt;is_double_fpu()) {
3979     assert(dest-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3980     if (src-&gt;is_double_stack()) {
3981       __ fild_d(frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3982     } else if (src-&gt;is_address()) {
3983       __ fild_d(as_Address(src-&gt;as_address_ptr()));
3984     } else {
3985       ShouldNotReachHere();
3986     }
3987 #endif // !_LP64
3988 
3989   } else {
3990     ShouldNotReachHere();
3991   }
3992 }
3993 
3994 #ifdef ASSERT
3995 // emit run-time assertion
3996 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3997   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3998 
3999   if (op-&gt;in_opr1()-&gt;is_valid()) {
4000     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
4001     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
4002   } else {
4003     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
4004     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
4005   }
4006 
4007   Label ok;
4008   if (op-&gt;condition() != lir_cond_always) {
4009     Assembler::Condition acond = Assembler::zero;
4010     switch (op-&gt;condition()) {
4011       case lir_cond_equal:        acond = Assembler::equal;       break;
4012       case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
4013       case lir_cond_less:         acond = Assembler::less;        break;
4014       case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
4015       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
4016       case lir_cond_greater:      acond = Assembler::greater;     break;
4017       case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
4018       case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
4019       default:                    ShouldNotReachHere();
4020     }
4021     __ jcc(acond, ok);
4022   }
4023   if (op-&gt;halt()) {
4024     const char* str = __ code_string(op-&gt;msg());
4025     __ stop(str);
4026   } else {
4027     breakpoint();
4028   }
4029   __ bind(ok);
4030 }
4031 #endif
4032 
4033 void LIR_Assembler::membar() {
4034   // QQQ sparc TSO uses this,
4035   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad));
4036 }
4037 
4038 void LIR_Assembler::membar_acquire() {
4039   // No x86 machines currently require load fences
4040 }
4041 
4042 void LIR_Assembler::membar_release() {
4043   // No x86 machines currently require store fences
4044 }
4045 
4046 void LIR_Assembler::membar_loadload() {
4047   // no-op
4048   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
4049 }
4050 
4051 void LIR_Assembler::membar_storestore() {
4052   // no-op
4053   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
4054 }
4055 
4056 void LIR_Assembler::membar_loadstore() {
4057   // no-op
4058   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
4059 }
4060 
4061 void LIR_Assembler::membar_storeload() {
4062   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4063 }
4064 
4065 void LIR_Assembler::on_spin_wait() {
4066   __ pause ();
4067 }
4068 
4069 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4070   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4071 #ifdef _LP64
4072   // __ get_thread(result_reg-&gt;as_register_lo());
4073   __ mov(result_reg-&gt;as_register(), r15_thread);
4074 #else
4075   __ get_thread(result_reg-&gt;as_register());
4076 #endif // _LP64
4077 }
4078 
4079 
4080 void LIR_Assembler::peephole(LIR_List*) {
4081   // do nothing for now
4082 }
4083 
4084 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4085   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4086 
4087   if (data-&gt;type() == T_INT) {
4088     if (code == lir_xadd) {
4089       __ lock();
4090       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4091     } else {
4092       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4093     }
4094   } else if (data-&gt;is_oop()) {
4095     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4096     Register obj = data-&gt;as_register();
4097 #ifdef _LP64
4098     if (UseCompressedOops) {
4099       __ encode_heap_oop(obj);
4100       __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4101       __ decode_heap_oop(obj);
4102     } else {
4103       __ xchgptr(obj, as_Address(src-&gt;as_address_ptr()));
4104     }
4105 #else
4106     __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4107 #endif
4108   } else if (data-&gt;type() == T_LONG) {
4109 #ifdef _LP64
4110     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
4111     if (code == lir_xadd) {
4112       __ lock();
4113       __ xaddq(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register_lo());
4114     } else {
4115       __ xchgq(data-&gt;as_register_lo(), as_Address(src-&gt;as_address_ptr()));
4116     }
4117 #else
4118     ShouldNotReachHere();
4119 #endif
4120   } else {
4121     ShouldNotReachHere();
4122   }
4123 }
4124 
4125 #undef __
    </pre>
  </body>
</html>
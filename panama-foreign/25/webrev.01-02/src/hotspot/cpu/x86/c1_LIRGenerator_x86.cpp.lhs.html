<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_FrameMap.hpp&quot;
  28 #include &quot;c1/c1_Instruction.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArray.hpp&quot;
  34 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  35 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  36 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  37 #include &quot;runtime/sharedRuntime.hpp&quot;
  38 #include &quot;runtime/stubRoutines.hpp&quot;
<a name="1" id="anc1"></a>
  39 #include &quot;vmreg_x86.inline.hpp&quot;
  40 
  41 #ifdef ASSERT
  42 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  43 #else
  44 #define __ gen()-&gt;lir()-&gt;
  45 #endif
  46 
  47 // Item will be loaded into a byte register; Intel only
  48 void LIRItem::load_byte_item() {
  49   load_item();
  50   LIR_Opr res = result();
  51 
  52   if (!res-&gt;is_virtual() || !_gen-&gt;is_vreg_flag_set(res, LIRGenerator::byte_reg)) {
  53     // make sure that it is a byte register
  54     assert(!value()-&gt;type()-&gt;is_float() &amp;&amp; !value()-&gt;type()-&gt;is_double(),
  55            &quot;can&#39;t load floats in byte register&quot;);
  56     LIR_Opr reg = _gen-&gt;rlock_byte(T_BYTE);
  57     __ move(res, reg);
  58 
  59     _result = reg;
  60   }
  61 }
  62 
  63 
  64 void LIRItem::load_nonconstant() {
  65   LIR_Opr r = value()-&gt;operand();
  66   if (r-&gt;is_constant()) {
  67     _result = r;
  68   } else {
  69     load_item();
  70   }
  71 }
  72 
  73 //--------------------------------------------------------------
  74 //               LIRGenerator
  75 //--------------------------------------------------------------
  76 
  77 
  78 LIR_Opr LIRGenerator::exceptionOopOpr() { return FrameMap::rax_oop_opr; }
  79 LIR_Opr LIRGenerator::exceptionPcOpr()  { return FrameMap::rdx_opr; }
  80 LIR_Opr LIRGenerator::divInOpr()        { return FrameMap::rax_opr; }
  81 LIR_Opr LIRGenerator::divOutOpr()       { return FrameMap::rax_opr; }
  82 LIR_Opr LIRGenerator::remOutOpr()       { return FrameMap::rdx_opr; }
  83 LIR_Opr LIRGenerator::shiftCountOpr()   { return FrameMap::rcx_opr; }
  84 LIR_Opr LIRGenerator::syncLockOpr()     { return new_register(T_INT); }
  85 LIR_Opr LIRGenerator::syncTempOpr()     { return FrameMap::rax_opr; }
  86 LIR_Opr LIRGenerator::getThreadTemp()   { return LIR_OprFact::illegalOpr; }
  87 
  88 
  89 LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {
  90   LIR_Opr opr;
  91   switch (type-&gt;tag()) {
  92     case intTag:     opr = FrameMap::rax_opr;          break;
  93     case objectTag:  opr = FrameMap::rax_oop_opr;      break;
  94     case longTag:    opr = FrameMap::long0_opr;        break;
  95     case floatTag:   opr = UseSSE &gt;= 1 ? FrameMap::xmm0_float_opr  : FrameMap::fpu0_float_opr;  break;
  96     case doubleTag:  opr = UseSSE &gt;= 2 ? FrameMap::xmm0_double_opr : FrameMap::fpu0_double_opr;  break;
  97 
  98     case addressTag:
  99     default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
 100   }
 101 
 102   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
 103   return opr;
 104 }
 105 
 106 
 107 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
 108   LIR_Opr reg = new_register(T_INT);
 109   set_vreg_flag(reg, LIRGenerator::byte_reg);
 110   return reg;
 111 }
 112 
 113 
 114 //--------- loading items into registers --------------------------------
 115 
 116 
 117 // i486 instructions can inline constants
 118 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 119   if (type == T_SHORT || type == T_CHAR) {
 120     // there is no immediate move of word values in asembler_i486.?pp
 121     return false;
 122   }
 123   Constant* c = v-&gt;as_Constant();
 124   if (c &amp;&amp; c-&gt;state_before() == NULL) {
 125     // constants of any type can be stored directly, except for
 126     // unloaded object constants.
 127     return true;
 128   }
 129   return false;
 130 }
 131 
 132 
 133 bool LIRGenerator::can_inline_as_constant(Value v) const {
 134   if (v-&gt;type()-&gt;tag() == longTag) return false;
 135   return v-&gt;type()-&gt;tag() != objectTag ||
 136     (v-&gt;type()-&gt;is_constant() &amp;&amp; v-&gt;type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object());
 137 }
 138 
 139 
 140 bool LIRGenerator::can_inline_as_constant(LIR_Const* c) const {
 141   if (c-&gt;type() == T_LONG) return false;
 142   return c-&gt;type() != T_OBJECT || c-&gt;as_jobject() == NULL;
 143 }
 144 
 145 
 146 LIR_Opr LIRGenerator::safepoint_poll_register() {
 147   NOT_LP64( if (SafepointMechanism::uses_thread_local_poll()) { return new_register(T_ADDRESS); } )
 148   return LIR_OprFact::illegalOpr;
 149 }
 150 
 151 
 152 LIR_Address* LIRGenerator::generate_address(LIR_Opr base, LIR_Opr index,
 153                                             int shift, int disp, BasicType type) {
 154   assert(base-&gt;is_register(), &quot;must be&quot;);
 155   if (index-&gt;is_constant()) {
 156     LIR_Const *constant = index-&gt;as_constant_ptr();
 157 #ifdef _LP64
 158     jlong c;
 159     if (constant-&gt;type() == T_INT) {
 160       c = (jlong(index-&gt;as_jint()) &lt;&lt; shift) + disp;
 161     } else {
 162       assert(constant-&gt;type() == T_LONG, &quot;should be&quot;);
 163       c = (index-&gt;as_jlong() &lt;&lt; shift) + disp;
 164     }
 165     if ((jlong)((jint)c) == c) {
 166       return new LIR_Address(base, (jint)c, type);
 167     } else {
 168       LIR_Opr tmp = new_register(T_LONG);
 169       __ move(index, tmp);
 170       return new LIR_Address(base, tmp, type);
 171     }
 172 #else
 173     return new LIR_Address(base,
 174                            ((intx)(constant-&gt;as_jint()) &lt;&lt; shift) + disp,
 175                            type);
 176 #endif
 177   } else {
 178     return new LIR_Address(base, index, (LIR_Address::Scale)shift, disp, type);
 179   }
 180 }
 181 
 182 
 183 LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr,
 184                                               BasicType type) {
 185   int offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);
 186 
 187   LIR_Address* addr;
 188   if (index_opr-&gt;is_constant()) {
 189     int elem_size = type2aelembytes(type);
 190     addr = new LIR_Address(array_opr,
 191                            offset_in_bytes + (intx)(index_opr-&gt;as_jint()) * elem_size, type);
 192   } else {
 193 #ifdef _LP64
 194     if (index_opr-&gt;type() == T_INT) {
 195       LIR_Opr tmp = new_register(T_LONG);
 196       __ convert(Bytecodes::_i2l, index_opr, tmp);
 197       index_opr = tmp;
 198     }
 199 #endif // _LP64
 200     addr =  new LIR_Address(array_opr,
 201                             index_opr,
 202                             LIR_Address::scale(type),
 203                             offset_in_bytes, type);
 204   }
 205   return addr;
 206 }
 207 
 208 
 209 LIR_Opr LIRGenerator::load_immediate(int x, BasicType type) {
 210   LIR_Opr r = NULL;
 211   if (type == T_LONG) {
 212     r = LIR_OprFact::longConst(x);
 213   } else if (type == T_INT) {
 214     r = LIR_OprFact::intConst(x);
 215   } else {
 216     ShouldNotReachHere();
 217   }
 218   return r;
 219 }
 220 
 221 void LIRGenerator::increment_counter(address counter, BasicType type, int step) {
 222   LIR_Opr pointer = new_pointer_register();
 223   __ move(LIR_OprFact::intptrConst(counter), pointer);
 224   LIR_Address* addr = new LIR_Address(pointer, type);
 225   increment_counter(addr, step);
 226 }
 227 
 228 
 229 void LIRGenerator::increment_counter(LIR_Address* addr, int step) {
 230   __ add((LIR_Opr)addr, LIR_OprFact::intConst(step), (LIR_Opr)addr);
 231 }
 232 
 233 void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
 234   __ cmp_mem_int(condition, base, disp, c, info);
 235 }
 236 
 237 
 238 void LIRGenerator::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info) {
 239   __ cmp_reg_mem(condition, reg, new LIR_Address(base, disp, type), info);
 240 }
 241 
 242 
 243 bool LIRGenerator::strength_reduce_multiply(LIR_Opr left, jint c, LIR_Opr result, LIR_Opr tmp) {
 244   if (tmp-&gt;is_valid() &amp;&amp; c &gt; 0 &amp;&amp; c &lt; max_jint) {
 245     if (is_power_of_2(c + 1)) {
 246       __ move(left, tmp);
 247       __ shift_left(left, log2_jint(c + 1), left);
 248       __ sub(left, tmp, result);
 249       return true;
 250     } else if (is_power_of_2(c - 1)) {
 251       __ move(left, tmp);
 252       __ shift_left(left, log2_jint(c - 1), left);
 253       __ add(left, tmp, result);
 254       return true;
 255     }
 256   }
 257   return false;
 258 }
 259 
 260 
 261 void LIRGenerator::store_stack_parameter (LIR_Opr item, ByteSize offset_from_sp) {
 262   BasicType type = item-&gt;type();
 263   __ store(item, new LIR_Address(FrameMap::rsp_opr, in_bytes(offset_from_sp), type));
 264 }
 265 
 266 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 267   LIR_Opr tmp1 = new_register(objectType);
 268   LIR_Opr tmp2 = new_register(objectType);
 269   LIR_Opr tmp3 = new_register(objectType);
 270   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 271 }
 272 
 273 //----------------------------------------------------------------------
 274 //             visitor functions
 275 //----------------------------------------------------------------------
 276 
 277 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 278   assert(x-&gt;is_pinned(),&quot;&quot;);
 279   LIRItem obj(x-&gt;obj(), this);
 280   obj.load_item();
 281 
 282   set_no_result(x);
 283 
 284   // &quot;lock&quot; stores the address of the monitor stack slot, so this is not an oop
 285   LIR_Opr lock = new_register(T_INT);
 286   // Need a scratch register for biased locking on x86
 287   LIR_Opr scratch = LIR_OprFact::illegalOpr;
 288   if (UseBiasedLocking) {
 289     scratch = new_register(T_INT);
 290   }
 291 
 292   CodeEmitInfo* info_for_exception = NULL;
 293   if (x-&gt;needs_null_check()) {
 294     info_for_exception = state_for(x);
 295   }
 296   // this CodeEmitInfo must not have the xhandlers because here the
 297   // object is already locked (xhandlers expect object to be unlocked)
 298   CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
 299   monitor_enter(obj.result(), lock, syncTempOpr(), scratch,
 300                         x-&gt;monitor_no(), info_for_exception, info);
 301 }
 302 
 303 
 304 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 305   assert(x-&gt;is_pinned(),&quot;&quot;);
 306 
 307   LIRItem obj(x-&gt;obj(), this);
 308   obj.dont_load_item();
 309 
 310   LIR_Opr lock = new_register(T_INT);
 311   LIR_Opr obj_temp = new_register(T_INT);
 312   set_no_result(x);
 313   monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 314 }
 315 
 316 
 317 // _ineg, _lneg, _fneg, _dneg
 318 void LIRGenerator::do_NegateOp(NegateOp* x) {
 319   LIRItem value(x-&gt;x(), this);
 320   value.set_destroys_register();
 321   value.load_item();
 322   LIR_Opr reg = rlock(x);
 323 
 324   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 325 #ifdef _LP64
 326   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
 327     if (x-&gt;type()-&gt;tag() == doubleTag) {
 328       tmp = new_register(T_DOUBLE);
 329       __ move(LIR_OprFact::doubleConst(-0.0), tmp);
 330     }
 331     else if (x-&gt;type()-&gt;tag() == floatTag) {
 332       tmp = new_register(T_FLOAT);
 333       __ move(LIR_OprFact::floatConst(-0.0), tmp);
 334     }
 335   }
 336 #endif
 337   __ negate(value.result(), reg, tmp);
 338 
 339   set_result(x, round_item(reg));
 340 }
 341 
 342 
 343 // for  _fadd, _fmul, _fsub, _fdiv, _frem
 344 //      _dadd, _dmul, _dsub, _ddiv, _drem
 345 void LIRGenerator::do_ArithmeticOp_FPU(ArithmeticOp* x) {
 346   LIRItem left(x-&gt;x(),  this);
 347   LIRItem right(x-&gt;y(), this);
 348   LIRItem* left_arg  = &amp;left;
 349   LIRItem* right_arg = &amp;right;
 350   assert(!left.is_stack() || !right.is_stack(), &quot;can&#39;t both be memory operands&quot;);
 351   bool must_load_both = (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem);
 352   if (left.is_register() || x-&gt;x()-&gt;type()-&gt;is_constant() || must_load_both) {
 353     left.load_item();
 354   } else {
 355     left.dont_load_item();
 356   }
 357 
 358   // do not load right operand if it is a constant.  only 0 and 1 are
 359   // loaded because there are special instructions for loading them
 360   // without memory access (not needed for SSE2 instructions)
 361   bool must_load_right = false;
 362   if (right.is_constant()) {
 363     LIR_Const* c = right.result()-&gt;as_constant_ptr();
 364     assert(c != NULL, &quot;invalid constant&quot;);
 365     assert(c-&gt;type() == T_FLOAT || c-&gt;type() == T_DOUBLE, &quot;invalid type&quot;);
 366 
 367     if (c-&gt;type() == T_FLOAT) {
 368       must_load_right = UseSSE &lt; 1 &amp;&amp; (c-&gt;is_one_float() || c-&gt;is_zero_float());
 369     } else {
 370       must_load_right = UseSSE &lt; 2 &amp;&amp; (c-&gt;is_one_double() || c-&gt;is_zero_double());
 371     }
 372   }
 373 
 374   if (must_load_both) {
 375     // frem and drem destroy also right operand, so move it to a new register
 376     right.set_destroys_register();
 377     right.load_item();
 378   } else if (right.is_register() || must_load_right) {
 379     right.load_item();
 380   } else {
 381     right.dont_load_item();
 382   }
 383   LIR_Opr reg = rlock(x);
 384   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 385   if (x-&gt;is_strictfp() &amp;&amp; (x-&gt;op() == Bytecodes::_dmul || x-&gt;op() == Bytecodes::_ddiv)) {
 386     tmp = new_register(T_DOUBLE);
 387   }
 388 
 389 #ifdef _LP64
 390   if (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem) {
 391     // frem and drem are implemented as a direct call into the runtime.
 392     LIRItem left(x-&gt;x(), this);
 393     LIRItem right(x-&gt;y(), this);
 394 
 395     BasicType bt = as_BasicType(x-&gt;type());
 396     BasicTypeList signature(2);
 397     signature.append(bt);
 398     signature.append(bt);
 399     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 400 
 401     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 402     left.load_item_force(cc-&gt;at(0));
 403     right.load_item_force(cc-&gt;at(1));
 404 
 405     address entry = NULL;
 406     switch (x-&gt;op()) {
 407       case Bytecodes::_frem:
 408         entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);
 409         break;
 410       case Bytecodes::_drem:
 411         entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);
 412         break;
 413       default:
 414         ShouldNotReachHere();
 415     }
 416 
 417     LIR_Opr result = rlock_result(x);
 418     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 419     __ move(result_reg, result);
 420   } else {
 421     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 422     set_result(x, round_item(reg));
 423   }
 424 #else
 425   if ((UseSSE &gt;= 1 &amp;&amp; x-&gt;op() == Bytecodes::_frem) || (UseSSE &gt;= 2 &amp;&amp; x-&gt;op() == Bytecodes::_drem)) {
 426     // special handling for frem and drem: no SSE instruction, so must use FPU with temporary fpu stack slots
 427     LIR_Opr fpu0, fpu1;
 428     if (x-&gt;op() == Bytecodes::_frem) {
 429       fpu0 = LIR_OprFact::single_fpu(0);
 430       fpu1 = LIR_OprFact::single_fpu(1);
 431     } else {
 432       fpu0 = LIR_OprFact::double_fpu(0);
 433       fpu1 = LIR_OprFact::double_fpu(1);
 434     }
 435     __ move(right.result(), fpu1); // order of left and right operand is important!
 436     __ move(left.result(), fpu0);
 437     __ rem (fpu0, fpu1, fpu0);
 438     __ move(fpu0, reg);
 439 
 440   } else {
 441     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 442   }
 443   set_result(x, round_item(reg));
 444 #endif // _LP64
 445 }
 446 
 447 
 448 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 449 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 450   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem ) {
 451     // long division is implemented as a direct call into the runtime
 452     LIRItem left(x-&gt;x(), this);
 453     LIRItem right(x-&gt;y(), this);
 454 
 455     // the check for division by zero destroys the right operand
 456     right.set_destroys_register();
 457 
 458     BasicTypeList signature(2);
 459     signature.append(T_LONG);
 460     signature.append(T_LONG);
 461     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 462 
 463     // check for division by zero (destroys registers of right operand!)
 464     CodeEmitInfo* info = state_for(x);
 465 
 466     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 467     left.load_item_force(cc-&gt;at(1));
 468     right.load_item();
 469 
 470     __ move(right.result(), cc-&gt;at(0));
 471 
 472     __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 473     __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 474 
 475     address entry = NULL;
 476     switch (x-&gt;op()) {
 477     case Bytecodes::_lrem:
 478       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 479       break; // check if dividend is 0 is done elsewhere
 480     case Bytecodes::_ldiv:
 481       entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 482       break; // check if dividend is 0 is done elsewhere
 483     default:
 484       ShouldNotReachHere();
 485     }
 486 
 487     LIR_Opr result = rlock_result(x);
 488     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 489     __ move(result_reg, result);
 490   } else if (x-&gt;op() == Bytecodes::_lmul) {
 491     // missing test if instr is commutative and if we should swap
 492     LIRItem left(x-&gt;x(), this);
 493     LIRItem right(x-&gt;y(), this);
 494 
 495     // right register is destroyed by the long mul, so it must be
 496     // copied to a new register.
 497     right.set_destroys_register();
 498 
 499     left.load_item();
 500     right.load_item();
 501 
 502     LIR_Opr reg = FrameMap::long0_opr;
 503     arithmetic_op_long(x-&gt;op(), reg, left.result(), right.result(), NULL);
 504     LIR_Opr result = rlock_result(x);
 505     __ move(reg, result);
 506   } else {
 507     // missing test if instr is commutative and if we should swap
 508     LIRItem left(x-&gt;x(), this);
 509     LIRItem right(x-&gt;y(), this);
 510 
 511     left.load_item();
 512     // don&#39;t load constants to save register
 513     right.load_nonconstant();
 514     rlock_result(x);
 515     arithmetic_op_long(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), NULL);
 516   }
 517 }
 518 
 519 
 520 
 521 // for: _iadd, _imul, _isub, _idiv, _irem
 522 void LIRGenerator::do_ArithmeticOp_Int(ArithmeticOp* x) {
 523   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 524     // The requirements for division and modulo
 525     // input : rax,: dividend                         min_int
 526     //         reg: divisor   (may not be rax,/rdx)   -1
 527     //
 528     // output: rax,: quotient  (= rax, idiv reg)       min_int
 529     //         rdx: remainder (= rax, irem reg)       0
 530 
 531     // rax, and rdx will be destroyed
 532 
 533     // Note: does this invalidate the spec ???
 534     LIRItem right(x-&gt;y(), this);
 535     LIRItem left(x-&gt;x() , this);   // visit left second, so that the is_register test is valid
 536 
 537     // call state_for before load_item_force because state_for may
 538     // force the evaluation of other instructions that are needed for
 539     // correct debug info.  Otherwise the live range of the fix
 540     // register might be too long.
 541     CodeEmitInfo* info = state_for(x);
 542 
 543     left.load_item_force(divInOpr());
 544 
 545     right.load_item();
 546 
 547     LIR_Opr result = rlock_result(x);
 548     LIR_Opr result_reg;
 549     if (x-&gt;op() == Bytecodes::_idiv) {
 550       result_reg = divOutOpr();
 551     } else {
 552       result_reg = remOutOpr();
 553     }
 554 
 555     if (!ImplicitDiv0Checks) {
 556       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::intConst(0));
 557       __ branch(lir_cond_equal, T_INT, new DivByZeroStub(info));
 558       // Idiv/irem cannot trap (passing info would generate an assertion).
 559       info = NULL;
 560     }
 561     LIR_Opr tmp = FrameMap::rdx_opr; // idiv and irem use rdx in their implementation
 562     if (x-&gt;op() == Bytecodes::_irem) {
 563       __ irem(left.result(), right.result(), result_reg, tmp, info);
 564     } else if (x-&gt;op() == Bytecodes::_idiv) {
 565       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 566     } else {
 567       ShouldNotReachHere();
 568     }
 569 
 570     __ move(result_reg, result);
 571   } else {
 572     // missing test if instr is commutative and if we should swap
 573     LIRItem left(x-&gt;x(),  this);
 574     LIRItem right(x-&gt;y(), this);
 575     LIRItem* left_arg = &amp;left;
 576     LIRItem* right_arg = &amp;right;
 577     if (x-&gt;is_commutative() &amp;&amp; left.is_stack() &amp;&amp; right.is_register()) {
 578       // swap them if left is real stack (or cached) and right is real register(not cached)
 579       left_arg = &amp;right;
 580       right_arg = &amp;left;
 581     }
 582 
 583     left_arg-&gt;load_item();
 584 
 585     // do not need to load right, as we can handle stack and constants
 586     if (x-&gt;op() == Bytecodes::_imul ) {
 587       // check if we can use shift instead
 588       bool use_constant = false;
 589       bool use_tmp = false;
 590       if (right_arg-&gt;is_constant()) {
 591         jint iconst = right_arg-&gt;get_jint_constant();
 592         if (iconst &gt; 0 &amp;&amp; iconst &lt; max_jint) {
 593           if (is_power_of_2(iconst)) {
 594             use_constant = true;
 595           } else if (is_power_of_2(iconst - 1) || is_power_of_2(iconst + 1)) {
 596             use_constant = true;
 597             use_tmp = true;
 598           }
 599         }
 600       }
 601       if (use_constant) {
 602         right_arg-&gt;dont_load_item();
 603       } else {
 604         right_arg-&gt;load_item();
 605       }
 606       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 607       if (use_tmp) {
 608         tmp = new_register(T_INT);
 609       }
 610       rlock_result(x);
 611 
 612       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 613     } else {
 614       right_arg-&gt;dont_load_item();
 615       rlock_result(x);
 616       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 617       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 618     }
 619   }
 620 }
 621 
 622 
 623 void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
 624   // when an operand with use count 1 is the left operand, then it is
 625   // likely that no move for 2-operand-LIR-form is necessary
 626   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 627     x-&gt;swap_operands();
 628   }
 629 
 630   ValueTag tag = x-&gt;type()-&gt;tag();
 631   assert(x-&gt;x()-&gt;type()-&gt;tag() == tag &amp;&amp; x-&gt;y()-&gt;type()-&gt;tag() == tag, &quot;wrong parameters&quot;);
 632   switch (tag) {
 633     case floatTag:
 634     case doubleTag:  do_ArithmeticOp_FPU(x);  return;
 635     case longTag:    do_ArithmeticOp_Long(x); return;
 636     case intTag:     do_ArithmeticOp_Int(x);  return;
 637     default:         ShouldNotReachHere();    return;
 638   }
 639 }
 640 
 641 
 642 // _ishl, _lshl, _ishr, _lshr, _iushr, _lushr
 643 void LIRGenerator::do_ShiftOp(ShiftOp* x) {
 644   // count must always be in rcx
 645   LIRItem value(x-&gt;x(), this);
 646   LIRItem count(x-&gt;y(), this);
 647 
 648   ValueTag elemType = x-&gt;type()-&gt;tag();
 649   bool must_load_count = !count.is_constant() || elemType == longTag;
 650   if (must_load_count) {
 651     // count for long must be in register
 652     count.load_item_force(shiftCountOpr());
 653   } else {
 654     count.dont_load_item();
 655   }
 656   value.load_item();
 657   LIR_Opr reg = rlock_result(x);
 658 
 659   shift_op(x-&gt;op(), reg, value.result(), count.result(), LIR_OprFact::illegalOpr);
 660 }
 661 
 662 
 663 // _iand, _land, _ior, _lor, _ixor, _lxor
 664 void LIRGenerator::do_LogicOp(LogicOp* x) {
 665   // when an operand with use count 1 is the left operand, then it is
 666   // likely that no move for 2-operand-LIR-form is necessary
 667   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 668     x-&gt;swap_operands();
 669   }
 670 
 671   LIRItem left(x-&gt;x(), this);
 672   LIRItem right(x-&gt;y(), this);
 673 
 674   left.load_item();
 675   right.load_nonconstant();
 676   LIR_Opr reg = rlock_result(x);
 677 
 678   logic_op(x-&gt;op(), reg, left.result(), right.result());
 679 }
 680 
 681 
 682 
 683 // _lcmp, _fcmpl, _fcmpg, _dcmpl, _dcmpg
 684 void LIRGenerator::do_CompareOp(CompareOp* x) {
 685   LIRItem left(x-&gt;x(), this);
 686   LIRItem right(x-&gt;y(), this);
 687   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
 688   if (tag == longTag) {
 689     left.set_destroys_register();
 690   }
 691   left.load_item();
 692   right.load_item();
 693   LIR_Opr reg = rlock_result(x);
 694 
 695   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 696     Bytecodes::Code code = x-&gt;op();
 697     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 698   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 699     __ lcmp2int(left.result(), right.result(), reg);
 700   } else {
 701     Unimplemented();
 702   }
 703 }
 704 
 705 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 706   LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
 707   if (is_reference_type(type)) {
 708     cmp_value.load_item_force(FrameMap::rax_oop_opr);
 709     new_value.load_item();
 710     __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 711   } else if (type == T_INT) {
 712     cmp_value.load_item_force(FrameMap::rax_opr);
 713     new_value.load_item();
 714     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 715   } else if (type == T_LONG) {
 716     cmp_value.load_item_force(FrameMap::long0_opr);
 717     new_value.load_item_force(FrameMap::long1_opr);
 718     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 719   } else {
 720     Unimplemented();
 721   }
 722   LIR_Opr result = new_register(T_INT);
 723   __ cmove(lir_cond_equal, LIR_OprFact::intConst(1), LIR_OprFact::intConst(0),
 724            result, T_INT);
 725   return result;
 726 }
 727 
 728 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 729   bool is_oop = is_reference_type(type);
 730   LIR_Opr result = new_register(type);
 731   value.load_item();
 732   // Because we want a 2-arg form of xchg and xadd
 733   __ move(value.result(), result);
 734   assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 735   __ xchg(addr, result, result, LIR_OprFact::illegalOpr);
 736   return result;
 737 }
 738 
 739 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 740   LIR_Opr result = new_register(type);
 741   value.load_item();
 742   // Because we want a 2-arg form of xchg and xadd
 743   __ move(value.result(), result);
 744   assert(type == T_INT LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 745   __ xadd(addr, result, result, LIR_OprFact::illegalOpr);
 746   return result;
 747 }
 748 
 749 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
 750   assert(x-&gt;number_of_arguments() == 3, &quot;wrong type&quot;);
 751   assert(UseFMA, &quot;Needs FMA instructions support.&quot;);
 752   LIRItem value(x-&gt;argument_at(0), this);
 753   LIRItem value1(x-&gt;argument_at(1), this);
 754   LIRItem value2(x-&gt;argument_at(2), this);
 755 
 756   value2.set_destroys_register();
 757 
 758   value.load_item();
 759   value1.load_item();
 760   value2.load_item();
 761 
 762   LIR_Opr calc_input = value.result();
 763   LIR_Opr calc_input1 = value1.result();
 764   LIR_Opr calc_input2 = value2.result();
 765   LIR_Opr calc_result = rlock_result(x);
 766 
 767   switch (x-&gt;id()) {
 768   case vmIntrinsics::_fmaD:   __ fmad(calc_input, calc_input1, calc_input2, calc_result); break;
 769   case vmIntrinsics::_fmaF:   __ fmaf(calc_input, calc_input1, calc_input2, calc_result); break;
 770   default:                    ShouldNotReachHere();
 771   }
 772 
 773 }
 774 
 775 
 776 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 777   assert(x-&gt;number_of_arguments() == 1 || (x-&gt;number_of_arguments() == 2 &amp;&amp; x-&gt;id() == vmIntrinsics::_dpow), &quot;wrong type&quot;);
 778 
 779   if (x-&gt;id() == vmIntrinsics::_dexp || x-&gt;id() == vmIntrinsics::_dlog ||
 780       x-&gt;id() == vmIntrinsics::_dpow || x-&gt;id() == vmIntrinsics::_dcos ||
 781       x-&gt;id() == vmIntrinsics::_dsin || x-&gt;id() == vmIntrinsics::_dtan ||
 782       x-&gt;id() == vmIntrinsics::_dlog10) {
 783     do_LibmIntrinsic(x);
 784     return;
 785   }
 786 
 787   LIRItem value(x-&gt;argument_at(0), this);
 788 
 789   bool use_fpu = false;
 790   if (UseSSE &lt; 2) {
 791     value.set_destroys_register();
 792   }
 793   value.load_item();
 794 
 795   LIR_Opr calc_input = value.result();
 796   LIR_Opr calc_result = rlock_result(x);
 797 
 798   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 799 #ifdef _LP64
 800   if (UseAVX &gt; 2 &amp;&amp; (!VM_Version::supports_avx512vl()) &amp;&amp;
 801       (x-&gt;id() == vmIntrinsics::_dabs)) {
 802     tmp = new_register(T_DOUBLE);
 803     __ move(LIR_OprFact::doubleConst(-0.0), tmp);
 804   }
 805 #endif
 806 
 807   switch(x-&gt;id()) {
 808     case vmIntrinsics::_dabs:   __ abs  (calc_input, calc_result, tmp); break;
 809     case vmIntrinsics::_dsqrt:  __ sqrt (calc_input, calc_result, LIR_OprFact::illegalOpr); break;
 810     default:                    ShouldNotReachHere();
 811   }
 812 
 813   if (use_fpu) {
 814     __ move(calc_result, x-&gt;operand());
 815   }
 816 }
 817 
 818 void LIRGenerator::do_LibmIntrinsic(Intrinsic* x) {
 819   LIRItem value(x-&gt;argument_at(0), this);
 820   value.set_destroys_register();
 821 
 822   LIR_Opr calc_result = rlock_result(x);
 823   LIR_Opr result_reg = result_register_for(x-&gt;type());
 824 
 825   CallingConvention* cc = NULL;
 826 
 827   if (x-&gt;id() == vmIntrinsics::_dpow) {
 828     LIRItem value1(x-&gt;argument_at(1), this);
 829 
 830     value1.set_destroys_register();
 831 
 832     BasicTypeList signature(2);
 833     signature.append(T_DOUBLE);
 834     signature.append(T_DOUBLE);
 835     cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 836     value.load_item_force(cc-&gt;at(0));
 837     value1.load_item_force(cc-&gt;at(1));
 838   } else {
 839     BasicTypeList signature(1);
 840     signature.append(T_DOUBLE);
 841     cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 842     value.load_item_force(cc-&gt;at(0));
 843   }
 844 
 845 #ifndef _LP64
 846   LIR_Opr tmp = FrameMap::fpu0_double_opr;
 847   result_reg = tmp;
 848   switch(x-&gt;id()) {
 849     case vmIntrinsics::_dexp:
 850       if (StubRoutines::dexp() != NULL) {
 851         __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc-&gt;args());
 852       } else {
 853         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dexp), getThreadTemp(), result_reg, cc-&gt;args());
 854       }
 855       break;
 856     case vmIntrinsics::_dlog:
 857       if (StubRoutines::dlog() != NULL) {
 858         __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc-&gt;args());
 859       } else {
 860         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc-&gt;args());
 861       }
 862       break;
 863     case vmIntrinsics::_dlog10:
 864       if (StubRoutines::dlog10() != NULL) {
 865        __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc-&gt;args());
 866       } else {
 867         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc-&gt;args());
 868       }
 869       break;
 870     case vmIntrinsics::_dpow:
 871       if (StubRoutines::dpow() != NULL) {
 872         __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc-&gt;args());
 873       } else {
 874         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dpow), getThreadTemp(), result_reg, cc-&gt;args());
 875       }
 876       break;
 877     case vmIntrinsics::_dsin:
 878       if (VM_Version::supports_sse2() &amp;&amp; StubRoutines::dsin() != NULL) {
 879         __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc-&gt;args());
 880       } else {
 881         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dsin), getThreadTemp(), result_reg, cc-&gt;args());
 882       }
 883       break;
 884     case vmIntrinsics::_dcos:
 885       if (VM_Version::supports_sse2() &amp;&amp; StubRoutines::dcos() != NULL) {
 886         __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc-&gt;args());
 887       } else {
 888         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dcos), getThreadTemp(), result_reg, cc-&gt;args());
 889       }
 890       break;
 891     case vmIntrinsics::_dtan:
 892       if (StubRoutines::dtan() != NULL) {
 893         __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc-&gt;args());
 894       } else {
 895         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc-&gt;args());
 896       }
 897       break;
 898     default:  ShouldNotReachHere();
 899   }
 900 #else
 901   switch (x-&gt;id()) {
 902     case vmIntrinsics::_dexp:
 903       if (StubRoutines::dexp() != NULL) {
 904         __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc-&gt;args());
 905       } else {
 906         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dexp), getThreadTemp(), result_reg, cc-&gt;args());
 907       }
 908       break;
 909     case vmIntrinsics::_dlog:
 910       if (StubRoutines::dlog() != NULL) {
 911       __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc-&gt;args());
 912       } else {
 913         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc-&gt;args());
 914       }
 915       break;
 916     case vmIntrinsics::_dlog10:
 917       if (StubRoutines::dlog10() != NULL) {
 918       __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc-&gt;args());
 919       } else {
 920         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc-&gt;args());
 921       }
 922       break;
 923     case vmIntrinsics::_dpow:
 924        if (StubRoutines::dpow() != NULL) {
 925       __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc-&gt;args());
 926       } else {
 927         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dpow), getThreadTemp(), result_reg, cc-&gt;args());
 928       }
 929       break;
 930     case vmIntrinsics::_dsin:
 931       if (StubRoutines::dsin() != NULL) {
 932         __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc-&gt;args());
 933       } else {
 934         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dsin), getThreadTemp(), result_reg, cc-&gt;args());
 935       }
 936       break;
 937     case vmIntrinsics::_dcos:
 938       if (StubRoutines::dcos() != NULL) {
 939         __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc-&gt;args());
 940       } else {
 941         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dcos), getThreadTemp(), result_reg, cc-&gt;args());
 942       }
 943       break;
 944     case vmIntrinsics::_dtan:
 945        if (StubRoutines::dtan() != NULL) {
 946       __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc-&gt;args());
 947       } else {
 948         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc-&gt;args());
 949       }
 950       break;
 951     default:  ShouldNotReachHere();
 952   }
 953 #endif // _LP64
 954   __ move(result_reg, calc_result);
 955 }
 956 
 957 void LIRGenerator::do_ArrayCopy(Intrinsic* x) {
 958   assert(x-&gt;number_of_arguments() == 5, &quot;wrong type&quot;);
 959 
 960   // Make all state_for calls early since they can emit code
 961   CodeEmitInfo* info = state_for(x, x-&gt;state());
 962 
 963   LIRItem src(x-&gt;argument_at(0), this);
 964   LIRItem src_pos(x-&gt;argument_at(1), this);
 965   LIRItem dst(x-&gt;argument_at(2), this);
 966   LIRItem dst_pos(x-&gt;argument_at(3), this);
 967   LIRItem length(x-&gt;argument_at(4), this);
 968 
 969   // operands for arraycopy must use fixed registers, otherwise
 970   // LinearScan will fail allocation (because arraycopy always needs a
 971   // call)
 972 
 973 #ifndef _LP64
 974   src.load_item_force     (FrameMap::rcx_oop_opr);
 975   src_pos.load_item_force (FrameMap::rdx_opr);
 976   dst.load_item_force     (FrameMap::rax_oop_opr);
 977   dst_pos.load_item_force (FrameMap::rbx_opr);
 978   length.load_item_force  (FrameMap::rdi_opr);
 979   LIR_Opr tmp =           (FrameMap::rsi_opr);
 980 #else
 981 
 982   // The java calling convention will give us enough registers
 983   // so that on the stub side the args will be perfect already.
 984   // On the other slow/special case side we call C and the arg
 985   // positions are not similar enough to pick one as the best.
 986   // Also because the java calling convention is a &quot;shifted&quot; version
 987   // of the C convention we can process the java args trivially into C
 988   // args without worry of overwriting during the xfer
 989 
 990   src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));
 991   src_pos.load_item_force (FrameMap::as_opr(j_rarg1));
 992   dst.load_item_force     (FrameMap::as_oop_opr(j_rarg2));
 993   dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));
 994   length.load_item_force  (FrameMap::as_opr(j_rarg4));
 995 
 996   LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);
 997 #endif // LP64
 998 
 999   set_no_result(x);
1000 
1001   int flags;
1002   ciArrayKlass* expected_type;
1003   arraycopy_helper(x, &amp;flags, &amp;expected_type);
1004 
1005   __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(), length.result(), tmp, expected_type, flags, info); // does add_safepoint
1006 }
1007 
1008 void LIRGenerator::do_update_CRC32(Intrinsic* x) {
1009   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
1010   // Make all state_for calls early since they can emit code
1011   LIR_Opr result = rlock_result(x);
1012   int flags = 0;
1013   switch (x-&gt;id()) {
1014     case vmIntrinsics::_updateCRC32: {
1015       LIRItem crc(x-&gt;argument_at(0), this);
1016       LIRItem val(x-&gt;argument_at(1), this);
1017       // val is destroyed by update_crc32
1018       val.set_destroys_register();
1019       crc.load_item();
1020       val.load_item();
1021       __ update_crc32(crc.result(), val.result(), result);
1022       break;
1023     }
1024     case vmIntrinsics::_updateBytesCRC32:
1025     case vmIntrinsics::_updateByteBufferCRC32: {
1026       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32);
1027 
1028       LIRItem crc(x-&gt;argument_at(0), this);
1029       LIRItem buf(x-&gt;argument_at(1), this);
1030       LIRItem off(x-&gt;argument_at(2), this);
1031       LIRItem len(x-&gt;argument_at(3), this);
1032       buf.load_item();
1033       off.load_nonconstant();
1034 
1035       LIR_Opr index = off.result();
1036       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
1037       if(off.result()-&gt;is_constant()) {
1038         index = LIR_OprFact::illegalOpr;
1039        offset += off.result()-&gt;as_jint();
1040       }
1041       LIR_Opr base_op = buf.result();
1042 
1043 #ifndef _LP64
1044       if (!is_updateBytes) { // long b raw address
1045          base_op = new_register(T_INT);
1046          __ convert(Bytecodes::_l2i, buf.result(), base_op);
1047       }
1048 #else
1049       if (index-&gt;is_valid()) {
1050         LIR_Opr tmp = new_register(T_LONG);
1051         __ convert(Bytecodes::_i2l, index, tmp);
1052         index = tmp;
1053       }
1054 #endif
1055 
1056       if (is_updateBytes) {
1057         base_op = access_resolve(IS_NOT_NULL | ACCESS_READ, base_op);
1058       }
1059 
1060       LIR_Address* a = new LIR_Address(base_op,
1061                                        index,
1062                                        offset,
1063                                        T_BYTE);
1064       BasicTypeList signature(3);
1065       signature.append(T_INT);
1066       signature.append(T_ADDRESS);
1067       signature.append(T_INT);
1068       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1069       const LIR_Opr result_reg = result_register_for(x-&gt;type());
1070 
1071       LIR_Opr addr = new_pointer_register();
1072       __ leal(LIR_OprFact::address(a), addr);
1073 
1074       crc.load_item_force(cc-&gt;at(0));
1075       __ move(addr, cc-&gt;at(1));
1076       len.load_item_force(cc-&gt;at(2));
1077 
1078       __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), getThreadTemp(), result_reg, cc-&gt;args());
1079       __ move(result_reg, result);
1080 
1081       break;
1082     }
1083     default: {
1084       ShouldNotReachHere();
1085     }
1086   }
1087 }
1088 
1089 void LIRGenerator::do_update_CRC32C(Intrinsic* x) {
1090   Unimplemented();
1091 }
1092 
1093 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
1094   assert(UseVectorizedMismatchIntrinsic, &quot;need AVX instruction support&quot;);
1095 
1096   // Make all state_for calls early since they can emit code
1097   LIR_Opr result = rlock_result(x);
1098 
1099   LIRItem a(x-&gt;argument_at(0), this); // Object
1100   LIRItem aOffset(x-&gt;argument_at(1), this); // long
1101   LIRItem b(x-&gt;argument_at(2), this); // Object
1102   LIRItem bOffset(x-&gt;argument_at(3), this); // long
1103   LIRItem length(x-&gt;argument_at(4), this); // int
1104   LIRItem log2ArrayIndexScale(x-&gt;argument_at(5), this); // int
1105 
1106   a.load_item();
1107   aOffset.load_nonconstant();
1108   b.load_item();
1109   bOffset.load_nonconstant();
1110 
1111   long constant_aOffset = 0;
1112   LIR_Opr result_aOffset = aOffset.result();
1113   if (result_aOffset-&gt;is_constant()) {
1114     constant_aOffset = result_aOffset-&gt;as_jlong();
1115     result_aOffset = LIR_OprFact::illegalOpr;
1116   }
1117   LIR_Opr result_a = access_resolve(ACCESS_READ, a.result());
1118 
1119   long constant_bOffset = 0;
1120   LIR_Opr result_bOffset = bOffset.result();
1121   if (result_bOffset-&gt;is_constant()) {
1122     constant_bOffset = result_bOffset-&gt;as_jlong();
1123     result_bOffset = LIR_OprFact::illegalOpr;
1124   }
1125   LIR_Opr result_b = access_resolve(ACCESS_READ, b.result());
1126 
1127 #ifndef _LP64
1128   result_a = new_register(T_INT);
1129   __ convert(Bytecodes::_l2i, a.result(), result_a);
1130   result_b = new_register(T_INT);
1131   __ convert(Bytecodes::_l2i, b.result(), result_b);
1132 #endif
1133 
1134 
1135   LIR_Address* addr_a = new LIR_Address(result_a,
1136                                         result_aOffset,
1137                                         constant_aOffset,
1138                                         T_BYTE);
1139 
1140   LIR_Address* addr_b = new LIR_Address(result_b,
1141                                         result_bOffset,
1142                                         constant_bOffset,
1143                                         T_BYTE);
1144 
1145   BasicTypeList signature(4);
1146   signature.append(T_ADDRESS);
1147   signature.append(T_ADDRESS);
1148   signature.append(T_INT);
1149   signature.append(T_INT);
1150   CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1151   const LIR_Opr result_reg = result_register_for(x-&gt;type());
1152 
1153   LIR_Opr ptr_addr_a = new_pointer_register();
1154   __ leal(LIR_OprFact::address(addr_a), ptr_addr_a);
1155 
1156   LIR_Opr ptr_addr_b = new_pointer_register();
1157   __ leal(LIR_OprFact::address(addr_b), ptr_addr_b);
1158 
1159   __ move(ptr_addr_a, cc-&gt;at(0));
1160   __ move(ptr_addr_b, cc-&gt;at(1));
1161   length.load_item_force(cc-&gt;at(2));
1162   log2ArrayIndexScale.load_item_force(cc-&gt;at(3));
1163 
1164   __ call_runtime_leaf(StubRoutines::vectorizedMismatch(), getThreadTemp(), result_reg, cc-&gt;args());
1165   __ move(result_reg, result);
1166 }
1167 
1168 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
1169 // _i2b, _i2c, _i2s
1170 LIR_Opr fixed_register_for(BasicType type) {
1171   switch (type) {
1172     case T_FLOAT:  return FrameMap::fpu0_float_opr;
1173     case T_DOUBLE: return FrameMap::fpu0_double_opr;
1174     case T_INT:    return FrameMap::rax_opr;
1175     case T_LONG:   return FrameMap::long0_opr;
1176     default:       ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
1177   }
1178 }
1179 
1180 void LIRGenerator::do_Convert(Convert* x) {
1181 #ifdef _LP64
1182   LIRItem value(x-&gt;value(), this);
1183   value.load_item();
1184   LIR_Opr input = value.result();
1185   LIR_Opr result = rlock(x);
1186   __ convert(x-&gt;op(), input, result);
1187   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1188   set_result(x, result);
1189 #else
1190   // flags that vary for the different operations and different SSE-settings
1191   bool fixed_input = false, fixed_result = false, round_result = false, needs_stub = false;
1192 
1193   switch (x-&gt;op()) {
1194     case Bytecodes::_i2l: // fall through
1195     case Bytecodes::_l2i: // fall through
1196     case Bytecodes::_i2b: // fall through
1197     case Bytecodes::_i2c: // fall through
1198     case Bytecodes::_i2s: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1199 
1200     case Bytecodes::_f2d: fixed_input = UseSSE == 1; fixed_result = false;       round_result = false;      needs_stub = false; break;
1201     case Bytecodes::_d2f: fixed_input = false;       fixed_result = UseSSE == 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1202     case Bytecodes::_i2f: fixed_input = false;       fixed_result = false;       round_result = UseSSE &lt; 1; needs_stub = false; break;
1203     case Bytecodes::_i2d: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1204     case Bytecodes::_f2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1205     case Bytecodes::_d2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1206     case Bytecodes::_l2f: fixed_input = false;       fixed_result = UseSSE &gt;= 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1207     case Bytecodes::_l2d: fixed_input = false;       fixed_result = UseSSE &gt;= 2; round_result = UseSSE &lt; 2; needs_stub = false; break;
1208     case Bytecodes::_f2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
1209     case Bytecodes::_d2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
1210     default: ShouldNotReachHere();
1211   }
1212 
1213   LIRItem value(x-&gt;value(), this);
1214   value.load_item();
1215   LIR_Opr input = value.result();
1216   LIR_Opr result = rlock(x);
1217 
1218   // arguments of lir_convert
1219   LIR_Opr conv_input = input;
1220   LIR_Opr conv_result = result;
1221   ConversionStub* stub = NULL;
1222 
1223   if (fixed_input) {
1224     conv_input = fixed_register_for(input-&gt;type());
1225     __ move(input, conv_input);
1226   }
1227 
1228   assert(fixed_result == false || round_result == false, &quot;cannot set both&quot;);
1229   if (fixed_result) {
1230     conv_result = fixed_register_for(result-&gt;type());
1231   } else if (round_result) {
1232     result = new_register(result-&gt;type());
1233     set_vreg_flag(result, must_start_in_memory);
1234   }
1235 
1236   if (needs_stub) {
1237     stub = new ConversionStub(x-&gt;op(), conv_input, conv_result);
1238   }
1239 
1240   __ convert(x-&gt;op(), conv_input, conv_result, stub);
1241 
1242   if (result != conv_result) {
1243     __ move(conv_result, result);
1244   }
1245 
1246   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1247   set_result(x, result);
1248 #endif // _LP64
1249 }
1250 
1251 
1252 void LIRGenerator::do_NewInstance(NewInstance* x) {
1253   print_if_not_loaded(x);
1254 
1255   CodeEmitInfo* info = state_for(x, x-&gt;state());
1256   LIR_Opr reg = result_register_for(x-&gt;type());
1257   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1258                        FrameMap::rcx_oop_opr,
1259                        FrameMap::rdi_oop_opr,
1260                        FrameMap::rsi_oop_opr,
1261                        LIR_OprFact::illegalOpr,
1262                        FrameMap::rdx_metadata_opr, info);
1263   LIR_Opr result = rlock_result(x);
1264   __ move(reg, result);
1265 }
1266 
1267 
1268 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
1269   CodeEmitInfo* info = state_for(x, x-&gt;state());
1270 
1271   LIRItem length(x-&gt;length(), this);
1272   length.load_item_force(FrameMap::rbx_opr);
1273 
1274   LIR_Opr reg = result_register_for(x-&gt;type());
1275   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1276   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1277   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1278   LIR_Opr tmp4 = reg;
1279   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1280   LIR_Opr len = length.result();
1281   BasicType elem_type = x-&gt;elt_type();
1282 
1283   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
1284 
1285   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
1286   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
1287 
1288   LIR_Opr result = rlock_result(x);
1289   __ move(reg, result);
1290 }
1291 
1292 
1293 void LIRGenerator::do_NewObjectArray(NewObjectArray* x) {
1294   LIRItem length(x-&gt;length(), this);
1295   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1296   // and therefore provide the state before the parameters have been consumed
1297   CodeEmitInfo* patching_info = NULL;
1298   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1299     patching_info =  state_for(x, x-&gt;state_before());
1300   }
1301 
1302   CodeEmitInfo* info = state_for(x, x-&gt;state());
1303 
1304   const LIR_Opr reg = result_register_for(x-&gt;type());
1305   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1306   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1307   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1308   LIR_Opr tmp4 = reg;
1309   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1310 
1311   length.load_item_force(FrameMap::rbx_opr);
1312   LIR_Opr len = length.result();
1313 
1314   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);
1315   ciKlass* obj = (ciKlass*) ciObjArrayKlass::make(x-&gt;klass());
1316   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1317     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1318   }
1319   klass2reg_with_patching(klass_reg, obj, patching_info);
1320   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
1321 
1322   LIR_Opr result = rlock_result(x);
1323   __ move(reg, result);
1324 }
1325 
1326 
1327 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1328   Values* dims = x-&gt;dims();
1329   int i = dims-&gt;length();
1330   LIRItemList* items = new LIRItemList(i, i, NULL);
1331   while (i-- &gt; 0) {
1332     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1333     items-&gt;at_put(i, size);
1334   }
1335 
1336   // Evaluate state_for early since it may emit code.
1337   CodeEmitInfo* patching_info = NULL;
1338   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1339     patching_info = state_for(x, x-&gt;state_before());
1340 
1341     // Cannot re-use same xhandlers for multiple CodeEmitInfos, so
1342     // clone all handlers (NOTE: Usually this is handled transparently
1343     // by the CodeEmitInfo cloning logic in CodeStub constructors but
1344     // is done explicitly here because a stub isn&#39;t being used).
1345     x-&gt;set_exception_handlers(new XHandlers(x-&gt;exception_handlers()));
1346   }
1347   CodeEmitInfo* info = state_for(x, x-&gt;state());
1348 
1349   i = dims-&gt;length();
1350   while (i-- &gt; 0) {
1351     LIRItem* size = items-&gt;at(i);
1352     size-&gt;load_nonconstant();
1353 
1354     store_stack_parameter(size-&gt;result(), in_ByteSize(i*4));
1355   }
1356 
1357   LIR_Opr klass_reg = FrameMap::rax_metadata_opr;
1358   klass2reg_with_patching(klass_reg, x-&gt;klass(), patching_info);
1359 
1360   LIR_Opr rank = FrameMap::rbx_opr;
1361   __ move(LIR_OprFact::intConst(x-&gt;rank()), rank);
1362   LIR_Opr varargs = FrameMap::rcx_opr;
1363   __ move(FrameMap::rsp_opr, varargs);
1364   LIR_OprList* args = new LIR_OprList(3);
1365   args-&gt;append(klass_reg);
1366   args-&gt;append(rank);
1367   args-&gt;append(varargs);
1368   LIR_Opr reg = result_register_for(x-&gt;type());
1369   __ call_runtime(Runtime1::entry_for(Runtime1::new_multi_array_id),
1370                   LIR_OprFact::illegalOpr,
1371                   reg, args, info);
1372 
1373   LIR_Opr result = rlock_result(x);
1374   __ move(reg, result);
1375 }
1376 
1377 
1378 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
1379   // nothing to do for now
1380 }
1381 
1382 
1383 void LIRGenerator::do_CheckCast(CheckCast* x) {
1384   LIRItem obj(x-&gt;obj(), this);
1385 
1386   CodeEmitInfo* patching_info = NULL;
1387   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1388     // must do this before locking the destination register as an oop register,
1389     // and before the obj is loaded (the latter is for deoptimization)
1390     patching_info = state_for(x, x-&gt;state_before());
1391   }
1392   obj.load_item();
1393 
1394   // info for exceptions
1395   CodeEmitInfo* info_for_exception =
1396       (x-&gt;needs_exception_state() ? state_for(x) :
1397                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
1398 
1399   CodeStub* stub;
1400   if (x-&gt;is_incompatible_class_change_check()) {
1401     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1402     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1403   } else if (x-&gt;is_invokespecial_receiver_check()) {
1404     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1405     stub = new DeoptimizeStub(info_for_exception, Deoptimization::Reason_class_check, Deoptimization::Action_none);
1406   } else {
1407     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1408   }
1409   LIR_Opr reg = rlock_result(x);
1410   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1411   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1412     tmp3 = new_register(objectType);
1413   }
1414   __ checkcast(reg, obj.result(), x-&gt;klass(),
1415                new_register(objectType), new_register(objectType), tmp3,
1416                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
1417                x-&gt;profiled_method(), x-&gt;profiled_bci());
1418 }
1419 
1420 
1421 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1422   LIRItem obj(x-&gt;obj(), this);
1423 
1424   // result and test object may not be in same register
1425   LIR_Opr reg = rlock_result(x);
1426   CodeEmitInfo* patching_info = NULL;
1427   if ((!x-&gt;klass()-&gt;is_loaded() || PatchALot)) {
1428     // must do this before locking the destination register as an oop register
1429     patching_info = state_for(x, x-&gt;state_before());
1430   }
1431   obj.load_item();
1432   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1433   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1434     tmp3 = new_register(objectType);
1435   }
1436   __ instanceof(reg, obj.result(), x-&gt;klass(),
1437                 new_register(objectType), new_register(objectType), tmp3,
1438                 x-&gt;direct_compare(), patching_info, x-&gt;profiled_method(), x-&gt;profiled_bci());
1439 }
1440 
1441 
1442 void LIRGenerator::do_If(If* x) {
1443   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1444   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1445   bool is_safepoint = x-&gt;is_safepoint();
1446 
1447   If::Condition cond = x-&gt;cond();
1448 
1449   LIRItem xitem(x-&gt;x(), this);
1450   LIRItem yitem(x-&gt;y(), this);
1451   LIRItem* xin = &amp;xitem;
1452   LIRItem* yin = &amp;yitem;
1453 
1454   if (tag == longTag) {
1455     // for longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
1456     // mirror for other conditions
1457     if (cond == If::gtr || cond == If::leq) {
1458       cond = Instruction::mirror(cond);
1459       xin = &amp;yitem;
1460       yin = &amp;xitem;
1461     }
1462     xin-&gt;set_destroys_register();
1463   }
1464   xin-&gt;load_item();
1465   if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp; (cond == If::eql || cond == If::neq)) {
1466     // inline long zero
1467     yin-&gt;dont_load_item();
1468   } else if (tag == longTag || tag == floatTag || tag == doubleTag) {
1469     // longs cannot handle constants at right side
1470     yin-&gt;load_item();
1471   } else {
1472     yin-&gt;dont_load_item();
1473   }
1474 
1475   LIR_Opr left = xin-&gt;result();
1476   LIR_Opr right = yin-&gt;result();
1477 
1478   set_no_result(x);
1479 
1480   // add safepoint before generating condition code so it can be recomputed
1481   if (x-&gt;is_safepoint()) {
1482     // increment backedge counter if needed
1483     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1484         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1485     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
1486   }
1487 
1488   __ cmp(lir_cond(cond), left, right);
1489   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1490   profile_branch(x, cond);
1491   move_to_phi(x-&gt;state());
1492   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
1493     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
1494   } else {
1495     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
1496   }
1497   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1498   __ jump(x-&gt;default_sux());
1499 }
1500 
1501 
1502 LIR_Opr LIRGenerator::getThreadPointer() {
1503 #ifdef _LP64
1504   return FrameMap::as_pointer_opr(r15_thread);
1505 #else
1506   LIR_Opr result = new_register(T_INT);
1507   __ get_thread(result);
1508   return result;
1509 #endif //
1510 }
1511 
1512 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1513   store_stack_parameter(LIR_OprFact::intConst(block-&gt;block_id()), in_ByteSize(0));
1514   LIR_OprList* args = new LIR_OprList();
1515   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1516   __ call_runtime_leaf(func, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, args);
1517 }
1518 
1519 
1520 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1521                                         CodeEmitInfo* info) {
1522   if (address-&gt;type() == T_LONG) {
1523     address = new LIR_Address(address-&gt;base(),
1524                               address-&gt;index(), address-&gt;scale(),
1525                               address-&gt;disp(), T_DOUBLE);
1526     // Transfer the value atomically by using FP moves.  This means
1527     // the value has to be moved between CPU and FPU registers.  It
1528     // always has to be moved through spill slot since there&#39;s no
1529     // quick way to pack the value into an SSE register.
1530     LIR_Opr temp_double = new_register(T_DOUBLE);
1531     LIR_Opr spill = new_register(T_LONG);
1532     set_vreg_flag(spill, must_start_in_memory);
1533     __ move(value, spill);
1534     __ volatile_move(spill, temp_double, T_LONG);
1535     __ volatile_move(temp_double, LIR_OprFact::address(address), T_LONG, info);
1536   } else {
1537     __ store(value, address, info);
1538   }
1539 }
1540 
1541 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1542                                        CodeEmitInfo* info) {
1543   if (address-&gt;type() == T_LONG) {
1544     address = new LIR_Address(address-&gt;base(),
1545                               address-&gt;index(), address-&gt;scale(),
1546                               address-&gt;disp(), T_DOUBLE);
1547     // Transfer the value atomically by using FP moves.  This means
1548     // the value has to be moved between CPU and FPU registers.  In
1549     // SSE0 and SSE1 mode it has to be moved through spill slot but in
1550     // SSE2+ mode it can be moved directly.
1551     LIR_Opr temp_double = new_register(T_DOUBLE);
1552     __ volatile_move(LIR_OprFact::address(address), temp_double, T_LONG, info);
1553     __ volatile_move(temp_double, result, T_LONG);
1554     if (UseSSE &lt; 2) {
1555       // no spill slot needed in SSE2 mode because xmm-&gt;cpu register move is possible
1556       set_vreg_flag(result, must_start_in_memory);
1557     }
1558   } else {
1559     __ load(address, result, info);
1560   }
1561 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/macroAssembler_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../x86/assembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/macroAssembler_sparc.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 461 
 462   // locating memory-based arguments
 463   Address as_address() const {
 464     assert(!is_register(), &quot;must be a memory argument&quot;);
 465     return address_in_frame();
 466   }
 467 
 468   // When applied to a register-based argument, give the corresponding address
 469   // into the 6-word area &quot;into which callee may store register arguments&quot;
 470   // (This is a different place than the corresponding register-save area location.)
 471   Address address_in_frame() const;
 472 
 473   // debugging
 474   const char* name() const;
 475 
 476   friend class Assembler;
 477 };
 478 
 479 
 480 class RegistersForDebugging : public StackObj {



 481  public:
 482   intptr_t i[8], l[8], o[8], g[8];
 483   float    f[32];
 484   double   d[32];
 485 
 486   void print(outputStream* s);
 487 
<span class="line-modified"> 488   static int i_offset(int j) { return offset_of(RegistersForDebugging, i[j]); }</span>
<span class="line-modified"> 489   static int l_offset(int j) { return offset_of(RegistersForDebugging, l[j]); }</span>
<span class="line-modified"> 490   static int o_offset(int j) { return offset_of(RegistersForDebugging, o[j]); }</span>
<span class="line-modified"> 491   static int g_offset(int j) { return offset_of(RegistersForDebugging, g[j]); }</span>
<span class="line-modified"> 492   static int f_offset(int j) { return offset_of(RegistersForDebugging, f[j]); }</span>
<span class="line-modified"> 493   static int d_offset(int j) { return offset_of(RegistersForDebugging, d[j / 2]); }</span>
 494 
 495   // gen asm code to save regs
 496   static void save_registers(MacroAssembler* a);
 497 
 498   // restore global registers in case C code disturbed them
 499   static void restore_registers(MacroAssembler* a, Register r);
 500 };
 501 
 502 
 503 // MacroAssembler extends Assembler by a few frequently used macros.
 504 //
 505 // Most of the standard SPARC synthetic ops are defined here.
 506 // Instructions for which a &#39;better&#39; code sequence exists depending
 507 // on arguments should also go in here.
 508 
 509 #define JMP2(r1, r2) jmp(r1, r2, __FILE__, __LINE__)
 510 #define JMP(r1, off) jmp(r1, off, __FILE__, __LINE__)
 511 #define JUMP(a, temp, off)     jump(a, temp, off, __FILE__, __LINE__)
 512 #define JUMPL(a, temp, d, off) jumpl(a, temp, d, off, __FILE__, __LINE__)
 513 
</pre>
</td>
<td>
<hr />
<pre>
 461 
 462   // locating memory-based arguments
 463   Address as_address() const {
 464     assert(!is_register(), &quot;must be a memory argument&quot;);
 465     return address_in_frame();
 466   }
 467 
 468   // When applied to a register-based argument, give the corresponding address
 469   // into the 6-word area &quot;into which callee may store register arguments&quot;
 470   // (This is a different place than the corresponding register-save area location.)
 471   Address address_in_frame() const;
 472 
 473   // debugging
 474   const char* name() const;
 475 
 476   friend class Assembler;
 477 };
 478 
 479 
 480 class RegistersForDebugging : public StackObj {
<span class="line-added"> 481  private:</span>
<span class="line-added"> 482   static const RegistersForDebugging&amp; _dummy; // not ODR-used so not defined</span>
<span class="line-added"> 483 </span>
 484  public:
 485   intptr_t i[8], l[8], o[8], g[8];
 486   float    f[32];
 487   double   d[32];
 488 
 489   void print(outputStream* s);
 490 
<span class="line-modified"> 491   static int i_offset(int j) { return offset_of(RegistersForDebugging, i) + j * sizeof(_dummy.i[0]); }</span>
<span class="line-modified"> 492   static int l_offset(int j) { return offset_of(RegistersForDebugging, l) + j * sizeof(_dummy.l[0]); }</span>
<span class="line-modified"> 493   static int o_offset(int j) { return offset_of(RegistersForDebugging, o) + j * sizeof(_dummy.o[0]); }</span>
<span class="line-modified"> 494   static int g_offset(int j) { return offset_of(RegistersForDebugging, g) + j * sizeof(_dummy.g[0]); }</span>
<span class="line-modified"> 495   static int f_offset(int j) { return offset_of(RegistersForDebugging, f) + j * sizeof(_dummy.f[0]); }</span>
<span class="line-modified"> 496   static int d_offset(int j) { return offset_of(RegistersForDebugging, d) + (j / 2) * sizeof(_dummy.d[0]); }</span>
 497 
 498   // gen asm code to save regs
 499   static void save_registers(MacroAssembler* a);
 500 
 501   // restore global registers in case C code disturbed them
 502   static void restore_registers(MacroAssembler* a, Register r);
 503 };
 504 
 505 
 506 // MacroAssembler extends Assembler by a few frequently used macros.
 507 //
 508 // Most of the standard SPARC synthetic ops are defined here.
 509 // Instructions for which a &#39;better&#39; code sequence exists depending
 510 // on arguments should also go in here.
 511 
 512 #define JMP2(r1, r2) jmp(r1, r2, __FILE__, __LINE__)
 513 #define JMP(r1, off) jmp(r1, off, __FILE__, __LINE__)
 514 #define JUMP(a, temp, off)     jump(a, temp, off, __FILE__, __LINE__)
 515 #define JUMPL(a, temp, d, off) jumpl(a, temp, d, off, __FILE__, __LINE__)
 516 
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../x86/assembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/ppc/c1_LIRAssembler_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2019, SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;nativeInst_ppc.hpp&quot;
  38 #include &quot;oops/compressedOops.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 
  44 #define __ _masm-&gt;
  45 
  46 
  47 const ConditionRegister LIR_Assembler::BOOL_RESULT = CCR5;
  48 
  49 
  50 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  51   Unimplemented(); return false; // Currently not used on this platform.
  52 }
  53 
  54 
  55 LIR_Opr LIR_Assembler::receiverOpr() {
  56   return FrameMap::R3_oop_opr;
  57 }
  58 
  59 
  60 LIR_Opr LIR_Assembler::osrBufferPointer() {
  61   return FrameMap::R3_opr;
  62 }
  63 
  64 
  65 // This specifies the stack pointer decrement needed to build the frame.
  66 int LIR_Assembler::initial_frame_size_in_bytes() const {
  67   return in_bytes(frame_map()-&gt;framesize_in_bytes());
  68 }
  69 
  70 
  71 // Inline cache check: the inline cached class is in inline_cache_reg;
  72 // we fetch the class of the receiver and compare it with the cached class.
  73 // If they do not match we jump to slow case.
  74 int LIR_Assembler::check_icache() {
  75   int offset = __ offset();
  76   __ inline_cache_check(R3_ARG1, R19_inline_cache_reg);
  77   return offset;
  78 }
  79 
  80 void LIR_Assembler::clinit_barrier(ciMethod* method) {
  81   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  82 
  83   Label L_skip_barrier;
  84   Register klass = R20;
  85 
  86   metadata2reg(method-&gt;holder()-&gt;constant_encoding(), klass);
  87   __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
  88 
  89   __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
  90   __ mtctr(klass);
  91   __ bctr();
  92 
  93   __ bind(L_skip_barrier);
  94 }
  95 
  96 void LIR_Assembler::osr_entry() {
  97   // On-stack-replacement entry sequence:
  98   //
  99   //   1. Create a new compiled activation.
 100   //   2. Initialize local variables in the compiled activation. The expression
 101   //      stack must be empty at the osr_bci; it is not initialized.
 102   //   3. Jump to the continuation address in compiled code to resume execution.
 103 
 104   // OSR entry point
 105   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 106   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 107   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
 108   int number_of_locks = entry_state-&gt;locks_size();
 109 
 110   // Create a frame for the compiled activation.
 111   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 112 
 113   // OSR buffer is
 114   //
 115   // locals[nlocals-1..0]
 116   // monitors[number_of_locks-1..0]
 117   //
 118   // Locals is a direct copy of the interpreter frame so in the osr buffer
 119   // the first slot in the local array is the last local from the interpreter
 120   // and the last slot is local[0] (receiver) from the interpreter.
 121   //
 122   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 123   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 124   // in the interpreter frame (the method lock if a sync method).
 125 
 126   // Initialize monitors in the compiled activation.
 127   //   R3: pointer to osr buffer
 128   //
 129   // All other registers are dead at this point and the locals will be
 130   // copied into place by code emitted in the IR.
 131 
 132   Register OSR_buf = osrBufferPointer()-&gt;as_register();
 133   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 134     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 135       (2 * BytesPerWord) * (number_of_locks - 1);
 136     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 137     // the OSR buffer using 2 word entries: first the lock and then
 138     // the oop.
 139     for (int i = 0; i &lt; number_of_locks; i++) {
 140       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 141 #ifdef ASSERT
 142       // Verify the interpreter&#39;s monitor has a non-null object.
 143       {
 144         Label L;
 145         __ ld(R0, slot_offset + 1*BytesPerWord, OSR_buf);
 146         __ cmpdi(CCR0, R0, 0);
 147         __ bne(CCR0, L);
 148         __ stop(&quot;locked object is NULL&quot;);
 149         __ bind(L);
 150       }
 151 #endif // ASSERT
 152       // Copy the lock field into the compiled activation.
 153       Address ml = frame_map()-&gt;address_for_monitor_lock(i),
 154               mo = frame_map()-&gt;address_for_monitor_object(i);
 155       assert(ml.index() == noreg &amp;&amp; mo.index() == noreg, &quot;sanity&quot;);
 156       __ ld(R0, slot_offset + 0, OSR_buf);
 157       __ std(R0, ml.disp(), ml.base());
 158       __ ld(R0, slot_offset + 1*BytesPerWord, OSR_buf);
 159       __ std(R0, mo.disp(), mo.base());
 160     }
 161   }
 162 }
 163 
 164 
 165 int LIR_Assembler::emit_exception_handler() {
 166   // If the last instruction is a call (typically to do a throw which
 167   // is coming at the end after block reordering) the return address
 168   // must still point into the code area in order to avoid assertion
 169   // failures when searching for the corresponding bci =&gt; add a nop
 170   // (was bug 5/14/1999 - gri).
 171   __ nop();
 172 
 173   // Generate code for the exception handler.
 174   address handler_base = __ start_a_stub(exception_handler_size());
 175 
 176   if (handler_base == NULL) {
 177     // Not enough space left for the handler.
 178     bailout(&quot;exception handler overflow&quot;);
 179     return -1;
 180   }
 181 
 182   int offset = code_offset();
 183   address entry_point = CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::handle_exception_from_callee_id));
 184   //__ load_const_optimized(R0, entry_point);
 185   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(entry_point));
 186   __ mtctr(R0);
 187   __ bctr();
 188 
 189   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 190   __ end_a_stub();
 191 
 192   return offset;
 193 }
 194 
 195 
 196 // Emit the code to remove the frame from the stack in the exception
 197 // unwind path.
 198 int LIR_Assembler::emit_unwind_handler() {
 199   _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 200 
 201   int offset = code_offset();
 202   bool preserve_exception = method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes();
 203   const Register Rexception = R3 /*LIRGenerator::exceptionOopOpr()*/, Rexception_save = R31;
 204 
 205   // Fetch the exception from TLS and clear out exception related thread state.
 206   __ ld(Rexception, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
 207   __ li(R0, 0);
 208   __ std(R0, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
 209   __ std(R0, in_bytes(JavaThread::exception_pc_offset()), R16_thread);
 210 
 211   __ bind(_unwind_handler_entry);
 212   __ verify_not_null_oop(Rexception);
 213   if (preserve_exception) { __ mr(Rexception_save, Rexception); }
 214 
 215   // Perform needed unlocking
 216   MonitorExitStub* stub = NULL;
 217   if (method()-&gt;is_synchronized()) {
 218     monitor_address(0, FrameMap::R4_opr);
 219     stub = new MonitorExitStub(FrameMap::R4_opr, true, 0);
 220     __ unlock_object(R5, R6, R4, *stub-&gt;entry());
 221     __ bind(*stub-&gt;continuation());
 222   }
 223 
 224   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 225     Unimplemented();
 226   }
 227 
 228   // Dispatch to the unwind logic.
 229   address unwind_stub = Runtime1::entry_for(Runtime1::unwind_exception_id);
 230   //__ load_const_optimized(R0, unwind_stub);
 231   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(unwind_stub));
 232   if (preserve_exception) { __ mr(Rexception, Rexception_save); }
 233   __ mtctr(R0);
 234   __ bctr();
 235 
 236   // Emit the slow path assembly.
 237   if (stub != NULL) {
 238     stub-&gt;emit_code(this);
 239   }
 240 
 241   return offset;
 242 }
 243 
 244 
 245 int LIR_Assembler::emit_deopt_handler() {
 246   // If the last instruction is a call (typically to do a throw which
 247   // is coming at the end after block reordering) the return address
 248   // must still point into the code area in order to avoid assertion
 249   // failures when searching for the corresponding bci =&gt; add a nop
 250   // (was bug 5/14/1999 - gri).
 251   __ nop();
 252 
 253   // Generate code for deopt handler.
 254   address handler_base = __ start_a_stub(deopt_handler_size());
 255 
 256   if (handler_base == NULL) {
 257     // Not enough space left for the handler.
 258     bailout(&quot;deopt handler overflow&quot;);
 259     return -1;
 260   }
 261 
 262   int offset = code_offset();
 263   __ bl64_patchable(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type);
 264 
 265   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 266   __ end_a_stub();
 267 
 268   return offset;
 269 }
 270 
 271 
 272 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 273   if (o == NULL) {
 274     __ li(reg, 0);
 275   } else {
 276     AddressLiteral addrlit = __ constant_oop_address(o);
 277     __ load_const(reg, addrlit, (reg != R0) ? R0 : noreg);
 278   }
 279 }
 280 
 281 
 282 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 283   // Allocate a new index in table to hold the object once it&#39;s been patched.
 284   int oop_index = __ oop_recorder()-&gt;allocate_oop_index(NULL);
 285   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), oop_index);
 286 
 287   AddressLiteral addrlit((address)NULL, oop_Relocation::spec(oop_index));
 288   __ load_const(reg, addrlit, R0);
 289 
 290   patching_epilog(patch, lir_patch_normal, reg, info);
 291 }
 292 
 293 
 294 void LIR_Assembler::metadata2reg(Metadata* o, Register reg) {
 295   AddressLiteral md = __ constant_metadata_address(o); // Notify OOP recorder (don&#39;t need the relocation)
 296   __ load_const_optimized(reg, md.value(), (reg != R0) ? R0 : noreg);
 297 }
 298 
 299 
 300 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo *info) {
 301   // Allocate a new index in table to hold the klass once it&#39;s been patched.
 302   int index = __ oop_recorder()-&gt;allocate_metadata_index(NULL);
 303   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 304 
 305   AddressLiteral addrlit((address)NULL, metadata_Relocation::spec(index));
 306   assert(addrlit.rspec().type() == relocInfo::metadata_type, &quot;must be an metadata reloc&quot;);
 307   __ load_const(reg, addrlit, R0);
 308 
 309   patching_epilog(patch, lir_patch_normal, reg, info);
 310 }
 311 
 312 
 313 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
 314   const bool is_int = result-&gt;is_single_cpu();
 315   Register Rdividend = is_int ? left-&gt;as_register() : left-&gt;as_register_lo();
 316   Register Rdivisor  = noreg;
 317   Register Rscratch  = temp-&gt;as_register();
 318   Register Rresult   = is_int ? result-&gt;as_register() : result-&gt;as_register_lo();
 319   long divisor = -1;
 320 
 321   if (right-&gt;is_register()) {
 322     Rdivisor = is_int ? right-&gt;as_register() : right-&gt;as_register_lo();
 323   } else {
 324     divisor = is_int ? right-&gt;as_constant_ptr()-&gt;as_jint()
 325                      : right-&gt;as_constant_ptr()-&gt;as_jlong();
 326   }
 327 
 328   assert(Rdividend != Rscratch, &quot;&quot;);
 329   assert(Rdivisor  != Rscratch, &quot;&quot;);
 330   assert(code == lir_idiv || code == lir_irem, &quot;Must be irem or idiv&quot;);
 331 
 332   if (Rdivisor == noreg) {
 333     if (divisor == 1) { // stupid, but can happen
 334       if (code == lir_idiv) {
 335         __ mr_if_needed(Rresult, Rdividend);
 336       } else {
 337         __ li(Rresult, 0);
 338       }
 339 
 340     } else if (is_power_of_2(divisor)) {
 341       // Convert division by a power of two into some shifts and logical operations.
 342       int log2 = log2_intptr(divisor);
 343 
 344       // Round towards 0.
 345       if (divisor == 2) {
 346         if (is_int) {
 347           __ srwi(Rscratch, Rdividend, 31);
 348         } else {
 349           __ srdi(Rscratch, Rdividend, 63);
 350         }
 351       } else {
 352         if (is_int) {
 353           __ srawi(Rscratch, Rdividend, 31);
 354         } else {
 355           __ sradi(Rscratch, Rdividend, 63);
 356         }
 357         __ clrldi(Rscratch, Rscratch, 64-log2);
 358       }
 359       __ add(Rscratch, Rdividend, Rscratch);
 360 
 361       if (code == lir_idiv) {
 362         if (is_int) {
 363           __ srawi(Rresult, Rscratch, log2);
 364         } else {
 365           __ sradi(Rresult, Rscratch, log2);
 366         }
 367       } else { // lir_irem
 368         __ clrrdi(Rscratch, Rscratch, log2);
 369         __ sub(Rresult, Rdividend, Rscratch);
 370       }
 371 
 372     } else if (divisor == -1) {
 373       if (code == lir_idiv) {
 374         __ neg(Rresult, Rdividend);
 375       } else {
 376         __ li(Rresult, 0);
 377       }
 378 
 379     } else {
 380       __ load_const_optimized(Rscratch, divisor);
 381       if (code == lir_idiv) {
 382         if (is_int) {
 383           __ divw(Rresult, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 384         } else {
 385           __ divd(Rresult, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 386         }
 387       } else {
 388         assert(Rscratch != R0, &quot;need both&quot;);
 389         if (is_int) {
 390           __ divw(R0, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 391           __ mullw(Rscratch, R0, Rscratch);
 392         } else {
 393           __ divd(R0, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 394           __ mulld(Rscratch, R0, Rscratch);
 395         }
 396         __ sub(Rresult, Rdividend, Rscratch);
 397       }
 398 
 399     }
 400     return;
 401   }
 402 
 403   Label regular, done;
 404   if (is_int) {
 405     __ cmpwi(CCR0, Rdivisor, -1);
 406   } else {
 407     __ cmpdi(CCR0, Rdivisor, -1);
 408   }
 409   __ bne(CCR0, regular);
 410   if (code == lir_idiv) {
 411     __ neg(Rresult, Rdividend);
 412     __ b(done);
 413     __ bind(regular);
 414     if (is_int) {
 415       __ divw(Rresult, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 416     } else {
 417       __ divd(Rresult, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 418     }
 419   } else { // lir_irem
 420     __ li(Rresult, 0);
 421     __ b(done);
 422     __ bind(regular);
 423     if (is_int) {
 424       __ divw(Rscratch, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 425       __ mullw(Rscratch, Rscratch, Rdivisor);
 426     } else {
 427       __ divd(Rscratch, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 428       __ mulld(Rscratch, Rscratch, Rdivisor);
 429     }
 430     __ sub(Rresult, Rdividend, Rscratch);
 431   }
 432   __ bind(done);
 433 }
 434 
 435 
 436 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 437   switch (op-&gt;code()) {
 438   case lir_idiv:
 439   case lir_irem:
 440     arithmetic_idiv(op-&gt;code(), op-&gt;in_opr1(), op-&gt;in_opr2(), op-&gt;in_opr3(),
 441                     op-&gt;result_opr(), op-&gt;info());
 442     break;
 443   case lir_fmad:
 444     __ fmadd(op-&gt;result_opr()-&gt;as_double_reg(), op-&gt;in_opr1()-&gt;as_double_reg(),
 445              op-&gt;in_opr2()-&gt;as_double_reg(), op-&gt;in_opr3()-&gt;as_double_reg());
 446     break;
 447   case lir_fmaf:
 448     __ fmadds(op-&gt;result_opr()-&gt;as_float_reg(), op-&gt;in_opr1()-&gt;as_float_reg(),
 449               op-&gt;in_opr2()-&gt;as_float_reg(), op-&gt;in_opr3()-&gt;as_float_reg());
 450     break;
 451   default: ShouldNotReachHere(); break;
 452   }
 453 }
 454 
 455 
 456 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
 457 #ifdef ASSERT
 458   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
 459   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
 460   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
 461   assert(op-&gt;info() == NULL, &quot;shouldn&#39;t have CodeEmitInfo&quot;);
 462 #endif
 463 
 464   Label *L = op-&gt;label();
 465   if (op-&gt;cond() == lir_cond_always) {
 466     __ b(*L);
 467   } else {
 468     Label done;
 469     bool is_unordered = false;
 470     if (op-&gt;code() == lir_cond_float_branch) {
 471       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
 472       is_unordered = true;
 473     } else {
 474       assert(op-&gt;code() == lir_branch, &quot;just checking&quot;);
 475     }
 476 
 477     bool positive = false;
 478     Assembler::Condition cond = Assembler::equal;
 479     switch (op-&gt;cond()) {
 480       case lir_cond_equal:        positive = true ; cond = Assembler::equal  ; is_unordered = false; break;
 481       case lir_cond_notEqual:     positive = false; cond = Assembler::equal  ; is_unordered = false; break;
 482       case lir_cond_less:         positive = true ; cond = Assembler::less   ; break;
 483       case lir_cond_belowEqual:   assert(op-&gt;code() != lir_cond_float_branch, &quot;&quot;); // fallthru
 484       case lir_cond_lessEqual:    positive = false; cond = Assembler::greater; break;
 485       case lir_cond_greater:      positive = true ; cond = Assembler::greater; break;
 486       case lir_cond_aboveEqual:   assert(op-&gt;code() != lir_cond_float_branch, &quot;&quot;); // fallthru
 487       case lir_cond_greaterEqual: positive = false; cond = Assembler::less   ; break;
 488       default:                    ShouldNotReachHere();
 489     }
 490     int bo = positive ? Assembler::bcondCRbiIs1 : Assembler::bcondCRbiIs0;
 491     int bi = Assembler::bi0(BOOL_RESULT, cond);
 492     if (is_unordered) {
 493       if (positive) {
 494         if (op-&gt;ublock() == op-&gt;block()) {
 495           __ bc_far_optimized(Assembler::bcondCRbiIs1, __ bi0(BOOL_RESULT, Assembler::summary_overflow), *L);
 496         }
 497       } else {
 498         if (op-&gt;ublock() != op-&gt;block()) { __ bso(BOOL_RESULT, done); }
 499       }
 500     }
 501     __ bc_far_optimized(bo, bi, *L);
 502     __ bind(done);
 503   }
 504 }
 505 
 506 
 507 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
 508   Bytecodes::Code code = op-&gt;bytecode();
 509   LIR_Opr src = op-&gt;in_opr(),
 510           dst = op-&gt;result_opr();
 511 
 512   switch(code) {
 513     case Bytecodes::_i2l: {
 514       __ extsw(dst-&gt;as_register_lo(), src-&gt;as_register());
 515       break;
 516     }
 517     case Bytecodes::_l2i: {
 518       __ mr_if_needed(dst-&gt;as_register(), src-&gt;as_register_lo()); // high bits are garbage
 519       break;
 520     }
 521     case Bytecodes::_i2b: {
 522       __ extsb(dst-&gt;as_register(), src-&gt;as_register());
 523       break;
 524     }
 525     case Bytecodes::_i2c: {
 526       __ clrldi(dst-&gt;as_register(), src-&gt;as_register(), 64-16);
 527       break;
 528     }
 529     case Bytecodes::_i2s: {
 530       __ extsh(dst-&gt;as_register(), src-&gt;as_register());
 531       break;
 532     }
 533     case Bytecodes::_i2d:
 534     case Bytecodes::_l2d: {
 535       bool src_in_memory = !VM_Version::has_mtfprd();
 536       FloatRegister rdst = dst-&gt;as_double_reg();
 537       FloatRegister rsrc;
 538       if (src_in_memory) {
 539         rsrc = src-&gt;as_double_reg(); // via mem
 540       } else {
 541         // move src to dst register
 542         if (code == Bytecodes::_i2d) {
 543           __ mtfprwa(rdst, src-&gt;as_register());
 544         } else {
 545           __ mtfprd(rdst, src-&gt;as_register_lo());
 546         }
 547         rsrc = rdst;
 548       }
 549       __ fcfid(rdst, rsrc);
 550       break;
 551     }
 552     case Bytecodes::_i2f:
 553     case Bytecodes::_l2f: {
 554       bool src_in_memory = !VM_Version::has_mtfprd();
 555       FloatRegister rdst = dst-&gt;as_float_reg();
 556       FloatRegister rsrc;
 557       if (src_in_memory) {
 558         rsrc = src-&gt;as_double_reg(); // via mem
 559       } else {
 560         // move src to dst register
 561         if (code == Bytecodes::_i2f) {
 562           __ mtfprwa(rdst, src-&gt;as_register());
 563         } else {
 564           __ mtfprd(rdst, src-&gt;as_register_lo());
 565         }
 566         rsrc = rdst;
 567       }
 568       if (VM_Version::has_fcfids()) {
 569         __ fcfids(rdst, rsrc);
 570       } else {
 571         assert(code == Bytecodes::_i2f, &quot;fcfid+frsp needs fixup code to avoid rounding incompatibility&quot;);
 572         __ fcfid(rdst, rsrc);
 573         __ frsp(rdst, rdst);
 574       }
 575       break;
 576     }
 577     case Bytecodes::_f2d: {
 578       __ fmr_if_needed(dst-&gt;as_double_reg(), src-&gt;as_float_reg());
 579       break;
 580     }
 581     case Bytecodes::_d2f: {
 582       __ frsp(dst-&gt;as_float_reg(), src-&gt;as_double_reg());
 583       break;
 584     }
 585     case Bytecodes::_d2i:
 586     case Bytecodes::_f2i: {
 587       bool dst_in_memory = !VM_Version::has_mtfprd();
 588       FloatRegister rsrc = (code == Bytecodes::_d2i) ? src-&gt;as_double_reg() : src-&gt;as_float_reg();
 589       Address       addr = dst_in_memory ? frame_map()-&gt;address_for_slot(dst-&gt;double_stack_ix()) : NULL;
 590       Label L;
 591       // Result must be 0 if value is NaN; test by comparing value to itself.
 592       __ fcmpu(CCR0, rsrc, rsrc);
 593       if (dst_in_memory) {
 594         __ li(R0, 0); // 0 in case of NAN
 595         __ std(R0, addr.disp(), addr.base());
 596       } else {
 597         __ li(dst-&gt;as_register(), 0);
 598       }
 599       __ bso(CCR0, L);
 600       __ fctiwz(rsrc, rsrc); // USE_KILL
 601       if (dst_in_memory) {
 602         __ stfd(rsrc, addr.disp(), addr.base());
 603       } else {
 604         __ mffprd(dst-&gt;as_register(), rsrc);
 605       }
 606       __ bind(L);
 607       break;
 608     }
 609     case Bytecodes::_d2l:
 610     case Bytecodes::_f2l: {
 611       bool dst_in_memory = !VM_Version::has_mtfprd();
 612       FloatRegister rsrc = (code == Bytecodes::_d2l) ? src-&gt;as_double_reg() : src-&gt;as_float_reg();
 613       Address       addr = dst_in_memory ? frame_map()-&gt;address_for_slot(dst-&gt;double_stack_ix()) : NULL;
 614       Label L;
 615       // Result must be 0 if value is NaN; test by comparing value to itself.
 616       __ fcmpu(CCR0, rsrc, rsrc);
 617       if (dst_in_memory) {
 618         __ li(R0, 0); // 0 in case of NAN
 619         __ std(R0, addr.disp(), addr.base());
 620       } else {
 621         __ li(dst-&gt;as_register_lo(), 0);
 622       }
 623       __ bso(CCR0, L);
 624       __ fctidz(rsrc, rsrc); // USE_KILL
 625       if (dst_in_memory) {
 626         __ stfd(rsrc, addr.disp(), addr.base());
 627       } else {
 628         __ mffprd(dst-&gt;as_register_lo(), rsrc);
 629       }
 630       __ bind(L);
 631       break;
 632     }
 633 
 634     default: ShouldNotReachHere();
 635   }
 636 }
 637 
 638 
 639 void LIR_Assembler::align_call(LIR_Code) {
 640   // do nothing since all instructions are word aligned on ppc
 641 }
 642 
 643 
 644 bool LIR_Assembler::emit_trampoline_stub_for_call(address target, Register Rtoc) {
 645   int start_offset = __ offset();
 646   // Put the entry point as a constant into the constant pool.
 647   const address entry_point_toc_addr   = __ address_constant(target, RelocationHolder::none);
 648   if (entry_point_toc_addr == NULL) {
 649     bailout(&quot;const section overflow&quot;);
 650     return false;
 651   }
 652   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 653 
 654   // Emit the trampoline stub which will be related to the branch-and-link below.
 655   address stub = __ emit_trampoline_stub(entry_point_toc_offset, start_offset, Rtoc);
 656   if (!stub) {
 657     bailout(&quot;no space for trampoline stub&quot;);
 658     return false;
 659   }
 660   return true;
 661 }
 662 
 663 
 664 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
 665   assert(rtype==relocInfo::opt_virtual_call_type || rtype==relocInfo::static_call_type, &quot;unexpected rtype&quot;);
 666 
 667   bool success = emit_trampoline_stub_for_call(op-&gt;addr());
 668   if (!success) { return; }
 669 
 670   __ relocate(rtype);
 671   // Note: At this point we do not have the address of the trampoline
 672   // stub, and the entry point might be too far away for bl, so __ pc()
 673   // serves as dummy and the bl will be patched later.
 674   __ code()-&gt;set_insts_mark();
 675   __ bl(__ pc());
 676   add_call_info(code_offset(), op-&gt;info());
 677 }
 678 
 679 
 680 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
 681   __ calculate_address_from_global_toc(R2_TOC, __ method_toc());
 682 
 683   // Virtual call relocation will point to ic load.
 684   address virtual_call_meta_addr = __ pc();
 685   // Load a clear inline cache.
 686   AddressLiteral empty_ic((address) Universe::non_oop_word());
 687   bool success = __ load_const_from_method_toc(R19_inline_cache_reg, empty_ic, R2_TOC);
 688   if (!success) {
 689     bailout(&quot;const section overflow&quot;);
 690     return;
 691   }
 692   // Call to fixup routine. Fixup routine uses ScopeDesc info
 693   // to determine who we intended to call.
 694   __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
 695 
 696   success = emit_trampoline_stub_for_call(op-&gt;addr(), R2_TOC);
 697   if (!success) { return; }
 698 
 699   // Note: At this point we do not have the address of the trampoline
 700   // stub, and the entry point might be too far away for bl, so __ pc()
 701   // serves as dummy and the bl will be patched later.
 702   __ bl(__ pc());
 703   add_call_info(code_offset(), op-&gt;info());
 704 }
 705 
 706 
 707 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
 708   ShouldNotReachHere(); // ic_call is used instead.
 709 }
 710 
 711 
 712 void LIR_Assembler::explicit_null_check(Register addr, CodeEmitInfo* info) {
 713   ImplicitNullCheckStub* stub = new ImplicitNullCheckStub(code_offset(), info);
 714   __ null_check(addr, stub-&gt;entry());
 715   append_code_stub(stub);
 716 }
 717 
 718 
 719 // Attention: caller must encode oop if needed
 720 int LIR_Assembler::store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide, bool unaligned) {
 721   int store_offset;
 722   if (!Assembler::is_simm16(offset)) {
 723     // For offsets larger than a simm16 we setup the offset.
 724     assert(wide &amp;&amp; !from_reg-&gt;is_same_register(FrameMap::R0_opr), &quot;large offset only supported in special case&quot;);
 725     __ load_const_optimized(R0, offset);
 726     store_offset = store(from_reg, base, R0, type, wide);
 727   } else {
 728     store_offset = code_offset();
 729     switch (type) {
 730       case T_BOOLEAN: // fall through
 731       case T_BYTE  : __ stb(from_reg-&gt;as_register(), offset, base); break;
 732       case T_CHAR  :
 733       case T_SHORT : __ sth(from_reg-&gt;as_register(), offset, base); break;
 734       case T_INT   : __ stw(from_reg-&gt;as_register(), offset, base); break;
 735       case T_LONG  : __ std(from_reg-&gt;as_register_lo(), offset, base); break;
 736       case T_ADDRESS:
 737       case T_METADATA: __ std(from_reg-&gt;as_register(), offset, base); break;
 738       case T_ARRAY : // fall through
 739       case T_OBJECT:
 740         {
 741           if (UseCompressedOops &amp;&amp; !wide) {
 742             // Encoding done in caller
 743             __ stw(from_reg-&gt;as_register(), offset, base);
 744             __ verify_coop(from_reg-&gt;as_register(), FILE_AND_LINE);
 745           } else {
 746             __ std(from_reg-&gt;as_register(), offset, base);
 747             __ verify_oop(from_reg-&gt;as_register(), FILE_AND_LINE);
 748           }
 749           break;
 750         }
 751       case T_FLOAT : __ stfs(from_reg-&gt;as_float_reg(), offset, base); break;
 752       case T_DOUBLE: __ stfd(from_reg-&gt;as_double_reg(), offset, base); break;
 753       default      : ShouldNotReachHere();
 754     }
 755   }
 756   return store_offset;
 757 }
 758 
 759 
 760 // Attention: caller must encode oop if needed
 761 int LIR_Assembler::store(LIR_Opr from_reg, Register base, Register disp, BasicType type, bool wide) {
 762   int store_offset = code_offset();
 763   switch (type) {
 764     case T_BOOLEAN: // fall through
 765     case T_BYTE  : __ stbx(from_reg-&gt;as_register(), base, disp); break;
 766     case T_CHAR  :
 767     case T_SHORT : __ sthx(from_reg-&gt;as_register(), base, disp); break;
 768     case T_INT   : __ stwx(from_reg-&gt;as_register(), base, disp); break;
 769     case T_LONG  :
 770 #ifdef _LP64
 771       __ stdx(from_reg-&gt;as_register_lo(), base, disp);
 772 #else
 773       Unimplemented();
 774 #endif
 775       break;
 776     case T_ADDRESS:
 777       __ stdx(from_reg-&gt;as_register(), base, disp);
 778       break;
 779     case T_ARRAY : // fall through
 780     case T_OBJECT:
 781       {
 782         if (UseCompressedOops &amp;&amp; !wide) {
 783           // Encoding done in caller.
 784           __ stwx(from_reg-&gt;as_register(), base, disp);
 785           __ verify_coop(from_reg-&gt;as_register(), FILE_AND_LINE); // kills R0
 786         } else {
 787           __ stdx(from_reg-&gt;as_register(), base, disp);
 788           __ verify_oop(from_reg-&gt;as_register(), FILE_AND_LINE); // kills R0
 789         }
 790         break;
 791       }
 792     case T_FLOAT : __ stfsx(from_reg-&gt;as_float_reg(), base, disp); break;
 793     case T_DOUBLE: __ stfdx(from_reg-&gt;as_double_reg(), base, disp); break;
 794     default      : ShouldNotReachHere();
 795   }
 796   return store_offset;
 797 }
 798 
 799 
 800 int LIR_Assembler::load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide, bool unaligned) {
 801   int load_offset;
 802   if (!Assembler::is_simm16(offset)) {
 803     // For offsets larger than a simm16 we setup the offset.
 804     __ load_const_optimized(R0, offset);
 805     load_offset = load(base, R0, to_reg, type, wide);
 806   } else {
 807     load_offset = code_offset();
 808     switch(type) {
 809       case T_BOOLEAN: // fall through
 810       case T_BYTE  :   __ lbz(to_reg-&gt;as_register(), offset, base);
 811                        __ extsb(to_reg-&gt;as_register(), to_reg-&gt;as_register()); break;
 812       case T_CHAR  :   __ lhz(to_reg-&gt;as_register(), offset, base); break;
 813       case T_SHORT :   __ lha(to_reg-&gt;as_register(), offset, base); break;
 814       case T_INT   :   __ lwa(to_reg-&gt;as_register(), offset, base); break;
 815       case T_LONG  :   __ ld(to_reg-&gt;as_register_lo(), offset, base); break;
 816       case T_METADATA: __ ld(to_reg-&gt;as_register(), offset, base); break;
 817       case T_ADDRESS:
 818         if (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; UseCompressedClassPointers) {
 819           __ lwz(to_reg-&gt;as_register(), offset, base);
 820           __ decode_klass_not_null(to_reg-&gt;as_register());
 821         } else {
 822           __ ld(to_reg-&gt;as_register(), offset, base);
 823         }
 824         break;
 825       case T_ARRAY : // fall through
 826       case T_OBJECT:
 827         {
 828           if (UseCompressedOops &amp;&amp; !wide) {
 829             __ lwz(to_reg-&gt;as_register(), offset, base);
 830             __ decode_heap_oop(to_reg-&gt;as_register());
 831           } else {
 832             __ ld(to_reg-&gt;as_register(), offset, base);
 833           }
 834           __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);
 835           break;
 836         }
 837       case T_FLOAT:  __ lfs(to_reg-&gt;as_float_reg(), offset, base); break;
 838       case T_DOUBLE: __ lfd(to_reg-&gt;as_double_reg(), offset, base); break;
 839       default      : ShouldNotReachHere();
 840     }
 841   }
 842   return load_offset;
 843 }
 844 
 845 
 846 int LIR_Assembler::load(Register base, Register disp, LIR_Opr to_reg, BasicType type, bool wide) {
 847   int load_offset = code_offset();
 848   switch(type) {
 849     case T_BOOLEAN: // fall through
 850     case T_BYTE  :  __ lbzx(to_reg-&gt;as_register(), base, disp);
 851                     __ extsb(to_reg-&gt;as_register(), to_reg-&gt;as_register()); break;
 852     case T_CHAR  :  __ lhzx(to_reg-&gt;as_register(), base, disp); break;
 853     case T_SHORT :  __ lhax(to_reg-&gt;as_register(), base, disp); break;
 854     case T_INT   :  __ lwax(to_reg-&gt;as_register(), base, disp); break;
 855     case T_ADDRESS: __ ldx(to_reg-&gt;as_register(), base, disp); break;
 856     case T_ARRAY : // fall through
 857     case T_OBJECT:
 858       {
 859         if (UseCompressedOops &amp;&amp; !wide) {
 860           __ lwzx(to_reg-&gt;as_register(), base, disp);
 861           __ decode_heap_oop(to_reg-&gt;as_register());
 862         } else {
 863           __ ldx(to_reg-&gt;as_register(), base, disp);
 864         }
 865         __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);
 866         break;
 867       }
 868     case T_FLOAT:  __ lfsx(to_reg-&gt;as_float_reg() , base, disp); break;
 869     case T_DOUBLE: __ lfdx(to_reg-&gt;as_double_reg(), base, disp); break;
 870     case T_LONG  :
 871 #ifdef _LP64
 872       __ ldx(to_reg-&gt;as_register_lo(), base, disp);
 873 #else
 874       Unimplemented();
 875 #endif
 876       break;
 877     default      : ShouldNotReachHere();
 878   }
 879   return load_offset;
 880 }
 881 
 882 
 883 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 884   LIR_Const* c = src-&gt;as_constant_ptr();
 885   Register src_reg = R0;
 886   switch (c-&gt;type()) {
 887     case T_INT:
 888     case T_FLOAT: {
 889       int value = c-&gt;as_jint_bits();
 890       __ load_const_optimized(src_reg, value);
 891       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 892       __ stw(src_reg, addr.disp(), addr.base());
 893       break;
 894     }
 895     case T_ADDRESS: {
 896       int value = c-&gt;as_jint_bits();
 897       __ load_const_optimized(src_reg, value);
 898       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 899       __ std(src_reg, addr.disp(), addr.base());
 900       break;
 901     }
 902     case T_OBJECT: {
 903       jobject2reg(c-&gt;as_jobject(), src_reg);
 904       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 905       __ std(src_reg, addr.disp(), addr.base());
 906       break;
 907     }
 908     case T_LONG:
 909     case T_DOUBLE: {
 910       int value = c-&gt;as_jlong_bits();
 911       __ load_const_optimized(src_reg, value);
 912       Address addr = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
 913       __ std(src_reg, addr.disp(), addr.base());
 914       break;
 915     }
 916     default:
 917       Unimplemented();
 918   }
 919 }
 920 
 921 
 922 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 923   LIR_Const* c = src-&gt;as_constant_ptr();
 924   LIR_Address* addr = dest-&gt;as_address_ptr();
 925   Register base = addr-&gt;base()-&gt;as_pointer_register();
 926   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 927   int offset = -1;
 928   // Null check for large offsets in LIRGenerator::do_StoreField.
 929   bool needs_explicit_null_check = !ImplicitNullChecks;
 930 
 931   if (info != NULL &amp;&amp; needs_explicit_null_check) {
 932     explicit_null_check(base, info);
 933   }
 934 
 935   switch (c-&gt;type()) {
 936     case T_FLOAT: type = T_INT;
 937     case T_INT:
 938     case T_ADDRESS: {
 939       tmp = FrameMap::R0_opr;
 940       __ load_const_optimized(tmp-&gt;as_register(), c-&gt;as_jint_bits());
 941       break;
 942     }
 943     case T_DOUBLE: type = T_LONG;
 944     case T_LONG: {
 945       tmp = FrameMap::R0_long_opr;
 946       __ load_const_optimized(tmp-&gt;as_register_lo(), c-&gt;as_jlong_bits());
 947       break;
 948     }
 949     case T_OBJECT: {
 950       tmp = FrameMap::R0_opr;
 951       if (UseCompressedOops &amp;&amp; !wide &amp;&amp; c-&gt;as_jobject() != NULL) {
 952         AddressLiteral oop_addr = __ constant_oop_address(c-&gt;as_jobject());
 953         __ lis(R0, oop_addr.value() &gt;&gt; 16); // Don&#39;t care about sign extend (will use stw).
 954         __ relocate(oop_addr.rspec(), /*compressed format*/ 1);
 955         __ ori(R0, R0, oop_addr.value() &amp; 0xffff);
 956       } else {
 957         jobject2reg(c-&gt;as_jobject(), R0);
 958       }
 959       break;
 960     }
 961     default:
 962       Unimplemented();
 963   }
 964 
 965   // Handle either reg+reg or reg+disp address.
 966   if (addr-&gt;index()-&gt;is_valid()) {
 967     assert(addr-&gt;disp() == 0, &quot;must be zero&quot;);
 968     offset = store(tmp, base, addr-&gt;index()-&gt;as_pointer_register(), type, wide);
 969   } else {
 970     assert(Assembler::is_simm16(addr-&gt;disp()), &quot;can&#39;t handle larger addresses&quot;);
 971     offset = store(tmp, base, addr-&gt;disp(), type, wide, false);
 972   }
 973 
 974   if (info != NULL) {
 975     assert(offset != -1, &quot;offset should&#39;ve been set&quot;);
 976     if (!needs_explicit_null_check) {
 977       add_debug_info_for_null_check(offset, info);
 978     }
 979   }
 980 }
 981 
 982 
 983 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 984   LIR_Const* c = src-&gt;as_constant_ptr();
 985   LIR_Opr to_reg = dest;
 986 
 987   switch (c-&gt;type()) {
 988     case T_INT: {
 989       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 990       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint(), R0);
 991       break;
 992     }
 993     case T_ADDRESS: {
 994       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 995       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint(), R0);  // Yes, as_jint ...
 996       break;
 997     }
 998     case T_LONG: {
 999       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
1000       __ load_const_optimized(dest-&gt;as_register_lo(), c-&gt;as_jlong(), R0);
1001       break;
1002     }
1003 
1004     case T_OBJECT: {
1005       if (patch_code == lir_patch_none) {
1006         jobject2reg(c-&gt;as_jobject(), to_reg-&gt;as_register());
1007       } else {
1008         jobject2reg_with_patching(to_reg-&gt;as_register(), info);
1009       }
1010       break;
1011     }
1012 
1013     case T_METADATA:
1014       {
1015         if (patch_code == lir_patch_none) {
1016           metadata2reg(c-&gt;as_metadata(), to_reg-&gt;as_register());
1017         } else {
1018           klass2reg_with_patching(to_reg-&gt;as_register(), info);
1019         }
1020       }
1021       break;
1022 
1023     case T_FLOAT:
1024       {
1025         if (to_reg-&gt;is_single_fpu()) {
1026           address const_addr = __ float_constant(c-&gt;as_jfloat());
1027           if (const_addr == NULL) {
1028             bailout(&quot;const section overflow&quot;);
1029             break;
1030           }
1031           RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1032           __ relocate(rspec);
1033           __ load_const(R0, const_addr);
1034           __ lfsx(to_reg-&gt;as_float_reg(), R0);
1035         } else {
1036           assert(to_reg-&gt;is_single_cpu(), &quot;Must be a cpu register.&quot;);
1037           __ load_const_optimized(to_reg-&gt;as_register(), jint_cast(c-&gt;as_jfloat()), R0);
1038         }
1039       }
1040       break;
1041 
1042     case T_DOUBLE:
1043       {
1044         if (to_reg-&gt;is_double_fpu()) {
1045           address const_addr = __ double_constant(c-&gt;as_jdouble());
1046           if (const_addr == NULL) {
1047             bailout(&quot;const section overflow&quot;);
1048             break;
1049           }
1050           RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1051           __ relocate(rspec);
1052           __ load_const(R0, const_addr);
1053           __ lfdx(to_reg-&gt;as_double_reg(), R0);
1054         } else {
1055           assert(to_reg-&gt;is_double_cpu(), &quot;Must be a long register.&quot;);
1056           __ load_const_optimized(to_reg-&gt;as_register_lo(), jlong_cast(c-&gt;as_jdouble()), R0);
1057         }
1058       }
1059       break;
1060 
1061     default:
1062       ShouldNotReachHere();
1063   }
1064 }
1065 
1066 
1067 Address LIR_Assembler::as_Address(LIR_Address* addr) {
1068   Unimplemented(); return Address();
1069 }
1070 
1071 
1072 inline RegisterOrConstant index_or_disp(LIR_Address* addr) {
1073   if (addr-&gt;index()-&gt;is_illegal()) {
1074     return (RegisterOrConstant)(addr-&gt;disp());
1075   } else {
1076     return (RegisterOrConstant)(addr-&gt;index()-&gt;as_pointer_register());
1077   }
1078 }
1079 
1080 
1081 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1082   const Register tmp = R0;
1083   switch (type) {
1084     case T_INT:
1085     case T_FLOAT: {
1086       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1087       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1088       __ lwz(tmp, from.disp(), from.base());
1089       __ stw(tmp, to.disp(), to.base());
1090       break;
1091     }
1092     case T_ADDRESS:
1093     case T_OBJECT: {
1094       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1095       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1096       __ ld(tmp, from.disp(), from.base());
1097       __ std(tmp, to.disp(), to.base());
1098       break;
1099     }
1100     case T_LONG:
1101     case T_DOUBLE: {
1102       Address from = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1103       Address to   = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
1104       __ ld(tmp, from.disp(), from.base());
1105       __ std(tmp, to.disp(), to.base());
1106       break;
1107     }
1108 
1109     default:
1110       ShouldNotReachHere();
1111   }
1112 }
1113 
1114 
1115 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
1116   Unimplemented(); return Address();
1117 }
1118 
1119 
1120 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
1121   Unimplemented(); return Address();
1122 }
1123 
1124 
1125 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type,
1126                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool unaligned) {
1127 
1128   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
1129   LIR_Address* addr = src_opr-&gt;as_address_ptr();
1130   LIR_Opr to_reg = dest;
1131 
1132   Register src = addr-&gt;base()-&gt;as_pointer_register();
1133   Register disp_reg = noreg;
1134   int disp_value = addr-&gt;disp();
1135   bool needs_patching = (patch_code != lir_patch_none);
1136   // null check for large offsets in LIRGenerator::do_LoadField
1137   bool needs_explicit_null_check = !os::zero_page_read_protected() || !ImplicitNullChecks;
1138 
1139   if (info != NULL &amp;&amp; needs_explicit_null_check) {
1140     explicit_null_check(src, info);
1141   }
1142 
1143   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1144     __ verify_oop(src, FILE_AND_LINE);
1145   }
1146 
1147   PatchingStub* patch = NULL;
1148   if (needs_patching) {
1149     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1150     assert(!to_reg-&gt;is_double_cpu() ||
1151            patch_code == lir_patch_none ||
1152            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1153   }
1154 
1155   if (addr-&gt;index()-&gt;is_illegal()) {
1156     if (!Assembler::is_simm16(disp_value)) {
1157       if (needs_patching) {
1158         __ load_const32(R0, 0); // patchable int
1159       } else {
1160         __ load_const_optimized(R0, disp_value);
1161       }
1162       disp_reg = R0;
1163     }
1164   } else {
1165     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1166     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1167   }
1168 
1169   // Remember the offset of the load. The patching_epilog must be done
1170   // before the call to add_debug_info, otherwise the PcDescs don&#39;t get
1171   // entered in increasing order.
1172   int offset;
1173 
1174   if (disp_reg == noreg) {
1175     assert(Assembler::is_simm16(disp_value), &quot;should have set this up&quot;);
1176     offset = load(src, disp_value, to_reg, type, wide, unaligned);
1177   } else {
1178     assert(!unaligned, &quot;unexpected&quot;);
1179     offset = load(src, disp_reg, to_reg, type, wide);
1180   }
1181 
1182   if (patch != NULL) {
1183     patching_epilog(patch, patch_code, src, info);
1184   }
1185   if (info != NULL &amp;&amp; !needs_explicit_null_check) {
1186     add_debug_info_for_null_check(offset, info);
1187   }
1188 }
1189 
1190 
1191 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1192   Address addr;
1193   if (src-&gt;is_single_word()) {
1194     addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1195   } else if (src-&gt;is_double_word())  {
1196     addr = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1197   }
1198 
1199   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1200   load(addr.base(), addr.disp(), dest, dest-&gt;type(), true /*wide*/, unaligned);
1201 }
1202 
1203 
1204 void LIR_Assembler::reg2stack(LIR_Opr from_reg, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1205   Address addr;
1206   if (dest-&gt;is_single_word()) {
1207     addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1208   } else if (dest-&gt;is_double_word())  {
1209     addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1210   }
1211   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1212   store(from_reg, addr.base(), addr.disp(), from_reg-&gt;type(), true /*wide*/, unaligned);
1213 }
1214 
1215 
1216 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1217   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
1218     if (from_reg-&gt;is_double_fpu()) {
1219       // double to double moves
1220       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1221       __ fmr_if_needed(to_reg-&gt;as_double_reg(), from_reg-&gt;as_double_reg());
1222     } else {
1223       // float to float moves
1224       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1225       __ fmr_if_needed(to_reg-&gt;as_float_reg(), from_reg-&gt;as_float_reg());
1226     }
1227   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1228     if (from_reg-&gt;is_double_cpu()) {
1229       __ mr_if_needed(to_reg-&gt;as_pointer_register(), from_reg-&gt;as_pointer_register());
1230     } else if (to_reg-&gt;is_double_cpu()) {
1231       // int to int moves
1232       __ mr_if_needed(to_reg-&gt;as_register_lo(), from_reg-&gt;as_register());
1233     } else {
1234       // int to int moves
1235       __ mr_if_needed(to_reg-&gt;as_register(), from_reg-&gt;as_register());
1236     }
1237   } else {
1238     ShouldNotReachHere();
1239   }
1240   if (is_reference_type(to_reg-&gt;type())) {
1241     __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);
1242   }
1243 }
1244 
1245 
1246 void LIR_Assembler::reg2mem(LIR_Opr from_reg, LIR_Opr dest, BasicType type,
1247                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1248                             bool wide, bool unaligned) {
1249   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1250   LIR_Address* addr = dest-&gt;as_address_ptr();
1251 
1252   Register src = addr-&gt;base()-&gt;as_pointer_register();
1253   Register disp_reg = noreg;
1254   int disp_value = addr-&gt;disp();
1255   bool needs_patching = (patch_code != lir_patch_none);
1256   bool compress_oop = (is_reference_type(type)) &amp;&amp; UseCompressedOops &amp;&amp; !wide &amp;&amp;
1257                       CompressedOops::mode() != CompressedOops::UnscaledNarrowOop;
1258   bool load_disp = addr-&gt;index()-&gt;is_illegal() &amp;&amp; !Assembler::is_simm16(disp_value);
1259   bool use_R29 = compress_oop &amp;&amp; load_disp; // Avoid register conflict, also do null check before killing R29.
1260   // Null check for large offsets in LIRGenerator::do_StoreField.
1261   bool needs_explicit_null_check = !ImplicitNullChecks || use_R29;
1262 
1263   if (info != NULL &amp;&amp; needs_explicit_null_check) {
1264     explicit_null_check(src, info);
1265   }
1266 
1267   if (addr-&gt;base()-&gt;is_oop_register()) {
1268     __ verify_oop(src, FILE_AND_LINE);
1269   }
1270 
1271   PatchingStub* patch = NULL;
1272   if (needs_patching) {
1273     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1274     assert(!from_reg-&gt;is_double_cpu() ||
1275            patch_code == lir_patch_none ||
1276            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1277   }
1278 
1279   if (addr-&gt;index()-&gt;is_illegal()) {
1280     if (load_disp) {
1281       disp_reg = use_R29 ? R29_TOC : R0;
1282       if (needs_patching) {
1283         __ load_const32(disp_reg, 0); // patchable int
1284       } else {
1285         __ load_const_optimized(disp_reg, disp_value);
1286       }
1287     }
1288   } else {
1289     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1290     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1291   }
1292 
1293   // remember the offset of the store. The patching_epilog must be done
1294   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1295   // entered in increasing order.
1296   int offset;
1297 
1298   if (compress_oop) {
1299     Register co = __ encode_heap_oop(R0, from_reg-&gt;as_register());
1300     from_reg = FrameMap::as_opr(co);
1301   }
1302 
1303   if (disp_reg == noreg) {
1304     assert(Assembler::is_simm16(disp_value), &quot;should have set this up&quot;);
1305     offset = store(from_reg, src, disp_value, type, wide, unaligned);
1306   } else {
1307     assert(!unaligned, &quot;unexpected&quot;);
1308     offset = store(from_reg, src, disp_reg, type, wide);
1309   }
1310 
1311   if (use_R29) {
1312     __ load_const_optimized(R29_TOC, MacroAssembler::global_toc(), R0); // reinit
1313   }
1314 
1315   if (patch != NULL) {
1316     patching_epilog(patch, patch_code, src, info);
1317   }
1318 
1319   if (info != NULL &amp;&amp; !needs_explicit_null_check) {
1320     add_debug_info_for_null_check(offset, info);
1321   }
1322 }
1323 
1324 
1325 void LIR_Assembler::return_op(LIR_Opr result) {
1326   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
1327   const Register polling_page     = R12;
1328 
1329   // Pop the stack before the safepoint code.
1330   int frame_size = initial_frame_size_in_bytes();
1331   if (Assembler::is_simm(frame_size, 16)) {
1332     __ addi(R1_SP, R1_SP, frame_size);
1333   } else {
1334     __ pop_frame();
1335   }
1336 
1337   if (SafepointMechanism::uses_thread_local_poll()) {
1338     __ ld(polling_page, in_bytes(Thread::polling_page_offset()), R16_thread);
1339   } else {
1340     __ load_const_optimized(polling_page, (long)(address) os::get_polling_page(), R0);
1341   }
1342 
1343   // Restore return pc relative to callers&#39; sp.
1344   __ ld(return_pc, _abi(lr), R1_SP);
1345   // Move return pc to LR.
1346   __ mtlr(return_pc);
1347 
1348   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1349     __ reserved_stack_check(return_pc);
1350   }
1351 
1352   // We need to mark the code position where the load from the safepoint
1353   // polling page was emitted as relocInfo::poll_return_type here.
1354   __ relocate(relocInfo::poll_return_type);
1355   __ load_from_polling_page(polling_page);
1356 
1357   // Return.
1358   __ blr();
1359 }
1360 
1361 
1362 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
1363   const Register poll_addr = tmp-&gt;as_register();
1364   if (SafepointMechanism::uses_thread_local_poll()) {
1365     __ ld(poll_addr, in_bytes(Thread::polling_page_offset()), R16_thread);
1366   } else {
1367     __ load_const_optimized(poll_addr, (intptr_t)os::get_polling_page(), R0);
1368   }
1369   if (info != NULL) {
1370     add_debug_info_for_branch(info);
1371   }
1372   int offset = __ offset();
1373   __ relocate(relocInfo::poll_type);
1374   __ load_from_polling_page(poll_addr);
1375 
1376   return offset;
1377 }
1378 
1379 
1380 void LIR_Assembler::emit_static_call_stub() {
1381   address call_pc = __ pc();
1382   address stub = __ start_a_stub(static_call_stub_size());
1383   if (stub == NULL) {
1384     bailout(&quot;static call stub overflow&quot;);
1385     return;
1386   }
1387 
1388   // For java_to_interp stubs we use R11_scratch1 as scratch register
1389   // and in call trampoline stubs we use R12_scratch2. This way we
1390   // can distinguish them (see is_NativeCallTrampolineStub_at()).
1391   const Register reg_scratch = R11_scratch1;
1392 
1393   // Create a static stub relocation which relates this stub
1394   // with the call instruction at insts_call_instruction_offset in the
1395   // instructions code-section.
1396   int start = __ offset();
1397   __ relocate(static_stub_Relocation::spec(call_pc));
1398 
1399   // Now, create the stub&#39;s code:
1400   // - load the TOC
1401   // - load the inline cache oop from the constant pool
1402   // - load the call target from the constant pool
1403   // - call
1404   __ calculate_address_from_global_toc(reg_scratch, __ method_toc());
1405   AddressLiteral ic = __ allocate_metadata_address((Metadata *)NULL);
1406   bool success = __ load_const_from_method_toc(R19_inline_cache_reg, ic, reg_scratch, /*fixed_size*/ true);
1407 
1408   if (ReoptimizeCallSequences) {
1409     __ b64_patchable((address)-1, relocInfo::none);
1410   } else {
1411     AddressLiteral a((address)-1);
1412     success = success &amp;&amp; __ load_const_from_method_toc(reg_scratch, a, reg_scratch, /*fixed_size*/ true);
1413     __ mtctr(reg_scratch);
1414     __ bctr();
1415   }
1416   if (!success) {
1417     bailout(&quot;const section overflow&quot;);
1418     return;
1419   }
1420 
1421   assert(__ offset() - start &lt;= static_call_stub_size(), &quot;stub too big&quot;);
1422   __ end_a_stub();
1423 }
1424 
1425 
1426 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1427   bool unsigned_comp = (condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual);
1428   if (opr1-&gt;is_single_fpu()) {
1429     __ fcmpu(BOOL_RESULT, opr1-&gt;as_float_reg(), opr2-&gt;as_float_reg());
1430   } else if (opr1-&gt;is_double_fpu()) {
1431     __ fcmpu(BOOL_RESULT, opr1-&gt;as_double_reg(), opr2-&gt;as_double_reg());
1432   } else if (opr1-&gt;is_single_cpu()) {
1433     if (opr2-&gt;is_constant()) {
1434       switch (opr2-&gt;as_constant_ptr()-&gt;type()) {
1435         case T_INT:
1436           {
1437             jint con = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1438             if (unsigned_comp) {
1439               if (Assembler::is_uimm(con, 16)) {
1440                 __ cmplwi(BOOL_RESULT, opr1-&gt;as_register(), con);
1441               } else {
1442                 __ load_const_optimized(R0, con);
1443                 __ cmplw(BOOL_RESULT, opr1-&gt;as_register(), R0);
1444               }
1445             } else {
1446               if (Assembler::is_simm(con, 16)) {
1447                 __ cmpwi(BOOL_RESULT, opr1-&gt;as_register(), con);
1448               } else {
1449                 __ load_const_optimized(R0, con);
1450                 __ cmpw(BOOL_RESULT, opr1-&gt;as_register(), R0);
1451               }
1452             }
1453           }
1454           break;
1455 
1456         case T_OBJECT:
1457           // There are only equal/notequal comparisons on objects.
1458           {
1459             assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1460             jobject con = opr2-&gt;as_constant_ptr()-&gt;as_jobject();
1461             if (con == NULL) {
1462               __ cmpdi(BOOL_RESULT, opr1-&gt;as_register(), 0);
1463             } else {
1464               jobject2reg(con, R0);
1465               __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), R0);
1466             }
1467           }
1468           break;
1469 
1470         case T_METADATA:
1471           // We only need, for now, comparison with NULL for metadata.
1472           {
1473             assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1474             Metadata* p = opr2-&gt;as_constant_ptr()-&gt;as_metadata();
1475             if (p == NULL) {
1476               __ cmpdi(BOOL_RESULT, opr1-&gt;as_register(), 0);
1477             } else {
1478               ShouldNotReachHere();
1479             }
1480           }
1481           break;
1482 
1483         default:
1484           ShouldNotReachHere();
1485           break;
1486       }
1487     } else {
1488       assert(opr1-&gt;type() != T_ADDRESS &amp;&amp; opr2-&gt;type() != T_ADDRESS, &quot;currently unsupported&quot;);
1489       if (is_reference_type(opr1-&gt;type())) {
1490         // There are only equal/notequal comparisons on objects.
1491         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1492         __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
1493       } else {
1494         if (unsigned_comp) {
1495           __ cmplw(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
1496         } else {
1497           __ cmpw(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
1498         }
1499       }
1500     }
1501   } else if (opr1-&gt;is_double_cpu()) {
1502     if (opr2-&gt;is_constant()) {
1503       jlong con = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
1504       if (unsigned_comp) {
1505         if (Assembler::is_uimm(con, 16)) {
1506           __ cmpldi(BOOL_RESULT, opr1-&gt;as_register_lo(), con);
1507         } else {
1508           __ load_const_optimized(R0, con);
1509           __ cmpld(BOOL_RESULT, opr1-&gt;as_register_lo(), R0);
1510         }
1511       } else {
1512         if (Assembler::is_simm(con, 16)) {
1513           __ cmpdi(BOOL_RESULT, opr1-&gt;as_register_lo(), con);
1514         } else {
1515           __ load_const_optimized(R0, con);
1516           __ cmpd(BOOL_RESULT, opr1-&gt;as_register_lo(), R0);
1517         }
1518       }
1519     } else if (opr2-&gt;is_register()) {
1520       if (unsigned_comp) {
1521         __ cmpld(BOOL_RESULT, opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo());
1522       } else {
1523         __ cmpd(BOOL_RESULT, opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo());
1524       }
1525     } else {
1526       ShouldNotReachHere();
1527     }
1528   } else {
1529     ShouldNotReachHere();
1530   }
1531 }
1532 
1533 
1534 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
1535   const Register Rdst = dst-&gt;as_register();
1536   Label done;
1537   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
1538     bool is_unordered_less = (code == lir_ucmp_fd2i);
1539     if (left-&gt;is_single_fpu()) {
1540       __ fcmpu(CCR0, left-&gt;as_float_reg(), right-&gt;as_float_reg());
1541     } else if (left-&gt;is_double_fpu()) {
1542       __ fcmpu(CCR0, left-&gt;as_double_reg(), right-&gt;as_double_reg());
1543     } else {
1544       ShouldNotReachHere();
1545     }
1546     __ li(Rdst, is_unordered_less ? -1 : 1);
1547     __ bso(CCR0, done);
1548   } else if (code == lir_cmp_l2i) {
1549     __ cmpd(CCR0, left-&gt;as_register_lo(), right-&gt;as_register_lo());
1550   } else {
1551     ShouldNotReachHere();
1552   }
1553   __ mfcr(R0); // set bit 32..33 as follows: &lt;: 0b10, =: 0b00, &gt;: 0b01
1554   __ srwi(Rdst, R0, 30);
1555   __ srawi(R0, R0, 31);
1556   __ orr(Rdst, R0, Rdst); // set result as follows: &lt;: -1, =: 0, &gt;: 1
1557   __ bind(done);
1558 }
1559 
1560 
1561 inline void load_to_reg(LIR_Assembler *lasm, LIR_Opr src, LIR_Opr dst) {
1562   if (src-&gt;is_constant()) {
1563     lasm-&gt;const2reg(src, dst, lir_patch_none, NULL);
1564   } else if (src-&gt;is_register()) {
1565     lasm-&gt;reg2reg(src, dst);
1566   } else if (src-&gt;is_stack()) {
1567     lasm-&gt;stack2reg(src, dst, dst-&gt;type());
1568   } else {
1569     ShouldNotReachHere();
1570   }
1571 }
1572 
1573 
1574 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1575   if (opr1-&gt;is_equal(opr2) || opr1-&gt;is_same_register(opr2)) {
1576     load_to_reg(this, opr1, result); // Condition doesn&#39;t matter.
1577     return;
1578   }
1579 
1580   bool positive = false;
1581   Assembler::Condition cond = Assembler::equal;
1582   switch (condition) {
1583     case lir_cond_equal:        positive = true ; cond = Assembler::equal  ; break;
1584     case lir_cond_notEqual:     positive = false; cond = Assembler::equal  ; break;
1585     case lir_cond_less:         positive = true ; cond = Assembler::less   ; break;
1586     case lir_cond_belowEqual:
1587     case lir_cond_lessEqual:    positive = false; cond = Assembler::greater; break;
1588     case lir_cond_greater:      positive = true ; cond = Assembler::greater; break;
1589     case lir_cond_aboveEqual:
1590     case lir_cond_greaterEqual: positive = false; cond = Assembler::less   ; break;
1591     default:                    ShouldNotReachHere();
1592   }
1593 
1594   // Try to use isel on &gt;=Power7.
1595   if (VM_Version::has_isel() &amp;&amp; result-&gt;is_cpu_register()) {
1596     bool o1_is_reg = opr1-&gt;is_cpu_register(), o2_is_reg = opr2-&gt;is_cpu_register();
1597     const Register result_reg = result-&gt;is_single_cpu() ? result-&gt;as_register() : result-&gt;as_register_lo();
1598 
1599     // We can use result_reg to load one operand if not already in register.
1600     Register first  = o1_is_reg ? (opr1-&gt;is_single_cpu() ? opr1-&gt;as_register() : opr1-&gt;as_register_lo()) : result_reg,
1601              second = o2_is_reg ? (opr2-&gt;is_single_cpu() ? opr2-&gt;as_register() : opr2-&gt;as_register_lo()) : result_reg;
1602 
1603     if (first != second) {
1604       if (!o1_is_reg) {
1605         load_to_reg(this, opr1, result);
1606       }
1607 
1608       if (!o2_is_reg) {
1609         load_to_reg(this, opr2, result);
1610       }
1611 
1612       __ isel(result_reg, BOOL_RESULT, cond, !positive, first, second);
1613       return;
1614     }
1615   } // isel
1616 
1617   load_to_reg(this, opr1, result);
1618 
1619   Label skip;
1620   int bo = positive ? Assembler::bcondCRbiIs1 : Assembler::bcondCRbiIs0;
1621   int bi = Assembler::bi0(BOOL_RESULT, cond);
1622   __ bc(bo, bi, skip);
1623 
1624   load_to_reg(this, opr2, result);
1625   __ bind(skip);
1626 }
1627 
1628 
1629 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest,
1630                              CodeEmitInfo* info, bool pop_fpu_stack) {
1631   assert(info == NULL, &quot;unused on this code path&quot;);
1632   assert(left-&gt;is_register(), &quot;wrong items state&quot;);
1633   assert(dest-&gt;is_register(), &quot;wrong items state&quot;);
1634 
1635   if (right-&gt;is_register()) {
1636     if (dest-&gt;is_float_kind()) {
1637 
1638       FloatRegister lreg, rreg, res;
1639       if (right-&gt;is_single_fpu()) {
1640         lreg = left-&gt;as_float_reg();
1641         rreg = right-&gt;as_float_reg();
1642         res  = dest-&gt;as_float_reg();
1643         switch (code) {
1644           case lir_add: __ fadds(res, lreg, rreg); break;
1645           case lir_sub: __ fsubs(res, lreg, rreg); break;
1646           case lir_mul: // fall through
1647           case lir_mul_strictfp: __ fmuls(res, lreg, rreg); break;
1648           case lir_div: // fall through
1649           case lir_div_strictfp: __ fdivs(res, lreg, rreg); break;
1650           default: ShouldNotReachHere();
1651         }
1652       } else {
1653         lreg = left-&gt;as_double_reg();
1654         rreg = right-&gt;as_double_reg();
1655         res  = dest-&gt;as_double_reg();
1656         switch (code) {
1657           case lir_add: __ fadd(res, lreg, rreg); break;
1658           case lir_sub: __ fsub(res, lreg, rreg); break;
1659           case lir_mul: // fall through
1660           case lir_mul_strictfp: __ fmul(res, lreg, rreg); break;
1661           case lir_div: // fall through
1662           case lir_div_strictfp: __ fdiv(res, lreg, rreg); break;
1663           default: ShouldNotReachHere();
1664         }
1665       }
1666 
1667     } else if (dest-&gt;is_double_cpu()) {
1668 
1669       Register dst_lo = dest-&gt;as_register_lo();
1670       Register op1_lo = left-&gt;as_pointer_register();
1671       Register op2_lo = right-&gt;as_pointer_register();
1672 
1673       switch (code) {
1674         case lir_add: __ add(dst_lo, op1_lo, op2_lo); break;
1675         case lir_sub: __ sub(dst_lo, op1_lo, op2_lo); break;
1676         case lir_mul: __ mulld(dst_lo, op1_lo, op2_lo); break;
1677         default: ShouldNotReachHere();
1678       }
1679     } else {
1680       assert (right-&gt;is_single_cpu(), &quot;Just Checking&quot;);
1681 
1682       Register lreg = left-&gt;as_register();
1683       Register res  = dest-&gt;as_register();
1684       Register rreg = right-&gt;as_register();
1685       switch (code) {
1686         case lir_add:  __ add  (res, lreg, rreg); break;
1687         case lir_sub:  __ sub  (res, lreg, rreg); break;
1688         case lir_mul:  __ mullw(res, lreg, rreg); break;
1689         default: ShouldNotReachHere();
1690       }
1691     }
1692   } else {
1693     assert (right-&gt;is_constant(), &quot;must be constant&quot;);
1694 
1695     if (dest-&gt;is_single_cpu()) {
1696       Register lreg = left-&gt;as_register();
1697       Register res  = dest-&gt;as_register();
1698       int    simm16 = right-&gt;as_constant_ptr()-&gt;as_jint();
1699 
1700       switch (code) {
1701         case lir_sub:  assert(Assembler::is_simm16(-simm16), &quot;cannot encode&quot;); // see do_ArithmeticOp_Int
1702                        simm16 = -simm16;
1703         case lir_add:  if (res == lreg &amp;&amp; simm16 == 0) break;
1704                        __ addi(res, lreg, simm16); break;
1705         case lir_mul:  if (res == lreg &amp;&amp; simm16 == 1) break;
1706                        __ mulli(res, lreg, simm16); break;
1707         default: ShouldNotReachHere();
1708       }
1709     } else {
1710       Register lreg = left-&gt;as_pointer_register();
1711       Register res  = dest-&gt;as_register_lo();
1712       long con = right-&gt;as_constant_ptr()-&gt;as_jlong();
1713       assert(Assembler::is_simm16(con), &quot;must be simm16&quot;);
1714 
1715       switch (code) {
1716         case lir_sub:  assert(Assembler::is_simm16(-con), &quot;cannot encode&quot;);  // see do_ArithmeticOp_Long
1717                        con = -con;
1718         case lir_add:  if (res == lreg &amp;&amp; con == 0) break;
1719                        __ addi(res, lreg, (int)con); break;
1720         case lir_mul:  if (res == lreg &amp;&amp; con == 1) break;
1721                        __ mulli(res, lreg, (int)con); break;
1722         default: ShouldNotReachHere();
1723       }
1724     }
1725   }
1726 }
1727 
1728 
1729 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1730   switch (code) {
1731     case lir_sqrt: {
1732       __ fsqrt(dest-&gt;as_double_reg(), value-&gt;as_double_reg());
1733       break;
1734     }
1735     case lir_abs: {
1736       __ fabs(dest-&gt;as_double_reg(), value-&gt;as_double_reg());
1737       break;
1738     }
1739     default: {
1740       ShouldNotReachHere();
1741       break;
1742     }
1743   }
1744 }
1745 
1746 
1747 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest) {
1748   if (right-&gt;is_constant()) { // see do_LogicOp
1749     long uimm;
1750     Register d, l;
1751     if (dest-&gt;is_single_cpu()) {
1752       uimm = right-&gt;as_constant_ptr()-&gt;as_jint();
1753       d = dest-&gt;as_register();
1754       l = left-&gt;as_register();
1755     } else {
1756       uimm = right-&gt;as_constant_ptr()-&gt;as_jlong();
1757       d = dest-&gt;as_register_lo();
1758       l = left-&gt;as_register_lo();
1759     }
1760     long uimms  = (unsigned long)uimm &gt;&gt; 16,
1761          uimmss = (unsigned long)uimm &gt;&gt; 32;
1762 
1763     switch (code) {
1764       case lir_logic_and:
1765         if (uimmss != 0 || (uimms != 0 &amp;&amp; (uimm &amp; 0xFFFF) != 0) || is_power_of_2_long(uimm)) {
1766           __ andi(d, l, uimm); // special cases
1767         } else if (uimms != 0) { __ andis_(d, l, uimms); }
1768         else { __ andi_(d, l, uimm); }
1769         break;
1770 
1771       case lir_logic_or:
1772         if (uimms != 0) { assert((uimm &amp; 0xFFFF) == 0, &quot;sanity&quot;); __ oris(d, l, uimms); }
1773         else { __ ori(d, l, uimm); }
1774         break;
1775 
1776       case lir_logic_xor:
1777         if (uimm == -1) { __ nand(d, l, l); } // special case
1778         else if (uimms != 0) { assert((uimm &amp; 0xFFFF) == 0, &quot;sanity&quot;); __ xoris(d, l, uimms); }
1779         else { __ xori(d, l, uimm); }
1780         break;
1781 
1782       default: ShouldNotReachHere();
1783     }
1784   } else {
1785     assert(right-&gt;is_register(), &quot;right should be in register&quot;);
1786 
1787     if (dest-&gt;is_single_cpu()) {
1788       switch (code) {
1789         case lir_logic_and: __ andr(dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1790         case lir_logic_or:  __ orr (dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1791         case lir_logic_xor: __ xorr(dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1792         default: ShouldNotReachHere();
1793       }
1794     } else {
1795       Register l = (left-&gt;is_single_cpu() &amp;&amp; left-&gt;is_oop_register()) ? left-&gt;as_register() :
1796                                                                         left-&gt;as_register_lo();
1797       Register r = (right-&gt;is_single_cpu() &amp;&amp; right-&gt;is_oop_register()) ? right-&gt;as_register() :
1798                                                                           right-&gt;as_register_lo();
1799 
1800       switch (code) {
1801         case lir_logic_and: __ andr(dest-&gt;as_register_lo(), l, r); break;
1802         case lir_logic_or:  __ orr (dest-&gt;as_register_lo(), l, r); break;
1803         case lir_logic_xor: __ xorr(dest-&gt;as_register_lo(), l, r); break;
1804         default: ShouldNotReachHere();
1805       }
1806     }
1807   }
1808 }
1809 
1810 
1811 int LIR_Assembler::shift_amount(BasicType t) {
1812   int elem_size = type2aelembytes(t);
1813   switch (elem_size) {
1814     case 1 : return 0;
1815     case 2 : return 1;
1816     case 4 : return 2;
1817     case 8 : return 3;
1818   }
1819   ShouldNotReachHere();
1820   return -1;
1821 }
1822 
1823 
1824 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
1825   info-&gt;add_register_oop(exceptionOop);
1826 
1827   // Reuse the debug info from the safepoint poll for the throw op itself.
1828   address pc_for_athrow = __ pc();
1829   int pc_for_athrow_offset = __ offset();
1830   //RelocationHolder rspec = internal_word_Relocation::spec(pc_for_athrow);
1831   //__ relocate(rspec);
1832   //__ load_const(exceptionPC-&gt;as_register(), pc_for_athrow, R0);
1833   __ calculate_address_from_global_toc(exceptionPC-&gt;as_register(), pc_for_athrow, true, true, /*add_relocation*/ true);
1834   add_call_info(pc_for_athrow_offset, info); // for exception handler
1835 
1836   address stub = Runtime1::entry_for(compilation()-&gt;has_fpu_code() ? Runtime1::handle_exception_id
1837                                                                    : Runtime1::handle_exception_nofpu_id);
1838   //__ load_const_optimized(R0, stub);
1839   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));
1840   __ mtctr(R0);
1841   __ bctr();
1842 }
1843 
1844 
1845 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
1846   // Note: Not used with EnableDebuggingOnDemand.
1847   assert(exceptionOop-&gt;as_register() == R3, &quot;should match&quot;);
1848   __ b(_unwind_handler_entry);
1849 }
1850 
1851 
1852 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
1853   Register src = op-&gt;src()-&gt;as_register();
1854   Register dst = op-&gt;dst()-&gt;as_register();
1855   Register src_pos = op-&gt;src_pos()-&gt;as_register();
1856   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1857   Register length  = op-&gt;length()-&gt;as_register();
1858   Register tmp = op-&gt;tmp()-&gt;as_register();
1859   Register tmp2 = R0;
1860 
1861   int flags = op-&gt;flags();
1862   ciArrayKlass* default_type = op-&gt;expected_type();
1863   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1864   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1865 
1866   // Set up the arraycopy stub information.
1867   ArrayCopyStub* stub = op-&gt;stub();
1868   const int frame_resize = frame::abi_reg_args_size - sizeof(frame::jit_abi); // C calls need larger frame.
1869 
1870   // Always do stub if no type information is available. It&#39;s ok if
1871   // the known type isn&#39;t loaded since the code sanity checks
1872   // in debug mode and the type isn&#39;t required when we know the exact type
1873   // also check that the type is an array type.
1874   if (op-&gt;expected_type() == NULL) {
1875     assert(src-&gt;is_nonvolatile() &amp;&amp; src_pos-&gt;is_nonvolatile() &amp;&amp; dst-&gt;is_nonvolatile() &amp;&amp; dst_pos-&gt;is_nonvolatile() &amp;&amp;
1876            length-&gt;is_nonvolatile(), &quot;must preserve&quot;);
1877     address copyfunc_addr = StubRoutines::generic_arraycopy();
1878     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
1879 
1880     // 3 parms are int. Convert to long.
1881     __ mr(R3_ARG1, src);
1882     __ extsw(R4_ARG2, src_pos);
1883     __ mr(R5_ARG3, dst);
1884     __ extsw(R6_ARG4, dst_pos);
1885     __ extsw(R7_ARG5, length);
1886 
1887 #ifndef PRODUCT
1888     if (PrintC1Statistics) {
1889       address counter = (address)&amp;Runtime1::_generic_arraycopystub_cnt;
1890       int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
1891       __ lwz(R11_scratch1, simm16_offs, tmp);
1892       __ addi(R11_scratch1, R11_scratch1, 1);
1893       __ stw(R11_scratch1, simm16_offs, tmp);
1894     }
1895 #endif
1896     __ call_c_with_frame_resize(copyfunc_addr, /*stub does not need resized frame*/ 0);
1897 
1898     __ nand(tmp, R3_RET, R3_RET);
1899     __ subf(length, tmp, length);
1900     __ add(src_pos, tmp, src_pos);
1901     __ add(dst_pos, tmp, dst_pos);
1902 
1903     __ cmpwi(CCR0, R3_RET, 0);
1904     __ bc_far_optimized(Assembler::bcondCRbiIs1, __ bi0(CCR0, Assembler::less), *stub-&gt;entry());
1905     __ bind(*stub-&gt;continuation());
1906     return;
1907   }
1908 
1909   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass(), &quot;must be true at this point&quot;);
1910   Label cont, slow, copyfunc;
1911 
1912   bool simple_check_flag_set = flags &amp; (LIR_OpArrayCopy::src_null_check |
1913                                         LIR_OpArrayCopy::dst_null_check |
1914                                         LIR_OpArrayCopy::src_pos_positive_check |
1915                                         LIR_OpArrayCopy::dst_pos_positive_check |
1916                                         LIR_OpArrayCopy::length_positive_check);
1917 
1918   // Use only one conditional branch for simple checks.
1919   if (simple_check_flag_set) {
1920     ConditionRegister combined_check = CCR1, tmp_check = CCR1;
1921 
1922     // Make sure src and dst are non-null.
1923     if (flags &amp; LIR_OpArrayCopy::src_null_check) {
1924       __ cmpdi(combined_check, src, 0);
1925       tmp_check = CCR0;
1926     }
1927 
1928     if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
1929       __ cmpdi(tmp_check, dst, 0);
1930       if (tmp_check != combined_check) {
1931         __ cror(combined_check, Assembler::equal, tmp_check, Assembler::equal);
1932       }
1933       tmp_check = CCR0;
1934     }
1935 
1936     // Clear combined_check.eq if not already used.
1937     if (tmp_check == combined_check) {
1938       __ crandc(combined_check, Assembler::equal, combined_check, Assembler::equal);
1939       tmp_check = CCR0;
1940     }
1941 
1942     if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
1943       // Test src_pos register.
1944       __ cmpwi(tmp_check, src_pos, 0);
1945       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1946     }
1947 
1948     if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
1949       // Test dst_pos register.
1950       __ cmpwi(tmp_check, dst_pos, 0);
1951       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1952     }
1953 
1954     if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
1955       // Make sure length isn&#39;t negative.
1956       __ cmpwi(tmp_check, length, 0);
1957       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1958     }
1959 
1960     __ beq(combined_check, slow);
1961   }
1962 
1963   // If the compiler was not able to prove that exact type of the source or the destination
1964   // of the arraycopy is an array type, check at runtime if the source or the destination is
1965   // an instance type.
1966   if (flags &amp; LIR_OpArrayCopy::type_check) {
1967     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
1968       __ load_klass(tmp, dst);
1969       __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
1970       __ cmpwi(CCR0, tmp2, Klass::_lh_neutral_value);
1971       __ bge(CCR0, slow);
1972     }
1973 
1974     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
1975       __ load_klass(tmp, src);
1976       __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
1977       __ cmpwi(CCR0, tmp2, Klass::_lh_neutral_value);
1978       __ bge(CCR0, slow);
1979     }
1980   }
1981 
1982   // Higher 32bits must be null.
1983   __ extsw(length, length);
1984 
1985   __ extsw(src_pos, src_pos);
1986   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
1987     __ lwz(tmp2, arrayOopDesc::length_offset_in_bytes(), src);
1988     __ add(tmp, length, src_pos);
1989     __ cmpld(CCR0, tmp2, tmp);
1990     __ ble(CCR0, slow);
1991   }
1992 
1993   __ extsw(dst_pos, dst_pos);
1994   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
1995     __ lwz(tmp2, arrayOopDesc::length_offset_in_bytes(), dst);
1996     __ add(tmp, length, dst_pos);
1997     __ cmpld(CCR0, tmp2, tmp);
1998     __ ble(CCR0, slow);
1999   }
2000 
2001   int shift = shift_amount(basic_type);
2002 
2003   if (!(flags &amp; LIR_OpArrayCopy::type_check)) {
2004     __ b(cont);
2005   } else {
2006     // We don&#39;t know the array types are compatible.
2007     if (basic_type != T_OBJECT) {
2008       // Simple test for basic type arrays.
2009       if (UseCompressedClassPointers) {
2010         // We don&#39;t need decode because we just need to compare.
2011         __ lwz(tmp, oopDesc::klass_offset_in_bytes(), src);
2012         __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2013         __ cmpw(CCR0, tmp, tmp2);
2014       } else {
2015         __ ld(tmp, oopDesc::klass_offset_in_bytes(), src);
2016         __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2017         __ cmpd(CCR0, tmp, tmp2);
2018       }
2019       __ beq(CCR0, cont);
2020     } else {
2021       // For object arrays, if src is a sub class of dst then we can
2022       // safely do the copy.
2023       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2024 
2025       const Register sub_klass = R5, super_klass = R4; // like CheckCast/InstanceOf
2026       assert_different_registers(tmp, tmp2, sub_klass, super_klass);
2027 
2028       __ load_klass(sub_klass, src);
2029       __ load_klass(super_klass, dst);
2030 
2031       __ check_klass_subtype_fast_path(sub_klass, super_klass, tmp, tmp2,
2032                                        &amp;cont, copyfunc_addr != NULL ? &amp;copyfunc : &amp;slow, NULL);
2033 
2034       address slow_stc = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2035       //__ load_const_optimized(tmp, slow_stc, tmp2);
2036       __ calculate_address_from_global_toc(tmp, slow_stc, true, true, false);
2037       __ mtctr(tmp);
2038       __ bctrl(); // sets CR0
2039       __ beq(CCR0, cont);
2040 
2041       if (copyfunc_addr != NULL) { // Use stub if available.
2042         __ bind(copyfunc);
2043         // Src is not a sub class of dst so we have to do a
2044         // per-element check.
2045         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2046         if ((flags &amp; mask) != mask) {
2047           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2048 
2049           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2050             __ load_klass(tmp, src);
2051           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2052             __ load_klass(tmp, dst);
2053           }
2054 
2055           __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
2056 
2057           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2058           __ load_const_optimized(tmp, objArray_lh);
2059           __ cmpw(CCR0, tmp, tmp2);
2060           __ bne(CCR0, slow);
2061         }
2062 
2063         Register src_ptr = R3_ARG1;
2064         Register dst_ptr = R4_ARG2;
2065         Register len     = R5_ARG3;
2066         Register chk_off = R6_ARG4;
2067         Register super_k = R7_ARG5;
2068 
2069         __ addi(src_ptr, src, arrayOopDesc::base_offset_in_bytes(basic_type));
2070         __ addi(dst_ptr, dst, arrayOopDesc::base_offset_in_bytes(basic_type));
2071         if (shift == 0) {
2072           __ add(src_ptr, src_pos, src_ptr);
2073           __ add(dst_ptr, dst_pos, dst_ptr);
2074         } else {
2075           __ sldi(tmp, src_pos, shift);
2076           __ sldi(tmp2, dst_pos, shift);
2077           __ add(src_ptr, tmp, src_ptr);
2078           __ add(dst_ptr, tmp2, dst_ptr);
2079         }
2080 
2081         __ load_klass(tmp, dst);
2082         __ mr(len, length);
2083 
2084         int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
2085         __ ld(super_k, ek_offset, tmp);
2086 
2087         int sco_offset = in_bytes(Klass::super_check_offset_offset());
2088         __ lwz(chk_off, sco_offset, super_k);
2089 
2090         __ call_c_with_frame_resize(copyfunc_addr, /*stub does not need resized frame*/ 0);
2091 
2092 #ifndef PRODUCT
2093         if (PrintC1Statistics) {
2094           Label failed;
2095           __ cmpwi(CCR0, R3_RET, 0);
2096           __ bne(CCR0, failed);
2097           address counter = (address)&amp;Runtime1::_arraycopy_checkcast_cnt;
2098           int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2099           __ lwz(R11_scratch1, simm16_offs, tmp);
2100           __ addi(R11_scratch1, R11_scratch1, 1);
2101           __ stw(R11_scratch1, simm16_offs, tmp);
2102           __ bind(failed);
2103         }
2104 #endif
2105 
2106         __ nand(tmp, R3_RET, R3_RET);
2107         __ cmpwi(CCR0, R3_RET, 0);
2108         __ beq(CCR0, *stub-&gt;continuation());
2109 
2110 #ifndef PRODUCT
2111         if (PrintC1Statistics) {
2112           address counter = (address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt;
2113           int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2114           __ lwz(R11_scratch1, simm16_offs, tmp);
2115           __ addi(R11_scratch1, R11_scratch1, 1);
2116           __ stw(R11_scratch1, simm16_offs, tmp);
2117         }
2118 #endif
2119 
2120         __ subf(length, tmp, length);
2121         __ add(src_pos, tmp, src_pos);
2122         __ add(dst_pos, tmp, dst_pos);
2123       }
2124     }
2125   }
2126   __ bind(slow);
2127   __ b(*stub-&gt;entry());
2128   __ bind(cont);
2129 
2130 #ifdef ASSERT
2131   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2132     // Sanity check the known type with the incoming class. For the
2133     // primitive case the types must match exactly with src.klass and
2134     // dst.klass each exactly matching the default type. For the
2135     // object array case, if no type check is needed then either the
2136     // dst type is exactly the expected type and the src type is a
2137     // subtype which we can&#39;t check or src is the same array as dst
2138     // but not necessarily exactly of type default_type.
2139     Label known_ok, halt;
2140     metadata2reg(op-&gt;expected_type()-&gt;constant_encoding(), tmp);
2141     if (UseCompressedClassPointers) {
2142       // Tmp holds the default type. It currently comes uncompressed after the
2143       // load of a constant, so encode it.
2144       __ encode_klass_not_null(tmp);
2145       // Load the raw value of the dst klass, since we will be comparing
2146       // uncompressed values directly.
2147       __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2148       __ cmpw(CCR0, tmp, tmp2);
2149       if (basic_type != T_OBJECT) {
2150         __ bne(CCR0, halt);
2151         // Load the raw value of the src klass.
2152         __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), src);
2153         __ cmpw(CCR0, tmp, tmp2);
2154         __ beq(CCR0, known_ok);
2155       } else {
2156         __ beq(CCR0, known_ok);
2157         __ cmpw(CCR0, src, dst);
2158         __ beq(CCR0, known_ok);
2159       }
2160     } else {
2161       __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2162       __ cmpd(CCR0, tmp, tmp2);
2163       if (basic_type != T_OBJECT) {
2164         __ bne(CCR0, halt);
2165         // Load the raw value of the src klass.
2166         __ ld(tmp2, oopDesc::klass_offset_in_bytes(), src);
2167         __ cmpd(CCR0, tmp, tmp2);
2168         __ beq(CCR0, known_ok);
2169       } else {
2170         __ beq(CCR0, known_ok);
2171         __ cmpd(CCR0, src, dst);
2172         __ beq(CCR0, known_ok);
2173       }
2174     }
2175     __ bind(halt);
2176     __ stop(&quot;incorrect type information in arraycopy&quot;);
2177     __ bind(known_ok);
2178   }
2179 #endif
2180 
2181 #ifndef PRODUCT
2182   if (PrintC1Statistics) {
2183     address counter = Runtime1::arraycopy_count_address(basic_type);
2184     int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2185     __ lwz(R11_scratch1, simm16_offs, tmp);
2186     __ addi(R11_scratch1, R11_scratch1, 1);
2187     __ stw(R11_scratch1, simm16_offs, tmp);
2188   }
2189 #endif
2190 
2191   Register src_ptr = R3_ARG1;
2192   Register dst_ptr = R4_ARG2;
2193   Register len     = R5_ARG3;
2194 
2195   __ addi(src_ptr, src, arrayOopDesc::base_offset_in_bytes(basic_type));
2196   __ addi(dst_ptr, dst, arrayOopDesc::base_offset_in_bytes(basic_type));
2197   if (shift == 0) {
2198     __ add(src_ptr, src_pos, src_ptr);
2199     __ add(dst_ptr, dst_pos, dst_ptr);
2200   } else {
2201     __ sldi(tmp, src_pos, shift);
2202     __ sldi(tmp2, dst_pos, shift);
2203     __ add(src_ptr, tmp, src_ptr);
2204     __ add(dst_ptr, tmp2, dst_ptr);
2205   }
2206 
2207   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2208   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2209   const char *name;
2210   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2211 
2212   // Arraycopy stubs takes a length in number of elements, so don&#39;t scale it.
2213   __ mr(len, length);
2214   __ call_c_with_frame_resize(entry, /*stub does not need resized frame*/ 0);
2215 
2216   __ bind(*stub-&gt;continuation());
2217 }
2218 
2219 
2220 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2221   if (dest-&gt;is_single_cpu()) {
2222     __ rldicl(tmp-&gt;as_register(), count-&gt;as_register(), 0, 64-5);
2223 #ifdef _LP64
2224     if (left-&gt;type() == T_OBJECT) {
2225       switch (code) {
2226         case lir_shl:  __ sld(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2227         case lir_shr:  __ srad(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2228         case lir_ushr: __ srd(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2229         default: ShouldNotReachHere();
2230       }
2231     } else
2232 #endif
2233       switch (code) {
2234         case lir_shl:  __ slw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2235         case lir_shr:  __ sraw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2236         case lir_ushr: __ srw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2237         default: ShouldNotReachHere();
2238       }
2239   } else {
2240     __ rldicl(tmp-&gt;as_register(), count-&gt;as_register(), 0, 64-6);
2241     switch (code) {
2242       case lir_shl:  __ sld(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2243       case lir_shr:  __ srad(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2244       case lir_ushr: __ srd(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2245       default: ShouldNotReachHere();
2246     }
2247   }
2248 }
2249 
2250 
2251 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2252 #ifdef _LP64
2253   if (left-&gt;type() == T_OBJECT) {
2254     count = count &amp; 63;  // Shouldn&#39;t shift by more than sizeof(intptr_t).
2255     if (count == 0) { __ mr_if_needed(dest-&gt;as_register_lo(), left-&gt;as_register()); }
2256     else {
2257       switch (code) {
2258         case lir_shl:  __ sldi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2259         case lir_shr:  __ sradi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2260         case lir_ushr: __ srdi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2261         default: ShouldNotReachHere();
2262       }
2263     }
2264     return;
2265   }
2266 #endif
2267 
2268   if (dest-&gt;is_single_cpu()) {
2269     count = count &amp; 0x1F; // Java spec
2270     if (count == 0) { __ mr_if_needed(dest-&gt;as_register(), left-&gt;as_register()); }
2271     else {
2272       switch (code) {
2273         case lir_shl: __ slwi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2274         case lir_shr:  __ srawi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2275         case lir_ushr: __ srwi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2276         default: ShouldNotReachHere();
2277       }
2278     }
2279   } else if (dest-&gt;is_double_cpu()) {
2280     count = count &amp; 63; // Java spec
2281     if (count == 0) { __ mr_if_needed(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register()); }
2282     else {
2283       switch (code) {
2284         case lir_shl:  __ sldi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2285         case lir_shr:  __ sradi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2286         case lir_ushr: __ srdi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2287         default: ShouldNotReachHere();
2288       }
2289     }
2290   } else {
2291     ShouldNotReachHere();
2292   }
2293 }
2294 
2295 
2296 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
2297   if (op-&gt;init_check()) {
2298     if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2299       explicit_null_check(op-&gt;klass()-&gt;as_register(), op-&gt;stub()-&gt;info());
2300     } else {
2301       add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2302     }
2303     __ lbz(op-&gt;tmp1()-&gt;as_register(),
2304            in_bytes(InstanceKlass::init_state_offset()), op-&gt;klass()-&gt;as_register());
2305     __ cmpwi(CCR0, op-&gt;tmp1()-&gt;as_register(), InstanceKlass::fully_initialized);
2306     __ bc_far_optimized(Assembler::bcondCRbiIs0, __ bi0(CCR0, Assembler::equal), *op-&gt;stub()-&gt;entry());
2307   }
2308   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2309                      op-&gt;tmp1()-&gt;as_register(),
2310                      op-&gt;tmp2()-&gt;as_register(),
2311                      op-&gt;tmp3()-&gt;as_register(),
2312                      op-&gt;header_size(),
2313                      op-&gt;object_size(),
2314                      op-&gt;klass()-&gt;as_register(),
2315                      *op-&gt;stub()-&gt;entry());
2316 
2317   __ bind(*op-&gt;stub()-&gt;continuation());
2318   __ verify_oop(op-&gt;obj()-&gt;as_register(), FILE_AND_LINE);
2319 }
2320 
2321 
2322 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2323   LP64_ONLY( __ extsw(op-&gt;len()-&gt;as_register(), op-&gt;len()-&gt;as_register()); )
2324   if (UseSlowPath ||
2325       (!UseFastNewObjectArray &amp;&amp; (is_reference_type(op-&gt;type()))) ||
2326       (!UseFastNewTypeArray   &amp;&amp; (!is_reference_type(op-&gt;type())))) {
2327     __ b(*op-&gt;stub()-&gt;entry());
2328   } else {
2329     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2330                       op-&gt;len()-&gt;as_register(),
2331                       op-&gt;tmp1()-&gt;as_register(),
2332                       op-&gt;tmp2()-&gt;as_register(),
2333                       op-&gt;tmp3()-&gt;as_register(),
2334                       arrayOopDesc::header_size(op-&gt;type()),
2335                       type2aelembytes(op-&gt;type()),
2336                       op-&gt;klass()-&gt;as_register(),
2337                       *op-&gt;stub()-&gt;entry());
2338   }
2339   __ bind(*op-&gt;stub()-&gt;continuation());
2340 }
2341 
2342 
2343 void LIR_Assembler::type_profile_helper(Register mdo, int mdo_offset_bias,
2344                                         ciMethodData *md, ciProfileData *data,
2345                                         Register recv, Register tmp1, Label* update_done) {
2346   uint i;
2347   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2348     Label next_test;
2349     // See if the receiver is receiver[n].
2350     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2351     __ verify_klass_ptr(tmp1);
2352     __ cmpd(CCR0, recv, tmp1);
2353     __ bne(CCR0, next_test);
2354 
2355     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2356     __ addi(tmp1, tmp1, DataLayout::counter_increment);
2357     __ std(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2358     __ b(*update_done);
2359 
2360     __ bind(next_test);
2361   }
2362 
2363   // Didn&#39;t find receiver; find next empty slot and fill it in.
2364   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2365     Label next_test;
2366     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2367     __ cmpdi(CCR0, tmp1, 0);
2368     __ bne(CCR0, next_test);
2369     __ li(tmp1, DataLayout::counter_increment);
2370     __ std(recv, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2371     __ std(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2372     __ b(*update_done);
2373 
2374     __ bind(next_test);
2375   }
2376 }
2377 
2378 
2379 void LIR_Assembler::setup_md_access(ciMethod* method, int bci,
2380                                     ciMethodData*&amp; md, ciProfileData*&amp; data, int&amp; mdo_offset_bias) {
2381   md = method-&gt;method_data_or_null();
2382   assert(md != NULL, &quot;Sanity&quot;);
2383   data = md-&gt;bci_to_data(bci);
2384   assert(data != NULL,       &quot;need data for checkcast&quot;);
2385   assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2386   if (!Assembler::is_simm16(md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()) + data-&gt;size_in_bytes())) {
2387     // The offset is large so bias the mdo by the base of the slot so
2388     // that the ld can use simm16s to reference the slots of the data.
2389     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, DataLayout::header_offset());
2390   }
2391 }
2392 
2393 
2394 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
2395   const Register obj = op-&gt;object()-&gt;as_register(); // Needs to live in this register at safepoint (patching stub).
2396   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2397   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2398   Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2399   Register dst = op-&gt;result_opr()-&gt;as_register();
2400   ciKlass* k = op-&gt;klass();
2401   bool should_profile = op-&gt;should_profile();
2402   // Attention: do_temp(opTypeCheck-&gt;_object) is not used, i.e. obj may be same as one of the temps.
2403   bool reg_conflict = false;
2404   if (obj == k_RInfo) {
2405     k_RInfo = dst;
2406     reg_conflict = true;
2407   } else if (obj == klass_RInfo) {
2408     klass_RInfo = dst;
2409     reg_conflict = true;
2410   } else if (obj == Rtmp1) {
2411     Rtmp1 = dst;
2412     reg_conflict = true;
2413   }
2414   assert_different_registers(obj, k_RInfo, klass_RInfo, Rtmp1);
2415 
2416   __ cmpdi(CCR0, obj, 0);
2417 
2418   ciMethodData* md = NULL;
2419   ciProfileData* data = NULL;
2420   int mdo_offset_bias = 0;
2421   if (should_profile) {
2422     ciMethod* method = op-&gt;profiled_method();
2423     assert(method != NULL, &quot;Should have method&quot;);
2424     setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2425 
2426     Register mdo      = k_RInfo;
2427     Register data_val = Rtmp1;
2428     Label not_null;
2429     __ bne(CCR0, not_null);
2430     metadata2reg(md-&gt;constant_encoding(), mdo);
2431     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2432     __ lbz(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2433     __ ori(data_val, data_val, BitData::null_seen_byte_constant());
2434     __ stb(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2435     __ b(*obj_is_null);
2436     __ bind(not_null);
2437   } else {
2438     __ beq(CCR0, *obj_is_null);
2439   }
2440 
2441   // get object class
2442   __ load_klass(klass_RInfo, obj);
2443 
2444   if (k-&gt;is_loaded()) {
2445     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2446   } else {
2447     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2448   }
2449 
2450   Label profile_cast_failure, failure_restore_obj, profile_cast_success;
2451   Label *failure_target = should_profile ? &amp;profile_cast_failure : failure;
2452   Label *success_target = should_profile ? &amp;profile_cast_success : success;
2453 
2454   if (op-&gt;fast_check()) {
2455     assert_different_registers(klass_RInfo, k_RInfo);
2456     __ cmpd(CCR0, k_RInfo, klass_RInfo);
2457     if (should_profile) {
2458       __ bne(CCR0, *failure_target);
2459       // Fall through to success case.
2460     } else {
2461       __ beq(CCR0, *success);
2462       // Fall through to failure case.
2463     }
2464   } else {
2465     bool need_slow_path = true;
2466     if (k-&gt;is_loaded()) {
2467       if ((int) k-&gt;super_check_offset() != in_bytes(Klass::secondary_super_cache_offset())) {
2468         need_slow_path = false;
2469       }
2470       // Perform the fast part of the checking logic.
2471       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, (need_slow_path ? success_target : NULL),
2472                                        failure_target, NULL, RegisterOrConstant(k-&gt;super_check_offset()));
2473     } else {
2474       // Perform the fast part of the checking logic.
2475       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, failure_target);
2476     }
2477     if (!need_slow_path) {
2478       if (!should_profile) { __ b(*success); }
2479     } else {
2480       // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2481       address entry = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2482       // Stub needs fixed registers (tmp1-3).
2483       Register original_k_RInfo = op-&gt;tmp1()-&gt;as_register();
2484       Register original_klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2485       Register original_Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2486       bool keep_obj_alive = reg_conflict &amp;&amp; (op-&gt;code() == lir_checkcast);
2487       bool keep_klass_RInfo_alive = (obj == original_klass_RInfo) &amp;&amp; should_profile;
2488       if (keep_obj_alive &amp;&amp; (obj != original_Rtmp1)) { __ mr(R0, obj); }
2489       __ mr_if_needed(original_k_RInfo, k_RInfo);
2490       __ mr_if_needed(original_klass_RInfo, klass_RInfo);
2491       if (keep_obj_alive) { __ mr(dst, (obj == original_Rtmp1) ? obj : R0); }
2492       //__ load_const_optimized(original_Rtmp1, entry, R0);
2493       __ calculate_address_from_global_toc(original_Rtmp1, entry, true, true, false);
2494       __ mtctr(original_Rtmp1);
2495       __ bctrl(); // sets CR0
2496       if (keep_obj_alive) {
2497         if (keep_klass_RInfo_alive) { __ mr(R0, obj); }
2498         __ mr(obj, dst);
2499       }
2500       if (should_profile) {
2501         __ bne(CCR0, *failure_target);
2502         if (keep_klass_RInfo_alive) { __ mr(klass_RInfo, keep_obj_alive ? R0 : obj); }
2503         // Fall through to success case.
2504       } else {
2505         __ beq(CCR0, *success);
2506         // Fall through to failure case.
2507       }
2508     }
2509   }
2510 
2511   if (should_profile) {
2512     Register mdo = k_RInfo, recv = klass_RInfo;
2513     assert_different_registers(mdo, recv, Rtmp1);
2514     __ bind(profile_cast_success);
2515     metadata2reg(md-&gt;constant_encoding(), mdo);
2516     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2517     type_profile_helper(mdo, mdo_offset_bias, md, data, recv, Rtmp1, success);
2518     __ b(*success);
2519 
2520     // Cast failure case.
2521     __ bind(profile_cast_failure);
2522     metadata2reg(md-&gt;constant_encoding(), mdo);
2523     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2524     __ ld(Rtmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2525     __ addi(Rtmp1, Rtmp1, -DataLayout::counter_increment);
2526     __ std(Rtmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2527   }
2528 
2529   __ bind(*failure);
2530 }
2531 
2532 
2533 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
2534   LIR_Code code = op-&gt;code();
2535   if (code == lir_store_check) {
2536     Register value = op-&gt;object()-&gt;as_register();
2537     Register array = op-&gt;array()-&gt;as_register();
2538     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2539     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2540     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2541     bool should_profile = op-&gt;should_profile();
2542 
2543     __ verify_oop(value, FILE_AND_LINE);
2544     CodeStub* stub = op-&gt;stub();
2545     // Check if it needs to be profiled.
2546     ciMethodData* md = NULL;
2547     ciProfileData* data = NULL;
2548     int mdo_offset_bias = 0;
2549     if (should_profile) {
2550       ciMethod* method = op-&gt;profiled_method();
2551       assert(method != NULL, &quot;Should have method&quot;);
2552       setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2553     }
2554     Label profile_cast_success, failure, done;
2555     Label *success_target = should_profile ? &amp;profile_cast_success : &amp;done;
2556 
2557     __ cmpdi(CCR0, value, 0);
2558     if (should_profile) {
2559       Label not_null;
2560       __ bne(CCR0, not_null);
2561       Register mdo      = k_RInfo;
2562       Register data_val = Rtmp1;
2563       metadata2reg(md-&gt;constant_encoding(), mdo);
2564       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2565       __ lbz(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2566       __ ori(data_val, data_val, BitData::null_seen_byte_constant());
2567       __ stb(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2568       __ b(done);
2569       __ bind(not_null);
2570     } else {
2571       __ beq(CCR0, done);
2572     }
2573     if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2574       explicit_null_check(array, op-&gt;info_for_exception());
2575     } else {
2576       add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2577     }
2578     __ load_klass(k_RInfo, array);
2579     __ load_klass(klass_RInfo, value);
2580 
2581     // Get instance klass.
2582     __ ld(k_RInfo, in_bytes(ObjArrayKlass::element_klass_offset()), k_RInfo);
2583     // Perform the fast part of the checking logic.
2584     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, &amp;failure, NULL);
2585 
2586     // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2587     const address slow_path = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2588     //__ load_const_optimized(R0, slow_path);
2589     __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(slow_path));
2590     __ mtctr(R0);
2591     __ bctrl(); // sets CR0
2592     if (!should_profile) {
2593       __ beq(CCR0, done);
2594       __ bind(failure);
2595     } else {
2596       __ bne(CCR0, failure);
2597       // Fall through to the success case.
2598 
2599       Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;
2600       assert_different_registers(value, mdo, recv, tmp1);
2601       __ bind(profile_cast_success);
2602       metadata2reg(md-&gt;constant_encoding(), mdo);
2603       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2604       __ load_klass(recv, value);
2605       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;done);
2606       __ b(done);
2607 
2608       // Cast failure case.
2609       __ bind(failure);
2610       metadata2reg(md-&gt;constant_encoding(), mdo);
2611       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2612       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2613       __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2614       __ addi(tmp1, tmp1, -DataLayout::counter_increment);
2615       __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2616     }
2617     __ b(*stub-&gt;entry());
2618     __ bind(done);
2619 
2620   } else if (code == lir_checkcast) {
2621     Label success, failure;
2622     emit_typecheck_helper(op, &amp;success, /*fallthru*/&amp;failure, &amp;success);
2623     __ b(*op-&gt;stub()-&gt;entry());
2624     __ align(32, 12);
2625     __ bind(success);
2626     __ mr_if_needed(op-&gt;result_opr()-&gt;as_register(), op-&gt;object()-&gt;as_register());
2627   } else if (code == lir_instanceof) {
2628     Register dst = op-&gt;result_opr()-&gt;as_register();
2629     Label success, failure, done;
2630     emit_typecheck_helper(op, &amp;success, /*fallthru*/&amp;failure, &amp;failure);
2631     __ li(dst, 0);
2632     __ b(done);
2633     __ align(32, 12);
2634     __ bind(success);
2635     __ li(dst, 1);
2636     __ bind(done);
2637   } else {
2638     ShouldNotReachHere();
2639   }
2640 }
2641 
2642 
2643 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2644   Register addr = op-&gt;addr()-&gt;as_pointer_register();
2645   Register cmp_value = noreg, new_value = noreg;
2646   bool is_64bit = false;
2647 
2648   if (op-&gt;code() == lir_cas_long) {
2649     cmp_value = op-&gt;cmp_value()-&gt;as_register_lo();
2650     new_value = op-&gt;new_value()-&gt;as_register_lo();
2651     is_64bit = true;
2652   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj) {
2653     cmp_value = op-&gt;cmp_value()-&gt;as_register();
2654     new_value = op-&gt;new_value()-&gt;as_register();
2655     if (op-&gt;code() == lir_cas_obj) {
2656       if (UseCompressedOops) {
2657         Register t1 = op-&gt;tmp1()-&gt;as_register();
2658         Register t2 = op-&gt;tmp2()-&gt;as_register();
2659         cmp_value = __ encode_heap_oop(t1, cmp_value);
2660         new_value = __ encode_heap_oop(t2, new_value);
2661       } else {
2662         is_64bit = true;
2663       }
2664     }
2665   } else {
2666     Unimplemented();
2667   }
2668 
2669   if (is_64bit) {
2670     __ cmpxchgd(BOOL_RESULT, /*current_value=*/R0, cmp_value, new_value, addr,
2671                 MacroAssembler::MemBarNone,
2672                 MacroAssembler::cmpxchgx_hint_atomic_update(),
2673                 noreg, NULL, /*check without ldarx first*/true);
2674   } else {
2675     __ cmpxchgw(BOOL_RESULT, /*current_value=*/R0, cmp_value, new_value, addr,
2676                 MacroAssembler::MemBarNone,
2677                 MacroAssembler::cmpxchgx_hint_atomic_update(),
2678                 noreg, /*check without ldarx first*/true);
2679   }
2680 
2681   if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
2682     __ isync();
2683   } else {
2684     __ sync();
2685   }
2686 }
2687 
2688 void LIR_Assembler::breakpoint() {
2689   __ illtrap();
2690 }
2691 
2692 
2693 void LIR_Assembler::push(LIR_Opr opr) {
2694   Unimplemented();
2695 }
2696 
2697 void LIR_Assembler::pop(LIR_Opr opr) {
2698   Unimplemented();
2699 }
2700 
2701 
2702 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2703   Address mon_addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2704   Register dst = dst_opr-&gt;as_register();
2705   Register reg = mon_addr.base();
2706   int offset = mon_addr.disp();
2707   // Compute pointer to BasicLock.
2708   __ add_const_optimized(dst, reg, offset);
2709 }
2710 
2711 
2712 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2713   Register obj = op-&gt;obj_opr()-&gt;as_register();
2714   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2715   Register lock = op-&gt;lock_opr()-&gt;as_register();
2716 
2717   // Obj may not be an oop.
2718   if (op-&gt;code() == lir_lock) {
2719     MonitorEnterStub* stub = (MonitorEnterStub*)op-&gt;stub();
2720     if (UseFastLocking) {
2721       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2722       // Add debug info for NullPointerException only if one is possible.
2723       if (op-&gt;info() != NULL) {
2724         if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2725           explicit_null_check(obj, op-&gt;info());
2726         } else {
2727           add_debug_info_for_null_check_here(op-&gt;info());
2728         }
2729       }
2730       __ lock_object(hdr, obj, lock, op-&gt;scratch_opr()-&gt;as_register(), *op-&gt;stub()-&gt;entry());
2731     } else {
2732       // always do slow locking
2733       // note: The slow locking code could be inlined here, however if we use
2734       //       slow locking, speed doesn&#39;t matter anyway and this solution is
2735       //       simpler and requires less duplicated code - additionally, the
2736       //       slow locking code is the same in either case which simplifies
2737       //       debugging.
2738       __ b(*op-&gt;stub()-&gt;entry());
2739     }
2740   } else {
2741     assert (op-&gt;code() == lir_unlock, &quot;Invalid code, expected lir_unlock&quot;);
2742     if (UseFastLocking) {
2743       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2744       __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2745     } else {
2746       // always do slow unlocking
2747       // note: The slow unlocking code could be inlined here, however if we use
2748       //       slow unlocking, speed doesn&#39;t matter anyway and this solution is
2749       //       simpler and requires less duplicated code - additionally, the
2750       //       slow unlocking code is the same in either case which simplifies
2751       //       debugging.
2752       __ b(*op-&gt;stub()-&gt;entry());
2753     }
2754   }
2755   __ bind(*op-&gt;stub()-&gt;continuation());
2756 }
2757 
2758 
2759 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2760   ciMethod* method = op-&gt;profiled_method();
2761   int bci          = op-&gt;profiled_bci();
2762   ciMethod* callee = op-&gt;profiled_callee();
2763 
2764   // Update counter for all call types.
2765   ciMethodData* md = method-&gt;method_data_or_null();
2766   assert(md != NULL, &quot;Sanity&quot;);
2767   ciProfileData* data = md-&gt;bci_to_data(bci);
2768   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2769   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2770   Register mdo = op-&gt;mdo()-&gt;as_register();
2771 #ifdef _LP64
2772   assert(op-&gt;tmp1()-&gt;is_double_cpu(), &quot;tmp1 must be allocated&quot;);
2773   Register tmp1 = op-&gt;tmp1()-&gt;as_register_lo();
2774 #else
2775   assert(op-&gt;tmp1()-&gt;is_single_cpu(), &quot;tmp1 must be allocated&quot;);
2776   Register tmp1 = op-&gt;tmp1()-&gt;as_register();
2777 #endif
2778   metadata2reg(md-&gt;constant_encoding(), mdo);
2779   int mdo_offset_bias = 0;
2780   if (!Assembler::is_simm16(md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) +
2781                             data-&gt;size_in_bytes())) {
2782     // The offset is large so bias the mdo by the base of the slot so
2783     // that the ld can use simm16s to reference the slots of the data.
2784     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, CounterData::count_offset());
2785     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2786   }
2787 
2788   // Perform additional virtual call profiling for invokevirtual and
2789   // invokeinterface bytecodes
2790   if (op-&gt;should_profile_receiver_type()) {
2791     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2792     Register recv = op-&gt;recv()-&gt;as_register();
2793     assert_different_registers(mdo, tmp1, recv);
2794     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2795     ciKlass* known_klass = op-&gt;known_holder();
2796     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2797       // We know the type that will be seen at this call site; we can
2798       // statically update the MethodData* rather than needing to do
2799       // dynamic tests on the receiver type.
2800 
2801       // NOTE: we should probably put a lock around this search to
2802       // avoid collisions by concurrent compilations.
2803       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2804       uint i;
2805       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2806         ciKlass* receiver = vc_data-&gt;receiver(i);
2807         if (known_klass-&gt;equals(receiver)) {
2808           __ ld(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2809           __ addi(tmp1, tmp1, DataLayout::counter_increment);
2810           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2811           return;
2812         }
2813       }
2814 
2815       // Receiver type not found in profile data; select an empty slot.
2816 
2817       // Note that this is less efficient than it should be because it
2818       // always does a write to the receiver part of the
2819       // VirtualCallData rather than just the first time.
2820       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2821         ciKlass* receiver = vc_data-&gt;receiver(i);
2822         if (receiver == NULL) {
2823           metadata2reg(known_klass-&gt;constant_encoding(), tmp1);
2824           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)) - mdo_offset_bias, mdo);
2825 
2826           __ ld(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2827           __ addi(tmp1, tmp1, DataLayout::counter_increment);
2828           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2829           return;
2830         }
2831       }
2832     } else {
2833       __ load_klass(recv, recv);
2834       Label update_done;
2835       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;update_done);
2836       // Receiver did not match any saved receiver and there is no empty row for it.
2837       // Increment total counter to indicate polymorphic case.
2838       __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2839       __ addi(tmp1, tmp1, DataLayout::counter_increment);
2840       __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2841 
2842       __ bind(update_done);
2843     }
2844   } else {
2845     // Static call
2846     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2847     __ addi(tmp1, tmp1, DataLayout::counter_increment);
2848     __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2849   }
2850 }
2851 
2852 
2853 void LIR_Assembler::align_backward_branch_target() {
2854   __ align(32, 12); // Insert up to 3 nops to align with 32 byte boundary.
2855 }
2856 
2857 
2858 void LIR_Assembler::emit_delay(LIR_OpDelay* op) {
2859   Unimplemented();
2860 }
2861 
2862 
2863 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2864   // tmp must be unused
2865   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2866   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
2867 
2868   if (left-&gt;is_single_cpu()) {
2869     __ neg(dest-&gt;as_register(), left-&gt;as_register());
2870   } else if (left-&gt;is_single_fpu()) {
2871     __ fneg(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2872   } else if (left-&gt;is_double_fpu()) {
2873     __ fneg(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2874   } else {
2875     assert (left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
2876     __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2877   }
2878 }
2879 
2880 
2881 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
2882                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2883   // Stubs: Called via rt_call, but dest is a stub address (no function descriptor).
2884   if (dest == Runtime1::entry_for(Runtime1::register_finalizer_id) ||
2885       dest == Runtime1::entry_for(Runtime1::new_multi_array_id   )) {
2886     //__ load_const_optimized(R0, dest);
2887     __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(dest));
2888     __ mtctr(R0);
2889     __ bctrl();
2890     assert(info != NULL, &quot;sanity&quot;);
2891     add_call_info_here(info);
2892     return;
2893   }
2894 
2895   __ call_c_with_frame_resize(dest, /*no resizing*/ 0);
2896   if (info != NULL) {
2897     add_call_info_here(info);
2898   }
2899 }
2900 
2901 
2902 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2903   ShouldNotReachHere(); // Not needed on _LP64.
2904 }
2905 
2906 void LIR_Assembler::membar() {
2907   __ fence();
2908 }
2909 
2910 void LIR_Assembler::membar_acquire() {
2911   __ acquire();
2912 }
2913 
2914 void LIR_Assembler::membar_release() {
2915   __ release();
2916 }
2917 
2918 void LIR_Assembler::membar_loadload() {
2919   __ membar(Assembler::LoadLoad);
2920 }
2921 
2922 void LIR_Assembler::membar_storestore() {
2923   __ membar(Assembler::StoreStore);
2924 }
2925 
2926 void LIR_Assembler::membar_loadstore() {
2927   __ membar(Assembler::LoadStore);
2928 }
2929 
2930 void LIR_Assembler::membar_storeload() {
2931   __ membar(Assembler::StoreLoad);
2932 }
2933 
2934 void LIR_Assembler::on_spin_wait() {
2935   Unimplemented();
2936 }
2937 
2938 void LIR_Assembler::leal(LIR_Opr addr_opr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
2939   assert(patch_code == lir_patch_none, &quot;Patch code not supported&quot;);
2940   LIR_Address* addr = addr_opr-&gt;as_address_ptr();
2941   assert(addr-&gt;scale() == LIR_Address::times_1, &quot;no scaling on this platform&quot;);
2942   if (addr-&gt;index()-&gt;is_illegal()) {
2943     __ add_const_optimized(dest-&gt;as_pointer_register(), addr-&gt;base()-&gt;as_pointer_register(), addr-&gt;disp());
2944   } else {
2945     assert(addr-&gt;disp() == 0, &quot;can&#39;t have both: index and disp&quot;);
2946     __ add(dest-&gt;as_pointer_register(), addr-&gt;index()-&gt;as_pointer_register(), addr-&gt;base()-&gt;as_pointer_register());
2947   }
2948 }
2949 
2950 
2951 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
2952   ShouldNotReachHere();
2953 }
2954 
2955 
2956 #ifdef ASSERT
2957 // Emit run-time assertion.
2958 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
2959   Unimplemented();
2960 }
2961 #endif
2962 
2963 
2964 void LIR_Assembler::peephole(LIR_List* lir) {
2965   // Optimize instruction pairs before emitting.
2966   LIR_OpList* inst = lir-&gt;instructions_list();
2967   for (int i = 1; i &lt; inst-&gt;length(); i++) {
2968     LIR_Op* op = inst-&gt;at(i);
2969 
2970     // 2 register-register-moves
2971     if (op-&gt;code() == lir_move) {
2972       LIR_Opr in2  = ((LIR_Op1*)op)-&gt;in_opr(),
2973               res2 = ((LIR_Op1*)op)-&gt;result_opr();
2974       if (in2-&gt;is_register() &amp;&amp; res2-&gt;is_register()) {
2975         LIR_Op* prev = inst-&gt;at(i - 1);
2976         if (prev &amp;&amp; prev-&gt;code() == lir_move) {
2977           LIR_Opr in1  = ((LIR_Op1*)prev)-&gt;in_opr(),
2978                   res1 = ((LIR_Op1*)prev)-&gt;result_opr();
2979           if (in1-&gt;is_same_register(res2) &amp;&amp; in2-&gt;is_same_register(res1)) {
2980             inst-&gt;remove_at(i);
2981           }
2982         }
2983       }
2984     }
2985 
2986   }
2987   return;
2988 }
2989 
2990 
2991 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
2992   const LIR_Address *addr = src-&gt;as_address_ptr();
2993   assert(addr-&gt;disp() == 0 &amp;&amp; addr-&gt;index()-&gt;is_illegal(), &quot;use leal!&quot;);
2994   const Register Rptr = addr-&gt;base()-&gt;as_pointer_register(),
2995                  Rtmp = tmp-&gt;as_register();
2996   Register Rco = noreg;
2997   if (UseCompressedOops &amp;&amp; data-&gt;is_oop()) {
2998     Rco = __ encode_heap_oop(Rtmp, data-&gt;as_register());
2999   }
3000 
3001   Label Lretry;
3002   __ bind(Lretry);
3003 
3004   if (data-&gt;type() == T_INT) {
3005     const Register Rold = dest-&gt;as_register(),
3006                    Rsrc = data-&gt;as_register();
3007     assert_different_registers(Rptr, Rtmp, Rold, Rsrc);
3008     __ lwarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3009     if (code == lir_xadd) {
3010       __ add(Rtmp, Rsrc, Rold);
3011       __ stwcx_(Rtmp, Rptr);
3012     } else {
3013       __ stwcx_(Rsrc, Rptr);
3014     }
3015   } else if (data-&gt;is_oop()) {
3016     assert(code == lir_xchg, &quot;xadd for oops&quot;);
3017     const Register Rold = dest-&gt;as_register();
3018     if (UseCompressedOops) {
3019       assert_different_registers(Rptr, Rold, Rco);
3020       __ lwarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3021       __ stwcx_(Rco, Rptr);
3022     } else {
3023       const Register Robj = data-&gt;as_register();
3024       assert_different_registers(Rptr, Rold, Robj);
3025       __ ldarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3026       __ stdcx_(Robj, Rptr);
3027     }
3028   } else if (data-&gt;type() == T_LONG) {
3029     const Register Rold = dest-&gt;as_register_lo(),
3030                    Rsrc = data-&gt;as_register_lo();
3031     assert_different_registers(Rptr, Rtmp, Rold, Rsrc);
3032     __ ldarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3033     if (code == lir_xadd) {
3034       __ add(Rtmp, Rsrc, Rold);
3035       __ stdcx_(Rtmp, Rptr);
3036     } else {
3037       __ stdcx_(Rsrc, Rptr);
3038     }
3039   } else {
3040     ShouldNotReachHere();
3041   }
3042 
3043   if (UseStaticBranchPredictionInCompareAndSwapPPC64) {
3044     __ bne_predict_not_taken(CCR0, Lretry);
3045   } else {
3046     __ bne(                  CCR0, Lretry);
3047   }
3048 
3049   if (UseCompressedOops &amp;&amp; data-&gt;is_oop()) {
3050     __ decode_heap_oop(dest-&gt;as_register());
3051   }
3052 }
3053 
3054 
3055 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3056   Register obj = op-&gt;obj()-&gt;as_register();
3057   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3058   LIR_Address* mdo_addr = op-&gt;mdp()-&gt;as_address_ptr();
3059   ciKlass* exact_klass = op-&gt;exact_klass();
3060   intptr_t current_klass = op-&gt;current_klass();
3061   bool not_null = op-&gt;not_null();
3062   bool no_conflict = op-&gt;no_conflict();
3063 
3064   Label Lupdate, Ldo_update, Ldone;
3065 
3066   bool do_null = !not_null;
3067   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3068   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3069 
3070   assert(do_null || do_update, &quot;why are we here?&quot;);
3071   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3072 
3073   __ verify_oop(obj, FILE_AND_LINE);
3074 
3075   if (do_null) {
3076     if (!TypeEntries::was_null_seen(current_klass)) {
3077       __ cmpdi(CCR0, obj, 0);
3078       __ bne(CCR0, Lupdate);
3079       __ ld(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3080       __ ori(R0, R0, TypeEntries::null_seen);
3081       if (do_update) {
3082         __ b(Ldo_update);
3083       } else {
3084         __ std(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3085       }
3086     } else {
3087       if (do_update) {
3088         __ cmpdi(CCR0, obj, 0);
3089         __ beq(CCR0, Ldone);
3090       }
3091     }
3092 #ifdef ASSERT
3093   } else {
3094     __ cmpdi(CCR0, obj, 0);
3095     __ bne(CCR0, Lupdate);
3096     __ stop(&quot;unexpect null obj&quot;, 0x9652);
3097 #endif
3098   }
3099 
3100   __ bind(Lupdate);
3101   if (do_update) {
3102     Label Lnext;
3103     const Register klass = R29_TOC; // kill and reload
3104     bool klass_reg_used = false;
3105 #ifdef ASSERT
3106     if (exact_klass != NULL) {
3107       Label ok;
3108       klass_reg_used = true;
3109       __ load_klass(klass, obj);
3110       metadata2reg(exact_klass-&gt;constant_encoding(), R0);
3111       __ cmpd(CCR0, klass, R0);
3112       __ beq(CCR0, ok);
3113       __ stop(&quot;exact klass and actual klass differ&quot;, 0x8564);
3114       __ bind(ok);
3115     }
3116 #endif
3117 
3118     if (!no_conflict) {
3119       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3120         klass_reg_used = true;
3121         if (exact_klass != NULL) {
3122           __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3123           metadata2reg(exact_klass-&gt;constant_encoding(), klass);
3124         } else {
3125           __ load_klass(klass, obj);
3126           __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register()); // may kill obj
3127         }
3128 
3129         // Like InterpreterMacroAssembler::profile_obj_type
3130         __ clrrdi(R0, tmp, exact_log2(-TypeEntries::type_klass_mask));
3131         // Basically same as andi(R0, tmp, TypeEntries::type_klass_mask);
3132         __ cmpd(CCR1, R0, klass);
3133         // Klass seen before, nothing to do (regardless of unknown bit).
3134         //beq(CCR1, do_nothing);
3135 
3136         __ andi_(R0, klass, TypeEntries::type_unknown);
3137         // Already unknown. Nothing to do anymore.
3138         //bne(CCR0, do_nothing);
3139         __ crorc(CCR0, Assembler::equal, CCR1, Assembler::equal); // cr0 eq = cr1 eq or cr0 ne
3140         __ beq(CCR0, Lnext);
3141 
3142         if (TypeEntries::is_type_none(current_klass)) {
3143           __ clrrdi_(R0, tmp, exact_log2(-TypeEntries::type_mask));
3144           __ orr(R0, klass, tmp); // Combine klass and null_seen bit (only used if (tmp &amp; type_mask)==0).
3145           __ beq(CCR0, Ldo_update); // First time here. Set profile type.
3146         }
3147 
3148       } else {
3149         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3150                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3151 
3152         __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3153         __ andi_(R0, tmp, TypeEntries::type_unknown);
3154         // Already unknown. Nothing to do anymore.
3155         __ bne(CCR0, Lnext);
3156       }
3157 
3158       // Different than before. Cannot keep accurate profile.
3159       __ ori(R0, tmp, TypeEntries::type_unknown);
3160     } else {
3161       // There&#39;s a single possible klass at this profile point
3162       assert(exact_klass != NULL, &quot;should be&quot;);
3163       __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3164 
3165       if (TypeEntries::is_type_none(current_klass)) {
3166         klass_reg_used = true;
3167         metadata2reg(exact_klass-&gt;constant_encoding(), klass);
3168 
3169         __ clrrdi(R0, tmp, exact_log2(-TypeEntries::type_klass_mask));
3170         // Basically same as andi(R0, tmp, TypeEntries::type_klass_mask);
3171         __ cmpd(CCR1, R0, klass);
3172         // Klass seen before, nothing to do (regardless of unknown bit).
3173         __ beq(CCR1, Lnext);
3174 #ifdef ASSERT
3175         {
3176           Label ok;
3177           __ clrrdi_(R0, tmp, exact_log2(-TypeEntries::type_mask));
3178           __ beq(CCR0, ok); // First time here.
3179 
3180           __ stop(&quot;unexpected profiling mismatch&quot;, 0x7865);
3181           __ bind(ok);
3182         }
3183 #endif
3184         // First time here. Set profile type.
3185         __ orr(R0, klass, tmp); // Combine klass and null_seen bit (only used if (tmp &amp; type_mask)==0).
3186       } else {
3187         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3188                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3189 
3190         // Already unknown. Nothing to do anymore.
3191         __ andi_(R0, tmp, TypeEntries::type_unknown);
3192         __ bne(CCR0, Lnext);
3193 
3194         // Different than before. Cannot keep accurate profile.
3195         __ ori(R0, tmp, TypeEntries::type_unknown);
3196       }
3197     }
3198 
3199     __ bind(Ldo_update);
3200     __ std(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3201 
3202     __ bind(Lnext);
3203     if (klass_reg_used) { __ load_const_optimized(R29_TOC, MacroAssembler::global_toc(), R0); } // reinit
3204   }
3205   __ bind(Ldone);
3206 }
3207 
3208 
3209 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3210   assert(op-&gt;crc()-&gt;is_single_cpu(), &quot;crc must be register&quot;);
3211   assert(op-&gt;val()-&gt;is_single_cpu(), &quot;byte value must be register&quot;);
3212   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3213   Register crc = op-&gt;crc()-&gt;as_register();
3214   Register val = op-&gt;val()-&gt;as_register();
3215   Register res = op-&gt;result_opr()-&gt;as_register();
3216 
3217   assert_different_registers(val, crc, res);
3218 
3219   __ load_const_optimized(res, StubRoutines::crc_table_addr(), R0);
3220   __ kernel_crc32_singleByteReg(crc, val, res, true);
3221   __ mr(res, crc);
3222 }
3223 
3224 #undef __
    </pre>
  </body>
</html>
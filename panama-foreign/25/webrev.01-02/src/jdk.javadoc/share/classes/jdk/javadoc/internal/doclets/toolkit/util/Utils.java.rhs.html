<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
  35 import java.util.ArrayDeque;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;
  40 import java.util.Comparator;
  41 import java.util.Deque;
  42 import java.util.EnumSet;
  43 import java.util.HashMap;
  44 import java.util.HashSet;
  45 import java.util.Iterator;
  46 import java.util.LinkedHashMap;
  47 import java.util.LinkedHashSet;
  48 import java.util.List;
  49 import java.util.Locale;
  50 import java.util.Map;
  51 import java.util.Map.Entry;
  52 import java.util.Objects;
  53 import java.util.Set;
  54 import java.util.SortedSet;
  55 import java.util.TreeMap;
  56 import java.util.TreeSet;
  57 import java.util.function.Predicate;
  58 import java.util.stream.Collectors;
  59 
  60 import javax.lang.model.SourceVersion;
  61 import javax.lang.model.element.AnnotationMirror;
  62 import javax.lang.model.element.AnnotationValue;
  63 import javax.lang.model.element.Element;
  64 import javax.lang.model.element.ElementKind;
  65 import javax.lang.model.element.ExecutableElement;
  66 import javax.lang.model.element.Modifier;
  67 import javax.lang.model.element.ModuleElement;
  68 import javax.lang.model.element.ModuleElement.RequiresDirective;
  69 import javax.lang.model.element.PackageElement;
  70 import javax.lang.model.element.RecordComponentElement;
  71 import javax.lang.model.element.TypeElement;
  72 import javax.lang.model.element.TypeParameterElement;
  73 import javax.lang.model.element.VariableElement;
  74 import javax.lang.model.type.ArrayType;
  75 import javax.lang.model.type.DeclaredType;
  76 import javax.lang.model.type.ErrorType;
  77 import javax.lang.model.type.ExecutableType;
  78 import javax.lang.model.type.NoType;
  79 import javax.lang.model.type.PrimitiveType;
  80 import javax.lang.model.type.TypeMirror;
  81 import javax.lang.model.type.TypeVariable;
  82 import javax.lang.model.type.WildcardType;
  83 import javax.lang.model.util.ElementFilter;
  84 import javax.lang.model.util.ElementKindVisitor14;
  85 import javax.lang.model.util.Elements;
  86 import javax.lang.model.util.SimpleElementVisitor14;
  87 import javax.lang.model.util.SimpleTypeVisitor9;
  88 import javax.lang.model.util.TypeKindVisitor9;
  89 import javax.lang.model.util.Types;
  90 import javax.tools.FileObject;
  91 import javax.tools.JavaFileManager;
  92 import javax.tools.JavaFileManager.Location;
  93 import javax.tools.StandardLocation;
  94 
  95 import com.sun.source.doctree.DocCommentTree;
  96 import com.sun.source.doctree.DocTree;
  97 import com.sun.source.doctree.DocTree.Kind;
  98 import com.sun.source.doctree.ParamTree;
  99 import com.sun.source.doctree.SerialFieldTree;
 100 import com.sun.source.doctree.UnknownBlockTagTree;
 101 import com.sun.source.tree.CompilationUnitTree;
 102 import com.sun.source.tree.LineMap;
 103 import com.sun.source.util.DocSourcePositions;
 104 import com.sun.source.util.DocTrees;
 105 import com.sun.source.util.TreePath;
 106 import com.sun.tools.javac.model.JavacTypes;
 107 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;
 108 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 109 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 110 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
 111 import jdk.javadoc.internal.doclets.toolkit.Messages;
 112 import jdk.javadoc.internal.doclets.toolkit.Resources;
 113 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 114 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 115 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 116 import jdk.javadoc.internal.tool.DocEnvImpl;
 117 
 118 import static javax.lang.model.element.ElementKind.*;
 119 import static javax.lang.model.element.Modifier.*;
 120 import static javax.lang.model.type.TypeKind.*;
 121 
 122 import static com.sun.source.doctree.DocTree.Kind.*;
 123 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 124 
 125 /**
 126  * Utilities Class for Doclets.
 127  *
 128  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 129  *  If you write code that depends on this, you do so at your own risk.
 130  *  This code and its internal interfaces are subject to change or
 131  *  deletion without notice.&lt;/b&gt;
 132  */
 133 public class Utils {
 134     public final BaseConfiguration configuration;
 135     private final BaseOptions options;
 136     private final Messages messages;
 137     private final Resources resources;
 138     public final DocTrees docTrees;
 139     public final Elements elementUtils;
 140     public final Types typeUtils;
 141     private final JavaScriptScanner javaScriptScanner;
 142 
 143     public Utils(BaseConfiguration c) {
 144         configuration = c;
 145         options = configuration.getOptions();
 146         messages = configuration.getMessages();
 147         resources = configuration.getDocResources();
 148         elementUtils = c.docEnv.getElementUtils();
 149         typeUtils = c.docEnv.getTypeUtils();
 150         docTrees = c.docEnv.getDocTrees();
 151         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
 152     }
 153 
 154     // our own little symbol table
 155     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 156 
 157     public TypeMirror getSymbol(String signature) {
 158         TypeMirror type = symtab.get(signature);
 159         if (type == null) {
 160             TypeElement typeElement = elementUtils.getTypeElement(signature);
 161             if (typeElement == null)
 162                 return null;
 163             type = typeElement.asType();
 164             if (type == null)
 165                 return null;
 166             symtab.put(signature, type);
 167         }
 168         return type;
 169     }
 170 
 171     public TypeMirror getObjectType() {
 172         return getSymbol(&quot;java.lang.Object&quot;);
 173     }
 174 
 175     public TypeMirror getExceptionType() {
 176         return getSymbol(&quot;java.lang.Exception&quot;);
 177     }
 178 
 179     public TypeMirror getErrorType() {
 180         return getSymbol(&quot;java.lang.Error&quot;);
 181     }
 182 
 183     public TypeMirror getSerializableType() {
 184         return getSymbol(&quot;java.io.Serializable&quot;);
 185     }
 186 
 187     public TypeMirror getExternalizableType() {
 188         return getSymbol(&quot;java.io.Externalizable&quot;);
 189     }
 190 
 191     public TypeMirror getIllegalArgumentExceptionType() {
 192         return getSymbol(&quot;java.lang.IllegalArgumentException&quot;);
 193     }
 194 
 195     public TypeMirror getNullPointerExceptionType() {
 196         return getSymbol(&quot;java.lang.NullPointerException&quot;);
 197     }
 198 
 199     public TypeMirror getDeprecatedType() {
 200         return getSymbol(&quot;java.lang.Deprecated&quot;);
 201     }
 202 
 203     public TypeMirror getFunctionalInterface() {
 204         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 205     }
 206 
 207     /**
 208      * Return array of class members whose documentation is to be generated.
 209      * If the member is deprecated do not include such a member in the
 210      * returned array.
 211      *
 212      * @param  members    Array of members to choose from.
 213      * @return List       List of eligible members for whom
 214      *                    documentation is getting generated.
 215      */
 216     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
<a name="1" id="anc1"></a><span class="line-modified"> 217         return members.stream()</span>
<span class="line-modified"> 218                       .filter(member -&gt; !isDeprecated(member))</span>
<span class="line-modified"> 219                       .sorted(makeGeneralPurposeComparator())</span>
<span class="line-modified"> 220                       .collect(Collectors.toCollection(ArrayList::new));</span>

 221     }
 222 
 223     /**
 224      * Search for the given method in the given class.
 225      *
 226      * @param  te        Class to search into.
 227      * @param  method    Method to be searched.
 228      * @return ExecutableElement Method found, null otherwise.
 229      */
 230     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 231         for (Element m : getMethods(te)) {
<a name="2" id="anc2"></a><span class="line-modified"> 232             if (executableMembersEqual(method, (ExecutableElement) m)) {</span>
<span class="line-modified"> 233                 return (ExecutableElement) m;</span>
 234             }
 235         }
 236         return null;
 237     }
 238 
 239     /**
 240      * Test whether a class is a subclass of another class.
 241      *
 242      * @param t1 the candidate superclass.
 243      * @param t2 the target
 244      * @return true if t1 is a superclass of t2.
 245      */
 246     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
 247         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
 248     }
 249 
 250     /**
 251      * @param e1 the first method to compare.
 252      * @param e2 the second method to compare.
 253      * @return true if member1 overrides/hides or is overridden/hidden by member2.
 254      */
<a name="3" id="anc3"></a>
 255     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 256         // TODO: investigate if Elements.hides(..) will work here.
 257         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 258             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 259             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 260             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 261                     parameters1.size() == parameters2.size()) {
 262                 int j;
 263                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 264                     VariableElement v1 = parameters1.get(j);
 265                     VariableElement v2 = parameters2.get(j);
 266                     String t1 = getTypeName(v1.asType(), true);
 267                     String t2 = getTypeName(v2.asType(), true);
 268                     if (!(t1.equals(t2) ||
 269                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 270                         break;
 271                     }
 272                 }
 273                 if (j == parameters1.size()) {
<a name="4" id="anc4"></a><span class="line-modified"> 274                     return true;</span>
 275                 }
 276             }
 277             return false;
 278         } else {
 279             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 280                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 281                     e1.equals(e2);
 282         }
 283     }
 284 
 285     /**
 286      * According to
 287      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 288      * all the outer classes and static inner classes are core classes.
 289      */
 290     public boolean isCoreClass(TypeElement e) {
 291         return getEnclosingTypeElement(e) == null || isStatic(e);
 292     }
 293 
 294     public Location getLocationForPackage(PackageElement pd) {
 295         ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(pd);
 296 
 297         if (mdle == null)
 298             return defaultLocation();
 299 
 300         return getLocationForModule(mdle);
 301     }
 302 
 303     public Location getLocationForModule(ModuleElement mdle) {
 304         Location loc = configuration.workArounds.getLocationForModule(mdle);
 305         if (loc != null)
 306             return loc;
 307 
 308         return defaultLocation();
 309     }
 310 
 311     private Location defaultLocation() {
 312         JavaFileManager fm = configuration.docEnv.getJavaFileManager();
 313         return fm.hasLocation(StandardLocation.SOURCE_PATH)
 314                 ? StandardLocation.SOURCE_PATH
 315                 : StandardLocation.CLASS_PATH;
 316     }
 317 
 318     public boolean isAnnotated(TypeMirror e) {
 319         return !e.getAnnotationMirrors().isEmpty();
 320     }
 321 
 322     public boolean isAnnotated(Element e) {
 323         return !e.getAnnotationMirrors().isEmpty();
 324     }
 325 
 326     @SuppressWarnings(&quot;preview&quot;)
 327     public boolean isAnnotationType(Element e) {
 328         return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
 329             @Override
 330             public Boolean visitExecutable(ExecutableElement e, Void p) {
 331                 return visit(e.getEnclosingElement());
 332             }
 333 
 334             @Override
 335             public Boolean visitUnknown(Element e, Void p) {
 336                 return false;
 337             }
 338 
 339             @Override
 340             protected Boolean defaultAction(Element e, Void p) {
 341                 return e.getKind() == ANNOTATION_TYPE;
 342             }
 343         }.visit(e);
 344     }
 345 
 346     /**
 347      * An Enum implementation is almost identical, thus this method returns if
 348      * this element represents a CLASS or an ENUM
 349      * @param e element
 350      * @return true if class or enum
 351      */
 352     public boolean isClass(Element e) {
 353         return e.getKind().isClass();
 354     }
 355 
 356     public boolean isConstructor(Element e) {
 357          return e.getKind() == CONSTRUCTOR;
 358     }
 359 
 360     public boolean isEnum(Element e) {
 361         return e.getKind() == ENUM;
 362     }
 363 
 364     boolean isEnumConstant(Element e) {
 365         return e.getKind() == ENUM_CONSTANT;
 366     }
 367 
 368     public boolean isField(Element e) {
 369         return e.getKind() == FIELD;
 370     }
 371 
 372     public boolean isInterface(Element e) {
 373         return e.getKind() == INTERFACE;
 374     }
 375 
 376     public boolean isMethod(Element e) {
 377         return e.getKind() == METHOD;
 378     }
 379 
 380     public boolean isModule(Element e) {
 381         return e.getKind() == ElementKind.MODULE;
 382     }
 383 
 384     public boolean isPackage(Element e) {
 385         return e.getKind() == ElementKind.PACKAGE;
 386     }
 387 
 388     public boolean isAbstract(Element e) {
 389         return e.getModifiers().contains(Modifier.ABSTRACT);
 390     }
 391 
 392     public boolean isDefault(Element e) {
 393         return e.getModifiers().contains(Modifier.DEFAULT);
 394     }
 395 
 396     public boolean isPackagePrivate(Element e) {
 397         return !(isPublic(e) || isPrivate(e) || isProtected(e));
 398     }
 399 
 400     public boolean isPrivate(Element e) {
 401         return e.getModifiers().contains(Modifier.PRIVATE);
 402     }
 403 
 404     public boolean isProtected(Element e) {
 405         return e.getModifiers().contains(Modifier.PROTECTED);
 406     }
 407 
 408     public boolean isPublic(Element e) {
 409         return e.getModifiers().contains(Modifier.PUBLIC);
 410     }
 411 
 412     public boolean isProperty(String name) {
 413         return options.javafx() &amp;&amp; name.endsWith(&quot;Property&quot;);
 414     }
 415 
 416     public String getPropertyName(String name) {
 417         return isProperty(name)
 418                 ? name.substring(0, name.length() - &quot;Property&quot;.length())
 419                 : name;
 420     }
 421 
 422     public String getPropertyLabel(String name) {
 423         return name.substring(0, name.lastIndexOf(&quot;Property&quot;));
 424     }
 425 
 426     public boolean isOverviewElement(Element e) {
 427         return e.getKind() == ElementKind.OTHER;
 428     }
 429 
 430     public boolean isStatic(Element e) {
 431         return e.getModifiers().contains(Modifier.STATIC);
 432     }
 433 
 434     public boolean isSerializable(TypeElement e) {
 435         return typeUtils.isSubtype(e.asType(), getSerializableType());
 436     }
 437 
 438     public boolean isExternalizable(TypeElement e) {
 439         return typeUtils.isSubtype(e.asType(), getExternalizableType());
 440     }
 441 
 442     @SuppressWarnings(&quot;preview&quot;)
 443     public boolean isRecord(TypeElement e) {
 444         return e.getKind() == ElementKind.RECORD;
 445     }
 446 
 447     @SuppressWarnings(&quot;preview&quot;)
 448     public boolean isCanonicalRecordConstructor(ExecutableElement ee) {
 449         TypeElement te = (TypeElement) ee.getEnclosingElement();
 450         List&lt;? extends RecordComponentElement&gt; stateComps = te.getRecordComponents();
 451         List&lt;? extends VariableElement&gt; params = ee.getParameters();
 452         if (stateComps.size() != params.size()) {
 453             return false;
 454         }
 455 
 456         Iterator&lt;? extends RecordComponentElement&gt; stateIter = stateComps.iterator();
 457         Iterator&lt;? extends VariableElement&gt; paramIter = params.iterator();
 458         while (paramIter.hasNext() &amp;&amp; stateIter.hasNext()) {
 459             VariableElement param = paramIter.next();
 460             RecordComponentElement comp = stateIter.next();
 461             if (!Objects.equals(param.getSimpleName(), comp.getSimpleName())
 462                     || !typeUtils.isSameType(param.asType(), comp.asType())) {
 463                 return false;
 464             }
 465         }
 466 
 467         return true;
 468     }
 469 
 470     public SortedSet&lt;VariableElement&gt; serializableFields(TypeElement aclass) {
 471         return configuration.workArounds.getSerializableFields(aclass);
 472     }
 473 
 474     public SortedSet&lt;ExecutableElement&gt; serializationMethods(TypeElement aclass) {
 475         return configuration.workArounds.getSerializationMethods(aclass);
 476     }
 477 
 478     public boolean definesSerializableFields(TypeElement aclass) {
 479         return configuration.workArounds.definesSerializableFields( aclass);
 480     }
 481 
 482     @SuppressWarnings(&quot;preview&quot;)
 483     public String modifiersToString(Element e, boolean trailingSpace) {
 484         SortedSet&lt;Modifier&gt; modifiers = new TreeSet&lt;&gt;(e.getModifiers());
 485         modifiers.remove(NATIVE);
 486         modifiers.remove(STRICTFP);
 487         modifiers.remove(SYNCHRONIZED);
 488 
 489         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {
 490             final StringBuilder sb = new StringBuilder();
 491 
 492             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 493                 if (modifiers.contains(PUBLIC)) {
 494                     append(&quot;public&quot;);
 495                 } else if (modifiers.contains(PROTECTED)) {
 496                     append(&quot;protected&quot;);
 497                 } else if (modifiers.contains(PRIVATE)) {
 498                     append(&quot;private&quot;);
 499                 }
 500             }
 501 
 502             void addStatic(Set&lt;Modifier&gt; modifiers) {
 503                 if (modifiers.contains(STATIC)) {
 504                     append(&quot;static&quot;);
 505                 }
 506             }
 507 
 508             void addModifiers(Set&lt;Modifier&gt; modifiers) {
<a name="5" id="anc5"></a><span class="line-modified"> 509                 modifiers.stream().map(Modifier::toString).forEachOrdered(this::append);</span>
 510             }
 511 
 512             void append(String s) {
 513                 if (sb.length() &gt; 0) {
 514                     sb.append(&quot; &quot;);
 515                 }
 516                 sb.append(s);
 517             }
 518 
 519             String finalString(String s) {
 520                 append(s);
 521                 if (trailingSpace) {
 522                     sb.append(&quot; &quot;);
<a name="6" id="anc6"></a><span class="line-modified"> 523                 }</span>
 524                 return sb.toString();
 525             }
 526 
 527             @Override
 528             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 529                 addVisibilityModifier(mods);
 530                 addStatic(mods);
 531                 return finalString(&quot;interface&quot;);
 532             }
 533 
 534             @Override
 535             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 536                 addVisibilityModifier(mods);
 537                 addStatic(mods);
 538                 return finalString(&quot;enum&quot;);
 539             }
 540 
 541             @Override
 542             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 543                 addVisibilityModifier(mods);
 544                 addStatic(mods);
 545                 return finalString(&quot;@interface&quot;);
 546             }
 547 
 548             @Override
 549             public String visitTypeAsRecord(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 550                 mods.remove(FINAL); // suppress the implicit `final`
 551                 return visitTypeAsClass(e, mods);
 552             }
 553 
 554             @Override
 555             @SuppressWarnings(&quot;preview&quot;)
 556             public String visitTypeAsClass(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 557                 addModifiers(mods);
 558                 String keyword = e.getKind() == ElementKind.RECORD ? &quot;record&quot; : &quot;class&quot;;
 559                 return finalString(keyword);
 560             }
 561 
 562             @Override
 563             protected String defaultAction(Element e, SortedSet&lt;Modifier&gt; mods) {
 564                 addModifiers(mods);
 565                 return sb.toString().trim();
 566             }
 567 
 568         }.visit(e, modifiers);
 569     }
 570 
 571     public boolean isFunctionalInterface(AnnotationMirror amirror) {
 572         return amirror.getAnnotationType().equals(getFunctionalInterface()) &amp;&amp;
 573                 configuration.docEnv.getSourceVersion()
 574                         .compareTo(SourceVersion.RELEASE_8) &gt;= 0;
 575     }
 576 
 577     public boolean isNoType(TypeMirror t) {
 578         return t.getKind() == NONE;
 579     }
 580 
 581     public boolean isOrdinaryClass(TypeElement te) {
 582         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 583             return false;
 584         }
 585         if (isError(te) || isException(te)) {
 586             return false;
 587         }
 588         return true;
 589     }
 590 
 591     public boolean isUndocumentedEnclosure(TypeElement enclosingTypeElement) {
 592         return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement))
 593                 &amp;&amp; !isLinkable(enclosingTypeElement);
 594     }
 595 
 596     public boolean isError(TypeElement te) {
 597         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 598             return false;
 599         }
 600         return typeUtils.isSubtype(te.asType(), getErrorType());
 601     }
 602 
 603     public boolean isException(TypeElement te) {
 604         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 605             return false;
 606         }
 607         return typeUtils.isSubtype(te.asType(), getExceptionType());
 608     }
 609 
 610     public boolean isPrimitive(TypeMirror t) {
 611         return new SimpleTypeVisitor9&lt;Boolean, Void&gt;() {
 612 
 613             @Override
 614             public Boolean visitNoType(NoType t, Void p) {
 615                 return t.getKind() == VOID;
 616             }
 617             @Override
 618             public Boolean visitPrimitive(PrimitiveType t, Void p) {
 619                 return true;
 620             }
 621             @Override
 622             public Boolean visitArray(ArrayType t, Void p) {
 623                 return visit(t.getComponentType());
 624             }
 625             @Override
 626             protected Boolean defaultAction(TypeMirror e, Void p) {
 627                 return false;
 628             }
 629         }.visit(t);
 630     }
 631 
 632     public boolean isExecutableElement(Element e) {
 633         ElementKind kind = e.getKind();
 634         switch (kind) {
 635             case CONSTRUCTOR: case METHOD: case INSTANCE_INIT:
 636                 return true;
 637             default:
 638                 return false;
 639         }
 640     }
 641 
 642     public boolean isVariableElement(Element e) {
 643         ElementKind kind = e.getKind();
 644         switch(kind) {
 645               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 646               case LOCAL_VARIABLE: case PARAMETER:
 647               case RESOURCE_VARIABLE:
 648                   return true;
 649               default:
 650                   return false;
 651         }
 652     }
 653 
 654     public boolean isTypeElement(Element e) {
 655         switch (e.getKind()) {
 656             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 657                 return true;
 658             default:
 659                 return false;
 660         }
 661     }
 662 
 663     /**
 664      * Get the signature. It is the parameter list, type is qualified.
 665      * For instance, for a method {@code mymethod(String x, int y)},
<a name="7" id="anc7"></a><span class="line-modified"> 666      * it will return {@code (java.lang.String,int)}.</span>
 667      *
 668      * @param e
 669      * @return String
 670      */
 671     public String signature(ExecutableElement e) {
 672         return makeSignature(e, true);
 673     }
 674 
 675     /**
 676      * Get flat signature.  All types are not qualified.
 677      * Return a String, which is the flat signature of this member.
 678      * It is the parameter list, type is not qualified.
 679      * For instance, for a method {@code mymethod(String x, int y)},
 680      * it will return {@code (String, int)}.
 681      */
 682     public String flatSignature(ExecutableElement e) {
 683         return makeSignature(e, false);
 684     }
 685 
 686     public String makeSignature(ExecutableElement e, boolean full) {
 687         return makeSignature(e, full, false);
 688     }
 689 
 690     public String makeSignature(ExecutableElement e, boolean full, boolean ignoreTypeParameters) {
 691         StringBuilder result = new StringBuilder();
 692         result.append(&quot;(&quot;);
 693         Iterator&lt;? extends VariableElement&gt; iterator = e.getParameters().iterator();
 694         while (iterator.hasNext()) {
 695             VariableElement next = iterator.next();
 696             TypeMirror type = next.asType();
 697             result.append(getTypeSignature(type, full, ignoreTypeParameters));
 698             if (iterator.hasNext()) {
 699                 result.append(&quot;, &quot;);
 700             }
 701         }
 702         if (e.isVarArgs()) {
 703             int len = result.length();
 704             result.replace(len - 2, len, &quot;...&quot;);
 705         }
 706         result.append(&quot;)&quot;);
 707         return result.toString();
 708     }
 709 
 710     public String getTypeSignature(TypeMirror t, boolean qualifiedName, boolean noTypeParameters) {
 711         return new SimpleTypeVisitor9&lt;StringBuilder, Void&gt;() {
 712             final StringBuilder sb = new StringBuilder();
 713 
 714             @Override
 715             public StringBuilder visitArray(ArrayType t, Void p) {
 716                 TypeMirror componentType = t.getComponentType();
 717                 visit(componentType);
 718                 sb.append(&quot;[]&quot;);
 719                 return sb;
 720             }
 721 
 722             @Override
 723             public StringBuilder visitDeclared(DeclaredType t, Void p) {
 724                 Element e = t.asElement();
 725                 sb.append(qualifiedName ? getFullyQualifiedName(e) : getSimpleName(e));
 726                 List&lt;? extends TypeMirror&gt; typeArguments = t.getTypeArguments();
 727                 if (typeArguments.isEmpty() || noTypeParameters) {
 728                     return sb;
 729                 }
 730                 sb.append(&quot;&lt;&quot;);
 731                 Iterator&lt;? extends TypeMirror&gt; iterator = typeArguments.iterator();
 732                 while (iterator.hasNext()) {
 733                     TypeMirror ta = iterator.next();
 734                     visit(ta);
 735                     if (iterator.hasNext()) {
 736                         sb.append(&quot;, &quot;);
 737                     }
 738                 }
 739                 sb.append(&quot;&gt;&quot;);
 740                 return sb;
 741             }
 742 
 743             @Override
 744             public StringBuilder visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
 745                 Element e = t.asElement();
 746                 sb.append(qualifiedName ? getFullyQualifiedName(e, false) : getSimpleName(e));
 747                 return sb;
 748             }
 749 
 750             @Override
 751             public StringBuilder visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
 752                 sb.append(&quot;?&quot;);
 753                 TypeMirror upperBound = t.getExtendsBound();
 754                 if (upperBound != null) {
 755                     sb.append(&quot; extends &quot;);
 756                     visit(upperBound);
 757                 }
 758                 TypeMirror superBound = t.getSuperBound();
 759                 if (superBound != null) {
 760                     sb.append(&quot; super &quot;);
 761                     visit(superBound);
 762                 }
 763                 return sb;
 764             }
 765 
 766             @Override
 767             protected StringBuilder defaultAction(TypeMirror e, Void p) {
 768                 return sb.append(e);
 769             }
 770         }.visit(t).toString();
 771     }
 772 
 773     public boolean isArrayType(TypeMirror t) {
 774         return t.getKind() == ARRAY;
 775     }
 776 
 777     public boolean isDeclaredType(TypeMirror t) {
 778         return t.getKind() == DECLARED;
 779     }
 780 
 781     public boolean isErrorType(TypeMirror t) {
 782         return t.getKind() == ERROR;
 783     }
 784 
 785     public boolean isIntersectionType(TypeMirror t) {
 786         return t.getKind() == INTERSECTION;
 787     }
 788 
 789     public boolean isTypeParameterElement(Element e) {
 790         return e.getKind() == TYPE_PARAMETER;
 791     }
 792 
 793     public boolean isTypeVariable(TypeMirror t) {
 794         return t.getKind() == TYPEVAR;
 795     }
 796 
 797     public boolean isVoid(TypeMirror t) {
 798         return t.getKind() == VOID;
 799     }
 800 
 801     public boolean isWildCard(TypeMirror t) {
 802         return t.getKind() == WILDCARD;
 803     }
 804 
 805     public boolean ignoreBounds(TypeMirror bound) {
 806         return bound.equals(getObjectType()) &amp;&amp; !isAnnotated(bound);
 807     }
 808 
 809     /*
 810      * a direct port of TypeVariable.getBounds
 811      */
 812     public List&lt;? extends TypeMirror&gt; getBounds(TypeParameterElement tpe) {
 813         List&lt;? extends TypeMirror&gt; bounds = tpe.getBounds();
 814         if (!bounds.isEmpty()) {
 815             TypeMirror upperBound = bounds.get(bounds.size() - 1);
 816             if (ignoreBounds(upperBound)) {
 817                 return Collections.emptyList();
 818             }
 819         }
 820         return bounds;
 821     }
 822 
 823     /**
 824      * Returns the TypeMirror of the ExecutableElement if it is a method, or null
 825      * if it is a constructor.
 826      * @param site the contextual type
 827      * @param ee the ExecutableElement
 828      * @return the return type
 829      */
 830     public TypeMirror getReturnType(TypeElement site, ExecutableElement ee) {
 831         return ee.getKind() == CONSTRUCTOR ? null : asInstantiatedMethodType(site, ee).getReturnType();
 832     }
 833 
 834     /**
 835      * Returns the ExecutableType corresponding to the type of the method declaration seen as a
 836      * member of a given declared type. This might cause type-variable substitution to kick in.
 837      * @param site the contextual type.
 838      * @param ee the method declaration.
 839      * @return the instantiated method type.
 840      */
 841     public ExecutableType asInstantiatedMethodType(TypeElement site, ExecutableElement ee) {
 842         return shouldInstantiate(site, ee) ?
 843                 (ExecutableType)typeUtils.asMemberOf((DeclaredType)site.asType(), ee) :
 844                 (ExecutableType)ee.asType();
 845     }
 846 
 847     /**
 848      * Returns the TypeMirror corresponding to the type of the field declaration seen as a
 849      * member of a given declared type. This might cause type-variable substitution to kick in.
 850      * @param site the contextual type.
 851      * @param ve the field declaration.
 852      * @return the instantiated field type.
 853      */
 854     public TypeMirror asInstantiatedFieldType(TypeElement site, VariableElement ve) {
 855         return shouldInstantiate(site, ve) ?
 856                 typeUtils.asMemberOf((DeclaredType)site.asType(), ve) :
 857                 ve.asType();
 858     }
 859 
 860     /*
 861      * We should not instantiate if (i) there&#39;s no contextual type declaration, (ii) the declaration
 862      * to which the member belongs to is the same as the one under consideration, (iii) if the
 863      * delcaration to which the member belongs to is not generic.
 864      */
 865     private boolean shouldInstantiate(TypeElement site, Element e) {
 866         return site != null &amp;&amp;
 867                 site != e.getEnclosingElement() &amp;&amp;
 868                !((DeclaredType)e.getEnclosingElement().asType()).getTypeArguments().isEmpty();
 869     }
 870 
 871     /**
 872      * Return the type containing the method that this method overrides.
 873      * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
 874      */
 875     public TypeMirror overriddenType(ExecutableElement method) {
 876         return configuration.workArounds.overriddenType(method);
 877     }
 878 
 879     private  TypeMirror getType(TypeMirror t) {
 880         return (isNoType(t)) ? getObjectType() : t;
 881     }
 882 
 883     public TypeMirror getSuperType(TypeElement te) {
 884         TypeMirror t = te.getSuperclass();
 885         return getType(t);
 886     }
 887 
 888     /**
 889      * Return the class that originally defined the method that
 890      * is overridden by the current definition, or null if no
 891      * such class exists.
 892      *
 893      * @return a TypeElement representing the superclass that
 894      * originally defined this method, null if this method does
 895      * not override a definition in a superclass.
 896      */
 897     public TypeElement overriddenClass(ExecutableElement ee) {
 898         TypeMirror type = overriddenType(ee);
 899         return (type != null) ? asTypeElement(type) : null;
 900     }
 901 
 902     public ExecutableElement overriddenMethod(ExecutableElement method) {
 903         if (isStatic(method)) {
 904             return null;
 905         }
 906         final TypeElement origin = getEnclosingTypeElement(method);
 907         for (TypeMirror t = getSuperType(origin);
 908                 t.getKind() == DECLARED;
 909                 t = getSuperType(asTypeElement(t))) {
 910             TypeElement te = asTypeElement(t);
 911             if (te == null) {
 912                 return null;
 913             }
 914             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 915             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 916                 ExecutableElement ee = (ExecutableElement)e;
 917                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 918                         !isSimpleOverride(ee)) {
 919                     return ee;
 920                 }
 921             }
 922             if (t.equals(getObjectType()))
 923                 return null;
 924         }
 925         return null;
 926     }
 927 
 928     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 929         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
<a name="8" id="anc8"></a><span class="line-modified"> 930         typeElements.forEach(set::add);</span>


 931         return set;
 932     }
 933 
 934     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 935         return getBlockTags(member, SERIAL_DATA);
 936     }
 937 
 938     public FileObject getFileObject(TypeElement te) {
 939         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 940     }
 941 
 942     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 943         return getDeclaredType(Collections.emptyList(), enclosing, target);
 944     }
 945 
 946     /**
 947      * Finds the declaration of the enclosing&#39;s type parameter.
 948      *
 949      * @param values
 950      * @param enclosing a TypeElement whose type arguments  we desire
 951      * @param target the TypeMirror of the type as described by the enclosing
 952      * @return
 953      */
 954     public TypeMirror getDeclaredType(Collection&lt;TypeMirror&gt; values,
 955                                       TypeElement enclosing, TypeMirror target) {
 956         TypeElement targetElement = asTypeElement(target);
 957         List&lt;? extends TypeParameterElement&gt; targetTypeArgs = targetElement.getTypeParameters();
 958         if (targetTypeArgs.isEmpty()) {
 959             return target;
 960         }
 961 
 962         List&lt;? extends TypeParameterElement&gt; enclosingTypeArgs = enclosing.getTypeParameters();
 963         List&lt;TypeMirror&gt; targetTypeArgTypes = new ArrayList&lt;&gt;(targetTypeArgs.size());
 964 
 965         if (enclosingTypeArgs.isEmpty()) {
 966             for (TypeMirror te : values) {
 967                 List&lt;? extends TypeMirror&gt; typeArguments = ((DeclaredType)te).getTypeArguments();
 968                 if (typeArguments.size() &gt;= targetTypeArgs.size()) {
 969                     for (int i = 0 ; i &lt; targetTypeArgs.size(); i++) {
 970                         targetTypeArgTypes.add(typeArguments.get(i));
 971                     }
 972                     break;
 973                 }
 974             }
 975             // we found no matches in the hierarchy
 976             if (targetTypeArgTypes.isEmpty()) {
 977                 return target;
 978             }
 979         } else {
 980             if (targetTypeArgs.size() &gt; enclosingTypeArgs.size()) {
 981                 return target;
 982             }
 983             for (int i = 0; i &lt; targetTypeArgs.size(); i++) {
 984                 TypeParameterElement tpe = enclosingTypeArgs.get(i);
 985                 targetTypeArgTypes.add(tpe.asType());
 986             }
 987         }
 988         TypeMirror dt = typeUtils.getDeclaredType(targetElement,
 989                 targetTypeArgTypes.toArray(new TypeMirror[targetTypeArgTypes.size()]));
 990         return dt;
 991     }
 992 
 993     /**
 994      * Returns all the implemented super-interfaces of a given type,
 995      * in the case of classes, include all the super-interfaces of
 996      * the supertype. The super-interfaces are collected before the
 997      * super-interfaces of the supertype.
 998      *
 999      * @param  te the type element to get the super-interfaces for.
1000      * @return the list of super-interfaces.
1001      */
1002     public Set&lt;TypeMirror&gt; getAllInterfaces(TypeElement te) {
1003         Set&lt;TypeMirror&gt; results = new LinkedHashSet&lt;&gt;();
1004         getAllInterfaces(te.asType(), results);
1005         return results;
1006     }
1007 
1008     private void getAllInterfaces(TypeMirror type, Set&lt;TypeMirror&gt; results) {
1009         List&lt;? extends TypeMirror&gt; intfacs = typeUtils.directSupertypes(type);
1010         TypeMirror superType = null;
1011         for (TypeMirror intfac : intfacs) {
1012             if (intfac == getObjectType())
1013                 continue;
1014             TypeElement e = asTypeElement(intfac);
1015             if (isInterface(e)) {
1016                 if (isPublic(e) || isLinkable(e))
1017                     results.add(intfac);
1018 
1019                 getAllInterfaces(intfac, results);
1020             } else {
1021                 // Save the supertype for later.
1022                 superType = intfac;
1023             }
1024         }
1025         // Collect the super-interfaces of the supertype.
1026         if (superType != null)
1027             getAllInterfaces(superType, results);
1028     }
1029 
1030     /**
1031      * Lookup for a class within this package.
1032      *
1033      * @return TypeElement of found class, or null if not found.
1034      */
1035     public TypeElement findClassInPackageElement(PackageElement pkg, String className) {
1036         for (TypeElement c : getAllClasses(pkg)) {
1037             if (getSimpleName(c).equals(className)) {
1038                 return c;
1039             }
1040         }
1041         return null;
1042     }
1043 
1044     /**
1045      * TODO: FIXME: port to javax.lang.model
1046      * Find a class within the context of this class. Search order: qualified name, in this class
1047      * (inner), in this package, in the class imports, in the package imports. Return the
1048      * TypeElement if found, null if not found.
1049      */
1050     //### The specified search order is not the normal rule the
1051     //### compiler would use.  Leave as specified or change it?
1052     public TypeElement findClass(Element element, String className) {
1053         TypeElement encl = getEnclosingTypeElement(element);
1054         TypeElement searchResult = configuration.workArounds.searchClass(encl, className);
1055         if (searchResult == null) {
1056             encl = getEnclosingTypeElement(encl);
1057             //Expand search space to include enclosing class.
1058             while (encl != null &amp;&amp; getEnclosingTypeElement(encl) != null) {
1059                 encl = getEnclosingTypeElement(encl);
1060             }
1061             searchResult = encl == null
1062                     ? null
1063                     : configuration.workArounds.searchClass(encl, className);
1064         }
1065         return searchResult;
1066     }
1067 
1068     /**
1069      * Enclose in quotes, used for paths and filenames that contains spaces
1070      */
1071     public String quote(String filepath) {
1072         return (&quot;\&quot;&quot; + filepath + &quot;\&quot;&quot;);
1073     }
1074 
1075     /**
1076      * Parse the package name.  We only want to display package name up to
1077      * 2 levels.
1078      */
1079     public String parsePackageName(PackageElement p) {
1080         String pkgname = p.isUnnamed() ? &quot;&quot; : getPackageName(p);
1081         int index = -1;
1082         for (int j = 0; j &lt; MAX_CONSTANT_VALUE_INDEX_LENGTH; j++) {
1083             index = pkgname.indexOf(&quot;.&quot;, index + 1);
1084         }
1085         if (index != -1) {
1086             pkgname = pkgname.substring(0, index);
1087         }
1088         return pkgname;
1089     }
1090 
1091     /**
1092      * Given a string, replace all occurrences of &#39;newStr&#39; with &#39;oldStr&#39;.
1093      * @param originalStr the string to modify.
1094      * @param oldStr the string to replace.
1095      * @param newStr the string to insert in place of the old string.
1096      */
1097     public String replaceText(String originalStr, String oldStr,
1098             String newStr) {
1099         if (oldStr == null || newStr == null || oldStr.equals(newStr)) {
1100             return originalStr;
1101         }
1102         return originalStr.replace(oldStr, newStr);
1103     }
1104 
1105     /**
1106      * Given an annotation, return true if it should be documented and false
1107      * otherwise.
1108      *
1109      * @param annotation the annotation to check.
1110      *
1111      * @return true return true if it should be documented and false otherwise.
1112      */
1113     public boolean isDocumentedAnnotation(TypeElement annotation) {
1114         for (AnnotationMirror anno : annotation.getAnnotationMirrors()) {
1115             if (getFullyQualifiedName(anno.getAnnotationType().asElement()).equals(
1116                     Documented.class.getName())) {
1117                 return true;
1118             }
1119         }
1120         return false;
1121     }
1122 
1123     /**
1124      * Returns true if this class is linkable and false if we can&#39;t link to it.
1125      *
1126      * &lt;p&gt;
1127      * &lt;b&gt;NOTE:&lt;/b&gt;  You can only link to external classes if they are public or
1128      * protected.
1129      *
1130      * @return true if this class is linkable and false if we can&#39;t link to the
1131      * desired class.
1132      */
1133     public boolean isLinkable(TypeElement typeElem) {
1134         return
1135             (typeElem != null &amp;&amp;
1136                 (isIncluded(typeElem) &amp;&amp; configuration.isGeneratedDoc(typeElem))) ||
1137             (configuration.extern.isExternal(typeElem) &amp;&amp;
1138                 (isPublic(typeElem) || isProtected(typeElem)));
1139     }
1140 
1141     /**
1142      * Returns true if an element is linkable in the context of a given type element.
1143      *
1144      * If the element is a type element, it delegates to {@link #isLinkable(TypeElement)}.
1145      * Otherwise, the element is linkable if any of the following are true:
1146      * &lt;ul&gt;
1147      * &lt;li&gt;it is &quot;included&quot; (see {@link jdk.javadoc.doclet})
1148      * &lt;li&gt;it is inherited from an undocumented supertype
1149      * &lt;li&gt;it is a public or protected member of an external API
1150      * &lt;/ul&gt;
1151      *
1152      * @param typeElem the type element
1153      * @param elem the element
1154      * @return whether or not the element is linkable
1155      */
1156     public boolean isLinkable(TypeElement typeElem, Element elem) {
1157         if (isTypeElement(elem)) {
1158             return isLinkable((TypeElement) elem); // defer to existing behavior
1159         }
1160 
1161         if (isIncluded(elem)) {
1162             return true;
1163         }
1164 
1165         // Allow for the behavior that members of undocumented supertypes
1166         // may be included in documented types
1167         if (isUndocumentedEnclosure(getEnclosingTypeElement(elem))) {
1168             return true;
1169         }
1170 
1171         // Allow for external members
1172         return isLinkable(typeElem)
1173                     &amp;&amp; configuration.extern.isExternal(typeElem)
1174                     &amp;&amp; (isPublic(elem) || isProtected(elem));
1175     }
1176 
1177     /**
1178      * Return this type as a {@code TypeElement} if it represents a class
1179      * interface or annotation.  Array dimensions are ignored.
1180      * If this type {@code ParameterizedType} or {@code WildcardType}, return
1181      * the {@code TypeElement} of the type&#39;s erasure.  If this is an
1182      * annotation, return this as a {@code TypeElement}.
1183      * If this is a primitive type, return null.
1184      *
1185      * @return the {@code TypeElement} of this type,
1186      *         or null if it is a primitive type.
1187      */
1188     public TypeElement asTypeElement(TypeMirror t) {
1189         return new SimpleTypeVisitor9&lt;TypeElement, Void&gt;() {
1190 
1191             @Override
1192             public TypeElement visitDeclared(DeclaredType t, Void p) {
1193                 return (TypeElement) t.asElement();
1194             }
1195 
1196             @Override
1197             public TypeElement visitArray(ArrayType t, Void p) {
1198                 return visit(t.getComponentType());
1199             }
1200 
1201             @Override
1202             public TypeElement visitTypeVariable(TypeVariable t, Void p) {
1203                /* TODO, this may not be an optimal fix.
1204                 * if we have an annotated type @DA T, then erasure returns a
1205                 * none, in this case we use asElement instead.
1206                 */
1207                 if (isAnnotated(t)) {
1208                     return visit(typeUtils.asElement(t).asType());
1209                 }
1210                 return visit(typeUtils.erasure(t));
1211             }
1212 
1213             @Override
1214             public TypeElement visitWildcard(WildcardType t, Void p) {
1215                 return visit(typeUtils.erasure(t));
1216             }
1217 
1218             @Override
1219             public TypeElement visitError(ErrorType t, Void p) {
1220                 return (TypeElement)t.asElement();
1221             }
1222 
1223             @Override
1224             protected TypeElement defaultAction(TypeMirror e, Void p) {
1225                 return super.defaultAction(e, p);
1226             }
1227         }.visit(t);
1228     }
1229 
1230     public TypeMirror getComponentType(TypeMirror t) {
1231         while (isArrayType(t)) {
1232             t = ((ArrayType) t).getComponentType();
1233         }
1234         return t;
1235     }
1236 
1237     /**
1238      * Return the type&#39;s dimension information, as a string.
1239      * &lt;p&gt;
1240      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1241      *
1242      * @return the type&#39;s dimension information as a string.
1243      */
1244     public String getDimension(TypeMirror t) {
1245         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
<a name="9" id="anc9"></a><span class="line-modified">1246             StringBuilder dimension = new StringBuilder();</span>
1247             @Override
1248             public String visitArray(ArrayType t, Void p) {
1249                 dimension.append(&quot;[]&quot;);
1250                 return visit(t.getComponentType());
1251             }
1252 
1253             @Override
1254             protected String defaultAction(TypeMirror e, Void p) {
1255                 return dimension.toString();
1256             }
1257 
1258         }.visit(t);
1259     }
1260 
1261     public TypeElement getSuperClass(TypeElement te) {
1262         if (isInterface(te) || isAnnotationType(te) ||
1263                 te.asType().equals(getObjectType())) {
1264             return null;
1265         }
1266         TypeMirror superclass = te.getSuperclass();
1267         if (isNoType(superclass) &amp;&amp; isClass(te)) {
1268             superclass = getObjectType();
1269         }
1270         return asTypeElement(superclass);
1271     }
1272 
1273     public TypeElement getFirstVisibleSuperClassAsTypeElement(TypeElement te) {
1274         if (isAnnotationType(te) || isInterface(te) ||
1275                 te.asType().equals(getObjectType())) {
1276             return null;
1277         }
1278         TypeMirror firstVisibleSuperClass = getFirstVisibleSuperClass(te);
1279         return firstVisibleSuperClass == null ? null : asTypeElement(firstVisibleSuperClass);
1280     }
1281 
1282     /**
1283      * Given a class, return the closest visible super class.
1284      * @param type the TypeMirror to be interrogated
1285      * @return  the closest visible super class.  Return null if it cannot
1286      *          be found.
1287      */
1288 
1289     public TypeMirror getFirstVisibleSuperClass(TypeMirror type) {
1290         return getFirstVisibleSuperClass(asTypeElement(type));
1291     }
1292 
1293 
1294     /**
1295      * Given a class, return the closest visible super class.
1296      *
1297      * @param te the TypeElement to be interrogated
1298      * @return the closest visible super class.  Return null if it cannot
1299      *         be found..
1300      */
1301     public TypeMirror getFirstVisibleSuperClass(TypeElement te) {
1302         TypeMirror superType = te.getSuperclass();
1303         if (isNoType(superType)) {
1304             superType = getObjectType();
1305         }
1306         TypeElement superClass = asTypeElement(superType);
1307         // skip &quot;hidden&quot; classes
1308         while ((superClass != null &amp;&amp; hasHiddenTag(superClass))
1309                 || (superClass != null &amp;&amp;  !isPublic(superClass) &amp;&amp; !isLinkable(superClass))) {
1310             TypeMirror supersuperType = superClass.getSuperclass();
1311             TypeElement supersuperClass = asTypeElement(supersuperType);
1312             if (supersuperClass == null
1313                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1314                 break;
1315             }
1316             superType = supersuperType;
1317             superClass = supersuperClass;
1318         }
1319         if (te.asType().equals(superType)) {
1320             return null;
1321         }
1322         return superType;
1323     }
1324 
1325     /**
1326      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1327      *
1328      * @param te the TypeElement to check.
1329      * @param lowerCaseOnly true if you want the name returned in lower case.
1330      *                      If false, the first letter of the name is capitalized.
1331      * @return
1332      */
<a name="10" id="anc10"></a>
1333     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1334         String typeName = &quot;&quot;;
1335         if (isInterface(te)) {
1336             typeName = &quot;doclet.Interface&quot;;
1337         } else if (isException(te)) {
1338             typeName = &quot;doclet.Exception&quot;;
1339         } else if (isError(te)) {
1340             typeName = &quot;doclet.Error&quot;;
1341         } else if (isAnnotationType(te)) {
1342             typeName = &quot;doclet.AnnotationType&quot;;
1343         } else if (isEnum(te)) {
1344             typeName = &quot;doclet.Enum&quot;;
1345         } else if (isOrdinaryClass(te)) {
1346             typeName = &quot;doclet.Class&quot;;
1347         }
1348         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1349         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1350     }
1351 
1352     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
1353 
1354     public String getTypeName(TypeMirror t, boolean fullyQualified) {
1355         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1356 
1357             @Override
1358             public String visitArray(ArrayType t, Void p) {
1359                 return visit(t.getComponentType());
1360             }
1361 
1362             @Override
1363             public String visitDeclared(DeclaredType t, Void p) {
1364                 TypeElement te = asTypeElement(t);
1365                 return fullyQualified
1366                         ? te.getQualifiedName().toString()
1367                         : getSimpleName(te);
1368             }
1369 
1370             @Override
1371             public String visitExecutable(ExecutableType t, Void p) {
1372                 return t.toString();
1373             }
1374 
1375             @Override
1376             public String visitPrimitive(PrimitiveType t, Void p) {
1377                 return t.toString();
1378             }
1379 
1380             @Override
1381             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1382                 return getSimpleName(t.asElement());
1383             }
1384 
1385             @Override
1386             public String visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
1387                 return t.toString();
1388             }
1389 
1390             @Override
1391             protected String defaultAction(TypeMirror e, Void p) {
1392                 return e.toString();
1393             }
1394         }.visit(t);
1395     }
1396 
1397     /**
1398      * Replace all tabs in a string with the appropriate number of spaces.
1399      * The string may be a multi-line string.
1400      * @param text the text for which the tabs should be expanded
1401      * @return the text with all tabs expanded
1402      */
1403     public String replaceTabs(String text) {
1404         if (!text.contains(&quot;\t&quot;))
1405             return text;
1406 
1407         final int tabLength = options.sourceTabSize();
1408         final String whitespace = &quot; &quot;.repeat(tabLength);
1409         final int textLength = text.length();
1410         StringBuilder result = new StringBuilder(textLength);
1411         int pos = 0;
1412         int lineLength = 0;
1413         for (int i = 0; i &lt; textLength; i++) {
1414             char ch = text.charAt(i);
1415             switch (ch) {
1416                 case &#39;\n&#39;: case &#39;\r&#39;:
1417                     lineLength = 0;
1418                     break;
1419                 case &#39;\t&#39;:
1420                     result.append(text, pos, i);
1421                     int spaceCount = tabLength - lineLength % tabLength;
1422                     result.append(whitespace, 0, spaceCount);
1423                     lineLength += spaceCount;
1424                     pos = i + 1;
1425                     break;
1426                 default:
1427                     lineLength++;
1428             }
1429         }
1430         result.append(text, pos, textLength);
1431         return result.toString();
1432     }
1433 
1434     public CharSequence normalizeNewlines(CharSequence text) {
1435         StringBuilder sb = new StringBuilder();
1436         final int textLength = text.length();
1437         final String NL = DocletConstants.NL;
1438         int pos = 0;
1439         for (int i = 0; i &lt; textLength; i++) {
1440             char ch = text.charAt(i);
1441             switch (ch) {
1442                 case &#39;\n&#39;:
1443                     sb.append(text, pos, i);
1444                     sb.append(NL);
1445                     pos = i + 1;
1446                     break;
1447                 case &#39;\r&#39;:
1448                     sb.append(text, pos, i);
1449                     sb.append(NL);
1450                     if (i + 1 &lt; textLength &amp;&amp; text.charAt(i + 1) == &#39;\n&#39;)
1451                         i++;
1452                     pos = i + 1;
1453                     break;
1454             }
1455         }
1456         sb.append(text, pos, textLength);
1457         return sb;
1458     }
1459 
1460     /**
1461      * Returns a locale independent lower cased String. That is, it
1462      * always uses US locale, this is a clone of the one in StringUtils.
1463      * @param s to convert
1464      * @return converted String
1465      */
1466     public static String toLowerCase(String s) {
1467         return s.toLowerCase(Locale.US);
1468     }
1469 
1470     /**
1471      * Return true if the given Element is deprecated.
1472      *
1473      * @param e the Element to check.
1474      * @return true if the given Element is deprecated.
1475      */
1476     public boolean isDeprecated(Element e) {
1477         if (isPackage(e)) {
1478             return configuration.workArounds.isDeprecated0(e);
1479         }
1480         return elementUtils.isDeprecated(e);
1481     }
1482 
1483     /**
1484      * Return true if the given Element is deprecated for removal.
1485      *
1486      * @param e the Element to check.
1487      * @return true if the given Element is deprecated for removal.
1488      */
1489     public boolean isDeprecatedForRemoval(Element e) {
1490         List&lt;? extends AnnotationMirror&gt; annotationList = e.getAnnotationMirrors();
1491         JavacTypes jctypes = ((DocEnvImpl) configuration.docEnv).toolEnv.typeutils;
1492         for (AnnotationMirror anno : annotationList) {
1493             if (jctypes.isSameType(anno.getAnnotationType().asElement().asType(), getDeprecatedType())) {
1494                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = anno.getElementValues();
1495                 if (!pairs.isEmpty()) {
1496                     for (ExecutableElement element : pairs.keySet()) {
1497                         if (element.getSimpleName().contentEquals(&quot;forRemoval&quot;)) {
1498                             return Boolean.parseBoolean((pairs.get(element)).toString());
1499                         }
1500                     }
1501                 }
1502             }
1503         }
1504         return false;
1505     }
1506 
1507     /**
1508      * A convenience method to get property name from the name of the
1509      * getter or setter method.
1510      * @param e the input method.
1511      * @return the name of the property of the given setter of getter.
1512      */
1513     public String propertyName(ExecutableElement e) {
1514         String name = getSimpleName(e);
1515         String propertyName = null;
1516         if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {
1517             propertyName = name.substring(3);
1518         } else if (name.startsWith(&quot;is&quot;)) {
1519             propertyName = name.substring(2);
1520         }
1521         if ((propertyName == null) || propertyName.isEmpty()){
1522             return &quot;&quot;;
1523         }
1524         return propertyName.substring(0, 1).toLowerCase(configuration.getLocale())
1525                 + propertyName.substring(1);
1526     }
1527 
1528     /**
1529      * Returns true if the element is included, contains &amp;#64;hidden tag,
1530      * or if javafx flag is present and element contains &amp;#64;treatAsPrivate
1531      * tag.
1532      * @param e the queried element
1533      * @return true if it exists, false otherwise
1534      */
1535     public boolean hasHiddenTag(Element e) {
1536         // prevent needless tests on elements which are not included
1537         if (!isIncluded(e)) {
1538             return false;
1539         }
1540         if (options.javafx() &amp;&amp;
1541                 hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, &quot;treatAsPrivate&quot;)) {
1542             return true;
1543         }
1544         return hasBlockTag(e, DocTree.Kind.HIDDEN);
1545     }
1546 
1547     /**
1548      * Returns true if the method has no comments, or a lone &amp;commat;inheritDoc.
1549      * @param m a method
1550      * @return true if there are no comments, false otherwise
1551      */
1552     public boolean isSimpleOverride(ExecutableElement m) {
1553         if (!options.summarizeOverriddenMethods() || !isIncluded(m)) {
1554             return false;
1555         }
1556 
1557         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1558             return false;
1559 
1560         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1561         return fullBody.isEmpty() ||
1562                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1563     }
1564 
1565     /**
1566      * In case of JavaFX mode on, filters out classes that are private,
1567      * package private, these are not documented in JavaFX mode, also
1568      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1569      *
1570      * @param classlist a collection of TypeElements
1571      * @param javafx set to true if in JavaFX mode.
1572      * @return list of filtered classes.
1573      */
1574     public SortedSet&lt;TypeElement&gt; filterOutPrivateClasses(Iterable&lt;TypeElement&gt; classlist,
1575             boolean javafx) {
1576         SortedSet&lt;TypeElement&gt; filteredOutClasses =
1577                 new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
1578         if (!javafx) {
1579             for (Element te : classlist) {
1580                 if (!hasHiddenTag(te)) {
1581                     filteredOutClasses.add((TypeElement)te);
1582                 }
1583             }
1584             return filteredOutClasses;
1585         }
1586         for (Element e : classlist) {
1587             if (isPrivate(e) || isPackagePrivate(e) || hasHiddenTag(e)) {
1588                 continue;
1589             }
1590             filteredOutClasses.add((TypeElement)e);
1591         }
1592         return filteredOutClasses;
1593     }
1594 
1595     /**
1596      * Compares two elements.
1597      * @param e1 first Element
1598      * @param e2 second Element
1599      * @return a true if they are the same, false otherwise.
1600      */
1601     public boolean elementsEqual(Element e1, Element e2) {
1602         if (e1.getKind() != e2.getKind()) {
1603             return false;
1604         }
1605         String s1 = getSimpleName(e1);
1606         String s2 = getSimpleName(e2);
1607         if (compareStrings(s1, s2) == 0) {
1608             String f1 = getFullyQualifiedName(e1, true);
1609             String f2 = getFullyQualifiedName(e2, true);
1610             return compareStrings(f1, f2) == 0;
1611         }
1612         return false;
1613     }
1614 
1615     /**
1616      * A general purpose case insensitive String comparator, which compares
1617      * two Strings using a Collator strength of &quot;TERTIARY&quot;.
1618      *
1619      * @param s1 first String to compare.
1620      * @param s2 second String to compare.
1621      * @return a negative integer, zero, or a positive integer as the first
1622      *         argument is less than, equal to, or greater than the second.
1623      */
1624     public int compareStrings(String s1, String s2) {
1625         return compareStrings(true, s1, s2);
1626     }
1627 
1628     /**
1629      * A general purpose case sensitive String comparator, which
1630      * compares two Strings using a Collator strength of &quot;SECONDARY&quot;.
1631      *
1632      * @param s1 first String to compare.
1633      * @param s2 second String to compare.
1634      * @return a negative integer, zero, or a positive integer as the first
1635      *         argument is less than, equal to, or greater than the second.
1636      */
1637     public int compareCaseCompare(String s1, String s2) {
1638         return compareStrings(false, s1, s2);
1639     }
1640 
1641     private DocCollator tertiaryCollator = null;
1642     private DocCollator secondaryCollator = null;
1643 
1644     private int compareStrings(boolean caseSensitive, String s1, String s2) {
1645         if (caseSensitive) {
1646             if (tertiaryCollator == null) {
1647                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1648             }
1649             return tertiaryCollator.compare(s1, s2);
1650         }
1651         if (secondaryCollator == null) {
1652             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1653         }
1654         return secondaryCollator.compare(s1, s2);
1655     }
1656 
1657     private static class DocCollator {
1658         private final Map&lt;String, CollationKey&gt; keys;
1659         private final Collator instance;
1660         private final int MAX_SIZE = 1000;
1661         private DocCollator(Locale locale, int strength) {
1662             instance = createCollator(locale);
1663             instance.setStrength(strength);
1664 
1665             keys = new LinkedHashMap&lt;String, CollationKey&gt;(MAX_SIZE + 1, 0.75f, true) {
1666                 private static final long serialVersionUID = 1L;
1667                 @Override
1668                 protected boolean removeEldestEntry(Entry&lt;String, CollationKey&gt; eldest) {
1669                     return size() &gt; MAX_SIZE;
1670                 }
1671             };
1672         }
1673 
1674         CollationKey getKey(String s) {
1675             return keys.computeIfAbsent(s, instance :: getCollationKey);
1676         }
1677 
1678         public int compare(String s1, String s2) {
1679             return getKey(s1).compareTo(getKey(s2));
1680         }
1681 
1682         private Collator createCollator(Locale locale) {
1683             Collator baseCollator = Collator.getInstance(locale);
1684             if (baseCollator instanceof RuleBasedCollator) {
1685                 // Extend collator to sort signatures with additional args and var-args in a well-defined order:
1686                 // () &lt; (int) &lt; (int, int) &lt; (int...)
1687                 try {
1688                     return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()
1689                             + &quot;&amp; &#39;)&#39; &lt; &#39;,&#39; &lt; &#39;.&#39;,&#39;[&#39;&quot;);
1690                 } catch (ParseException e) {
1691                     throw new RuntimeException(e);
1692                 }
1693             }
1694             return baseCollator;
1695         }
1696     }
1697 
1698     private Comparator&lt;Element&gt; moduleComparator = null;
1699     /**
1700      * Comparator for ModuleElements, simply compares the fully qualified names
1701      * @return a Comparator
1702      */
1703     public Comparator&lt;Element&gt; makeModuleComparator() {
1704         if (moduleComparator == null) {
1705             moduleComparator = new Utils.ElementComparator() {
1706                 @Override
1707                 public int compare(Element mod1, Element mod2) {
1708                     return compareFullyQualifiedNames(mod1, mod2);
1709                 }
1710             };
1711         }
1712         return moduleComparator;
1713     }
1714 
1715     private Comparator&lt;Element&gt; allClassesComparator = null;
1716     /**
1717      * Returns a Comparator for all classes, compares the simple names of
1718      * TypeElement, if equal then the fully qualified names.
1719      *
1720      * @return Comparator
1721      */
1722     public Comparator&lt;Element&gt; makeAllClassesComparator() {
1723         if (allClassesComparator == null) {
1724             allClassesComparator = new Utils.ElementComparator() {
1725                 @Override
1726                 public int compare(Element e1, Element e2) {
1727                     int result = compareNames(e1, e2);
1728                     if (result == 0)
1729                         result = compareFullyQualifiedNames(e1, e2);
1730 
1731                     return result;
1732                 }
1733             };
1734         }
1735         return allClassesComparator;
1736     }
1737 
1738     private Comparator&lt;Element&gt; packageComparator = null;
1739     /**
1740      * Returns a Comparator for packages, by comparing the fully qualified names.
1741      *
1742      * @return a Comparator
1743      */
1744     public Comparator&lt;Element&gt; makePackageComparator() {
1745         if (packageComparator == null) {
1746             packageComparator = new Utils.ElementComparator() {
1747                 @Override
1748                 public int compare(Element pkg1, Element pkg2) {
1749                     return compareFullyQualifiedNames(pkg1, pkg2);
1750                 }
1751             };
1752         }
1753         return packageComparator;
1754     }
1755 
1756     private Comparator&lt;Element&gt; deprecatedComparator = null;
1757     /**
1758      * Returns a Comparator for deprecated items listed on deprecated list page, by comparing the
1759      * fully qualified names.
1760      *
1761      * @return a Comparator
1762      */
1763     public Comparator&lt;Element&gt; makeDeprecatedComparator() {
1764         if (deprecatedComparator == null) {
1765             deprecatedComparator = new Utils.ElementComparator() {
1766                 @Override
1767                 public int compare(Element e1, Element e2) {
1768                     return compareFullyQualifiedNames(e1, e2);
1769                 }
1770             };
1771         }
1772         return deprecatedComparator;
1773     }
1774 
1775     private Comparator&lt;SerialFieldTree&gt; serialFieldTreeComparator = null;
1776     /**
1777      * Returns a Comparator for SerialFieldTree.
1778      * @return a Comparator
1779      */
1780     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {
1781         if (serialFieldTreeComparator == null) {
1782             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {
1783                 String s1 = o1.getName().toString();
1784                 String s2 = o2.getName().toString();
1785                 return s1.compareTo(s2);
1786             };
1787         }
1788         return serialFieldTreeComparator;
1789     }
1790 
1791     /**
1792      * Returns a general purpose comparator.
1793      * @return a Comparator
1794      */
1795     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {
1796         return makeClassUseComparator();
1797     }
1798 
1799     private Comparator&lt;Element&gt; overrideUseComparator = null;
<a name="11" id="anc11"></a><span class="line-added">1800 </span>
1801     /**
1802      * Returns a Comparator for overrides and implements,
1803      * used primarily on methods, compares the name first,
1804      * then compares the simple names of the enclosing
1805      * TypeElement and the fully qualified name of the enclosing TypeElement.
1806      * @return a Comparator
1807      */
1808     public Comparator&lt;Element&gt; makeOverrideUseComparator() {
1809         if (overrideUseComparator == null) {
1810             overrideUseComparator = new Utils.ElementComparator() {
1811                 @Override
1812                 public int compare(Element o1, Element o2) {
1813                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));
1814                     if (result != 0) {
1815                         return result;
1816                     }
1817                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {
1818                         TypeElement t1 = getEnclosingTypeElement(o1);
1819                         TypeElement t2 = getEnclosingTypeElement(o2);
1820                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));
1821                         if (result != 0)
1822                             return result;
1823                     }
1824                     result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));
1825                     if (result != 0)
1826                         return result;
1827                     return compareElementKinds(o1, o2);
1828                 }
1829             };
1830         }
1831         return overrideUseComparator;
1832     }
1833 
1834     private Comparator&lt;Element&gt; indexUseComparator = null;
1835     /**
1836      *  Returns a Comparator for index file presentations, and are sorted as follows.
1837      *  If comparing modules and/or packages then simply compare the qualified names,
1838      *  if comparing a module or a package with a type/member then compare the
1839      *  FullyQualifiedName of the module or a package with the SimpleName of the entity,
1840      *  otherwise:
1841      *  1. compare the ElementKind ex: Module, Package, Interface etc.
1842      *  2a. if equal and if the type is of ExecutableElement(Constructor, Methods),
1843      *      a case insensitive comparison of parameter the type signatures
1844      *  2b. if equal, case sensitive comparison of the type signatures
1845      *  3. finally, if equal, compare the FQNs of the entities
1846      * @return a comparator for index file use
1847      */
1848     public Comparator&lt;Element&gt; makeIndexUseComparator() {
1849         if (indexUseComparator == null) {
1850             indexUseComparator = new Utils.ElementComparator() {
1851                 /**
1852                  * Compares two elements.
1853                  *
1854                  * @param e1 - an element.
1855                  * @param e2 - an element.
1856                  * @return a negative integer, zero, or a positive integer as the first
1857                  * argument is less than, equal to, or greater than the second.
1858                  */
1859                 @Override
1860                 public int compare(Element e1, Element e2) {
1861                     int result;
1862                     // first, compare names as appropriate
1863                     if ((isModule(e1) || isPackage(e1)) &amp;&amp; (isModule(e2) || isPackage(e2))) {
1864                         result = compareFullyQualifiedNames(e1, e2);
1865                     } else if (isModule(e1) || isPackage(e1)) {
1866                         result = compareStrings(getFullyQualifiedName(e1), getSimpleName(e2));
1867                     } else if (isModule(e2) || isPackage(e2)) {
1868                         result = compareStrings(getSimpleName(e1), getFullyQualifiedName(e2));
1869                     } else {
1870                         result = compareNames(e1, e2);
1871                     }
1872                     if (result != 0) {
1873                         return result;
1874                     }
1875                     // if names are the same, compare element kinds
1876                     result = compareElementKinds(e1, e2);
1877                     if (result != 0) {
1878                         return result;
1879                     }
1880                     // if element kinds are the same, and are methods,
1881                     // compare the method parameters
1882                     if (hasParameters(e1)) {
1883                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();
1884                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();
1885                         result = compareParameters(false, parameters1, parameters2);
1886                         if (result != 0) {
1887                             return result;
1888                         }
1889                         result = compareParameters(true, parameters1, parameters2);
1890                         if (result != 0) {
1891                             return result;
1892                         }
1893                     }
1894                     // else fall back on fully qualified names
1895                     return compareFullyQualifiedNames(e1, e2);
1896                 }
1897             };
1898         }
1899         return indexUseComparator;
1900     }
1901 
1902     private Comparator&lt;TypeMirror&gt; typeMirrorClassUseComparator = null;
1903     /**
1904      * Compares the FullyQualifiedNames of two TypeMirrors
1905      * @return
1906      */
1907     public Comparator&lt;TypeMirror&gt; makeTypeMirrorClassUseComparator() {
1908         if (typeMirrorClassUseComparator == null) {
1909             typeMirrorClassUseComparator = (TypeMirror type1, TypeMirror type2) -&gt; {
1910                 String s1 = getQualifiedTypeName(type1);
1911                 String s2 = getQualifiedTypeName(type2);
1912                 return compareStrings(s1, s2);
1913             };
1914         }
1915         return typeMirrorClassUseComparator;
1916     }
1917 
1918     private Comparator&lt;TypeMirror&gt; typeMirrorIndexUseComparator = null;
1919     /**
1920      * Compares the SimpleNames of TypeMirrors if equal then the
1921      * FullyQualifiedNames of TypeMirrors.
1922      *
1923      * @return
1924      */
1925     public Comparator&lt;TypeMirror&gt; makeTypeMirrorIndexUseComparator() {
1926         if (typeMirrorIndexUseComparator == null) {
1927             typeMirrorIndexUseComparator = (TypeMirror t1, TypeMirror t2) -&gt; {
1928                 int result = compareStrings(getTypeName(t1, false), getTypeName(t2, false));
1929                 if (result != 0)
1930                     return result;
1931                 return compareStrings(getQualifiedTypeName(t1), getQualifiedTypeName(t2));
1932             };
1933         }
1934         return typeMirrorIndexUseComparator;
1935     }
1936 
1937     /**
1938      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s
1939      * getQualified name, returns  the qualified name of the Reference type
1940      * otherwise the primitive name.
1941      * @param t the type whose name is to be obtained.
1942      * @return the fully qualified name of Reference type or the primitive name
1943      */
1944     public String getQualifiedTypeName(TypeMirror t) {
1945         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1946             @Override
1947             public String visitDeclared(DeclaredType t, Void p) {
1948                 return getFullyQualifiedName(t.asElement());
1949             }
1950 
1951             @Override
1952             public String visitArray(ArrayType t, Void p) {
1953                return visit(t.getComponentType());
1954             }
1955 
1956             @Override
1957             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1958                 // The knee jerk reaction is to do this but don&#39;t!, as we would like
1959                 // it to be compatible with the old world, now if we decide to do so
1960                 // care must be taken to avoid collisions.
1961                 // return getFullyQualifiedName(t.asElement());
1962                 return t.toString();
1963             }
1964 
1965             @Override
1966             protected String defaultAction(TypeMirror t, Void p) {
1967                 return t.toString();
1968             }
1969 
1970         }.visit(t);
1971     }
1972 
1973     /**
1974      * A generic utility which returns the fully qualified names of an entity,
1975      * if the entity is not qualifiable then its enclosing entity, it is upto
1976      * the caller to add the elements name as required.
1977      * @param e the element to get FQN for.
1978      * @return the name
1979      */
1980     public String getFullyQualifiedName(Element e) {
1981         return getFullyQualifiedName(e, true);
1982     }
1983 
1984     @SuppressWarnings(&quot;preview&quot;)
1985     public String getFullyQualifiedName(Element e, final boolean outer) {
1986         return new SimpleElementVisitor14&lt;String, Void&gt;() {
1987             @Override
1988             public String visitModule(ModuleElement e, Void p) {
1989                 return e.getQualifiedName().toString();
1990             }
1991 
1992             @Override
1993             public String visitPackage(PackageElement e, Void p) {
1994                 return e.getQualifiedName().toString();
1995             }
1996 
1997             @Override
1998             public String visitType(TypeElement e, Void p) {
1999                 return e.getQualifiedName().toString();
2000             }
2001 
2002             @Override
2003             protected String defaultAction(Element e, Void p) {
2004                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
2005             }
2006         }.visit(e);
2007     }
2008 
2009     private Comparator&lt;Element&gt; classUseComparator = null;
<a name="12" id="anc12"></a><span class="line-added">2010 </span>
2011     /**
2012      * Comparator for ClassUse presentations, and sorts as follows:
2013      * 1. member names
2014      * 2. then fully qualified member names
2015      * 3. then parameter types if applicable
2016      * 4. finally the element kinds ie. package, class, interface etc.
2017      * @return a comparator to sort classes and members for class use
2018      */
2019     public Comparator&lt;Element&gt; makeClassUseComparator() {
2020         if (classUseComparator == null) {
2021             classUseComparator = new Utils.ElementComparator() {
2022                 /**
2023                  * Compares two Elements.
2024                  *
2025                  * @param e1 - an element.
2026                  * @param e2 - an element.
2027                  * @return a negative integer, zero, or a positive integer as the first
2028                  * argument is less than, equal to, or greater than the second.
2029                  */
2030                 @Override
2031                 public int compare(Element e1, Element e2) {
2032                     int result = compareNames(e1, e2);
2033                     if (result != 0) {
2034                         return result;
2035                     }
2036                     result = compareFullyQualifiedNames(e1, e2);
2037                     if (result != 0) {
2038                         return result;
2039                     }
2040                     if (hasParameters(e1) &amp;&amp; hasParameters(e2)) {
2041                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();
2042                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();
2043                         result = compareParameters(false, parameters1, parameters2);
2044                         if (result != 0) {
2045                             return result;
2046                         }
2047                         result = compareParameters(true, parameters1, parameters2);
2048                     }
2049                     if (result != 0) {
2050                         return result;
2051                     }
2052                     return compareElementKinds(e1, e2);
2053                 }
2054             };
2055         }
2056         return classUseComparator;
2057     }
2058 
2059     /**
2060      * A general purpose comparator to sort Element entities, basically provides the building blocks
2061      * for creating specific comparators for an use-case.
2062      */
2063     private abstract class ElementComparator implements Comparator&lt;Element&gt; {
2064         public ElementComparator() { }
2065 
2066         /**
2067          * compares two parameter arrays by first comparing the length of the arrays, and
2068          * then each Type of the parameter in the array.
2069          * @param params1 the first parameter array.
2070          * @param params2 the first parameter array.
2071          * @return a negative integer, zero, or a positive integer as the first
2072          *         argument is less than, equal to, or greater than the second.
2073          */
2074         protected int compareParameters(boolean caseSensitive, List&lt;? extends VariableElement&gt; params1,
2075                                                                List&lt;? extends VariableElement&gt; params2) {
2076 
2077             return compareStrings(caseSensitive, getParametersAsString(params1),
2078                                                  getParametersAsString(params2));
2079         }
2080 
2081         String getParametersAsString(List&lt;? extends VariableElement&gt; params) {
2082             StringBuilder sb = new StringBuilder();
2083             for (VariableElement param : params) {
2084                 TypeMirror t = param.asType();
2085                 // prefix P for primitive and R for reference types, thus items will
2086                 // be ordered lexically and correctly.
2087                 sb.append(getTypeCode(t)).append(&quot;-&quot;).append(t).append(&quot;-&quot;);
2088             }
2089             return sb.toString();
2090         }
2091 
2092         private String getTypeCode(TypeMirror t) {
2093             return new SimpleTypeVisitor9&lt;String, Void&gt;() {
2094 
2095                 @Override
2096                 public String visitPrimitive(PrimitiveType t, Void p) {
2097                     return &quot;P&quot;;
2098                 }
2099                 @Override
2100                 public String visitArray(ArrayType t, Void p) {
2101                     return visit(t.getComponentType());
2102                 }
2103                 @Override
2104                 protected String defaultAction(TypeMirror e, Void p) {
2105                     return &quot;R&quot;;
2106                 }
2107 
2108             }.visit(t);
2109         }
2110 
2111         /**
2112          * Compares two Elements, typically the name of a method,
2113          * field or constructor.
2114          * @param e1 the first Element.
2115          * @param e2 the second Element.
2116          * @return a negative integer, zero, or a positive integer as the first
2117          *         argument is less than, equal to, or greater than the second.
2118          */
2119         protected int compareNames(Element e1, Element e2) {
2120             return compareStrings(getSimpleName(e1), getSimpleName(e2));
2121         }
2122 
2123         /**
2124          * Compares the fully qualified names of the entities
2125          * @param e1 the first Element.
2126          * @param e2 the first Element.
2127          * @return a negative integer, zero, or a positive integer as the first
2128          *         argument is less than, equal to, or greater than the second.
2129          */
2130         protected int compareFullyQualifiedNames(Element e1, Element e2) {
2131             // add simplename to be compatible
2132             String thisElement = getFullyQualifiedName(e1);
2133             String thatElement = getFullyQualifiedName(e2);
2134             return compareStrings(thisElement, thatElement);
2135         }
2136 
2137         protected int compareElementKinds(Element e1, Element e2) {
2138             return Integer.compare(getKindIndex(e1), getKindIndex(e2));
2139         }
2140 
2141         private int getKindIndex(Element e) {
2142             switch (e.getKind()) {
2143                 case MODULE:            return 0;
2144                 case PACKAGE:           return 1;
2145                 case CLASS:             return 2;
2146                 case ENUM:              return 3;
2147                 case ENUM_CONSTANT:     return 4;
2148                 case RECORD:            return 5;
2149                 case INTERFACE:         return 6;
2150                 case ANNOTATION_TYPE:   return 7;
2151                 case FIELD:             return 8;
2152                 case CONSTRUCTOR:       return 9;
2153                 case METHOD:            return 10;
2154                 default: throw new IllegalArgumentException(e.getKind().toString());
2155             }
2156         }
2157 
2158         @SuppressWarnings(&quot;preview&quot;)
2159         boolean hasParameters(Element e) {
2160             return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2161                 @Override
2162                 public Boolean visitExecutable(ExecutableElement e, Void p) {
2163                     return true;
2164                 }
2165 
2166                 @Override
2167                 protected Boolean defaultAction(Element e, Void p) {
2168                     return false;
2169                 }
2170 
2171             }.visit(e);
2172         }
2173 
2174         /**
2175          * The fully qualified names of the entities, used solely by the comparator.
2176          *
2177          * @return a negative integer, zero, or a positive integer as the first argument is less
2178          * than, equal to, or greater than the second.
2179          */
2180         @SuppressWarnings(&quot;preview&quot;)
2181         private String getFullyQualifiedName(Element e) {
2182             return new SimpleElementVisitor14&lt;String, Void&gt;() {
2183                 @Override
2184                 public String visitModule(ModuleElement e, Void p) {
2185                     return e.getQualifiedName().toString();
2186                 }
2187 
2188                 @Override
2189                 public String visitPackage(PackageElement e, Void p) {
2190                     return e.getQualifiedName().toString();
2191                 }
2192 
2193                 @Override
2194                 public String visitExecutable(ExecutableElement e, Void p) {
2195                     // For backward compatibility
2196                     return getFullyQualifiedName(e.getEnclosingElement())
2197                             + &quot;.&quot; + e.getSimpleName().toString();
2198                 }
2199 
2200                 @Override
2201                 public String visitType(TypeElement e, Void p) {
2202                     return e.getQualifiedName().toString();
2203                 }
2204 
2205                 @Override
2206                 protected String defaultAction(Element e, Void p) {
2207                     return getEnclosingTypeElement(e).getQualifiedName().toString()
2208                             + &quot;.&quot; + e.getSimpleName().toString();
2209                 }
2210             }.visit(e);
2211         }
2212     }
2213 
2214     /**
2215      * Returns a Comparator for SearchIndexItems representing types. Items are
2216      * compared by short name, or full string representation if names are equal.
2217      *
2218      * @return a Comparator
2219      */
2220     public Comparator&lt;SearchIndexItem&gt; makeTypeSearchIndexComparator() {
2221         return (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {
2222             int result = compareStrings(sii1.getSimpleName(), sii2.getSimpleName());
2223             if (result == 0) {
2224                 // TreeSet needs this to be consistent with equal so we do
2225                 // a plain comparison of string representations as fallback.
2226                 result = sii1.toString().compareTo(sii2.toString());
2227             }
2228             return result;
2229         };
2230     }
2231 
2232     private Comparator&lt;SearchIndexItem&gt; genericSearchIndexComparator = null;
2233     /**
2234      * Returns a Comparator for SearchIndexItems representing modules, packages, or members.
2235      * Items are compared by label (member name plus signature for members, package name for
2236      * packages, and module name for modules). If labels are equal then full string
2237      * representation is compared.
2238      *
2239      * @return a Comparator
2240      */
2241     public Comparator&lt;SearchIndexItem&gt; makeGenericSearchIndexComparator() {
2242         if (genericSearchIndexComparator == null) {
2243             genericSearchIndexComparator = (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {
2244                 int result = compareStrings(sii1.getLabel(), sii2.getLabel());
2245                 if (result == 0) {
2246                     // TreeSet needs this to be consistent with equal so we do
2247                     // a plain comparison of string representations as fallback.
2248                     result = sii1.toString().compareTo(sii2.toString());
2249                 }
2250                 return result;
2251             };
2252         }
2253         return genericSearchIndexComparator;
2254     }
2255 
2256     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
2257         List&lt;TypeElement&gt; out = getInterfaces(pkg);
2258         out.addAll(getClasses(pkg));
2259         out.addAll(getEnums(pkg));
2260         out.addAll(getAnnotationTypes(pkg));
2261         out.addAll(getRecords(pkg));
2262         return out;
2263     }
2264 
2265     // Element related methods
2266     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
2267         List&lt;Element&gt; members = getAnnotationFields(aClass);
2268         members.addAll(getAnnotationMethods(aClass));
2269         return members;
2270     }
2271 
2272     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
2273         return getItems0(aClass, true, FIELD);
2274     }
2275 
2276     List&lt;Element&gt; getAnnotationFieldsUnfiltered(TypeElement aClass) {
2277         return getItems0(aClass, true, FIELD);
2278     }
2279 
2280     public List&lt;Element&gt; getAnnotationMethods(TypeElement aClass) {
2281         return getItems0(aClass, true, METHOD);
2282     }
2283 
2284     public List&lt;TypeElement&gt; getAnnotationTypes(Element e) {
2285         return convertToTypeElement(getItems(e, true, ANNOTATION_TYPE));
2286     }
2287 
2288     public List&lt;TypeElement&gt; getAnnotationTypesUnfiltered(Element e) {
2289         return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));
2290     }
2291 
2292     @SuppressWarnings(&quot;preview&quot;)
2293     public List&lt;TypeElement&gt; getRecords(Element e) {
2294         return convertToTypeElement(getItems(e, true, RECORD));
2295     }
2296 
2297     @SuppressWarnings(&quot;preview&quot;)
2298     public List&lt;TypeElement&gt; getRecordsUnfiltered(Element e) {
2299         return convertToTypeElement(getItems(e, false, RECORD));
2300     }
2301 
2302     public List&lt;VariableElement&gt; getFields(Element e) {
2303         return convertToVariableElement(getItems(e, true, FIELD));
2304     }
2305 
2306     public List&lt;VariableElement&gt; getFieldsUnfiltered(Element e) {
2307         return convertToVariableElement(getItems(e, false, FIELD));
2308     }
2309 
2310     public List&lt;TypeElement&gt; getClasses(Element e) {
2311        return convertToTypeElement(getItems(e, true, CLASS));
2312     }
2313 
2314     public List&lt;TypeElement&gt; getClassesUnfiltered(Element e) {
2315        return convertToTypeElement(getItems(e, false, CLASS));
2316     }
2317 
2318     public List&lt;ExecutableElement&gt; getConstructors(Element e) {
2319         return convertToExecutableElement(getItems(e, true, CONSTRUCTOR));
2320     }
2321 
2322     public List&lt;ExecutableElement&gt; getMethods(Element e) {
2323         return convertToExecutableElement(getItems(e, true, METHOD));
2324     }
2325 
2326     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
2327         return convertToExecutableElement(getItems(e, false, METHOD));
2328     }
2329 
2330     public int getOrdinalValue(VariableElement member) {
2331         if (member == null || member.getKind() != ENUM_CONSTANT) {
2332             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2333         }
2334         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2335     }
2336 
2337     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2338     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2339         if (modulePackageMap == null) {
2340             modulePackageMap = new HashMap&lt;&gt;();
2341             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
<a name="13" id="anc13"></a><span class="line-modified">2342             pkgs.forEach(pkg -&gt; {</span>
2343                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2344                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2345             });
2346         }
2347         return modulePackageMap;
2348     }
2349 
2350     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
2351         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());
2352         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2353         // get all the requires for the element in question
2354         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2355             ModuleElement dep = rd.getDependency();
2356             // add the dependency to work queue
2357             if (!result.containsKey(dep)) {
2358                 if (rd.isTransitive()) {
2359                     queue.addLast(dep);
2360                 }
2361             }
2362             // add all exports for the primary module
2363             result.put(rd.getDependency(), getModifiers(rd));
2364         }
2365 
2366         // add only requires public for subsequent module dependencies
2367         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2368             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2369                 ModuleElement dep = rd.getDependency();
2370                 if (!result.containsKey(dep)) {
2371                     if (rd.isTransitive()) {
2372                         result.put(dep, getModifiers(rd));
2373                         queue.addLast(dep);
2374                     }
2375                 }
2376             }
2377         }
2378         return result;
2379     }
2380 
2381     public String getModifiers(RequiresDirective rd) {
2382         StringBuilder modifiers = new StringBuilder();
<a name="14" id="anc14"></a><span class="line-modified">2383         String sep = &quot;&quot;;</span>
2384         if (rd.isTransitive()) {
2385             modifiers.append(&quot;transitive&quot;);
2386             sep = &quot; &quot;;
2387         }
2388         if (rd.isStatic()) {
2389             modifiers.append(sep);
2390             modifiers.append(&quot;static&quot;);
2391         }
2392         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
2393     }
2394 
2395     public long getLineNumber(Element e) {
2396         TreePath path = getTreePath(e);
2397         if (path == null) { // maybe null if synthesized
2398             TypeElement encl = getEnclosingTypeElement(e);
2399             path = getTreePath(encl);
2400         }
2401         CompilationUnitTree cu = path.getCompilationUnit();
2402         LineMap lineMap = cu.getLineMap();
2403         DocSourcePositions spos = docTrees.getSourcePositions();
2404         long pos = spos.getStartPosition(cu, path.getLeaf());
2405         return lineMap.getLineNumber(pos);
2406     }
2407 
2408     public List&lt;ExecutableElement&gt; convertToExecutableElement(List&lt;Element&gt; list) {
2409         List&lt;ExecutableElement&gt; out = new ArrayList&lt;&gt;(list.size());
2410         for (Element e : list) {
2411             out.add((ExecutableElement)e);
2412         }
2413         return out;
2414     }
2415 
2416     public List&lt;TypeElement&gt; convertToTypeElement(List&lt;Element&gt; list) {
2417         List&lt;TypeElement&gt; out = new ArrayList&lt;&gt;(list.size());
2418         for (Element e : list) {
2419             out.add((TypeElement)e);
2420         }
2421         return out;
2422     }
2423 
2424     public List&lt;VariableElement&gt; convertToVariableElement(List&lt;Element&gt; list) {
2425         List&lt;VariableElement&gt; out = new ArrayList&lt;&gt;(list.size());
2426         for (Element e : list) {
2427             out.add((VariableElement) e);
2428         }
2429         return out;
2430     }
2431 
2432     public List&lt;TypeElement&gt; getInterfaces(Element e)  {
2433         return convertToTypeElement(getItems(e, true, INTERFACE));
2434     }
2435 
2436     public List&lt;TypeElement&gt; getInterfacesUnfiltered(Element e)  {
2437         return convertToTypeElement(getItems(e, false, INTERFACE));
2438     }
2439 
2440     public List&lt;Element&gt; getEnumConstants(Element e) {
2441         return getItems(e, true, ENUM_CONSTANT);
2442     }
2443 
2444     public List&lt;TypeElement&gt; getEnums(Element e) {
2445         return convertToTypeElement(getItems(e, true, ENUM));
2446     }
2447 
2448     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2449         return convertToTypeElement(getItems(e, false, ENUM));
2450     }
2451 
2452     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2453         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2454         clist.addAll(getInterfacesUnfiltered(e));
2455         clist.addAll(getAnnotationTypesUnfiltered(e));
2456         clist.addAll(getRecordsUnfiltered(e));
2457         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
2458         oset.addAll(clist);
2459         return oset;
2460     }
2461 
2462     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2463     /**
2464      * Returns a list containing classes and interfaces,
2465      * including annotation types.
2466      * @param e Element
2467      * @return List
2468      */
2469     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2470         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2471         if (oset != null)
2472             return oset;
2473         List&lt;TypeElement&gt; clist = getClasses(e);
2474         clist.addAll(getInterfaces(e));
2475         clist.addAll(getAnnotationTypes(e));
2476         clist.addAll(getEnums(e));
2477         clist.addAll(getRecords(e));
2478         oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
2479         oset.addAll(clist);
2480         cachedClasses.put(e, oset);
2481         return oset;
2482     }
2483 
2484     /*
2485      * Get all the elements unfiltered and filter them finally based
2486      * on its visibility, this works differently from the other getters.
2487      */
2488     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2489         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2490         for (TypeElement te : getClassesUnfiltered(e)) {
2491             if (!filter || configuration.docEnv.isSelected(te)) {
2492                 olist.add(te);
2493             }
2494         }
2495         for (TypeElement te : getInterfacesUnfiltered(e)) {
2496             if (!filter || configuration.docEnv.isSelected(te)) {
2497                 olist.add(te);
2498             }
2499         }
2500         for (TypeElement te : getAnnotationTypesUnfiltered(e)) {
2501             if (!filter || configuration.docEnv.isSelected(te)) {
2502                 olist.add(te);
2503             }
2504         }
2505         for (TypeElement te : getEnumsUnfiltered(e)) {
2506             if (!filter || configuration.docEnv.isSelected(te)) {
2507                 olist.add(te);
2508             }
2509         }
2510         return olist;
2511     }
2512 
2513     public List&lt;TypeElement&gt; getInnerClasses(Element e) {
2514         return getInnerClasses(e, true);
2515     }
2516 
2517     public List&lt;TypeElement&gt; getInnerClassesUnfiltered(Element e) {
2518         return getInnerClasses(e, false);
2519     }
2520 
2521     /**
2522      * Returns a list of classes that are not errors or exceptions
2523      * @param e Element
2524      * @return List
2525      */
2526     public List&lt;TypeElement&gt; getOrdinaryClasses(Element e) {
2527         return getClasses(e).stream()
2528                 .filter(te -&gt; (!isException(te) &amp;&amp; !isError(te)))
2529                 .collect(Collectors.toList());
2530     }
2531 
2532     public List&lt;TypeElement&gt; getErrors(Element e) {
2533         return getClasses(e)
2534                 .stream()
2535                 .filter(this::isError)
2536                 .collect(Collectors.toList());
2537     }
2538 
2539     public List&lt;TypeElement&gt; getExceptions(Element e) {
2540         return getClasses(e)
2541                 .stream()
2542                 .filter(this::isException)
2543                 .collect(Collectors.toList());
2544     }
2545 
2546     @SuppressWarnings(&quot;preview&quot;)
2547     List&lt;Element&gt; getItems(Element e, boolean filter, ElementKind select) {
2548         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2549         return new SimpleElementVisitor14&lt;List&lt;Element&gt;, Void&gt;() {
2550 
2551             @Override
2552             public List&lt;Element&gt; visitPackage(PackageElement e, Void p) {
2553                 recursiveGetItems(elements, e, filter, select);
2554                 return elements;
2555             }
2556 
2557             @Override
2558             protected List&lt;Element&gt; defaultAction(Element e0, Void p) {
2559                 return getItems0(e0, filter, select);
2560             }
2561 
2562         }.visit(e);
2563     }
2564 
2565     Set&lt;ElementKind&gt; nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);
2566     void recursiveGetItems(Collection&lt;Element&gt; list, Element e, boolean filter, ElementKind... select) {
2567         list.addAll(getItems0(e, filter, select));
2568         List&lt;Element&gt; classes = getItems0(e, filter, nestedKinds);
2569         for (Element c : classes) {
2570             list.addAll(getItems0(c, filter, select));
2571             if (isTypeElement(c)) {
2572                 recursiveGetItems(list, c, filter, select);
2573             }
2574         }
2575     }
2576 
2577     private List&lt;Element&gt; getItems0(Element te, boolean filter, ElementKind... select) {
2578         Set&lt;ElementKind&gt; kinds = EnumSet.copyOf(Arrays.asList(select));
2579         return getItems0(te, filter, kinds);
2580     }
2581 
2582     private List&lt;Element&gt; getItems0(Element te, boolean filter, Set&lt;ElementKind&gt; kinds) {
2583         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2584         for (Element e : te.getEnclosedElements()) {
2585             if (kinds.contains(e.getKind())) {
2586                 if (!filter || shouldDocument(e)) {
2587                     elements.add(e);
2588                 }
2589             }
2590         }
2591         return elements;
2592     }
2593 
2594     @SuppressWarnings(&quot;preview&quot;)
2595     private SimpleElementVisitor14&lt;Boolean, Void&gt; shouldDocumentVisitor = null;
2596 
2597     @SuppressWarnings(&quot;preview&quot;)
2598     public boolean shouldDocument(Element e) {
2599         if (shouldDocumentVisitor == null) {
2600             shouldDocumentVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2601                 private boolean hasSource(TypeElement e) {
2602                     return configuration.docEnv.getFileKind(e) ==
2603                             javax.tools.JavaFileObject.Kind.SOURCE;
2604                 }
2605 
2606                 // handle types
2607                 @Override
2608                 public Boolean visitType(TypeElement e, Void p) {
2609                     // treat inner classes etc as members
2610                     if (e.getNestingKind().isNested()) {
2611                         return defaultAction(e, p);
2612                     }
2613                     return configuration.docEnv.isSelected(e) &amp;&amp; hasSource(e);
2614                 }
2615 
2616                 // handle everything else
2617                 @Override
2618                 protected Boolean defaultAction(Element e, Void p) {
2619                     return configuration.docEnv.isSelected(e);
2620                 }
2621 
2622                 @Override
2623                 public Boolean visitUnknown(Element e, Void p) {
2624                     throw new AssertionError(&quot;unknown element: &quot; + e);
2625                 }
2626             };
2627         }
2628         return shouldDocumentVisitor.visit(e);
2629     }
2630 
2631     /*
2632      * nameCache is maintained for improving the comparator
2633      * performance, noting that the Collator used by the comparators
2634      * use Strings, as of this writing.
2635      * TODO: when those APIs handle charSequences, the use of
2636      * this nameCache must be re-investigated and removed.
2637      */
2638     private final Map&lt;Element, String&gt; nameCache = new LinkedHashMap&lt;&gt;();
2639 
2640     /**
2641      * Returns the name of the element after the last dot of the package name.
2642      * This emulates the behavior of the old doclet.
2643      * @param e an element whose name is required
2644      * @return the name
2645      */
2646     public String getSimpleName(Element e) {
2647         return nameCache.computeIfAbsent(e, this::getSimpleName0);
2648     }
2649 
2650     @SuppressWarnings(&quot;preview&quot;)
2651     private SimpleElementVisitor14&lt;String, Void&gt; snvisitor = null;
2652 
2653     @SuppressWarnings(&quot;preview&quot;)
2654     private String getSimpleName0(Element e) {
2655         if (snvisitor == null) {
2656             snvisitor = new SimpleElementVisitor14&lt;String, Void&gt;() {
2657                 @Override
2658                 public String visitModule(ModuleElement e, Void p) {
2659                     return e.getQualifiedName().toString();  // temp fix for 8182736
2660                 }
2661 
2662                 @Override
2663                 public String visitType(TypeElement e, Void p) {
2664                     StringBuilder sb = new StringBuilder(e.getSimpleName());
2665                     Element enclosed = e.getEnclosingElement();
2666                     while (enclosed != null
2667                             &amp;&amp; (enclosed.getKind().isClass() || enclosed.getKind().isInterface())) {
2668                         sb.insert(0, enclosed.getSimpleName() + &quot;.&quot;);
2669                         enclosed = enclosed.getEnclosingElement();
2670                     }
2671                     return sb.toString();
2672                 }
2673 
2674                 @Override
2675                 public String visitExecutable(ExecutableElement e, Void p) {
2676                     if (e.getKind() == CONSTRUCTOR || e.getKind() == STATIC_INIT) {
2677                         return e.getEnclosingElement().getSimpleName().toString();
2678                     }
2679                     return e.getSimpleName().toString();
2680                 }
2681 
2682                 @Override
2683                 protected String defaultAction(Element e, Void p) {
2684                     return e.getSimpleName().toString();
2685                 }
2686             };
2687         }
2688         return snvisitor.visit(e);
2689     }
2690 
2691     public TypeElement getEnclosingTypeElement(Element e) {
2692         if (e.getKind() == ElementKind.PACKAGE)
2693             return null;
2694         Element encl = e.getEnclosingElement();
2695         ElementKind kind = encl.getKind();
2696         if (kind == ElementKind.PACKAGE)
2697             return null;
2698         while (!(kind.isClass() || kind.isInterface())) {
2699             encl = encl.getEnclosingElement();
2700             kind = encl.getKind();
2701         }
2702         return (TypeElement)encl;
2703     }
2704 
2705     private ConstantValueExpression cve = null;
2706 
2707     public String constantValueExpresion(VariableElement ve) {
2708         if (cve == null)
2709             cve = new ConstantValueExpression();
2710         return cve.constantValueExpression(configuration.workArounds, ve);
2711     }
2712 
2713     private static class ConstantValueExpression {
2714         public String constantValueExpression(WorkArounds workArounds, VariableElement ve) {
2715             return new TypeKindVisitor9&lt;String, Object&gt;() {
2716                 /* TODO: we need to fix this correctly.
2717                  * we have a discrepancy here, note the use of getConstValue
2718                  * vs. getConstantValue, at some point we need to use
2719                  * getConstantValue.
2720                  * In the legacy world byte and char primitives appear as Integer values,
2721                  * thus a byte value of 127 will appear as 127, but in the new world,
2722                  * a byte value appears as Byte thus 0x7f will be printed, similarly
2723                  * chars will be  translated to \n, \r etc. however, in the new world,
2724                  * they will be printed as decimal values. The new world is correct,
2725                  * and we should fix this by using getConstantValue and the visitor to
2726                  * address this in the future.
2727                  */
2728                 @Override
2729                 public String visitPrimitiveAsBoolean(PrimitiveType t, Object val) {
2730                     return (int)val == 0 ? &quot;false&quot; : &quot;true&quot;;
2731                 }
2732 
2733                 @Override
2734                 public String visitPrimitiveAsDouble(PrimitiveType t, Object val) {
2735                     return sourceForm(((Double)val), &#39;d&#39;);
2736                 }
2737 
2738                 @Override
2739                 public String visitPrimitiveAsFloat(PrimitiveType t, Object val) {
2740                     return sourceForm(((Float)val).doubleValue(), &#39;f&#39;);
2741                 }
2742 
2743                 @Override
2744                 public String visitPrimitiveAsLong(PrimitiveType t, Object val) {
2745                     return val + &quot;L&quot;;
2746                 }
2747 
2748                 @Override
2749                 protected String defaultAction(TypeMirror e, Object val) {
2750                     if (val == null)
2751                         return null;
2752                     else if (val instanceof Character)
2753                         return sourceForm(((Character)val));
2754                     else if (val instanceof Byte)
2755                         return sourceForm(((Byte)val));
2756                     else if (val instanceof String)
2757                         return sourceForm((String)val);
2758                     return val.toString(); // covers int, short
2759                 }
2760             }.visit(ve.asType(), workArounds.getConstValue(ve));
2761         }
2762 
2763         // where
2764         private String sourceForm(double v, char suffix) {
2765             if (Double.isNaN(v))
2766                 return &quot;0&quot; + suffix + &quot;/0&quot; + suffix;
2767             if (v == Double.POSITIVE_INFINITY)
2768                 return &quot;1&quot; + suffix + &quot;/0&quot; + suffix;
2769             if (v == Double.NEGATIVE_INFINITY)
2770                 return &quot;-1&quot; + suffix + &quot;/0&quot; + suffix;
2771             return v + (suffix == &#39;f&#39; || suffix == &#39;F&#39; ? &quot;&quot; + suffix : &quot;&quot;);
2772         }
2773 
2774         private  String sourceForm(char c) {
2775             StringBuilder buf = new StringBuilder(8);
2776             buf.append(&#39;\&#39;&#39;);
2777             sourceChar(c, buf);
2778             buf.append(&#39;\&#39;&#39;);
2779             return buf.toString();
2780         }
2781 
2782         private String sourceForm(byte c) {
2783             return &quot;0x&quot; + Integer.toString(c &amp; 0xff, 16);
2784         }
2785 
2786         private String sourceForm(String s) {
2787             StringBuilder buf = new StringBuilder(s.length() + 5);
2788             buf.append(&#39;\&quot;&#39;);
2789             for (int i=0; i&lt;s.length(); i++) {
2790                 char c = s.charAt(i);
2791                 sourceChar(c, buf);
2792             }
2793             buf.append(&#39;\&quot;&#39;);
2794             return buf.toString();
2795         }
2796 
2797         private void sourceChar(char c, StringBuilder buf) {
2798             switch (c) {
2799             case &#39;\b&#39;: buf.append(&quot;\\b&quot;); return;
2800             case &#39;\t&#39;: buf.append(&quot;\\t&quot;); return;
2801             case &#39;\n&#39;: buf.append(&quot;\\n&quot;); return;
2802             case &#39;\f&#39;: buf.append(&quot;\\f&quot;); return;
2803             case &#39;\r&#39;: buf.append(&quot;\\r&quot;); return;
2804             case &#39;\&quot;&#39;: buf.append(&quot;\\\&quot;&quot;); return;
2805             case &#39;\&#39;&#39;: buf.append(&quot;\\\&#39;&quot;); return;
2806             case &#39;\\&#39;: buf.append(&quot;\\\\&quot;); return;
2807             default:
2808                 if (isPrintableAscii(c)) {
2809                     buf.append(c); return;
2810                 }
2811                 unicodeEscape(c, buf);
2812                 return;
2813             }
2814         }
2815 
2816         private void unicodeEscape(char c, StringBuilder buf) {
2817             final String chars = &quot;0123456789abcdef&quot;;
2818             buf.append(&quot;\\u&quot;);
2819             buf.append(chars.charAt(15 &amp; (c&gt;&gt;12)));
2820             buf.append(chars.charAt(15 &amp; (c&gt;&gt;8)));
2821             buf.append(chars.charAt(15 &amp; (c&gt;&gt;4)));
2822             buf.append(chars.charAt(15 &amp; (c&gt;&gt;0)));
2823         }
2824         private boolean isPrintableAscii(char c) {
2825             return c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;;
2826         }
2827     }
2828 
2829     public boolean isEnclosingPackageIncluded(TypeElement te) {
2830         return isIncluded(containingPackage(te));
2831     }
2832 
2833     public boolean isIncluded(Element e) {
2834         return configuration.docEnv.isIncluded(e);
2835     }
2836 
2837     @SuppressWarnings(&quot;preview&quot;)
2838     private SimpleElementVisitor14&lt;Boolean, Void&gt; specifiedVisitor = null;
2839     @SuppressWarnings(&quot;preview&quot;)
2840     public boolean isSpecified(Element e) {
2841         if (specifiedVisitor == null) {
2842             specifiedVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2843                 @Override
2844                 public Boolean visitModule(ModuleElement e, Void p) {
2845                     return configuration.getSpecifiedModuleElements().contains(e);
2846                 }
2847 
2848                 @Override
2849                 public Boolean visitPackage(PackageElement e, Void p) {
2850                     return configuration.getSpecifiedPackageElements().contains(e);
2851                 }
2852 
2853                 @Override
2854                 public Boolean visitType(TypeElement e, Void p) {
2855                     return configuration.getSpecifiedTypeElements().contains(e);
2856                 }
2857 
2858                 @Override
2859                 protected Boolean defaultAction(Element e, Void p) {
2860                     return false;
2861                 }
2862             };
2863         }
2864         return specifiedVisitor.visit(e);
2865     }
2866 
2867     /**
2868      * Get the package name for a given package element. An unnamed package is returned as &amp;lt;Unnamed&amp;gt;
2869      *
2870      * @param pkg
2871      * @return
2872      */
2873     public String getPackageName(PackageElement pkg) {
2874         if (pkg == null || pkg.isUnnamed()) {
2875             return DocletConstants.DEFAULT_PACKAGE_NAME;
2876         }
2877         return pkg.getQualifiedName().toString();
2878     }
2879 
2880     /**
2881      * Get the module name for a given module element. An unnamed module is returned as &amp;lt;Unnamed&amp;gt;
2882      *
2883      * @param mdle a ModuleElement
2884      * @return
2885      */
2886     public String getModuleName(ModuleElement mdle) {
2887         if (mdle == null || mdle.isUnnamed()) {
2888             return DocletConstants.DEFAULT_ELEMENT_NAME;
2889         }
2890         return mdle.getQualifiedName().toString();
2891     }
2892 
2893     public boolean isAttribute(DocTree doctree) {
2894         return isKind(doctree, ATTRIBUTE);
2895     }
2896 
2897     public boolean isAuthor(DocTree doctree) {
2898         return isKind(doctree, AUTHOR);
2899     }
2900 
2901     public boolean isComment(DocTree doctree) {
2902         return isKind(doctree, COMMENT);
2903     }
2904 
2905     public boolean isDeprecated(DocTree doctree) {
2906         return isKind(doctree, DEPRECATED);
2907     }
2908 
2909     public boolean isDocComment(DocTree doctree) {
2910         return isKind(doctree, DOC_COMMENT);
2911     }
2912 
2913     public boolean isDocRoot(DocTree doctree) {
2914         return isKind(doctree, DOC_ROOT);
2915     }
2916 
2917     public boolean isEndElement(DocTree doctree) {
2918         return isKind(doctree, END_ELEMENT);
2919     }
2920 
2921     public boolean isEntity(DocTree doctree) {
2922         return isKind(doctree, ENTITY);
2923     }
2924 
2925     public boolean isErroneous(DocTree doctree) {
2926         return isKind(doctree, ERRONEOUS);
2927     }
2928 
2929     public boolean isException(DocTree doctree) {
2930         return isKind(doctree, EXCEPTION);
2931     }
2932 
2933     public boolean isIdentifier(DocTree doctree) {
2934         return isKind(doctree, IDENTIFIER);
2935     }
2936 
2937     public boolean isInheritDoc(DocTree doctree) {
2938         return isKind(doctree, INHERIT_DOC);
2939     }
2940 
2941     public boolean isLink(DocTree doctree) {
2942         return isKind(doctree, LINK);
2943     }
2944 
2945     public boolean isLinkPlain(DocTree doctree) {
2946         return isKind(doctree, LINK_PLAIN);
2947     }
2948 
2949     public boolean isLiteral(DocTree doctree) {
2950         return isKind(doctree, LITERAL);
2951     }
2952 
2953     public boolean isOther(DocTree doctree) {
2954         return doctree.getKind() == DocTree.Kind.OTHER;
2955     }
2956 
2957     public boolean isParam(DocTree doctree) {
2958         return isKind(doctree, PARAM);
2959     }
2960 
2961     public boolean isReference(DocTree doctree) {
2962         return isKind(doctree, REFERENCE);
2963     }
2964 
2965     public boolean isReturn(DocTree doctree) {
2966         return isKind(doctree, RETURN);
2967     }
2968 
2969     public boolean isSee(DocTree doctree) {
2970         return isKind(doctree, SEE);
2971     }
2972 
2973     public boolean isSerial(DocTree doctree) {
2974         return isKind(doctree, SERIAL);
2975     }
2976 
2977     public boolean isSerialData(DocTree doctree) {
2978         return isKind(doctree, SERIAL_DATA);
2979     }
2980 
2981     public boolean isSerialField(DocTree doctree) {
2982         return isKind(doctree, SERIAL_FIELD);
2983     }
2984 
2985     public boolean isSince(DocTree doctree) {
2986         return isKind(doctree, SINCE);
2987     }
2988 
2989     public boolean isStartElement(DocTree doctree) {
2990         return isKind(doctree, START_ELEMENT);
2991     }
2992 
2993     public boolean isText(DocTree doctree) {
2994         return isKind(doctree, TEXT);
2995     }
2996 
2997     public boolean isThrows(DocTree doctree) {
2998         return isKind(doctree, THROWS);
2999     }
3000 
3001     public boolean isUnknownBlockTag(DocTree doctree) {
3002         return isKind(doctree, UNKNOWN_BLOCK_TAG);
3003     }
3004 
3005     public boolean isUnknownInlineTag(DocTree doctree) {
3006         return isKind(doctree, UNKNOWN_INLINE_TAG);
3007     }
3008 
3009     public boolean isValue(DocTree doctree) {
3010         return isKind(doctree, VALUE);
3011     }
3012 
3013     public boolean isVersion(DocTree doctree) {
3014         return isKind(doctree, VERSION);
3015     }
3016 
3017     private boolean isKind(DocTree doctree, DocTree.Kind match) {
3018         return  doctree.getKind() == match;
3019     }
3020 
3021     private final CommentHelperCache commentHelperCache = new CommentHelperCache(this);
3022 
3023     public CommentHelper getCommentHelper(Element element) {
3024         return commentHelperCache.computeIfAbsent(element);
3025     }
3026 
3027     public void removeCommentHelper(Element element) {
3028         commentHelperCache.remove(element);
3029     }
3030 
3031     public List&lt;? extends DocTree&gt; getBlockTags(Element element) {
3032         DocCommentTree dcTree = getDocCommentTree(element);
3033         return dcTree == null ? Collections.emptyList() : dcTree.getBlockTags();
3034     }
3035 
3036     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Predicate&lt;DocTree&gt; filter) {
3037         return getBlockTags(element).stream()
3038                 .filter(t -&gt; t.getKind() != ERRONEOUS)
3039                 .filter(filter)
3040                 .collect(Collectors.toList());
3041     }
3042 
3043     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind) {
3044         return getBlockTags(element, t -&gt; t.getKind() == kind);
3045     }
3046 
3047     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind, DocTree.Kind altKind) {
3048         return getBlockTags(element, t -&gt; t.getKind() == kind || t.getKind() == altKind);
3049     }
3050 
3051     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Taglet taglet) {
3052         return getBlockTags(element, t -&gt; {
3053             if (taglet instanceof BaseTaglet) {
3054                 return ((BaseTaglet) taglet).accepts(t);
3055             } else if (t instanceof UnknownBlockTagTree) {
3056                 return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());
3057             } else {
3058                 return false;
3059             }
3060         });
3061     }
3062 
3063     public boolean hasBlockTag(Element element, DocTree.Kind kind) {
3064         return hasBlockTag(element, kind, null);
3065     }
3066 
3067     public boolean hasBlockTag(Element element, DocTree.Kind kind, final String tagName) {
3068         CommentHelper ch = getCommentHelper(element);
3069         String tname = tagName != null &amp;&amp; tagName.startsWith(&quot;@&quot;)
3070                 ? tagName.substring(1)
3071                 : tagName;
3072         for (DocTree dt : getBlockTags(element, kind)) {
3073             if (dt.getKind() == kind) {
3074                 if (tname == null || ch.getTagName(dt).equals(tname)) {
3075                     return true;
3076                 }
3077             }
3078         }
3079         return false;
3080     }
3081 
3082     /**
3083      * Gets a TreePath for an Element. Note this method is called very
3084      * frequently, care must be taken to ensure this method is lithe
3085      * and efficient.
3086      * @param e an Element
3087      * @return TreePath
3088      */
3089     public TreePath getTreePath(Element e) {
3090         DocCommentDuo duo = dcTreeCache.get(e);
3091         if (duo != null &amp;&amp; duo.treePath != null) {
3092             return duo.treePath;
3093         }
3094         duo = configuration.cmtUtils.getSyntheticCommentDuo(e);
3095         if (duo != null &amp;&amp; duo.treePath != null) {
3096             return duo.treePath;
3097         }
3098         Map&lt;Element, TreePath&gt; elementToTreePath = configuration.workArounds.getElementToTreePath();
3099         TreePath path = elementToTreePath.get(e);
3100         if (path != null || elementToTreePath.containsKey(e)) {
3101             // expedite the path and one that is a null
3102             return path;
3103         }
3104         return elementToTreePath.computeIfAbsent(e, docTrees::getPath);
3105     }
3106 
3107     private final Map&lt;Element, DocCommentDuo&gt; dcTreeCache = new LinkedHashMap&lt;&gt;();
3108 
3109     /**
3110      * Retrieves the doc comments for a given element.
3111      * @param element
3112      * @return DocCommentTree for the Element
3113      */
3114     public DocCommentTree getDocCommentTree0(Element element) {
3115 
3116         DocCommentDuo duo = null;
3117 
3118         ElementKind kind = element.getKind();
3119         if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
3120             duo = dcTreeCache.get(element); // local cache
3121             if (duo == null &amp;&amp; kind == ElementKind.PACKAGE) {
3122                 // package-info.java
3123                 duo = getDocCommentTuple(element);
3124             }
3125             if (duo == null) {
3126                 // package.html or overview.html
3127                 duo = configuration.cmtUtils.getHtmlCommentDuo(element); // html source
3128             }
3129         } else {
3130             duo = configuration.cmtUtils.getSyntheticCommentDuo(element);
3131             if (duo == null) {
3132                 duo = dcTreeCache.get(element); // local cache
3133             }
3134             if (duo == null) {
3135                 duo = getDocCommentTuple(element); // get the real mccoy
3136             }
3137         }
3138 
3139         DocCommentTree docCommentTree = isValidDuo(duo) ? duo.dcTree : null;
3140         TreePath path = isValidDuo(duo) ? duo.treePath : null;
3141         if (!dcTreeCache.containsKey(element)) {
3142             if (docCommentTree != null &amp;&amp; path != null) {
3143                 if (!configuration.isAllowScriptInComments()) {
3144                     try {
3145                         javaScriptScanner.scan(docCommentTree, path, p -&gt; {
3146                             throw new JavaScriptScanner.Fault();
3147                         });
3148                     } catch (JavaScriptScanner.Fault jsf) {
3149                         String text = resources.getText(&quot;doclet.JavaScript_in_comment&quot;);
3150                         throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3151                     }
3152                 }
3153                 configuration.workArounds.runDocLint(path);
3154             }
3155             dcTreeCache.put(element, duo);
3156         }
3157         return docCommentTree;
3158     }
3159 
3160     private DocCommentDuo getDocCommentTuple(Element element) {
3161         // prevent nasty things downstream with overview element
3162         if (element.getKind() != ElementKind.OTHER) {
3163             TreePath path = getTreePath(element);
3164             if (path != null) {
3165                 DocCommentTree docCommentTree = docTrees.getDocCommentTree(path);
3166                 return new DocCommentDuo(path, docCommentTree);
3167             }
3168         }
3169         return null;
3170     }
3171 
3172     public void checkJavaScriptInOption(String name, String value) {
3173         if (!configuration.isAllowScriptInComments()) {
3174             DocCommentTree dct = configuration.cmtUtils.parse(
3175                     URI.create(&quot;option://&quot; + name.replace(&quot;-&quot;, &quot;&quot;)), &quot;&lt;body&gt;&quot; + value + &quot;&lt;/body&gt;&quot;);
3176 
3177             if (dct == null)
3178                 return;
3179 
3180             try {
3181                 javaScriptScanner.scan(dct, null, p -&gt; {
3182                     throw new JavaScriptScanner.Fault();
3183                 });
3184             } catch (JavaScriptScanner.Fault jsf) {
3185                 String text = resources.getText(&quot;doclet.JavaScript_in_option&quot;, name);
3186                 throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3187             }
3188         }
3189     }
3190 
3191     boolean isValidDuo(DocCommentDuo duo) {
3192         return duo != null &amp;&amp; duo.dcTree != null;
3193     }
3194 
3195     public DocCommentTree getDocCommentTree(Element element) {
3196         CommentHelper ch = commentHelperCache.get(element);
3197         if (ch != null) {
3198             return ch.dcTree;
3199         }
3200         DocCommentTree dcTree = getDocCommentTree0(element);
3201         if (dcTree != null) {
3202             commentHelperCache.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));
3203         }
3204         return dcTree;
3205     }
3206 
3207     public List&lt;? extends DocTree&gt; getPreamble(Element element) {
3208         DocCommentTree docCommentTree = getDocCommentTree(element);
3209         return docCommentTree == null
3210                 ? Collections.emptyList()
3211                 : docCommentTree.getPreamble();
3212     }
3213 
3214     public List&lt;? extends DocTree&gt; getFullBody(Element element) {
3215         DocCommentTree docCommentTree = getDocCommentTree(element);
3216             return (docCommentTree == null)
3217                     ? Collections.emptyList()
3218                     : docCommentTree.getFullBody();
3219     }
3220 
3221     public List&lt;? extends DocTree&gt; getBody(Element element) {
3222         DocCommentTree docCommentTree = getDocCommentTree(element);
3223         return (docCommentTree == null)
3224                 ? Collections.emptyList()
3225                 : docCommentTree.getFullBody();
3226     }
3227 
3228     public List&lt;? extends DocTree&gt; getDeprecatedTrees(Element element) {
3229         return getBlockTags(element, DEPRECATED);
3230     }
3231 
3232     public List&lt;? extends DocTree&gt; getProvidesTrees(Element element) {
3233         return getBlockTags(element, PROVIDES);
3234     }
3235 
3236     public List&lt;? extends DocTree&gt; getSeeTrees(Element element) {
3237         return getBlockTags(element, SEE);
3238     }
3239 
3240     public List&lt;? extends DocTree&gt; getSerialTrees(Element element) {
3241         return getBlockTags(element, SERIAL);
3242     }
3243 
3244     public List&lt;? extends DocTree&gt; getSerialFieldTrees(VariableElement field) {
3245         return getBlockTags(field, DocTree.Kind.SERIAL_FIELD);
3246     }
3247 
3248     public List&lt;? extends DocTree&gt; getThrowsTrees(Element element) {
3249         return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
3250     }
3251 
3252     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {
3253         return getParamTrees(element, true);
3254     }
3255 
3256     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {
3257         return getParamTrees(element, false);
3258     }
3259 
3260     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {
3261         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();
3262         for (DocTree dt : getBlockTags(element, PARAM)) {
3263             ParamTree pt = (ParamTree) dt;
3264             if (pt.isTypeParameter() == isTypeParameters) {
3265                 out.add(pt);
3266             }
3267         }
3268         return out;
3269     }
3270 
3271     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
<a name="15" id="anc15"></a><span class="line-modified">3272         return new ArrayList&lt;&gt;(getBlockTags(element, RETURN));</span>




3273     }
3274 
3275     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
3276         return getBlockTags(element, USES);
3277     }
3278 
3279     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
3280         DocCommentTree dcTree = getDocCommentTree(element);
3281         if (dcTree == null) {
3282             return Collections.emptyList();
3283         }
<a name="16" id="anc16"></a><span class="line-modified">3284         return new ArrayList&lt;&gt;(dcTree.getFirstSentence());</span>




3285     }
3286 
3287     public ModuleElement containingModule(Element e) {
3288         return elementUtils.getModuleOf(e);
3289     }
3290 
3291     public PackageElement containingPackage(Element e) {
3292         return elementUtils.getPackageOf(e);
3293     }
3294 
3295     public TypeElement getTopMostContainingTypeElement(Element e) {
3296         if (isPackage(e)) {
3297             return null;
3298         }
3299         TypeElement outer = getEnclosingTypeElement(e);
3300         if (outer == null)
3301             return (TypeElement)e;
3302         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
3303             outer = getEnclosingTypeElement(outer);
3304         }
3305         return outer;
3306     }
3307 
3308     /**
3309      * A memory-sensitive cache for {@link CommentHelper} objects,
3310      * which are expensive to compute.
3311      */
3312     private static class CommentHelperCache {
3313 
3314         private final Map&lt;Element, SoftReference&lt;CommentHelper&gt;&gt; map;
3315         private final Utils utils;
3316 
3317         public CommentHelperCache(Utils utils) {
3318             map = new HashMap&lt;&gt;();
3319             this.utils = utils;
3320         }
3321 
3322         public CommentHelper remove(Element key) {
3323             SoftReference&lt;CommentHelper&gt; value = map.remove(key);
3324             return value == null ? null : value.get();
3325         }
3326 
3327         public CommentHelper put(Element key, CommentHelper value) {
3328             SoftReference&lt;CommentHelper&gt; prev = map.put(key, new SoftReference&lt;&gt;(value));
3329             return prev == null ? null : prev.get();
3330         }
3331 
3332         public CommentHelper get(Object key) {
3333             SoftReference&lt;CommentHelper&gt; value = map.get(key);
3334             return value == null ? null : value.get();
3335         }
3336 
3337         public CommentHelper computeIfAbsent(Element key) {
3338             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);
3339             if (refValue != null) {
3340                 CommentHelper value = refValue.get();
3341                 if (value != null) {
3342                     return value;
3343                 }
3344             }
3345             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
3346                     utils.getDocCommentTree(key));
3347             map.put(key, new SoftReference&lt;&gt;(newValue));
3348             return newValue;
3349         }
3350     }
3351 
3352     /**
<a name="17" id="anc17"></a><span class="line-modified">3353      * A container holding a pair of values (tuple).</span>
<span class="line-modified">3354      *</span>
<span class="line-modified">3355      * @param &lt;K&gt; the type of the first value</span>
<span class="line-added">3356      * @param &lt;L&gt; the type of the second value</span>
3357      */
3358     public static class Pair&lt;K, L&gt; {
3359         public final K first;
3360         public final L second;
3361 
3362         public Pair(K first, L second) {
3363             this.first = first;
3364             this.second = second;
3365         }
3366 
3367         @Override
3368         public String toString() {
<a name="18" id="anc18"></a><span class="line-modified">3369             return first + &quot;:&quot; + second;</span>


3370         }
3371     }
3372 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
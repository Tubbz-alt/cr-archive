<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.taglets;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.PrintStream;
 31 import java.util.ArrayList;
 32 import java.util.Collections;
 33 import java.util.EnumMap;
 34 import java.util.EnumSet;
 35 import java.util.HashSet;
 36 import java.util.Iterator;
 37 import java.util.LinkedHashMap;
 38 import java.util.LinkedHashSet;
 39 import java.util.List;
 40 import java.util.Map;
 41 import java.util.ServiceLoader;
 42 import java.util.Set;
 43 import java.util.TreeSet;
 44 
 45 import javax.lang.model.element.Element;
 46 import javax.lang.model.element.ExecutableElement;
 47 import javax.lang.model.element.ModuleElement;
 48 import javax.lang.model.element.PackageElement;
 49 import javax.lang.model.element.TypeElement;
 50 import javax.lang.model.element.VariableElement;
 51 import javax.lang.model.util.SimpleElementVisitor14;
 52 import javax.tools.JavaFileManager;
 53 import javax.tools.StandardJavaFileManager;
 54 
 55 import com.sun.source.doctree.DocTree;
 56 
 57 import jdk.javadoc.doclet.Doclet;
 58 import jdk.javadoc.doclet.DocletEnvironment;
 59 import jdk.javadoc.doclet.Taglet.Location;
 60 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 61 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 62 import jdk.javadoc.internal.doclets.toolkit.DocletElement;
 63 import jdk.javadoc.internal.doclets.toolkit.Messages;
 64 import jdk.javadoc.internal.doclets.toolkit.Resources;
 65 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 66 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 67 
 68 import static com.sun.source.doctree.DocTree.Kind.AUTHOR;
 69 import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;
 70 import static com.sun.source.doctree.DocTree.Kind.HIDDEN;
 71 import static com.sun.source.doctree.DocTree.Kind.LINK;
 72 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;
 73 import static com.sun.source.doctree.DocTree.Kind.PROVIDES;
 74 import static com.sun.source.doctree.DocTree.Kind.SEE;
 75 import static com.sun.source.doctree.DocTree.Kind.SERIAL;
 76 import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;
 77 import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;
 78 import static com.sun.source.doctree.DocTree.Kind.SINCE;
 79 import static com.sun.source.doctree.DocTree.Kind.THROWS;
 80 import static com.sun.source.doctree.DocTree.Kind.USES;
 81 import static com.sun.source.doctree.DocTree.Kind.VERSION;
 82 import static javax.tools.DocumentationTool.Location.TAGLET_PATH;
 83 
 84 /**
 85  * Manages the {@code Taglet}s used by doclets.
 86  *
 87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 88  *  If you write code that depends on this, you do so at your own risk.
 89  *  This code and its internal interfaces are subject to change or
 90  *  deletion without notice.&lt;/b&gt;
 91  */
 92 
 93 public class TagletManager {
 94 
 95     /**
 96      * The default separator for the simple tag option.
 97      */
 98     public static final char SIMPLE_TAGLET_OPT_SEPARATOR = &#39;:&#39;;
 99 
100     /**
101      * The map of all taglets.
102      */
103     private final LinkedHashMap&lt;String,Taglet&gt; allTaglets;
104 
105     /**
106      * Block (non-inline) taglets, grouped by Location
107      */
108     private Map&lt;Location, List&lt;Taglet&gt;&gt; blockTagletsByLocation;
109 
110     /**
111      * The taglets that can appear inline in descriptive text.
112      */
113     private List&lt;Taglet&gt; inlineTags;
114 
115     /**
116      * The taglets that can appear in the serialized form.
117      */
118     private List&lt;Taglet&gt; serializedFormTags;
119 
120     private final DocletEnvironment docEnv;
121     private final Doclet doclet;
122 
123     private final Utils utils;
124     private final Messages messages;
125     private final Resources resources;
126 
127     /**
128      * Keep track of standard tags.
129      */
130     private final Set&lt;String&gt; standardTags;
131 
132     /**
133      * Keep track of standard tags in lowercase to compare for better
134      * error messages when a tag like @docRoot is mistakenly spelled
135      * lowercase @docroot.
136      */
137     private final Set&lt;String&gt; standardTagsLowercase;
138 
139     /**
140      * Keep track of overridden standard tags.
141      */
142     private final Set&lt;String&gt; overriddenStandardTags;
143 
144     /**
145      * Keep track of the tags that may conflict
146      * with standard tags in the future (any custom tag without
147      * a period in its name).
148      */
149     private final Set&lt;String&gt; potentiallyConflictingTags;
150 
151     /**
152      * The set of unseen custom tags.
153      */
154     private final Set&lt;String&gt; unseenCustomTags;
155 
156     /**
157      * True if we do not want to use @since tags.
158      */
159     private final boolean nosince;
160 
161     /**
162      * True if we want to use @version tags.
163      */
164     private final boolean showversion;
165 
166     /**
167      * True if we want to use @author tags.
168      */
169     private final boolean showauthor;
170 
171     /**
172      * True if we want to use JavaFX-related tags (@defaultValue, @treatAsPrivate).
173      */
174     private final boolean javafx;
175 
176     /**
177      * Show the taglets table when it has been initialized.
178      */
179     private final boolean showTaglets;
180 
181     private final String tagletPath;
182 
183     /**
184      * Construct a new {@code TagletManager}.
185      * @param configuration the configuration for this taglet manager
186      */
187     public TagletManager(BaseConfiguration configuration) {
188         overriddenStandardTags = new HashSet&lt;&gt;();
189         potentiallyConflictingTags = new HashSet&lt;&gt;();
190         standardTags = new HashSet&lt;&gt;();
191         standardTagsLowercase = new HashSet&lt;&gt;();
192         unseenCustomTags = new HashSet&lt;&gt;();
193         allTaglets = new LinkedHashMap&lt;&gt;();
194         BaseOptions options = configuration.getOptions();
195         this.nosince = options.noSince();
196         this.showversion = options.showVersion();
197         this.showauthor = options.showAuthor();
198         this.javafx = options.javafx();
199         this.docEnv = configuration.docEnv;
200         this.doclet = configuration.doclet;
201         this.messages = configuration.getMessages();
202         this.resources = configuration.getDocResources();
203         this.showTaglets = options.showTaglets();
204         this.utils = configuration.utils;
205         this.tagletPath = options.tagletPath();
206         initStandardTaglets();
207     }
208 
209     /**
210      * Add a new {@code Taglet}.  This is used to add a Taglet from within
211      * a Doclet.  No message is printed to indicate that the Taglet is properly
212      * registered because these Taglets are typically added for every execution of the
213      * Doclet.  We don&#39;t want to see this type of error message every time.
214      * @param customTag the new {@code Taglet} to add.
215      */
216     public void addCustomTag(Taglet customTag) {
217         if (customTag != null) {
218             String name = customTag.getName();
219             allTaglets.remove(name);
220             allTaglets.put(name, customTag);
221             checkTagName(name);
222         }
223     }
224 
225     public Set&lt;String&gt; getAllTagletNames() {
226         return allTaglets.keySet();
227     }
228 
229     /**
230      * Initializes the location TAGLET_PATH which is used to locate the custom taglets.
231      * @param fileManager the file manager to load classes and resources.
232      * @throws IOException if an error occurs while setting the location.
233      */
234     public void initTagletPath(JavaFileManager fileManager) throws IOException {
235         if (fileManager instanceof StandardJavaFileManager) {
236             StandardJavaFileManager sfm = (StandardJavaFileManager)fileManager;
237             if (tagletPath != null) {
238                 List&lt;File&gt; paths = new ArrayList&lt;&gt;();
239                 for (String pathname : tagletPath.split(File.pathSeparator)) {
240                     paths.add(new File(pathname));
241                 }
242                 sfm.setLocation(TAGLET_PATH, paths);
243             } else if (!sfm.hasLocation(TAGLET_PATH)) {
244                 sfm.setLocation(TAGLET_PATH, Collections.emptyList());
245             }
246         } else if (tagletPath != null) {
247             messages.error(&quot;doclet.not_standard_file_manager&quot;);
248         }
249     }
250 
251     /**
252      * Adds a new {@code Taglet}.  Print a message to indicate whether or not
253      * the Taglet was registered properly.
254      * @param classname  the name of the class representing the custom tag.
255      * @param fileManager the file manager to load classes and resources.
256      */
257     public void addCustomTag(String classname, JavaFileManager fileManager) {
258         try {
259             ClassLoader tagClassLoader;
260             tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);
261             Class&lt;? extends jdk.javadoc.doclet.Taglet&gt; customTagClass =
262                     tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);
263             jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();
264             registerTaglet(instance);
265         } catch (ReflectiveOperationException exc) {
266             messages.error(&quot;doclet.Error_taglet_not_registered&quot;, exc.getClass().getName(),
267                     classname);
268         }
269     }
270 
271     /**
272      * Loads taglets from a taglet path using service loader.
273      * @param fileManager the file manager to load the taglets.
274      * @throws IOException if an error occurs while getting the service loader.
275      */
276     public void loadTaglets(JavaFileManager fileManager) throws IOException {
277         Iterable&lt;? extends File&gt; location = ((StandardJavaFileManager)fileManager).getLocation(TAGLET_PATH);
278         if (location != null &amp;&amp; location.iterator().hasNext()) {
279             ServiceLoader&lt;jdk.javadoc.doclet.Taglet&gt; serviceLoader =
280                     fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);
281             Iterator&lt;jdk.javadoc.doclet.Taglet&gt; iterator = serviceLoader.iterator();
282             while (iterator.hasNext()) {
283                 jdk.javadoc.doclet.Taglet taglet = iterator.next();
284                 registerTaglet(taglet);
285             }
286         }
287     }
288 
289     /**
290      * Registers the {@code Taglet}. Prints a message if a {@code Taglet} got registered properly.
291      * @param instance the {@code Taglet} instance.
292      */
293     private void registerTaglet(jdk.javadoc.doclet.Taglet instance) {
294         instance.init(docEnv, doclet);
295         Taglet newLegacy = new UserTaglet(instance);
296         allTaglets.put(newLegacy.getName(), newLegacy);
297         messages.notice(&quot;doclet.Notice_taglet_registered&quot;, instance.getClass().getName());
298     }
299 
300     /**
301      * Add a new {@code SimpleTaglet}.  If this tag already exists
302      * and the header passed as an argument is null, move tag to the back of the
303      * list. If this tag already exists and the header passed as an argument is
304      * not null, overwrite previous tag with new one.  Otherwise, add new
305      * SimpleTaglet to list.
306      * @param tagName the name of this tag
307      * @param header the header to output.
308      * @param locations the possible locations that this tag
309      * can appear in.
310      */
311     public void addNewSimpleCustomTag(String tagName, String header, String locations) {
312         if (tagName == null || locations == null) {
313             return;
314         }
315         Taglet tag = allTaglets.get(tagName);
316         if (tag == null || header != null) {
317             allTaglets.remove(tagName);
318             allTaglets.put(tagName, new SimpleTaglet(tagName, header, locations));
319             if (Utils.toLowerCase(locations).indexOf(&#39;x&#39;) == -1) {
320                 checkTagName(tagName);
321             }
322         } else {
323             //Move to back
324             allTaglets.remove(tagName);
325             allTaglets.put(tagName, tag);
326         }
327     }
328 
329     /**
330      * Given a tag name, add it to the set of tags it belongs to.
331      */
332     private void checkTagName(String name) {
333         if (standardTags.contains(name)) {
334             overriddenStandardTags.add(name);
335         } else {
336             if (name.indexOf(&#39;.&#39;) == -1) {
337                 potentiallyConflictingTags.add(name);
338             }
339             unseenCustomTags.add(name);
340         }
341     }
342 
343     /**
344      * Given a name of a seen custom tag, remove it from the set of unseen
345      * custom tags.
346      * @param name the name of the seen custom tag.
347      */
348     void seenCustomTag(String name) {
349         unseenCustomTags.remove(name);
350     }
351 
352     /**
353      * Given a series of {@code DocTree}s, check for spelling mistakes.
354      * @param element the tags holder
355      * @param trees the trees containing the comments
356      * @param inlineTrees true if the trees are inline and false otherwise.
357      */
358     @SuppressWarnings(&quot;preview&quot;)
359     public void checkTags(Element element, Iterable&lt;? extends DocTree&gt; trees, boolean inlineTrees) {
360         if (trees == null) {
361             return;
362         }
363         CommentHelper ch = utils.getCommentHelper(element);
364         for (DocTree tag : trees) {
365             String name = tag.getKind().tagName;
366             if (name == null) {
367                 continue;
368             }
369             if (name.length() &gt; 0 &amp;&amp; name.charAt(0) == &#39;@&#39;) {
370                 name = name.substring(1, name.length());
371             }
372             if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {
373                 if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {
374                     messages.warning(ch.getDocTreePath(tag), &quot;doclet.UnknownTagLowercase&quot;, ch.getTagName(tag));
375                     continue;
376                 } else {
377                     messages.warning(ch.getDocTreePath(tag), &quot;doclet.UnknownTag&quot;, ch.getTagName(tag));
378                     continue;
379                 }
380             }
381             final Taglet taglet = allTaglets.get(name);
382             // Check and verify tag usage
383             if (taglet != null) {
384                 if (inlineTrees &amp;&amp; !taglet.isInlineTag()) {
385                     printTagMisuseWarn(ch, taglet, tag, &quot;inline&quot;);
386                 }
387                 // nothing more to do
388                 if (element == null) {
389                     return;
390                 }
391 
392                 if (!inlineTrees) {
393                     new SimpleElementVisitor14&lt;Void, Void&gt;() {
394                         @Override
395                         public Void visitModule(ModuleElement e, Void p) {
396                             if (!taglet.inModule()) {
397                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;module&quot;);
398                             }
399                             return null;
400                         }
401 
402                         @Override
403                         public Void visitPackage(PackageElement e, Void p) {
404                             if (!taglet.inPackage()) {
405                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;package&quot;);
406                             }
407                             return null;
408                         }
409 
410                         @Override
411                         public Void visitType(TypeElement e, Void p) {
412                             if (!taglet.inType()) {
413                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;class&quot;);
414                             }
415                             return null;
416                         }
417 
418                         @Override
419                         public Void visitExecutable(ExecutableElement e, Void p) {
420                             if (utils.isConstructor(e) &amp;&amp; !taglet.inConstructor()) {
421                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;constructor&quot;);
422                             } else if (!taglet.inMethod()) {
423                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;method&quot;);
424                             }
425                             return null;
426                         }
427 
428                         @Override
429                         public Void visitVariable(VariableElement e, Void p) {
430                             if (utils.isField(e) &amp;&amp; !taglet.inField()) {
431                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;field&quot;);
432                             }
433                             return null;
434                         }
435 
436                         @Override
437                         public Void visitUnknown(Element e, Void p) {
438                             if (utils.isOverviewElement(e) &amp;&amp; !taglet.inOverview()) {
439                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;overview&quot;);
440                             }
441                             return null;
442                         }
443 
444                         @Override
445                         protected Void defaultAction(Element e, Void p) {
446                             return null;
447                         }
448                     }.visit(element);
449                 }
450             }
451         }
452     }
453 
454     /**
455      * Given the taglet, the tag and the type of documentation that the tag
456      * was found in, print a tag misuse warning.
457      * @param taglet the taglet representing the misused tag.
458      * @param tag the misused tag.
459      * @param holderType the type of documentation that the misused tag was found in.
460      */
461     private void printTagMisuseWarn(CommentHelper ch, Taglet taglet, DocTree tag, String holderType) {
462         Set&lt;String&gt; locationsSet = new LinkedHashSet&lt;&gt;();
463         // The following names should be localized
464         if (taglet.inOverview()) {
465             locationsSet.add(&quot;overview&quot;);
466         }
467         if (taglet.inModule()) {
468             locationsSet.add(&quot;module&quot;);
469         }
470         if (taglet.inPackage()) {
471             locationsSet.add(&quot;package&quot;);
472         }
473         if (taglet.inType()) {
474             locationsSet.add(&quot;class/interface&quot;);
475         }
476         if (taglet.inConstructor())  {
477             locationsSet.add(&quot;constructor&quot;);
478         }
479         if (taglet.inField()) {
480             locationsSet.add(&quot;field&quot;);
481         }
482         if (taglet.inMethod()) {
483             locationsSet.add(&quot;method&quot;);
484         }
485         if (taglet.isInlineTag()) {
486             locationsSet.add(&quot;inline text&quot;);
487         }
488         if (locationsSet.isEmpty()) {
489             //This known tag is excluded.
490             return;
491         }
492         StringBuilder combined_locations = new StringBuilder();
493         for (String location: locationsSet) {
494             if (combined_locations.length() &gt; 0) {
495                 combined_locations.append(&quot;, &quot;);
496             }
497             combined_locations.append(location);
498         }
499         messages.warning(ch.getDocTreePath(tag), &quot;doclet.tag_misuse&quot;,
500             &quot;@&quot; + taglet.getName(), holderType, combined_locations.toString());
501     }
502 
503     /**
504      * Returns the taglets that can appear inline, in descriptive text.
505      * @return the taglets that can appear inline
506      */
507     List&lt;Taglet&gt; getInlineTaglets() {
508         if (inlineTags == null) {
509             initBlockTaglets();
510         }
511         return inlineTags;
512     }
513 
514     /**
515      * Returns the taglets that can appear in the serialized form.
516      * @return the taglet that can appear in the serialized form
517      */
518     public List&lt;Taglet&gt; getSerializedFormTaglets() {
519         if (serializedFormTags == null) {
520             initBlockTaglets();
521         }
522         return serializedFormTags;
523     }
524 
525     /**
526      * Returns the custom tags for a given element.
527      *
528      * @param e the element to get custom tags for
529      * @return the array of {@code Taglet}s that can
530      * appear in the given element.
531      */
532     @SuppressWarnings(&quot;fallthrough&quot;)
533     public List&lt;Taglet&gt; getBlockTaglets(Element e) {
534         if (blockTagletsByLocation == null) {
535             initBlockTaglets();
536         }
537 
538         switch (e.getKind()) {
539             case CONSTRUCTOR:
540                 return blockTagletsByLocation.get(Location.CONSTRUCTOR);
541             case METHOD:
542                 return blockTagletsByLocation.get(Location.METHOD);
543             case ENUM_CONSTANT:
544             case FIELD:
545                 return blockTagletsByLocation.get(Location.FIELD);
546             case ANNOTATION_TYPE:
547             case INTERFACE:
548             case CLASS:
549             case ENUM:
550             case RECORD:
551                 return blockTagletsByLocation.get(Location.TYPE);
552             case MODULE:
553                 return blockTagletsByLocation.get(Location.MODULE);
554             case PACKAGE:
555                 return blockTagletsByLocation.get(Location.PACKAGE);
556             case OTHER:
557                 if (e instanceof DocletElement) {
558                     DocletElement de = (DocletElement)e;
559                     switch (de.getSubKind()) {
560                         case DOCFILE:
561                             return blockTagletsByLocation.get(Location.PACKAGE);
562                         case OVERVIEW:
563                             return blockTagletsByLocation.get(Location.OVERVIEW);
564                         default:
565                             // fall through
566                     }
567                 }
568                 // fall through
569             default:
570                 throw new AssertionError(&quot;unknown element: &quot; + e + &quot; ,kind: &quot; + e.getKind());
571         }
572     }
573 
574     /**
575      * Initialize the custom tag Lists.
576      */
577     private void initBlockTaglets() {
578 
579         blockTagletsByLocation = new EnumMap&lt;&gt;(Location.class);
580         for (Location site : Location.values()) {
581             blockTagletsByLocation.put(site, new ArrayList&lt;&gt;());
582         }
583 
584         inlineTags = new ArrayList&lt;&gt;();
585 
586         for (Taglet current : allTaglets.values()) {
587             if (current.isInlineTag()) {
588                 inlineTags.add(current);
589             }
590 
591             if (current.isBlockTag()) {
592                 for (Location l : current.getAllowedLocations()) {
593                     blockTagletsByLocation.get(l).add(current);
594                 }
595             }
596         }
597 
598         //Init the serialized form tags
599         serializedFormTags = new ArrayList&lt;&gt;();
600         serializedFormTags.add(allTaglets.get(SERIAL_DATA.tagName));
601         serializedFormTags.add(allTaglets.get(THROWS.tagName));
602         if (!nosince)
603             serializedFormTags.add(allTaglets.get(SINCE.tagName));
604         serializedFormTags.add(allTaglets.get(SEE.tagName));
605 
606         if (showTaglets) {
607             showTaglets(System.out);
608         }
609     }
610 
611     /**
612      * Initialize standard Javadoc tags for ordering purposes.
613      */
614     private void initStandardTaglets() {
615         if (javafx) {
616             initJavaFXTaglets();
617         }
618 
619         addStandardTaglet(new ParamTaglet());
620         addStandardTaglet(new ReturnTaglet());
621         addStandardTaglet(new ThrowsTaglet());
622         addStandardTaglet(
623                 new SimpleTaglet(EXCEPTION, null,
624                     EnumSet.of(Location.METHOD, Location.CONSTRUCTOR)));
625         addStandardTaglet(
626                 new SimpleTaglet(SINCE, resources.getText(&quot;doclet.Since&quot;),
627                     EnumSet.allOf(Location.class), !nosince));
628         addStandardTaglet(
629                 new SimpleTaglet(VERSION, resources.getText(&quot;doclet.Version&quot;),
630                     EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showversion));
631         addStandardTaglet(
632                 new SimpleTaglet(AUTHOR, resources.getText(&quot;doclet.Author&quot;),
633                     EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showauthor));
634         addStandardTaglet(
635                 new SimpleTaglet(SERIAL_DATA, resources.getText(&quot;doclet.SerialData&quot;),
636                     EnumSet.noneOf(Location.class)));
637         addStandardTaglet(
638                 new SimpleTaglet(HIDDEN, null,
639                     EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));
640 
641         // This appears to be a default custom (non-standard) taglet
642         Taglet factoryTaglet = new SimpleTaglet(&quot;factory&quot;, resources.getText(&quot;doclet.Factory&quot;),
643                 EnumSet.of(Location.METHOD));
644         allTaglets.put(factoryTaglet.getName(), factoryTaglet);
645 
646         addStandardTaglet(new SeeTaglet());
647 
648         // Standard inline tags
649         addStandardTaglet(new DocRootTaglet());
650         addStandardTaglet(new InheritDocTaglet());
651         addStandardTaglet(new ValueTaglet());
652         addStandardTaglet(new LiteralTaglet());
653         addStandardTaglet(new CodeTaglet());
654         addStandardTaglet(new IndexTaglet());
655         addStandardTaglet(new SummaryTaglet());
656         addStandardTaglet(new SystemPropertyTaglet());
657 
658         // Keep track of the names of standard tags for error checking purposes.
659         // The following are not handled above.
660         addStandardTaglet(new DeprecatedTaglet());
661         addStandardTaglet(new BaseTaglet(LINK, true, EnumSet.allOf(Location.class)));
662         addStandardTaglet(new BaseTaglet(LINK_PLAIN, true, EnumSet.allOf(Location.class)));
663         addStandardTaglet(new BaseTaglet(USES, false, EnumSet.of(Location.MODULE)));
664         addStandardTaglet(new BaseTaglet(PROVIDES, false, EnumSet.of(Location.MODULE)));
665         addStandardTaglet(
666                 new SimpleTaglet(SERIAL, null,
667                     EnumSet.of(Location.PACKAGE, Location.TYPE, Location.FIELD)));
668         addStandardTaglet(
669                 new SimpleTaglet(SERIAL_FIELD, null, EnumSet.of(Location.FIELD)));
670     }
671 
672     /**
673      * Initialize JavaFX-related tags.
674      */
675     private void initJavaFXTaglets() {
676         addStandardTaglet(new PropertyGetterTaglet());
677         addStandardTaglet(new PropertySetterTaglet());
678         addStandardTaglet(new SimpleTaglet(&quot;propertyDescription&quot;,
679                 resources.getText(&quot;doclet.PropertyDescription&quot;),
680                 EnumSet.of(Location.METHOD, Location.FIELD)));
681         addStandardTaglet(new SimpleTaglet(&quot;defaultValue&quot;, resources.getText(&quot;doclet.DefaultValue&quot;),
682                 EnumSet.of(Location.METHOD, Location.FIELD)));
683         addStandardTaglet(new SimpleTaglet(&quot;treatAsPrivate&quot;, null,
684                 EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));
685     }
686 
687     private void addStandardTaglet(Taglet taglet) {
688         String name = taglet.getName();
689         allTaglets.put(name, taglet);
690         standardTags.add(name);
691         standardTagsLowercase.add(Utils.toLowerCase(name));
692     }
693 
694     public boolean isKnownCustomTag(String tagName) {
695         return allTaglets.containsKey(tagName);
696     }
697 
698     /**
699      * Print a list of {@link Taglet}s that might conflict with
700      * standard tags in the future and a list of standard tags
701      * that have been overridden.
702      */
703     public void printReport() {
704         printReportHelper(&quot;doclet.Notice_taglet_conflict_warn&quot;, potentiallyConflictingTags);
705         printReportHelper(&quot;doclet.Notice_taglet_overridden&quot;, overriddenStandardTags);
706         printReportHelper(&quot;doclet.Notice_taglet_unseen&quot;, unseenCustomTags);
707     }
708 
709     private void printReportHelper(String noticeKey, Set&lt;String&gt; names) {
710         if (names.size() &gt; 0) {
711             StringBuilder result = new StringBuilder();
712             for (String name : names) {
713                 result.append(result.length() == 0 ? &quot; &quot; : &quot;, &quot;);
714                 result.append(&quot;@&quot;).append(name);
715             }
716             messages.notice(noticeKey, result);
717         }
718     }
719 
720     /**
721      * Given the name of a tag, return the corresponding taglet.
722      * Return null if the tag is unknown.
723      *
724      * @param name the name of the taglet to retrieve.
725      * @return return the corresponding taglet. Return null if the tag is
726      *         unknown.
727      */
728     Taglet getTaglet(String name) {
729         if (name.indexOf(&quot;@&quot;) == 0) {
730             return allTaglets.get(name.substring(1));
731         } else {
732             return allTaglets.get(name);
733         }
734 
735     }
736 
737     /*
738      * The output of this method is the basis for a table at the end of the
739      * doc comment specification, so any changes in the output may indicate
740      * a need for a corresponding update to the spec.
741      */
742     private void showTaglets(PrintStream out) {
743         Set&lt;Taglet&gt; taglets = new TreeSet&lt;&gt;((o1, o2) -&gt; o1.getName().compareTo(o2.getName()));
744         taglets.addAll(allTaglets.values());
745 
746         for (Taglet t : taglets) {
747             String name = t.isInlineTag() ? &quot;{@&quot; + t.getName() + &quot;}&quot; : &quot;@&quot; + t.getName();
748             out.println(String.format(&quot;%20s&quot;, name) + &quot;: &quot;
749                     + format(t.isBlockTag(), &quot;block&quot;)+ &quot; &quot;
750                     + format(t.inOverview(), &quot;overview&quot;) + &quot; &quot;
751                     + format(t.inModule(), &quot;module&quot;) + &quot; &quot;
752                     + format(t.inPackage(), &quot;package&quot;) + &quot; &quot;
753                     + format(t.inType(), &quot;type&quot;) + &quot; &quot;
754                     + format(t.inConstructor(),&quot;constructor&quot;) + &quot; &quot;
755                     + format(t.inMethod(), &quot;method&quot;) + &quot; &quot;
756                     + format(t.inField(), &quot;field&quot;) + &quot; &quot;
757                     + format(t.isInlineTag(), &quot;inline&quot;)+ &quot; &quot;
758                     + format((t instanceof SimpleTaglet) &amp;&amp; !((SimpleTaglet)t).enabled, &quot;disabled&quot;));
759         }
760     }
761 
762     private String format(boolean b, String s) {
763         return b ? s : s.replaceAll(&quot;.&quot;, &quot;.&quot;); // replace all with &quot;.&quot;
764     }
765 }
    </pre>
  </body>
</html>
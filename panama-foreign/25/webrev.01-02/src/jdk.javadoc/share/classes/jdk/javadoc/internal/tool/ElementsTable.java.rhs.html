<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/ElementsTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package jdk.javadoc.internal.tool;
  26 
  27 import java.io.IOException;
  28 import java.util.ArrayList;
  29 import java.util.Collection;
  30 import java.util.Collections;
  31 import java.util.EnumMap;
  32 import java.util.EnumSet;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.LinkedHashMap;
  36 import java.util.LinkedHashSet;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.Set;
  40 
  41 import javax.lang.model.element.Element;
  42 import javax.lang.model.element.ElementKind;
  43 import javax.lang.model.element.Modifier;
  44 import javax.lang.model.element.ModuleElement;
  45 import javax.lang.model.element.ModuleElement.ExportsDirective;
  46 import javax.lang.model.element.ModuleElement.RequiresDirective;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.TypeElement;
  49 import javax.lang.model.util.ElementFilter;
  50 import javax.lang.model.util.SimpleElementVisitor14;
  51 import javax.tools.JavaFileManager;
  52 import javax.tools.JavaFileManager.Location;
  53 import javax.tools.JavaFileObject;
  54 import javax.tools.StandardLocation;
  55 
  56 import com.sun.tools.javac.code.Kinds.Kind;
  57 import com.sun.tools.javac.code.Source;
  58 import com.sun.tools.javac.code.Source.Feature;
  59 import com.sun.tools.javac.code.Symbol;
  60 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  61 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  62 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  63 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  64 import com.sun.tools.javac.code.Symtab;
  65 import com.sun.tools.javac.comp.Modules;
  66 import com.sun.tools.javac.main.JavaCompiler;
  67 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
  68 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
  69 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
  70 import com.sun.tools.javac.tree.TreeInfo;
  71 import com.sun.tools.javac.util.Context;
  72 import com.sun.tools.javac.util.ListBuffer;
  73 import com.sun.tools.javac.util.Name;
  74 import com.sun.tools.javac.util.Names;
  75 import jdk.javadoc.doclet.DocletEnvironment;
  76 import jdk.javadoc.doclet.DocletEnvironment.ModuleMode;
  77 
  78 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  79 
  80 import static javax.lang.model.util.Elements.Origin.*;
  81 import static javax.tools.JavaFileObject.Kind.*;
  82 
  83 import static jdk.javadoc.internal.tool.Main.Result.*;
  84 import static jdk.javadoc.internal.tool.JavadocTool.isValidClassName;
  85 
  86 
  87 /**
  88  * This class manages elements specified on the command line, and
  89  * produces &quot;specified&quot; and &quot;included&quot; data sets, needed by the
  90  * doclet environment, as well as querying an elements&#39; visibility
  91  * or inclusion.
  92  *
  93  * A. Initialization phase: the class is initialized with the
  94  *    options table by the caller. Some program elements may not
  95  *    be specified via specific options, such as packages, classes,
  96  *    these are set with the use of setter methods, such setClassArgList
  97  *    and setClassDeclList.
  98  *
  99  * B. Scan and decode phase: this is performed by scanSpecifiedItems,
 100  *    to identify the modules specified on the command line, modules
 101  *    specified with qualified packages and qualified subpackages, the
 102  *    modules so identified are used to initialize the module system.
 103  *
 104  * C. Intermediate phase: before the final analysis can be done,
 105  *    intermediate methods can be used to get specified elements from
 106  *    the initialization phase, typically used to parse sources or packages
 107  *    specified on the command line.
 108  *
 109  * D. Analysis phase: the final analysis is performed to determine
 110  *    the packages that ought to be included, as follows:
 111  *
 112  *    1. computes the specified modules, by considering the option
 113  *       &quot;expand-requires&quot;, this must be done exhaustively, as the package
 114  *       computation phase expects a completed module graph, in order to
 115  *       check the target of a qualified export is in the included set.
 116  *
 117  *    2. computes the packages that must be documented, by considering
 118  *       the option &quot;show-packages&quot;, also if only exported packages are
 119  *       to be considered, then also check for qualified packages, and
 120  *       include only those packages whose target is in the included set.
 121  *
 122  *    3. compute the specified packages, as part of this, first compute
 123  *       the subpackages and exclude any packages, if required.
 124  *
 125  *    4. Finally, compute the types found by previous parsing steps,
 126  *       noting that, all enclosed types (nested types) must also be
 127  *       considered.
 128  *
 129  * E. Finally, this class provides methods to obtain the specified sets,
 130  *    which are frozen and cached in the analysis phase, the included
 131  *    sets, are computed lazily and cached for future use. An element
 132  *    can be checked if it should be documented, in which case, the
 133  *    element is checked against the included set and the result is
 134  *    cached, for performance reasons.
 135  *
 136  * Definitions:
 137  *    Fully included: an element is included and some or parts
 138  *    of it components are included implicitly, subject to a
 139  *    selection criteria of its enclosed children.
 140  *
 141  *    Included: if the item should be documented.
 142  *
 143  * Rules for processing:
 144  *
 145  * 1. A specified element, meaning an element given on the
 146  *    command-line, and exposed via specified elements collections.
 147  * 2. Expand-contents, an internal pseudo term, meaning
 148  *    it is part of the recursive expansion of specified
 149  *    elements, meaning, the modules are expanded first, then
 150  *    the packages contained in the expanded modules, and then
 151  *    the types contained within the packages, to produce the
 152  *    collections returned by the methods
 153  *    getInclude{Module|Package|Type}Elements(), this is a
 154  *    downward expansion.
 155  * 3. An included element, meaning it should be documented, and
 156  *    exposed via isIncluded, this enclosing element (module, package)
 157  *    is recursively included.
 158  */
 159 public class ElementsTable {
 160 
 161     private final ToolEnvironment toolEnv;
 162     private final Symtab syms;
 163     private final Names names;
 164     private final JavaFileManager fm;
 165     private final List&lt;Location&gt; locations;
 166     private final Modules modules;
 167     private final ToolOptions options;
 168     private final Messager messager;
 169     private final JavaCompiler compiler;
 170 
 171     private final Map&lt;String, Entry&gt; entries = new LinkedHashMap&lt;&gt;();
 172 
 173     // specified elements
 174     private Set&lt;ModuleElement&gt; specifiedModuleElements = new LinkedHashSet&lt;&gt;();
 175     private Set&lt;PackageElement&gt; specifiedPackageElements = new LinkedHashSet&lt;&gt;();
<a name="1" id="anc1"></a><span class="line-modified"> 176     private Set&lt;TypeElement&gt; specifiedTypeElements = new LinkedHashSet&lt;&gt;();</span>
 177 
 178     // included elements
 179     private Set&lt;ModuleElement&gt; includedModuleElements = null;
 180     private Set&lt;PackageElement&gt; includedPackageElements = null;
 181     private Set&lt;TypeElement&gt; includedTypeElements = null;
 182 
 183     // cmdline specifiers
 184     private Set&lt;ModulePackage&gt; cmdLinePackages = new LinkedHashSet&lt;&gt;();
 185     private Set&lt;ModulePackage&gt; excludePackages = new LinkedHashSet&lt;&gt;();
 186     private Set&lt;ModulePackage&gt; subPackages = new LinkedHashSet&lt;&gt;();
 187 
 188     private List&lt;JCClassDecl&gt; classDecList = Collections.emptyList();
 189     private List&lt;String&gt; classArgList = Collections.emptyList();
 190     private com.sun.tools.javac.util.List&lt;JCCompilationUnit&gt; classTreeList = null;
 191 
 192     private final Set&lt;JavaFileObject.Kind&gt; sourceKinds = EnumSet.of(JavaFileObject.Kind.SOURCE);
 193 
 194     private final ModifierFilter accessFilter;
 195 
 196     private final AccessKind expandRequires;
 197 
 198     final boolean xclasses;
 199 
 200     /**
 201      * Creates the table to manage included and excluded elements.
 202      *
 203      * @param context the context to locate commonly used objects
 204      * @param options the tool options
 205      */
 206     ElementsTable(Context context, ToolOptions options) {
 207         this.toolEnv = ToolEnvironment.instance(context);
 208         this.syms = Symtab.instance(context);
 209         this.names = Names.instance(context);
 210         this.fm = toolEnv.fileManager;
 211         this.modules = Modules.instance(context);
 212         this.options = options;
 213         this.messager = Messager.instance0(context);
 214         this.compiler = JavaCompiler.instance(context);
 215         Source source = Source.instance(context);
 216 
 217         List&lt;Location&gt; locs = new ArrayList&lt;&gt;();
 218         if (modules.multiModuleMode) {
 219             locs.add(StandardLocation.MODULE_SOURCE_PATH);
 220         } else {
 221             if (toolEnv.fileManager.hasLocation(StandardLocation.SOURCE_PATH))
 222                 locs.add(StandardLocation.SOURCE_PATH);
 223             else
 224                 locs.add(StandardLocation.CLASS_PATH);
 225         }
 226         if (Feature.MODULES.allowedInSource(source) &amp;&amp; toolEnv.fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH))
 227             locs.add(StandardLocation.PATCH_MODULE_PATH);
 228         this.locations = Collections.unmodifiableList(locs);
 229 
 230         getEntry(&quot;&quot;).excluded = false;
 231 
 232         accessFilter = new ModifierFilter(options);
 233         xclasses = options.xclasses();
 234         expandRequires = options.expandRequires();
 235     }
 236 
 237     /**
 238      * Returns the module documentation level mode.
 239      * @return the module documentation level mode
 240      */
 241     public ModuleMode getModuleMode() {
 242         switch(accessFilter.getAccessValue(ElementKind.MODULE)) {
 243             case PACKAGE: case PRIVATE:
 244                 return DocletEnvironment.ModuleMode.ALL;
 245             default:
 246                 return DocletEnvironment.ModuleMode.API;
 247         }
 248     }
 249 
 250     private Set&lt;Element&gt; specifiedElements = null;
 251     /**
 252      * Returns a set of elements specified on the
 253      * command line, including any inner classes.
 254      *
 255      * @return the set of elements specified on the command line
 256      */
 257     public Set&lt;? extends Element&gt; getSpecifiedElements() {
 258         if (specifiedElements == null) {
 259             Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
 260             result.addAll(specifiedModuleElements);
 261             result.addAll(specifiedPackageElements);
 262             result.addAll(specifiedTypeElements);
 263             specifiedElements = Collections.unmodifiableSet(result);
 264         }
 265         return specifiedElements;
 266     }
 267 
 268     private Set&lt;Element&gt; includedElements = null;
 269     /**
 270      * Returns a set of elements included elements. The inclusion is as
 271      * follows:
 272      * A module is fully included,
 273      *   - is specified on the command line --module
 274      *   - is derived from the module graph, that is, by expanding the
 275      *     requires directive, based on --expand-requires
 276      *
 277      * A module is included if an enclosed package or type is
 278      * specified on the command line.
 279      *
 280      * A package is fully included,
 281      *  - is specified on the command line
 282      *  - is derived from expanding -subpackages
 283      *  - can be documented in a fully included module based on --show-packages
 284      *
 285      * A package is included, if an enclosed package or a type is specified on
 286      * the command line.
 287      *
 288      * Included type elements (including those within specified or included packages)
 289      * to be documented.
 290      *
 291      * A type is fully included if
 292      *  - is specified on the command line with -sourcepath
 293      *  - is visible with --show-types filter
 294      * A nested type is fully included if
 295      *  - is visible with --show-types filter
 296      *  - is enclosed in a fully included type
 297      * @return the set of elements specified on the command line
 298      */
 299     public Set&lt;? extends Element&gt; getIncludedElements() {
 300         if (includedElements == null) {
 301             Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
 302             result.addAll(includedModuleElements);
 303             result.addAll(includedPackageElements);
 304             result.addAll(includedTypeElements);
 305             includedElements = Collections.unmodifiableSet(result);
 306         }
 307         return includedElements;
 308     }
 309 
 310     private IncludedVisitor includedVisitor = null;
 311 
 312     /**
 313      * Returns true if the given element is included for consideration.
 314      * This method accumulates elements in the cache as enclosed elements of
 315      * fully included elements are tested.
 316      * A member (constructor, method, field) is included if
 317      *  - it is visible in a fully included type (--show-members)
 318      *
 319      * @param e the element in question
 320      *
 321      * @see #getIncludedElements()
 322      *
 323      * @return true if included
 324      */
 325     public boolean isIncluded(Element e) {
 326         if (e == null) {
 327             return false;
 328         }
 329         if (includedVisitor == null) {
 330             includedVisitor = new IncludedVisitor();
 331         }
 332         return includedVisitor.visit(e);
 333     }
 334 
 335     /**
 336      * Performs the final computation and freezes the collections.
 337      * This is a terminal operation, thus no further modifications
 338      * are allowed to the specified data sets.
 339      *
 340      * @throws ToolException if an error occurs
 341      */
 342     void analyze() throws ToolException {
 343         // compute the specified element, by expanding module dependencies
 344         computeSpecifiedModules();
 345 
 346         // compute all specified packages and subpackages
 347         computeSpecifiedPackages();
 348 
 349         // compute the specified types
 350         computeSpecifiedTypes();
 351 
 352         // compute the packages belonging to all the specified modules
 353         Set&lt;PackageElement&gt; expandedModulePackages = computeModulePackages();
 354         initializeIncludedSets(expandedModulePackages);
 355     }
 356 
 357     ElementsTable classTrees(com.sun.tools.javac.util.List&lt;JCCompilationUnit&gt; classTrees) {
 358         this.classTreeList = classTrees;
 359         return this;
 360     }
 361 
 362     /*
 363      * This method sanity checks the following cases:
 364      * a. a source-path containing a single module and many modules specified with --module
 365      * b. no modules on source-path
 366      * c. mismatched source-path and many modules specified with --module
 367      */
 368     void sanityCheckSourcePathModules(List&lt;String&gt; moduleNames) throws ToolException {
 369         if (!haveSourceLocationWithModule)
 370             return;
 371 
 372         if (moduleNames.size() &gt; 1) {
 373             String text = messager.getText(&quot;main.cannot_use_sourcepath_for_modules&quot;,
 374                     String.join(&quot;, &quot;, moduleNames));
 375             throw new ToolException(CMDERR, text);
 376         }
 377 
 378         String foundModule = getModuleName(StandardLocation.SOURCE_PATH);
 379         if (foundModule == null) {
 380             String text = messager.getText(&quot;main.module_not_found_on_sourcepath&quot;, moduleNames.get(0));
 381             throw new ToolException(CMDERR, text);
 382         }
 383 
 384         if (!moduleNames.get(0).equals(foundModule)) {
 385             String text = messager.getText(&quot;main.sourcepath_does_not_contain_module&quot;, moduleNames.get(0));
 386             throw new ToolException(CMDERR, text);
 387         }
 388     }
 389 
 390     private String getModuleName(Location location) throws ToolException {
 391         try {
 392             JavaFileObject jfo = fm.getJavaFileForInput(location,
 393                     &quot;module-info&quot;, JavaFileObject.Kind.SOURCE);
 394             if (jfo != null) {
 395                 JCCompilationUnit jcu = compiler.parse(jfo);
 396                 JCModuleDecl module = TreeInfo.getModule(jcu);
 397                 if (module != null) {
 398                     return module.getName().toString();
 399                 }
 400             }
 401         } catch (IOException ioe) {
 402             String text = messager.getText(&quot;main.file.manager.list&quot;, location);
 403             throw new ToolException(SYSERR, text, ioe);
 404         }
 405         return null;
 406     }
 407 
 408     ElementsTable scanSpecifiedItems() throws ToolException {
 409 
 410         // scan modules specified on the command line
 411         List&lt;String&gt; modules = options.modules();
 412         List&lt;String&gt; mlist = new ArrayList&lt;&gt;();
 413         for (String m : modules) {
 414             List&lt;Location&gt; moduleLocations = getModuleLocation(locations, m);
 415             if (moduleLocations.isEmpty()) {
 416                 String text = messager.getText(&quot;main.module_not_found&quot;, m);
 417                 throw new ToolException(CMDERR, text);
 418             }
 419             if (moduleLocations.contains(StandardLocation.SOURCE_PATH)) {
 420                 sanityCheckSourcePathModules(modules);
 421             }
 422             mlist.add(m);
 423             ModuleSymbol msym = syms.enterModule(names.fromString(m));
<a name="2" id="anc2"></a><span class="line-modified"> 424             specifiedModuleElements.add(msym);</span>
 425         }
 426 
 427         // scan for modules with qualified packages
 428         cmdLinePackages.stream()
<a name="3" id="anc3"></a><span class="line-modified"> 429                 .filter(ModulePackage::hasModule)</span>
<span class="line-modified"> 430                 .forEachOrdered(mpkg -&gt; mlist.add(mpkg.moduleName));</span>


 431 
 432         // scan for modules with qualified subpackages
 433         options.subpackages().stream()
 434             .map(ModulePackage::new)
<a name="4" id="anc4"></a><span class="line-modified"> 435             .forEachOrdered(mpkg -&gt; {</span>
 436                 subPackages.add(mpkg);
 437                 if (mpkg.hasModule()) {
 438                     mlist.add(mpkg.moduleName);
 439                 }
 440             });
 441 
 442         // all the modules specified on the command line have been scraped
 443         // init the module systems
 444         this.modules.addExtraAddModules(mlist.toArray(new String[mlist.size()]));
 445         this.modules.initModules(this.classTreeList);
 446 
 447         return this;
 448     }
 449 
 450     /**
 451      * Returns the includes table after setting a class names specified on the command line.
 452      *
 453      * @param classList
 454      * @return the include table
 455      */
 456     ElementsTable setClassArgList(List&lt;String&gt; classList) {
 457         classArgList = classList;
 458         return this;
 459     }
 460 
 461     /**
 462      * Returns the includes table after setting the parsed class names.
 463      *
 464      * @param classesDecList
 465      * @return the include table
 466      */
 467     ElementsTable setClassDeclList(List&lt;JCClassDecl&gt; classesDecList) {
 468         this.classDecList = classesDecList;
 469         return this;
 470     }
 471 
 472     /**
 473      * Returns an includes table after setting the specified package
 474      * names.
 475      * @param packageNames packages on the command line
 476      * @return the includes table after setting the specified package
 477      * names
 478      */
 479     ElementsTable packages(Collection&lt;String&gt; packageNames) {
 480         packageNames.stream()
 481             .map(ModulePackage::new)
<a name="5" id="anc5"></a><span class="line-modified"> 482             .forEachOrdered(mpkg -&gt; cmdLinePackages.add(mpkg));</span>
 483         return this;
 484     }
 485 
 486     /**
 487      * Returns the aggregate set of included packages and specified
 488      * sub packages.
 489      *
 490      * @return the aggregate set of included packages and specified
 491      * sub packages
 492      */
 493     Iterable&lt;ModulePackage&gt; getPackagesToParse() throws IOException {
 494         List&lt;ModulePackage&gt; result = new ArrayList&lt;&gt;();
 495         result.addAll(cmdLinePackages);
 496         result.addAll(subPackages);
 497         return result;
 498     }
 499 
 500     private void computeSubpackages() throws ToolException {
 501         options.excludes().stream()
 502                 .map(ModulePackage::new)
<a name="6" id="anc6"></a><span class="line-modified"> 503                 .forEachOrdered(mpkg -&gt; excludePackages.add(mpkg));</span>
 504 
<a name="7" id="anc7"></a><span class="line-modified"> 505         excludePackages.forEach(p -&gt; getEntry(p).excluded = true);</span>


 506 
 507         for (ModulePackage modpkg : subPackages) {
 508             List&lt;Location&gt; locs = getLocation(modpkg);
 509             for (Location loc : locs) {
 510                 addPackagesFromLocations(loc, modpkg);
 511             }
 512         }
 513     }
 514 
 515     /* Call fm.list and wrap any IOException that occurs in a ToolException */
 516     private Iterable&lt;JavaFileObject&gt; fmList(Location location,
 517                                             String packagename,
 518                                             Set&lt;JavaFileObject.Kind&gt; kinds,
 519                                             boolean recurse) throws ToolException {
 520         try {
 521             return fm.list(location, packagename, kinds, recurse);
 522         } catch (IOException ioe) {
 523             String text = messager.getText(&quot;main.file.manager.list&quot;, packagename);
 524             throw new ToolException(SYSERR, text, ioe);
 525         }
 526     }
 527 
 528     private void addPackagesFromLocations(Location packageLocn, ModulePackage modpkg) throws ToolException {
 529         for (JavaFileObject fo : fmList(packageLocn, modpkg.packageName, sourceKinds, true)) {
 530             String binaryName = fm.inferBinaryName(packageLocn, fo);
 531             String pn = getPackageName(binaryName);
 532             String simpleName = getSimpleName(binaryName);
 533             Entry e = getEntry(pn);
 534             if (!e.isExcluded() &amp;&amp; isValidClassName(simpleName)) {
 535                 ModuleSymbol msym = (modpkg.hasModule())
 536                         ? syms.getModule(names.fromString(modpkg.moduleName))
 537                         : findModuleOfPackageName(modpkg.packageName);
 538 
 539                 if (msym != null &amp;&amp; !msym.isUnnamed()) {
 540                     syms.enterPackage(msym, names.fromString(pn));
 541                     ModulePackage npkg = new ModulePackage(msym.toString(), pn);
 542                     cmdLinePackages.add(npkg);
 543                 } else {
 544                     cmdLinePackages.add(e.modpkg);
 545                 }
 546                 e.files = (e.files == null
 547                         ? com.sun.tools.javac.util.List.of(fo)
 548                         : e.files.prepend(fo));
 549             }
 550         }
 551     }
 552 
 553     /**
 554      * Returns the &quot;requires&quot; modules for the target module.
 555      * @param mdle the target module element
 556      * @param onlyTransitive true gets all the requires transitive, otherwise
 557      *                 gets all the non-transitive requires
 558      *
 559      * @return a set of modules
 560      */
 561     private Set&lt;ModuleElement&gt; getModuleRequires(ModuleElement mdle, boolean onlyTransitive) throws ToolException {
 562         Set&lt;ModuleElement&gt; result = new HashSet&lt;&gt;();
 563         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
 564             ModuleElement dep = rd.getDependency();
 565             if (result.contains(dep))
 566                 continue;
 567             if (!isMandated(mdle, rd) &amp;&amp; onlyTransitive == rd.isTransitive()) {
 568                 if (!haveModuleSources(dep)) {
 569                     messager.printWarning(dep, &quot;main.module_not_found&quot;, dep.getSimpleName());
 570                 }
 571                 result.add(dep);
 572             } else if (isMandated(mdle, rd) &amp;&amp; haveModuleSources(dep)) {
 573                 result.add(dep);
 574             }
 575         }
 576         return result;
 577     }
 578 
 579     private boolean isMandated(ModuleElement mdle, RequiresDirective rd) {
 580         return toolEnv.elements.getOrigin(mdle, rd) == MANDATED;
 581     }
 582 
 583     Map&lt;ModuleSymbol, Boolean&gt; haveModuleSourcesCache = new HashMap&lt;&gt;();
 584     private boolean haveModuleSources(ModuleElement mdle) throws ToolException {
 585         ModuleSymbol msym =  (ModuleSymbol)mdle;
 586         if (msym.sourceLocation != null) {
 587             return true;
 588         }
 589         if (msym.patchLocation != null) {
 590             Boolean value = haveModuleSourcesCache.get(msym);
 591             if (value == null) {
 592                 value = fmList(msym.patchLocation, &quot;&quot;, sourceKinds, true).iterator().hasNext();
 593                 haveModuleSourcesCache.put(msym, value);
 594             }
 595             return value;
 596         }
 597         return false;
 598     }
 599 
 600     private void computeSpecifiedModules() throws ToolException {
 601         if (expandRequires == null) { // no expansion requested
 602             specifiedModuleElements = Collections.unmodifiableSet(specifiedModuleElements);
 603             return;
 604         }
 605 
 606         final boolean expandAll = expandRequires.equals(AccessKind.PRIVATE)
 607                 || expandRequires.equals(AccessKind.PACKAGE);
 608 
 609         Set&lt;ModuleElement&gt; result = new LinkedHashSet&lt;&gt;();
 610         ListBuffer&lt;ModuleElement&gt; queue = new ListBuffer&lt;&gt;();
 611 
 612         // expand each specified module
 613         for (ModuleElement mdle : specifiedModuleElements) {
 614             result.add(mdle); // a specified module is included
 615             queue.append(mdle);
 616             Set&lt;ModuleElement&gt; publicRequires = getModuleRequires(mdle, true);
 617             result.addAll(publicRequires);
 618             // add all requires public
 619             queue.addAll(publicRequires);
 620 
 621             if (expandAll) {
 622                  // add non-public requires if needed
 623                 result.addAll(getModuleRequires(mdle, !expandAll));
 624             }
 625         }
 626 
 627         // compute the transitive closure of all the requires public
 628         for (ModuleElement m = queue.poll() ; m != null ; m = queue.poll()) {
 629             for (ModuleElement mdle : getModuleRequires(m, true)) {
 630                 if (!result.contains(mdle)) {
 631                     result.add(mdle);
 632                     queue.append(mdle);
 633                 }
 634             }
 635         }
 636         specifiedModuleElements = Collections.unmodifiableSet(result);
 637     }
 638 
 639     private Set&lt;PackageElement&gt; getAllModulePackages(ModuleElement mdle) throws ToolException {
 640         Set&lt;PackageElement&gt; result = new HashSet&lt;&gt;();
 641         ModuleSymbol msym = (ModuleSymbol) mdle;
 642         List&lt;Location&gt; msymlocs = getModuleLocation(locations, msym.name.toString());
 643         for (Location msymloc : msymlocs) {
 644             for (JavaFileObject fo : fmList(msymloc, &quot;&quot;, sourceKinds, true)) {
 645                 if (fo.getName().endsWith(&quot;module-info.java&quot;)) {
 646                     continue;
 647                 }
 648                 String binaryName = fm.inferBinaryName(msymloc, fo);
 649                 String pn = getPackageName(binaryName);
 650                 PackageSymbol psym = syms.enterPackage(msym, names.fromString(pn));
 651                 result.add((PackageElement) psym);
 652             }
 653         }
 654         return result;
 655     }
 656 
 657     private Set&lt;PackageElement&gt; computeModulePackages() throws ToolException {
 658         AccessKind accessValue = accessFilter.getAccessValue(ElementKind.PACKAGE);
 659         final boolean documentAllModulePackages = (accessValue == AccessKind.PACKAGE ||
 660                 accessValue == AccessKind.PRIVATE);
 661 
 662         accessValue = accessFilter.getAccessValue(ElementKind.MODULE);
 663         final boolean moduleDetailedMode = (accessValue == AccessKind.PACKAGE ||
 664                 accessValue == AccessKind.PRIVATE);
 665         Set&lt;PackageElement&gt; expandedModulePackages = new LinkedHashSet&lt;&gt;();
 666 
 667         for (ModuleElement mdle : specifiedModuleElements) {
 668             if (documentAllModulePackages) { // include all packages
 669                 List&lt;PackageElement&gt; packages = ElementFilter.packagesIn(mdle.getEnclosedElements());
 670                 expandedModulePackages.addAll(packages);
 671                 expandedModulePackages.addAll(getAllModulePackages(mdle));
 672             } else { // selectively include required packages
 673                 List&lt;ExportsDirective&gt; exports = ElementFilter.exportsIn(mdle.getDirectives());
 674                 for (ExportsDirective export : exports) {
 675                     // add if fully exported or add qualified exports only if desired
 676                     if (export.getTargetModules() == null
 677                             || documentAllModulePackages || moduleDetailedMode) {
 678                         expandedModulePackages.add(export.getPackage());
 679                     }
 680                 }
 681             }
 682 
 683             // add all packages specified on the command line
 684             // belonging to this module
 685             if (!cmdLinePackages.isEmpty()) {
 686                 for (ModulePackage modpkg : cmdLinePackages) {
 687                     PackageElement pkg = toolEnv.elements.getPackageElement(mdle,
 688                             modpkg.packageName);
 689                     if (pkg != null) {
 690                         expandedModulePackages.add(pkg);
 691                     }
 692                 }
 693             }
 694         }
 695         return expandedModulePackages;
 696     }
 697 
 698     private void initializeIncludedSets(Set&lt;PackageElement&gt; expandedModulePackages) {
 699 
 700         // process modules
 701         Set&lt;ModuleElement&gt; imodules = new LinkedHashSet&lt;&gt;();
 702         // add all the expanded modules
 703         imodules.addAll(specifiedModuleElements);
 704 
 705         // process packages
 706         Set&lt;PackageElement&gt; ipackages = new LinkedHashSet&lt;&gt;();
 707         // add all packages belonging to expanded modules
 708         ipackages.addAll(expandedModulePackages);
 709         // add all specified packages
 710         specifiedPackageElements.forEach(pkg -&gt; {
 711             ModuleElement mdle = toolEnv.elements.getModuleOf(pkg);
 712             if (mdle != null)
 713                 imodules.add(mdle);
 714             ipackages.add(pkg);
 715         });
 716 
 717         // process types
 718         Set&lt;TypeElement&gt; iclasses = new LinkedHashSet&lt;&gt;();
 719         // add all types enclosed in expanded modules and packages
<a name="8" id="anc8"></a><span class="line-modified"> 720         ipackages.forEach(pkg -&gt; addAllClasses(iclasses, pkg));</span>


 721         // add all types and its nested types
<a name="9" id="anc9"></a><span class="line-modified"> 722         specifiedTypeElements.forEach(klass -&gt; {</span>
 723             ModuleElement mdle = toolEnv.elements.getModuleOf(klass);
 724             if (mdle != null &amp;&amp; !mdle.isUnnamed())
 725                 imodules.add(mdle);
 726             PackageElement pkg = toolEnv.elements.getPackageOf(klass);
 727             ipackages.add(pkg);
 728             addAllClasses(iclasses, klass, true);
 729         });
 730 
 731         // all done, freeze the collections
 732         includedModuleElements = Collections.unmodifiableSet(imodules);
 733         includedPackageElements = Collections.unmodifiableSet(ipackages);
 734         includedTypeElements = Collections.unmodifiableSet(iclasses);
 735     }
 736 
 737     /*
 738      * Computes the included packages and freezes the specified packages list.
 739      */
 740     private void computeSpecifiedPackages() throws ToolException {
 741 
 742         computeSubpackages();
 743 
 744         Set&lt;PackageElement&gt; packlist = new LinkedHashSet&lt;&gt;();
<a name="10" id="anc10"></a><span class="line-modified"> 745         cmdLinePackages.forEach(modpkg -&gt; {</span>
 746             PackageElement pkg;
 747             if (modpkg.hasModule()) {
 748                 ModuleElement mdle = toolEnv.elements.getModuleElement(modpkg.moduleName);
 749                 pkg = toolEnv.elements.getPackageElement(mdle, modpkg.packageName);
 750             } else {
 751                 pkg = toolEnv.elements.getPackageElement(modpkg.toString());
 752             }
 753 
 754             if (pkg != null) {
 755                 packlist.add(pkg);
 756             } else {
 757                 messager.printWarningUsingKey(&quot;main.package_not_found&quot;, modpkg.toString());
 758             }
 759         });
 760         specifiedPackageElements = Collections.unmodifiableSet(packlist);
 761     }
 762 
 763     /**
 764      * Adds all classes as well as inner classes, to the specified
 765      * list.
 766      */
 767     private void computeSpecifiedTypes() throws ToolException {
 768         Set&lt;TypeElement&gt; classes = new LinkedHashSet&lt;&gt;();
<a name="11" id="anc11"></a><span class="line-modified"> 769           classDecList.forEach(def -&gt; {</span>
<span class="line-modified"> 770             TypeElement te = def.sym;</span>
 771             if (te != null) {
 772                 addAllClasses(classes, te, true);
 773             }
 774         });
 775         for (String className : classArgList) {
 776             TypeElement te = toolEnv.loadClass(className);
 777             if (te == null) {
 778                 String text = messager.getText(&quot;javadoc.class_not_found&quot;, className);
 779                 throw new ToolException(CMDERR, text);
 780             } else {
 781                 addAllClasses(classes, te, true);
 782             }
 783         }
 784         specifiedTypeElements = Collections.unmodifiableSet(classes);
 785     }
 786 
 787     private void addFilesForParser(Collection&lt;JavaFileObject&gt; result,
 788             Collection&lt;ModulePackage&gt; collection,
 789             boolean recurse) throws ToolException {
 790         for (ModulePackage modpkg : collection) {
 791             toolEnv.notice(&quot;main.Loading_source_files_for_package&quot;, modpkg.toString());
 792             List&lt;JavaFileObject&gt; files = getFiles(modpkg, recurse);
 793             if (files.isEmpty()) {
 794                 String text = messager.getText(&quot;main.no_source_files_for_package&quot;,
 795                         modpkg.toString());
 796                 throw new ToolException(CMDERR, text);
 797             } else {
 798                 result.addAll(files);
 799             }
 800         }
 801     }
 802 
 803     /**
 804      * Returns an aggregated list of java file objects from the items
 805      * specified on the command line. The packages specified should not
 806      * recurse, however sub-packages should recurse into the sub directories.
 807      * @return a list of java file objects
 808      * @throws IOException if an error occurs
 809      */
 810     List&lt;JavaFileObject&gt; getFilesToParse() throws ToolException {
 811         List&lt;JavaFileObject&gt; result = new ArrayList&lt;&gt;();
 812         addFilesForParser(result, cmdLinePackages, false);
 813         addFilesForParser(result, subPackages, true);
 814         return result;
 815     }
 816 
 817     /**
 818      * Returns the set of source files for a package.
 819      *
 820      * @param modpkg the specified package
 821      * @return the set of file objects for the specified package
 822      * @throws ToolException if an error occurs while accessing the files
 823      */
 824     private List&lt;JavaFileObject&gt; getFiles(ModulePackage modpkg,
 825             boolean recurse) throws ToolException {
 826         Entry e = getEntry(modpkg);
 827         // The files may have been found as a side effect of searching for subpackages
 828         if (e.files != null) {
 829             return e.files;
 830         }
 831 
 832         ListBuffer&lt;JavaFileObject&gt; lb = new ListBuffer&lt;&gt;();
 833         List&lt;Location&gt; locs = getLocation(modpkg);
 834         if (locs.isEmpty()) {
 835             return Collections.emptyList();
 836         }
 837         String pname = modpkg.packageName;
 838         for (Location packageLocn : locs) {
 839             for (JavaFileObject fo : fmList(packageLocn, pname, sourceKinds, recurse)) {
 840                 String binaryName = fm.inferBinaryName(packageLocn, fo);
 841                 String simpleName = getSimpleName(binaryName);
 842                 if (isValidClassName(simpleName)) {
 843                     lb.append(fo);
 844                 }
 845             }
 846         }
 847         return lb.toList();
 848     }
 849 
 850     private ModuleSymbol findModuleOfPackageName(String packageName) {
 851             Name pack = names.fromString(packageName);
 852             for (ModuleSymbol msym : modules.allModules()) {
 853                 PackageSymbol p = syms.getPackage(msym, pack);
 854                 if (p != null &amp;&amp; !p.members().isEmpty()) {
 855                     return msym;
 856                 }
 857             }
 858             return null;
 859     }
 860 
 861     private List&lt;Location&gt; getLocation(ModulePackage modpkg) throws ToolException {
 862         if (locations.size() == 1 &amp;&amp; !locations.contains(StandardLocation.MODULE_SOURCE_PATH)) {
 863             return Collections.singletonList(locations.get(0));
 864         }
 865 
 866         if (modpkg.hasModule()) {
 867             return getModuleLocation(locations, modpkg.moduleName);
 868         }
 869         // TODO: handle invalid results better.
 870         ModuleSymbol msym = findModuleOfPackageName(modpkg.packageName);
 871         if (msym == null) {
 872             return Collections.emptyList();
 873         }
 874         return getModuleLocation(locations, msym.name.toString());
 875     }
 876 
 877     boolean haveSourceLocationWithModule = false;
 878 
 879     private List&lt;Location&gt; getModuleLocation(List&lt;Location&gt; locations, String msymName) throws ToolException {
 880         List&lt;Location&gt; out = new ArrayList&lt;&gt;();
 881         // search in the patch module first, this overrides others
 882         if (locations.contains(StandardLocation.PATCH_MODULE_PATH)) {
 883             Location loc = getModuleLocation(StandardLocation.PATCH_MODULE_PATH, msymName);
 884             if (loc != null)
 885                 out.add(loc);
 886         }
 887         for (Location location : locations) {
 888             // skip patch module, already done
 889             if (location == StandardLocation.PATCH_MODULE_PATH) {
 890                 continue;
 891             } else if (location == StandardLocation.MODULE_SOURCE_PATH) {
 892                 Location loc = getModuleLocation(location, msymName);
 893                 if (loc != null)
 894                     out.add(loc);
 895             } else if (location == StandardLocation.SOURCE_PATH) {
 896                 haveSourceLocationWithModule = true;
 897                 out.add(StandardLocation.SOURCE_PATH);
 898             }
 899         }
 900         return out;
 901     }
 902 
 903     private Location getModuleLocation(Location location, String msymName) throws ToolException {
 904         try {
 905             return fm.getLocationForModule(location, msymName);
 906         } catch (IOException ioe) {
 907             String text = messager.getText(&quot;main.doclet_could_not_get_location&quot;, msymName);
 908             throw new ToolException(ERROR, text, ioe);
 909         }
 910     }
 911 
 912     private Entry getEntry(String name) {
 913         return getEntry(new ModulePackage(name));
 914     }
 915 
 916     private Entry getEntry(ModulePackage modpkg) {
 917         Entry e = entries.get(modpkg.packageName);
 918         if (e == null) {
 919             entries.put(modpkg.packageName, e = new Entry(modpkg));
 920         }
 921         return e;
 922     }
 923 
 924     private String getPackageName(String name) {
 925         int lastDot = name.lastIndexOf(&quot;.&quot;);
 926         return (lastDot == -1 ? &quot;&quot; : name.substring(0, lastDot));
 927     }
 928 
 929     private String getSimpleName(String name) {
 930         int lastDot = name.lastIndexOf(&quot;.&quot;);
 931         return (lastDot == -1 ? name : name.substring(lastDot + 1));
 932     }
 933 
 934     /**
 935      * Adds all inner classes of this class, and their inner classes recursively, to the list
 936      */
 937     private void addAllClasses(Collection&lt;TypeElement&gt; list, TypeElement typeElement, boolean filtered) {
 938         ClassSymbol klass = (ClassSymbol)typeElement;
 939         try {
 940             // eliminate needless checking, do this first.
 941             if (list.contains(klass)) return;
 942             // ignore classes with invalid Java class names
 943             if (!JavadocTool.isValidClassName(klass.name.toString())) return;
 944             if (filtered &amp;&amp; !isTypeElementSelected(klass)) return;
 945             list.add(klass);
 946             for (Symbol sym : klass.members().getSymbols(NON_RECURSIVE)) {
 947                 if (sym != null &amp;&amp; sym.kind == Kind.TYP) {
 948                     ClassSymbol s = (ClassSymbol)sym;
 949                     addAllClasses(list, s, filtered);
 950                 }
 951             }
 952         } catch (CompletionFailure e) {
 953             if (e.getMessage() != null)
 954                 messager.printWarning(e.getMessage());
 955             else
 956                 messager.printWarningUsingKey(&quot;main.unexpected.exception&quot;, e);
 957         }
 958     }
 959 
 960     /**
 961      * Returns a list of all classes contained in this package, including
 962      * member classes of those classes, and their member classes, etc.
 963      */
 964     private void addAllClasses(Collection&lt;TypeElement&gt; list, PackageElement pkg) {
 965         boolean filtered = true;
 966         for (Element isym : pkg.getEnclosedElements()) {
 967             addAllClasses(list, (TypeElement)isym, filtered);
 968         }
 969     }
 970 
 971     private boolean isTypeElementSelected(TypeElement te) {
 972         return (xclasses || toolEnv.getFileKind(te) == SOURCE) &amp;&amp; isSelected(te);
 973     }
 974 
 975     @SuppressWarnings(&quot;preview&quot;)
 976     SimpleElementVisitor14&lt;Boolean, Void&gt; visibleElementVisitor = null;
 977     /**
 978      * Returns true if the element is selected, by applying
 979      * the access filter checks. Special treatment is applied to
 980      * types, for a top level type the access filter applies completely,
 981      * however if is a nested type then it is allowed either  if
 982      * the enclosing is a static or the enclosing is also selected.
 983      *
 984      * @param e the element to be checked
 985      * @return true if the element is visible
 986      */
 987     @SuppressWarnings(&quot;preview&quot;)
 988     public boolean isSelected(Element e) {
 989         if (toolEnv.isSynthetic((Symbol) e)) {
 990             return false;
 991         }
 992         if (visibleElementVisitor == null) {
 993             visibleElementVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
 994                 @Override
 995                 public Boolean visitType(TypeElement e, Void p) {
 996                     if (!accessFilter.checkModifier(e)) {
 997                         return false; // it is not allowed
 998                     }
 999                     Element encl = e.getEnclosingElement();
1000 
1001                     // check if nested
1002                     if (encl.getKind() == ElementKind.PACKAGE)
1003                         return true; // top-level class, allow it
1004 
1005                     // is enclosed static
1006                     if (encl.getModifiers().contains(Modifier.STATIC))
1007                         return true; // allowed
1008 
1009                     // check the enclosing
1010                     return visit(encl);
1011                 }
1012 
1013                 @Override
1014                 protected Boolean defaultAction(Element e, Void p) {
1015                     return accessFilter.checkModifier(e);
1016                 }
1017 
1018                 @Override
1019                 public Boolean visitUnknown(Element e, Void p) {
1020                     throw new AssertionError(&quot;unknown element: &quot; + e);
1021                 }
1022             };
1023         }
1024         return visibleElementVisitor.visit(e);
1025     }
1026 
1027     @SuppressWarnings(&quot;preview&quot;)
1028     private class IncludedVisitor extends SimpleElementVisitor14&lt;Boolean, Void&gt; {
1029         private final Set&lt;Element&gt; includedCache;
1030 
1031         public IncludedVisitor() {
1032             includedCache = new LinkedHashSet&lt;&gt;();
1033         }
1034 
1035         @Override
1036         public Boolean visitModule(ModuleElement e, Void p) {
1037             // deduced by specified and/or requires expansion
1038             return includedModuleElements.contains(e);
1039         }
1040 
1041         @Override
1042         public Boolean visitPackage(PackageElement e, Void p) {
1043             // deduced by specified or downward expansions
1044             return includedPackageElements.contains(e);
1045         }
1046 
1047         @Override
1048         public Boolean visitType(TypeElement e, Void p) {
1049             if (includedTypeElements.contains(e)) {
1050                 return true;
1051             }
1052             if (isTypeElementSelected(e)) {
1053                 // Class is nameable from top-level and
1054                 // the class and all enclosing classes
1055                 // pass the modifier filter.
1056                 PackageElement pkg = toolEnv.elements.getPackageOf(e);
1057                 if (specifiedPackageElements.contains(pkg)) {
1058                     return true;
1059                 }
1060                 Element enclosing = e.getEnclosingElement();
1061                 if (enclosing != null) {
1062                     switch(enclosing.getKind()) {
1063                         case PACKAGE:
1064                             return specifiedPackageElements.contains((PackageElement)enclosing);
1065                         case CLASS: case INTERFACE: case ENUM: case ANNOTATION_TYPE:
1066                             return visit((TypeElement) enclosing);
1067                         default:
1068                             throw new AssertionError(&quot;unknown element: &quot; + enclosing);
1069                     }
1070                 }
1071             }
1072             return false;
1073         }
1074 
1075         // members
1076         @Override
1077         public Boolean defaultAction(Element e, Void p) {
1078             if (includedCache.contains(e))
1079                 return true;
1080             if (visit(e.getEnclosingElement()) &amp;&amp; isSelected(e)) {
1081                 switch(e.getKind()) {
1082                     case ANNOTATION_TYPE: case CLASS: case ENUM: case INTERFACE:
1083                     case MODULE: case OTHER: case PACKAGE:
1084                         throw new AssertionError(&quot;invalid element for this operation: &quot; + e);
1085                     default:
1086                         // the only allowed kinds in the cache are &quot;members&quot;
1087                         includedCache.add(e);
1088                         return true;
1089                 }
1090             }
1091             return false;
1092         }
1093 
1094         @Override
1095         public Boolean visitUnknown(Element e, Void p) {
1096             throw new AssertionError(&quot;unknown element: &quot; + e);
1097         }
1098 
1099     }
1100 
1101     class Entry {
1102         final ModulePackage modpkg;
1103         Boolean excluded = false;
1104         com.sun.tools.javac.util.List&lt;JavaFileObject&gt; files;
1105 
1106         Entry(ModulePackage modpkg) {
1107             this.modpkg = modpkg;
1108         }
1109 
1110         Entry(String name) {
1111             modpkg = new ModulePackage(name);
1112         }
1113 
1114         boolean isExcluded() {
1115             return excluded;
1116         }
1117 
1118         @Override
1119         public String toString() {
1120             return &quot;Entry{&quot; + &quot;modpkg=&quot; + modpkg + &quot;, excluded=&quot; + excluded + &quot;, files=&quot; + files + &#39;}&#39;;
1121         }
1122     }
1123 
1124     /**
1125      * A container class to retrieve the module and package pair
1126      * from a parsed qualified package name.
1127      */
1128     static class ModulePackage {
1129 
1130         public final String moduleName;
1131         public final String packageName;
1132 
1133         ModulePackage(String modulename, String packagename) {
1134             this.moduleName = modulename;
1135             this.packageName = packagename;
1136         }
1137 
1138         ModulePackage(ModuleElement msym, String packagename) {
1139             this.moduleName = msym.toString();
1140             this.packageName = packagename;
1141         }
1142 
1143         ModulePackage(String name) {
1144             String a[] = name.split(&quot;/&quot;);
1145             if (a.length == 2) {
1146                 this.moduleName = a[0];
1147                 this.packageName = a[1];
1148             } else {
1149                 moduleName = null;
1150                 packageName = name;
1151             }
1152         }
1153 
1154         boolean hasModule() {
1155             return this.moduleName != null;
1156         }
1157 
1158         @Override
1159         public boolean equals(Object obj) {
1160             if (obj instanceof ModulePackage) {
1161                 ModulePackage that = (ModulePackage)obj;
1162                 return this.toString().equals(that.toString());
1163             }
1164             return false;
1165         }
1166 
1167         @Override
1168         public int hashCode() {
1169              return toString().hashCode();
1170         }
1171 
1172         @Override
1173         public String toString() {
1174             return moduleName == null ? packageName : moduleName + &quot;/&quot; + packageName;
1175         }
1176     }
1177 
1178     /**
1179      * A class which filters the access flags on classes, fields, methods, etc.
1180      *
1181      * @see javax.lang.model.element.Modifier
1182      */
1183 
1184     static class ModifierFilter {
1185         /**
1186          * The allowed ElementKind that can be stored.
1187          */
1188         static final EnumSet&lt;ElementKind&gt; ALLOWED_KINDS = EnumSet.of(ElementKind.METHOD,
1189                                                     ElementKind.CLASS,
1190                                                     ElementKind.PACKAGE,
1191                                                     ElementKind.MODULE);
1192 
1193         // all possible access levels allowed for each element
1194         private final EnumMap&lt;ElementKind, EnumSet&lt;AccessKind&gt;&gt; filterMap =
1195                 new EnumMap&lt;&gt;(ElementKind.class);
1196 
1197         // the specified access level for each element
1198         private final EnumMap&lt;ElementKind, AccessKind&gt; accessMap =
1199                 new EnumMap&lt;&gt;(ElementKind.class);
1200 
1201         /**
1202          * Constructor - Specify a filter.
1203          *
1204          * @param options the tool options
1205          */
1206         ModifierFilter(ToolOptions options) {
1207 
1208             AccessKind accessValue = null;
1209             for (ElementKind kind : ALLOWED_KINDS) {
1210                 switch (kind) {
1211                     case METHOD:
1212                         accessValue  = options.showMembersAccess();
1213                         break;
1214                     case CLASS:
1215                         accessValue  = options.showTypesAccess();
1216                         break;
1217                     case PACKAGE:
1218                         accessValue  = options.showPackagesAccess();
1219                         break;
1220                     case MODULE:
1221                         accessValue  = options.showModuleContents();
1222                         break;
1223                     default:
1224                         throw new AssertionError(&quot;unknown element: &quot; + kind);
1225 
1226                 }
1227                 accessMap.put(kind, accessValue);
1228                 filterMap.put(kind, getFilterSet(accessValue));
1229             }
1230         }
1231 
1232         static EnumSet&lt;AccessKind&gt; getFilterSet(AccessKind accessValue) {
1233             switch (accessValue) {
1234                 case PUBLIC:
1235                     return EnumSet.of(AccessKind.PUBLIC);
1236                 case PROTECTED:
1237                 default:
1238                     return EnumSet.of(AccessKind.PUBLIC, AccessKind.PROTECTED);
1239                 case PACKAGE:
1240                     return EnumSet.of(AccessKind.PUBLIC, AccessKind.PROTECTED, AccessKind.PACKAGE);
1241                 case PRIVATE:
1242                     return EnumSet.allOf(AccessKind.class);
1243             }
1244         }
1245 
1246         public AccessKind getAccessValue(ElementKind kind) {
1247             if (!ALLOWED_KINDS.contains(kind)) {
1248                 throw new IllegalArgumentException(&quot;not allowed: &quot; + kind);
1249             }
1250             return accessMap.getOrDefault(kind, AccessKind.PROTECTED);
1251         }
1252 
1253         /**
1254          * Returns true if access is allowed.
1255          *
1256          * @param e the element in question
1257          * @return whether the modifiers pass this filter
1258          */
1259         public boolean checkModifier(Element e) {
1260             Set&lt;Modifier&gt; modifiers = e.getModifiers();
1261             AccessKind fflag = AccessKind.PACKAGE;
1262             if (modifiers.contains(Modifier.PUBLIC)) {
1263                 fflag = AccessKind.PUBLIC;
1264             } else if (modifiers.contains(Modifier.PROTECTED)) {
1265                 fflag = AccessKind.PROTECTED;
1266             } else if (modifiers.contains(Modifier.PRIVATE)) {
1267                 fflag = AccessKind.PRIVATE;
1268             }
1269             EnumSet&lt;AccessKind&gt; filterSet = filterMap.get(getAllowedKind(e.getKind()));
1270             return filterSet.contains(fflag);
1271         }
1272 
1273         // convert a requested element kind to an allowed access kind
1274         private ElementKind getAllowedKind(ElementKind kind) {
1275             switch (kind) {
1276                 case CLASS: case METHOD: case MODULE: case PACKAGE:
1277                     return kind;
1278                 case RECORD: case ANNOTATION_TYPE: case ENUM: case INTERFACE:
1279                     return ElementKind.CLASS;
1280                 case CONSTRUCTOR: case ENUM_CONSTANT: case EXCEPTION_PARAMETER:
1281                 case FIELD: case INSTANCE_INIT: case LOCAL_VARIABLE: case PARAMETER:
1282                 case RESOURCE_VARIABLE: case STATIC_INIT: case TYPE_PARAMETER:
1283                     return ElementKind.METHOD;
1284                 default:
1285                     throw new AssertionError(&quot;unsupported kind: &quot; + kind);
1286             }
1287         }
1288     } // end ModifierFilter
1289 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
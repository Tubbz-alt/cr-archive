<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/pkcs12/PKCS12KeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.pkcs12;
  27 
  28 import java.io.*;
  29 import java.security.AccessController;
  30 import java.security.MessageDigest;
  31 import java.security.NoSuchAlgorithmException;
  32 import java.security.Key;
  33 import java.security.KeyFactory;
  34 import java.security.KeyStore;
  35 import java.security.KeyStoreSpi;
  36 import java.security.KeyStoreException;
  37 import java.security.PKCS12Attribute;
  38 import java.security.PrivateKey;
  39 import java.security.PrivilegedAction;
  40 import java.security.UnrecoverableEntryException;
  41 import java.security.UnrecoverableKeyException;
  42 import java.security.SecureRandom;
  43 import java.security.Security;
  44 import java.security.cert.Certificate;
  45 import java.security.cert.CertificateFactory;
  46 import java.security.cert.X509Certificate;
  47 import java.security.cert.CertificateException;
  48 import java.security.spec.AlgorithmParameterSpec;
  49 import java.security.spec.InvalidParameterSpecException;
  50 import java.security.spec.KeySpec;
  51 import java.security.spec.PKCS8EncodedKeySpec;
  52 import java.util.*;
  53 
  54 import static java.nio.charset.StandardCharsets.UTF_8;
  55 
  56 import java.security.AlgorithmParameters;
  57 import java.security.InvalidAlgorithmParameterException;
  58 import javax.crypto.spec.PBEParameterSpec;
  59 import javax.crypto.spec.PBEKeySpec;
  60 import javax.crypto.spec.SecretKeySpec;
  61 import javax.crypto.SecretKeyFactory;
  62 import javax.crypto.SecretKey;
  63 import javax.crypto.Cipher;
  64 import javax.crypto.Mac;
  65 import javax.security.auth.DestroyFailedException;
  66 import javax.security.auth.x500.X500Principal;
  67 
  68 import sun.security.tools.KeyStoreUtil;
  69 import sun.security.util.Debug;
  70 import sun.security.util.DerInputStream;
  71 import sun.security.util.DerOutputStream;
  72 import sun.security.util.DerValue;
  73 import sun.security.util.ObjectIdentifier;
  74 import sun.security.pkcs.ContentInfo;
  75 import sun.security.util.SecurityProperties;
  76 import sun.security.x509.AlgorithmId;
  77 import sun.security.pkcs.EncryptedPrivateKeyInfo;
  78 import sun.security.provider.JavaKeyStore.JKS;
  79 import sun.security.util.KeyStoreDelegator;
  80 import sun.security.x509.AuthorityKeyIdentifierExtension;
  81 
  82 
  83 /**
  84  * This class provides the keystore implementation referred to as &quot;PKCS12&quot;.
  85  * Implements the PKCS#12 PFX protected using the Password privacy mode.
  86  * The contents are protected using Password integrity mode.
  87  *
  88  * Currently these PBE algorithms are used by default:
  89  *  - PBEWithSHA1AndDESede to encrypt private keys, iteration count 50000.
  90  *  - PBEWithSHA1AndRC2_40 to encrypt certificates, iteration count 50000.
  91  *
  92  * The default Mac algorithm is  HmacPBESHA1, iteration count 100000.
  93  *
  94  * Supported encryption of various implementations :
  95  *
  96  * Software and mode.     Certificate encryption  Private key encryption
  97  * ---------------------------------------------------------------------
  98  * MSIE4 (domestic            40 bit RC2.            40 bit RC2
  99  * and xport versions)
 100  * PKCS#12 export.
 101  *
 102  * MSIE4, 5 (domestic         40 bit RC2,            40 bit RC2,
 103  * and export versions)       3 key triple DES       3 key triple DES
 104  * PKCS#12 import.
 105  *
 106  * MSIE5                      40 bit RC2             3 key triple DES,
 107  * PKCS#12 export.                                   with SHA1 (168 bits)
 108  *
 109  * Netscape Communicator      40 bit RC2             3 key triple DES,
 110  * (domestic and export                              with SHA1 (168 bits)
 111  * versions) PKCS#12 export
 112  *
 113  * Netscape Communicator      40 bit ciphers only    All.
 114  * (export version)
 115  * PKCS#12 import.
 116  *
 117  * Netscape Communicator      All.                   All.
 118  * (domestic or fortified
 119  * version) PKCS#12 import.
 120  *
 121  * OpenSSL PKCS#12 code.      All.                   All.
 122  * ---------------------------------------------------------------------
 123  *
 124  * NOTE: PKCS12 KeyStore supports PrivateKeyEntry and TrustedCertficateEntry.
 125  * PKCS#12 is mainly used to deliver private keys with their associated
 126  * certificate chain and aliases. In a PKCS12 keystore, entries are
 127  * identified by the alias, and a localKeyId is required to match the
 128  * private key with the certificate. Trusted certificate entries are identified
 129  * by the presence of an trustedKeyUsage attribute.
 130  *
 131  * @author Seema Malkani
 132  * @author Jeff Nisewanger
 133  * @author Jan Luehe
 134  *
 135  * @see java.security.KeyStoreSpi
 136  */
 137 public final class PKCS12KeyStore extends KeyStoreSpi {
 138 
 139     // special PKCS12 keystore that supports PKCS12 and JKS file formats
 140     public static final class DualFormatPKCS12 extends KeyStoreDelegator {
 141         public DualFormatPKCS12() {
 142             super(&quot;PKCS12&quot;, PKCS12KeyStore.class, &quot;JKS&quot;, JKS.class);
 143         }
 144     }
 145 
 146     public static final int VERSION_3 = 3;
 147 
 148     private static final int MAX_ITERATION_COUNT = 5000000;
 149     private static final int SALT_LEN = 20;
 150 
 151     // friendlyName, localKeyId, trustedKeyUsage
 152     private static final String[] CORE_ATTRIBUTES = {
 153         &quot;1.2.840.113549.1.9.20&quot;,
 154         &quot;1.2.840.113549.1.9.21&quot;,
 155         &quot;2.16.840.1.113894.746875.1.1&quot;
 156     };
 157 
 158     private static final Debug debug = Debug.getInstance(&quot;pkcs12&quot;);
 159 
<a name="2" id="anc2"></a><span class="line-modified"> 160     private static final ObjectIdentifier PKCS8ShroudedKeyBag_OID =</span>
<span class="line-modified"> 161             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.10.1.2&quot;);</span>
<span class="line-modified"> 162     private static final ObjectIdentifier CertBag_OID =</span>
<span class="line-added"> 163             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.10.1.3&quot;);</span>
<span class="line-added"> 164     private static final ObjectIdentifier SecretBag_OID =</span>
<span class="line-added"> 165             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.10.1.5&quot;);</span>
<span class="line-added"> 166     private static final ObjectIdentifier PKCS9FriendlyName_OID =</span>
<span class="line-added"> 167             ObjectIdentifier.of(&quot;1.2.840.113549.1.9.20&quot;);</span>
<span class="line-added"> 168     private static final ObjectIdentifier PKCS9LocalKeyId_OID =</span>
<span class="line-added"> 169             ObjectIdentifier.of(&quot;1.2.840.113549.1.9.21&quot;);</span>
<span class="line-added"> 170     private static final ObjectIdentifier PKCS9CertType_OID =</span>
<span class="line-added"> 171             ObjectIdentifier.of(&quot;1.2.840.113549.1.9.22.1&quot;);</span>
<span class="line-added"> 172     private static final ObjectIdentifier pbes2_OID =</span>
<span class="line-added"> 173             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.13&quot;);</span>
 174 
<a name="3" id="anc3"></a>






 175     /*
<a name="4" id="anc4"></a><span class="line-modified"> 176      * Temporary Oracle OID</span>
<span class="line-modified"> 177      *</span>
<span class="line-added"> 178      * {joint-iso-itu-t(2) country(16) us(840) organization(1)</span>
<span class="line-added"> 179      *  oracle(113894) jdk(746875) crypto(1) id-at-trustedKeyUsage(1)}</span>
 180      */
<a name="5" id="anc5"></a><span class="line-modified"> 181     private static final ObjectIdentifier TrustedKeyUsage_OID =</span>
<span class="line-modified"> 182             ObjectIdentifier.of(&quot;2.16.840.1.113894.746875.1.1&quot;);</span>

 183 
<a name="6" id="anc6"></a><span class="line-modified"> 184     private static final ObjectIdentifier[] AnyUsage = new ObjectIdentifier[] {</span>
<span class="line-modified"> 185                 // AnyExtendedKeyUsage</span>
<span class="line-modified"> 186                 ObjectIdentifier.of(&quot;2.5.29.37.0&quot;)</span>
<span class="line-modified"> 187             };</span>





 188 
 189     private int counter = 0;
 190 
 191     // private key count
 192     // Note: This is a workaround to allow null localKeyID attribute
 193     // in pkcs12 with one private key entry and associated cert-chain
 194     private int privateKeyCount = 0;
 195 
 196     // secret key count
 197     private int secretKeyCount = 0;
 198 
 199     // certificate count
 200     private int certificateCount = 0;
 201 
 202     // Alg/params used for *this* keystore. Initialized as -1 for ic and
 203     // null for algorithm names. When an existing file is read, they will be
 204     // assigned inside engineLoad() so storing an existing keystore uses the
 205     // old alg/params. This makes sure if a keystore is created password-less
 206     // it will be password-less forever. Otherwise, engineStore() will read
 207     // the default values. These fields are always reset when load() is called.
 208     private String certProtectionAlgorithm = null;
 209     private int certPbeIterationCount = -1;
 210     private String macAlgorithm = null;
 211     private int macIterationCount = -1;
 212 
 213     // the source of randomness
 214     private SecureRandom random;
 215 
<a name="7" id="anc7"></a>
















 216     // A keystore entry and associated attributes
 217     private static class Entry {
 218         Date date; // the creation date of this entry
 219         String alias;
 220         byte[] keyId;
 221         Set&lt;KeyStore.Entry.Attribute&gt; attributes;
 222     }
 223 
 224     // A key entry
 225     private static class KeyEntry extends Entry {
 226     }
 227 
 228     // A private key entry and its supporting certificate chain
 229     private static class PrivateKeyEntry extends KeyEntry {
 230         byte[] protectedPrivKey;
 231         Certificate[] chain;
 232     };
 233 
 234     // A secret key
 235     private static class SecretKeyEntry extends KeyEntry {
 236         byte[] protectedSecretKey;
 237     };
 238 
 239     // A certificate entry
 240     private static class CertEntry extends Entry {
 241         final X509Certificate cert;
 242         ObjectIdentifier[] trustedKeyUsage;
 243 
 244         CertEntry(X509Certificate cert, byte[] keyId, String alias) {
 245             this(cert, keyId, alias, null, null);
 246         }
 247 
 248         CertEntry(X509Certificate cert, byte[] keyId, String alias,
 249                 ObjectIdentifier[] trustedKeyUsage,
 250                 Set&lt;? extends KeyStore.Entry.Attribute&gt; attributes) {
 251             this.date = new Date();
 252             this.cert = cert;
 253             this.keyId = keyId;
 254             this.alias = alias;
 255             this.trustedKeyUsage = trustedKeyUsage;
 256             this.attributes = new HashSet&lt;&gt;();
 257             if (attributes != null) {
 258                 this.attributes.addAll(attributes);
 259             }
 260         }
 261     }
 262 
 263     /**
 264      * Retries an action with password &quot;\0&quot; if &quot;&quot; fails.
 265      * @param &lt;T&gt; the return type
 266      */
 267     @FunctionalInterface
 268     private interface RetryWithZero&lt;T&gt; {
 269 
 270         T tryOnce(char[] password) throws Exception;
 271 
 272         static &lt;S&gt; S run(RetryWithZero&lt;S&gt; f, char[] password) throws Exception {
 273             try {
 274                 return f.tryOnce(password);
 275             } catch (Exception e) {
 276                 if (password.length == 0) {
 277                     // Retry using an empty password with a NUL terminator.
 278                     if (debug != null) {
 279                         debug.println(&quot;Retry with a NUL password&quot;);
 280                     }
 281                     return f.tryOnce(new char[1]);
 282                 }
 283                 throw e;
 284             }
 285         }
 286     }
 287 
 288     /**
 289      * Private keys and certificates are stored in a map.
 290      * Map entries are keyed by alias names.
 291      */
 292     private Map&lt;String, Entry&gt; entries =
 293         Collections.synchronizedMap(new LinkedHashMap&lt;String, Entry&gt;());
 294 
 295     private ArrayList&lt;KeyEntry&gt; keyList = new ArrayList&lt;KeyEntry&gt;();
 296     private List&lt;X509Certificate&gt; allCerts = new ArrayList&lt;&gt;();
 297     private ArrayList&lt;CertEntry&gt; certEntries = new ArrayList&lt;CertEntry&gt;();
 298 
 299     /**
 300      * Returns the key associated with the given alias, using the given
 301      * password to recover it.
 302      *
 303      * @param alias the alias name
 304      * @param password the password for recovering the key
 305      *
 306      * @return the requested key, or null if the given alias does not exist
 307      * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
 308      *
 309      * @exception NoSuchAlgorithmException if the algorithm for recovering the
 310      * key cannot be found
 311      * @exception UnrecoverableKeyException if the key cannot be recovered
 312      * (e.g., the given password is wrong).
 313      */
 314     public Key engineGetKey(String alias, char[] password)
 315         throws NoSuchAlgorithmException, UnrecoverableKeyException
 316     {
 317         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 318         Key key = null;
 319 
 320         if (entry == null || (!(entry instanceof KeyEntry))) {
 321             return null;
 322         }
 323 
 324         // get the encoded private key or secret key
 325         byte[] encrBytes = null;
 326         if (entry instanceof PrivateKeyEntry) {
 327             encrBytes = ((PrivateKeyEntry) entry).protectedPrivKey;
 328         } else if (entry instanceof SecretKeyEntry) {
 329             encrBytes = ((SecretKeyEntry) entry).protectedSecretKey;
 330         } else {
 331             throw new UnrecoverableKeyException(&quot;Error locating key&quot;);
 332         }
 333 
 334         byte[] encryptedKey;
 335         AlgorithmParameters algParams;
 336         ObjectIdentifier algOid;
 337 
 338         try {
 339             // get the encrypted private key
 340             EncryptedPrivateKeyInfo encrInfo =
 341                         new EncryptedPrivateKeyInfo(encrBytes);
 342             encryptedKey = encrInfo.getEncryptedData();
 343 
 344             // parse Algorithm parameters
 345             DerValue val = new DerValue(encrInfo.getAlgorithm().encode());
 346             DerInputStream in = val.toDerInputStream();
 347             algOid = in.getOID();
 348             algParams = parseAlgParameters(algOid, in);
 349 
 350         } catch (IOException ioe) {
 351             UnrecoverableKeyException uke =
 352                 new UnrecoverableKeyException(&quot;Private key not stored as &quot;
 353                                  + &quot;PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe);
 354             uke.initCause(ioe);
 355             throw uke;
 356         }
 357 
 358        try {
 359             PBEParameterSpec pbeSpec;
 360             int ic;
 361 
 362             if (algParams != null) {
 363                 try {
 364                     pbeSpec =
 365                         algParams.getParameterSpec(PBEParameterSpec.class);
 366                 } catch (InvalidParameterSpecException ipse) {
 367                     throw new IOException(&quot;Invalid PBE algorithm parameters&quot;);
 368                 }
 369                 ic = pbeSpec.getIterationCount();
 370 
 371                 if (ic &gt; MAX_ITERATION_COUNT) {
 372                     throw new IOException(&quot;key PBE iteration count too large&quot;);
 373                 }
 374             } else {
 375                 ic = 0;
 376             }
 377 
 378             key = RetryWithZero.run(pass -&gt; {
 379                 // Use JCE
 380                 SecretKey skey = getPBEKey(pass);
 381                 Cipher cipher = Cipher.getInstance(
 382                         mapPBEParamsToAlgorithm(algOid, algParams));
 383                 cipher.init(Cipher.DECRYPT_MODE, skey, algParams);
 384                 byte[] keyInfo = cipher.doFinal(encryptedKey);
 385                 /*
 386                  * Parse the key algorithm and then use a JCA key factory
 387                  * to re-create the key.
 388                  */
 389                 DerValue val = new DerValue(keyInfo);
 390                 DerInputStream in = val.toDerInputStream();
 391                 int i = in.getInteger();
 392                 DerValue[] value = in.getSequence(2);
 393                 AlgorithmId algId = new AlgorithmId(value[0].getOID());
 394                 String keyAlgo = algId.getName();
 395 
 396                 // decode private key
 397                 if (entry instanceof PrivateKeyEntry) {
 398                     KeyFactory kfac = KeyFactory.getInstance(keyAlgo);
 399                     PKCS8EncodedKeySpec kspec = new PKCS8EncodedKeySpec(keyInfo);
 400                     Key tmp = kfac.generatePrivate(kspec);
 401 
 402                     if (debug != null) {
 403                         debug.println(&quot;Retrieved a protected private key at alias&quot; +
 404                                 &quot; &#39;&quot; + alias + &quot;&#39; (&quot; +
 405                                 mapPBEParamsToAlgorithm(algOid, algParams) +
 406                                 &quot; iterations: &quot; + ic + &quot;)&quot;);
 407                     }
 408                     return tmp;
 409                     // decode secret key
 410                 } else {
 411                     byte[] keyBytes = in.getOctetString();
 412                     SecretKeySpec secretKeySpec =
 413                             new SecretKeySpec(keyBytes, keyAlgo);
 414 
 415                     // Special handling required for PBE: needs a PBEKeySpec
 416                     Key tmp;
 417                     if (keyAlgo.startsWith(&quot;PBE&quot;)) {
 418                         SecretKeyFactory sKeyFactory =
 419                                 SecretKeyFactory.getInstance(keyAlgo);
 420                         KeySpec pbeKeySpec =
 421                                 sKeyFactory.getKeySpec(secretKeySpec, PBEKeySpec.class);
 422                         tmp = sKeyFactory.generateSecret(pbeKeySpec);
 423                     } else {
 424                         tmp = secretKeySpec;
 425                     }
 426 
 427                     if (debug != null) {
 428                         debug.println(&quot;Retrieved a protected secret key at alias &quot; +
 429                                 &quot;&#39;&quot; + alias + &quot;&#39; (&quot; +
 430                                 mapPBEParamsToAlgorithm(algOid, algParams) +
 431                                 &quot; iterations: &quot; + ic + &quot;)&quot;);
 432                     }
 433                     return tmp;
 434                 }
 435             }, password);
 436 
 437         } catch (Exception e) {
 438             UnrecoverableKeyException uke =
 439                 new UnrecoverableKeyException(&quot;Get Key failed: &quot; +
 440                                         e.getMessage());
 441             uke.initCause(e);
 442             throw uke;
 443         }
 444         return key;
 445     }
 446 
 447     /**
 448      * Returns the certificate chain associated with the given alias.
 449      *
 450      * @param alias the alias name
 451      *
 452      * @return the certificate chain (ordered with the user&#39;s certificate first
 453      * and the root certificate authority last), or null if the given alias
 454      * does not exist or does not contain a certificate chain (i.e., the given
 455      * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
 456      * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
 457      */
 458     public Certificate[] engineGetCertificateChain(String alias) {
 459         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 460         if (entry != null &amp;&amp; entry instanceof PrivateKeyEntry) {
 461             if (((PrivateKeyEntry) entry).chain == null) {
 462                 return null;
 463             } else {
 464 
 465                 if (debug != null) {
 466                     debug.println(&quot;Retrieved a &quot; +
 467                         ((PrivateKeyEntry) entry).chain.length +
 468                         &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 469                 }
 470 
 471                 return ((PrivateKeyEntry) entry).chain.clone();
 472             }
 473         } else {
 474             return null;
 475         }
 476     }
 477 
 478     /**
 479      * Returns the certificate associated with the given alias.
 480      *
 481      * &lt;p&gt;If the given alias name identifies a
 482      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
 483      * entry is returned. If the given alias name identifies a
 484      * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
 485      * entry is returned, or null if that entry does not have a certificate
 486      * chain.
 487      *
 488      * @param alias the alias name
 489      *
 490      * @return the certificate, or null if the given alias does not exist or
 491      * does not contain a certificate.
 492      */
 493     public Certificate engineGetCertificate(String alias) {
 494         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 495         if (entry == null) {
 496             return null;
 497         }
 498         if (entry instanceof CertEntry &amp;&amp;
 499             ((CertEntry) entry).trustedKeyUsage != null) {
 500 
 501             if (debug != null) {
 502                 if (Arrays.equals(AnyUsage,
 503                     ((CertEntry) entry).trustedKeyUsage)) {
 504                     debug.println(&quot;Retrieved a certificate at alias &#39;&quot; + alias +
 505                         &quot;&#39; (trusted for any purpose)&quot;);
 506                 } else {
 507                     debug.println(&quot;Retrieved a certificate at alias &#39;&quot; + alias +
 508                         &quot;&#39; (trusted for limited purposes)&quot;);
 509                 }
 510             }
 511 
 512             return ((CertEntry) entry).cert;
 513 
 514         } else if (entry instanceof PrivateKeyEntry) {
 515             if (((PrivateKeyEntry) entry).chain == null) {
 516                 return null;
 517             } else {
 518 
 519                 if (debug != null) {
 520                     debug.println(&quot;Retrieved a certificate at alias &#39;&quot; + alias +
 521                         &quot;&#39;&quot;);
 522                 }
 523 
 524                 return ((PrivateKeyEntry) entry).chain[0];
 525             }
 526 
 527         } else {
 528             return null;
 529         }
 530     }
 531 
 532     /**
 533      * Returns the creation date of the entry identified by the given alias.
 534      *
 535      * @param alias the alias name
 536      *
 537      * @return the creation date of this entry, or null if the given alias does
 538      * not exist
 539      */
 540     public Date engineGetCreationDate(String alias) {
 541         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 542         if (entry != null) {
 543             return new Date(entry.date.getTime());
 544         } else {
 545             return null;
 546         }
 547     }
 548 
 549     /**
 550      * Assigns the given key to the given alias, protecting it with the given
 551      * password.
 552      *
 553      * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
 554      * it must be accompanied by a certificate chain certifying the
 555      * corresponding public key.
 556      *
 557      * &lt;p&gt;If the given alias already exists, the keystore information
 558      * associated with it is overridden by the given key (and possibly
 559      * certificate chain).
 560      *
 561      * @param alias the alias name
 562      * @param key the key to be associated with the alias
 563      * @param password the password to protect the key
 564      * @param chain the certificate chain for the corresponding public
 565      * key (only required if the given key is of type
 566      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
 567      *
 568      * @exception KeyStoreException if the given key cannot be protected, or
 569      * this operation fails for some other reason
 570      */
 571     public synchronized void engineSetKeyEntry(String alias, Key key,
 572                         char[] password, Certificate[] chain)
 573         throws KeyStoreException
 574     {
 575         KeyStore.PasswordProtection passwordProtection =
 576             new KeyStore.PasswordProtection(password);
 577 
 578         try {
 579             setKeyEntry(alias, key, passwordProtection, chain, null);
 580 
 581         } finally {
 582             try {
 583                 passwordProtection.destroy();
 584             } catch (DestroyFailedException dfe) {
 585                 // ignore
 586             }
 587         }
 588     }
 589 
 590     /*
 591      * Sets a key entry (with attributes, when present)
 592      */
 593     private void setKeyEntry(String alias, Key key,
 594         KeyStore.PasswordProtection passwordProtection, Certificate[] chain,
 595         Set&lt;KeyStore.Entry.Attribute&gt; attributes)
 596             throws KeyStoreException
 597     {
 598         try {
 599             Entry entry;
 600 
 601             if (key instanceof PrivateKey) {
 602                 // Check that all the certs are X.509 certs
 603                 checkX509Certs(chain);
 604 
 605                 PrivateKeyEntry keyEntry = new PrivateKeyEntry();
 606                 keyEntry.date = new Date();
 607 
 608                 if ((key.getFormat().equals(&quot;PKCS#8&quot;)) ||
 609                     (key.getFormat().equals(&quot;PKCS8&quot;))) {
 610 
 611                     if (debug != null) {
 612                         debug.println(
 613                             &quot;Setting a protected private key at alias &#39;&quot; +
 614                             alias + &quot;&#39;&quot;);
 615                         }
 616 
 617                     // Encrypt the private key
 618                     keyEntry.protectedPrivKey =
 619                         encryptPrivateKey(key.getEncoded(), passwordProtection);
 620                 } else {
 621                     throw new KeyStoreException(&quot;Private key is not encoded&quot; +
 622                                 &quot;as PKCS#8&quot;);
 623                 }
 624 
 625                 // clone the chain
 626                 if (chain != null) {
 627                     // validate cert-chain
 628                     if ((chain.length &gt; 1) &amp;&amp; (!validateChain(chain)))
 629                        throw new KeyStoreException(&quot;Certificate chain is &quot; +
 630                                                 &quot;not valid&quot;);
 631                     keyEntry.chain = chain.clone();
 632                     certificateCount += chain.length;
 633 
 634                     if (debug != null) {
 635                         debug.println(&quot;Setting a &quot; + chain.length +
 636                             &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 637                     }
 638                 }
 639                 privateKeyCount++;
 640                 entry = keyEntry;
 641 
 642             } else if (key instanceof SecretKey) {
 643                 SecretKeyEntry keyEntry = new SecretKeyEntry();
 644                 keyEntry.date = new Date();
 645 
 646                 // Encode secret key in a PKCS#8
 647                 DerOutputStream pkcs8 = new DerOutputStream();
 648                 DerOutputStream secretKeyInfo = new DerOutputStream();
 649                 secretKeyInfo.putInteger(0);
 650                 AlgorithmId algId = AlgorithmId.get(key.getAlgorithm());
 651                 algId.encode(secretKeyInfo);
 652                 secretKeyInfo.putOctetString(key.getEncoded());
 653                 pkcs8.write(DerValue.tag_Sequence, secretKeyInfo);
 654 
 655                 // Encrypt the secret key (using same PBE as for private keys)
 656                 keyEntry.protectedSecretKey =
 657                     encryptPrivateKey(pkcs8.toByteArray(), passwordProtection);
 658 
 659                 if (debug != null) {
 660                     debug.println(&quot;Setting a protected secret key at alias &#39;&quot; +
 661                         alias + &quot;&#39;&quot;);
 662                 }
 663                 secretKeyCount++;
 664                 entry = keyEntry;
 665 
 666             } else {
 667                 throw new KeyStoreException(&quot;Unsupported Key type&quot;);
 668             }
 669 
 670             entry.attributes = new HashSet&lt;&gt;();
 671             if (attributes != null) {
 672                 entry.attributes.addAll(attributes);
 673             }
 674             // set the keyId to current date
 675             entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(UTF_8);
 676             // set the alias
 677             entry.alias = alias.toLowerCase(Locale.ENGLISH);
 678             // add the entry
 679             entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
 680 
 681         } catch (KeyStoreException kse) {
 682             throw kse;
 683         } catch (Exception nsae) {
 684             throw new KeyStoreException(&quot;Key protection&quot; +
 685                        &quot; algorithm not found: &quot; + nsae, nsae);
 686         }
 687     }
 688 
 689     /**
 690      * Assigns the given key (that has already been protected) to the given
 691      * alias.
 692      *
 693      * &lt;p&gt;If the protected key is of type
 694      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
 695      * certificate chain certifying the corresponding public key. If the
 696      * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
 697      * &lt;code&gt;key&lt;/code&gt; must be encoded as an
 698      * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
 699      *
 700      * &lt;p&gt;If the given alias already exists, the keystore information
 701      * associated with it is overridden by the given key (and possibly
 702      * certificate chain).
 703      *
 704      * @param alias the alias name
 705      * @param key the key (in protected format) to be associated with the alias
 706      * @param chain the certificate chain for the corresponding public
 707      * key (only useful if the protected key is of type
 708      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
 709      *
 710      * @exception KeyStoreException if this operation fails.
 711      */
 712     public synchronized void engineSetKeyEntry(String alias, byte[] key,
 713                                   Certificate[] chain)
 714         throws KeyStoreException
 715     {
 716         // Check that all the certs are X.509 certs
 717         checkX509Certs(chain);
 718 
 719         // Private key must be encoded as EncryptedPrivateKeyInfo
 720         // as defined in PKCS#8
 721         try {
 722             new EncryptedPrivateKeyInfo(key);
 723         } catch (IOException ioe) {
 724             throw new KeyStoreException(&quot;Private key is not stored&quot;
 725                     + &quot; as PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe, ioe);
 726         }
 727 
 728         PrivateKeyEntry entry = new PrivateKeyEntry();
 729         entry.date = new Date();
 730 
 731         if (debug != null) {
 732             debug.println(&quot;Setting a protected private key at alias &#39;&quot; +
 733                 alias + &quot;&#39;&quot;);
 734         }
 735 
 736         // set the keyId to current date
 737         entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(UTF_8);
 738         // set the alias
 739         entry.alias = alias.toLowerCase(Locale.ENGLISH);
 740 
 741         entry.protectedPrivKey = key.clone();
 742         if (chain != null) {
 743             // validate cert-chain
 744             if ((chain.length &gt; 1) &amp;&amp; (!validateChain(chain))) {
 745                 throw new KeyStoreException(&quot;Certificate chain is &quot;
 746                         + &quot;not valid&quot;);
 747             }
 748             entry.chain = chain.clone();
 749             certificateCount += chain.length;
 750 
 751             if (debug != null) {
 752                 debug.println(&quot;Setting a &quot; + entry.chain.length +
 753                     &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 754             }
 755         }
 756 
 757         // add the entry
 758         privateKeyCount++;
 759         entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
 760     }
 761 
 762 
 763     /*
 764      * Generate random salt
 765      */
 766     private byte[] getSalt()
 767     {
 768         // Generate a random salt.
 769         byte[] salt = new byte[SALT_LEN];
 770         if (random == null) {
 771            random = new SecureRandom();
 772         }
 773         random.nextBytes(salt);
 774         return salt;
 775     }
 776 
 777     /*
 778      * Generate PBE Algorithm Parameters
 779      */
 780     private AlgorithmParameters getPBEAlgorithmParameters(
 781             String algorithm, int iterationCount) throws IOException {
 782         AlgorithmParameters algParams = null;
 783 
 784         // create PBE parameters from salt and iteration count
 785         PBEParameterSpec paramSpec =
 786                 new PBEParameterSpec(getSalt(), iterationCount);
 787         try {
 788            algParams = AlgorithmParameters.getInstance(algorithm);
 789            algParams.init(paramSpec);
 790         } catch (Exception e) {
 791            throw new IOException(&quot;getPBEAlgorithmParameters failed: &quot; +
 792                                  e.getMessage(), e);
 793         }
 794         return algParams;
 795     }
 796 
 797     /*
 798      * parse Algorithm Parameters
 799      */
 800     private AlgorithmParameters parseAlgParameters(ObjectIdentifier algorithm,
 801         DerInputStream in) throws IOException
 802     {
 803         AlgorithmParameters algParams = null;
 804         try {
 805             DerValue params;
 806             if (in.available() == 0) {
 807                 params = null;
 808             } else {
 809                 params = in.getDerValue();
 810                 if (params.tag == DerValue.tag_Null) {
 811                    params = null;
 812                 }
 813             }
 814             if (params != null) {
 815                 if (algorithm.equals(pbes2_OID)) {
 816                     algParams = AlgorithmParameters.getInstance(&quot;PBES2&quot;);
 817                 } else {
 818                     algParams = AlgorithmParameters.getInstance(&quot;PBE&quot;);
 819                 }
 820                 algParams.init(params.toByteArray());
 821             }
 822         } catch (Exception e) {
 823            throw new IOException(&quot;parseAlgParameters failed: &quot; +
 824                                  e.getMessage(), e);
 825         }
 826         return algParams;
 827     }
 828 
 829     /*
 830      * Generate PBE key
 831      */
 832     private SecretKey getPBEKey(char[] password) throws IOException
 833     {
 834         SecretKey skey = null;
 835 
 836         try {
 837             PBEKeySpec keySpec = new PBEKeySpec(password);
 838             SecretKeyFactory skFac = SecretKeyFactory.getInstance(&quot;PBE&quot;);
 839             skey = skFac.generateSecret(keySpec);
 840             keySpec.clearPassword();
 841         } catch (Exception e) {
 842            throw new IOException(&quot;getSecretKey failed: &quot; +
 843                                  e.getMessage(), e);
 844         }
 845         return skey;
 846     }
 847 
 848     /*
 849      * Encrypt private key or secret key using Password-based encryption (PBE)
 850      * as defined in PKCS#5.
 851      *
 852      * NOTE: By default, pbeWithSHAAnd3-KeyTripleDES-CBC algorithmID is
 853      *       used to derive the key and IV.
 854      *
 855      * @return encrypted private key or secret key encoded as
 856      *         EncryptedPrivateKeyInfo
 857      */
 858     private byte[] encryptPrivateKey(byte[] data,
 859         KeyStore.PasswordProtection passwordProtection)
 860         throws IOException, NoSuchAlgorithmException, UnrecoverableKeyException
 861     {
 862         byte[] key = null;
 863 
 864         try {
 865             String algorithm;
 866             AlgorithmParameters algParams;
 867             AlgorithmId algid;
 868 
 869             // Initialize PBE algorithm and parameters
 870             algorithm = passwordProtection.getProtectionAlgorithm();
 871             if (algorithm != null) {
 872                 AlgorithmParameterSpec algParamSpec =
 873                     passwordProtection.getProtectionParameters();
 874                 if (algParamSpec != null) {
 875                     algParams = AlgorithmParameters.getInstance(algorithm);
 876                     algParams.init(algParamSpec);
 877                 } else {
 878                     algParams = getPBEAlgorithmParameters(algorithm,
 879                             defaultKeyPbeIterationCount());
 880                 }
 881             } else {
 882                 // Check default key protection algorithm for PKCS12 keystores
 883                 algorithm = defaultKeyProtectionAlgorithm();
 884                 algParams = getPBEAlgorithmParameters(algorithm,
 885                         defaultKeyPbeIterationCount());
 886             }
 887 
 888             ObjectIdentifier pbeOID = mapPBEAlgorithmToOID(algorithm);
 889             if (pbeOID == null) {
 890                     throw new IOException(&quot;PBE algorithm &#39;&quot; + algorithm +
 891                         &quot; &#39;is not supported for key entry protection&quot;);
 892             }
 893 
 894             // Use JCE
 895             SecretKey skey = getPBEKey(passwordProtection.getPassword());
 896             Cipher cipher = Cipher.getInstance(algorithm);
 897             cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);
 898             byte[] encryptedKey = cipher.doFinal(data);
 899             algid = new AlgorithmId(pbeOID, cipher.getParameters());
 900 
 901             if (debug != null) {
 902                 debug.println(&quot;  (Cipher algorithm: &quot; + cipher.getAlgorithm() +
 903                     &quot;)&quot;);
 904             }
 905 
 906             // wrap encrypted private key in EncryptedPrivateKeyInfo
 907             // as defined in PKCS#8
 908             EncryptedPrivateKeyInfo encrInfo =
 909                 new EncryptedPrivateKeyInfo(algid, encryptedKey);
 910             key = encrInfo.getEncoded();
 911         } catch (Exception e) {
 912             UnrecoverableKeyException uke =
 913                 new UnrecoverableKeyException(&quot;Encrypt Private Key failed: &quot;
 914                                                 + e.getMessage());
 915             uke.initCause(e);
 916             throw uke;
 917         }
 918 
 919         return key;
 920     }
 921 
 922     /*
 923      * Map a PBE algorithm name onto its object identifier
 924      */
 925     private static ObjectIdentifier mapPBEAlgorithmToOID(String algorithm)
 926         throws NoSuchAlgorithmException {
 927         // Check for PBES2 algorithms
 928         if (algorithm.toLowerCase(Locale.ENGLISH).startsWith(&quot;pbewithhmacsha&quot;)) {
 929             return pbes2_OID;
 930         }
 931         return AlgorithmId.get(algorithm).getOID();
 932     }
 933 
 934     /*
 935      * Map a PBE algorithm parameters onto its algorithm name
 936      */
 937     private static String mapPBEParamsToAlgorithm(ObjectIdentifier algorithm,
 938         AlgorithmParameters algParams) throws NoSuchAlgorithmException {
 939         // Check for PBES2 algorithms
 940         if (algorithm.equals(pbes2_OID) &amp;&amp; algParams != null) {
 941             return algParams.toString();
 942         }
 943         return new AlgorithmId(algorithm).getName();
 944     }
 945 
 946     /**
 947      * Assigns the given certificate to the given alias.
 948      *
 949      * &lt;p&gt;If the given alias already exists in this keystore and identifies a
 950      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
 951      * overridden by the given certificate.
 952      *
 953      * @param alias the alias name
 954      * @param cert the certificate
 955      *
 956      * @exception KeyStoreException if the given alias already exists and does
 957      * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation fails
 958      * for some other reason.
 959      */
 960     public synchronized void engineSetCertificateEntry(String alias,
 961         Certificate cert) throws KeyStoreException
 962     {
 963         setCertEntry(alias, cert, null);
 964     }
 965 
 966     /*
 967      * Sets a trusted cert entry (with attributes, when present)
 968      */
 969     private void setCertEntry(String alias, Certificate cert,
 970         Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws KeyStoreException {
 971 
 972         // Check that the cert is an X.509 cert
 973         if (cert != null &amp;&amp; (!(cert instanceof X509Certificate))) {
 974             throw new KeyStoreException(
 975                 &quot;Only X.509 certificates are supported - rejecting class: &quot; +
 976                 cert.getClass().getName());
 977         }
 978 
 979         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 980         if (entry != null &amp;&amp; entry instanceof KeyEntry) {
 981             throw new KeyStoreException(&quot;Cannot overwrite own certificate&quot;);
 982         }
 983 
 984         CertEntry certEntry =
 985             new CertEntry((X509Certificate) cert, null, alias, AnyUsage,
 986                 attributes);
 987         certificateCount++;
 988         entries.put(alias.toLowerCase(Locale.ENGLISH), certEntry);
 989 
 990         if (debug != null) {
 991             debug.println(&quot;Setting a trusted certificate at alias &#39;&quot; + alias +
 992                 &quot;&#39;&quot;);
 993         }
 994     }
 995 
 996     /**
 997      * Deletes the entry identified by the given alias from this keystore.
 998      *
 999      * @param alias the alias name
1000      *
1001      * @exception KeyStoreException if the entry cannot be removed.
1002      */
1003     public synchronized void engineDeleteEntry(String alias)
1004         throws KeyStoreException
1005     {
1006         if (debug != null) {
1007             debug.println(&quot;Removing entry at alias &#39;&quot; + alias + &quot;&#39;&quot;);
1008         }
1009 
1010         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1011         if (entry instanceof PrivateKeyEntry) {
1012             PrivateKeyEntry keyEntry = (PrivateKeyEntry) entry;
1013             if (keyEntry.chain != null) {
1014                 certificateCount -= keyEntry.chain.length;
1015             }
1016             privateKeyCount--;
1017         } else if (entry instanceof CertEntry) {
1018             certificateCount--;
1019         } else if (entry instanceof SecretKeyEntry) {
1020             secretKeyCount--;
1021         }
1022         entries.remove(alias.toLowerCase(Locale.ENGLISH));
1023     }
1024 
1025     /**
1026      * Lists all the alias names of this keystore.
1027      *
1028      * @return enumeration of the alias names
1029      */
1030     public Enumeration&lt;String&gt; engineAliases() {
1031         return Collections.enumeration(entries.keySet());
1032     }
1033 
1034     /**
1035      * Checks if the given alias exists in this keystore.
1036      *
1037      * @param alias the alias name
1038      *
1039      * @return true if the alias exists, false otherwise
1040      */
1041     public boolean engineContainsAlias(String alias) {
1042         return entries.containsKey(alias.toLowerCase(Locale.ENGLISH));
1043     }
1044 
1045     /**
1046      * Retrieves the number of entries in this keystore.
1047      *
1048      * @return the number of entries in this keystore
1049      */
1050     public int engineSize() {
1051         return entries.size();
1052     }
1053 
1054     /**
1055      * Returns true if the entry identified by the given alias is a
1056      * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
1057      *
1058      * @return true if the entry identified by the given alias is a
1059      * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
1060      */
1061     public boolean engineIsKeyEntry(String alias) {
1062         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1063         if (entry != null &amp;&amp; entry instanceof KeyEntry) {
1064             return true;
1065         } else {
1066             return false;
1067         }
1068     }
1069 
1070     /**
1071      * Returns true if the entry identified by the given alias is a
1072      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
1073      *
1074      * @return true if the entry identified by the given alias is a
1075      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
1076      */
1077     public boolean engineIsCertificateEntry(String alias) {
1078         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1079         if (entry != null &amp;&amp; entry instanceof CertEntry &amp;&amp;
1080             ((CertEntry) entry).trustedKeyUsage != null) {
1081             return true;
1082         } else {
1083             return false;
1084         }
1085     }
1086 
1087     /**
1088      * Determines if the keystore {@code Entry} for the specified
1089      * {@code alias} is an instance or subclass of the specified
1090      * {@code entryClass}.
1091      *
1092      * @param alias the alias name
1093      * @param entryClass the entry class
1094      *
1095      * @return true if the keystore {@code Entry} for the specified
1096      *          {@code alias} is an instance or subclass of the
1097      *          specified {@code entryClass}, false otherwise
1098      *
1099      * @since 1.5
1100      */
1101     @Override
1102     public boolean
1103         engineEntryInstanceOf(String alias,
1104                               Class&lt;? extends KeyStore.Entry&gt; entryClass)
1105     {
1106         if (entryClass == KeyStore.TrustedCertificateEntry.class) {
1107             return engineIsCertificateEntry(alias);
1108         }
1109 
1110         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1111         if (entryClass == KeyStore.PrivateKeyEntry.class) {
1112             return (entry != null &amp;&amp; entry instanceof PrivateKeyEntry);
1113         }
1114         if (entryClass == KeyStore.SecretKeyEntry.class) {
1115             return (entry != null &amp;&amp; entry instanceof SecretKeyEntry);
1116         }
1117         return false;
1118     }
1119 
1120     /**
1121      * Returns the (alias) name of the first keystore entry whose certificate
1122      * matches the given certificate.
1123      *
1124      * &lt;p&gt;This method attempts to match the given certificate with each
1125      * keystore entry. If the entry being considered
1126      * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
1127      * compared to that entry&#39;s certificate. If the entry being considered is
1128      * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
1129      * element of that entry&#39;s certificate chain (if a chain exists).
1130      *
1131      * @param cert the certificate to match with.
1132      *
1133      * @return the (alias) name of the first entry with matching certificate,
1134      * or null if no such entry exists in this keystore.
1135      */
1136     public String engineGetCertificateAlias(Certificate cert) {
1137         Certificate certElem = null;
1138 
1139         for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {
1140             String alias = e.nextElement();
1141             Entry entry = entries.get(alias);
1142             if (entry instanceof PrivateKeyEntry) {
1143                 if (((PrivateKeyEntry) entry).chain != null) {
1144                     certElem = ((PrivateKeyEntry) entry).chain[0];
1145                 }
1146             } else if (entry instanceof CertEntry &amp;&amp;
1147                     ((CertEntry) entry).trustedKeyUsage != null) {
1148                 certElem = ((CertEntry) entry).cert;
1149             } else {
1150                 continue;
1151             }
1152             if (certElem != null &amp;&amp; certElem.equals(cert)) {
1153                 return alias;
1154             }
1155         }
1156         return null;
1157     }
1158 
1159     /**
1160      * Stores this keystore to the given output stream, and protects its
1161      * integrity with the given password.
1162      *
1163      * @param stream the output stream to which this keystore is written.
1164      * @param password the password to generate the keystore integrity check
1165      *
1166      * @exception IOException if there was an I/O problem with data
1167      * @exception NoSuchAlgorithmException if the appropriate data integrity
1168      * algorithm could not be found
1169      * @exception CertificateException if any of the certificates included in
1170      * the keystore data could not be stored
1171      */
1172     public synchronized void engineStore(OutputStream stream, char[] password)
1173         throws IOException, NoSuchAlgorithmException, CertificateException
1174     {
1175 
1176         // -- Create PFX
1177         DerOutputStream pfx = new DerOutputStream();
1178 
1179         // PFX version (always write the latest version)
1180         DerOutputStream version = new DerOutputStream();
1181         version.putInteger(VERSION_3);
1182         byte[] pfxVersion = version.toByteArray();
1183         pfx.write(pfxVersion);
1184 
1185         // -- Create AuthSafe
1186         DerOutputStream authSafe = new DerOutputStream();
1187 
1188         // -- Create ContentInfos
1189         DerOutputStream authSafeContentInfo = new DerOutputStream();
1190 
1191         // -- create safeContent Data ContentInfo
1192         if (privateKeyCount &gt; 0 || secretKeyCount &gt; 0) {
1193 
1194             if (debug != null) {
1195                 debug.println(&quot;Storing &quot; + (privateKeyCount + secretKeyCount) +
1196                     &quot; protected key(s) in a PKCS#7 data&quot;);
1197             }
1198 
1199             byte[] safeContentData = createSafeContent();
1200             ContentInfo dataContentInfo = new ContentInfo(safeContentData);
1201             dataContentInfo.encode(authSafeContentInfo);
1202         }
1203 
1204         // -- create EncryptedContentInfo
1205         if (certificateCount &gt; 0) {
1206 
1207             if (certProtectionAlgorithm == null) {
1208                 certProtectionAlgorithm = defaultCertProtectionAlgorithm();
1209             }
1210             if (certPbeIterationCount &lt; 0) {
1211                 certPbeIterationCount = defaultCertPbeIterationCount();
1212             }
1213 
1214             if (debug != null) {
1215                 debug.println(&quot;Storing &quot; + certificateCount +
1216                     &quot; certificate(s) in a PKCS#7 encryptedData&quot;);
1217             }
1218 
1219             byte[] encrData = createEncryptedData(password);
1220             if (!certProtectionAlgorithm.equalsIgnoreCase(&quot;NONE&quot;)) {
1221                 ContentInfo encrContentInfo =
1222                         new ContentInfo(ContentInfo.ENCRYPTED_DATA_OID,
1223                                 new DerValue(encrData));
1224                 encrContentInfo.encode(authSafeContentInfo);
1225             } else {
1226                 ContentInfo dataContentInfo = new ContentInfo(encrData);
1227                 dataContentInfo.encode(authSafeContentInfo);
1228             }
1229         }
1230 
1231         // wrap as SequenceOf ContentInfos
1232         DerOutputStream cInfo = new DerOutputStream();
1233         cInfo.write(DerValue.tag_SequenceOf, authSafeContentInfo);
1234         byte[] authenticatedSafe = cInfo.toByteArray();
1235 
1236         // Create Encapsulated ContentInfo
1237         ContentInfo contentInfo = new ContentInfo(authenticatedSafe);
1238         contentInfo.encode(authSafe);
1239         byte[] authSafeData = authSafe.toByteArray();
1240         pfx.write(authSafeData);
1241 
1242         // -- MAC
1243         if (macAlgorithm == null) {
1244             macAlgorithm = defaultMacAlgorithm();
1245         }
1246         if (macIterationCount &lt; 0) {
1247             macIterationCount = defaultMacIterationCount();
1248         }
1249         if (!macAlgorithm.equalsIgnoreCase(&quot;NONE&quot;)) {
1250             byte[] macData = calculateMac(password, authenticatedSafe);
1251             pfx.write(macData);
1252         }
1253         // write PFX to output stream
1254         DerOutputStream pfxout = new DerOutputStream();
1255         pfxout.write(DerValue.tag_Sequence, pfx);
1256         byte[] pfxData = pfxout.toByteArray();
1257         stream.write(pfxData);
1258         stream.flush();
1259     }
1260 
1261     /**
1262      * Gets a &lt;code&gt;KeyStore.Entry&lt;/code&gt; for the specified alias
1263      * with the specified protection parameter.
1264      *
1265      * @param alias get the &lt;code&gt;KeyStore.Entry&lt;/code&gt; for this alias
1266      * @param protParam the &lt;code&gt;ProtectionParameter&lt;/code&gt;
1267      *          used to protect the &lt;code&gt;Entry&lt;/code&gt;,
1268      *          which may be &lt;code&gt;null&lt;/code&gt;
1269      *
1270      * @return the &lt;code&gt;KeyStore.Entry&lt;/code&gt; for the specified alias,
1271      *          or &lt;code&gt;null&lt;/code&gt; if there is no such entry
1272      *
1273      * @exception KeyStoreException if the operation failed
1274      * @exception NoSuchAlgorithmException if the algorithm for recovering the
1275      *          entry cannot be found
1276      * @exception UnrecoverableEntryException if the specified
1277      *          &lt;code&gt;protParam&lt;/code&gt; were insufficient or invalid
1278      * @exception UnrecoverableKeyException if the entry is a
1279      *          &lt;code&gt;PrivateKeyEntry&lt;/code&gt; or &lt;code&gt;SecretKeyEntry&lt;/code&gt;
1280      *          and the specified &lt;code&gt;protParam&lt;/code&gt; does not contain
1281      *          the information needed to recover the key (e.g. wrong password)
1282      *
1283      * @since 1.5
1284      */
1285     @Override
1286     public KeyStore.Entry engineGetEntry(String alias,
1287                         KeyStore.ProtectionParameter protParam)
1288                 throws KeyStoreException, NoSuchAlgorithmException,
1289                 UnrecoverableEntryException {
1290 
1291         if (!engineContainsAlias(alias)) {
1292             return null;
1293         }
1294 
1295         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1296         if (protParam == null) {
1297             if (engineIsCertificateEntry(alias)) {
1298                 if (entry instanceof CertEntry &amp;&amp;
1299                     ((CertEntry) entry).trustedKeyUsage != null) {
1300 
1301                     if (debug != null) {
1302                         debug.println(&quot;Retrieved a trusted certificate at &quot; +
1303                             &quot;alias &#39;&quot; + alias + &quot;&#39;&quot;);
1304                     }
1305 
1306                     return new KeyStore.TrustedCertificateEntry(
1307                         ((CertEntry)entry).cert, getAttributes(entry));
1308                 }
1309             } else {
1310                 throw new UnrecoverableKeyException
1311                         (&quot;requested entry requires a password&quot;);
1312             }
1313         }
1314 
1315         if (protParam instanceof KeyStore.PasswordProtection) {
1316             if (engineIsCertificateEntry(alias)) {
1317                 throw new UnsupportedOperationException
1318                     (&quot;trusted certificate entries are not password-protected&quot;);
1319             } else if (engineIsKeyEntry(alias)) {
1320                 KeyStore.PasswordProtection pp =
1321                         (KeyStore.PasswordProtection)protParam;
1322                 char[] password = pp.getPassword();
1323 
1324                 Key key = engineGetKey(alias, password);
1325                 if (key instanceof PrivateKey) {
1326                     Certificate[] chain = engineGetCertificateChain(alias);
1327 
1328                     return new KeyStore.PrivateKeyEntry((PrivateKey)key, chain,
1329                         getAttributes(entry));
1330 
1331                 } else if (key instanceof SecretKey) {
1332 
1333                     return new KeyStore.SecretKeyEntry((SecretKey)key,
1334                         getAttributes(entry));
1335                 }
1336             } else if (!engineIsKeyEntry(alias)) {
1337                 throw new UnsupportedOperationException
1338                     (&quot;untrusted certificate entries are not &quot; +
1339                         &quot;password-protected&quot;);
1340             }
1341         }
1342 
1343         throw new UnsupportedOperationException();
1344     }
1345 
1346     /**
1347      * Saves a &lt;code&gt;KeyStore.Entry&lt;/code&gt; under the specified alias.
1348      * The specified protection parameter is used to protect the
1349      * &lt;code&gt;Entry&lt;/code&gt;.
1350      *
1351      * &lt;p&gt; If an entry already exists for the specified alias,
1352      * it is overridden.
1353      *
1354      * @param alias save the &lt;code&gt;KeyStore.Entry&lt;/code&gt; under this alias
1355      * @param entry the &lt;code&gt;Entry&lt;/code&gt; to save
1356      * @param protParam the &lt;code&gt;ProtectionParameter&lt;/code&gt;
1357      *          used to protect the &lt;code&gt;Entry&lt;/code&gt;,
1358      *          which may be &lt;code&gt;null&lt;/code&gt;
1359      *
1360      * @exception KeyStoreException if this operation fails
1361      *
1362      * @since 1.5
1363      */
1364     @Override
1365     public synchronized void engineSetEntry(String alias, KeyStore.Entry entry,
1366         KeyStore.ProtectionParameter protParam) throws KeyStoreException {
1367 
1368         // get password
1369         if (protParam != null &amp;&amp;
1370             !(protParam instanceof KeyStore.PasswordProtection)) {
1371             throw new KeyStoreException(&quot;unsupported protection parameter&quot;);
1372         }
1373         KeyStore.PasswordProtection pProtect = null;
1374         if (protParam != null) {
1375             pProtect = (KeyStore.PasswordProtection)protParam;
1376         }
1377 
1378         // set entry
1379         if (entry instanceof KeyStore.TrustedCertificateEntry) {
1380             if (protParam != null &amp;&amp; pProtect.getPassword() != null) {
1381                 // pre-1.5 style setCertificateEntry did not allow password
1382                 throw new KeyStoreException
1383                     (&quot;trusted certificate entries are not password-protected&quot;);
1384             } else {
1385                 KeyStore.TrustedCertificateEntry tce =
1386                         (KeyStore.TrustedCertificateEntry)entry;
1387                 setCertEntry(alias, tce.getTrustedCertificate(),
1388                     tce.getAttributes());
1389 
1390                 return;
1391             }
1392         } else if (entry instanceof KeyStore.PrivateKeyEntry) {
1393             if (pProtect == null || pProtect.getPassword() == null) {
1394                 // pre-1.5 style setKeyEntry required password
1395                 throw new KeyStoreException
1396                     (&quot;non-null password required to create PrivateKeyEntry&quot;);
1397             } else {
1398                 KeyStore.PrivateKeyEntry pke = (KeyStore.PrivateKeyEntry)entry;
1399                 setKeyEntry(alias, pke.getPrivateKey(), pProtect,
1400                     pke.getCertificateChain(), pke.getAttributes());
1401 
1402                 return;
1403             }
1404         } else if (entry instanceof KeyStore.SecretKeyEntry) {
1405             if (pProtect == null || pProtect.getPassword() == null) {
1406                 // pre-1.5 style setKeyEntry required password
1407                 throw new KeyStoreException
1408                     (&quot;non-null password required to create SecretKeyEntry&quot;);
1409             } else {
1410                 KeyStore.SecretKeyEntry ske = (KeyStore.SecretKeyEntry)entry;
1411                 setKeyEntry(alias, ske.getSecretKey(), pProtect,
1412                     (Certificate[])null, ske.getAttributes());
1413 
1414                 return;
1415             }
1416         }
1417 
1418         throw new KeyStoreException
1419                 (&quot;unsupported entry type: &quot; + entry.getClass().getName());
1420     }
1421 
1422     /*
1423      * Assemble the entry attributes
1424      */
1425     private Set&lt;KeyStore.Entry.Attribute&gt; getAttributes(Entry entry) {
1426 
1427         if (entry.attributes == null) {
1428             entry.attributes = new HashSet&lt;&gt;();
1429         }
1430 
1431         // friendlyName
1432         entry.attributes.add(new PKCS12Attribute(
1433             PKCS9FriendlyName_OID.toString(), entry.alias));
1434 
1435         // localKeyID
1436         byte[] keyIdValue = entry.keyId;
1437         if (keyIdValue != null) {
1438             entry.attributes.add(new PKCS12Attribute(
1439                 PKCS9LocalKeyId_OID.toString(), Debug.toString(keyIdValue)));
1440         }
1441 
1442         // trustedKeyUsage
1443         if (entry instanceof CertEntry) {
1444             ObjectIdentifier[] trustedKeyUsageValue =
1445                 ((CertEntry) entry).trustedKeyUsage;
1446             if (trustedKeyUsageValue != null) {
1447                 if (trustedKeyUsageValue.length == 1) { // omit brackets
1448                     entry.attributes.add(new PKCS12Attribute(
1449                         TrustedKeyUsage_OID.toString(),
1450                         trustedKeyUsageValue[0].toString()));
1451                 } else { // multi-valued
1452                     entry.attributes.add(new PKCS12Attribute(
1453                         TrustedKeyUsage_OID.toString(),
1454                         Arrays.toString(trustedKeyUsageValue)));
1455                 }
1456             }
1457         }
1458 
1459         return entry.attributes;
1460     }
1461 
1462     /*
1463      * Calculate MAC using HMAC algorithm (required for password integrity)
1464      *
1465      * Hash-based MAC algorithm combines secret key with message digest to
1466      * create a message authentication code (MAC)
1467      */
1468     private byte[] calculateMac(char[] passwd, byte[] data)
1469         throws IOException
1470     {
1471         byte[] mData = null;
1472         String algName = macAlgorithm.substring(7);
1473 
1474         try {
1475             // Generate a random salt.
1476             byte[] salt = getSalt();
1477 
1478             // generate MAC (MAC key is generated within JCE)
1479             Mac m = Mac.getInstance(macAlgorithm);
1480             PBEParameterSpec params =
1481                         new PBEParameterSpec(salt, macIterationCount);
1482             SecretKey key = getPBEKey(passwd);
1483             m.init(key, params);
1484             m.update(data);
1485             byte[] macResult = m.doFinal();
1486 
1487             // encode as MacData
1488             MacData macData = new MacData(algName, macResult, salt,
1489                     macIterationCount);
1490             DerOutputStream bytes = new DerOutputStream();
1491             bytes.write(macData.getEncoded());
1492             mData = bytes.toByteArray();
1493         } catch (Exception e) {
1494             throw new IOException(&quot;calculateMac failed: &quot; + e, e);
1495         }
1496         return mData;
1497     }
1498 
1499 
1500     /*
1501      * Validate Certificate Chain
1502      */
1503     private boolean validateChain(Certificate[] certChain)
1504     {
1505         for (int i = 0; i &lt; certChain.length-1; i++) {
1506             X500Principal issuerDN =
1507                 ((X509Certificate)certChain[i]).getIssuerX500Principal();
1508             X500Principal subjectDN =
1509                 ((X509Certificate)certChain[i+1]).getSubjectX500Principal();
1510             if (!(issuerDN.equals(subjectDN)))
1511                 return false;
1512         }
1513 
1514         // Check for loops in the chain. If there are repeated certs,
1515         // the Set of certs in the chain will contain fewer certs than
1516         // the chain
1517         Set&lt;Certificate&gt; set = new HashSet&lt;&gt;(Arrays.asList(certChain));
1518         return set.size() == certChain.length;
1519     }
1520 
1521     /*
1522      * Check that all the certificates are X.509 certificates
1523      */
1524     private static void checkX509Certs(Certificate[] certs)
1525             throws KeyStoreException {
1526         if (certs != null) {
1527             for (Certificate cert : certs) {
1528                 if (!(cert instanceof X509Certificate)) {
1529                     throw new KeyStoreException(
1530                         &quot;Only X.509 certificates are supported - &quot; +
1531                         &quot;rejecting class: &quot; + cert.getClass().getName());
1532                 }
1533             }
1534         }
1535     }
1536 
1537     /*
1538      * Create PKCS#12 Attributes, friendlyName, localKeyId and trustedKeyUsage.
1539      *
1540      * Although attributes are optional, they could be required.
1541      * For e.g. localKeyId attribute is required to match the
1542      * private key with the associated end-entity certificate.
1543      * The trustedKeyUsage attribute is used to denote a trusted certificate.
1544      *
1545      * PKCS8ShroudedKeyBags include unique localKeyID and friendlyName.
1546      * CertBags may or may not include attributes depending on the type
1547      * of Certificate. In end-entity certificates, localKeyID should be
1548      * unique, and the corresponding private key should have the same
1549      * localKeyID. For trusted CA certs in the cert-chain, localKeyID
1550      * attribute is not required, hence most vendors don&#39;t include it.
1551      * NSS/Netscape require it to be unique or null, where as IE/OpenSSL
1552      * ignore it.
1553      *
1554      * Here is a list of pkcs12 attribute values in CertBags.
1555      *
1556      * PKCS12 Attribute       NSS/Netscape    IE     OpenSSL    J2SE
1557      * --------------------------------------------------------------
1558      * LocalKeyId
1559      * (In EE cert only,
1560      *  NULL in CA certs)      true          true     true      true
1561      *
1562      * friendlyName            unique        same/    same/     unique
1563      *                                       unique   unique/
1564      *                                                null
1565      * trustedKeyUsage         -             -        -         true
1566      *
1567      * Note: OpenSSL adds friendlyName for end-entity cert only, and
1568      * removes the localKeyID and friendlyName for CA certs.
1569      * If the CertBag did not have a friendlyName, most vendors will
1570      * add it, and assign it to the DN of the cert.
1571      */
1572     private byte[] getBagAttributes(String alias, byte[] keyId,
1573         Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws IOException {
1574         return getBagAttributes(alias, keyId, null, attributes);
1575     }
1576 
1577     private byte[] getBagAttributes(String alias, byte[] keyId,
1578         ObjectIdentifier[] trustedUsage,
1579         Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws IOException {
1580 
1581         byte[] localKeyID = null;
1582         byte[] friendlyName = null;
1583         byte[] trustedKeyUsage = null;
1584 
1585         // return null if all three attributes are null
1586         if ((alias == null) &amp;&amp; (keyId == null) &amp;&amp; (trustedKeyUsage == null)) {
1587             return null;
1588         }
1589 
1590         // SafeBag Attributes
1591         DerOutputStream bagAttrs = new DerOutputStream();
1592 
1593         // Encode the friendlyname oid.
1594         if (alias != null) {
1595             DerOutputStream bagAttr1 = new DerOutputStream();
1596             bagAttr1.putOID(PKCS9FriendlyName_OID);
1597             DerOutputStream bagAttrContent1 = new DerOutputStream();
1598             DerOutputStream bagAttrValue1 = new DerOutputStream();
1599             bagAttrContent1.putBMPString(alias);
1600             bagAttr1.write(DerValue.tag_Set, bagAttrContent1);
1601             bagAttrValue1.write(DerValue.tag_Sequence, bagAttr1);
1602             friendlyName = bagAttrValue1.toByteArray();
1603         }
1604 
1605         // Encode the localkeyId oid.
1606         if (keyId != null) {
1607             DerOutputStream bagAttr2 = new DerOutputStream();
1608             bagAttr2.putOID(PKCS9LocalKeyId_OID);
1609             DerOutputStream bagAttrContent2 = new DerOutputStream();
1610             DerOutputStream bagAttrValue2 = new DerOutputStream();
1611             bagAttrContent2.putOctetString(keyId);
1612             bagAttr2.write(DerValue.tag_Set, bagAttrContent2);
1613             bagAttrValue2.write(DerValue.tag_Sequence, bagAttr2);
1614             localKeyID = bagAttrValue2.toByteArray();
1615         }
1616 
1617         // Encode the trustedKeyUsage oid.
1618         if (trustedUsage != null) {
1619             DerOutputStream bagAttr3 = new DerOutputStream();
1620             bagAttr3.putOID(TrustedKeyUsage_OID);
1621             DerOutputStream bagAttrContent3 = new DerOutputStream();
1622             DerOutputStream bagAttrValue3 = new DerOutputStream();
1623             for (ObjectIdentifier usage : trustedUsage) {
1624                 bagAttrContent3.putOID(usage);
1625             }
1626             bagAttr3.write(DerValue.tag_Set, bagAttrContent3);
1627             bagAttrValue3.write(DerValue.tag_Sequence, bagAttr3);
1628             trustedKeyUsage = bagAttrValue3.toByteArray();
1629         }
1630 
1631         DerOutputStream attrs = new DerOutputStream();
1632         if (friendlyName != null) {
1633             attrs.write(friendlyName);
1634         }
1635         if (localKeyID != null) {
1636             attrs.write(localKeyID);
1637         }
1638         if (trustedKeyUsage != null) {
1639             attrs.write(trustedKeyUsage);
1640         }
1641 
1642         if (attributes != null) {
1643             for (KeyStore.Entry.Attribute attribute : attributes) {
1644                 String attributeName = attribute.getName();
1645                 // skip friendlyName, localKeyId and trustedKeyUsage
1646                 if (CORE_ATTRIBUTES[0].equals(attributeName) ||
1647                     CORE_ATTRIBUTES[1].equals(attributeName) ||
1648                     CORE_ATTRIBUTES[2].equals(attributeName)) {
1649                     continue;
1650                 }
1651                 attrs.write(((PKCS12Attribute) attribute).getEncoded());
1652             }
1653         }
1654 
1655         bagAttrs.write(DerValue.tag_Set, attrs);
1656         return bagAttrs.toByteArray();
1657     }
1658 
1659     /*
1660      * Create EncryptedData content type, that contains EncryptedContentInfo.
1661      * Includes certificates in individual SafeBags of type CertBag.
1662      * Each CertBag may include pkcs12 attributes
1663      * (see comments in getBagAttributes)
1664      */
1665     private byte[] createEncryptedData(char[] password)
1666         throws CertificateException, IOException
1667     {
1668         DerOutputStream out = new DerOutputStream();
1669         for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {
1670 
1671             String alias = e.nextElement();
1672             Entry entry = entries.get(alias);
1673 
1674             // certificate chain
1675             Certificate[] certs;
1676 
1677             if (entry instanceof PrivateKeyEntry) {
1678                 PrivateKeyEntry keyEntry = (PrivateKeyEntry) entry;
1679                 if (keyEntry.chain != null) {
1680                     certs = keyEntry.chain;
1681                 } else {
1682                     certs = new Certificate[0];
1683                 }
1684             } else if (entry instanceof CertEntry) {
1685                 certs = new Certificate[]{((CertEntry) entry).cert};
1686             } else {
1687                 certs = new Certificate[0];
1688             }
1689 
1690             for (int i = 0; i &lt; certs.length; i++) {
1691                 // create SafeBag of Type CertBag
1692                 DerOutputStream safeBag = new DerOutputStream();
1693                 safeBag.putOID(CertBag_OID);
1694 
1695                 // create a CertBag
1696                 DerOutputStream certBag = new DerOutputStream();
1697                 certBag.putOID(PKCS9CertType_OID);
1698 
1699                 // write encoded certs in a context-specific tag
1700                 DerOutputStream certValue = new DerOutputStream();
1701                 X509Certificate cert = (X509Certificate) certs[i];
1702                 certValue.putOctetString(cert.getEncoded());
1703                 certBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1704                                         true, (byte) 0), certValue);
1705 
1706                 // wrap CertBag in a Sequence
1707                 DerOutputStream certout = new DerOutputStream();
1708                 certout.write(DerValue.tag_Sequence, certBag);
1709                 byte[] certBagValue = certout.toByteArray();
1710 
1711                 // Wrap the CertBag encoding in a context-specific tag.
1712                 DerOutputStream bagValue = new DerOutputStream();
1713                 bagValue.write(certBagValue);
1714                 // write SafeBag Value
1715                 safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1716                                 true, (byte) 0), bagValue);
1717 
1718                 // write SafeBag Attributes
1719                 // All Certs should have a unique friendlyName.
1720                 // This change is made to meet NSS requirements.
1721                 byte[] bagAttrs = null;
1722                 if (i == 0) {
1723                     // Only End-Entity Cert should have a localKeyId.
1724                     if (entry instanceof KeyEntry) {
1725                         KeyEntry keyEntry = (KeyEntry) entry;
1726                         bagAttrs =
1727                             getBagAttributes(keyEntry.alias, keyEntry.keyId,
1728                                 keyEntry.attributes);
1729                     } else {
1730                         CertEntry certEntry = (CertEntry) entry;
1731                         bagAttrs =
1732                             getBagAttributes(certEntry.alias, certEntry.keyId,
1733                                 certEntry.trustedKeyUsage,
1734                                 certEntry.attributes);
1735                     }
1736                 } else {
1737                     // Trusted root CA certs and Intermediate CA certs do not
1738                     // need to have a localKeyId, and hence localKeyId is null
1739                     // This change is made to meet NSS/Netscape requirements.
1740                     // NSS pkcs12 library requires trusted CA certs in the
1741                     // certificate chain to have unique or null localKeyID.
1742                     // However, IE/OpenSSL do not impose this restriction.
1743                     bagAttrs = getBagAttributes(
1744                             cert.getSubjectX500Principal().getName(), null,
1745                             entry.attributes);
1746                 }
1747                 if (bagAttrs != null) {
1748                     safeBag.write(bagAttrs);
1749                 }
1750 
1751                 // wrap as Sequence
1752                 out.write(DerValue.tag_Sequence, safeBag);
1753             } // for cert-chain
1754         }
1755 
1756         // wrap as SequenceOf SafeBag
1757         DerOutputStream safeBagValue = new DerOutputStream();
1758         safeBagValue.write(DerValue.tag_SequenceOf, out);
1759         byte[] safeBagData = safeBagValue.toByteArray();
1760 
1761         // encrypt the content (EncryptedContentInfo)
1762         if (!certProtectionAlgorithm.equalsIgnoreCase(&quot;NONE&quot;)) {
1763             byte[] encrContentInfo = encryptContent(safeBagData, password);
1764 
1765             // -- SEQUENCE of EncryptedData
1766             DerOutputStream encrData = new DerOutputStream();
1767             DerOutputStream encrDataContent = new DerOutputStream();
1768             encrData.putInteger(0);
1769             encrData.write(encrContentInfo);
1770             encrDataContent.write(DerValue.tag_Sequence, encrData);
1771             return encrDataContent.toByteArray();
1772         } else {
1773             return safeBagData;
1774         }
1775     }
1776 
1777     /*
1778      * Create SafeContent Data content type.
1779      * Includes encrypted secret key in a SafeBag of type SecretBag.
1780      * Includes encrypted private key in a SafeBag of type PKCS8ShroudedKeyBag.
1781      * Each PKCS8ShroudedKeyBag includes pkcs12 attributes
1782      * (see comments in getBagAttributes)
1783      */
1784     private byte[] createSafeContent()
1785         throws CertificateException, IOException {
1786 
1787         DerOutputStream out = new DerOutputStream();
1788         for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {
1789 
1790             String alias = e.nextElement();
1791             Entry entry = entries.get(alias);
1792             if (entry == null || (!(entry instanceof KeyEntry))) {
1793                 continue;
1794             }
1795             DerOutputStream safeBag = new DerOutputStream();
1796             KeyEntry keyEntry = (KeyEntry) entry;
1797 
1798             // DER encode the private key
1799             if (keyEntry instanceof PrivateKeyEntry) {
1800                 // Create SafeBag of type pkcs8ShroudedKeyBag
1801                 safeBag.putOID(PKCS8ShroudedKeyBag_OID);
1802 
1803                 // get the encrypted private key
1804                 byte[] encrBytes = ((PrivateKeyEntry)keyEntry).protectedPrivKey;
1805                 EncryptedPrivateKeyInfo encrInfo = null;
1806                 try {
1807                     encrInfo = new EncryptedPrivateKeyInfo(encrBytes);
1808 
1809                 } catch (IOException ioe) {
1810                     throw new IOException(&quot;Private key not stored as &quot;
1811                             + &quot;PKCS#8 EncryptedPrivateKeyInfo&quot;
1812                             + ioe.getMessage());
1813                 }
1814 
1815                 // Wrap the EncryptedPrivateKeyInfo in a context-specific tag.
1816                 DerOutputStream bagValue = new DerOutputStream();
1817                 bagValue.write(encrInfo.getEncoded());
1818                 safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1819                                 true, (byte) 0), bagValue);
1820 
1821             // DER encode the secret key
1822             } else if (keyEntry instanceof SecretKeyEntry) {
1823                 // Create SafeBag of type SecretBag
1824                 safeBag.putOID(SecretBag_OID);
1825 
1826                 // Create a SecretBag
1827                 DerOutputStream secretBag = new DerOutputStream();
1828                 secretBag.putOID(PKCS8ShroudedKeyBag_OID);
1829 
1830                 // Write secret key in a context-specific tag
1831                 DerOutputStream secretKeyValue = new DerOutputStream();
1832                 secretKeyValue.putOctetString(
1833                     ((SecretKeyEntry) keyEntry).protectedSecretKey);
1834                 secretBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1835                                         true, (byte) 0), secretKeyValue);
1836 
1837                 // Wrap SecretBag in a Sequence
1838                 DerOutputStream secretBagSeq = new DerOutputStream();
1839                 secretBagSeq.write(DerValue.tag_Sequence, secretBag);
1840                 byte[] secretBagValue = secretBagSeq.toByteArray();
1841 
1842                 // Wrap the secret bag in a context-specific tag.
1843                 DerOutputStream bagValue = new DerOutputStream();
1844                 bagValue.write(secretBagValue);
1845 
1846                 // Write SafeBag value
1847                 safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1848                                     true, (byte) 0), bagValue);
1849             } else {
1850                 continue; // skip this entry
1851             }
1852 
1853             // write SafeBag Attributes
1854             byte[] bagAttrs =
1855                 getBagAttributes(alias, entry.keyId, entry.attributes);
1856             safeBag.write(bagAttrs);
1857 
1858             // wrap as Sequence
1859             out.write(DerValue.tag_Sequence, safeBag);
1860         }
1861 
1862         // wrap as Sequence
1863         DerOutputStream safeBagValue = new DerOutputStream();
1864         safeBagValue.write(DerValue.tag_Sequence, out);
1865         return safeBagValue.toByteArray();
1866     }
1867 
1868 
1869     /*
1870      * Encrypt the contents using Password-based (PBE) encryption
1871      * as defined in PKCS #5.
1872      *
1873      * NOTE: Currently pbeWithSHAAnd40BiteRC2-CBC algorithmID is used
1874      *       to derive the key and IV.
1875      *
1876      * @return encrypted contents encoded as EncryptedContentInfo
1877      */
1878     private byte[] encryptContent(byte[] data, char[] password)
1879         throws IOException {
1880 
1881         byte[] encryptedData = null;
1882 
1883 
1884         try {
1885             // create AlgorithmParameters
1886             AlgorithmParameters algParams = getPBEAlgorithmParameters(
1887                     certProtectionAlgorithm, certPbeIterationCount);
1888             DerOutputStream bytes = new DerOutputStream();
1889 
1890             // Use JCE
1891             SecretKey skey = getPBEKey(password);
1892             Cipher cipher = Cipher.getInstance(certProtectionAlgorithm);
1893             cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);
1894             encryptedData = cipher.doFinal(data);
1895 
1896             AlgorithmId algId = new AlgorithmId(
1897                     mapPBEAlgorithmToOID(certProtectionAlgorithm),
1898                     cipher.getParameters());
1899                     // cipher.getParameters() now has IV
1900             algId.encode(bytes);
1901             byte[] encodedAlgId = bytes.toByteArray();
1902 
1903             if (debug != null) {
1904                 debug.println(&quot;  (Cipher algorithm: &quot; + cipher.getAlgorithm() +
1905                         &quot;)&quot;);
1906             }
1907 
1908             // create EncryptedContentInfo
1909             DerOutputStream bytes2 = new DerOutputStream();
1910             bytes2.putOID(ContentInfo.DATA_OID);
1911             bytes2.write(encodedAlgId);
1912 
1913             // Wrap encrypted data in a context-specific tag.
1914             DerOutputStream tmpout2 = new DerOutputStream();
1915             tmpout2.putOctetString(encryptedData);
1916             bytes2.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,
1917                     false, (byte) 0), tmpout2);
1918 
1919             // wrap EncryptedContentInfo in a Sequence
1920             DerOutputStream out = new DerOutputStream();
1921             out.write(DerValue.tag_Sequence, bytes2);
1922             return out.toByteArray();
1923         } catch (IOException ioe) {
1924             throw ioe;
1925         } catch (Exception e) {
1926             throw new IOException(&quot;Failed to encrypt&quot; +
1927                     &quot; safe contents entry: &quot; + e, e);
1928         }
1929     }
1930 
1931     /**
1932      * Loads the keystore from the given input stream.
1933      *
1934      * &lt;p&gt;If a password is given, it is used to check the integrity of the
1935      * keystore data. Otherwise, the integrity of the keystore is not checked.
1936      *
1937      * @param stream the input stream from which the keystore is loaded
1938      * @param password the (optional) password used to check the integrity of
1939      * the keystore.
1940      *
1941      * @exception IOException if there is an I/O or format problem with the
1942      * keystore data
1943      * @exception NoSuchAlgorithmException if the algorithm used to check
1944      * the integrity of the keystore cannot be found
1945      * @exception CertificateException if any of the certificates in the
1946      * keystore could not be loaded
1947      */
1948     public synchronized void engineLoad(InputStream stream, char[] password)
1949         throws IOException, NoSuchAlgorithmException, CertificateException
1950     {
1951 
1952         // Reset config when loading a different keystore.
1953         certProtectionAlgorithm = null;
1954         certPbeIterationCount = -1;
1955         macAlgorithm = null;
1956         macIterationCount = -1;
1957 
1958         if (stream == null)
1959            return;
1960 
1961         // reset the counter
1962         counter = 0;
1963 
1964         DerValue val = new DerValue(stream);
1965         DerInputStream s = val.toDerInputStream();
1966         int version = s.getInteger();
1967 
1968         if (version != VERSION_3) {
1969            throw new IOException(&quot;PKCS12 keystore not in version 3 format&quot;);
1970         }
1971 
1972         entries.clear();
1973 
1974         /*
1975          * Read the authSafe.
1976          */
1977         byte[] authSafeData;
1978         ContentInfo authSafe = new ContentInfo(s);
1979         ObjectIdentifier contentType = authSafe.getContentType();
1980 
1981         if (contentType.equals(ContentInfo.DATA_OID)) {
1982            authSafeData = authSafe.getData();
1983         } else /* signed data */ {
1984            throw new IOException(&quot;public key protected PKCS12 not supported&quot;);
1985         }
1986 
1987         DerInputStream as = new DerInputStream(authSafeData);
1988         DerValue[] safeContentsArray = as.getSequence(2);
1989         int count = safeContentsArray.length;
1990 
1991         // reset the counters at the start
1992         privateKeyCount = 0;
1993         secretKeyCount = 0;
1994         certificateCount = 0;
1995 
1996         boolean seeEncBag = false;
1997 
1998         /*
1999          * Spin over the ContentInfos.
2000          */
2001         for (int i = 0; i &lt; count; i++) {
2002             ContentInfo safeContents;
2003             DerInputStream sci;
2004             byte[] eAlgId = null;
2005 
2006             sci = new DerInputStream(safeContentsArray[i].toByteArray());
2007             safeContents = new ContentInfo(sci);
2008             contentType = safeContents.getContentType();
2009             if (contentType.equals(ContentInfo.DATA_OID)) {
2010 
2011                 if (debug != null) {
2012                     debug.println(&quot;Loading PKCS#7 data&quot;);
2013                 }
2014 
2015                 loadSafeContents(new DerInputStream(safeContents.getData()));
2016             } else if (contentType.equals(ContentInfo.ENCRYPTED_DATA_OID)) {
2017                 if (password == null) {
2018 
2019                     if (debug != null) {
2020                         debug.println(&quot;Warning: skipping PKCS#7 encryptedData&quot; +
2021                             &quot; - no password was supplied&quot;);
2022                     }
2023                     // No password to decrypt ENCRYPTED_DATA_OID. *Skip it*.
2024                     // This means user will see a PrivateKeyEntry without
2025                     // certificates and a whole TrustedCertificateEntry will
2026                     // be lost. This is not a perfect solution but alternative
2027                     // solutions are more disruptive:
2028                     //
2029                     // We cannot just fail, since KeyStore.load(is, null)
2030                     // has been known to never fail because of a null password.
2031                     //
2032                     // We cannot just throw away the whole PrivateKeyEntry,
2033                     // this is too silent and no one will notice anything.
2034                     //
2035                     // We also cannot fail when getCertificate() on such a
2036                     // PrivateKeyEntry is called, since the method has not
2037                     // specified this behavior.
2038                     continue;
2039                 }
2040 
2041                 DerInputStream edi =
2042                                 safeContents.getContent().toDerInputStream();
2043                 int edVersion = edi.getInteger();
2044                 DerValue[] seq = edi.getSequence(2);
2045                 ObjectIdentifier edContentType = seq[0].getOID();
2046                 eAlgId = seq[1].toByteArray();
2047                 if (!seq[2].isContextSpecific((byte)0)) {
2048                    throw new IOException(&quot;encrypted content not present!&quot;);
2049                 }
2050                 byte newTag = DerValue.tag_OctetString;
2051                 if (seq[2].isConstructed())
2052                    newTag |= 0x20;
2053                 seq[2].resetTag(newTag);
2054                 byte[] rawData = seq[2].getOctetString();
2055 
2056                 // parse Algorithm parameters
2057                 DerInputStream in = seq[1].toDerInputStream();
2058                 ObjectIdentifier algOid = in.getOID();
2059                 AlgorithmParameters algParams = parseAlgParameters(algOid, in);
2060 
2061                 PBEParameterSpec pbeSpec;
2062                 int ic = 0;
2063 
2064                 if (algParams != null) {
2065                     try {
2066                         pbeSpec =
2067                             algParams.getParameterSpec(PBEParameterSpec.class);
2068                     } catch (InvalidParameterSpecException ipse) {
2069                         throw new IOException(
2070                             &quot;Invalid PBE algorithm parameters&quot;);
2071                     }
2072                     ic = pbeSpec.getIterationCount();
2073 
2074                     if (ic &gt; MAX_ITERATION_COUNT) {
2075                         throw new IOException(&quot;cert PBE iteration count too large&quot;);
2076                     }
2077 
2078                     certProtectionAlgorithm
2079                             = mapPBEParamsToAlgorithm(algOid, algParams);
2080                     certPbeIterationCount = ic;
2081                     seeEncBag = true;
2082                 }
2083 
2084                 if (debug != null) {
2085                     debug.println(&quot;Loading PKCS#7 encryptedData &quot; +
2086                         &quot;(&quot; + mapPBEParamsToAlgorithm(algOid, algParams) +
2087                         &quot; iterations: &quot; + ic + &quot;)&quot;);
2088                 }
2089 
2090                 try {
2091                     RetryWithZero.run(pass -&gt; {
2092                         // Use JCE
2093                         SecretKey skey = getPBEKey(pass);
2094                         Cipher cipher = Cipher.getInstance(
2095                                 mapPBEParamsToAlgorithm(algOid, algParams));
2096                         cipher.init(Cipher.DECRYPT_MODE, skey, algParams);
2097                         loadSafeContents(new DerInputStream(cipher.doFinal(rawData)));
2098                         return null;
2099                     }, password);
2100                 } catch (Exception e) {
2101                     throw new IOException(&quot;keystore password was incorrect&quot;,
2102                             new UnrecoverableKeyException(
2103                                     &quot;failed to decrypt safe contents entry: &quot; + e));
2104                 }
2105             } else {
2106                 throw new IOException(&quot;public key protected PKCS12&quot; +
2107                                         &quot; not supported&quot;);
2108             }
2109         }
2110 
2111         // No ENCRYPTED_DATA_OID but see certificate. Must be passwordless.
2112         if (!seeEncBag &amp;&amp; certificateCount &gt; 0) {
2113             certProtectionAlgorithm = &quot;NONE&quot;;
2114         }
2115 
2116         // The MacData is optional.
2117         if (s.available() &gt; 0) {
2118             // If there is no password, we cannot fail. KeyStore.load(is, null)
2119             // has been known to never fail because of a null password.
2120             if (password != null) {
2121                 MacData macData = new MacData(s);
2122                 int ic = macData.getIterations();
2123 
2124                 try {
2125                     if (ic &gt; MAX_ITERATION_COUNT) {
2126                         throw new InvalidAlgorithmParameterException(
2127                                 &quot;MAC iteration count too large: &quot; + ic);
2128                     }
2129 
2130                     String algName =
2131                             macData.getDigestAlgName().toUpperCase(Locale.ENGLISH);
2132 
2133                     // Change SHA-1 to SHA1
2134                     algName = algName.replace(&quot;-&quot;, &quot;&quot;);
2135 
2136                     macAlgorithm = &quot;HmacPBE&quot; + algName;
2137                     macIterationCount = ic;
2138 
2139                     // generate MAC (MAC key is created within JCE)
2140                     Mac m = Mac.getInstance(macAlgorithm);
2141                     PBEParameterSpec params =
2142                             new PBEParameterSpec(macData.getSalt(), ic);
2143 
2144                     RetryWithZero.run(pass -&gt; {
2145                         SecretKey key = getPBEKey(pass);
2146                         m.init(key, params);
2147                         m.update(authSafeData);
2148                         byte[] macResult = m.doFinal();
2149 
2150                         if (debug != null) {
2151                             debug.println(&quot;Checking keystore integrity &quot; +
2152                                     &quot;(&quot; + m.getAlgorithm() + &quot; iterations: &quot; + ic + &quot;)&quot;);
2153                         }
2154 
2155                         if (!MessageDigest.isEqual(macData.getDigest(), macResult)) {
2156                             throw new UnrecoverableKeyException(&quot;Failed PKCS12&quot; +
2157                                     &quot; integrity checking&quot;);
2158                         }
2159                         return (Void) null;
2160                     }, password);
2161                 } catch (Exception e) {
2162                     throw new IOException(&quot;Integrity check failed: &quot; + e, e);
2163                 }
2164             }
2165         } else {
2166             macAlgorithm = &quot;NONE&quot;;
2167         }
2168 
2169         /*
2170          * Match up private keys with certificate chains.
2171          */
2172         PrivateKeyEntry[] list =
2173             keyList.toArray(new PrivateKeyEntry[keyList.size()]);
2174         for (int m = 0; m &lt; list.length; m++) {
2175             PrivateKeyEntry entry = list[m];
2176             if (entry.keyId != null) {
2177                 ArrayList&lt;X509Certificate&gt; chain =
2178                                 new ArrayList&lt;X509Certificate&gt;();
2179                 X509Certificate cert = findMatchedCertificate(entry);
2180 
2181                 mainloop:
2182                 while (cert != null) {
2183                     // Check for loops in the certificate chain
2184                     if (!chain.isEmpty()) {
2185                         for (X509Certificate chainCert : chain) {
2186                             if (cert.equals(chainCert)) {
2187                                 if (debug != null) {
2188                                     debug.println(&quot;Loop detected in &quot; +
2189                                         &quot;certificate chain. Skip adding &quot; +
2190                                         &quot;repeated cert to chain. Subject: &quot; +
2191                                         cert.getSubjectX500Principal()
2192                                             .toString());
2193                                 }
2194                                 break mainloop;
2195                             }
2196                         }
2197                     }
2198                     chain.add(cert);
2199                     if (KeyStoreUtil.isSelfSigned(cert)) {
2200                         break;
2201                     }
2202                     cert = findIssuer(cert);
2203                 }
2204                 /* Update existing KeyEntry in entries table */
2205                 if (chain.size() &gt; 0) {
2206                     entry.chain = chain.toArray(new Certificate[chain.size()]);
2207                 } else {
2208                     // Remove private key entries where there is no associated
2209                     // certs. Most likely the keystore is loaded with a null
2210                     // password.
2211                     entries.remove(entry);
2212                 }
2213             }
2214         }
2215 
2216         if (debug != null) {
2217             debug.println(&quot;PKCS12KeyStore load: private key count: &quot; +
2218                     privateKeyCount + &quot;. secret key count: &quot; + secretKeyCount +
2219                     &quot;. certificate count: &quot; + certificateCount);
2220         }
2221 
2222         certEntries.clear();
2223         allCerts.clear();
2224         keyList.clear();
2225     }
2226 
2227     /**
2228      * Find the issuer of input in allCerts. If the input has an
2229      * AuthorityKeyIdentifier extension and the keyId inside matches
2230      * the keyId of the SubjectKeyIdentifier of a cert. This cert is
2231      * returned. Otherwise, a cert whose subjectDN is the same as the
2232      * input&#39;s issuerDN is returned.
2233      *
2234      * @param input the input certificate
2235      * @return the isssuer, or null if none matches
2236      */
2237     private X509Certificate findIssuer(X509Certificate input) {
2238 
2239         X509Certificate fallback = null; // the DN match
2240         X500Principal issuerPrinc = input.getIssuerX500Principal();
2241 
2242         // AuthorityKeyIdentifier value encoded as an OCTET STRING
2243         byte[] issuerIdExtension = input.getExtensionValue(&quot;2.5.29.35&quot;);
2244         byte[] issuerId = null;
2245 
2246         if (issuerIdExtension != null) {
2247             try {
2248                 issuerId = new AuthorityKeyIdentifierExtension(
2249                             false,
2250                             new DerValue(issuerIdExtension).getOctetString())
2251                         .getEncodedKeyIdentifier();
2252             } catch (IOException e) {
2253                 // ignored. issuerId is still null
2254             }
2255         }
2256 
2257         for (X509Certificate cert : allCerts) {
2258             if (cert.getSubjectX500Principal().equals(issuerPrinc)) {
2259                 if (issuerId != null) {
2260                     // SubjectKeyIdentifier value encoded as an OCTET STRING
2261                     byte[] subjectIdExtension = cert.getExtensionValue(&quot;2.5.29.14&quot;);
2262                     byte[] subjectId = null;
2263                     if (subjectIdExtension != null) {
2264                         try {
2265                             subjectId = new DerValue(subjectIdExtension)
2266                                     .getOctetString();
2267                         } catch (IOException e) {
2268                             // ignored. issuerId is still null
2269                         }
2270                     }
2271                     if (subjectId != null) {
2272                         if (Arrays.equals(issuerId, subjectId)) {
2273                             // keyId exact match!
2274                             return cert;
2275                         } else {
2276                             // Different keyId. Not a fallback.
2277                             continue;
2278                         }
2279                     } else {
2280                         // A DN match with no subjectId
2281                         fallback = cert;
2282                     }
2283                 } else { // if there is no issuerId, return the 1st DN match
2284                     return cert;
2285                 }
2286             }
2287         }
2288         return fallback;
2289     }
2290 
2291     /**
2292      * Returns if a pkcs12 file is password-less. This means no cert is
2293      * encrypted and there is no Mac. Please note that the private key
2294      * can be encrypted.
2295      *
2296      * This is a simplified version of {@link #engineLoad} that only looks
2297      * at the ContentInfo types.
2298      *
2299      * @param f the pkcs12 file
2300      * @return if it&#39;s password-less
2301      * @throws IOException
2302      */
2303     public static boolean isPasswordless(File f) throws IOException {
2304 
2305         try (FileInputStream stream = new FileInputStream(f)) {
2306             DerValue val = new DerValue(stream);
2307             DerInputStream s = val.toDerInputStream();
2308 
2309             s.getInteger(); // skip version
2310 
2311             ContentInfo authSafe = new ContentInfo(s);
2312             DerInputStream as = new DerInputStream(authSafe.getData());
2313             for (DerValue seq : as.getSequence(2)) {
2314                 DerInputStream sci = new DerInputStream(seq.toByteArray());
2315                 ContentInfo safeContents = new ContentInfo(sci);
2316                 if (safeContents.getContentType()
2317                         .equals(ContentInfo.ENCRYPTED_DATA_OID)) {
2318                     // Certificate encrypted
2319                     return false;
2320                 }
2321             }
2322 
2323             if (s.available() &gt; 0) {
2324                 // The MacData exists.
2325                 return false;
2326             }
2327         }
2328         return true;
2329     }
2330 
2331     /**
2332      * Locates a matched CertEntry from certEntries, and returns its cert.
2333      * @param entry the KeyEntry to match
2334      * @return a certificate, null if not found
2335      */
2336     private X509Certificate findMatchedCertificate(PrivateKeyEntry entry) {
2337         CertEntry keyIdMatch = null;
2338         CertEntry aliasMatch = null;
2339         for (CertEntry ce: certEntries) {
2340             if (Arrays.equals(entry.keyId, ce.keyId)) {
2341                 keyIdMatch = ce;
2342                 if (entry.alias.equalsIgnoreCase(ce.alias)) {
2343                     // Full match!
2344                     return ce.cert;
2345                 }
2346             } else if (entry.alias.equalsIgnoreCase(ce.alias)) {
2347                 aliasMatch = ce;
2348             }
2349         }
2350         // keyId match first, for compatibility
2351         if (keyIdMatch != null) return keyIdMatch.cert;
2352         else if (aliasMatch != null) return aliasMatch.cert;
2353         else return null;
2354     }
2355 
2356     private void loadSafeContents(DerInputStream stream)
2357         throws IOException, NoSuchAlgorithmException, CertificateException
2358     {
2359         DerValue[] safeBags = stream.getSequence(2);
2360         int count = safeBags.length;
2361 
2362         /*
2363          * Spin over the SafeBags.
2364          */
2365         for (int i = 0; i &lt; count; i++) {
2366             ObjectIdentifier bagId;
2367             DerInputStream sbi;
2368             DerValue bagValue;
2369             Object bagItem = null;
2370 
2371             sbi = safeBags[i].toDerInputStream();
2372             bagId = sbi.getOID();
2373             bagValue = sbi.getDerValue();
2374             if (!bagValue.isContextSpecific((byte)0)) {
2375                 throw new IOException(&quot;unsupported PKCS12 bag value type &quot;
2376                                         + bagValue.tag);
2377             }
2378             bagValue = bagValue.data.getDerValue();
2379             if (bagId.equals(PKCS8ShroudedKeyBag_OID)) {
2380                 PrivateKeyEntry kEntry = new PrivateKeyEntry();
2381                 kEntry.protectedPrivKey = bagValue.toByteArray();
2382                 bagItem = kEntry;
2383                 privateKeyCount++;
2384             } else if (bagId.equals(CertBag_OID)) {
2385                 DerInputStream cs = new DerInputStream(bagValue.toByteArray());
2386                 DerValue[] certValues = cs.getSequence(2);
2387                 ObjectIdentifier certId = certValues[0].getOID();
2388                 if (!certValues[1].isContextSpecific((byte)0)) {
2389                     throw new IOException(&quot;unsupported PKCS12 cert value type &quot;
2390                                         + certValues[1].tag);
2391                 }
2392                 DerValue certValue = certValues[1].data.getDerValue();
2393                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X509&quot;);
2394                 X509Certificate cert;
2395                 cert = (X509Certificate)cf.generateCertificate
2396                         (new ByteArrayInputStream(certValue.getOctetString()));
2397                 bagItem = cert;
2398                 certificateCount++;
2399             } else if (bagId.equals(SecretBag_OID)) {
2400                 DerInputStream ss = new DerInputStream(bagValue.toByteArray());
2401                 DerValue[] secretValues = ss.getSequence(2);
2402                 ObjectIdentifier secretId = secretValues[0].getOID();
2403                 if (!secretValues[1].isContextSpecific((byte)0)) {
2404                     throw new IOException(
2405                         &quot;unsupported PKCS12 secret value type &quot;
2406                                         + secretValues[1].tag);
2407                 }
2408                 DerValue secretValue = secretValues[1].data.getDerValue();
2409                 SecretKeyEntry kEntry = new SecretKeyEntry();
2410                 kEntry.protectedSecretKey = secretValue.getOctetString();
2411                 bagItem = kEntry;
2412                 secretKeyCount++;
2413             } else {
2414 
2415                 if (debug != null) {
2416                     debug.println(&quot;Unsupported PKCS12 bag type: &quot; + bagId);
2417                 }
2418             }
2419 
2420             DerValue[] attrSet;
2421             try {
2422                 attrSet = sbi.getSet(3);
2423             } catch (IOException e) {
2424                 // entry does not have attributes
2425                 // Note: CA certs can have no attributes
2426                 // OpenSSL generates pkcs12 with no attr for CA certs.
2427                 attrSet = null;
2428             }
2429 
2430             String alias = null;
2431             byte[] keyId = null;
2432             ObjectIdentifier[] trustedKeyUsage = null;
2433             Set&lt;PKCS12Attribute&gt; attributes = new HashSet&lt;&gt;();
2434 
2435             if (attrSet != null) {
2436                 for (int j = 0; j &lt; attrSet.length; j++) {
2437                     byte[] encoded = attrSet[j].toByteArray();
2438                     DerInputStream as = new DerInputStream(encoded);
2439                     DerValue[] attrSeq = as.getSequence(2);
2440                     ObjectIdentifier attrId = attrSeq[0].getOID();
2441                     DerInputStream vs =
2442                         new DerInputStream(attrSeq[1].toByteArray());
2443                     DerValue[] valSet;
2444                     try {
2445                         valSet = vs.getSet(1);
2446                     } catch (IOException e) {
2447                         throw new IOException(&quot;Attribute &quot; + attrId +
2448                                 &quot; should have a value &quot; + e.getMessage());
2449                     }
2450                     if (attrId.equals(PKCS9FriendlyName_OID)) {
2451                         alias = valSet[0].getBMPString();
2452                     } else if (attrId.equals(PKCS9LocalKeyId_OID)) {
2453                         keyId = valSet[0].getOctetString();
2454                     } else if
2455                         (attrId.equals(TrustedKeyUsage_OID)) {
2456                         trustedKeyUsage = new ObjectIdentifier[valSet.length];
2457                         for (int k = 0; k &lt; valSet.length; k++) {
2458                             trustedKeyUsage[k] = valSet[k].getOID();
2459                         }
2460                     } else {
2461                         attributes.add(new PKCS12Attribute(encoded));
2462                     }
2463                 }
2464             }
2465 
2466             /*
2467              * As per PKCS12 v1.0 friendlyname (alias) and localKeyId (keyId)
2468              * are optional PKCS12 bagAttributes. But entries in the keyStore
2469              * are identified by their alias. Hence we need to have an
2470              * Unfriendlyname in the alias, if alias is null. The keyId
2471              * attribute is required to match the private key with the
2472              * certificate. If we get a bagItem of type KeyEntry with a
2473              * null keyId, we should skip it entirely.
2474              */
2475             if (bagItem instanceof KeyEntry) {
2476                 KeyEntry entry = (KeyEntry)bagItem;
2477 
2478                 if (keyId == null) {
2479                     if (bagItem instanceof PrivateKeyEntry) {
2480                        // Insert a localKeyID for the privateKey
2481                        // Note: This is a workaround to allow null localKeyID
2482                        // attribute in pkcs12 with one private key entry and
2483                        // associated cert-chain
2484                        if (privateKeyCount == 1) {
2485                             keyId = &quot;01&quot;.getBytes(UTF_8);
2486                        } else {
2487                             continue;
2488                        }
2489                     } else {
2490                         // keyId in a SecretKeyEntry is not significant
2491                         keyId = &quot;00&quot;.getBytes(UTF_8);
2492                     }
2493                 }
2494                 entry.keyId = keyId;
2495                 // restore date if it exists
2496                 String keyIdStr = new String(keyId, UTF_8);
2497                 Date date = null;
2498                 if (keyIdStr.startsWith(&quot;Time &quot;)) {
2499                     try {
2500                         date = new Date(
2501                                 Long.parseLong(keyIdStr.substring(5)));
2502                     } catch (Exception e) {
2503                         date = null;
2504                     }
2505                 }
2506                 if (date == null) {
2507                     date = new Date();
2508                 }
2509                 entry.date = date;
2510 
2511                 if (bagItem instanceof PrivateKeyEntry) {
2512                     keyList.add((PrivateKeyEntry) entry);
2513                 }
2514                 if (entry.attributes == null) {
2515                     entry.attributes = new HashSet&lt;&gt;();
2516                 }
2517                 entry.attributes.addAll(attributes);
2518                 if (alias == null) {
2519                    alias = getUnfriendlyName();
2520                 }
2521                 entry.alias = alias;
2522                 entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
2523 
2524             } else if (bagItem instanceof X509Certificate) {
2525                 X509Certificate cert = (X509Certificate)bagItem;
2526                 // Insert a localKeyID for the corresponding cert
2527                 // Note: This is a workaround to allow null localKeyID
2528                 // attribute in pkcs12 with one private key entry and
2529                 // associated cert-chain
2530                 if ((keyId == null) &amp;&amp; (privateKeyCount == 1)) {
2531                     // insert localKeyID only for EE cert or self-signed cert
2532                     if (i == 0) {
2533                         keyId = &quot;01&quot;.getBytes(UTF_8);
2534                     }
2535                 }
2536                 // Trusted certificate
2537                 if (trustedKeyUsage != null) {
2538                     if (alias == null) {
2539                         alias = getUnfriendlyName();
2540                     }
2541                     CertEntry certEntry =
2542                         new CertEntry(cert, keyId, alias, trustedKeyUsage,
2543                             attributes);
2544                     entries.put(alias.toLowerCase(Locale.ENGLISH), certEntry);
2545                 } else {
2546                     certEntries.add(new CertEntry(cert, keyId, alias));
2547                 }
2548                 allCerts.add(cert);
2549             }
2550         }
2551     }
2552 
2553     private String getUnfriendlyName() {
2554         counter++;
2555         return (String.valueOf(counter));
2556     }
2557 
2558     /*
2559      * PKCS12 permitted first 24 bytes:
2560      *
2561      * 30 80 02 01 03 30 80 06 09 2A 86 48 86 F7 0D 01 07 01 A0 80 24 80 04 --
2562      * 30 82 -- -- 02 01 03 30 82 -- -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 8-
2563      * 30 -- 02 01 03 30 -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 -- 04 -- -- --
2564      * 30 81 -- 02 01 03 30 81 -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 81 -- 04
2565      * 30 82 -- -- 02 01 03 30 81 -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 81 --
2566      * 30 83 -- -- -- 02 01 03 30 82 -- -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0
2567      * 30 83 -- -- -- 02 01 03 30 83 -- -- -- 06 09 2A 86 48 86 F7 0D 01 07 01
2568      * 30 84 -- -- -- -- 02 01 03 30 83 -- -- -- 06 09 2A 86 48 86 F7 0D 01 07
2569      * 30 84 -- -- -- -- 02 01 03 30 84 -- -- -- -- 06 09 2A 86 48 86 F7 0D 01
2570      */
2571 
2572     private static final long[][] PKCS12_HEADER_PATTERNS = {
2573         { 0x3080020103308006L, 0x092A864886F70D01L, 0x0701A08024800400L },
2574         { 0x3082000002010330L, 0x82000006092A8648L, 0x86F70D010701A080L },
2575         { 0x3000020103300006L, 0x092A864886F70D01L, 0x0701A00004000000L },
2576         { 0x3081000201033081L, 0x0006092A864886F7L, 0x0D010701A0810004L },
2577         { 0x3082000002010330L, 0x810006092A864886L, 0xF70D010701A08100L },
2578         { 0x3083000000020103L, 0x3082000006092A86L, 0x4886F70D010701A0L },
2579         { 0x3083000000020103L, 0x308300000006092AL, 0x864886F70D010701L },
2580         { 0x3084000000000201L, 0x0330830000000609L, 0x2A864886F70D0107L },
2581         { 0x3084000000000201L, 0x0330840000000006L, 0x092A864886F70D01L }
2582     };
2583 
2584     private static final long[][] PKCS12_HEADER_MASKS = {
2585         { 0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFF00L },
2586         { 0xFFFF0000FFFFFFFFL, 0xFF0000FFFFFFFFFFL, 0xFFFFFFFFFFFFFFF0L },
2587         { 0xFF00FFFFFFFF00FFL, 0xFFFFFFFFFFFFFFFFL, 0xFFFFFF00FF000000L },
2588         { 0xFFFF00FFFFFFFFFFL, 0x00FFFFFFFFFFFFFFL, 0xFFFFFFFFFFFF00FFL },
2589         { 0xFFFF0000FFFFFFFFL, 0xFF00FFFFFFFFFFFFL, 0xFFFFFFFFFFFFFF00L },
2590         { 0xFFFF000000FFFFFFL, 0xFFFF0000FFFFFFFFL, 0xFFFFFFFFFFFFFFFFL },
2591         { 0xFFFF000000FFFFFFL, 0xFFFF000000FFFFFFL, 0xFFFFFFFFFFFFFFFFL },
2592         { 0xFFFF00000000FFFFL, 0xFFFFFF000000FFFFL, 0xFFFFFFFFFFFFFFFFL },
2593         { 0xFFFF00000000FFFFL, 0xFFFFFF00000000FFL, 0xFFFFFFFFFFFFFFFFL }
2594     };
2595 
2596     /**
2597      * Probe the first few bytes of the keystore data stream for a valid
2598      * PKCS12 keystore encoding.
2599      */
2600     @Override
2601     public boolean engineProbe(InputStream stream) throws IOException {
2602 
2603         DataInputStream dataStream;
2604         if (stream instanceof DataInputStream) {
2605             dataStream = (DataInputStream)stream;
2606         } else {
2607             dataStream = new DataInputStream(stream);
2608         }
2609 
2610         long firstPeek = dataStream.readLong();
2611         long nextPeek = dataStream.readLong();
2612         long finalPeek = dataStream.readLong();
2613         boolean result = false;
2614 
2615         for (int i = 0; i &lt; PKCS12_HEADER_PATTERNS.length; i++) {
2616             if (PKCS12_HEADER_PATTERNS[i][0] ==
2617                     (firstPeek &amp; PKCS12_HEADER_MASKS[i][0]) &amp;&amp;
2618                 (PKCS12_HEADER_PATTERNS[i][1] ==
2619                     (nextPeek &amp; PKCS12_HEADER_MASKS[i][1])) &amp;&amp;
2620                 (PKCS12_HEADER_PATTERNS[i][2] ==
2621                     (finalPeek &amp; PKCS12_HEADER_MASKS[i][2]))) {
2622                 result = true;
2623                 break;
2624             }
2625         }
2626 
2627         return result;
2628     }
2629 
2630     // 8076190: Customizing the generation of a PKCS12 keystore
2631 
2632     private static String defaultCertProtectionAlgorithm() {
2633         String result = SecurityProperties.privilegedGetOverridable(
2634                 &quot;keystore.pkcs12.certProtectionAlgorithm&quot;);
2635         return (result != null &amp;&amp; !result.isEmpty())
2636                 ? result : &quot;PBEWithSHA1AndRC2_40&quot;;
2637     }
2638 
2639     private static int defaultCertPbeIterationCount() {
2640         String result = SecurityProperties.privilegedGetOverridable(
2641                 &quot;keystore.pkcs12.certPbeIterationCount&quot;);
2642         return (result != null &amp;&amp; !result.isEmpty())
2643                 ? string2IC(&quot;certPbeIterationCount&quot;, result) : 50000;
2644     }
2645 
2646     // Read both &quot;keystore.pkcs12.keyProtectionAlgorithm&quot; and
2647     // &quot;keystore.PKCS12.keyProtectionAlgorithm&quot; for compatibility.
2648     private static String defaultKeyProtectionAlgorithm() {
2649         String result = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
2650             public String run() {
2651                 String result;
2652                 String name1 = &quot;keystore.pkcs12.keyProtectionAlgorithm&quot;;
2653                 String name2 = &quot;keystore.PKCS12.keyProtectionAlgorithm&quot;;
2654                 result = System.getProperty(name1);
2655                 if (result != null) {
2656                     return result;
2657                 }
2658                 result = System.getProperty(name2);
2659                 if (result != null) {
2660                     return result;
2661                 }
2662                 result = Security.getProperty(name1);
2663                 if (result != null) {
2664                     return result;
2665                 }
2666                 return Security.getProperty(name2);
2667             }
2668         });
2669         return (result != null &amp;&amp; !result.isEmpty())
2670                 ? result : &quot;PBEWithSHA1AndDESede&quot;;
2671     }
2672 
2673     private static int defaultKeyPbeIterationCount() {
2674         String result = SecurityProperties.privilegedGetOverridable(
2675                 &quot;keystore.pkcs12.keyPbeIterationCount&quot;);
2676         return (result != null &amp;&amp; !result.isEmpty())
2677                 ? string2IC(&quot;keyPbeIterationCount&quot;, result) : 50000;
2678     }
2679 
2680     private static String defaultMacAlgorithm() {
2681         String result = SecurityProperties.privilegedGetOverridable(
2682                 &quot;keystore.pkcs12.macAlgorithm&quot;);
2683         return (result != null &amp;&amp; !result.isEmpty())
2684                 ? result : &quot;HmacPBESHA1&quot;;
2685     }
2686 
2687     private static int defaultMacIterationCount() {
2688         String result = SecurityProperties.privilegedGetOverridable(
2689                 &quot;keystore.pkcs12.macIterationCount&quot;);
2690         return (result != null &amp;&amp; !result.isEmpty())
2691                 ? string2IC(&quot;macIterationCount&quot;, result) : 100000;
2692     }
2693 
2694     private static int string2IC(String type, String value) {
2695         int number;
2696         try {
2697             number = Integer.parseInt(value);
2698         } catch (NumberFormatException e) {
2699             throw new IllegalArgumentException(&quot;keystore.pkcs12.&quot; + type
2700                     + &quot; is not a number: &quot; + value);
2701         }
2702         if (number &lt;= 0 || number &gt; MAX_ITERATION_COUNT) {
2703             throw new IllegalArgumentException(&quot;Invalid keystore.pkcs12.&quot;
2704                     + type + &quot;: &quot; + value);
2705         }
2706         return number;
2707     }
2708 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
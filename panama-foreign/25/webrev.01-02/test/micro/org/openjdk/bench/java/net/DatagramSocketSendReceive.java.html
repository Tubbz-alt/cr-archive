<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/micro/org/openjdk/bench/java/net/DatagramSocketSendReceive.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.bench.java.net;
 24 
 25 import org.openjdk.jmh.annotations.Benchmark;
 26 import org.openjdk.jmh.annotations.BenchmarkMode;
 27 import org.openjdk.jmh.annotations.Mode;
 28 import org.openjdk.jmh.annotations.OutputTimeUnit;
 29 import org.openjdk.jmh.annotations.Param;
 30 import org.openjdk.jmh.annotations.Scope;
 31 import org.openjdk.jmh.annotations.Setup;
 32 import org.openjdk.jmh.annotations.State;
 33 import org.openjdk.jmh.annotations.TearDown;
 34 
 35 import java.util.concurrent.TimeUnit;
 36 import java.io.IOException;
 37 import java.net.DatagramPacket;
 38 import java.net.DatagramSocket;
 39 import java.net.InetAddress;
 40 
 41 /**
 42  * Benchmark DatagramSocket send/receive.
 43  */
 44 @BenchmarkMode(Mode.AverageTime)
 45 @OutputTimeUnit(TimeUnit.MICROSECONDS)
 46 @State(Scope.Thread)
 47 public class DatagramSocketSendReceive {
 48     private int counter = 0;
 49 
 50     private DatagramSocket socket1, socket2, connectedSendSocket,
 51             connectedReceiveSocket, multipleRecieveSocket, multipleSendSocket;
 52     private DatagramPacket sendPkt1, sendPkt2, connectedSendPkt, multipleSendPkt,
 53             receivePkt;
 54 
 55     private DatagramSocket[] dsa;
 56     private DatagramPacket[] pkts;
 57 
 58     @Param({&quot;128&quot;, &quot;512&quot;, &quot;2048&quot;, &quot;8192&quot;, &quot;32768&quot;})
 59     public int size;
 60 
 61     @Param({&quot;4&quot;})
 62     public int socketCount;
 63 
 64     @Setup
 65     public void setUp() throws IOException {
 66         byte[] buf = new byte[size];
 67         InetAddress addr = InetAddress.getLocalHost();
 68 
 69         receivePkt = new DatagramPacket(buf, buf.length);
 70 
 71         // single send - same socket; different sockets
 72         socket1 = new DatagramSocket(0, addr);
 73         socket2 = new DatagramSocket(0, addr);
 74         sendPkt1 = new DatagramPacket(buf, buf.length, addr,
 75                 socket1.getLocalPort());
 76         sendPkt2 = new DatagramPacket(buf, buf.length, addr,
 77                 socket2.getLocalPort());
 78 
 79         // connected send/receive
 80         connectedSendSocket = new DatagramSocket(0, addr);
 81         connectedReceiveSocket = new DatagramSocket(0, addr);
 82         connectedSendSocket.connect(addr, connectedReceiveSocket.getLocalPort());
 83         connectedReceiveSocket.connect(addr, connectedSendSocket.getLocalPort());
 84         connectedSendPkt = new DatagramPacket(buf, buf.length);
 85 
 86         // multiple senders / multiple receivers
 87         dsa = new DatagramSocket[socketCount];
 88         pkts = new DatagramPacket[socketCount];
 89         for (int i = 0; i &lt; dsa.length; i++) {
 90             dsa[i] = new DatagramSocket(0, addr);
 91             pkts[i] = new DatagramPacket(buf, buf.length,
 92                     addr, dsa[i].getLocalPort());
 93         }
 94         multipleRecieveSocket = new DatagramSocket(0, addr);
 95         multipleSendSocket = new DatagramSocket(0, addr);
 96         multipleSendPkt = new DatagramPacket(buf, buf.length, addr,
 97                 multipleRecieveSocket.getLocalPort());
 98     }
 99 
100     // same sender receiver
101     @Benchmark
102     public void sendReceiveSingleSocket() throws IOException {
103         socket1.send(sendPkt1);
104         socket1.receive(receivePkt);
105     }
106 
107     // single sender, single receiver
108     @Benchmark
109     public void sendReceive() throws IOException {
110         socket1.send(sendPkt2);
111         socket2.receive(receivePkt);
112     }
113 
114     // connected sender receiver
115     @Benchmark
116     public void sendReceiveConnected() throws IOException {
117         connectedSendSocket.send(connectedSendPkt);
118         connectedReceiveSocket.receive(receivePkt);
119     }
120 
121     // multiple senders, single receiver
122     @Benchmark
123     public void sendMultiple() throws IOException {
124         int i = counter;
125         dsa[i].send(multipleSendPkt);
126         multipleRecieveSocket.receive(receivePkt);
127         counter = ++i % dsa.length;
128     }
129 
130     // single sender, multiple receivers
131     @Benchmark
132     public void receiveMultiple() throws IOException {
133         int i = counter;
134         multipleSendSocket.send(pkts[i]);
135         dsa[i].receive(receivePkt);
136         counter = ++i % dsa.length;
137     }
138 
139     @TearDown
140     public void tearDown() {
141         socket1.close();
142         socket2.close();
143         connectedSendSocket.close();
144         connectedReceiveSocket.close();
145 
146         multipleRecieveSocket.close();
147         multipleSendSocket.close();
148         for (DatagramSocket ds : dsa) {
149             ds.close();
150         }
151     }
152 }
    </pre>
  </body>
</html>
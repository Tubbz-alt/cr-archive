<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestByteBuffer.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="TestArrays.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayouts.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestByteBuffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
153     }
154 
155     static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer&lt;MemoryAddress, Long&gt; handleSetter) {
156         for (long i = 0; i &lt; seq.elementCount().getAsLong() ; i++) {
157             handleSetter.accept(base, i);
158         }
159     }
160 
161     static &lt;Z extends Buffer&gt; void checkBytes(MemoryAddress base, SequenceLayout layout,
162                                               Function&lt;ByteBuffer, Z&gt; bufFactory,
163                                               BiFunction&lt;MemoryAddress, Long, Object&gt; handleExtractor,
164                                               Function&lt;Z, Object&gt; bufferExtractor) {
165         long nelems = layout.elementCount().getAsLong();
166         long elemSize = layout.elementLayout().byteSize();
167         for (long i = 0 ; i &lt; nelems ; i++) {
168             long limit = nelems - i;
169             MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);
170             ByteBuffer bb = resizedSegment.asByteBuffer();
171             Z z = bufFactory.apply(bb);
172             for (long j = i ; j &lt; limit ; j++) {
<span class="line-modified">173                 Object handleValue = handleExtractor.apply(resizedSegment.baseAddress(), j - i);</span>
174                 Object bufferValue = bufferExtractor.apply(z);
175                 if (handleValue instanceof Number) {
176                     assertEquals(((Number)handleValue).longValue(), j);
177                     assertEquals(((Number)bufferValue).longValue(), j);
178                 } else {
179                     assertEquals((long)(char)handleValue, j);
180                     assertEquals((long)(char)bufferValue, j);
181                 }
182             }
183         }
184     }
185 
186     @Test
187     public void testOffheap() {
188         try (MemorySegment segment = MemorySegment.allocateNative(tuples)) {
<span class="line-modified">189             MemoryAddress base = segment.baseAddress();</span>
190             initTuples(base, tuples.elementCount().getAsLong());
191 
192             ByteBuffer bb = segment.asByteBuffer();
193             checkTuples(base, bb, tuples.elementCount().getAsLong());
194         }
195     }
196 
197     @Test
198     public void testHeap() {
199         byte[] arr = new byte[(int) tuples.byteSize()];
200         MemorySegment region = MemorySegment.ofArray(arr);
<span class="line-modified">201         MemoryAddress base = region.baseAddress();</span>
202         initTuples(base, tuples.elementCount().getAsLong());
203 
204         ByteBuffer bb = region.asByteBuffer();
205         checkTuples(base, bb, tuples.elementCount().getAsLong());
206     }
207 
208     @Test
209     public void testChannel() throws Throwable {
210         File f = new File(&quot;test.out&quot;);
211         assertTrue(f.createNewFile());
212         f.deleteOnExit();
213 
214         //write to channel
215         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
216             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -&gt; {
217                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
<span class="line-modified">218                 MemoryAddress base = segment.baseAddress();</span>
219                 initTuples(base, tuples.elementCount().getAsLong());
220                 mbb.force();
221             });
222         }
223 
224         //read from channel
225         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
226             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -&gt; {
227                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
<span class="line-modified">228                 MemoryAddress base = segment.baseAddress();</span>
229                 checkTuples(base, mbb, tuples.elementCount().getAsLong());
230             });
231         }
232     }
233 
234     @Test
235     public void testDefaultAccessModesMappedSegment() throws Throwable {
236         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {
237             assertTrue(segment.hasAccessModes(ALL_ACCESS));
238             assertEquals(segment.accessModes(), ALL_ACCESS);
239         }
240 
241         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {
242             assertTrue(segment.hasAccessModes(ALL_ACCESS &amp; ~WRITE));
243             assertEquals(segment.accessModes(), ALL_ACCESS &amp; ~WRITE);
244         }
245     }
246 
247     @Test
248     public void testMappedSegment() throws Throwable {
249         File f = new File(&quot;test2.out&quot;);
250         f.createNewFile();
251         f.deleteOnExit();
252 
253         //write to channel
254         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
<span class="line-modified">255             MemoryAddress base = segment.baseAddress();</span>
256             initTuples(base, tuples.elementCount().getAsLong());
257             segment.force();
258         }
259 
260         //read from channel
261         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
<span class="line-modified">262             MemoryAddress base = segment.baseAddress();</span>
263             checkTuples(base, segment.asByteBuffer(), tuples.elementCount().getAsLong());
264         }
265     }
266 
267     @Test
268     public void testMappedSegmentOffset() throws Throwable {
269         File f = new File(&quot;test3.out&quot;);
270         f.createNewFile();
271         f.deleteOnExit();
272 
273         MemoryLayout tupleLayout = tuples.elementLayout();
274 
275         // write one at a time
276         for (int i = 0 ; i &lt; tuples.byteSize() ; i += tupleLayout.byteSize()) {
277             //write to channel
278             try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
<span class="line-modified">279                 MemoryAddress base = segment.baseAddress();</span>
280                 initTuples(base, 1);
281                 segment.force();
282             }
283         }
284 
285         // check one at a time
286         for (int i = 0 ; i &lt; tuples.byteSize() ; i += tupleLayout.byteSize()) {
287             //read from channel
288             try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
<span class="line-modified">289                 MemoryAddress base = segment.baseAddress();</span>
290                 checkTuples(base, segment.asByteBuffer(), 1);
291             }
292         }
293     }
294 
295     static void withMappedBuffer(FileChannel channel, FileChannel.MapMode mode, long pos, long size, Consumer&lt;MappedByteBuffer&gt; action) throws Throwable {
296         MappedByteBuffer mbb = channel.map(mode, pos, size);
297         var ref = new WeakReference&lt;&gt;(mbb);
298         action.accept(mbb);
299         mbb = null;
300         //wait for it to be GCed
301         System.gc();
302         while (ref.get() != null) {
303             Thread.sleep(20);
304         }
305     }
306 
307     static void checkByteArrayAlignment(MemoryLayout layout) {
308         if (layout.bitSize() &gt; 32
309                 &amp;&amp; System.getProperty(&quot;sun.arch.data.model&quot;).equals(&quot;32&quot;)) {
310             throw new SkipException(&quot;avoid unaligned access on 32-bit system&quot;);
311         }
312     }
313 
314     @Test(dataProvider = &quot;bufferOps&quot;)
315     public void testScopedBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
316         Buffer bb;
317         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
<span class="line-modified">318             MemoryAddress base = segment.baseAddress();</span>
319             bb = bufferFactory.apply(segment.asByteBuffer());
320         }
321         //outside of scope!!
322         for (Map.Entry&lt;Method, Object[]&gt; e : members.entrySet()) {
323             if (!e.getKey().getName().contains(&quot;get&quot;) &amp;&amp;
324                             !e.getKey().getName().contains(&quot;put&quot;)) {
325                 //skip
326                 return;
327             }
328             try {
329                 e.getKey().invoke(bb, e.getValue());
330                 assertTrue(false);
331             } catch (InvocationTargetException ex) {
332                 Throwable cause = ex.getCause();
333                 if (cause instanceof IllegalStateException) {
334                     //all get/set buffer operation should fail because of the scope check
335                     assertTrue(ex.getCause().getMessage().contains(&quot;already closed&quot;));
336                 } else {
337                     //all other exceptions were unexpected - fail
338                     assertTrue(false);
</pre>
<hr />
<pre>
364         }
365         for (Map.Entry&lt;MethodHandle, Object[]&gt; e : varHandleMembers(bb, bufferHandle).entrySet()) {
366             try {
367                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
368                         .asSpreader(Object[].class, e.getValue().length);
369                 handle.invoke(e.getValue());
370                 fail();
371             } catch (IllegalStateException ex) {
372                 assertTrue(ex.getMessage().contains(&quot;already closed&quot;));
373             } catch (UnsupportedOperationException ex) {
374                 //skip
375             } catch (Throwable ex) {
376                 fail();
377             }
378         }
379     }
380 
381     @Test(dataProvider = &quot;bufferOps&quot;)
382     public void testDirectBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
383         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
<span class="line-modified">384             MemoryAddress base = segment.baseAddress();</span>
385             Buffer bb = bufferFactory.apply(segment.asByteBuffer());
386             assertTrue(bb.isDirect());
387             DirectBuffer directBuffer = ((DirectBuffer)bb);
388             assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
389             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
390             assertTrue(directBuffer.cleaner() == null);
391         }
392     }
393 
394     @Test(dataProvider=&quot;resizeOps&quot;)
395     public void testResizeOffheap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
396         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
<span class="line-modified">397             MemoryAddress base = segment.baseAddress();</span>
398             initializer.accept(base);
399             checker.accept(base);
400         }
401     }
402 
403     @Test(dataProvider=&quot;resizeOps&quot;)
404     public void testResizeHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
405         checkByteArrayAlignment(seq.elementLayout());
406         int capacity = (int)seq.byteSize();
<span class="line-modified">407         MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).baseAddress();</span>
408         initializer.accept(base);
409         checker.accept(base);
410     }
411 
412     @Test(dataProvider=&quot;resizeOps&quot;)
413     public void testResizeBuffer(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
414         checkByteArrayAlignment(seq.elementLayout());
415         int capacity = (int)seq.byteSize();
<span class="line-modified">416         MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).baseAddress();</span>
417         initializer.accept(base);
418         checker.accept(base);
419     }
420 
421     @Test(dataProvider=&quot;resizeOps&quot;)
422     public void testResizeRoundtripHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
423         checkByteArrayAlignment(seq.elementLayout());
424         int capacity = (int)seq.byteSize();
425         byte[] arr = new byte[capacity];
426         MemorySegment segment = MemorySegment.ofArray(arr);
<span class="line-modified">427         MemoryAddress first = segment.baseAddress();</span>
428         initializer.accept(first);
<span class="line-modified">429         MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();</span>
430         checker.accept(second);
431     }
432 
433     @Test(dataProvider=&quot;resizeOps&quot;)
434     public void testResizeRoundtripNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
435         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
<span class="line-modified">436             MemoryAddress first = segment.baseAddress();</span>
437             initializer.accept(first);
<span class="line-modified">438             MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();</span>
439             checker.accept(second);
440         }
441     }
442 
443     @Test(expectedExceptions = IllegalStateException.class)
444     public void testBufferOnClosedScope() {
445         MemorySegment leaked;
446         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
447             leaked = segment;
448         }
449         ByteBuffer byteBuffer = leaked.asByteBuffer(); // ok
450         byteBuffer.get(); // should throw
451     }
452 
453     @Test(expectedExceptions = { UnsupportedOperationException.class,
454                                  IllegalArgumentException.class })
455     public void testTooBigForByteBuffer() {
456         try (MemorySegment segment = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {
457             segment.asByteBuffer();
458         }
</pre>
<hr />
<pre>
472         f.createNewFile();
473         f.deleteOnExit();
474         MemorySegment.mapFromPath(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);
475     }
476 
477     public void testMapZeroSize() throws IOException {
478         File f = new File(&quot;testPos1.out&quot;);
479         f.createNewFile();
480         f.deleteOnExit();
481         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {
482             assertEquals(segment.byteSize(), 0);
483         }
484     }
485 
486     @Test(dataProvider=&quot;resizeOps&quot;)
487     public void testCopyHeapToNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
488         checkByteArrayAlignment(seq.elementLayout());
489         int bytes = (int)seq.byteSize();
490         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
491              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
<span class="line-modified">492             initializer.accept(heapArray.baseAddress());</span>
493             nativeArray.copyFrom(heapArray);
<span class="line-modified">494             checker.accept(nativeArray.baseAddress());</span>
495         }
496     }
497 
498     @Test(dataProvider=&quot;resizeOps&quot;)
499     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
500         checkByteArrayAlignment(seq.elementLayout());
501         int bytes = (int)seq.byteSize();
502         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
503              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
<span class="line-modified">504             initializer.accept(nativeArray.baseAddress());</span>
505             heapArray.copyFrom(nativeArray);
<span class="line-modified">506             checker.accept(heapArray.baseAddress());</span>
507         }
508     }
509 
510     @Test
511     public void testDefaultAccessModesOfBuffer() {
512         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);
513         try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {
514             assertTrue(segment.hasAccessModes(ALL_ACCESS));
515             assertEquals(segment.accessModes(), ALL_ACCESS);
516         }
517 
518         ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();
519         try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {
520             assertTrue(segment.hasAccessModes(ALL_ACCESS &amp; ~WRITE));
521             assertEquals(segment.accessModes(), ALL_ACCESS &amp; ~WRITE);
522         }
523     }
524 
525     @Test(dataProvider=&quot;bufferSources&quot;)
526     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
</pre>
<hr />
<pre>
538         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
539         assertEquals(bb.capacity(), segment.byteSize());
540     }
541 
542     @Test
543     public void testRoundTripAccess() {
544         try(MemorySegment ms = MemorySegment.allocateNative(4)) {
545             MemorySegment msNoAccess = ms.withAccessModes(MemorySegment.READ); // READ is required to make BB
546             MemorySegment msRoundTrip = MemorySegment.ofByteBuffer(msNoAccess.asByteBuffer());
547             assertEquals(msNoAccess.accessModes(), msRoundTrip.accessModes());
548         }
549     }
550 
551     @Test(expectedExceptions = IllegalStateException.class)
552     public void testDeadAccessOnClosedBufferSegment() {
553         MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);
554         MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());
555 
556         s1.close(); // memory freed
557 
<span class="line-modified">558         MemoryAccess.setInt(s2.baseAddress(), 10); // Dead access!</span>
559     }
560 
561     @DataProvider(name = &quot;bufferOps&quot;)
562     public static Object[][] bufferOps() throws Throwable {
563         return new Object[][]{
564                 { (Function&lt;ByteBuffer, Buffer&gt;) bb -&gt; bb, bufferMembers(ByteBuffer.class)},
565                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asCharBuffer, bufferMembers(CharBuffer.class)},
566                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asShortBuffer, bufferMembers(ShortBuffer.class)},
567                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asIntBuffer, bufferMembers(IntBuffer.class)},
568                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asFloatBuffer, bufferMembers(FloatBuffer.class)},
569                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asLongBuffer, bufferMembers(LongBuffer.class)},
570                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asDoubleBuffer, bufferMembers(DoubleBuffer.class)},
571         };
572     }
573 
574     static Map&lt;Method, Object[]&gt; bufferMembers(Class&lt;?&gt; bufferClass) {
575         Map&lt;Method, Object[]&gt; members = new HashMap&lt;&gt;();
576         for (Method m : bufferClass.getMethods()) {
577             //skip statics and method declared in j.l.Object
578             if (m.getDeclaringClass().equals(Object.class) ||
</pre>
</td>
<td>
<hr />
<pre>
153     }
154 
155     static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer&lt;MemoryAddress, Long&gt; handleSetter) {
156         for (long i = 0; i &lt; seq.elementCount().getAsLong() ; i++) {
157             handleSetter.accept(base, i);
158         }
159     }
160 
161     static &lt;Z extends Buffer&gt; void checkBytes(MemoryAddress base, SequenceLayout layout,
162                                               Function&lt;ByteBuffer, Z&gt; bufFactory,
163                                               BiFunction&lt;MemoryAddress, Long, Object&gt; handleExtractor,
164                                               Function&lt;Z, Object&gt; bufferExtractor) {
165         long nelems = layout.elementCount().getAsLong();
166         long elemSize = layout.elementLayout().byteSize();
167         for (long i = 0 ; i &lt; nelems ; i++) {
168             long limit = nelems - i;
169             MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);
170             ByteBuffer bb = resizedSegment.asByteBuffer();
171             Z z = bufFactory.apply(bb);
172             for (long j = i ; j &lt; limit ; j++) {
<span class="line-modified">173                 Object handleValue = handleExtractor.apply(resizedSegment.address(), j - i);</span>
174                 Object bufferValue = bufferExtractor.apply(z);
175                 if (handleValue instanceof Number) {
176                     assertEquals(((Number)handleValue).longValue(), j);
177                     assertEquals(((Number)bufferValue).longValue(), j);
178                 } else {
179                     assertEquals((long)(char)handleValue, j);
180                     assertEquals((long)(char)bufferValue, j);
181                 }
182             }
183         }
184     }
185 
186     @Test
187     public void testOffheap() {
188         try (MemorySegment segment = MemorySegment.allocateNative(tuples)) {
<span class="line-modified">189             MemoryAddress base = segment.address();</span>
190             initTuples(base, tuples.elementCount().getAsLong());
191 
192             ByteBuffer bb = segment.asByteBuffer();
193             checkTuples(base, bb, tuples.elementCount().getAsLong());
194         }
195     }
196 
197     @Test
198     public void testHeap() {
199         byte[] arr = new byte[(int) tuples.byteSize()];
200         MemorySegment region = MemorySegment.ofArray(arr);
<span class="line-modified">201         MemoryAddress base = region.address();</span>
202         initTuples(base, tuples.elementCount().getAsLong());
203 
204         ByteBuffer bb = region.asByteBuffer();
205         checkTuples(base, bb, tuples.elementCount().getAsLong());
206     }
207 
208     @Test
209     public void testChannel() throws Throwable {
210         File f = new File(&quot;test.out&quot;);
211         assertTrue(f.createNewFile());
212         f.deleteOnExit();
213 
214         //write to channel
215         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
216             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -&gt; {
217                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
<span class="line-modified">218                 MemoryAddress base = segment.address();</span>
219                 initTuples(base, tuples.elementCount().getAsLong());
220                 mbb.force();
221             });
222         }
223 
224         //read from channel
225         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
226             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -&gt; {
227                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
<span class="line-modified">228                 MemoryAddress base = segment.address();</span>
229                 checkTuples(base, mbb, tuples.elementCount().getAsLong());
230             });
231         }
232     }
233 
234     @Test
235     public void testDefaultAccessModesMappedSegment() throws Throwable {
236         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {
237             assertTrue(segment.hasAccessModes(ALL_ACCESS));
238             assertEquals(segment.accessModes(), ALL_ACCESS);
239         }
240 
241         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {
242             assertTrue(segment.hasAccessModes(ALL_ACCESS &amp; ~WRITE));
243             assertEquals(segment.accessModes(), ALL_ACCESS &amp; ~WRITE);
244         }
245     }
246 
247     @Test
248     public void testMappedSegment() throws Throwable {
249         File f = new File(&quot;test2.out&quot;);
250         f.createNewFile();
251         f.deleteOnExit();
252 
253         //write to channel
254         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
<span class="line-modified">255             MemoryAddress base = segment.address();</span>
256             initTuples(base, tuples.elementCount().getAsLong());
257             segment.force();
258         }
259 
260         //read from channel
261         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
<span class="line-modified">262             MemoryAddress base = segment.address();</span>
263             checkTuples(base, segment.asByteBuffer(), tuples.elementCount().getAsLong());
264         }
265     }
266 
267     @Test
268     public void testMappedSegmentOffset() throws Throwable {
269         File f = new File(&quot;test3.out&quot;);
270         f.createNewFile();
271         f.deleteOnExit();
272 
273         MemoryLayout tupleLayout = tuples.elementLayout();
274 
275         // write one at a time
276         for (int i = 0 ; i &lt; tuples.byteSize() ; i += tupleLayout.byteSize()) {
277             //write to channel
278             try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
<span class="line-modified">279                 MemoryAddress base = segment.address();</span>
280                 initTuples(base, 1);
281                 segment.force();
282             }
283         }
284 
285         // check one at a time
286         for (int i = 0 ; i &lt; tuples.byteSize() ; i += tupleLayout.byteSize()) {
287             //read from channel
288             try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
<span class="line-modified">289                 MemoryAddress base = segment.address();</span>
290                 checkTuples(base, segment.asByteBuffer(), 1);
291             }
292         }
293     }
294 
295     static void withMappedBuffer(FileChannel channel, FileChannel.MapMode mode, long pos, long size, Consumer&lt;MappedByteBuffer&gt; action) throws Throwable {
296         MappedByteBuffer mbb = channel.map(mode, pos, size);
297         var ref = new WeakReference&lt;&gt;(mbb);
298         action.accept(mbb);
299         mbb = null;
300         //wait for it to be GCed
301         System.gc();
302         while (ref.get() != null) {
303             Thread.sleep(20);
304         }
305     }
306 
307     static void checkByteArrayAlignment(MemoryLayout layout) {
308         if (layout.bitSize() &gt; 32
309                 &amp;&amp; System.getProperty(&quot;sun.arch.data.model&quot;).equals(&quot;32&quot;)) {
310             throw new SkipException(&quot;avoid unaligned access on 32-bit system&quot;);
311         }
312     }
313 
314     @Test(dataProvider = &quot;bufferOps&quot;)
315     public void testScopedBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
316         Buffer bb;
317         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
<span class="line-modified">318             MemoryAddress base = segment.address();</span>
319             bb = bufferFactory.apply(segment.asByteBuffer());
320         }
321         //outside of scope!!
322         for (Map.Entry&lt;Method, Object[]&gt; e : members.entrySet()) {
323             if (!e.getKey().getName().contains(&quot;get&quot;) &amp;&amp;
324                             !e.getKey().getName().contains(&quot;put&quot;)) {
325                 //skip
326                 return;
327             }
328             try {
329                 e.getKey().invoke(bb, e.getValue());
330                 assertTrue(false);
331             } catch (InvocationTargetException ex) {
332                 Throwable cause = ex.getCause();
333                 if (cause instanceof IllegalStateException) {
334                     //all get/set buffer operation should fail because of the scope check
335                     assertTrue(ex.getCause().getMessage().contains(&quot;already closed&quot;));
336                 } else {
337                     //all other exceptions were unexpected - fail
338                     assertTrue(false);
</pre>
<hr />
<pre>
364         }
365         for (Map.Entry&lt;MethodHandle, Object[]&gt; e : varHandleMembers(bb, bufferHandle).entrySet()) {
366             try {
367                 MethodHandle handle = e.getKey().bindTo(bufferHandle)
368                         .asSpreader(Object[].class, e.getValue().length);
369                 handle.invoke(e.getValue());
370                 fail();
371             } catch (IllegalStateException ex) {
372                 assertTrue(ex.getMessage().contains(&quot;already closed&quot;));
373             } catch (UnsupportedOperationException ex) {
374                 //skip
375             } catch (Throwable ex) {
376                 fail();
377             }
378         }
379     }
380 
381     @Test(dataProvider = &quot;bufferOps&quot;)
382     public void testDirectBuffer(Function&lt;ByteBuffer, Buffer&gt; bufferFactory, Map&lt;Method, Object[]&gt; members) {
383         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
<span class="line-modified">384             MemoryAddress base = segment.address();</span>
385             Buffer bb = bufferFactory.apply(segment.asByteBuffer());
386             assertTrue(bb.isDirect());
387             DirectBuffer directBuffer = ((DirectBuffer)bb);
388             assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
389             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
390             assertTrue(directBuffer.cleaner() == null);
391         }
392     }
393 
394     @Test(dataProvider=&quot;resizeOps&quot;)
395     public void testResizeOffheap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
396         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
<span class="line-modified">397             MemoryAddress base = segment.address();</span>
398             initializer.accept(base);
399             checker.accept(base);
400         }
401     }
402 
403     @Test(dataProvider=&quot;resizeOps&quot;)
404     public void testResizeHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
405         checkByteArrayAlignment(seq.elementLayout());
406         int capacity = (int)seq.byteSize();
<span class="line-modified">407         MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).address();</span>
408         initializer.accept(base);
409         checker.accept(base);
410     }
411 
412     @Test(dataProvider=&quot;resizeOps&quot;)
413     public void testResizeBuffer(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
414         checkByteArrayAlignment(seq.elementLayout());
415         int capacity = (int)seq.byteSize();
<span class="line-modified">416         MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).address();</span>
417         initializer.accept(base);
418         checker.accept(base);
419     }
420 
421     @Test(dataProvider=&quot;resizeOps&quot;)
422     public void testResizeRoundtripHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
423         checkByteArrayAlignment(seq.elementLayout());
424         int capacity = (int)seq.byteSize();
425         byte[] arr = new byte[capacity];
426         MemorySegment segment = MemorySegment.ofArray(arr);
<span class="line-modified">427         MemoryAddress first = segment.address();</span>
428         initializer.accept(first);
<span class="line-modified">429         MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).address();</span>
430         checker.accept(second);
431     }
432 
433     @Test(dataProvider=&quot;resizeOps&quot;)
434     public void testResizeRoundtripNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
435         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
<span class="line-modified">436             MemoryAddress first = segment.address();</span>
437             initializer.accept(first);
<span class="line-modified">438             MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).address();</span>
439             checker.accept(second);
440         }
441     }
442 
443     @Test(expectedExceptions = IllegalStateException.class)
444     public void testBufferOnClosedScope() {
445         MemorySegment leaked;
446         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
447             leaked = segment;
448         }
449         ByteBuffer byteBuffer = leaked.asByteBuffer(); // ok
450         byteBuffer.get(); // should throw
451     }
452 
453     @Test(expectedExceptions = { UnsupportedOperationException.class,
454                                  IllegalArgumentException.class })
455     public void testTooBigForByteBuffer() {
456         try (MemorySegment segment = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {
457             segment.asByteBuffer();
458         }
</pre>
<hr />
<pre>
472         f.createNewFile();
473         f.deleteOnExit();
474         MemorySegment.mapFromPath(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);
475     }
476 
477     public void testMapZeroSize() throws IOException {
478         File f = new File(&quot;testPos1.out&quot;);
479         f.createNewFile();
480         f.deleteOnExit();
481         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {
482             assertEquals(segment.byteSize(), 0);
483         }
484     }
485 
486     @Test(dataProvider=&quot;resizeOps&quot;)
487     public void testCopyHeapToNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
488         checkByteArrayAlignment(seq.elementLayout());
489         int bytes = (int)seq.byteSize();
490         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
491              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
<span class="line-modified">492             initializer.accept(heapArray.address());</span>
493             nativeArray.copyFrom(heapArray);
<span class="line-modified">494             checker.accept(nativeArray.address());</span>
495         }
496     }
497 
498     @Test(dataProvider=&quot;resizeOps&quot;)
499     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
500         checkByteArrayAlignment(seq.elementLayout());
501         int bytes = (int)seq.byteSize();
502         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
503              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
<span class="line-modified">504             initializer.accept(nativeArray.address());</span>
505             heapArray.copyFrom(nativeArray);
<span class="line-modified">506             checker.accept(heapArray.address());</span>
507         }
508     }
509 
510     @Test
511     public void testDefaultAccessModesOfBuffer() {
512         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);
513         try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {
514             assertTrue(segment.hasAccessModes(ALL_ACCESS));
515             assertEquals(segment.accessModes(), ALL_ACCESS);
516         }
517 
518         ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();
519         try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {
520             assertTrue(segment.hasAccessModes(ALL_ACCESS &amp; ~WRITE));
521             assertEquals(segment.accessModes(), ALL_ACCESS &amp; ~WRITE);
522         }
523     }
524 
525     @Test(dataProvider=&quot;bufferSources&quot;)
526     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {
</pre>
<hr />
<pre>
538         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));
539         assertEquals(bb.capacity(), segment.byteSize());
540     }
541 
542     @Test
543     public void testRoundTripAccess() {
544         try(MemorySegment ms = MemorySegment.allocateNative(4)) {
545             MemorySegment msNoAccess = ms.withAccessModes(MemorySegment.READ); // READ is required to make BB
546             MemorySegment msRoundTrip = MemorySegment.ofByteBuffer(msNoAccess.asByteBuffer());
547             assertEquals(msNoAccess.accessModes(), msRoundTrip.accessModes());
548         }
549     }
550 
551     @Test(expectedExceptions = IllegalStateException.class)
552     public void testDeadAccessOnClosedBufferSegment() {
553         MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);
554         MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());
555 
556         s1.close(); // memory freed
557 
<span class="line-modified">558         MemoryAccess.setInt(s2.address(), 10); // Dead access!</span>
559     }
560 
561     @DataProvider(name = &quot;bufferOps&quot;)
562     public static Object[][] bufferOps() throws Throwable {
563         return new Object[][]{
564                 { (Function&lt;ByteBuffer, Buffer&gt;) bb -&gt; bb, bufferMembers(ByteBuffer.class)},
565                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asCharBuffer, bufferMembers(CharBuffer.class)},
566                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asShortBuffer, bufferMembers(ShortBuffer.class)},
567                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asIntBuffer, bufferMembers(IntBuffer.class)},
568                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asFloatBuffer, bufferMembers(FloatBuffer.class)},
569                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asLongBuffer, bufferMembers(LongBuffer.class)},
570                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asDoubleBuffer, bufferMembers(DoubleBuffer.class)},
571         };
572     }
573 
574     static Map&lt;Method, Object[]&gt; bufferMembers(Class&lt;?&gt; bufferClass) {
575         Map&lt;Method, Object[]&gt; members = new HashMap&lt;&gt;();
576         for (Method m : bufferClass.getMethods()) {
577             //skip statics and method declared in j.l.Object
578             if (m.getDeclaringClass().equals(Object.class) ||
</pre>
</td>
</tr>
</table>
<center><a href="TestArrays.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayouts.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
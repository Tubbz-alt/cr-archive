diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Addressable.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Addressable.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Addressable.java
@@ -0,0 +1,21 @@
+package jdk.incubator.foreign;
+
+/**
+ * Represents a type which is <em>addressable</em>. An addressable type is one which can projected down to
+ * a memory address instance (see {@link #address()}). Examples of addressable types are {@link MemorySegment},
+ * and {@link MemoryAddress}.
+ *
+ * @apiNote In the future, if the Java language permits, {@link Addressable}
+ * may become a {@code sealed} interface, which would prohibit subclassing except by
+ * explicitly permitted types, such as {@link MemorySegment} and {@link MemoryAddress}.
+ *
+ * @implSpec
+ * Implementations of this interface <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>.
+ */
+public interface Addressable {
+    /**
+     * Map this object into a {@link MemoryAddress} instance.
+     * @return the {@link MemoryAddress} instance associated with this object.
+     */
+    MemoryAddress address();
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -28,11 +28,11 @@
 
 import jdk.internal.foreign.MemoryAddressImpl;
 
 /**
  * A memory address models a reference into a memory location. Memory addresses are typically obtained using the
- * {@link MemorySegment#baseAddress()} method; such addresses are said to be <em>checked</em>, and can be expressed
+ * {@link MemorySegment#address()} method; such addresses are said to be <em>checked</em>, and can be expressed
  * as <em>offsets</em> into some underlying memory segment (see {@link #segment()} and {@link #segmentOffset()}).
  * Since checked memory addresses feature both spatial and temporal bounds, these addresses can <em>safely</em> be
  * dereferenced using a memory access var handle (see {@link MemoryHandles}).
  * <p>
  * If an address does not have any associated segment, it is said to be <em>unchecked</em>. Unchecked memory
@@ -52,11 +52,17 @@
  * explicitly permitted types.
  *
  * @implSpec
  * Implementations of this interface are immutable, thread-safe and <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>.
  */
-public interface MemoryAddress {
+public interface MemoryAddress extends Addressable {
+
+    @Override
+    default MemoryAddress address() {
+        return this;
+    }
+
     /**
      * Creates a new memory address with given offset (in bytes), which might be negative, from current one.
      * @param offset specified offset (in bytes), relative to this address, which should be used to create the new address.
      * @return a new memory address with given offset from current one.
      */
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -167,19 +167,20 @@
  * {@link MappedMemorySegment} and other explicitly permitted subtypes.
  *
  * @implSpec
  * Implementations of this interface are immutable, thread-safe and <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>.
  */
-public interface MemorySegment extends AutoCloseable {
+public interface MemorySegment extends Addressable, AutoCloseable {
 
     /**
      * The base memory address associated with this memory segment. The returned address is
-     * a <em>checked</em> memory address and can therefore be used in derefrence operations
+     * a <em>checked</em> memory address and can therefore be used in dereference operations
      * (see {@link MemoryAddress}).
      * @return The base memory address.
      */
-    MemoryAddress baseAddress();
+    @Override
+    MemoryAddress address();
 
     /**
      * Returns a spliterator for the given memory segment. The returned spliterator reports {@link Spliterator#SIZED},
      * {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE}, {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED}
      * characteristics.
@@ -347,11 +348,11 @@
     void copyFrom(MemorySegment src);
 
     /**
      * Finds and returns the offset, in bytes, of the first mismatch between
      * this segment and a given other segment. The offset is relative to the
-     * {@link #baseAddress() base address} of each segment and will be in the
+     * {@link #address() base address} of each segment and will be in the
      * range of 0 (inclusive) up to the {@link #byteSize() size} (in bytes) of
      * the smaller memory segment (exclusive).
      * <p>
      * If the two segments share a common prefix then the returned offset is
      * the length of the common prefix and it follows that there is a mismatch
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -149,11 +149,11 @@
             return -1;
         }
 
         long i = 0;
         if (length > 7) {
-            if ((byte) BYTE_HANDLE.get(this.baseAddress(), 0) != (byte) BYTE_HANDLE.get(that.baseAddress(), 0)) {
+            if ((byte) BYTE_HANDLE.get(this.address(), 0) != (byte) BYTE_HANDLE.get(that.address(), 0)) {
                 return 0;
             }
             i = ArraysSupport.vectorizedMismatchLargeForBytes(
                     this.base(), this.min(),
                     that.base(), that.min(),
@@ -163,23 +163,23 @@
             }
             long remaining = ~i;
             assert remaining < 8 : "remaining greater than 7: " + remaining;
             i = length - remaining;
         }
-        MemoryAddress thisAddress = this.baseAddress();
-        MemoryAddress thatAddress = that.baseAddress();
+        MemoryAddress thisAddress = this.address();
+        MemoryAddress thatAddress = that.address();
         for (; i < length; i++) {
             if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {
                 return i;
             }
         }
         return thisSize != thatSize ? length : -1;
     }
 
     @Override
     @ForceInline
-    public final MemoryAddress baseAddress() {
+    public final MemoryAddress address() {
         return new MemoryAddressImpl(this, 0);
     }
 
     @Override
     public final ByteBuffer asByteBuffer() {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -88,11 +88,11 @@
         AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
         if (segmentImpl.base() != this.segment.base()) {
             throw new IllegalArgumentException("Invalid rebase target: " + segment);
         }
         return new MemoryAddressImpl((AbstractMemorySegmentImpl)segment,
-                unsafeGetOffset() - ((MemoryAddressImpl)segment.baseAddress()).unsafeGetOffset());
+                unsafeGetOffset() - ((MemoryAddressImpl)segment.address()).unsafeGetOffset());
     }
 
     // MemoryAddressProxy methods
 
     public void checkAccess(long offset, long length, boolean readOnly) {
diff a/test/jdk/java/foreign/TestAdaptVarHandles.java b/test/jdk/java/foreign/TestAdaptVarHandles.java
--- a/test/jdk/java/foreign/TestAdaptVarHandles.java
+++ b/test/jdk/java/foreign/TestAdaptVarHandles.java
@@ -90,20 +90,20 @@
     public void testFilterValue() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, S2I, I2S);
-        i2SHandle.set(segment.baseAddress(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), "42");
+        i2SHandle.set(segment.address(), "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
         assertEquals(oldValue, "1");
-        String value = (String)i2SHandle.get(segment.baseAddress());
+        String value = (String)i2SHandle.get(segment.address());
         assertEquals(value, "43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
         assertEquals(oldValue, "12");
-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());
+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
         assertEquals(value, "42");
     }
 
     @Test
     public void testFilterValueComposite() throws Throwable {
@@ -111,39 +111,39 @@
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         MethodHandle CTX_S2I = MethodHandles.dropArguments(S2I, 0, String.class, String.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, CTX_S2I, CTX_I2S);
         i2SHandle = MemoryHandles.insertCoordinates(i2SHandle, 1, "a", "b");
-        i2SHandle.set(segment.baseAddress(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), "42");
+        i2SHandle.set(segment.address(), "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
         assertEquals(oldValue, "ab1");
-        String value = (String)i2SHandle.get(segment.baseAddress());
+        String value = (String)i2SHandle.get(segment.address());
         assertEquals(value, "ab43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
         assertEquals(oldValue, "ab12");
-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());
+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
         assertEquals(value, "ab42");
     }
 
     @Test
     public void testFilterValueLoose() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, O2I, I2O);
-        i2SHandle.set(segment.baseAddress(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), "42");
+        i2SHandle.set(segment.address(), "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
         assertEquals(oldValue, "1");
-        String value = (String)i2SHandle.get(segment.baseAddress());
+        String value = (String)i2SHandle.get(segment.address());
         assertEquals(value, "43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
         assertEquals(oldValue, "12");
-        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());
+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
         assertEquals(value, "42");
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterNullTarget() {
@@ -275,11 +275,11 @@
     @Test
     public void testInsertCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandle, 0, segment.baseAddress(), 0L);
+        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandle, 0, segment.address(), 0L);
         intHandle_longIndex.set(1);
         int oldValue = (int)intHandle_longIndex.getAndAdd(42);
         assertEquals(oldValue, 1);
         int value = (int)intHandle_longIndex.get();
         assertEquals(value, 43);
@@ -331,20 +331,20 @@
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_swap = MemoryHandles.permuteCoordinates(intHandle,
                 List.of(long.class, MemoryAddress.class), 1, 0);
-        intHandle_swap.set(0L, segment.baseAddress(), 1);
-        int oldValue = (int)intHandle_swap.getAndAdd(0L, segment.baseAddress(), 42);
+        intHandle_swap.set(0L, segment.address(), 1);
+        int oldValue = (int)intHandle_swap.getAndAdd(0L, segment.address(), 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_swap.get(0L, segment.baseAddress());
+        int value = (int)intHandle_swap.get(0L, segment.address());
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_swap.compareAndSet(0L, segment.baseAddress(), 43, 12);
+        boolean swapped = (boolean)intHandle_swap.compareAndSet(0L, segment.address(), 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_swap.compareAndExchange(0L, segment.baseAddress(), 12, 42);
+        oldValue = (int)intHandle_swap.compareAndExchange(0L, segment.address(), 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_swap.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(0L, segment.baseAddress());
+        value = (int)intHandle_swap.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(0L, segment.address());
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadPermuteCoordinatesNullTarget() {
@@ -391,20 +391,20 @@
     public void testCollectCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_sum = MemoryHandles.collectCoordinates(intHandle, 1, SUM_OFFSETS);
-        intHandle_sum.set(segment.baseAddress(), -2L, 2L, 1);
-        int oldValue = (int)intHandle_sum.getAndAdd(segment.baseAddress(), -2L, 2L, 42);
+        intHandle_sum.set(segment.address(), -2L, 2L, 1);
+        int oldValue = (int)intHandle_sum.getAndAdd(segment.address(), -2L, 2L, 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_sum.get(segment.baseAddress(), -2L, 2L);
+        int value = (int)intHandle_sum.get(segment.address(), -2L, 2L);
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_sum.compareAndSet(segment.baseAddress(), -2L, 2L, 43, 12);
+        boolean swapped = (boolean)intHandle_sum.compareAndSet(segment.address(), -2L, 2L, 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_sum.compareAndExchange(segment.baseAddress(), -2L, 2L, 12, 42);
+        oldValue = (int)intHandle_sum.compareAndExchange(segment.address(), -2L, 2L, 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_sum.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress(), -2L, 2L);
+        value = (int)intHandle_sum.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address(), -2L, 2L);
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadCollectCoordinatesNullTarget() {
@@ -451,20 +451,20 @@
     public void testDropCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_dummy = MemoryHandles.dropCoordinates(intHandle, 1, float.class, String.class);
-        intHandle_dummy.set(segment.baseAddress(), 1f, "hello", 0L, 1);
-        int oldValue = (int)intHandle_dummy.getAndAdd(segment.baseAddress(), 1f, "hello", 0L, 42);
+        intHandle_dummy.set(segment.address(), 1f, "hello", 0L, 1);
+        int oldValue = (int)intHandle_dummy.getAndAdd(segment.address(), 1f, "hello", 0L, 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_dummy.get(segment.baseAddress(), 1f, "hello", 0L);
+        int value = (int)intHandle_dummy.get(segment.address(), 1f, "hello", 0L);
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment.baseAddress(), 1f, "hello", 0L, 43, 12);
+        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment.address(), 1f, "hello", 0L, 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_dummy.compareAndExchange(segment.baseAddress(), 1f, "hello", 0L, 12, 42);
+        oldValue = (int)intHandle_dummy.compareAndExchange(segment.address(), 1f, "hello", 0L, 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress(), 1f, "hello", 0L);
+        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address(), 1f, "hello", 0L);
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadDropCoordinatesNegativePos() {
@@ -506,11 +506,11 @@
     static long stringToLongException(String s) throws Throwable {
         return Long.valueOf(s);
     }
 
     static MemoryAddress baseAddress(MemorySegment segment) {
-        return segment.baseAddress();
+        return segment.address();
     }
 
     static long sumOffsets(long l1, long l2) {
         return l1 + l2;
     }
diff a/test/jdk/java/foreign/TestAddressHandle.java b/test/jdk/java/foreign/TestAddressHandle.java
--- a/test/jdk/java/foreign/TestAddressHandle.java
+++ b/test/jdk/java/foreign/TestAddressHandle.java
@@ -62,33 +62,33 @@
     @Test(dataProvider = "addressHandles")
     public void testAddressHandle(VarHandle addrHandle, int byteSize) {
         VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
             MemoryAddress target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?
-                    segment.baseAddress().addOffset(8 - byteSize) :
-                    segment.baseAddress();
-            longHandle.set(segment.baseAddress(), 42L);
+                    segment.address().addOffset(8 - byteSize) :
+                    segment.address();
+            longHandle.set(segment.address(), 42L);
             MemoryAddress address = (MemoryAddress)addrHandle.get(target);
             assertEquals(address.toRawLongValue(), 42L);
             try {
                 longHandle.get(address); // check that address cannot be de-referenced
                 fail();
             } catch (UnsupportedOperationException ex) {
                 assertTrue(true);
             }
             addrHandle.set(target, address.addOffset(1));
-            long result = (long)longHandle.get(segment.baseAddress());
+            long result = (long)longHandle.get(segment.address());
             assertEquals(43L, result);
         }
     }
 
     @Test(dataProvider = "addressHandles")
     public void testNull(VarHandle addrHandle, int byteSize) {
         VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
-            longHandle.set(segment.baseAddress(), 0L);
-            MemoryAddress address = (MemoryAddress)addrHandle.get(segment.baseAddress());
+            longHandle.set(segment.address(), 0L);
+            MemoryAddress address = (MemoryAddress)addrHandle.get(segment.address());
             assertTrue(address == MemoryAddress.NULL);
         }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
diff a/test/jdk/java/foreign/TestArrays.java b/test/jdk/java/foreign/TestArrays.java
--- a/test/jdk/java/foreign/TestArrays.java
+++ b/test/jdk/java/foreign/TestArrays.java
@@ -37,11 +37,10 @@
 import java.lang.invoke.VarHandle;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Function;
-import java.util.function.ToIntFunction;
 
 import org.testng.annotations.*;
 
 import static jdk.incubator.foreign.MemorySegment.READ;
 import static org.testng.Assert.*;
@@ -101,12 +100,12 @@
     }
 
     @Test(dataProvider = "arrays")
     public void testArrays(Consumer<MemoryAddress> init, Consumer<MemoryAddress> checker, MemoryLayout layout) {
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            init.accept(segment.baseAddress());
-            checker.accept(segment.baseAddress());
+            init.accept(segment.address());
+            checker.accept(segment.address());
         }
     }
 
     @Test(dataProvider = "elemLayouts",
           expectedExceptions = UnsupportedOperationException.class)
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -168,11 +168,11 @@
             long limit = nelems - i;
             MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);
             ByteBuffer bb = resizedSegment.asByteBuffer();
             Z z = bufFactory.apply(bb);
             for (long j = i ; j < limit ; j++) {
-                Object handleValue = handleExtractor.apply(resizedSegment.baseAddress(), j - i);
+                Object handleValue = handleExtractor.apply(resizedSegment.address(), j - i);
                 Object bufferValue = bufferExtractor.apply(z);
                 if (handleValue instanceof Number) {
                     assertEquals(((Number)handleValue).longValue(), j);
                     assertEquals(((Number)bufferValue).longValue(), j);
                 } else {
@@ -184,11 +184,11 @@
     }
 
     @Test
     public void testOffheap() {
         try (MemorySegment segment = MemorySegment.allocateNative(tuples)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             initTuples(base, tuples.elementCount().getAsLong());
 
             ByteBuffer bb = segment.asByteBuffer();
             checkTuples(base, bb, tuples.elementCount().getAsLong());
         }
@@ -196,11 +196,11 @@
 
     @Test
     public void testHeap() {
         byte[] arr = new byte[(int) tuples.byteSize()];
         MemorySegment region = MemorySegment.ofArray(arr);
-        MemoryAddress base = region.baseAddress();
+        MemoryAddress base = region.address();
         initTuples(base, tuples.elementCount().getAsLong());
 
         ByteBuffer bb = region.asByteBuffer();
         checkTuples(base, bb, tuples.elementCount().getAsLong());
     }
@@ -213,21 +213,21 @@
 
         //write to channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -> {
                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
-                MemoryAddress base = segment.baseAddress();
+                MemoryAddress base = segment.address();
                 initTuples(base, tuples.elementCount().getAsLong());
                 mbb.force();
             });
         }
 
         //read from channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -> {
                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
-                MemoryAddress base = segment.baseAddress();
+                MemoryAddress base = segment.address();
                 checkTuples(base, mbb, tuples.elementCount().getAsLong());
             });
         }
     }
 
@@ -250,18 +250,18 @@
         f.createNewFile();
         f.deleteOnExit();
 
         //write to channel
         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             initTuples(base, tuples.elementCount().getAsLong());
             segment.force();
         }
 
         //read from channel
         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             checkTuples(base, segment.asByteBuffer(), tuples.elementCount().getAsLong());
         }
     }
 
     @Test
@@ -274,21 +274,21 @@
 
         // write one at a time
         for (int i = 0 ; i < tuples.byteSize() ; i += tupleLayout.byteSize()) {
             //write to channel
             try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
-                MemoryAddress base = segment.baseAddress();
+                MemoryAddress base = segment.address();
                 initTuples(base, 1);
                 segment.force();
             }
         }
 
         // check one at a time
         for (int i = 0 ; i < tuples.byteSize() ; i += tupleLayout.byteSize()) {
             //read from channel
             try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
-                MemoryAddress base = segment.baseAddress();
+                MemoryAddress base = segment.address();
                 checkTuples(base, segment.asByteBuffer(), 1);
             }
         }
     }
 
@@ -313,11 +313,11 @@
 
     @Test(dataProvider = "bufferOps")
     public void testScopedBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {
         Buffer bb;
         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             bb = bufferFactory.apply(segment.asByteBuffer());
         }
         //outside of scope!!
         for (Map.Entry<Method, Object[]> e : members.entrySet()) {
             if (!e.getKey().getName().contains("get") &&
@@ -379,11 +379,11 @@
     }
 
     @Test(dataProvider = "bufferOps")
     public void testDirectBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {
         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             Buffer bb = bufferFactory.apply(segment.asByteBuffer());
             assertTrue(bb.isDirect());
             DirectBuffer directBuffer = ((DirectBuffer)bb);
             assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
@@ -392,52 +392,52 @@
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeOffheap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             initializer.accept(base);
             checker.accept(base);
         }
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
-        MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).baseAddress();
+        MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).address();
         initializer.accept(base);
         checker.accept(base);
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeBuffer(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
-        MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).baseAddress();
+        MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).address();
         initializer.accept(base);
         checker.accept(base);
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeRoundtripHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
         byte[] arr = new byte[capacity];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress first = segment.baseAddress();
+        MemoryAddress first = segment.address();
         initializer.accept(first);
-        MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();
+        MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).address();
         checker.accept(second);
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeRoundtripNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress first = segment.baseAddress();
+            MemoryAddress first = segment.address();
             initializer.accept(first);
-            MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();
+            MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).address();
             checker.accept(second);
         }
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
@@ -487,25 +487,25 @@
     public void testCopyHeapToNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
-            initializer.accept(heapArray.baseAddress());
+            initializer.accept(heapArray.address());
             nativeArray.copyFrom(heapArray);
-            checker.accept(nativeArray.baseAddress());
+            checker.accept(nativeArray.address());
         }
     }
 
     @Test(dataProvider="resizeOps")
     public void testCopyNativeToHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
-            initializer.accept(nativeArray.baseAddress());
+            initializer.accept(nativeArray.address());
             heapArray.copyFrom(nativeArray);
-            checker.accept(heapArray.baseAddress());
+            checker.accept(heapArray.address());
         }
     }
 
     @Test
     public void testDefaultAccessModesOfBuffer() {
@@ -553,11 +553,11 @@
         MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);
         MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());
 
         s1.close(); // memory freed
 
-        MemoryAccess.setInt(s2.baseAddress(), 10); // Dead access!
+        MemoryAccess.setInt(s2.address(), 10); // Dead access!
     }
 
     @DataProvider(name = "bufferOps")
     public static Object[][] bufferOps() throws Throwable {
         return new Object[][]{
diff a/test/jdk/java/foreign/TestLayouts.java b/test/jdk/java/foreign/TestLayouts.java
--- a/test/jdk/java/foreign/TestLayouts.java
+++ b/test/jdk/java/foreign/TestLayouts.java
@@ -62,18 +62,18 @@
         VarHandle array_elem_handle = layout.varHandle(double.class,
                 MemoryLayout.PathElement.groupElement("arr"),
                 MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(
                 layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement("arr")))) {
-            size_handle.set(segment.baseAddress(), 4);
+            size_handle.set(segment.address(), 4);
             for (int i = 0 ; i < 4 ; i++) {
-                array_elem_handle.set(segment.baseAddress(), i, (double)i);
+                array_elem_handle.set(segment.address(), i, (double)i);
             }
             //check
-            assertEquals(4, (int)size_handle.get(segment.baseAddress()));
+            assertEquals(4, (int)size_handle.get(segment.address()));
             for (int i = 0 ; i < 4 ; i++) {
-                assertEquals((double)i, (double)array_elem_handle.get(segment.baseAddress(), i));
+                assertEquals((double)i, (double)array_elem_handle.get(segment.address(), i));
             }
         }
     }
 
     @Test
@@ -88,18 +88,18 @@
                 MemoryLayout.PathElement.groupElement("arr"),
                 MemoryLayout.PathElement.sequenceElement(0),
                 MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(
                 layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement("arr"), MemoryLayout.PathElement.sequenceElement()))) {
-            size_handle.set(segment.baseAddress(), 4);
+            size_handle.set(segment.address(), 4);
             for (int i = 0 ; i < 4 ; i++) {
-                array_elem_handle.set(segment.baseAddress(), i, (double)i);
+                array_elem_handle.set(segment.address(), i, (double)i);
             }
             //check
-            assertEquals(4, (int)size_handle.get(segment.baseAddress()));
+            assertEquals(4, (int)size_handle.get(segment.address()));
             for (int i = 0 ; i < 4 ; i++) {
-                assertEquals((double)i, (double)array_elem_handle.get(segment.baseAddress(), i));
+                assertEquals((double)i, (double)array_elem_handle.get(segment.address(), i));
             }
         }
     }
 
     @Test
@@ -107,17 +107,17 @@
         MemoryLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
             VarHandle indexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
             // init segment
             for (int i = 0 ; i < 10 ; i++) {
-                indexHandle.set(segment.baseAddress(), (long)i, i);
+                indexHandle.set(segment.address(), (long)i, i);
             }
             //check statically indexed handles
             for (int i = 0 ; i < 10 ; i++) {
                 VarHandle preindexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(i));
-                int expected = (int)indexHandle.get(segment.baseAddress(), (long)i);
-                int found = (int)preindexHandle.get(segment.baseAddress());
+                int expected = (int)indexHandle.get(segment.address(), (long)i);
+                int found = (int)preindexHandle.get(segment.address());
                 assertEquals(expected, found);
             }
         }
     }
 
diff a/test/jdk/java/foreign/TestMemoryAccess.java b/test/jdk/java/foreign/TestMemoryAccess.java
--- a/test/jdk/java/foreign/TestMemoryAccess.java
+++ b/test/jdk/java/foreign/TestMemoryAccess.java
@@ -83,11 +83,11 @@
 
     private void testAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
         MemoryAddress outer_address;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             try {
                 checker.check(handle, addr);
                 if (isRO) {
                     throw new AssertionError(); //not ok, memory should be immutable
                 }
@@ -115,11 +115,11 @@
 
     private void testArrayAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
         MemoryAddress outer_address;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             try {
                 for (int i = 0; i < seq.elementCount().getAsLong(); i++) {
                     checker.check(handle, addr, i);
                 }
                 if (isRO) {
@@ -184,11 +184,11 @@
 
     private void testMatrixAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
         MemoryAddress outer_address;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             try {
                 for (int i = 0; i < seq.elementCount().getAsLong(); i++) {
                     for (int j = 0; j < ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
                         checker.check(handle, addr, i, j);
                     }
diff a/test/jdk/java/foreign/TestMemoryAlignment.java b/test/jdk/java/foreign/TestMemoryAlignment.java
--- a/test/jdk/java/foreign/TestMemoryAlignment.java
+++ b/test/jdk/java/foreign/TestMemoryAlignment.java
@@ -49,11 +49,11 @@
         assertEquals(layout.bitAlignment(), 32);
         ValueLayout aligned = layout.withBitAlignment(align);
         assertEquals(aligned.bitAlignment(), align); //unreasonable alignment here, to make sure access throws
         VarHandle vh = aligned.varHandle(int.class);
         try (MemorySegment segment = MemorySegment.allocateNative(aligned)) {
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             vh.set(addr, -42);
             int val = (int)vh.get(addr);
             assertEquals(val, -42);
         }
     }
@@ -65,11 +65,11 @@
         ValueLayout aligned = layout.withBitAlignment(align);
         MemoryLayout alignedGroup = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, aligned);
         assertEquals(alignedGroup.bitAlignment(), align);
         VarHandle vh = aligned.varHandle(int.class);
         try (MemorySegment segment = MemorySegment.allocateNative(alignedGroup)) {
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             vh.set(addr.addOffset(1L), -42);
             assertEquals(align, 8); //this is the only case where access is aligned
         } catch (IllegalStateException ex) {
             assertNotEquals(align, 8); //if align != 8, access is always unaligned
         }
@@ -92,11 +92,11 @@
     public void testUnalignedSequence(long align) {
         SequenceLayout layout = MemoryLayout.ofSequence(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));
         try {
             VarHandle vh = layout.varHandle(int.class, PathElement.sequenceElement());
             try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-                MemoryAddress addr = segment.baseAddress();
+                MemoryAddress addr = segment.address();
                 for (long i = 0 ; i < 5 ; i++) {
                     vh.set(addr, i, -42);
                 }
             }
         } catch (UnsupportedOperationException ex) {
@@ -116,11 +116,11 @@
         assertEquals(g.bitAlignment(), 8);
         VarHandle vh_c = g.varHandle(byte.class, PathElement.groupElement("a"));
         VarHandle vh_s = g.varHandle(short.class, PathElement.groupElement("b"));
         VarHandle vh_i = g.varHandle(int.class, PathElement.groupElement("c"));
         try (MemorySegment segment = MemorySegment.allocateNative(g)) {
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             vh_c.set(addr, Byte.MIN_VALUE);
             assertEquals(vh_c.get(addr), Byte.MIN_VALUE);
             vh_s.set(addr, Short.MIN_VALUE);
             assertEquals(vh_s.get(addr), Short.MIN_VALUE);
             vh_i.set(addr, Integer.MIN_VALUE);
diff a/test/jdk/java/foreign/TestMemoryCopy.java b/test/jdk/java/foreign/TestMemoryCopy.java
--- a/test/jdk/java/foreign/TestMemoryCopy.java
+++ b/test/jdk/java/foreign/TestMemoryCopy.java
@@ -44,12 +44,12 @@
 
     final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
 
     @Test(dataProvider = "slices")
     public void testCopy(SegmentSlice s1, SegmentSlice s2) {
-        MemoryAddress addr1 = s1.segment.baseAddress();
-        MemoryAddress addr2 = s2.segment.baseAddress();
+        MemoryAddress addr1 = s1.segment.address();
+        MemoryAddress addr2 = s2.segment.address();
         int size = Math.min(s1.size(), s2.size());
         //prepare source and target segments
         for (int i = 0 ; i < size ; i++) {
             BYTE_HANDLE.set(addr2.addOffset(i), (byte)0);
         }
diff a/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java b/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
--- a/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
+++ b/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
@@ -57,14 +57,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_8_BE;
         VarHandle byteHandle = layout.varHandle(byte.class);
         VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.baseAddress(), intValue);
+            intHandle.set(segment.address(), intValue);
             int expectedIntValue = Byte.toUnsignedInt(byteValue);
-            assertEquals((int) intHandle.get(segment.baseAddress()), expectedIntValue);
-            assertEquals((byte) byteHandle.get(segment.baseAddress()), byteValue);
+            assertEquals((int) intHandle.get(segment.address()), expectedIntValue);
+            assertEquals((byte) byteHandle.get(segment.address()), byteValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToByteData")
     public Object[][] unsignedLongToByteData() {
@@ -79,14 +79,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_8_BE;
         VarHandle byteHandle = layout.varHandle(byte.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(byteHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.baseAddress(), longValue);
+            longHandle.set(segment.address(), longValue);
             long expectedLongValue = Byte.toUnsignedLong(byteValue);
-            assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);
-            assertEquals((byte) byteHandle.get(segment.baseAddress()), byteValue);
+            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
+            assertEquals((byte) byteHandle.get(segment.address()), byteValue);
         }
     }
 
     @DataProvider(name = "unsignedIntToShortData")
     public Object[][] unsignedIntToShortData() {
@@ -101,14 +101,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_16_BE;
         VarHandle shortHandle = layout.varHandle(short.class);
         VarHandle intHandle = MemoryHandles.asUnsigned(shortHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.baseAddress(), intValue);
+            intHandle.set(segment.address(), intValue);
             int expectedIntValue = Short.toUnsignedInt(shortValue);
-            assertEquals((int) intHandle.get(segment.baseAddress()), expectedIntValue);
-            assertEquals((short) shortHandle.get(segment.baseAddress()), shortValue);
+            assertEquals((int) intHandle.get(segment.address()), expectedIntValue);
+            assertEquals((short) shortHandle.get(segment.address()), shortValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToShortData")
     public Object[][] unsignedLongToShortData() {
@@ -123,14 +123,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_16_BE;
         VarHandle shortHandle = layout.varHandle(short.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(shortHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.baseAddress(), longValue);
+            longHandle.set(segment.address(), longValue);
             long expectedLongValue = Short.toUnsignedLong(shortValue);
-            assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);
-            assertEquals((short) shortHandle.get(segment.baseAddress()), shortValue);
+            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
+            assertEquals((short) shortHandle.get(segment.address()), shortValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToIntData")
     public Object[][] unsignedLongToIntData() {
@@ -149,36 +149,36 @@
         MemoryLayout layout = MemoryLayouts.BITS_32_BE;
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(intHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.baseAddress(), longValue);
+            longHandle.set(segment.address(), longValue);
             long expectedLongValue = Integer.toUnsignedLong(intValue);
-            assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);
-            assertEquals((int) intHandle.get(segment.baseAddress()), intValue);
+            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
+            assertEquals((int) intHandle.get(segment.address()), intValue);
         }
     }
 
     @Test
     public void testCoordinatesSequenceLayout() {
         MemoryLayout layout = MemoryLayout.ofSequence(2, MemoryLayouts.BITS_8_BE);
         VarHandle byteHandle = layout.varHandle(byte.class, PathElement.sequenceElement());
         VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.baseAddress(), 0L, (int) -1);
-            assertEquals((int) intHandle.get(segment.baseAddress(), 0L), 255);
-            intHandle.set(segment.baseAddress(), 1L, (int) 200);
-            assertEquals((int) intHandle.get(segment.baseAddress(), 1L), 200);
+            intHandle.set(segment.address(), 0L, (int) -1);
+            assertEquals((int) intHandle.get(segment.address(), 0L), 255);
+            intHandle.set(segment.address(), 1L, (int) 200);
+            assertEquals((int) intHandle.get(segment.address(), 1L), 200);
         }
     }
 
     @Test
     public void testCoordinatesStride() {
         byte[] arr = { 0, 0, (byte) 129, 0 };
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress addr = segment.baseAddress();
+        MemoryAddress addr = segment.address();
 
         {
             VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
             VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
             VarHandle strideHandle = MemoryHandles.withStride(intHandle, 1);
diff a/test/jdk/java/foreign/TestMismatch.java b/test/jdk/java/foreign/TestMismatch.java
--- a/test/jdk/java/foreign/TestMismatch.java
+++ b/test/jdk/java/foreign/TestMismatch.java
@@ -45,11 +45,11 @@
 
     final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
 
     // stores a increasing sequence of values into the memory of the given segment
     static MemorySegment initializeSegment(MemorySegment segment) {
-        MemoryAddress addr = segment.baseAddress();
+        MemoryAddress addr = segment.address();
         for (int i = 0 ; i < segment.byteSize() ; i++) {
             BYTE_HANDLE.set(addr.addOffset(i), (byte)i);
         }
         return segment;
     }
@@ -79,11 +79,11 @@
         s1 = initializeSegment(s1);
         s2 = initializeSegment(s2);
 
         for (long i = s2.byteSize() -1 ; i >= 0; i--) {
             long expectedMismatchOffset = i;
-            BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);
+            BYTE_HANDLE.set(s2.address().addOffset(i), (byte) 0xFF);
 
             if (s1.byteSize() == s2.byteSize()) {
                 assertEquals(s1.mismatch(s2), expectedMismatchOffset);
                 assertEquals(s2.mismatch(s1), expectedMismatchOffset);
             } else if (s1.byteSize() > s2.byteSize()) {
@@ -133,11 +133,11 @@
         }
     }
 
     private void testLargeMismatchAcrossMaxBoundary(MemorySegment s1, MemorySegment s2) {
         for (long i = s2.byteSize() -1 ; i >= Integer.MAX_VALUE - 10L; i--) {
-            BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);
+            BYTE_HANDLE.set(s2.address().addOffset(i), (byte) 0xFF);
             long expectedMismatchOffset = i;
             assertEquals(s1.mismatch(s2), expectedMismatchOffset);
             assertEquals(s2.mismatch(s1), expectedMismatchOffset);
         }
     }
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -153,11 +153,11 @@
     public static native void free(long address);
 
     @Test(dataProvider="nativeAccessOps")
     public void testNativeAccess(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress address = segment.baseAddress();
+            MemoryAddress address = segment.address();
             initializer.accept(address);
             checker.accept(address);
         }
     }
 
@@ -214,11 +214,11 @@
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadResize() {
         try (MemorySegment segment = MemorySegment.allocateNative(4)) {
-            MemorySegment.ofNativeRestricted(segment.baseAddress(), 0, null, null, null);
+            MemorySegment.ofNativeRestricted(segment.address(), 0, null, null, null);
         }
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testNullUnsafeSegment() {
diff a/test/jdk/java/foreign/TestRebase.java b/test/jdk/java/foreign/TestRebase.java
--- a/test/jdk/java/foreign/TestRebase.java
+++ b/test/jdk/java/foreign/TestRebase.java
@@ -48,28 +48,28 @@
 
     @Test(dataProvider = "slices")
     public void testRebase(SegmentSlice s1, SegmentSlice s2) {
         if (s1.contains(s2)) {
             //check that an address and its rebased counterpart point to same element
-            MemoryAddress base = s2.segment.baseAddress();
+            MemoryAddress base = s2.segment.address();
             MemoryAddress rebased = base.rebase(s1.segment);
             for (int i = 0; i < s2.size(); i++) {
                 int expected = (int) BYTE_VH.get(base.addOffset(i));
                 int found = (int) BYTE_VH.get(rebased.addOffset(i));
                 assertEquals(found, expected);
             }
         } else if (s1.kind != s2.kind) {
             // check that rebase s1 to s2 fails
             try {
-                s1.segment.baseAddress().rebase(s2.segment);
+                s1.segment.address().rebase(s2.segment);
                 fail("Rebase unexpectedly passed!");
             } catch (IllegalArgumentException ex) {
                 assertTrue(true);
             }
         } else if (!s2.contains(s1)) {
             //disjoint segments - check that rebased address is out of bounds
-            MemoryAddress base = s2.segment.baseAddress();
+            MemoryAddress base = s2.segment.address();
             MemoryAddress rebased = base.rebase(s1.segment);
             for (int i = 0; i < s2.size(); i++) {
                 BYTE_VH.get(base.addOffset(i));
                 try {
                     BYTE_VH.get(rebased.addOffset(i));
@@ -127,11 +127,11 @@
         List<SegmentSlice> slices = new ArrayList<>();
         for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {
             //init root segment
             MemorySegment segment = kind.makeSegment(16);
             for (int i = 0 ; i < 16 ; i++) {
-                BYTE_VH.set(segment.baseAddress().addOffset(i), (byte)i);
+                BYTE_VH.set(segment.address().addOffset(i), (byte)i);
             }
             //compute all slices
             for (int size : sizes) {
                 for (int index = 0 ; index < 16 ; index += size) {
                     MemorySegment slice = segment.asSlice(index, size);
diff a/test/jdk/java/foreign/TestSegments.java b/test/jdk/java/foreign/TestSegments.java
--- a/test/jdk/java/foreign/TestSegments.java
+++ b/test/jdk/java/foreign/TestSegments.java
@@ -92,11 +92,11 @@
     public void testNativeSegmentIsZeroed() {
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(1000)) {
             for (long i = 0 ; i < segment.byteSize() ; i++) {
-                assertEquals(0, (byte)byteHandle.get(segment.baseAddress(), i));
+                assertEquals(0, (byte)byteHandle.get(segment.address(), i));
             }
         }
     }
 
     @Test
@@ -125,21 +125,21 @@
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(10)) {
             //init
             for (byte i = 0 ; i < segment.byteSize() ; i++) {
-                byteHandle.set(segment.baseAddress(), (long)i, i);
+                byteHandle.set(segment.address(), (long)i, i);
             }
             long start = 0;
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             MemoryAddress last = base.addOffset(10);
             while (!base.equals(last)) {
                 MemorySegment slice = segment.asSlice(base.segmentOffset(), 10 - start);
                 for (long i = start ; i < 10 ; i++) {
                     assertEquals(
-                            byteHandle.get(segment.baseAddress(), i),
-                            byteHandle.get(slice.baseAddress(), i - start)
+                            byteHandle.get(segment.address(), i),
+                            byteHandle.get(slice.address(), i - start)
                     );
                 }
                 base = base.addOffset(1);
                 start++;
             }
@@ -195,24 +195,24 @@
 
         for (byte value : new byte[] {(byte) 0xFF, (byte) 0x00, (byte) 0x45}) {
             try (MemorySegment segment = memorySegmentSupplier.get()) {
                 segment.fill(value);
                 for (long l = 0; l < segment.byteSize(); l++) {
-                    assertEquals((byte) byteHandle.get(segment.baseAddress(), l), value);
+                    assertEquals((byte) byteHandle.get(segment.address(), l), value);
                 }
 
                 // fill a slice
                 var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);
                 for (long l = 0; l < sliceSegment.byteSize(); l++) {
-                    assertEquals((byte) byteHandle.get(sliceSegment.baseAddress(), l), ~value);
+                    assertEquals((byte) byteHandle.get(sliceSegment.address(), l), ~value);
                 }
                 // assert enclosing slice
-                assertEquals((byte) byteHandle.get(segment.baseAddress(), 0L), value);
+                assertEquals((byte) byteHandle.get(segment.address(), 0L), value);
                 for (long l = 1; l < segment.byteSize() - 2; l++) {
-                    assertEquals((byte) byteHandle.get(segment.baseAddress(), l), (byte) ~value);
+                    assertEquals((byte) byteHandle.get(segment.address(), l), (byte) ~value);
                 }
-                assertEquals((byte) byteHandle.get(segment.baseAddress(), segment.byteSize() - 1L), value);
+                assertEquals((byte) byteHandle.get(segment.address(), segment.byteSize() - 1L), value);
             }
         }
     }
 
     @Test(dataProvider = "segmentFactories", expectedExceptions = IllegalStateException.class)
@@ -434,17 +434,17 @@
             }
         },
         READ(MemorySegment.READ) {
             @Override
             void run(MemorySegment segment) {
-                INT_HANDLE.get(segment.baseAddress());
+                INT_HANDLE.get(segment.address());
             }
         },
         WRITE(MemorySegment.WRITE) {
             @Override
             void run(MemorySegment segment) {
-                INT_HANDLE.set(segment.baseAddress(), 42);
+                INT_HANDLE.set(segment.address(), 42);
             }
         },
         HANDOFF(MemorySegment.HANDOFF) {
             @Override
             void run(MemorySegment segment) {
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -39,11 +39,10 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Spliterator;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 
 import static org.testng.Assert.assertEquals;
@@ -57,16 +56,16 @@
     @Test
     public void testConfined() throws Throwable {
         Thread owner = Thread.currentThread();
         MemorySegment s = MemorySegment.allocateNative(4);
         AtomicReference<MemorySegment> confined = new AtomicReference<>(s);
-        setInt(s.baseAddress(), 42);
-        assertEquals(getInt(s.baseAddress()), 42);
+        setInt(s.address(), 42);
+        assertEquals(getInt(s.address()), 42);
         List<Thread> threads = new ArrayList<>();
         for (int i = 0 ; i < 1000 ; i++) {
             threads.add(new Thread(() -> {
-                assertEquals(getInt(confined.get().baseAddress()), 42);
+                assertEquals(getInt(confined.get().address()), 42);
                 confined.set(confined.get().withOwnerThread(owner));
             }));
         }
         threads.forEach(t -> {
             confined.set(confined.get().withOwnerThread(t));
@@ -83,11 +82,11 @@
     @Test
     public void testShared() throws Throwable {
         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
         try (MemorySegment s = MemorySegment.allocateNative(layout)) {
             for (int i = 0 ; i < layout.elementCount().getAsLong() ; i++) {
-                setInt(s.baseAddress().addOffset(i * 4), 42);
+                setInt(s.address().addOffset(i * 4), 42);
             }
             List<Thread> threads = new ArrayList<>();
             List<Spliterator<MemorySegment>> spliterators = new ArrayList<>();
             spliterators.add(MemorySegment.spliterator(s, layout));
             while (true) {
@@ -106,11 +105,11 @@
 
             AtomicInteger accessCount = new AtomicInteger();
             for (Spliterator<MemorySegment> spliterator : spliterators) {
                 threads.add(new Thread(() -> {
                     spliterator.tryAdvance(local -> {
-                        assertEquals(getInt(local.baseAddress()), 42);
+                        assertEquals(getInt(local.address()), 42);
                         accessCount.incrementAndGet();
                     });
                 }));
             }
             threads.forEach(Thread::start);
@@ -126,18 +125,18 @@
     }
 
     @Test
     public void testSharedUnsafe() throws Throwable {
         try (MemorySegment s = MemorySegment.allocateNative(4)) {
-            setInt(s.baseAddress(), 42);
-            assertEquals(getInt(s.baseAddress()), 42);
+            setInt(s.address(), 42);
+            assertEquals(getInt(s.address()), 42);
             List<Thread> threads = new ArrayList<>();
             MemorySegment sharedSegment = MemorySegment.ofNativeRestricted(
-                    s.baseAddress(), s.byteSize(), null, null, null);
+                    s.address(), s.byteSize(), null, null, null);
             for (int i = 0 ; i < 1000 ; i++) {
                 threads.add(new Thread(() -> {
-                    assertEquals(getInt(sharedSegment.baseAddress()), 42);
+                    assertEquals(getInt(sharedSegment.address()), 42);
                 }));
             }
             threads.forEach(Thread::start);
             threads.forEach(t -> {
                 try {
@@ -226,20 +225,20 @@
                     try {
                         b.await();
                     } catch (InterruptedException e) {
                     }
 
-                    MemoryAddress base = s2.baseAddress();
+                    MemoryAddress base = s2.address();
                     setInt(base.addOffset(4), -42);
                     fail();
                 } catch (IllegalStateException ex) {
                     assertTrue(ex.getMessage().contains("owning thread"));
                 }
             });
 
             a.await();
-            MemoryAddress base = s1.baseAddress();
+            MemoryAddress base = s1.address();
             setInt(base.addOffset(4), 42);
         }
 
         b.countDown();
         r.get();
diff a/test/jdk/java/foreign/TestSlices.java b/test/jdk/java/foreign/TestSlices.java
--- a/test/jdk/java/foreign/TestSlices.java
+++ b/test/jdk/java/foreign/TestSlices.java
@@ -50,11 +50,11 @@
     public void testSlices(VarHandle handle, int lo, int hi, int[] values) {
         try (MemorySegment segment = MemorySegment.allocateNative(LAYOUT)) {
             //init
             for (long i = 0 ; i < 2 ; i++) {
                 for (long j = 0 ; j < 5 ; j++) {
-                    VH_ALL.set(segment.baseAddress(), i, j, (int)j + 1 + ((int)i * 5));
+                    VH_ALL.set(segment.address(), i, j, (int)j + 1 + ((int)i * 5));
                 }
             }
 
             checkSlice(segment, handle, lo, hi, values);
         }
@@ -62,11 +62,11 @@
 
     static void checkSlice(MemorySegment segment, VarHandle handle, long i_max, long j_max, int... values) {
         int index = 0;
         for (long i = 0 ; i < i_max ; i++) {
             for (long j = 0 ; j < j_max ; j++) {
-                int x = (int) handle.get(segment.baseAddress(), i, j);
+                int x = (int) handle.get(segment.address(), i, j);
                 assertEquals(x, values[index++]);
             }
         }
         assertEquals(index, values.length);
     }
diff a/test/jdk/java/foreign/TestSpliterator.java b/test/jdk/java/foreign/TestSpliterator.java
--- a/test/jdk/java/foreign/TestSpliterator.java
+++ b/test/jdk/java/foreign/TestSpliterator.java
@@ -61,11 +61,11 @@
         SequenceLayout layout = MemoryLayout.ofSequence(size, MemoryLayouts.JAVA_INT);
 
         //setup
         MemorySegment segment = MemorySegment.allocateNative(layout);
         for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
-            INT_HANDLE.set(segment.baseAddress(), (long) i, i);
+            INT_HANDLE.set(segment.address(), (long) i, i);
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
         //serial
         long serial = sum(0, segment);
         assertEquals(serial, expected);
@@ -86,11 +86,11 @@
         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
 
         //setup
         MemorySegment segment = MemorySegment.allocateNative(layout);
         for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
-            INT_HANDLE.set(segment.baseAddress(), (long) i, i);
+            INT_HANDLE.set(segment.address(), (long) i, i);
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 
         //check that a segment w/o ACQUIRE access mode can still be used from same thread
         AtomicLong spliteratorSum = new AtomicLong();
@@ -98,16 +98,16 @@
                 .forEachRemaining(s -> spliteratorSum.addAndGet(sumSingle(0L, s)));
         assertEquals(spliteratorSum.get(), expected);
     }
 
     static long sumSingle(long acc, MemorySegment segment) {
-        return acc + (int)INT_HANDLE.get(segment.baseAddress(), 0L);
+        return acc + (int)INT_HANDLE.get(segment.address(), 0L);
     }
 
     static long sum(long start, MemorySegment segment) {
         long sum = start;
-        MemoryAddress base = segment.baseAddress();
+        MemoryAddress base = segment.address();
         int length = (int)segment.byteSize();
         for (int i = 0 ; i < length / CARRIER_SIZE ; i++) {
             sum += (int)INT_HANDLE.get(base, (long)i);
         }
         return sum;
diff a/test/jdk/java/foreign/TestVarHandleCombinators.java b/test/jdk/java/foreign/TestVarHandleCombinators.java
--- a/test/jdk/java/foreign/TestVarHandleCombinators.java
+++ b/test/jdk/java/foreign/TestVarHandleCombinators.java
@@ -47,29 +47,29 @@
         VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
         vh = MemoryHandles.withStride(vh, 1);
 
         byte[] arr = { 0, 0, -1, 0 };
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress addr = segment.baseAddress();
+        MemoryAddress addr = segment.address();
 
         assertEquals((byte) vh.get(addr, 2), (byte) -1);
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedElement() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
         vh = MemoryHandles.withStride(vh, 2);
         MemorySegment segment = MemorySegment.ofArray(new byte[4]);
-        vh.get(segment.baseAddress(), 1L); //should throw
+        vh.get(segment.address(), 1L); //should throw
     }
 
     public void testZeroStrideElement() {
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
         VarHandle strided_vh = MemoryHandles.withStride(vh, 0);
         MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
         for (int i = 0 ; i < 100 ; i++) {
-            assertEquals((int)vh.get(segment.baseAddress()), strided_vh.get(segment.baseAddress(), (long)i));
+            assertEquals((int)vh.get(segment.address()), strided_vh.get(segment.address(), (long)i));
         }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testStrideWrongHandle() {
@@ -90,11 +90,11 @@
     @Test
     public void testAlign() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
 
         MemorySegment segment = MemorySegment.allocateNative(1, 2);
-        MemoryAddress address = segment.baseAddress();
+        MemoryAddress address = segment.address();
 
         vh.set(address, (byte) 10); // fine, memory region is aligned
         assertEquals((byte) vh.get(address), (byte) 10);
     }
 
@@ -102,21 +102,21 @@
     public void testAlignBadAccess() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 1); // offset by 1 byte
 
         MemorySegment segment = MemorySegment.allocateNative(2, 2);
-        MemoryAddress address = segment.baseAddress();
+        MemoryAddress address = segment.address();
 
         vh.set(address, (byte) 10); // should be bad align
     }
 
     public void testZeroOffsetElement() {
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
         VarHandle offset_vh = MemoryHandles.withOffset(vh, 0);
         MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
         for (int i = 0 ; i < 100 ; i++) {
-            assertEquals((int)vh.get(segment.baseAddress()), offset_vh.get(segment.baseAddress(), (long)i));
+            assertEquals((int)vh.get(segment.address()), offset_vh.get(segment.address(), (long)i));
         }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testOffsetWrongHandle() {
@@ -127,31 +127,31 @@
     @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedOffset() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 2);
         MemorySegment segment = MemorySegment.ofArray(new byte[4]);
-        vh.get(segment.baseAddress()); //should throw
+        vh.get(segment.address()); //should throw
     }
 
     @Test
     public void testOffset() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 1);
 
         MemorySegment segment = MemorySegment.ofArray(new byte[2]);
-        MemoryAddress address = segment.baseAddress();
+        MemoryAddress address = segment.address();
 
         vh.set(address, (byte) 10);
         assertEquals((byte) vh.get(address), (byte) 10);
     }
 
     @Test
     public void testByteOrderLE() {
         VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.LITTLE_ENDIAN);
         byte[] arr = new byte[2];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress address = segment.baseAddress();
+        MemoryAddress address = segment.address();
 
         vh.set(address, (short) 0xFF);
         assertEquals(arr[0], (byte) 0xFF);
         assertEquals(arr[1], (byte) 0);
     }
@@ -159,11 +159,11 @@
     @Test
     public void testByteOrderBE() {
         VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.BIG_ENDIAN);
         byte[] arr = new byte[2];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress address = segment.baseAddress();
+        MemoryAddress address = segment.address();
 
         vh.set(address, (short) 0xFF);
         assertEquals(arr[0], (byte) 0);
         assertEquals(arr[1], (byte) 0xFF);
     }
@@ -181,13 +181,13 @@
         VarHandle outer_vh = MemoryHandles.withStride(inner_vh, 5 * 8);
         int count = 0;
         try (MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8)) {
             for (long i = 0; i < outer_size; i++) {
                 for (long j = 0; j < inner_size; j++) {
-                    outer_vh.set(segment.baseAddress(), i, j, count);
+                    outer_vh.set(segment.address(), i, j, count);
                     assertEquals(
-                            (int)inner_vh.get(segment.baseAddress().addOffset(i * inner_size * 8), j),
+                            (int)inner_vh.get(segment.address().addOffset(i * inner_size * 8), j),
                             count);
                     count++;
                 }
             }
         }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
@@ -70,11 +70,11 @@
         }
     }
 
     //setup native memory segment
 
-    static final MemoryAddress segment_addr = MemorySegment.allocateNative(ALLOC_SIZE).baseAddress();
+    static final MemoryAddress segment_addr = MemorySegment.allocateNative(ALLOC_SIZE).address();
     static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());
 
     static {
         for (int i = 0; i < ELEM_SIZE; i++) {
             VH_int.set(segment_addr, (long) i, i);
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.bench.jdk.incubator.foreign;
 
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
@@ -72,11 +71,11 @@
 
     @Benchmark
     public void segment_loop() {
         MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.baseAddress(), (long) i, i);
+            VH_int.set(segment.address(), (long) i, i);
         }
         segment.close();
     }
 
     @Benchmark
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
@@ -72,11 +72,11 @@
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(unsafe_addr + (i * CARRIER_SIZE) , i);
         }
         segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.baseAddress(), (long) i, i);
+            VH_int.set(segment.address(), (long) i, i);
         }
         byteBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());
         for (int i = 0; i < ELEM_SIZE; i++) {
             byteBuffer.putInt(i * CARRIER_SIZE , i);
         }
@@ -96,11 +96,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.baseAddress(), 0L);
+        return (int) VH_int.get(segment.address(), 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -118,39 +118,39 @@
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.baseAddress(), i);
+            res += MemoryAccess.getIntAtIndex(segment.address(), i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.baseAddress();
+        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();
+        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();
+        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
@@ -89,11 +89,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.baseAddress(), 0L);
+        return (int) VH_int.get(segment.address(), 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -110,40 +110,40 @@
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.baseAddress();
+        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.baseAddress(), i);
+            res += MemoryAccess.getIntAtIndex(segment.address(), i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();
+        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();
+        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
@@ -95,11 +95,11 @@
                 byteBuffer.putInt(i * CARRIER_SIZE, i);
             }
             ((MappedByteBuffer)byteBuffer).force();
         }
         segment = MemorySegment.mapFromPath(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);
-        unsafe_addr = segment.baseAddress().toRawLongValue();
+        unsafe_addr = segment.address().toRawLongValue();
     }
 
     @TearDown
     public void tearDown() {
         segment.close();
@@ -113,11 +113,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.baseAddress(), 0L);
+        return (int) VH_int.get(segment.address(), 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -134,40 +134,40 @@
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.baseAddress();
+        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.baseAddress(), i);
+            res += MemoryAccess.getIntAtIndex(segment.address(), i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();
+        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();
+        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
@@ -42,16 +42,14 @@
 import jdk.incubator.foreign.MemorySegment;
 import java.lang.invoke.VarHandle;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Optional;
-import java.util.OptionalInt;
 import java.util.Spliterator;
 import java.util.concurrent.CountedCompleter;
 import java.util.concurrent.RecursiveTask;
 import java.util.concurrent.TimeUnit;
-import java.util.function.IntFunction;
 import java.util.function.Predicate;
 import java.util.function.ToIntFunction;
 import java.util.stream.StreamSupport;
 
 import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;
@@ -85,11 +83,11 @@
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(address + (i * CARRIER_SIZE), i);
         }
         segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.baseAddress(), (long) i, i);
+            VH_int.set(segment.address(), (long) i, i);
         }
     }
 
     @TearDown
     public void tearDown() throws Throwable {
@@ -98,11 +96,11 @@
     }
 
     @Benchmark
     public int segment_serial() {
         int res = 0;
-        MemoryAddress base = segment.baseAddress();
+        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             res += (int)VH_int.get(base, (long) i);
         }
         return res;
     }
@@ -137,15 +135,15 @@
         return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)
                 .mapToInt(SEGMENT_TO_INT_BULK).sum();
     }
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT = slice ->
-            (int) VH_int.get(slice.baseAddress(), 0L);
+            (int) VH_int.get(slice.address(), 0L);
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT_BULK = slice -> {
         int res = 0;
-        MemoryAddress base = slice.baseAddress();
+        MemoryAddress base = slice.address();
         for (int i = 0; i < BULK_FACTOR ; i++) {
             res += (int)VH_int.get(base, (long) i);
         }
         return res;
     };
@@ -177,14 +175,14 @@
                 .filter(FIND_BULK)
                 .findAny();
     }
 
     final static Predicate<MemorySegment> FIND_SINGLE = slice ->
-            (int)VH_int.get(slice.baseAddress(), 0L) == (ELEM_SIZE - 1);
+            (int)VH_int.get(slice.address(), 0L) == (ELEM_SIZE - 1);
 
     final static Predicate<MemorySegment> FIND_BULK = slice -> {
-        MemoryAddress base = slice.baseAddress();
+        MemoryAddress base = slice.address();
         for (int i = 0; i < BULK_FACTOR ; i++) {
             if ((int)VH_int.get(base, (long)i) == (ELEM_SIZE - 1)) {
                 return true;
             }
         }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
@@ -142,21 +142,21 @@
     }
 
     @Benchmark
     public int segment_loop() throws Throwable {
         int sum = 0;
-        MemoryAddress baseAddress = segment.baseAddress();
+        MemoryAddress baseAddress = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int)VH_addr_int.get(baseAddress, (long)i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_box_loop() throws Throwable {
         int sum = 0;
-        MemoryAddress baseAddress = segment.baseAddress();
+        MemoryAddress baseAddress = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += ((IntBox)VH_addr_box_int.get(baseAddress, (long)i)).intValue();
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
@@ -56,23 +56,23 @@
     public PanamaPoint(MemorySegment segment) {
         this.segment = segment;
     }
 
     public void setX(int x) {
-        VH_x.set(segment.baseAddress(), x);
+        VH_x.set(segment.address(), x);
     }
 
     public int getX() {
-        return (int) VH_x.get(segment.baseAddress());
+        return (int) VH_x.get(segment.address());
     }
 
     public void setY(int y) {
-        VH_y.set(segment.baseAddress(), y);
+        VH_y.set(segment.address(), y);
     }
 
     public int getY() {
-        return (int) VH_y.get(segment.baseAddress());
+        return (int) VH_y.get(segment.address());
     }
 
     @Override
     public void close() {
         segment.close();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/callarranger/TestSysVCallArranger.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>test/jdk/java/foreign/callarranger/TestSysVCallArranger.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 57     @Test
 58     public void testEmpty() {
 59         MethodType mt = MethodType.methodType(void.class);
 60         FunctionDescriptor fd = FunctionDescriptor.ofVoid();
 61         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 62 
 63         assertFalse(bindings.isInMemoryReturn);
 64         CallingSequence callingSequence = bindings.callingSequence;
 65         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
 66         assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 67 
 68         checkArgumentBindings(callingSequence, new Binding[][]{
 69             { move(rax, long.class) }
 70         });
 71 
 72         checkReturnBindings(callingSequence, new Binding[]{});
 73 
 74         assertEquals(bindings.nVectorArgs, 0);
 75     }
 76 



























































 77     @Test
 78     public void testIntegerRegs() {
 79         MethodType mt = MethodType.methodType(void.class,
 80                 int.class, int.class, int.class, int.class, int.class, int.class);
 81         FunctionDescriptor fd = FunctionDescriptor.ofVoid(
 82                 C_INT, C_INT, C_INT, C_INT, C_INT, C_INT);
 83         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 84 
 85         assertFalse(bindings.isInMemoryReturn);
 86         CallingSequence callingSequence = bindings.callingSequence;
 87         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
 88         assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 89 
 90         checkArgumentBindings(callingSequence, new Binding[][]{
 91             { move(rdi, int.class) },
 92             { move(rsi, int.class) },
 93             { move(rdx, int.class) },
 94             { move(rcx, int.class) },
 95             { move(r8, int.class) },
 96             { move(r9, int.class) },
</pre>
</td>
<td>
<hr />
<pre>
 57     @Test
 58     public void testEmpty() {
 59         MethodType mt = MethodType.methodType(void.class);
 60         FunctionDescriptor fd = FunctionDescriptor.ofVoid();
 61         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 62 
 63         assertFalse(bindings.isInMemoryReturn);
 64         CallingSequence callingSequence = bindings.callingSequence;
 65         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
 66         assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 67 
 68         checkArgumentBindings(callingSequence, new Binding[][]{
 69             { move(rax, long.class) }
 70         });
 71 
 72         checkReturnBindings(callingSequence, new Binding[]{});
 73 
 74         assertEquals(bindings.nVectorArgs, 0);
 75     }
 76 
<span class="line-added"> 77     @Test</span>
<span class="line-added"> 78     public void testNestedStructs() {</span>
<span class="line-added"> 79         MemoryLayout POINT = MemoryLayout.ofStruct(</span>
<span class="line-added"> 80                 C_INT,</span>
<span class="line-added"> 81                 MemoryLayout.ofStruct(</span>
<span class="line-added"> 82                         C_INT,</span>
<span class="line-added"> 83                         C_INT</span>
<span class="line-added"> 84                 )</span>
<span class="line-added"> 85         );</span>
<span class="line-added"> 86         MethodType mt = MethodType.methodType(void.class, MemorySegment.class);</span>
<span class="line-added"> 87         FunctionDescriptor fd = FunctionDescriptor.ofVoid(POINT);</span>
<span class="line-added"> 88         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90         assertFalse(bindings.isInMemoryReturn);</span>
<span class="line-added"> 91         CallingSequence callingSequence = bindings.callingSequence;</span>
<span class="line-added"> 92         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));</span>
<span class="line-added"> 93         assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95         checkArgumentBindings(callingSequence, new Binding[][]{</span>
<span class="line-added"> 96                 { dup(), dereference(0, long.class), move(rdi, long.class),</span>
<span class="line-added"> 97                   dereference(8, int.class), move(rsi, int.class)},</span>
<span class="line-added"> 98                 { move(rax, long.class) },</span>
<span class="line-added"> 99         });</span>
<span class="line-added">100 </span>
<span class="line-added">101         checkReturnBindings(callingSequence, new Binding[]{});</span>
<span class="line-added">102 </span>
<span class="line-added">103         assertEquals(bindings.nVectorArgs, 0);</span>
<span class="line-added">104     }</span>
<span class="line-added">105 </span>
<span class="line-added">106     @Test</span>
<span class="line-added">107     public void testNestedUnion() {</span>
<span class="line-added">108         MemoryLayout POINT = MemoryLayout.ofStruct(</span>
<span class="line-added">109                 C_INT,</span>
<span class="line-added">110                 MemoryLayout.ofPaddingBits(32),</span>
<span class="line-added">111                 MemoryLayout.ofUnion(</span>
<span class="line-added">112                         MemoryLayout.ofStruct(C_INT, C_INT),</span>
<span class="line-added">113                         C_LONG</span>
<span class="line-added">114                 )</span>
<span class="line-added">115         );</span>
<span class="line-added">116         MethodType mt = MethodType.methodType(void.class, MemorySegment.class);</span>
<span class="line-added">117         FunctionDescriptor fd = FunctionDescriptor.ofVoid(POINT);</span>
<span class="line-added">118         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);</span>
<span class="line-added">119 </span>
<span class="line-added">120         assertFalse(bindings.isInMemoryReturn);</span>
<span class="line-added">121         CallingSequence callingSequence = bindings.callingSequence;</span>
<span class="line-added">122         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));</span>
<span class="line-added">123         assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));</span>
<span class="line-added">124 </span>
<span class="line-added">125         checkArgumentBindings(callingSequence, new Binding[][]{</span>
<span class="line-added">126                 { dup(), dereference(0, long.class), move(rdi, long.class),</span>
<span class="line-added">127                         dereference(8, long.class), move(rsi, long.class)},</span>
<span class="line-added">128                 { move(rax, long.class) },</span>
<span class="line-added">129         });</span>
<span class="line-added">130 </span>
<span class="line-added">131         checkReturnBindings(callingSequence, new Binding[]{});</span>
<span class="line-added">132 </span>
<span class="line-added">133         assertEquals(bindings.nVectorArgs, 0);</span>
<span class="line-added">134     }</span>
<span class="line-added">135 </span>
136     @Test
137     public void testIntegerRegs() {
138         MethodType mt = MethodType.methodType(void.class,
139                 int.class, int.class, int.class, int.class, int.class, int.class);
140         FunctionDescriptor fd = FunctionDescriptor.ofVoid(
141                 C_INT, C_INT, C_INT, C_INT, C_INT, C_INT);
142         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
143 
144         assertFalse(bindings.isInMemoryReturn);
145         CallingSequence callingSequence = bindings.callingSequence;
146         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
147         assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
148 
149         checkArgumentBindings(callingSequence, new Binding[][]{
150             { move(rdi, int.class) },
151             { move(rsi, int.class) },
152             { move(rdx, int.class) },
153             { move(rcx, int.class) },
154             { move(r8, int.class) },
155             { move(r9, int.class) },
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
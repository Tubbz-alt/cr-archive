diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -457,10 +457,11 @@
 
         for (int i = 0; i < classes.size(); i++) {
             ArgumentClassImpl c = classes.get(i);
 
             if (c == ArgumentClassImpl.MEMORY) {
+                // if any of the eightbytes was passed in memory, pass the whole thing in memory
                 return createMemoryClassArray(classes.size());
             }
 
             if (c == ArgumentClassImpl.X87UP) {
                 if (i == 0) {
@@ -539,11 +540,15 @@
             List<ArgumentClassImpl> layouts = groups[(int)offset / 8];
             if (layouts == null) {
                 layouts = new ArrayList<>();
                 groups[(int)offset / 8] = layouts;
             }
-            layouts.add(classifyValueType((ValueLayout)l));
+            // if the aggregate contains unaligned fields, it has class MEMORY
+            ArgumentClassImpl argumentClass = (offset % l.byteAlignment()) == 0 ?
+                    classifyValueType((ValueLayout)l) :
+                    ArgumentClassImpl.MEMORY;
+            layouts.add(argumentClass);
         } else {
             throw new IllegalStateException("Unexpected layout: " + l);
         }
     }
 }
diff a/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java b/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
@@ -131,10 +131,68 @@
         checkReturnBindings(callingSequence, new Binding[]{});
 
         assertEquals(bindings.nVectorArgs, 0);
     }
 
+    @Test
+    public void testNestedStructsUnaligned() {
+        MemoryLayout POINT = MemoryLayout.ofStruct(
+                C_INT,
+                MemoryLayout.ofStruct(
+                        C_LONG,
+                        C_INT
+                )
+        );
+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(POINT);
+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
+
+        assertFalse(bindings.isInMemoryReturn);
+        CallingSequence callingSequence = bindings.callingSequence;
+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
+
+        checkArgumentBindings(callingSequence, new Binding[][]{
+                { dup(), dereference(0, long.class), move(stackStorage(0), long.class),
+                        dereference(8, long.class), move(stackStorage(1), long.class)},
+                { move(rax, long.class) },
+        });
+
+        checkReturnBindings(callingSequence, new Binding[]{});
+
+        assertEquals(bindings.nVectorArgs, 0);
+    }
+
+    @Test
+    public void testNestedUnionUnaligned() {
+        MemoryLayout POINT = MemoryLayout.ofStruct(
+                C_INT,
+                MemoryLayout.ofUnion(
+                        MemoryLayout.ofStruct(C_INT, C_INT),
+                        C_LONG
+                )
+        );
+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(POINT);
+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
+
+        assertFalse(bindings.isInMemoryReturn);
+        CallingSequence callingSequence = bindings.callingSequence;
+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
+
+        checkArgumentBindings(callingSequence, new Binding[][]{
+                { dup(), dereference(0, long.class), move(stackStorage(0), long.class),
+                        dereference(8, int.class), move(stackStorage(1), int.class)},
+                { move(rax, long.class) },
+        });
+
+        checkReturnBindings(callingSequence, new Binding[]{});
+
+        assertEquals(bindings.nVectorArgs, 0);
+    }
+
     @Test
     public void testIntegerRegs() {
         MethodType mt = MethodType.methodType(void.class,
                 int.class, int.class, int.class, int.class, int.class, int.class);
         FunctionDescriptor fd = FunctionDescriptor.ofVoid(

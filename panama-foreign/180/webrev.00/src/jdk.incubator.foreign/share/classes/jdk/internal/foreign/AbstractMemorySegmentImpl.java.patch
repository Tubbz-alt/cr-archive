diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -31,10 +31,11 @@
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
+import jdk.internal.util.ArraysSupport;
 import jdk.internal.vm.annotation.ForceInline;
 import sun.security.action.GetPropertyAction;
 
 import java.lang.invoke.VarHandle;
 import java.nio.ByteBuffer;
@@ -129,10 +130,57 @@
         UNSAFE.copyMemory(
                 that.base(), that.min(),
                 base(), min(), size);
     }
 
+    @Override
+    public long mismatch(MemorySegment other) {
+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
+        final long thisSize = this.byteSize();
+        final long thatSize = that.byteSize();
+        final long minSize = Math.min(thisSize, thatSize);
+
+        this.checkRange(0, minSize, false);
+        that.checkRange(0, minSize, false);
+
+        if (this == other)
+            return -1;
+
+        long off = 0;
+        long remaining = minSize;
+        int i = 0;
+        while (remaining > 7) {
+            int size;
+            if (remaining > Integer.MAX_VALUE) {
+                size = Integer.MAX_VALUE;
+            } else {
+                size = (int) remaining;
+            }
+            i = ArraysSupport.vectorizedMismatch(
+                    this.base(),
+                    this.min() + off,
+                    that.base(),
+                    that.min() + off,
+                    size,
+                    ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);
+            if (i >= 0) {
+                return off + i;
+            }
+            i = size - ~i;
+
+            off += i;
+            remaining -= i;
+        }
+
+        for (; off < minSize; off++) {
+            if (UNSAFE.getByte(this.base(), this.min() + off) != UNSAFE.getByte(that.base(), that.min() + off)) {
+                return off;
+            }
+        }
+        return thisSize != thatSize ? minSize : -1;
+    }
+
     @Override
     @ForceInline
     public final MemoryAddress baseAddress() {
         return new MemoryAddressImpl(this, 0);
     }

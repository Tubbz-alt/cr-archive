<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../java.base/share/classes/jdk/internal/util/ArraysSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
327      * @throws IllegalStateException if either the source segment or this segment have been already closed,
328      * or if access occurs from a thread other than the thread owning either segment.
329      * @throws UnsupportedOperationException if either the source segment or this segment do not feature required access modes;
330      * more specifically, {@code src} should feature at least the {@link MemorySegment#READ} access mode,
331      * while this segment should feature at least the {@link MemorySegment#WRITE} access mode.
332      */
333     void copyFrom(MemorySegment src);
334 
335     /**
336      * Finds and returns the offset, in bytes, of the first mismatch between
337      * this segment and a given other segment. The offset is relative to the
338      * {@link #baseAddress() base address} of each segment and will be in the
339      * range of 0 (inclusive) up to the {@link #byteSize() size} (in bytes) of
340      * the smaller memory segment (exclusive).
341      * &lt;p&gt;
342      * If the two segments share a common prefix then the returned offset is
343      * the length of the common prefix and it follows that there is a mismatch
344      * between the two segments at that offset within the respective segments.
345      * If one segment is a proper prefix of the other then the returned offset is
346      * the smaller of the segment sizes, and it follows that the offset is only
<span class="line-modified">347      * valid for the larger segment. Otherwise, there is no mismatch.</span>

348      *
349      * @param other the segment to be tested for a mismatch with this segment
350      * @return the relative offset, in bytes, of the first mismatch between this
351      * and the given other segment, otherwise -1 if no mismatch
352      * @throws IllegalStateException if either this segment of the other segment
353      * have been already closed, or if access occurs from a thread other than the
354      * thread owning either segment
355      * @throws UnsupportedOperationException if either this segment or the other
356      * segment does not feature at least the {@link MemorySegment#READ} access mode
357      */
358     long mismatch(MemorySegment other);
359 
360     /**
361      * Wraps this segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to
362      * the properties of this segment. For instance, if this segment is &lt;em&gt;immutable&lt;/em&gt;
363      * (e.g. the segment has access mode {@link #READ} but not {@link #WRITE}), then the resulting buffer is &lt;em&gt;read-only&lt;/em&gt;
364      * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is
365      * &lt;em&gt;direct&lt;/em&gt; (see {@link ByteBuffer#isDirect()}).
366      * &lt;p&gt;
367      * The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment
</pre>
</td>
<td>
<hr />
<pre>
327      * @throws IllegalStateException if either the source segment or this segment have been already closed,
328      * or if access occurs from a thread other than the thread owning either segment.
329      * @throws UnsupportedOperationException if either the source segment or this segment do not feature required access modes;
330      * more specifically, {@code src} should feature at least the {@link MemorySegment#READ} access mode,
331      * while this segment should feature at least the {@link MemorySegment#WRITE} access mode.
332      */
333     void copyFrom(MemorySegment src);
334 
335     /**
336      * Finds and returns the offset, in bytes, of the first mismatch between
337      * this segment and a given other segment. The offset is relative to the
338      * {@link #baseAddress() base address} of each segment and will be in the
339      * range of 0 (inclusive) up to the {@link #byteSize() size} (in bytes) of
340      * the smaller memory segment (exclusive).
341      * &lt;p&gt;
342      * If the two segments share a common prefix then the returned offset is
343      * the length of the common prefix and it follows that there is a mismatch
344      * between the two segments at that offset within the respective segments.
345      * If one segment is a proper prefix of the other then the returned offset is
346      * the smaller of the segment sizes, and it follows that the offset is only
<span class="line-modified">347      * valid for the larger segment. Otherwise, there is no mismatch and {@code</span>
<span class="line-added">348      * -1} is returned.</span>
349      *
350      * @param other the segment to be tested for a mismatch with this segment
351      * @return the relative offset, in bytes, of the first mismatch between this
352      * and the given other segment, otherwise -1 if no mismatch
353      * @throws IllegalStateException if either this segment of the other segment
354      * have been already closed, or if access occurs from a thread other than the
355      * thread owning either segment
356      * @throws UnsupportedOperationException if either this segment or the other
357      * segment does not feature at least the {@link MemorySegment#READ} access mode
358      */
359     long mismatch(MemorySegment other);
360 
361     /**
362      * Wraps this segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to
363      * the properties of this segment. For instance, if this segment is &lt;em&gt;immutable&lt;/em&gt;
364      * (e.g. the segment has access mode {@link #READ} but not {@link #WRITE}), then the resulting buffer is &lt;em&gt;read-only&lt;/em&gt;
365      * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is
366      * &lt;em&gt;direct&lt;/em&gt; (see {@link ByteBuffer#isDirect()}).
367      * &lt;p&gt;
368      * The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../java.base/share/classes/jdk/internal/util/ArraysSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
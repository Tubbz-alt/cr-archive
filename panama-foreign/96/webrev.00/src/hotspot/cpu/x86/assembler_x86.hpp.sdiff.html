<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/assembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/cpu/x86/assembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1152   //Abs of packed Integer values
1153   void pabsb(XMMRegister dst, XMMRegister src);
1154   void pabsw(XMMRegister dst, XMMRegister src);
1155   void pabsd(XMMRegister dst, XMMRegister src);
1156   void vpabsb(XMMRegister dst, XMMRegister src, int vector_len);
1157   void vpabsw(XMMRegister dst, XMMRegister src, int vector_len);
1158   void vpabsd(XMMRegister dst, XMMRegister src, int vector_len);
1159   void evpabsq(XMMRegister dst, XMMRegister src, int vector_len);
1160 
1161   // Divide Scalar Double-Precision Floating-Point Values
1162   void divsd(XMMRegister dst, Address src);
1163   void divsd(XMMRegister dst, XMMRegister src);
1164 
1165   // Divide Scalar Single-Precision Floating-Point Values
1166   void divss(XMMRegister dst, Address src);
1167   void divss(XMMRegister dst, XMMRegister src);
1168 
1169 
1170 #ifndef _LP64
1171  private:
<span class="line-removed">1172   // operands that only take the original 32bit registers</span>
<span class="line-removed">1173   void emit_operand32(Register reg, Address adr);</span>
1174 
1175   void emit_farith(int b1, int b2, int i);
1176 
1177  public:
1178   void emms();
1179 
1180   void fabs();
1181 
1182   void fadd(int i);
1183 
1184   void fadd_d(Address src);
1185   void fadd_s(Address src);
1186 
1187   // &quot;Alternate&quot; versions of x87 instructions place result down in FPU
1188   // stack instead of on TOS
1189 
1190   void fadda(int i); // &quot;alternate&quot; fadd
1191   void faddp(int i = 1);
1192 
1193   void fchs();
</pre>
<hr />
<pre>
1297 
1298   void fsubrp(int i = 1);
1299 
1300   void ftan();
1301 
1302   void ftst();
1303 
1304   void fucomi(int i = 1);
1305   void fucomip(int i = 1);
1306 
1307   void fwait();
1308 
1309   void fxch(int i = 1);
1310 
1311   void fyl2x();
1312   void frndint();
1313   void f2xm1();
1314   void fldl2e();
1315 #endif // !_LP64
1316 



1317   void fld_x(Address adr);  // extended-precision (80-bit) format
1318   void fstp_x(Address adr); // extended-precision (80-bit) format
1319   void fxrstor(Address src);
1320   void xrstor(Address src);
1321 
1322   void fxsave(Address dst);
1323   void xsave(Address dst);
1324 
1325   void hlt();
1326 
1327   void idivl(Register src);
1328   void divl(Register src); // Unsigned division
1329 
1330 #ifdef _LP64
1331   void idivq(Register src);
1332 #endif
1333 
1334   void imull(Register src);
1335   void imull(Register dst, Register src);
1336   void imull(Register dst, Register src, int value);
</pre>
</td>
<td>
<hr />
<pre>
1152   //Abs of packed Integer values
1153   void pabsb(XMMRegister dst, XMMRegister src);
1154   void pabsw(XMMRegister dst, XMMRegister src);
1155   void pabsd(XMMRegister dst, XMMRegister src);
1156   void vpabsb(XMMRegister dst, XMMRegister src, int vector_len);
1157   void vpabsw(XMMRegister dst, XMMRegister src, int vector_len);
1158   void vpabsd(XMMRegister dst, XMMRegister src, int vector_len);
1159   void evpabsq(XMMRegister dst, XMMRegister src, int vector_len);
1160 
1161   // Divide Scalar Double-Precision Floating-Point Values
1162   void divsd(XMMRegister dst, Address src);
1163   void divsd(XMMRegister dst, XMMRegister src);
1164 
1165   // Divide Scalar Single-Precision Floating-Point Values
1166   void divss(XMMRegister dst, Address src);
1167   void divss(XMMRegister dst, XMMRegister src);
1168 
1169 
1170 #ifndef _LP64
1171  private:


1172 
1173   void emit_farith(int b1, int b2, int i);
1174 
1175  public:
1176   void emms();
1177 
1178   void fabs();
1179 
1180   void fadd(int i);
1181 
1182   void fadd_d(Address src);
1183   void fadd_s(Address src);
1184 
1185   // &quot;Alternate&quot; versions of x87 instructions place result down in FPU
1186   // stack instead of on TOS
1187 
1188   void fadda(int i); // &quot;alternate&quot; fadd
1189   void faddp(int i = 1);
1190 
1191   void fchs();
</pre>
<hr />
<pre>
1295 
1296   void fsubrp(int i = 1);
1297 
1298   void ftan();
1299 
1300   void ftst();
1301 
1302   void fucomi(int i = 1);
1303   void fucomip(int i = 1);
1304 
1305   void fwait();
1306 
1307   void fxch(int i = 1);
1308 
1309   void fyl2x();
1310   void frndint();
1311   void f2xm1();
1312   void fldl2e();
1313 #endif // !_LP64
1314 
<span class="line-added">1315   // operands that only take the original 32bit registers</span>
<span class="line-added">1316   void emit_operand32(Register reg, Address adr);</span>
<span class="line-added">1317 </span>
1318   void fld_x(Address adr);  // extended-precision (80-bit) format
1319   void fstp_x(Address adr); // extended-precision (80-bit) format
1320   void fxrstor(Address src);
1321   void xrstor(Address src);
1322 
1323   void fxsave(Address dst);
1324   void xsave(Address dst);
1325 
1326   void hlt();
1327 
1328   void idivl(Register src);
1329   void divl(Register src); // Unsigned division
1330 
1331 #ifdef _LP64
1332   void idivq(Register src);
1333 #endif
1334 
1335   void imull(Register src);
1336   void imull(Register dst, Register src);
1337   void imull(Register dst, Register src, int value);
</pre>
</td>
</tr>
</table>
<center><a href="assembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
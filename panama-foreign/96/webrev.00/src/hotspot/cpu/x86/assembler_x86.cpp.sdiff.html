<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/assembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/assembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
6872   emit_operand(rdi, src1);
6873   emit_data(imm32, rspec, 0);
6874 }
6875 
6876 // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
6877 // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
6878 // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
6879 void Assembler::cmpxchg8(Address adr) {
6880   InstructionMark im(this);
6881   emit_int16(0x0F, (unsigned char)0xC7);
6882   emit_operand(rcx, adr);
6883 }
6884 
6885 void Assembler::decl(Register dst) {
6886   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
6887  emit_int8(0x48 | dst-&gt;encoding());
6888 }
6889 
6890 // 64bit doesn&#39;t use the x87
6891 
<span class="line-removed">6892 void Assembler::emit_operand32(Register reg, Address adr) {</span>
<span class="line-removed">6893   assert(reg-&gt;encoding() &lt; 8, &quot;no extended registers&quot;);</span>
<span class="line-removed">6894   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-removed">6895   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,</span>
<span class="line-removed">6896                adr._rspec);</span>
<span class="line-removed">6897 }</span>
<span class="line-removed">6898 </span>
6899 void Assembler::emit_farith(int b1, int b2, int i) {
6900   assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);
6901   assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);
6902   emit_int16(b1, b2 + i);
6903 }
6904 
6905 void Assembler::fabs() {
6906   emit_int16((unsigned char)0xD9, (unsigned char)0xE1);
6907 }
6908 
6909 void Assembler::fadd(int i) {
6910   emit_farith(0xD8, 0xC0, i);
6911 }
6912 
6913 void Assembler::fadd_d(Address src) {
6914   InstructionMark im(this);
6915   emit_int8((unsigned char)0xDC);
6916   emit_operand32(rax, src);
6917 }
6918 
</pre>
<hr />
<pre>
8349 
8350 void Assembler::decq(Address dst) {
8351   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8352   InstructionMark im(this);
8353   emit_int16(get_prefixq(dst), (unsigned char)0xFF);
8354   emit_operand(rcx, dst);
8355 }
8356 
8357 void Assembler::fld_x(Address adr) {
8358   InstructionMark im(this);
8359   emit_int8((unsigned char)0xDB);
8360   emit_operand32(rbp, adr);
8361 }
8362 
8363 void Assembler::fstp_x(Address adr) {
8364   InstructionMark im(this);
8365   emit_int8((unsigned char)0xDB);
8366   emit_operand32(rdi, adr);
8367 }
8368 







8369 void Assembler::fxrstor(Address src) {
8370   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);
8371   emit_operand(as_Register(1), src);
8372 }
8373 
8374 void Assembler::xrstor(Address src) {
8375   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);
8376   emit_operand(as_Register(5), src);
8377 }
8378 
8379 void Assembler::fxsave(Address dst) {
8380   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);
8381   emit_operand(as_Register(0), dst);
8382 }
8383 
8384 void Assembler::xsave(Address dst) {
8385   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);
8386   emit_operand(as_Register(4), dst);
8387 }
8388 
</pre>
</td>
<td>
<hr />
<pre>
6872   emit_operand(rdi, src1);
6873   emit_data(imm32, rspec, 0);
6874 }
6875 
6876 // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
6877 // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
6878 // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
6879 void Assembler::cmpxchg8(Address adr) {
6880   InstructionMark im(this);
6881   emit_int16(0x0F, (unsigned char)0xC7);
6882   emit_operand(rcx, adr);
6883 }
6884 
6885 void Assembler::decl(Register dst) {
6886   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
6887  emit_int8(0x48 | dst-&gt;encoding());
6888 }
6889 
6890 // 64bit doesn&#39;t use the x87
6891 







6892 void Assembler::emit_farith(int b1, int b2, int i) {
6893   assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);
6894   assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);
6895   emit_int16(b1, b2 + i);
6896 }
6897 
6898 void Assembler::fabs() {
6899   emit_int16((unsigned char)0xD9, (unsigned char)0xE1);
6900 }
6901 
6902 void Assembler::fadd(int i) {
6903   emit_farith(0xD8, 0xC0, i);
6904 }
6905 
6906 void Assembler::fadd_d(Address src) {
6907   InstructionMark im(this);
6908   emit_int8((unsigned char)0xDC);
6909   emit_operand32(rax, src);
6910 }
6911 
</pre>
<hr />
<pre>
8342 
8343 void Assembler::decq(Address dst) {
8344   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8345   InstructionMark im(this);
8346   emit_int16(get_prefixq(dst), (unsigned char)0xFF);
8347   emit_operand(rcx, dst);
8348 }
8349 
8350 void Assembler::fld_x(Address adr) {
8351   InstructionMark im(this);
8352   emit_int8((unsigned char)0xDB);
8353   emit_operand32(rbp, adr);
8354 }
8355 
8356 void Assembler::fstp_x(Address adr) {
8357   InstructionMark im(this);
8358   emit_int8((unsigned char)0xDB);
8359   emit_operand32(rdi, adr);
8360 }
8361 
<span class="line-added">8362 void Assembler::emit_operand32(Register reg, Address adr) {</span>
<span class="line-added">8363   assert(reg-&gt;encoding() &lt; 8, &quot;no extended registers&quot;);</span>
<span class="line-added">8364   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-added">8365   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,</span>
<span class="line-added">8366                adr._rspec);</span>
<span class="line-added">8367 }</span>
<span class="line-added">8368 </span>
8369 void Assembler::fxrstor(Address src) {
8370   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);
8371   emit_operand(as_Register(1), src);
8372 }
8373 
8374 void Assembler::xrstor(Address src) {
8375   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);
8376   emit_operand(as_Register(5), src);
8377 }
8378 
8379 void Assembler::fxsave(Address dst) {
8380   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);
8381   emit_operand(as_Register(0), dst);
8382 }
8383 
8384 void Assembler::xsave(Address dst) {
8385   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);
8386   emit_operand(as_Register(4), dst);
8387 }
8388 
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
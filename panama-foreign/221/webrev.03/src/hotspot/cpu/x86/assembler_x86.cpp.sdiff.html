<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/assembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/assembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
6898   emit_operand(rdi, src1);
6899   emit_data(imm32, rspec, 0);
6900 }
6901 
6902 // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
6903 // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
6904 // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
6905 void Assembler::cmpxchg8(Address adr) {
6906   InstructionMark im(this);
6907   emit_int16(0x0F, (unsigned char)0xC7);
6908   emit_operand(rcx, adr);
6909 }
6910 
6911 void Assembler::decl(Register dst) {
6912   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
6913  emit_int8(0x48 | dst-&gt;encoding());
6914 }
6915 
6916 // 64bit doesn&#39;t use the x87
6917 
<span class="line-removed">6918 void Assembler::emit_operand32(Register reg, Address adr) {</span>
<span class="line-removed">6919   assert(reg-&gt;encoding() &lt; 8, &quot;no extended registers&quot;);</span>
<span class="line-removed">6920   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-removed">6921   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,</span>
<span class="line-removed">6922                adr._rspec);</span>
<span class="line-removed">6923 }</span>
<span class="line-removed">6924 </span>
6925 void Assembler::emit_farith(int b1, int b2, int i) {
6926   assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);
6927   assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);
6928   emit_int16(b1, b2 + i);
6929 }
6930 
6931 void Assembler::fabs() {
6932   emit_int16((unsigned char)0xD9, (unsigned char)0xE1);
6933 }
6934 
6935 void Assembler::fadd(int i) {
6936   emit_farith(0xD8, 0xC0, i);
6937 }
6938 
6939 void Assembler::fadd_d(Address src) {
6940   InstructionMark im(this);
6941   emit_int8((unsigned char)0xDC);
6942   emit_operand32(rax, src);
6943 }
6944 
</pre>
<hr />
<pre>
7089   emit_int16((unsigned char)0xD9, (unsigned char)0xE8);
7090 }
7091 
7092 void Assembler::fld_d(Address adr) {
7093   InstructionMark im(this);
7094   emit_int8((unsigned char)0xDD);
7095   emit_operand32(rax, adr);
7096 }
7097 
7098 void Assembler::fld_s(Address adr) {
7099   InstructionMark im(this);
7100   emit_int8((unsigned char)0xD9);
7101   emit_operand32(rax, adr);
7102 }
7103 
7104 
7105 void Assembler::fld_s(int index) {
7106   emit_farith(0xD9, 0xC0, index);
7107 }
7108 
<span class="line-removed">7109 void Assembler::fld_x(Address adr) {</span>
<span class="line-removed">7110   InstructionMark im(this);</span>
<span class="line-removed">7111   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">7112   emit_operand32(rbp, adr);</span>
<span class="line-removed">7113 }</span>
<span class="line-removed">7114 </span>
7115 void Assembler::fldcw(Address src) {
7116   InstructionMark im(this);
7117   emit_int8((unsigned char)0xD9);
7118   emit_operand32(rbp, src);
7119 }
7120 
7121 void Assembler::fldenv(Address src) {
7122   InstructionMark im(this);
7123   emit_int8((unsigned char)0xD9);
7124   emit_operand32(rsp, src);
7125 }
7126 
7127 void Assembler::fldlg2() {
7128   emit_int16((unsigned char)0xD9, (unsigned char)0xEC);
7129 }
7130 
7131 void Assembler::fldln2() {
7132   emit_int16((unsigned char)0xD9, (unsigned char)0xED);
7133 }
7134 
</pre>
<hr />
<pre>
7221   emit_int8((unsigned char)0xD9);
7222   emit_operand32(rdx, adr);
7223 }
7224 
7225 void Assembler::fstp_d(Address adr) {
7226   InstructionMark im(this);
7227   emit_int8((unsigned char)0xDD);
7228   emit_operand32(rbx, adr);
7229 }
7230 
7231 void Assembler::fstp_d(int index) {
7232   emit_farith(0xDD, 0xD8, index);
7233 }
7234 
7235 void Assembler::fstp_s(Address adr) {
7236   InstructionMark im(this);
7237   emit_int8((unsigned char)0xD9);
7238   emit_operand32(rbx, adr);
7239 }
7240 
<span class="line-removed">7241 void Assembler::fstp_x(Address adr) {</span>
<span class="line-removed">7242   InstructionMark im(this);</span>
<span class="line-removed">7243   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">7244   emit_operand32(rdi, adr);</span>
<span class="line-removed">7245 }</span>
<span class="line-removed">7246 </span>
7247 void Assembler::fsub(int i) {
7248   emit_farith(0xD8, 0xE0, i);
7249 }
7250 
7251 void Assembler::fsub_d(Address src) {
7252   InstructionMark im(this);
7253   emit_int8((unsigned char)0xDC);
7254   emit_operand32(rsp, src);
7255 }
7256 
7257 void Assembler::fsub_s(Address src) {
7258   InstructionMark im(this);
7259   emit_int8((unsigned char)0xD8);
7260   emit_operand32(rsp, src);
7261 }
7262 
7263 void Assembler::fsuba(int i) {
7264   emit_farith(0xDC, 0xE8, i);
7265 }
7266 
</pre>
<hr />
<pre>
8384   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
8385   // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
8386   int encode = prefix_and_encode(dst-&gt;encoding());
8387   emit_int16((unsigned char)0xFF, (0xC8 | encode));
8388 }
8389 
8390 void Assembler::decq(Register dst) {
8391   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8392   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8393   int encode = prefixq_and_encode(dst-&gt;encoding());
8394   emit_int16((unsigned char)0xFF, 0xC8 | encode);
8395 }
8396 
8397 void Assembler::decq(Address dst) {
8398   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8399   InstructionMark im(this);
8400   emit_int16(get_prefixq(dst), (unsigned char)0xFF);
8401   emit_operand(rcx, dst);
8402 }
8403 



















8404 void Assembler::fxrstor(Address src) {
8405   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);
8406   emit_operand(as_Register(1), src);
8407 }
8408 
8409 void Assembler::xrstor(Address src) {
8410   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);
8411   emit_operand(as_Register(5), src);
8412 }
8413 
8414 void Assembler::fxsave(Address dst) {
8415   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);
8416   emit_operand(as_Register(0), dst);
8417 }
8418 
8419 void Assembler::xsave(Address dst) {
8420   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);
8421   emit_operand(as_Register(4), dst);
8422 }
8423 
</pre>
</td>
<td>
<hr />
<pre>
6898   emit_operand(rdi, src1);
6899   emit_data(imm32, rspec, 0);
6900 }
6901 
6902 // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
6903 // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
6904 // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
6905 void Assembler::cmpxchg8(Address adr) {
6906   InstructionMark im(this);
6907   emit_int16(0x0F, (unsigned char)0xC7);
6908   emit_operand(rcx, adr);
6909 }
6910 
6911 void Assembler::decl(Register dst) {
6912   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
6913  emit_int8(0x48 | dst-&gt;encoding());
6914 }
6915 
6916 // 64bit doesn&#39;t use the x87
6917 







6918 void Assembler::emit_farith(int b1, int b2, int i) {
6919   assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);
6920   assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);
6921   emit_int16(b1, b2 + i);
6922 }
6923 
6924 void Assembler::fabs() {
6925   emit_int16((unsigned char)0xD9, (unsigned char)0xE1);
6926 }
6927 
6928 void Assembler::fadd(int i) {
6929   emit_farith(0xD8, 0xC0, i);
6930 }
6931 
6932 void Assembler::fadd_d(Address src) {
6933   InstructionMark im(this);
6934   emit_int8((unsigned char)0xDC);
6935   emit_operand32(rax, src);
6936 }
6937 
</pre>
<hr />
<pre>
7082   emit_int16((unsigned char)0xD9, (unsigned char)0xE8);
7083 }
7084 
7085 void Assembler::fld_d(Address adr) {
7086   InstructionMark im(this);
7087   emit_int8((unsigned char)0xDD);
7088   emit_operand32(rax, adr);
7089 }
7090 
7091 void Assembler::fld_s(Address adr) {
7092   InstructionMark im(this);
7093   emit_int8((unsigned char)0xD9);
7094   emit_operand32(rax, adr);
7095 }
7096 
7097 
7098 void Assembler::fld_s(int index) {
7099   emit_farith(0xD9, 0xC0, index);
7100 }
7101 






7102 void Assembler::fldcw(Address src) {
7103   InstructionMark im(this);
7104   emit_int8((unsigned char)0xD9);
7105   emit_operand32(rbp, src);
7106 }
7107 
7108 void Assembler::fldenv(Address src) {
7109   InstructionMark im(this);
7110   emit_int8((unsigned char)0xD9);
7111   emit_operand32(rsp, src);
7112 }
7113 
7114 void Assembler::fldlg2() {
7115   emit_int16((unsigned char)0xD9, (unsigned char)0xEC);
7116 }
7117 
7118 void Assembler::fldln2() {
7119   emit_int16((unsigned char)0xD9, (unsigned char)0xED);
7120 }
7121 
</pre>
<hr />
<pre>
7208   emit_int8((unsigned char)0xD9);
7209   emit_operand32(rdx, adr);
7210 }
7211 
7212 void Assembler::fstp_d(Address adr) {
7213   InstructionMark im(this);
7214   emit_int8((unsigned char)0xDD);
7215   emit_operand32(rbx, adr);
7216 }
7217 
7218 void Assembler::fstp_d(int index) {
7219   emit_farith(0xDD, 0xD8, index);
7220 }
7221 
7222 void Assembler::fstp_s(Address adr) {
7223   InstructionMark im(this);
7224   emit_int8((unsigned char)0xD9);
7225   emit_operand32(rbx, adr);
7226 }
7227 






7228 void Assembler::fsub(int i) {
7229   emit_farith(0xD8, 0xE0, i);
7230 }
7231 
7232 void Assembler::fsub_d(Address src) {
7233   InstructionMark im(this);
7234   emit_int8((unsigned char)0xDC);
7235   emit_operand32(rsp, src);
7236 }
7237 
7238 void Assembler::fsub_s(Address src) {
7239   InstructionMark im(this);
7240   emit_int8((unsigned char)0xD8);
7241   emit_operand32(rsp, src);
7242 }
7243 
7244 void Assembler::fsuba(int i) {
7245   emit_farith(0xDC, 0xE8, i);
7246 }
7247 
</pre>
<hr />
<pre>
8365   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
8366   // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
8367   int encode = prefix_and_encode(dst-&gt;encoding());
8368   emit_int16((unsigned char)0xFF, (0xC8 | encode));
8369 }
8370 
8371 void Assembler::decq(Register dst) {
8372   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8373   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8374   int encode = prefixq_and_encode(dst-&gt;encoding());
8375   emit_int16((unsigned char)0xFF, 0xC8 | encode);
8376 }
8377 
8378 void Assembler::decq(Address dst) {
8379   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8380   InstructionMark im(this);
8381   emit_int16(get_prefixq(dst), (unsigned char)0xFF);
8382   emit_operand(rcx, dst);
8383 }
8384 
<span class="line-added">8385 void Assembler::fld_x(Address adr) {</span>
<span class="line-added">8386   InstructionMark im(this);</span>
<span class="line-added">8387   emit_int8((unsigned char)0xDB);</span>
<span class="line-added">8388   emit_operand32(rbp, adr);</span>
<span class="line-added">8389 }</span>
<span class="line-added">8390 </span>
<span class="line-added">8391 void Assembler::fstp_x(Address adr) {</span>
<span class="line-added">8392   InstructionMark im(this);</span>
<span class="line-added">8393   emit_int8((unsigned char)0xDB);</span>
<span class="line-added">8394   emit_operand32(rdi, adr);</span>
<span class="line-added">8395 }</span>
<span class="line-added">8396 </span>
<span class="line-added">8397 void Assembler::emit_operand32(Register reg, Address adr) {</span>
<span class="line-added">8398   assert(reg-&gt;encoding() &lt; 8, &quot;no extended registers&quot;);</span>
<span class="line-added">8399   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-added">8400   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,</span>
<span class="line-added">8401                adr._rspec);</span>
<span class="line-added">8402 }</span>
<span class="line-added">8403 </span>
8404 void Assembler::fxrstor(Address src) {
8405   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);
8406   emit_operand(as_Register(1), src);
8407 }
8408 
8409 void Assembler::xrstor(Address src) {
8410   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);
8411   emit_operand(as_Register(5), src);
8412 }
8413 
8414 void Assembler::fxsave(Address dst) {
8415   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);
8416   emit_operand(as_Register(0), dst);
8417 }
8418 
8419 void Assembler::xsave(Address dst) {
8420   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);
8421   emit_operand(as_Register(4), dst);
8422 }
8423 
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
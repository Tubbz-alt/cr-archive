<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/assembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_ASSEMBLER_X86_HPP
  26 #define CPU_X86_ASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/register.hpp&quot;
  29 #include &quot;runtime/vm_version.hpp&quot;
  30 #include &quot;utilities/powerOfTwo.hpp&quot;
  31 
  32 class BiasedLockingCounters;
  33 
  34 // Contains all the definitions needed for x86 assembly code generation.
  35 
  36 // Calling convention
  37 class Argument {
  38  public:
  39   enum {
  40 #ifdef _LP64
  41 #ifdef _WIN64
  42     n_int_register_parameters_c   = 4, // rcx, rdx, r8, r9 (c_rarg0, c_rarg1, ...)
  43     n_float_register_parameters_c = 4,  // xmm0 - xmm3 (c_farg0, c_farg1, ... )
<a name="1" id="anc1"></a><span class="line-added">  44     n_int_register_returns_c = 1, // rax</span>
<span class="line-added">  45     n_float_register_returns_c = 1, // xmm0</span>
  46 #else
  47     n_int_register_parameters_c   = 6, // rdi, rsi, rdx, rcx, r8, r9 (c_rarg0, c_rarg1, ...)
  48     n_float_register_parameters_c = 8,  // xmm0 - xmm7 (c_farg0, c_farg1, ... )
<a name="2" id="anc2"></a><span class="line-added">  49     n_int_register_returns_c = 2, // rax, rdx</span>
<span class="line-added">  50     n_float_register_returns_c = 2, // xmm0, xmm1</span>
  51 #endif // _WIN64
  52     n_int_register_parameters_j   = 6, // j_rarg0, j_rarg1, ...
  53     n_float_register_parameters_j = 8  // j_farg0, j_farg1, ...
  54 #else
  55     n_register_parameters = 0   // 0 registers used to pass arguments
  56 #endif // _LP64
  57   };
  58 };
  59 
  60 
  61 #ifdef _LP64
  62 // Symbolically name the register arguments used by the c calling convention.
  63 // Windows is different from linux/solaris. So much for standards...
  64 
  65 #ifdef _WIN64
  66 
  67 REGISTER_DECLARATION(Register, c_rarg0, rcx);
  68 REGISTER_DECLARATION(Register, c_rarg1, rdx);
  69 REGISTER_DECLARATION(Register, c_rarg2, r8);
  70 REGISTER_DECLARATION(Register, c_rarg3, r9);
  71 
  72 REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);
  73 REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);
  74 REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);
  75 REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);
  76 
  77 #else
  78 
  79 REGISTER_DECLARATION(Register, c_rarg0, rdi);
  80 REGISTER_DECLARATION(Register, c_rarg1, rsi);
  81 REGISTER_DECLARATION(Register, c_rarg2, rdx);
  82 REGISTER_DECLARATION(Register, c_rarg3, rcx);
  83 REGISTER_DECLARATION(Register, c_rarg4, r8);
  84 REGISTER_DECLARATION(Register, c_rarg5, r9);
  85 
  86 REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);
  87 REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);
  88 REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);
  89 REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);
  90 REGISTER_DECLARATION(XMMRegister, c_farg4, xmm4);
  91 REGISTER_DECLARATION(XMMRegister, c_farg5, xmm5);
  92 REGISTER_DECLARATION(XMMRegister, c_farg6, xmm6);
  93 REGISTER_DECLARATION(XMMRegister, c_farg7, xmm7);
  94 
  95 #endif // _WIN64
  96 
  97 // Symbolically name the register arguments used by the Java calling convention.
  98 // We have control over the convention for java so we can do what we please.
  99 // What pleases us is to offset the java calling convention so that when
 100 // we call a suitable jni method the arguments are lined up and we don&#39;t
 101 // have to do little shuffling. A suitable jni method is non-static and a
 102 // small number of arguments (two fewer args on windows)
 103 //
 104 //        |-------------------------------------------------------|
 105 //        | c_rarg0   c_rarg1  c_rarg2 c_rarg3 c_rarg4 c_rarg5    |
 106 //        |-------------------------------------------------------|
 107 //        | rcx       rdx      r8      r9      rdi*    rsi*       | windows (* not a c_rarg)
 108 //        | rdi       rsi      rdx     rcx     r8      r9         | solaris/linux
 109 //        |-------------------------------------------------------|
 110 //        | j_rarg5   j_rarg0  j_rarg1 j_rarg2 j_rarg3 j_rarg4    |
 111 //        |-------------------------------------------------------|
 112 
 113 REGISTER_DECLARATION(Register, j_rarg0, c_rarg1);
 114 REGISTER_DECLARATION(Register, j_rarg1, c_rarg2);
 115 REGISTER_DECLARATION(Register, j_rarg2, c_rarg3);
 116 // Windows runs out of register args here
 117 #ifdef _WIN64
 118 REGISTER_DECLARATION(Register, j_rarg3, rdi);
 119 REGISTER_DECLARATION(Register, j_rarg4, rsi);
 120 #else
 121 REGISTER_DECLARATION(Register, j_rarg3, c_rarg4);
 122 REGISTER_DECLARATION(Register, j_rarg4, c_rarg5);
 123 #endif /* _WIN64 */
 124 REGISTER_DECLARATION(Register, j_rarg5, c_rarg0);
 125 
 126 REGISTER_DECLARATION(XMMRegister, j_farg0, xmm0);
 127 REGISTER_DECLARATION(XMMRegister, j_farg1, xmm1);
 128 REGISTER_DECLARATION(XMMRegister, j_farg2, xmm2);
 129 REGISTER_DECLARATION(XMMRegister, j_farg3, xmm3);
 130 REGISTER_DECLARATION(XMMRegister, j_farg4, xmm4);
 131 REGISTER_DECLARATION(XMMRegister, j_farg5, xmm5);
 132 REGISTER_DECLARATION(XMMRegister, j_farg6, xmm6);
 133 REGISTER_DECLARATION(XMMRegister, j_farg7, xmm7);
 134 
 135 REGISTER_DECLARATION(Register, rscratch1, r10);  // volatile
 136 REGISTER_DECLARATION(Register, rscratch2, r11);  // volatile
 137 
 138 REGISTER_DECLARATION(Register, r12_heapbase, r12); // callee-saved
 139 REGISTER_DECLARATION(Register, r15_thread, r15); // callee-saved
 140 
 141 #else
 142 // rscratch1 will apear in 32bit code that is dead but of course must compile
 143 // Using noreg ensures if the dead code is incorrectly live and executed it
 144 // will cause an assertion failure
 145 #define rscratch1 noreg
 146 #define rscratch2 noreg
 147 
 148 #endif // _LP64
 149 
 150 // JSR 292
 151 // On x86, the SP does not have to be saved when invoking method handle intrinsics
 152 // or compiled lambda forms. We indicate that by setting rbp_mh_SP_save to noreg.
 153 REGISTER_DECLARATION(Register, rbp_mh_SP_save, noreg);
 154 
 155 // Address is an abstraction used to represent a memory location
 156 // using any of the amd64 addressing modes with one object.
 157 //
 158 // Note: A register location is represented via a Register, not
 159 //       via an address for efficiency &amp; simplicity reasons.
 160 
 161 class ArrayAddress;
 162 
 163 class Address {
 164  public:
 165   enum ScaleFactor {
 166     no_scale = -1,
 167     times_1  =  0,
 168     times_2  =  1,
 169     times_4  =  2,
 170     times_8  =  3,
 171     times_ptr = LP64_ONLY(times_8) NOT_LP64(times_4)
 172   };
 173   static ScaleFactor times(int size) {
 174     assert(size &gt;= 1 &amp;&amp; size &lt;= 8 &amp;&amp; is_power_of_2(size), &quot;bad scale size&quot;);
 175     if (size == 8)  return times_8;
 176     if (size == 4)  return times_4;
 177     if (size == 2)  return times_2;
 178     return times_1;
 179   }
 180   static int scale_size(ScaleFactor scale) {
 181     assert(scale != no_scale, &quot;&quot;);
 182     assert(((1 &lt;&lt; (int)times_1) == 1 &amp;&amp;
 183             (1 &lt;&lt; (int)times_2) == 2 &amp;&amp;
 184             (1 &lt;&lt; (int)times_4) == 4 &amp;&amp;
 185             (1 &lt;&lt; (int)times_8) == 8), &quot;&quot;);
 186     return (1 &lt;&lt; (int)scale);
 187   }
 188 
 189  private:
 190   Register         _base;
 191   Register         _index;
 192   XMMRegister      _xmmindex;
 193   ScaleFactor      _scale;
 194   int              _disp;
 195   bool             _isxmmindex;
 196   RelocationHolder _rspec;
 197 
 198   // Easily misused constructors make them private
 199   // %%% can we make these go away?
 200   NOT_LP64(Address(address loc, RelocationHolder spec);)
 201   Address(int disp, address loc, relocInfo::relocType rtype);
 202   Address(int disp, address loc, RelocationHolder spec);
 203 
 204  public:
 205 
 206  int disp() { return _disp; }
 207   // creation
 208   Address()
 209     : _base(noreg),
 210       _index(noreg),
 211       _xmmindex(xnoreg),
 212       _scale(no_scale),
 213       _disp(0),
 214       _isxmmindex(false){
 215   }
 216 
 217   // No default displacement otherwise Register can be implicitly
 218   // converted to 0(Register) which is quite a different animal.
 219 
 220   Address(Register base, int disp)
 221     : _base(base),
 222       _index(noreg),
 223       _xmmindex(xnoreg),
 224       _scale(no_scale),
 225       _disp(disp),
 226       _isxmmindex(false){
 227   }
 228 
 229   Address(Register base, Register index, ScaleFactor scale, int disp = 0)
 230     : _base (base),
 231       _index(index),
 232       _xmmindex(xnoreg),
 233       _scale(scale),
 234       _disp (disp),
 235       _isxmmindex(false) {
 236     assert(!index-&gt;is_valid() == (scale == Address::no_scale),
 237            &quot;inconsistent address&quot;);
 238   }
 239 
 240   Address(Register base, RegisterOrConstant index, ScaleFactor scale = times_1, int disp = 0)
 241     : _base (base),
 242       _index(index.register_or_noreg()),
 243       _xmmindex(xnoreg),
 244       _scale(scale),
 245       _disp (disp + (index.constant_or_zero() * scale_size(scale))),
 246       _isxmmindex(false){
 247     if (!index.is_register())  scale = Address::no_scale;
 248     assert(!_index-&gt;is_valid() == (scale == Address::no_scale),
 249            &quot;inconsistent address&quot;);
 250   }
 251 
 252   Address(Register base, XMMRegister index, ScaleFactor scale, int disp = 0)
 253     : _base (base),
 254       _index(noreg),
 255       _xmmindex(index),
 256       _scale(scale),
 257       _disp(disp),
 258       _isxmmindex(true) {
 259       assert(!index-&gt;is_valid() == (scale == Address::no_scale),
 260              &quot;inconsistent address&quot;);
 261   }
 262 
 263   Address plus_disp(int disp) const {
 264     Address a = (*this);
 265     a._disp += disp;
 266     return a;
 267   }
 268   Address plus_disp(RegisterOrConstant disp, ScaleFactor scale = times_1) const {
 269     Address a = (*this);
 270     a._disp += disp.constant_or_zero() * scale_size(scale);
 271     if (disp.is_register()) {
 272       assert(!a.index()-&gt;is_valid(), &quot;competing indexes&quot;);
 273       a._index = disp.as_register();
 274       a._scale = scale;
 275     }
 276     return a;
 277   }
 278   bool is_same_address(Address a) const {
 279     // disregard _rspec
 280     return _base == a._base &amp;&amp; _disp == a._disp &amp;&amp; _index == a._index &amp;&amp; _scale == a._scale;
 281   }
 282 
 283   // The following two overloads are used in connection with the
 284   // ByteSize type (see sizes.hpp).  They simplify the use of
 285   // ByteSize&#39;d arguments in assembly code. Note that their equivalent
 286   // for the optimized build are the member functions with int disp
 287   // argument since ByteSize is mapped to an int type in that case.
 288   //
 289   // Note: DO NOT introduce similar overloaded functions for WordSize
 290   // arguments as in the optimized mode, both ByteSize and WordSize
 291   // are mapped to the same type and thus the compiler cannot make a
 292   // distinction anymore (=&gt; compiler errors).
 293 
 294 #ifdef ASSERT
 295   Address(Register base, ByteSize disp)
 296     : _base(base),
 297       _index(noreg),
 298       _xmmindex(xnoreg),
 299       _scale(no_scale),
 300       _disp(in_bytes(disp)),
 301       _isxmmindex(false){
 302   }
 303 
 304   Address(Register base, Register index, ScaleFactor scale, ByteSize disp)
 305     : _base(base),
 306       _index(index),
 307       _xmmindex(xnoreg),
 308       _scale(scale),
 309       _disp(in_bytes(disp)),
 310       _isxmmindex(false){
 311     assert(!index-&gt;is_valid() == (scale == Address::no_scale),
 312            &quot;inconsistent address&quot;);
 313   }
 314   Address(Register base, RegisterOrConstant index, ScaleFactor scale, ByteSize disp)
 315     : _base (base),
 316       _index(index.register_or_noreg()),
 317       _xmmindex(xnoreg),
 318       _scale(scale),
 319       _disp (in_bytes(disp) + (index.constant_or_zero() * scale_size(scale))),
 320       _isxmmindex(false) {
 321     if (!index.is_register())  scale = Address::no_scale;
 322     assert(!_index-&gt;is_valid() == (scale == Address::no_scale),
 323            &quot;inconsistent address&quot;);
 324   }
 325 
 326 #endif // ASSERT
 327 
 328   // accessors
 329   bool        uses(Register reg) const { return _base == reg || _index == reg; }
 330   Register    base()             const { return _base;  }
 331   Register    index()            const { return _index; }
 332   XMMRegister xmmindex()         const { return _xmmindex; }
 333   ScaleFactor scale()            const { return _scale; }
 334   int         disp()             const { return _disp;  }
 335   bool        isxmmindex()       const { return _isxmmindex; }
 336 
 337   // Convert the raw encoding form into the form expected by the constructor for
 338   // Address.  An index of 4 (rsp) corresponds to having no index, so convert
 339   // that to noreg for the Address constructor.
 340   static Address make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc);
 341 
 342   static Address make_array(ArrayAddress);
 343 
 344  private:
 345   bool base_needs_rex() const {
 346     return _base-&gt;is_valid() &amp;&amp; _base-&gt;encoding() &gt;= 8;
 347   }
 348 
 349   bool index_needs_rex() const {
 350     return _index-&gt;is_valid() &amp;&amp;_index-&gt;encoding() &gt;= 8;
 351   }
 352 
 353   bool xmmindex_needs_rex() const {
 354     return _xmmindex-&gt;is_valid() &amp;&amp; _xmmindex-&gt;encoding() &gt;= 8;
 355   }
 356 
 357   relocInfo::relocType reloc() const { return _rspec.type(); }
 358 
 359   friend class Assembler;
 360   friend class MacroAssembler;
 361   friend class LIR_Assembler; // base/index/scale/disp
 362 };
 363 
 364 //
 365 // AddressLiteral has been split out from Address because operands of this type
 366 // need to be treated specially on 32bit vs. 64bit platforms. By splitting it out
 367 // the few instructions that need to deal with address literals are unique and the
 368 // MacroAssembler does not have to implement every instruction in the Assembler
 369 // in order to search for address literals that may need special handling depending
 370 // on the instruction and the platform. As small step on the way to merging i486/amd64
 371 // directories.
 372 //
 373 class AddressLiteral {
 374   friend class ArrayAddress;
 375   RelocationHolder _rspec;
 376   // Typically we use AddressLiterals we want to use their rval
 377   // However in some situations we want the lval (effect address) of the item.
 378   // We provide a special factory for making those lvals.
 379   bool _is_lval;
 380 
 381   // If the target is far we&#39;ll need to load the ea of this to
 382   // a register to reach it. Otherwise if near we can do rip
 383   // relative addressing.
 384 
 385   address          _target;
 386 
 387  protected:
 388   // creation
 389   AddressLiteral()
 390     : _is_lval(false),
 391       _target(NULL)
 392   {}
 393 
 394   public:
 395 
 396 
 397   AddressLiteral(address target, relocInfo::relocType rtype);
 398 
 399   AddressLiteral(address target, RelocationHolder const&amp; rspec)
 400     : _rspec(rspec),
 401       _is_lval(false),
 402       _target(target)
 403   {}
 404 
 405   AddressLiteral addr() {
 406     AddressLiteral ret = *this;
 407     ret._is_lval = true;
 408     return ret;
 409   }
 410 
 411 
 412  private:
 413 
 414   address target() { return _target; }
 415   bool is_lval() { return _is_lval; }
 416 
 417   relocInfo::relocType reloc() const { return _rspec.type(); }
 418   const RelocationHolder&amp; rspec() const { return _rspec; }
 419 
 420   friend class Assembler;
 421   friend class MacroAssembler;
 422   friend class Address;
 423   friend class LIR_Assembler;
 424 };
 425 
 426 // Convience classes
 427 class RuntimeAddress: public AddressLiteral {
 428 
 429   public:
 430 
 431   RuntimeAddress(address target) : AddressLiteral(target, relocInfo::runtime_call_type) {}
 432 
 433 };
 434 
 435 class ExternalAddress: public AddressLiteral {
 436  private:
 437   static relocInfo::relocType reloc_for_target(address target) {
 438     // Sometimes ExternalAddress is used for values which aren&#39;t
 439     // exactly addresses, like the card table base.
 440     // external_word_type can&#39;t be used for values in the first page
 441     // so just skip the reloc in that case.
 442     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 443   }
 444 
 445  public:
 446 
 447   ExternalAddress(address target) : AddressLiteral(target, reloc_for_target(target)) {}
 448 
 449 };
 450 
 451 class InternalAddress: public AddressLiteral {
 452 
 453   public:
 454 
 455   InternalAddress(address target) : AddressLiteral(target, relocInfo::internal_word_type) {}
 456 
 457 };
 458 
 459 // x86 can do array addressing as a single operation since disp can be an absolute
 460 // address amd64 can&#39;t. We create a class that expresses the concept but does extra
 461 // magic on amd64 to get the final result
 462 
 463 class ArrayAddress {
 464   private:
 465 
 466   AddressLiteral _base;
 467   Address        _index;
 468 
 469   public:
 470 
 471   ArrayAddress() {};
 472   ArrayAddress(AddressLiteral base, Address index): _base(base), _index(index) {};
 473   AddressLiteral base() { return _base; }
 474   Address index() { return _index; }
 475 
 476 };
 477 
 478 class InstructionAttr;
 479 
 480 // 64-bit refect the fxsave size which is 512 bytes and the new xsave area on EVEX which is another 2176 bytes
 481 // See fxsave and xsave(EVEX enabled) documentation for layout
 482 const int FPUStateSizeInWords = NOT_LP64(27) LP64_ONLY(2688 / wordSize);
 483 
 484 // The Intel x86/Amd64 Assembler: Pure assembler doing NO optimizations on the instruction
 485 // level (e.g. mov rax, 0 is not translated into xor rax, rax!); i.e., what you write
 486 // is what you get. The Assembler is generating code into a CodeBuffer.
 487 
 488 class Assembler : public AbstractAssembler  {
 489   friend class AbstractAssembler; // for the non-virtual hack
 490   friend class LIR_Assembler; // as_Address()
 491   friend class StubGenerator;
 492 
 493  public:
 494   enum Condition {                     // The x86 condition codes used for conditional jumps/moves.
 495     zero          = 0x4,
 496     notZero       = 0x5,
 497     equal         = 0x4,
 498     notEqual      = 0x5,
 499     less          = 0xc,
 500     lessEqual     = 0xe,
 501     greater       = 0xf,
 502     greaterEqual  = 0xd,
 503     below         = 0x2,
 504     belowEqual    = 0x6,
 505     above         = 0x7,
 506     aboveEqual    = 0x3,
 507     overflow      = 0x0,
 508     noOverflow    = 0x1,
 509     carrySet      = 0x2,
 510     carryClear    = 0x3,
 511     negative      = 0x8,
 512     positive      = 0x9,
 513     parity        = 0xa,
 514     noParity      = 0xb
 515   };
 516 
 517   enum Prefix {
 518     // segment overrides
 519     CS_segment = 0x2e,
 520     SS_segment = 0x36,
 521     DS_segment = 0x3e,
 522     ES_segment = 0x26,
 523     FS_segment = 0x64,
 524     GS_segment = 0x65,
 525 
 526     REX        = 0x40,
 527 
 528     REX_B      = 0x41,
 529     REX_X      = 0x42,
 530     REX_XB     = 0x43,
 531     REX_R      = 0x44,
 532     REX_RB     = 0x45,
 533     REX_RX     = 0x46,
 534     REX_RXB    = 0x47,
 535 
 536     REX_W      = 0x48,
 537 
 538     REX_WB     = 0x49,
 539     REX_WX     = 0x4A,
 540     REX_WXB    = 0x4B,
 541     REX_WR     = 0x4C,
 542     REX_WRB    = 0x4D,
 543     REX_WRX    = 0x4E,
 544     REX_WRXB   = 0x4F,
 545 
 546     VEX_3bytes = 0xC4,
 547     VEX_2bytes = 0xC5,
 548     EVEX_4bytes = 0x62,
 549     Prefix_EMPTY = 0x0
 550   };
 551 
 552   enum VexPrefix {
 553     VEX_B = 0x20,
 554     VEX_X = 0x40,
 555     VEX_R = 0x80,
 556     VEX_W = 0x80
 557   };
 558 
 559   enum ExexPrefix {
 560     EVEX_F  = 0x04,
 561     EVEX_V  = 0x08,
 562     EVEX_Rb = 0x10,
 563     EVEX_X  = 0x40,
 564     EVEX_Z  = 0x80
 565   };
 566 
 567   enum VexSimdPrefix {
 568     VEX_SIMD_NONE = 0x0,
 569     VEX_SIMD_66   = 0x1,
 570     VEX_SIMD_F3   = 0x2,
 571     VEX_SIMD_F2   = 0x3
 572   };
 573 
 574   enum VexOpcode {
 575     VEX_OPCODE_NONE  = 0x0,
 576     VEX_OPCODE_0F    = 0x1,
 577     VEX_OPCODE_0F_38 = 0x2,
 578     VEX_OPCODE_0F_3A = 0x3,
 579     VEX_OPCODE_MASK  = 0x1F
 580   };
 581 
 582   enum AvxVectorLen {
 583     AVX_128bit = 0x0,
 584     AVX_256bit = 0x1,
 585     AVX_512bit = 0x2,
 586     AVX_NoVec  = 0x4
 587   };
 588 
 589   enum EvexTupleType {
 590     EVEX_FV   = 0,
 591     EVEX_HV   = 4,
 592     EVEX_FVM  = 6,
 593     EVEX_T1S  = 7,
 594     EVEX_T1F  = 11,
 595     EVEX_T2   = 13,
 596     EVEX_T4   = 15,
 597     EVEX_T8   = 17,
 598     EVEX_HVM  = 18,
 599     EVEX_QVM  = 19,
 600     EVEX_OVM  = 20,
 601     EVEX_M128 = 21,
 602     EVEX_DUP  = 22,
 603     EVEX_ETUP = 23
 604   };
 605 
 606   enum EvexInputSizeInBits {
 607     EVEX_8bit  = 0,
 608     EVEX_16bit = 1,
 609     EVEX_32bit = 2,
 610     EVEX_64bit = 3,
 611     EVEX_NObit = 4
 612   };
 613 
 614   enum WhichOperand {
 615     // input to locate_operand, and format code for relocations
 616     imm_operand  = 0,            // embedded 32-bit|64-bit immediate operand
 617     disp32_operand = 1,          // embedded 32-bit displacement or address
 618     call32_operand = 2,          // embedded 32-bit self-relative displacement
 619 #ifndef _LP64
 620     _WhichOperand_limit = 3
 621 #else
 622      narrow_oop_operand = 3,     // embedded 32-bit immediate narrow oop
 623     _WhichOperand_limit = 4
 624 #endif
 625   };
 626 
 627   enum ComparisonPredicate {
 628     eq = 0,
 629     lt = 1,
 630     le = 2,
 631     _false = 3,
 632     neq = 4,
 633     nlt = 5,
 634     nle = 6,
 635     _true = 7
 636   };
 637 
 638   //---&lt;  calculate length of instruction  &gt;---
 639   // As instruction size can&#39;t be found out easily on x86/x64,
 640   // we just use &#39;4&#39; for len and maxlen.
 641   // instruction must start at passed address
 642   static unsigned int instr_len(unsigned char *instr) { return 4; }
 643 
 644   //---&lt;  longest instructions  &gt;---
 645   // Max instruction length is not specified in architecture documentation.
 646   // We could use a &quot;safe enough&quot; estimate (15), but just default to
 647   // instruction length guess from above.
 648   static unsigned int instr_maxlen() { return 4; }
 649 
 650   // NOTE: The general philopsophy of the declarations here is that 64bit versions
 651   // of instructions are freely declared without the need for wrapping them an ifdef.
 652   // (Some dangerous instructions are ifdef&#39;s out of inappropriate jvm&#39;s.)
 653   // In the .cpp file the implementations are wrapped so that they are dropped out
 654   // of the resulting jvm. This is done mostly to keep the footprint of MINIMAL
 655   // to the size it was prior to merging up the 32bit and 64bit assemblers.
 656   //
 657   // This does mean you&#39;ll get a linker/runtime error if you use a 64bit only instruction
 658   // in a 32bit vm. This is somewhat unfortunate but keeps the ifdef noise down.
 659 
 660 private:
 661 
 662   bool _legacy_mode_bw;
 663   bool _legacy_mode_dq;
 664   bool _legacy_mode_vl;
 665   bool _legacy_mode_vlbw;
 666   NOT_LP64(bool _is_managed;)
 667 
 668   class InstructionAttr *_attributes;
 669 
 670   // 64bit prefixes
 671   void prefix(Register reg);
 672   void prefix(Register dst, Register src, Prefix p);
 673   void prefix(Register dst, Address adr, Prefix p);
 674 
 675   void prefix(Address adr);
 676   void prefix(Address adr, Register reg,  bool byteinst = false);
 677   void prefix(Address adr, XMMRegister reg);
 678 
 679   int prefix_and_encode(int reg_enc, bool byteinst = false);
 680   int prefix_and_encode(int dst_enc, int src_enc) {
 681     return prefix_and_encode(dst_enc, false, src_enc, false);
 682   }
 683   int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte);
 684 
 685   // Some prefixq variants always emit exactly one prefix byte, so besides a
 686   // prefix-emitting method we provide a method to get the prefix byte to emit,
 687   // which can then be folded into a byte stream.
 688   int8_t get_prefixq(Address adr);
 689   int8_t get_prefixq(Address adr, Register reg);
 690 
 691   void prefixq(Address adr);
 692   void prefixq(Address adr, Register reg);
 693   void prefixq(Address adr, XMMRegister reg);
 694 
 695   int prefixq_and_encode(int reg_enc);
 696   int prefixq_and_encode(int dst_enc, int src_enc);
 697 
 698   void rex_prefix(Address adr, XMMRegister xreg,
 699                   VexSimdPrefix pre, VexOpcode opc, bool rex_w);
 700   int  rex_prefix_and_encode(int dst_enc, int src_enc,
 701                              VexSimdPrefix pre, VexOpcode opc, bool rex_w);
 702 
 703   void vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc);
 704 
 705   void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v,
 706                    int nds_enc, VexSimdPrefix pre, VexOpcode opc);
 707 
 708   void vex_prefix(Address adr, int nds_enc, int xreg_enc,
 709                   VexSimdPrefix pre, VexOpcode opc,
 710                   InstructionAttr *attributes);
 711 
 712   int  vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc,
 713                              VexSimdPrefix pre, VexOpcode opc,
 714                              InstructionAttr *attributes);
 715 
 716   void simd_prefix(XMMRegister xreg, XMMRegister nds, Address adr, VexSimdPrefix pre,
 717                    VexOpcode opc, InstructionAttr *attributes);
 718 
 719   int simd_prefix_and_encode(XMMRegister dst, XMMRegister nds, XMMRegister src, VexSimdPrefix pre,
 720                              VexOpcode opc, InstructionAttr *attributes);
 721 
 722   // Helper functions for groups of instructions
 723   void emit_arith_b(int op1, int op2, Register dst, int imm8);
 724 
 725   void emit_arith(int op1, int op2, Register dst, int32_t imm32);
 726   // Force generation of a 4 byte immediate value even if it fits into 8bit
 727   void emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32);
 728   void emit_arith(int op1, int op2, Register dst, Register src);
 729 
 730   bool emit_compressed_disp_byte(int &amp;disp);
 731 
 732   void emit_modrm(int mod, int dst_enc, int src_enc);
 733   void emit_modrm_disp8(int mod, int dst_enc, int src_enc,
 734                         int disp);
 735   void emit_modrm_sib(int mod, int dst_enc, int src_enc,
 736                       Address::ScaleFactor scale, int index_enc, int base_enc);
 737   void emit_modrm_sib_disp8(int mod, int dst_enc, int src_enc,
 738                             Address::ScaleFactor scale, int index_enc, int base_enc,
 739                             int disp);
 740 
 741   void emit_operand_helper(int reg_enc,
 742                            int base_enc, int index_enc, Address::ScaleFactor scale,
 743                            int disp,
 744                            RelocationHolder const&amp; rspec,
 745                            int rip_relative_correction = 0);
 746 
 747   void emit_operand(Register reg,
 748                     Register base, Register index, Address::ScaleFactor scale,
 749                     int disp,
 750                     RelocationHolder const&amp; rspec,
 751                     int rip_relative_correction = 0);
 752 
 753   void emit_operand(Register reg,
 754                     Register base, XMMRegister index, Address::ScaleFactor scale,
 755                     int disp,
 756                     RelocationHolder const&amp; rspec);
 757 
 758   void emit_operand(XMMRegister xreg,
 759                     Register base, XMMRegister xindex, Address::ScaleFactor scale,
 760                     int disp,
 761                     RelocationHolder const&amp; rspec);
 762 
 763   void emit_operand(Register reg, Address adr,
 764                     int rip_relative_correction = 0);
 765 
 766   void emit_operand(XMMRegister reg,
 767                     Register base, Register index, Address::ScaleFactor scale,
 768                     int disp,
 769                     RelocationHolder const&amp; rspec);
 770 
 771   void emit_operand(XMMRegister reg, Address adr);
 772 
 773   // Immediate-to-memory forms
 774   void emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32);
 775 
 776  protected:
 777   #ifdef ASSERT
 778   void check_relocation(RelocationHolder const&amp; rspec, int format);
 779   #endif
 780 
 781   void emit_data(jint data, relocInfo::relocType    rtype, int format);
 782   void emit_data(jint data, RelocationHolder const&amp; rspec, int format);
 783   void emit_data64(jlong data, relocInfo::relocType rtype, int format = 0);
 784   void emit_data64(jlong data, RelocationHolder const&amp; rspec, int format = 0);
 785 
 786   bool reachable(AddressLiteral adr) NOT_LP64({ return true;});
 787 
 788   // These are all easily abused and hence protected
 789 
 790   // 32BIT ONLY SECTION
 791 #ifndef _LP64
 792   // Make these disappear in 64bit mode since they would never be correct
 793   void cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec);   // 32BIT ONLY
 794   void cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec);    // 32BIT ONLY
 795 
 796   void mov_literal32(Register dst, int32_t imm32, RelocationHolder const&amp; rspec);    // 32BIT ONLY
 797   void mov_literal32(Address dst, int32_t imm32, RelocationHolder const&amp; rspec);     // 32BIT ONLY
 798 
 799   void push_literal32(int32_t imm32, RelocationHolder const&amp; rspec);                 // 32BIT ONLY
 800 #else
 801   // 64BIT ONLY SECTION
 802   void mov_literal64(Register dst, intptr_t imm64, RelocationHolder const&amp; rspec);   // 64BIT ONLY
 803 
 804   void cmp_narrow_oop(Register src1, int32_t imm32, RelocationHolder const&amp; rspec);
 805   void cmp_narrow_oop(Address src1, int32_t imm32, RelocationHolder const&amp; rspec);
 806 
 807   void mov_narrow_oop(Register dst, int32_t imm32, RelocationHolder const&amp; rspec);
 808   void mov_narrow_oop(Address dst, int32_t imm32, RelocationHolder const&amp; rspec);
 809 #endif // _LP64
 810 
 811   // These are unique in that we are ensured by the caller that the 32bit
 812   // relative in these instructions will always be able to reach the potentially
 813   // 64bit address described by entry. Since they can take a 64bit address they
 814   // don&#39;t have the 32 suffix like the other instructions in this class.
 815 
 816   void call_literal(address entry, RelocationHolder const&amp; rspec);
 817   void jmp_literal(address entry, RelocationHolder const&amp; rspec);
 818 
 819   // Avoid using directly section
 820   // Instructions in this section are actually usable by anyone without danger
 821   // of failure but have performance issues that are addressed my enhanced
 822   // instructions which will do the proper thing base on the particular cpu.
 823   // We protect them because we don&#39;t trust you...
 824 
 825   // Don&#39;t use next inc() and dec() methods directly. INC &amp; DEC instructions
 826   // could cause a partial flag stall since they don&#39;t set CF flag.
 827   // Use MacroAssembler::decrement() &amp; MacroAssembler::increment() methods
 828   // which call inc() &amp; dec() or add() &amp; sub() in accordance with
 829   // the product flag UseIncDec value.
 830 
 831   void decl(Register dst);
 832   void decl(Address dst);
 833   void decq(Register dst);
 834   void decq(Address dst);
 835 
 836   void incl(Register dst);
 837   void incl(Address dst);
 838   void incq(Register dst);
 839   void incq(Address dst);
 840 
 841   // New cpus require use of movsd and movss to avoid partial register stall
 842   // when loading from memory. But for old Opteron use movlpd instead of movsd.
 843   // The selection is done in MacroAssembler::movdbl() and movflt().
 844 
 845   // Move Scalar Single-Precision Floating-Point Values
 846   void movss(XMMRegister dst, Address src);
 847   void movss(XMMRegister dst, XMMRegister src);
 848   void movss(Address dst, XMMRegister src);
 849 
 850   // Move Scalar Double-Precision Floating-Point Values
 851   void movsd(XMMRegister dst, Address src);
 852   void movsd(XMMRegister dst, XMMRegister src);
 853   void movsd(Address dst, XMMRegister src);
 854   void movlpd(XMMRegister dst, Address src);
 855 
 856   // New cpus require use of movaps and movapd to avoid partial register stall
 857   // when moving between registers.
 858   void movaps(XMMRegister dst, XMMRegister src);
 859   void movapd(XMMRegister dst, XMMRegister src);
 860 
 861   // End avoid using directly
 862 
 863 
 864   // Instruction prefixes
 865   void prefix(Prefix p);
 866 
 867   public:
 868 
 869   // Creation
 870   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
 871     init_attributes();
 872   }
 873 
 874   // Decoding
 875   static address locate_operand(address inst, WhichOperand which);
 876   static address locate_next_instruction(address inst);
 877 
 878   // Utilities
 879   static bool query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
 880                                          int cur_tuple_type, int in_size_in_bits, int cur_encoding);
 881 
 882   // Generic instructions
 883   // Does 32bit or 64bit as needed for the platform. In some sense these
 884   // belong in macro assembler but there is no need for both varieties to exist
 885 
 886   void init_attributes(void) {
 887     _legacy_mode_bw = (VM_Version::supports_avx512bw() == false);
 888     _legacy_mode_dq = (VM_Version::supports_avx512dq() == false);
 889     _legacy_mode_vl = (VM_Version::supports_avx512vl() == false);
 890     _legacy_mode_vlbw = (VM_Version::supports_avx512vlbw() == false);
 891     NOT_LP64(_is_managed = false;)
 892     _attributes = NULL;
 893   }
 894 
 895   void set_attributes(InstructionAttr *attributes) { _attributes = attributes; }
 896   void clear_attributes(void) { _attributes = NULL; }
 897 
 898   void set_managed(void) { NOT_LP64(_is_managed = true;) }
 899   void clear_managed(void) { NOT_LP64(_is_managed = false;) }
 900   bool is_managed(void) {
 901     NOT_LP64(return _is_managed;)
 902     LP64_ONLY(return false;) }
 903 
 904   void lea(Register dst, Address src);
 905 
 906   void mov(Register dst, Register src);
 907 
 908 #ifdef _LP64
 909   // support caching the result of some routines
 910 
 911   // must be called before pusha(), popa(), vzeroupper() - checked with asserts
 912   static void precompute_instructions();
 913 
 914   void pusha_uncached();
 915   void popa_uncached();
 916 #endif
 917   void vzeroupper_uncached();
 918 
 919   void pusha();
 920   void popa();
 921 
 922   void pushf();
 923   void popf();
 924 
 925   void push(int32_t imm32);
 926 
 927   void push(Register src);
 928 
 929   void pop(Register dst);
 930 
 931   // These are dummies to prevent surprise implicit conversions to Register
 932   void push(void* v);
 933   void pop(void* v);
 934 
 935   // These do register sized moves/scans
 936   void rep_mov();
 937   void rep_stos();
 938   void rep_stosb();
 939   void repne_scan();
 940 #ifdef _LP64
 941   void repne_scanl();
 942 #endif
 943 
 944   // Vanilla instructions in lexical order
 945 
 946   void adcl(Address dst, int32_t imm32);
 947   void adcl(Address dst, Register src);
 948   void adcl(Register dst, int32_t imm32);
 949   void adcl(Register dst, Address src);
 950   void adcl(Register dst, Register src);
 951 
 952   void adcq(Register dst, int32_t imm32);
 953   void adcq(Register dst, Address src);
 954   void adcq(Register dst, Register src);
 955 
 956   void addb(Address dst, int imm8);
 957   void addw(Address dst, int imm16);
 958 
 959   void addl(Address dst, int32_t imm32);
 960   void addl(Address dst, Register src);
 961   void addl(Register dst, int32_t imm32);
 962   void addl(Register dst, Address src);
 963   void addl(Register dst, Register src);
 964 
 965   void addq(Address dst, int32_t imm32);
 966   void addq(Address dst, Register src);
 967   void addq(Register dst, int32_t imm32);
 968   void addq(Register dst, Address src);
 969   void addq(Register dst, Register src);
 970 
 971 #ifdef _LP64
 972  //Add Unsigned Integers with Carry Flag
 973   void adcxq(Register dst, Register src);
 974 
 975  //Add Unsigned Integers with Overflow Flag
 976   void adoxq(Register dst, Register src);
 977 #endif
 978 
 979   void addr_nop_4();
 980   void addr_nop_5();
 981   void addr_nop_7();
 982   void addr_nop_8();
 983 
 984   // Add Scalar Double-Precision Floating-Point Values
 985   void addsd(XMMRegister dst, Address src);
 986   void addsd(XMMRegister dst, XMMRegister src);
 987 
 988   // Add Scalar Single-Precision Floating-Point Values
 989   void addss(XMMRegister dst, Address src);
 990   void addss(XMMRegister dst, XMMRegister src);
 991 
 992   // AES instructions
 993   void aesdec(XMMRegister dst, Address src);
 994   void aesdec(XMMRegister dst, XMMRegister src);
 995   void aesdeclast(XMMRegister dst, Address src);
 996   void aesdeclast(XMMRegister dst, XMMRegister src);
 997   void aesenc(XMMRegister dst, Address src);
 998   void aesenc(XMMRegister dst, XMMRegister src);
 999   void aesenclast(XMMRegister dst, Address src);
1000   void aesenclast(XMMRegister dst, XMMRegister src);
1001   // Vector AES instructions
1002   void vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1003   void vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1004   void vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1005   void vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1006 
1007   void andl(Address  dst, int32_t imm32);
1008   void andl(Register dst, int32_t imm32);
1009   void andl(Register dst, Address src);
1010   void andl(Register dst, Register src);
1011 
1012   void andq(Address  dst, int32_t imm32);
1013   void andq(Register dst, int32_t imm32);
1014   void andq(Register dst, Address src);
1015   void andq(Register dst, Register src);
1016 
1017   // BMI instructions
1018   void andnl(Register dst, Register src1, Register src2);
1019   void andnl(Register dst, Register src1, Address src2);
1020   void andnq(Register dst, Register src1, Register src2);
1021   void andnq(Register dst, Register src1, Address src2);
1022 
1023   void blsil(Register dst, Register src);
1024   void blsil(Register dst, Address src);
1025   void blsiq(Register dst, Register src);
1026   void blsiq(Register dst, Address src);
1027 
1028   void blsmskl(Register dst, Register src);
1029   void blsmskl(Register dst, Address src);
1030   void blsmskq(Register dst, Register src);
1031   void blsmskq(Register dst, Address src);
1032 
1033   void blsrl(Register dst, Register src);
1034   void blsrl(Register dst, Address src);
1035   void blsrq(Register dst, Register src);
1036   void blsrq(Register dst, Address src);
1037 
1038   void bsfl(Register dst, Register src);
1039   void bsrl(Register dst, Register src);
1040 
1041 #ifdef _LP64
1042   void bsfq(Register dst, Register src);
1043   void bsrq(Register dst, Register src);
1044 #endif
1045 
1046   void bswapl(Register reg);
1047 
1048   void bswapq(Register reg);
1049 
1050   void call(Label&amp; L, relocInfo::relocType rtype);
1051   void call(Register reg);  // push pc; pc &lt;- reg
1052   void call(Address adr);   // push pc; pc &lt;- adr
1053 
1054   void cdql();
1055 
1056   void cdqq();
1057 
1058   void cld();
1059 
1060   void clflush(Address adr);
1061   void clflushopt(Address adr);
1062   void clwb(Address adr);
1063 
1064   void cmovl(Condition cc, Register dst, Register src);
1065   void cmovl(Condition cc, Register dst, Address src);
1066 
1067   void cmovq(Condition cc, Register dst, Register src);
1068   void cmovq(Condition cc, Register dst, Address src);
1069 
1070 
1071   void cmpb(Address dst, int imm8);
1072 
1073   void cmpl(Address dst, int32_t imm32);
1074 
1075   void cmpl(Register dst, int32_t imm32);
1076   void cmpl(Register dst, Register src);
1077   void cmpl(Register dst, Address src);
1078 
1079   void cmpq(Address dst, int32_t imm32);
1080   void cmpq(Address dst, Register src);
1081 
1082   void cmpq(Register dst, int32_t imm32);
1083   void cmpq(Register dst, Register src);
1084   void cmpq(Register dst, Address src);
1085 
1086   // these are dummies used to catch attempting to convert NULL to Register
1087   void cmpl(Register dst, void* junk); // dummy
1088   void cmpq(Register dst, void* junk); // dummy
1089 
1090   void cmpw(Address dst, int imm16);
1091 
1092   void cmpxchg8 (Address adr);
1093 
1094   void cmpxchgb(Register reg, Address adr);
1095   void cmpxchgl(Register reg, Address adr);
1096 
1097   void cmpxchgq(Register reg, Address adr);
1098 
1099   // Ordered Compare Scalar Double-Precision Floating-Point Values and set EFLAGS
1100   void comisd(XMMRegister dst, Address src);
1101   void comisd(XMMRegister dst, XMMRegister src);
1102 
1103   // Ordered Compare Scalar Single-Precision Floating-Point Values and set EFLAGS
1104   void comiss(XMMRegister dst, Address src);
1105   void comiss(XMMRegister dst, XMMRegister src);
1106 
1107   // Identify processor type and features
1108   void cpuid();
1109 
1110   // CRC32C
1111   void crc32(Register crc, Register v, int8_t sizeInBytes);
1112   void crc32(Register crc, Address adr, int8_t sizeInBytes);
1113 
1114   // Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value
1115   void cvtsd2ss(XMMRegister dst, XMMRegister src);
1116   void cvtsd2ss(XMMRegister dst, Address src);
1117 
1118   // Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value
1119   void cvtsi2sdl(XMMRegister dst, Register src);
1120   void cvtsi2sdl(XMMRegister dst, Address src);
1121   void cvtsi2sdq(XMMRegister dst, Register src);
1122   void cvtsi2sdq(XMMRegister dst, Address src);
1123 
1124   // Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value
1125   void cvtsi2ssl(XMMRegister dst, Register src);
1126   void cvtsi2ssl(XMMRegister dst, Address src);
1127   void cvtsi2ssq(XMMRegister dst, Register src);
1128   void cvtsi2ssq(XMMRegister dst, Address src);
1129 
1130   // Convert Packed Signed Doubleword Integers to Packed Double-Precision Floating-Point Value
1131   void cvtdq2pd(XMMRegister dst, XMMRegister src);
1132 
1133   // Convert Packed Signed Doubleword Integers to Packed Single-Precision Floating-Point Value
1134   void cvtdq2ps(XMMRegister dst, XMMRegister src);
1135 
1136   // Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value
1137   void cvtss2sd(XMMRegister dst, XMMRegister src);
1138   void cvtss2sd(XMMRegister dst, Address src);
1139 
1140   // Convert with Truncation Scalar Double-Precision Floating-Point Value to Doubleword Integer
1141   void cvttsd2sil(Register dst, Address src);
1142   void cvttsd2sil(Register dst, XMMRegister src);
1143   void cvttsd2siq(Register dst, Address src);
1144   void cvttsd2siq(Register dst, XMMRegister src);
1145 
1146   // Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer
1147   void cvttss2sil(Register dst, XMMRegister src);
1148   void cvttss2siq(Register dst, XMMRegister src);
1149 
1150   void cvttpd2dq(XMMRegister dst, XMMRegister src);
1151 
1152   //Abs of packed Integer values
1153   void pabsb(XMMRegister dst, XMMRegister src);
1154   void pabsw(XMMRegister dst, XMMRegister src);
1155   void pabsd(XMMRegister dst, XMMRegister src);
1156   void vpabsb(XMMRegister dst, XMMRegister src, int vector_len);
1157   void vpabsw(XMMRegister dst, XMMRegister src, int vector_len);
1158   void vpabsd(XMMRegister dst, XMMRegister src, int vector_len);
1159   void evpabsq(XMMRegister dst, XMMRegister src, int vector_len);
1160 
1161   // Divide Scalar Double-Precision Floating-Point Values
1162   void divsd(XMMRegister dst, Address src);
1163   void divsd(XMMRegister dst, XMMRegister src);
1164 
1165   // Divide Scalar Single-Precision Floating-Point Values
1166   void divss(XMMRegister dst, Address src);
1167   void divss(XMMRegister dst, XMMRegister src);
1168 
1169 
1170 #ifndef _LP64
1171  private:
<a name="3" id="anc3"></a>

1172 
1173   void emit_farith(int b1, int b2, int i);
1174 
1175  public:
1176   void emms();
1177 
1178   void fabs();
1179 
1180   void fadd(int i);
1181 
1182   void fadd_d(Address src);
1183   void fadd_s(Address src);
1184 
1185   // &quot;Alternate&quot; versions of x87 instructions place result down in FPU
1186   // stack instead of on TOS
1187 
1188   void fadda(int i); // &quot;alternate&quot; fadd
1189   void faddp(int i = 1);
1190 
1191   void fchs();
1192 
1193   void fcom(int i);
1194 
1195   void fcomp(int i = 1);
1196   void fcomp_d(Address src);
1197   void fcomp_s(Address src);
1198 
1199   void fcompp();
1200 
1201   void fcos();
1202 
1203   void fdecstp();
1204 
1205   void fdiv(int i);
1206   void fdiv_d(Address src);
1207   void fdivr_s(Address src);
1208   void fdiva(int i);  // &quot;alternate&quot; fdiv
1209   void fdivp(int i = 1);
1210 
1211   void fdivr(int i);
1212   void fdivr_d(Address src);
1213   void fdiv_s(Address src);
1214 
1215   void fdivra(int i); // &quot;alternate&quot; reversed fdiv
1216 
1217   void fdivrp(int i = 1);
1218 
1219   void ffree(int i = 0);
1220 
1221   void fild_d(Address adr);
1222   void fild_s(Address adr);
1223 
1224   void fincstp();
1225 
1226   void finit();
1227 
1228   void fist_s (Address adr);
1229   void fistp_d(Address adr);
1230   void fistp_s(Address adr);
1231 
1232   void fld1();
1233 
1234   void fld_d(Address adr);
1235   void fld_s(Address adr);
1236   void fld_s(int index);
<a name="4" id="anc4"></a>
1237 
1238   void fldcw(Address src);
1239 
1240   void fldenv(Address src);
1241 
1242   void fldlg2();
1243 
1244   void fldln2();
1245 
1246   void fldz();
1247 
1248   void flog();
1249   void flog10();
1250 
1251   void fmul(int i);
1252 
1253   void fmul_d(Address src);
1254   void fmul_s(Address src);
1255 
1256   void fmula(int i);  // &quot;alternate&quot; fmul
1257 
1258   void fmulp(int i = 1);
1259 
1260   void fnsave(Address dst);
1261 
1262   void fnstcw(Address src);
1263 
1264   void fnstsw_ax();
1265 
1266   void fprem();
1267   void fprem1();
1268 
1269   void frstor(Address src);
1270 
1271   void fsin();
1272 
1273   void fsqrt();
1274 
1275   void fst_d(Address adr);
1276   void fst_s(Address adr);
1277 
1278   void fstp_d(Address adr);
1279   void fstp_d(int index);
1280   void fstp_s(Address adr);
<a name="5" id="anc5"></a>
1281 
1282   void fsub(int i);
1283   void fsub_d(Address src);
1284   void fsub_s(Address src);
1285 
1286   void fsuba(int i);  // &quot;alternate&quot; fsub
1287 
1288   void fsubp(int i = 1);
1289 
1290   void fsubr(int i);
1291   void fsubr_d(Address src);
1292   void fsubr_s(Address src);
1293 
1294   void fsubra(int i); // &quot;alternate&quot; reversed fsub
1295 
1296   void fsubrp(int i = 1);
1297 
1298   void ftan();
1299 
1300   void ftst();
1301 
1302   void fucomi(int i = 1);
1303   void fucomip(int i = 1);
1304 
1305   void fwait();
1306 
1307   void fxch(int i = 1);
1308 
1309   void fyl2x();
1310   void frndint();
1311   void f2xm1();
1312   void fldl2e();
1313 #endif // !_LP64
1314 
<a name="6" id="anc6"></a><span class="line-added">1315   // operands that only take the original 32bit registers</span>
<span class="line-added">1316   void emit_operand32(Register reg, Address adr);</span>
<span class="line-added">1317 </span>
<span class="line-added">1318   void fld_x(Address adr);  // extended-precision (80-bit) format</span>
<span class="line-added">1319   void fstp_x(Address adr); // extended-precision (80-bit) format</span>
1320   void fxrstor(Address src);
1321   void xrstor(Address src);
1322 
1323   void fxsave(Address dst);
1324   void xsave(Address dst);
1325 
1326   void hlt();
1327 
1328   void idivl(Register src);
1329   void divl(Register src); // Unsigned division
1330 
1331 #ifdef _LP64
1332   void idivq(Register src);
1333 #endif
1334 
1335   void imull(Register src);
1336   void imull(Register dst, Register src);
1337   void imull(Register dst, Register src, int value);
1338   void imull(Register dst, Address src);
1339 
1340 #ifdef _LP64
1341   void imulq(Register dst, Register src);
1342   void imulq(Register dst, Register src, int value);
1343   void imulq(Register dst, Address src);
1344 #endif
1345 
1346   // jcc is the generic conditional branch generator to run-
1347   // time routines, jcc is used for branches to labels. jcc
1348   // takes a branch opcode (cc) and a label (L) and generates
1349   // either a backward branch or a forward branch and links it
1350   // to the label fixup chain. Usage:
1351   //
1352   // Label L;      // unbound label
1353   // jcc(cc, L);   // forward branch to unbound label
1354   // bind(L);      // bind label to the current pc
1355   // jcc(cc, L);   // backward branch to bound label
1356   // bind(L);      // illegal: a label may be bound only once
1357   //
1358   // Note: The same Label can be used for forward and backward branches
1359   // but it may be bound only once.
1360 
1361   void jcc(Condition cc, Label&amp; L, bool maybe_short = true);
1362 
1363   // Conditional jump to a 8-bit offset to L.
1364   // WARNING: be very careful using this for forward jumps.  If the label is
1365   // not bound within an 8-bit offset of this instruction, a run-time error
1366   // will occur.
1367 
1368   // Use macro to record file and line number.
1369   #define jccb(cc, L) jccb_0(cc, L, __FILE__, __LINE__)
1370 
1371   void jccb_0(Condition cc, Label&amp; L, const char* file, int line);
1372 
1373   void jmp(Address entry);    // pc &lt;- entry
1374 
1375   // Label operations &amp; relative jumps (PPUM Appendix D)
1376   void jmp(Label&amp; L, bool maybe_short = true);   // unconditional jump to L
1377 
1378   void jmp(Register entry); // pc &lt;- entry
1379 
1380   // Unconditional 8-bit offset jump to L.
1381   // WARNING: be very careful using this for forward jumps.  If the label is
1382   // not bound within an 8-bit offset of this instruction, a run-time error
1383   // will occur.
1384 
1385   // Use macro to record file and line number.
1386   #define jmpb(L) jmpb_0(L, __FILE__, __LINE__)
1387 
1388   void jmpb_0(Label&amp; L, const char* file, int line);
1389 
1390   void ldmxcsr( Address src );
1391 
1392   void leal(Register dst, Address src);
1393 
1394   void leaq(Register dst, Address src);
1395 
1396   void lfence();
1397 
1398   void lock();
1399 
1400   void lzcntl(Register dst, Register src);
1401 
1402 #ifdef _LP64
1403   void lzcntq(Register dst, Register src);
1404 #endif
1405 
1406   enum Membar_mask_bits {
1407     StoreStore = 1 &lt;&lt; 3,
1408     LoadStore  = 1 &lt;&lt; 2,
1409     StoreLoad  = 1 &lt;&lt; 1,
1410     LoadLoad   = 1 &lt;&lt; 0
1411   };
1412 
1413   // Serializes memory and blows flags
1414   void membar(Membar_mask_bits order_constraint) {
1415     // We only have to handle StoreLoad
1416     if (order_constraint &amp; StoreLoad) {
1417       // All usable chips support &quot;locked&quot; instructions which suffice
1418       // as barriers, and are much faster than the alternative of
1419       // using cpuid instruction. We use here a locked add [esp-C],0.
1420       // This is conveniently otherwise a no-op except for blowing
1421       // flags, and introducing a false dependency on target memory
1422       // location. We can&#39;t do anything with flags, but we can avoid
1423       // memory dependencies in the current method by locked-adding
1424       // somewhere else on the stack. Doing [esp+C] will collide with
1425       // something on stack in current method, hence we go for [esp-C].
1426       // It is convenient since it is almost always in data cache, for
1427       // any small C.  We need to step back from SP to avoid data
1428       // dependencies with other things on below SP (callee-saves, for
1429       // example). Without a clear way to figure out the minimal safe
1430       // distance from SP, it makes sense to step back the complete
1431       // cache line, as this will also avoid possible second-order effects
1432       // with locked ops against the cache line. Our choice of offset
1433       // is bounded by x86 operand encoding, which should stay within
1434       // [-128; +127] to have the 8-byte displacement encoding.
1435       //
1436       // Any change to this code may need to revisit other places in
1437       // the code where this idiom is used, in particular the
1438       // orderAccess code.
1439 
1440       int offset = -VM_Version::L1_line_size();
1441       if (offset &lt; -128) {
1442         offset = -128;
1443       }
1444 
1445       lock();
1446       addl(Address(rsp, offset), 0);// Assert the lock# signal here
1447     }
1448   }
1449 
1450   void mfence();
1451   void sfence();
1452 
1453   // Moves
1454 
1455   void mov64(Register dst, int64_t imm64);
1456 
1457   void movb(Address dst, Register src);
1458   void movb(Address dst, int imm8);
1459   void movb(Register dst, Address src);
1460 
1461   void movddup(XMMRegister dst, XMMRegister src);
1462 
1463   void kmovbl(KRegister dst, Register src);
1464   void kmovbl(Register dst, KRegister src);
1465   void kmovwl(KRegister dst, Register src);
1466   void kmovwl(KRegister dst, Address src);
1467   void kmovwl(Register dst, KRegister src);
1468   void kmovdl(KRegister dst, Register src);
1469   void kmovdl(Register dst, KRegister src);
1470   void kmovql(KRegister dst, KRegister src);
1471   void kmovql(Address dst, KRegister src);
1472   void kmovql(KRegister dst, Address src);
1473   void kmovql(KRegister dst, Register src);
1474   void kmovql(Register dst, KRegister src);
1475 
1476   void knotwl(KRegister dst, KRegister src);
1477 
1478   void kortestbl(KRegister dst, KRegister src);
1479   void kortestwl(KRegister dst, KRegister src);
1480   void kortestdl(KRegister dst, KRegister src);
1481   void kortestql(KRegister dst, KRegister src);
1482 
1483   void ktestq(KRegister src1, KRegister src2);
1484   void ktestd(KRegister src1, KRegister src2);
1485 
1486   void ktestql(KRegister dst, KRegister src);
1487 
1488   void movdl(XMMRegister dst, Register src);
1489   void movdl(Register dst, XMMRegister src);
1490   void movdl(XMMRegister dst, Address src);
1491   void movdl(Address dst, XMMRegister src);
1492 
1493   // Move Double Quadword
1494   void movdq(XMMRegister dst, Register src);
1495   void movdq(Register dst, XMMRegister src);
1496 
1497   // Move Aligned Double Quadword
1498   void movdqa(XMMRegister dst, XMMRegister src);
1499   void movdqa(XMMRegister dst, Address src);
1500 
1501   // Move Unaligned Double Quadword
1502   void movdqu(Address     dst, XMMRegister src);
1503   void movdqu(XMMRegister dst, Address src);
1504   void movdqu(XMMRegister dst, XMMRegister src);
1505 
1506   // Move Unaligned 256bit Vector
1507   void vmovdqu(Address dst, XMMRegister src);
1508   void vmovdqu(XMMRegister dst, Address src);
1509   void vmovdqu(XMMRegister dst, XMMRegister src);
1510 
1511    // Move Unaligned 512bit Vector
1512   void evmovdqub(Address dst, XMMRegister src, int vector_len);
1513   void evmovdqub(XMMRegister dst, Address src, int vector_len);
1514   void evmovdqub(XMMRegister dst, XMMRegister src, int vector_len);
1515   void evmovdqub(XMMRegister dst, KRegister mask, Address src, int vector_len);
1516   void evmovdquw(Address dst, XMMRegister src, int vector_len);
1517   void evmovdquw(Address dst, KRegister mask, XMMRegister src, int vector_len);
1518   void evmovdquw(XMMRegister dst, Address src, int vector_len);
1519   void evmovdquw(XMMRegister dst, KRegister mask, Address src, int vector_len);
1520   void evmovdqul(Address dst, XMMRegister src, int vector_len);
1521   void evmovdqul(XMMRegister dst, Address src, int vector_len);
1522   void evmovdqul(XMMRegister dst, XMMRegister src, int vector_len);
1523   void evmovdquq(Address dst, XMMRegister src, int vector_len);
1524   void evmovdquq(XMMRegister dst, Address src, int vector_len);
1525   void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len);
1526 
1527   // Move lower 64bit to high 64bit in 128bit register
1528   void movlhps(XMMRegister dst, XMMRegister src);
1529 
1530   void movl(Register dst, int32_t imm32);
1531   void movl(Address dst, int32_t imm32);
1532   void movl(Register dst, Register src);
1533   void movl(Register dst, Address src);
1534   void movl(Address dst, Register src);
1535 
1536   // These dummies prevent using movl from converting a zero (like NULL) into Register
1537   // by giving the compiler two choices it can&#39;t resolve
1538 
1539   void movl(Address  dst, void* junk);
1540   void movl(Register dst, void* junk);
1541 
1542 #ifdef _LP64
1543   void movq(Register dst, Register src);
1544   void movq(Register dst, Address src);
1545   void movq(Address  dst, Register src);
1546 
1547   // These dummies prevent using movq from converting a zero (like NULL) into Register
1548   // by giving the compiler two choices it can&#39;t resolve
1549 
1550   void movq(Address  dst, void* dummy);
1551   void movq(Register dst, void* dummy);
1552 #endif
1553 
1554   // Move Quadword
1555   void movq(Address     dst, XMMRegister src);
1556   void movq(XMMRegister dst, Address src);
1557 
1558   void movsbl(Register dst, Address src);
1559   void movsbl(Register dst, Register src);
1560 
1561 #ifdef _LP64
1562   void movsbq(Register dst, Address src);
1563   void movsbq(Register dst, Register src);
1564 
1565   // Move signed 32bit immediate to 64bit extending sign
1566   void movslq(Address  dst, int32_t imm64);
1567   void movslq(Register dst, int32_t imm64);
1568 
1569   void movslq(Register dst, Address src);
1570   void movslq(Register dst, Register src);
1571   void movslq(Register dst, void* src); // Dummy declaration to cause NULL to be ambiguous
1572 #endif
1573 
1574   void movswl(Register dst, Address src);
1575   void movswl(Register dst, Register src);
1576 
1577 #ifdef _LP64
1578   void movswq(Register dst, Address src);
1579   void movswq(Register dst, Register src);
1580 #endif
1581 
1582   void movw(Address dst, int imm16);
1583   void movw(Register dst, Address src);
1584   void movw(Address dst, Register src);
1585 
1586   void movzbl(Register dst, Address src);
1587   void movzbl(Register dst, Register src);
1588 
1589 #ifdef _LP64
1590   void movzbq(Register dst, Address src);
1591   void movzbq(Register dst, Register src);
1592 #endif
1593 
1594   void movzwl(Register dst, Address src);
1595   void movzwl(Register dst, Register src);
1596 
1597 #ifdef _LP64
1598   void movzwq(Register dst, Address src);
1599   void movzwq(Register dst, Register src);
1600 #endif
1601 
1602   // Unsigned multiply with RAX destination register
1603   void mull(Address src);
1604   void mull(Register src);
1605 
1606 #ifdef _LP64
1607   void mulq(Address src);
1608   void mulq(Register src);
1609   void mulxq(Register dst1, Register dst2, Register src);
1610 #endif
1611 
1612   // Multiply Scalar Double-Precision Floating-Point Values
1613   void mulsd(XMMRegister dst, Address src);
1614   void mulsd(XMMRegister dst, XMMRegister src);
1615 
1616   // Multiply Scalar Single-Precision Floating-Point Values
1617   void mulss(XMMRegister dst, Address src);
1618   void mulss(XMMRegister dst, XMMRegister src);
1619 
1620   void negl(Register dst);
1621 
1622 #ifdef _LP64
1623   void negq(Register dst);
1624 #endif
1625 
1626   void nop(int i = 1);
1627 
1628   void notl(Register dst);
1629 
1630 #ifdef _LP64
1631   void notq(Register dst);
1632 
1633   void btsq(Address dst, int imm8);
1634   void btrq(Address dst, int imm8);
1635 #endif
1636 
1637   void orl(Address dst, int32_t imm32);
1638   void orl(Register dst, int32_t imm32);
1639   void orl(Register dst, Address src);
1640   void orl(Register dst, Register src);
1641   void orl(Address dst, Register src);
1642 
1643   void orb(Address dst, int imm8);
1644 
1645   void orq(Address dst, int32_t imm32);
1646   void orq(Register dst, int32_t imm32);
1647   void orq(Register dst, Address src);
1648   void orq(Register dst, Register src);
1649 
1650   // Pack with unsigned saturation
1651   void packuswb(XMMRegister dst, XMMRegister src);
1652   void packuswb(XMMRegister dst, Address src);
1653   void vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1654 
1655   // Pemutation of 64bit words
1656   void vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len);
1657   void vpermq(XMMRegister dst, XMMRegister src, int imm8);
1658   void vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1659   void vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8);
1660   void vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8);
1661   void evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1662 
1663   void pause();
1664 
1665   // Undefined Instruction
1666   void ud2();
1667 
1668   // SSE4.2 string instructions
1669   void pcmpestri(XMMRegister xmm1, XMMRegister xmm2, int imm8);
1670   void pcmpestri(XMMRegister xmm1, Address src, int imm8);
1671 
1672   void pcmpeqb(XMMRegister dst, XMMRegister src);
1673   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1674   void evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1675   void evpcmpeqb(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1676   void evpcmpeqb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len);
1677 
1678   void evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1679   void evpcmpgtb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len);
1680 
1681   void evpcmpuw(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);
1682   void evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate of, int vector_len);
1683   void evpcmpuw(KRegister kdst, XMMRegister nds, Address src, ComparisonPredicate vcc, int vector_len);
1684 
1685   void pcmpeqw(XMMRegister dst, XMMRegister src);
1686   void vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1687   void evpcmpeqw(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1688   void evpcmpeqw(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1689 
1690   void pcmpeqd(XMMRegister dst, XMMRegister src);
1691   void vpcmpeqd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1692   void evpcmpeqd(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1693   void evpcmpeqd(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1694 
1695   void pcmpeqq(XMMRegister dst, XMMRegister src);
1696   void vpcmpeqq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1697   void evpcmpeqq(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1698   void evpcmpeqq(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1699 
1700   void pmovmskb(Register dst, XMMRegister src);
1701   void vpmovmskb(Register dst, XMMRegister src);
1702 
1703   // SSE 4.1 extract
1704   void pextrd(Register dst, XMMRegister src, int imm8);
1705   void pextrq(Register dst, XMMRegister src, int imm8);
1706   void pextrd(Address dst, XMMRegister src, int imm8);
1707   void pextrq(Address dst, XMMRegister src, int imm8);
1708   void pextrb(Address dst, XMMRegister src, int imm8);
1709   // SSE 2 extract
1710   void pextrw(Register dst, XMMRegister src, int imm8);
1711   void pextrw(Address dst, XMMRegister src, int imm8);
1712 
1713   // SSE 4.1 insert
1714   void pinsrd(XMMRegister dst, Register src, int imm8);
1715   void pinsrq(XMMRegister dst, Register src, int imm8);
1716   void pinsrd(XMMRegister dst, Address src, int imm8);
1717   void pinsrq(XMMRegister dst, Address src, int imm8);
1718   void pinsrb(XMMRegister dst, Address src, int imm8);
1719   // SSE 2 insert
1720   void pinsrw(XMMRegister dst, Register src, int imm8);
1721   void pinsrw(XMMRegister dst, Address src, int imm8);
1722 
1723   // SSE4.1 packed move
1724   void pmovzxbw(XMMRegister dst, XMMRegister src);
1725   void pmovzxbw(XMMRegister dst, Address src);
1726 
1727   void vpmovzxbw( XMMRegister dst, Address src, int vector_len);
1728   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len);
1729   void evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len);
1730 
1731   void evpmovwb(Address dst, XMMRegister src, int vector_len);
1732   void evpmovwb(Address dst, KRegister mask, XMMRegister src, int vector_len);
1733 
1734   void vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len);
1735 
1736   void evpmovdb(Address dst, XMMRegister src, int vector_len);
1737 
1738   // Sign extend moves
1739   void pmovsxbw(XMMRegister dst, XMMRegister src);
1740   void vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len);
1741 
1742   // Multiply add
1743   void pmaddwd(XMMRegister dst, XMMRegister src);
1744   void vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1745   // Multiply add accumulate
1746   void evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1747 
1748 #ifndef _LP64 // no 32bit push/pop on amd64
1749   void popl(Address dst);
1750 #endif
1751 
1752 #ifdef _LP64
1753   void popq(Address dst);
1754 #endif
1755 
1756   void popcntl(Register dst, Address src);
1757   void popcntl(Register dst, Register src);
1758 
1759   void vpopcntd(XMMRegister dst, XMMRegister src, int vector_len);
1760 
1761 #ifdef _LP64
1762   void popcntq(Register dst, Address src);
1763   void popcntq(Register dst, Register src);
1764 #endif
1765 
1766   // Prefetches (SSE, SSE2, 3DNOW only)
1767 
1768   void prefetchnta(Address src);
1769   void prefetchr(Address src);
1770   void prefetcht0(Address src);
1771   void prefetcht1(Address src);
1772   void prefetcht2(Address src);
1773   void prefetchw(Address src);
1774 
1775   // Shuffle Bytes
1776   void pshufb(XMMRegister dst, XMMRegister src);
1777   void pshufb(XMMRegister dst, Address src);
1778   void vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1779 
1780   // Shuffle Packed Doublewords
1781   void pshufd(XMMRegister dst, XMMRegister src, int mode);
1782   void pshufd(XMMRegister dst, Address src,     int mode);
1783   void vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len);
1784 
1785   // Shuffle Packed Low Words
1786   void pshuflw(XMMRegister dst, XMMRegister src, int mode);
1787   void pshuflw(XMMRegister dst, Address src,     int mode);
1788 
1789   // Shuffle packed values at 128 bit granularity
1790   void evshufi64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len);
1791 
1792   // Shift Right by bytes Logical DoubleQuadword Immediate
1793   void psrldq(XMMRegister dst, int shift);
1794   // Shift Left by bytes Logical DoubleQuadword Immediate
1795   void pslldq(XMMRegister dst, int shift);
1796 
1797   // Logical Compare 128bit
1798   void ptest(XMMRegister dst, XMMRegister src);
1799   void ptest(XMMRegister dst, Address src);
1800   // Logical Compare 256bit
1801   void vptest(XMMRegister dst, XMMRegister src);
1802   void vptest(XMMRegister dst, Address src);
1803 
1804   // Interleave Low Bytes
1805   void punpcklbw(XMMRegister dst, XMMRegister src);
1806   void punpcklbw(XMMRegister dst, Address src);
1807 
1808   // Interleave Low Doublewords
1809   void punpckldq(XMMRegister dst, XMMRegister src);
1810   void punpckldq(XMMRegister dst, Address src);
1811 
1812   // Interleave Low Quadwords
1813   void punpcklqdq(XMMRegister dst, XMMRegister src);
1814 
1815 #ifndef _LP64 // no 32bit push/pop on amd64
1816   void pushl(Address src);
1817 #endif
1818 
1819   void pushq(Address src);
1820 
1821   void rcll(Register dst, int imm8);
1822 
1823   void rclq(Register dst, int imm8);
1824 
1825   void rcrq(Register dst, int imm8);
1826 
1827   void rcpps(XMMRegister dst, XMMRegister src);
1828 
1829   void rcpss(XMMRegister dst, XMMRegister src);
1830 
1831   void rdtsc();
1832 
1833   void ret(int imm16);
1834 
1835 #ifdef _LP64
1836   void rorq(Register dst, int imm8);
1837   void rorxq(Register dst, Register src, int imm8);
1838   void rorxd(Register dst, Register src, int imm8);
1839 #endif
1840 
1841   void sahf();
1842 
1843   void sarl(Register dst, int imm8);
1844   void sarl(Register dst);
1845 
1846   void sarq(Register dst, int imm8);
1847   void sarq(Register dst);
1848 
1849   void sbbl(Address dst, int32_t imm32);
1850   void sbbl(Register dst, int32_t imm32);
1851   void sbbl(Register dst, Address src);
1852   void sbbl(Register dst, Register src);
1853 
1854   void sbbq(Address dst, int32_t imm32);
1855   void sbbq(Register dst, int32_t imm32);
1856   void sbbq(Register dst, Address src);
1857   void sbbq(Register dst, Register src);
1858 
1859   void setb(Condition cc, Register dst);
1860 
1861   void palignr(XMMRegister dst, XMMRegister src, int imm8);
1862   void vpalignr(XMMRegister dst, XMMRegister src1, XMMRegister src2, int imm8, int vector_len);
1863   void evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
1864 
1865   void pblendw(XMMRegister dst, XMMRegister src, int imm8);
1866 
1867   void sha1rnds4(XMMRegister dst, XMMRegister src, int imm8);
1868   void sha1nexte(XMMRegister dst, XMMRegister src);
1869   void sha1msg1(XMMRegister dst, XMMRegister src);
1870   void sha1msg2(XMMRegister dst, XMMRegister src);
1871   // xmm0 is implicit additional source to the following instruction.
1872   void sha256rnds2(XMMRegister dst, XMMRegister src);
1873   void sha256msg1(XMMRegister dst, XMMRegister src);
1874   void sha256msg2(XMMRegister dst, XMMRegister src);
1875 
1876   void shldl(Register dst, Register src);
1877   void shldl(Register dst, Register src, int8_t imm8);
1878   void shrdl(Register dst, Register src);
1879   void shrdl(Register dst, Register src, int8_t imm8);
1880 
1881   void shll(Register dst, int imm8);
1882   void shll(Register dst);
1883 
1884   void shlq(Register dst, int imm8);
1885   void shlq(Register dst);
1886 
1887   void shrl(Register dst, int imm8);
1888   void shrl(Register dst);
1889 
1890   void shrq(Register dst, int imm8);
1891   void shrq(Register dst);
1892 
1893   void smovl(); // QQQ generic?
1894 
1895   // Compute Square Root of Scalar Double-Precision Floating-Point Value
1896   void sqrtsd(XMMRegister dst, Address src);
1897   void sqrtsd(XMMRegister dst, XMMRegister src);
1898 
1899   void roundsd(XMMRegister dst, Address src, int32_t rmode);
1900   void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode);
1901 
1902   // Compute Square Root of Scalar Single-Precision Floating-Point Value
1903   void sqrtss(XMMRegister dst, Address src);
1904   void sqrtss(XMMRegister dst, XMMRegister src);
1905 
1906   void std();
1907 
1908   void stmxcsr( Address dst );
1909 
1910   void subl(Address dst, int32_t imm32);
1911   void subl(Address dst, Register src);
1912   void subl(Register dst, int32_t imm32);
1913   void subl(Register dst, Address src);
1914   void subl(Register dst, Register src);
1915 
1916   void subq(Address dst, int32_t imm32);
1917   void subq(Address dst, Register src);
1918   void subq(Register dst, int32_t imm32);
1919   void subq(Register dst, Address src);
1920   void subq(Register dst, Register src);
1921 
1922   // Force generation of a 4 byte immediate value even if it fits into 8bit
1923   void subl_imm32(Register dst, int32_t imm32);
1924   void subq_imm32(Register dst, int32_t imm32);
1925 
1926   // Subtract Scalar Double-Precision Floating-Point Values
1927   void subsd(XMMRegister dst, Address src);
1928   void subsd(XMMRegister dst, XMMRegister src);
1929 
1930   // Subtract Scalar Single-Precision Floating-Point Values
1931   void subss(XMMRegister dst, Address src);
1932   void subss(XMMRegister dst, XMMRegister src);
1933 
1934   void testb(Register dst, int imm8);
1935   void testb(Address dst, int imm8);
1936 
1937   void testl(Register dst, int32_t imm32);
1938   void testl(Register dst, Register src);
1939   void testl(Register dst, Address src);
1940 
1941   void testq(Register dst, int32_t imm32);
1942   void testq(Register dst, Register src);
1943   void testq(Register dst, Address src);
1944 
1945   // BMI - count trailing zeros
1946   void tzcntl(Register dst, Register src);
1947   void tzcntq(Register dst, Register src);
1948 
1949   // Unordered Compare Scalar Double-Precision Floating-Point Values and set EFLAGS
1950   void ucomisd(XMMRegister dst, Address src);
1951   void ucomisd(XMMRegister dst, XMMRegister src);
1952 
1953   // Unordered Compare Scalar Single-Precision Floating-Point Values and set EFLAGS
1954   void ucomiss(XMMRegister dst, Address src);
1955   void ucomiss(XMMRegister dst, XMMRegister src);
1956 
1957   void xabort(int8_t imm8);
1958 
1959   void xaddb(Address dst, Register src);
1960   void xaddw(Address dst, Register src);
1961   void xaddl(Address dst, Register src);
1962   void xaddq(Address dst, Register src);
1963 
1964   void xbegin(Label&amp; abort, relocInfo::relocType rtype = relocInfo::none);
1965 
1966   void xchgb(Register reg, Address adr);
1967   void xchgw(Register reg, Address adr);
1968   void xchgl(Register reg, Address adr);
1969   void xchgl(Register dst, Register src);
1970 
1971   void xchgq(Register reg, Address adr);
1972   void xchgq(Register dst, Register src);
1973 
1974   void xend();
1975 
1976   // Get Value of Extended Control Register
1977   void xgetbv();
1978 
1979   void xorl(Register dst, int32_t imm32);
1980   void xorl(Register dst, Address src);
1981   void xorl(Register dst, Register src);
1982 
1983   void xorb(Register dst, Address src);
1984 
1985   void xorq(Register dst, Address src);
1986   void xorq(Register dst, Register src);
1987 
1988   void set_byte_if_not_zero(Register dst); // sets reg to 1 if not zero, otherwise 0
1989 
1990   // AVX 3-operands scalar instructions (encoded with VEX prefix)
1991 
1992   void vaddsd(XMMRegister dst, XMMRegister nds, Address src);
1993   void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1994   void vaddss(XMMRegister dst, XMMRegister nds, Address src);
1995   void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1996   void vdivsd(XMMRegister dst, XMMRegister nds, Address src);
1997   void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1998   void vdivss(XMMRegister dst, XMMRegister nds, Address src);
1999   void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src);
2000   void vfmadd231sd(XMMRegister dst, XMMRegister nds, XMMRegister src);
2001   void vfmadd231ss(XMMRegister dst, XMMRegister nds, XMMRegister src);
2002   void vmulsd(XMMRegister dst, XMMRegister nds, Address src);
2003   void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
2004   void vmulss(XMMRegister dst, XMMRegister nds, Address src);
2005   void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src);
2006   void vsubsd(XMMRegister dst, XMMRegister nds, Address src);
2007   void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
2008   void vsubss(XMMRegister dst, XMMRegister nds, Address src);
2009   void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src);
2010 
2011   void vmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src);
2012   void vmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
2013   void vminss(XMMRegister dst, XMMRegister nds, XMMRegister src);
2014   void vminsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
2015 
2016   void shlxl(Register dst, Register src1, Register src2);
2017   void shlxq(Register dst, Register src1, Register src2);
2018 
2019   //====================VECTOR ARITHMETIC=====================================
2020 
2021   // Add Packed Floating-Point Values
2022   void addpd(XMMRegister dst, XMMRegister src);
2023   void addpd(XMMRegister dst, Address src);
2024   void addps(XMMRegister dst, XMMRegister src);
2025   void vaddpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2026   void vaddps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2027   void vaddpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2028   void vaddps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2029 
2030   // Subtract Packed Floating-Point Values
2031   void subpd(XMMRegister dst, XMMRegister src);
2032   void subps(XMMRegister dst, XMMRegister src);
2033   void vsubpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2034   void vsubps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2035   void vsubpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2036   void vsubps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2037 
2038   // Multiply Packed Floating-Point Values
2039   void mulpd(XMMRegister dst, XMMRegister src);
2040   void mulpd(XMMRegister dst, Address src);
2041   void mulps(XMMRegister dst, XMMRegister src);
2042   void vmulpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2043   void vmulps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2044   void vmulpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2045   void vmulps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2046 
2047   void vfmadd231pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2048   void vfmadd231ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2049   void vfmadd231pd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2050   void vfmadd231ps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2051 
2052   // Divide Packed Floating-Point Values
2053   void divpd(XMMRegister dst, XMMRegister src);
2054   void divps(XMMRegister dst, XMMRegister src);
2055   void vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2056   void vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2057   void vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2058   void vdivps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2059 
2060   // Sqrt Packed Floating-Point Values
2061   void vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len);
2062   void vsqrtpd(XMMRegister dst, Address src, int vector_len);
2063   void vsqrtps(XMMRegister dst, XMMRegister src, int vector_len);
2064   void vsqrtps(XMMRegister dst, Address src, int vector_len);
2065 
2066   // Round Packed Double precision value.
2067   void vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len);
2068   void vroundpd(XMMRegister dst, Address src, int32_t rmode, int vector_len);
2069   void vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len);
2070   void vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len);
2071 
2072   // Bitwise Logical AND of Packed Floating-Point Values
2073   void andpd(XMMRegister dst, XMMRegister src);
2074   void andps(XMMRegister dst, XMMRegister src);
2075   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2076   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2077   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2078   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2079 
2080   void unpckhpd(XMMRegister dst, XMMRegister src);
2081   void unpcklpd(XMMRegister dst, XMMRegister src);
2082 
2083   // Bitwise Logical XOR of Packed Floating-Point Values
2084   void xorpd(XMMRegister dst, XMMRegister src);
2085   void xorps(XMMRegister dst, XMMRegister src);
2086   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2087   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2088   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2089   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2090 
2091   // Add horizontal packed integers
2092   void vphaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2093   void vphaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2094   void phaddw(XMMRegister dst, XMMRegister src);
2095   void phaddd(XMMRegister dst, XMMRegister src);
2096 
2097   // Add packed integers
2098   void paddb(XMMRegister dst, XMMRegister src);
2099   void paddw(XMMRegister dst, XMMRegister src);
2100   void paddd(XMMRegister dst, XMMRegister src);
2101   void paddd(XMMRegister dst, Address src);
2102   void paddq(XMMRegister dst, XMMRegister src);
2103   void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2104   void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2105   void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2106   void vpaddq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2107   void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2108   void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2109   void vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2110   void vpaddq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2111 
2112   // Sub packed integers
2113   void psubb(XMMRegister dst, XMMRegister src);
2114   void psubw(XMMRegister dst, XMMRegister src);
2115   void psubd(XMMRegister dst, XMMRegister src);
2116   void psubq(XMMRegister dst, XMMRegister src);
2117   void vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2118   void vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2119   void vpsubd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2120   void vpsubq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2121   void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2122   void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2123   void vpsubd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2124   void vpsubq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2125 
2126   // Multiply packed integers (only shorts and ints)
2127   void pmullw(XMMRegister dst, XMMRegister src);
2128   void pmulld(XMMRegister dst, XMMRegister src);
2129   void vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2130   void vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2131   void vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2132   void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2133   void vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2134   void vpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2135 
2136   // Shift left packed integers
2137   void psllw(XMMRegister dst, int shift);
2138   void pslld(XMMRegister dst, int shift);
2139   void psllq(XMMRegister dst, int shift);
2140   void psllw(XMMRegister dst, XMMRegister shift);
2141   void pslld(XMMRegister dst, XMMRegister shift);
2142   void psllq(XMMRegister dst, XMMRegister shift);
2143   void vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2144   void vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2145   void vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2146   void vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2147   void vpslld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2148   void vpsllq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2149   void vpslldq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2150 
2151   // Logical shift right packed integers
2152   void psrlw(XMMRegister dst, int shift);
2153   void psrld(XMMRegister dst, int shift);
2154   void psrlq(XMMRegister dst, int shift);
2155   void psrlw(XMMRegister dst, XMMRegister shift);
2156   void psrld(XMMRegister dst, XMMRegister shift);
2157   void psrlq(XMMRegister dst, XMMRegister shift);
2158   void vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2159   void vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2160   void vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2161   void vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2162   void vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2163   void vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2164   void vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2165   void evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2166   void evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2167 
2168   // Arithmetic shift right packed integers (only shorts and ints, no instructions for longs)
2169   void psraw(XMMRegister dst, int shift);
2170   void psrad(XMMRegister dst, int shift);
2171   void psraw(XMMRegister dst, XMMRegister shift);
2172   void psrad(XMMRegister dst, XMMRegister shift);
2173   void vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2174   void vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2175   void vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2176   void vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2177   void evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2178   void evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2179 
2180   void vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2181   void vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2182 
2183   // And packed integers
2184   void pand(XMMRegister dst, XMMRegister src);
2185   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2186   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2187   void vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2188 
2189   // Andn packed integers
2190   void pandn(XMMRegister dst, XMMRegister src);
2191   void vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2192 
2193   // Or packed integers
2194   void por(XMMRegister dst, XMMRegister src);
2195   void vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2196   void vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2197   void vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2198 
2199   // Xor packed integers
2200   void pxor(XMMRegister dst, XMMRegister src);
2201   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2202   void vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2203   void evpxorq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2204   void evpxorq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2205 
2206   // Ternary logic instruction.
2207   void vpternlogd(XMMRegister dst, int imm8, XMMRegister src2, XMMRegister src3, int vector_len);
2208   void vpternlogd(XMMRegister dst, int imm8, XMMRegister src2, Address     src3, int vector_len);
2209   void vpternlogq(XMMRegister dst, int imm8, XMMRegister src2, XMMRegister src3, int vector_len);
2210 
2211   // vinserti forms
2212   void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2213   void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2214   void vinserti32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2215   void vinserti32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2216   void vinserti64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2217 
2218   // vinsertf forms
2219   void vinsertf128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2220   void vinsertf128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2221   void vinsertf32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2222   void vinsertf32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2223   void vinsertf64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2224   void vinsertf64x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2225 
2226   // vextracti forms
2227   void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8);
2228   void vextracti128(Address dst, XMMRegister src, uint8_t imm8);
2229   void vextracti32x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2230   void vextracti32x4(Address dst, XMMRegister src, uint8_t imm8);
2231   void vextracti64x2(XMMRegister dst, XMMRegister src, uint8_t imm8);
2232   void vextracti64x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2233   void vextracti64x4(Address dst, XMMRegister src, uint8_t imm8);
2234 
2235   // vextractf forms
2236   void vextractf128(XMMRegister dst, XMMRegister src, uint8_t imm8);
2237   void vextractf128(Address dst, XMMRegister src, uint8_t imm8);
2238   void vextractf32x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2239   void vextractf32x4(Address dst, XMMRegister src, uint8_t imm8);
2240   void vextractf64x2(XMMRegister dst, XMMRegister src, uint8_t imm8);
2241   void vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2242   void vextractf64x4(Address dst, XMMRegister src, uint8_t imm8);
2243 
2244   // xmm/mem sourced byte/word/dword/qword replicate
2245   void vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len);
2246   void vpbroadcastb(XMMRegister dst, Address src, int vector_len);
2247   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
2248   void vpbroadcastw(XMMRegister dst, Address src, int vector_len);
2249   void vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len);
2250   void vpbroadcastd(XMMRegister dst, Address src, int vector_len);
2251   void vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len);
2252   void vpbroadcastq(XMMRegister dst, Address src, int vector_len);
2253 
2254   void evbroadcasti32x4(XMMRegister dst, Address src, int vector_len);
2255   void evbroadcasti64x2(XMMRegister dst, XMMRegister src, int vector_len);
2256   void evbroadcasti64x2(XMMRegister dst, Address src, int vector_len);
2257 
2258   // scalar single/double precision replicate
2259   void vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len);
2260   void vbroadcastss(XMMRegister dst, Address src, int vector_len);
2261   void vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len);
2262   void vbroadcastsd(XMMRegister dst, Address src, int vector_len);
2263 
2264   // gpr sourced byte/word/dword/qword replicate
2265   void evpbroadcastb(XMMRegister dst, Register src, int vector_len);
2266   void evpbroadcastw(XMMRegister dst, Register src, int vector_len);
2267   void evpbroadcastd(XMMRegister dst, Register src, int vector_len);
2268   void evpbroadcastq(XMMRegister dst, Register src, int vector_len);
2269 
2270   void evpgatherdd(XMMRegister dst, KRegister k1, Address src, int vector_len);
2271 
2272   // Carry-Less Multiplication Quadword
2273   void pclmulqdq(XMMRegister dst, XMMRegister src, int mask);
2274   void vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask);
2275   void evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len);
2276   // AVX instruction which is used to clear upper 128 bits of YMM registers and
2277   // to avoid transaction penalty between AVX and SSE states. There is no
2278   // penalty if legacy SSE instructions are encoded using VEX prefix because
2279   // they always clear upper 128 bits. It should be used before calling
2280   // runtime code and native libraries.
2281   void vzeroupper();
2282 
2283   // AVX support for vectorized conditional move (float/double). The following two instructions used only coupled.
2284   void blendvpb(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len);
2285   void cmppd(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len);
2286   void blendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len);
2287   void cmpps(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len);
2288   void blendvps(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len);
2289   void vpblendd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len);
2290 
2291  protected:
2292   // Next instructions require address alignment 16 bytes SSE mode.
2293   // They should be called only from corresponding MacroAssembler instructions.
2294   void andpd(XMMRegister dst, Address src);
2295   void andps(XMMRegister dst, Address src);
2296   void xorpd(XMMRegister dst, Address src);
2297   void xorps(XMMRegister dst, Address src);
2298 
2299 };
2300 
2301 // The Intel x86/Amd64 Assembler attributes: All fields enclosed here are to guide encoding level decisions.
2302 // Specific set functions are for specialized use, else defaults or whatever was supplied to object construction
2303 // are applied.
2304 class InstructionAttr {
2305 public:
2306   InstructionAttr(
2307     int vector_len,     // The length of vector to be applied in encoding - for both AVX and EVEX
2308     bool rex_vex_w,     // Width of data: if 32-bits or less, false, else if 64-bit or specially defined, true
2309     bool legacy_mode,   // Details if either this instruction is conditionally encoded to AVX or earlier if true else possibly EVEX
2310     bool no_reg_mask,   // when true, k0 is used when EVEX encoding is chosen, else embedded_opmask_register_specifier is used
2311     bool uses_vl)       // This instruction may have legacy constraints based on vector length for EVEX
2312     :
2313       _rex_vex_w(rex_vex_w),
2314       _legacy_mode(legacy_mode || UseAVX &lt; 3),
2315       _no_reg_mask(no_reg_mask),
2316       _uses_vl(uses_vl),
2317       _rex_vex_w_reverted(false),
2318       _is_evex_instruction(false),
2319       _is_clear_context(true),
2320       _is_extended_context(false),
2321       _avx_vector_len(vector_len),
2322       _tuple_type(Assembler::EVEX_ETUP),
2323       _input_size_in_bits(Assembler::EVEX_NObit),
2324       _evex_encoding(0),
2325       _embedded_opmask_register_specifier(0), // hard code k0
2326       _current_assembler(NULL) { }
2327 
2328   ~InstructionAttr() {
2329     if (_current_assembler != NULL) {
2330       _current_assembler-&gt;clear_attributes();
2331     }
2332     _current_assembler = NULL;
2333   }
2334 
2335 private:
2336   bool _rex_vex_w;
2337   bool _legacy_mode;
2338   bool _no_reg_mask;
2339   bool _uses_vl;
2340   bool _rex_vex_w_reverted;
2341   bool _is_evex_instruction;
2342   bool _is_clear_context;
2343   bool _is_extended_context;
2344   int  _avx_vector_len;
2345   int  _tuple_type;
2346   int  _input_size_in_bits;
2347   int  _evex_encoding;
2348   int _embedded_opmask_register_specifier;
2349 
2350   Assembler *_current_assembler;
2351 
2352 public:
2353   // query functions for field accessors
2354   bool is_rex_vex_w(void) const { return _rex_vex_w; }
2355   bool is_legacy_mode(void) const { return _legacy_mode; }
2356   bool is_no_reg_mask(void) const { return _no_reg_mask; }
2357   bool uses_vl(void) const { return _uses_vl; }
2358   bool is_rex_vex_w_reverted(void) { return _rex_vex_w_reverted; }
2359   bool is_evex_instruction(void) const { return _is_evex_instruction; }
2360   bool is_clear_context(void) const { return _is_clear_context; }
2361   bool is_extended_context(void) const { return _is_extended_context; }
2362   int  get_vector_len(void) const { return _avx_vector_len; }
2363   int  get_tuple_type(void) const { return _tuple_type; }
2364   int  get_input_size(void) const { return _input_size_in_bits; }
2365   int  get_evex_encoding(void) const { return _evex_encoding; }
2366   int  get_embedded_opmask_register_specifier(void) const { return _embedded_opmask_register_specifier; }
2367 
2368   // Set the vector len manually
2369   void set_vector_len(int vector_len) { _avx_vector_len = vector_len; }
2370 
2371   // Set revert rex_vex_w for avx encoding
2372   void set_rex_vex_w_reverted(void) { _rex_vex_w_reverted = true; }
2373 
2374   // Set rex_vex_w based on state
2375   void set_rex_vex_w(bool state) { _rex_vex_w = state; }
2376 
2377   // Set the instruction to be encoded in AVX mode
2378   void set_is_legacy_mode(void) { _legacy_mode = true; }
2379 
2380   // Set the current instuction to be encoded as an EVEX instuction
2381   void set_is_evex_instruction(void) { _is_evex_instruction = true; }
2382 
2383   // Internal encoding data used in compressed immediate offset programming
2384   void set_evex_encoding(int value) { _evex_encoding = value; }
2385 
2386   // Set the Evex.Z field to be used to clear all non directed XMM/YMM/ZMM components
2387   void reset_is_clear_context(void) { _is_clear_context = false; }
2388 
2389   // Map back to current asembler so that we can manage object level assocation
2390   void set_current_assembler(Assembler *current_assembler) { _current_assembler = current_assembler; }
2391 
2392   // Address modifiers used for compressed displacement calculation
2393   void set_address_attributes(int tuple_type, int input_size_in_bits) {
2394     if (VM_Version::supports_evex()) {
2395       _tuple_type = tuple_type;
2396       _input_size_in_bits = input_size_in_bits;
2397     }
2398   }
2399 
2400   // Set embedded opmask register specifier.
2401   void set_embedded_opmask_register_specifier(KRegister mask) {
2402     _embedded_opmask_register_specifier = (*mask).encoding() &amp; 0x7;
2403   }
2404 
2405 };
2406 
2407 #endif // CPU_X86_ASSEMBLER_X86_HPP
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
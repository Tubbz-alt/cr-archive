<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../incubator/foreign/MemorySegment.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LayoutPath.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -45,10 +45,12 @@</span>
  import java.util.List;
  import java.util.Objects;
  import java.util.Random;
  import java.util.Spliterator;
  import java.util.function.Consumer;
<span class="udiff-line-added">+ import java.util.function.Function;</span>
<span class="udiff-line-added">+ import java.util.function.IntFunction;</span>
  
  /**
   * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
   * about the segment&#39;s spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
   * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -130,10 +132,20 @@</span>
          UNSAFE.copyMemory(
                  that.base(), that.min(),
                  base(), min(), size);
      }
  
<span class="udiff-line-added">+     public void copyFromSwap(MemorySegment src, long elemSize) {</span>
<span class="udiff-line-added">+         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;</span>
<span class="udiff-line-added">+         long size = that.byteSize();</span>
<span class="udiff-line-added">+         checkRange(0, size, true);</span>
<span class="udiff-line-added">+         that.checkRange(0, size, false);</span>
<span class="udiff-line-added">+         UNSAFE.copySwapMemory(</span>
<span class="udiff-line-added">+                 that.base(), that.min(),</span>
<span class="udiff-line-added">+                 base(), min(), size, elemSize);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
              .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
  
      @Override
      public long mismatch(MemorySegment other) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -182,11 +194,11 @@</span>
      @Override
      public final ByteBuffer asByteBuffer() {
          if (!isSet(READ)) {
              throw unsupportedAccessMode(READ);
          }
<span class="udiff-line-modified-removed">-         checkIntSize(&quot;ByteBuffer&quot;);</span>
<span class="udiff-line-modified-added">+         checkArraySize(&quot;ByteBuffer&quot;, 1);</span>
          ByteBuffer _bb = makeByteBuffer();
          if (!isSet(WRITE)) {
              //scope is IMMUTABLE - obtain a RO byte buffer
              _bb = _bb.asReadOnlyBuffer();
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -241,16 +253,20 @@</span>
              throw unsupportedAccessMode(HANDOFF);
          }
          if (scope.ownerThread() == newOwner) {
              throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);
          } else {
<span class="udiff-line-modified-removed">-             try {</span>
<span class="udiff-line-modified-removed">-                 return dup(0L, length, mask, scope.dup(newOwner));</span>
<span class="udiff-line-modified-removed">-             } finally {</span>
<span class="udiff-line-modified-removed">-                 //flush read/writes to segment memory before returning the new segment</span>
<span class="udiff-line-modified-removed">-                 VarHandle.fullFence();</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-added">+             return dupAndClose(newOwner);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     public MemorySegment dupAndClose(Thread newOwner) {</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-added">+             return dup(0L, length, mask, scope.dup(newOwner));</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             //flush read/writes to segment memory before returning the new segment</span>
<span class="udiff-line-added">+             VarHandle.fullFence();</span>
          }
      }
  
      @Override
      public final void close() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -271,13 +287,47 @@</span>
          return dup(0, length, mask, scope.acquire());
      }
  
      @Override
      public final byte[] toByteArray() {
<span class="udiff-line-modified-removed">-         checkIntSize(&quot;byte[]&quot;);</span>
<span class="udiff-line-modified-removed">-         byte[] arr = new byte[(int)length];</span>
<span class="udiff-line-modified-removed">-         MemorySegment arrSegment = MemorySegment.ofArray(arr);</span>
<span class="udiff-line-modified-added">+         return toArray(byte[].class, 1, byte[]::new, MemorySegment::ofArray);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public final short[] toShortArray() {</span>
<span class="udiff-line-added">+         return toArray(short[].class, 2, short[]::new, MemorySegment::ofArray);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public final char[] toCharArray() {</span>
<span class="udiff-line-added">+         return toArray(char[].class, 2, char[]::new, MemorySegment::ofArray);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public final int[] toIntArray() {</span>
<span class="udiff-line-added">+         return toArray(int[].class, 4, int[]::new, MemorySegment::ofArray);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public final float[] toFloatArray() {</span>
<span class="udiff-line-added">+         return toArray(float[].class, 4, float[]::new, MemorySegment::ofArray);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public final long[] toLongArray() {</span>
<span class="udiff-line-added">+         return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public final double[] toDoubleArray() {</span>
<span class="udiff-line-added">+         return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private &lt;Z&gt; Z toArray(Class&lt;Z&gt; arrayClass, int elemSize, IntFunction&lt;Z&gt; arrayFactory, Function&lt;Z, MemorySegment&gt; segmentFactory) {</span>
<span class="udiff-line-added">+         int size = checkArraySize(arrayClass.getSimpleName(), elemSize);</span>
<span class="udiff-line-added">+         Z arr = arrayFactory.apply(size);</span>
<span class="udiff-line-added">+         MemorySegment arrSegment = segmentFactory.apply(arr);</span>
          arrSegment.copyFrom(this);
          return arr;
      }
  
      boolean isSmall() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -303,14 +353,19 @@</span>
  
      private boolean isSet(int mask) {
          return (this.mask &amp; mask) != 0;
      }
  
<span class="udiff-line-modified-removed">-     private void checkIntSize(String typeName) {</span>
<span class="udiff-line-modified-removed">-         if (length &gt; (Integer.MAX_VALUE - 8)) { //conservative check</span>
<span class="udiff-line-modified-added">+     private int checkArraySize(String typeName, int elemSize) {</span>
<span class="udiff-line-modified-added">+         if (length % elemSize != 0) {</span>
<span class="udiff-line-added">+             throw new UnsupportedOperationException(String.format(&quot;Segment size is not a multiple of %d. Size: %d&quot;, elemSize, length));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         long arraySize = length / elemSize;</span>
<span class="udiff-line-added">+         if (arraySize &gt; (Integer.MAX_VALUE - 8)) { //conservative check</span>
              throw new UnsupportedOperationException(String.format(&quot;Segment is too large to wrap as %s. Size: %d&quot;, typeName, length));
          }
<span class="udiff-line-added">+         return (int)arraySize;</span>
      }
  
      private void checkBounds(long offset, long length) {
          if (isSmall()) {
              checkBoundsSmall((int)offset, (int)length);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -510,6 +565,30 @@</span>
          @Override
          AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
              throw new UnsupportedOperationException();
          }
      };
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static final AbstractMemorySegmentImpl EVERYTHING = new AbstractMemorySegmentImpl(</span>
<span class="udiff-line-added">+             Long.MAX_VALUE, READ | WRITE, MemoryScope.createUnchecked(null, null, null)</span>
<span class="udiff-line-added">+     ) {</span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         ByteBuffer makeByteBuffer() {</span>
<span class="udiff-line-added">+             throw new UnsupportedOperationException();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         long min() {</span>
<span class="udiff-line-added">+             return 0;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         Object base() {</span>
<span class="udiff-line-added">+             return null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {</span>
<span class="udiff-line-added">+             throw new UnsupportedOperationException();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     };</span>
  }
</pre>
<center><a href="../../incubator/foreign/MemorySegment.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LayoutPath.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
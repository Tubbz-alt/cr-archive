<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../incubator/foreign/MemorySegment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LayoutPath.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 import jdk.incubator.foreign.MemoryLayouts;
 31 import jdk.incubator.foreign.MemorySegment;
 32 import jdk.incubator.foreign.SequenceLayout;
 33 import jdk.internal.access.JavaNioAccess;
 34 import jdk.internal.access.SharedSecrets;
 35 import jdk.internal.access.foreign.MemorySegmentProxy;
 36 import jdk.internal.access.foreign.UnmapperProxy;
 37 import jdk.internal.misc.Unsafe;
 38 import jdk.internal.util.ArraysSupport;
 39 import jdk.internal.vm.annotation.ForceInline;
 40 import sun.security.action.GetPropertyAction;
 41 
 42 import java.lang.invoke.VarHandle;
 43 import java.nio.ByteBuffer;
 44 import java.util.ArrayList;
 45 import java.util.List;
 46 import java.util.Objects;
 47 import java.util.Random;
 48 import java.util.Spliterator;
 49 import java.util.function.Consumer;


 50 
 51 /**
 52  * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
 53  * about the segment&#39;s spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
 54  * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
 55  * segment is either in an invalid state (e.g. it has already been closed) or if access occurs from a thread other
 56  * than the owner thread. See {@link MemoryScope} for more details on management of temporal bounds. Subclasses
 57  * are defined for each memory segment kind, see {@link NativeMemorySegmentImpl}, {@link HeapMemorySegmentImpl} and
 58  * {@link MappedMemorySegmentImpl}.
 59  */
 60 public abstract class AbstractMemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
 61 
 62     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
 63 
 64     private static final boolean enableSmallSegments =
 65             Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty(&quot;jdk.incubator.foreign.SmallSegments&quot;, &quot;true&quot;));
 66 
 67     final static int FIRST_RESERVED_FLAG = 1 &lt;&lt; 16; // upper 16 bits are reserved
 68     final static int SMALL = FIRST_RESERVED_FLAG;
 69     final static long NONCE = new Random().nextLong();
</pre>
<hr />
<pre>
115                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
116     }
117 
118     @Override
119     public final MemorySegment fill(byte value){
120         checkRange(0, length, true);
121         UNSAFE.setMemory(base(), min(), length, value);
122         return this;
123     }
124 
125     public void copyFrom(MemorySegment src) {
126         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
127         long size = that.byteSize();
128         checkRange(0, size, true);
129         that.checkRange(0, size, false);
130         UNSAFE.copyMemory(
131                 that.base(), that.min(),
132                 base(), min(), size);
133     }
134 










135     private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
136             .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
137 
138     @Override
139     public long mismatch(MemorySegment other) {
140         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
141         final long thisSize = this.byteSize();
142         final long thatSize = that.byteSize();
143         final long length = Math.min(thisSize, thatSize);
144         this.checkRange(0, length, false);
145         that.checkRange(0, length, false);
146         if (this == other) {
147             return -1;
148         }
149 
150         long i = 0;
151         if (length &gt; 7) {
152             if ((byte) BYTE_HANDLE.get(this.baseAddress(), 0) != (byte) BYTE_HANDLE.get(that.baseAddress(), 0)) {
153                 return 0;
154             }
</pre>
<hr />
<pre>
167         MemoryAddress thatAddress = that.baseAddress();
168         for (; i &lt; length; i++) {
169             if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {
170                 return i;
171             }
172         }
173         return thisSize != thatSize ? length : -1;
174     }
175 
176     @Override
177     @ForceInline
178     public final MemoryAddress baseAddress() {
179         return new MemoryAddressImpl(this, 0);
180     }
181 
182     @Override
183     public final ByteBuffer asByteBuffer() {
184         if (!isSet(READ)) {
185             throw unsupportedAccessMode(READ);
186         }
<span class="line-modified">187         checkIntSize(&quot;ByteBuffer&quot;);</span>
188         ByteBuffer _bb = makeByteBuffer();
189         if (!isSet(WRITE)) {
190             //scope is IMMUTABLE - obtain a RO byte buffer
191             _bb = _bb.asReadOnlyBuffer();
192         }
193         return _bb;
194     }
195 
196     @Override
197     public final int accessModes() {
198         return mask &amp; ALL_ACCESS;
199     }
200 
201     @Override
202     public final long byteSize() {
203         return length;
204     }
205 
206     @Override
207     public final boolean isAlive() {
</pre>
<hr />
<pre>
226     public boolean hasAccessModes(int accessModes) {
227         checkAccessModes(accessModes);
228         return (accessModes() &amp; accessModes) == accessModes;
229     }
230 
231     private void checkAccessModes(int accessModes) {
232         if ((accessModes &amp; ~ALL_ACCESS) != 0) {
233             throw new IllegalArgumentException(&quot;Invalid access modes&quot;);
234         }
235     }
236 
237     @Override
238     public MemorySegment withOwnerThread(Thread newOwner) {
239         Objects.requireNonNull(newOwner);
240         if (!isSet(HANDOFF)) {
241             throw unsupportedAccessMode(HANDOFF);
242         }
243         if (scope.ownerThread() == newOwner) {
244             throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);
245         } else {
<span class="line-modified">246             try {</span>
<span class="line-modified">247                 return dup(0L, length, mask, scope.dup(newOwner));</span>
<span class="line-modified">248             } finally {</span>
<span class="line-modified">249                 //flush read/writes to segment memory before returning the new segment</span>
<span class="line-modified">250                 VarHandle.fullFence();</span>
<span class="line-modified">251             }</span>




252         }
253     }
254 
255     @Override
256     public final void close() {
257         if (!isSet(CLOSE)) {
258             throw unsupportedAccessMode(CLOSE);
259         }
260         closeNoCheck();
261     }
262 
263     private final void closeNoCheck() {
264         scope.close();
265     }
266 
267     final AbstractMemorySegmentImpl acquire() {
268         if (Thread.currentThread() != ownerThread() &amp;&amp; !isSet(ACQUIRE)) {
269             throw unsupportedAccessMode(ACQUIRE);
270         }
271         return dup(0, length, mask, scope.acquire());
272     }
273 
274     @Override
275     public final byte[] toByteArray() {
<span class="line-modified">276         checkIntSize(&quot;byte[]&quot;);</span>
<span class="line-modified">277         byte[] arr = new byte[(int)length];</span>
<span class="line-modified">278         MemorySegment arrSegment = MemorySegment.ofArray(arr);</span>


































279         arrSegment.copyFrom(this);
280         return arr;
281     }
282 
283     boolean isSmall() {
284         return isSet(SMALL);
285     }
286 
287     void checkRange(long offset, long length, boolean writeAccess) {
288         scope.checkValidState();
289         if (writeAccess &amp;&amp; !isSet(WRITE)) {
290             throw unsupportedAccessMode(WRITE);
291         } else if (!writeAccess &amp;&amp; !isSet(READ)) {
292             throw unsupportedAccessMode(READ);
293         }
294         checkBounds(offset, length);
295     }
296 
297     @Override
298     public final void checkValidState() {
299         scope.checkValidState();
300     }
301 
302     // Helper methods
303 
304     private boolean isSet(int mask) {
305         return (this.mask &amp; mask) != 0;
306     }
307 
<span class="line-modified">308     private void checkIntSize(String typeName) {</span>
<span class="line-modified">309         if (length &gt; (Integer.MAX_VALUE - 8)) { //conservative check</span>




310             throw new UnsupportedOperationException(String.format(&quot;Segment is too large to wrap as %s. Size: %d&quot;, typeName, length));
311         }

312     }
313 
314     private void checkBounds(long offset, long length) {
315         if (isSmall()) {
316             checkBoundsSmall((int)offset, (int)length);
317         } else {
318             if (length &lt; 0 ||
319                     offset &lt; 0 ||
320                     offset &gt; this.length - length) { // careful of overflow
321                 throw outOfBoundException(offset, length);
322             }
323         }
324     }
325 
326     private void checkBoundsSmall(int offset, int length) {
327         if (length &lt; 0 ||
328                 offset &lt; 0 ||
329                 offset &gt; (int)this.length - length) { // careful of overflow
330             throw outOfBoundException(offset, length);
331         }
</pre>
<hr />
<pre>
495         @Override
496         ByteBuffer makeByteBuffer() {
497             throw new UnsupportedOperationException();
498         }
499 
500         @Override
501         long min() {
502             return 0;
503         }
504 
505         @Override
506         Object base() {
507             return null;
508         }
509 
510         @Override
511         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
512             throw new UnsupportedOperationException();
513         }
514     };
























515 }
</pre>
</td>
<td>
<hr />
<pre>
 30 import jdk.incubator.foreign.MemoryLayouts;
 31 import jdk.incubator.foreign.MemorySegment;
 32 import jdk.incubator.foreign.SequenceLayout;
 33 import jdk.internal.access.JavaNioAccess;
 34 import jdk.internal.access.SharedSecrets;
 35 import jdk.internal.access.foreign.MemorySegmentProxy;
 36 import jdk.internal.access.foreign.UnmapperProxy;
 37 import jdk.internal.misc.Unsafe;
 38 import jdk.internal.util.ArraysSupport;
 39 import jdk.internal.vm.annotation.ForceInline;
 40 import sun.security.action.GetPropertyAction;
 41 
 42 import java.lang.invoke.VarHandle;
 43 import java.nio.ByteBuffer;
 44 import java.util.ArrayList;
 45 import java.util.List;
 46 import java.util.Objects;
 47 import java.util.Random;
 48 import java.util.Spliterator;
 49 import java.util.function.Consumer;
<span class="line-added"> 50 import java.util.function.Function;</span>
<span class="line-added"> 51 import java.util.function.IntFunction;</span>
 52 
 53 /**
 54  * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
 55  * about the segment&#39;s spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
 56  * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
 57  * segment is either in an invalid state (e.g. it has already been closed) or if access occurs from a thread other
 58  * than the owner thread. See {@link MemoryScope} for more details on management of temporal bounds. Subclasses
 59  * are defined for each memory segment kind, see {@link NativeMemorySegmentImpl}, {@link HeapMemorySegmentImpl} and
 60  * {@link MappedMemorySegmentImpl}.
 61  */
 62 public abstract class AbstractMemorySegmentImpl implements MemorySegment, MemorySegmentProxy {
 63 
 64     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
 65 
 66     private static final boolean enableSmallSegments =
 67             Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty(&quot;jdk.incubator.foreign.SmallSegments&quot;, &quot;true&quot;));
 68 
 69     final static int FIRST_RESERVED_FLAG = 1 &lt;&lt; 16; // upper 16 bits are reserved
 70     final static int SMALL = FIRST_RESERVED_FLAG;
 71     final static long NONCE = new Random().nextLong();
</pre>
<hr />
<pre>
117                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
118     }
119 
120     @Override
121     public final MemorySegment fill(byte value){
122         checkRange(0, length, true);
123         UNSAFE.setMemory(base(), min(), length, value);
124         return this;
125     }
126 
127     public void copyFrom(MemorySegment src) {
128         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
129         long size = that.byteSize();
130         checkRange(0, size, true);
131         that.checkRange(0, size, false);
132         UNSAFE.copyMemory(
133                 that.base(), that.min(),
134                 base(), min(), size);
135     }
136 
<span class="line-added">137     public void copyFromSwap(MemorySegment src, long elemSize) {</span>
<span class="line-added">138         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;</span>
<span class="line-added">139         long size = that.byteSize();</span>
<span class="line-added">140         checkRange(0, size, true);</span>
<span class="line-added">141         that.checkRange(0, size, false);</span>
<span class="line-added">142         UNSAFE.copySwapMemory(</span>
<span class="line-added">143                 that.base(), that.min(),</span>
<span class="line-added">144                 base(), min(), size, elemSize);</span>
<span class="line-added">145     }</span>
<span class="line-added">146 </span>
147     private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
148             .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
149 
150     @Override
151     public long mismatch(MemorySegment other) {
152         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
153         final long thisSize = this.byteSize();
154         final long thatSize = that.byteSize();
155         final long length = Math.min(thisSize, thatSize);
156         this.checkRange(0, length, false);
157         that.checkRange(0, length, false);
158         if (this == other) {
159             return -1;
160         }
161 
162         long i = 0;
163         if (length &gt; 7) {
164             if ((byte) BYTE_HANDLE.get(this.baseAddress(), 0) != (byte) BYTE_HANDLE.get(that.baseAddress(), 0)) {
165                 return 0;
166             }
</pre>
<hr />
<pre>
179         MemoryAddress thatAddress = that.baseAddress();
180         for (; i &lt; length; i++) {
181             if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {
182                 return i;
183             }
184         }
185         return thisSize != thatSize ? length : -1;
186     }
187 
188     @Override
189     @ForceInline
190     public final MemoryAddress baseAddress() {
191         return new MemoryAddressImpl(this, 0);
192     }
193 
194     @Override
195     public final ByteBuffer asByteBuffer() {
196         if (!isSet(READ)) {
197             throw unsupportedAccessMode(READ);
198         }
<span class="line-modified">199         checkArraySize(&quot;ByteBuffer&quot;, 1);</span>
200         ByteBuffer _bb = makeByteBuffer();
201         if (!isSet(WRITE)) {
202             //scope is IMMUTABLE - obtain a RO byte buffer
203             _bb = _bb.asReadOnlyBuffer();
204         }
205         return _bb;
206     }
207 
208     @Override
209     public final int accessModes() {
210         return mask &amp; ALL_ACCESS;
211     }
212 
213     @Override
214     public final long byteSize() {
215         return length;
216     }
217 
218     @Override
219     public final boolean isAlive() {
</pre>
<hr />
<pre>
238     public boolean hasAccessModes(int accessModes) {
239         checkAccessModes(accessModes);
240         return (accessModes() &amp; accessModes) == accessModes;
241     }
242 
243     private void checkAccessModes(int accessModes) {
244         if ((accessModes &amp; ~ALL_ACCESS) != 0) {
245             throw new IllegalArgumentException(&quot;Invalid access modes&quot;);
246         }
247     }
248 
249     @Override
250     public MemorySegment withOwnerThread(Thread newOwner) {
251         Objects.requireNonNull(newOwner);
252         if (!isSet(HANDOFF)) {
253             throw unsupportedAccessMode(HANDOFF);
254         }
255         if (scope.ownerThread() == newOwner) {
256             throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);
257         } else {
<span class="line-modified">258             return dupAndClose(newOwner);</span>
<span class="line-modified">259         }</span>
<span class="line-modified">260     }</span>
<span class="line-modified">261 </span>
<span class="line-modified">262     public MemorySegment dupAndClose(Thread newOwner) {</span>
<span class="line-modified">263         try {</span>
<span class="line-added">264             return dup(0L, length, mask, scope.dup(newOwner));</span>
<span class="line-added">265         } finally {</span>
<span class="line-added">266             //flush read/writes to segment memory before returning the new segment</span>
<span class="line-added">267             VarHandle.fullFence();</span>
268         }
269     }
270 
271     @Override
272     public final void close() {
273         if (!isSet(CLOSE)) {
274             throw unsupportedAccessMode(CLOSE);
275         }
276         closeNoCheck();
277     }
278 
279     private final void closeNoCheck() {
280         scope.close();
281     }
282 
283     final AbstractMemorySegmentImpl acquire() {
284         if (Thread.currentThread() != ownerThread() &amp;&amp; !isSet(ACQUIRE)) {
285             throw unsupportedAccessMode(ACQUIRE);
286         }
287         return dup(0, length, mask, scope.acquire());
288     }
289 
290     @Override
291     public final byte[] toByteArray() {
<span class="line-modified">292         return toArray(byte[].class, 1, byte[]::new, MemorySegment::ofArray);</span>
<span class="line-modified">293     }</span>
<span class="line-modified">294 </span>
<span class="line-added">295     @Override</span>
<span class="line-added">296     public final short[] toShortArray() {</span>
<span class="line-added">297         return toArray(short[].class, 2, short[]::new, MemorySegment::ofArray);</span>
<span class="line-added">298     }</span>
<span class="line-added">299 </span>
<span class="line-added">300     @Override</span>
<span class="line-added">301     public final char[] toCharArray() {</span>
<span class="line-added">302         return toArray(char[].class, 2, char[]::new, MemorySegment::ofArray);</span>
<span class="line-added">303     }</span>
<span class="line-added">304 </span>
<span class="line-added">305     @Override</span>
<span class="line-added">306     public final int[] toIntArray() {</span>
<span class="line-added">307         return toArray(int[].class, 4, int[]::new, MemorySegment::ofArray);</span>
<span class="line-added">308     }</span>
<span class="line-added">309 </span>
<span class="line-added">310     @Override</span>
<span class="line-added">311     public final float[] toFloatArray() {</span>
<span class="line-added">312         return toArray(float[].class, 4, float[]::new, MemorySegment::ofArray);</span>
<span class="line-added">313     }</span>
<span class="line-added">314 </span>
<span class="line-added">315     @Override</span>
<span class="line-added">316     public final long[] toLongArray() {</span>
<span class="line-added">317         return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);</span>
<span class="line-added">318     }</span>
<span class="line-added">319 </span>
<span class="line-added">320     @Override</span>
<span class="line-added">321     public final double[] toDoubleArray() {</span>
<span class="line-added">322         return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);</span>
<span class="line-added">323     }</span>
<span class="line-added">324 </span>
<span class="line-added">325     private &lt;Z&gt; Z toArray(Class&lt;Z&gt; arrayClass, int elemSize, IntFunction&lt;Z&gt; arrayFactory, Function&lt;Z, MemorySegment&gt; segmentFactory) {</span>
<span class="line-added">326         int size = checkArraySize(arrayClass.getSimpleName(), elemSize);</span>
<span class="line-added">327         Z arr = arrayFactory.apply(size);</span>
<span class="line-added">328         MemorySegment arrSegment = segmentFactory.apply(arr);</span>
329         arrSegment.copyFrom(this);
330         return arr;
331     }
332 
333     boolean isSmall() {
334         return isSet(SMALL);
335     }
336 
337     void checkRange(long offset, long length, boolean writeAccess) {
338         scope.checkValidState();
339         if (writeAccess &amp;&amp; !isSet(WRITE)) {
340             throw unsupportedAccessMode(WRITE);
341         } else if (!writeAccess &amp;&amp; !isSet(READ)) {
342             throw unsupportedAccessMode(READ);
343         }
344         checkBounds(offset, length);
345     }
346 
347     @Override
348     public final void checkValidState() {
349         scope.checkValidState();
350     }
351 
352     // Helper methods
353 
354     private boolean isSet(int mask) {
355         return (this.mask &amp; mask) != 0;
356     }
357 
<span class="line-modified">358     private int checkArraySize(String typeName, int elemSize) {</span>
<span class="line-modified">359         if (length % elemSize != 0) {</span>
<span class="line-added">360             throw new UnsupportedOperationException(String.format(&quot;Segment size is not a multiple of %d. Size: %d&quot;, elemSize, length));</span>
<span class="line-added">361         }</span>
<span class="line-added">362         long arraySize = length / elemSize;</span>
<span class="line-added">363         if (arraySize &gt; (Integer.MAX_VALUE - 8)) { //conservative check</span>
364             throw new UnsupportedOperationException(String.format(&quot;Segment is too large to wrap as %s. Size: %d&quot;, typeName, length));
365         }
<span class="line-added">366         return (int)arraySize;</span>
367     }
368 
369     private void checkBounds(long offset, long length) {
370         if (isSmall()) {
371             checkBoundsSmall((int)offset, (int)length);
372         } else {
373             if (length &lt; 0 ||
374                     offset &lt; 0 ||
375                     offset &gt; this.length - length) { // careful of overflow
376                 throw outOfBoundException(offset, length);
377             }
378         }
379     }
380 
381     private void checkBoundsSmall(int offset, int length) {
382         if (length &lt; 0 ||
383                 offset &lt; 0 ||
384                 offset &gt; (int)this.length - length) { // careful of overflow
385             throw outOfBoundException(offset, length);
386         }
</pre>
<hr />
<pre>
550         @Override
551         ByteBuffer makeByteBuffer() {
552             throw new UnsupportedOperationException();
553         }
554 
555         @Override
556         long min() {
557             return 0;
558         }
559 
560         @Override
561         Object base() {
562             return null;
563         }
564 
565         @Override
566         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
567             throw new UnsupportedOperationException();
568         }
569     };
<span class="line-added">570 </span>
<span class="line-added">571     public static final AbstractMemorySegmentImpl EVERYTHING = new AbstractMemorySegmentImpl(</span>
<span class="line-added">572             Long.MAX_VALUE, READ | WRITE, MemoryScope.createUnchecked(null, null, null)</span>
<span class="line-added">573     ) {</span>
<span class="line-added">574         @Override</span>
<span class="line-added">575         ByteBuffer makeByteBuffer() {</span>
<span class="line-added">576             throw new UnsupportedOperationException();</span>
<span class="line-added">577         }</span>
<span class="line-added">578 </span>
<span class="line-added">579         @Override</span>
<span class="line-added">580         long min() {</span>
<span class="line-added">581             return 0;</span>
<span class="line-added">582         }</span>
<span class="line-added">583 </span>
<span class="line-added">584         @Override</span>
<span class="line-added">585         Object base() {</span>
<span class="line-added">586             return null;</span>
<span class="line-added">587         }</span>
<span class="line-added">588 </span>
<span class="line-added">589         @Override</span>
<span class="line-added">590         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {</span>
<span class="line-added">591             throw new UnsupportedOperationException();</span>
<span class="line-added">592         }</span>
<span class="line-added">593     };</span>
594 }
</pre>
</td>
</tr>
</table>
<center><a href="../../incubator/foreign/MemorySegment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LayoutPath.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
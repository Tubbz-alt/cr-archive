diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -45,10 +45,12 @@
 import java.util.List;
 import java.util.Objects;
 import java.util.Random;
 import java.util.Spliterator;
 import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.IntFunction;
 
 /**
  * This abstract class provides an immutable implementation for the {@code MemorySegment} interface. This class contains information
  * about the segment's spatial and temporal bounds; each memory segment implementation is associated with an owner thread which is set at creation time.
  * Access to certain sensitive operations on the memory segment will fail with {@code IllegalStateException} if the
@@ -130,10 +132,20 @@
         UNSAFE.copyMemory(
                 that.base(), that.min(),
                 base(), min(), size);
     }
 
+    public void copyFromSwap(MemorySegment src, long elemSize) {
+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
+        long size = that.byteSize();
+        checkRange(0, size, true);
+        that.checkRange(0, size, false);
+        UNSAFE.copySwapMemory(
+                that.base(), that.min(),
+                base(), min(), size, elemSize);
+    }
+
     private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
             .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
 
     @Override
     public long mismatch(MemorySegment other) {
@@ -182,11 +194,11 @@
     @Override
     public final ByteBuffer asByteBuffer() {
         if (!isSet(READ)) {
             throw unsupportedAccessMode(READ);
         }
-        checkIntSize("ByteBuffer");
+        checkArraySize("ByteBuffer", 1);
         ByteBuffer _bb = makeByteBuffer();
         if (!isSet(WRITE)) {
             //scope is IMMUTABLE - obtain a RO byte buffer
             _bb = _bb.asReadOnlyBuffer();
         }
@@ -241,16 +253,20 @@
             throw unsupportedAccessMode(HANDOFF);
         }
         if (scope.ownerThread() == newOwner) {
             throw new IllegalArgumentException("Segment already owned by thread: " + newOwner);
         } else {
-            try {
-                return dup(0L, length, mask, scope.dup(newOwner));
-            } finally {
-                //flush read/writes to segment memory before returning the new segment
-                VarHandle.fullFence();
-            }
+            return dupAndClose(newOwner);
+        }
+    }
+
+    public MemorySegment dupAndClose(Thread newOwner) {
+        try {
+            return dup(0L, length, mask, scope.dup(newOwner));
+        } finally {
+            //flush read/writes to segment memory before returning the new segment
+            VarHandle.fullFence();
         }
     }
 
     @Override
     public final void close() {
@@ -271,13 +287,47 @@
         return dup(0, length, mask, scope.acquire());
     }
 
     @Override
     public final byte[] toByteArray() {
-        checkIntSize("byte[]");
-        byte[] arr = new byte[(int)length];
-        MemorySegment arrSegment = MemorySegment.ofArray(arr);
+        return toArray(byte[].class, 1, byte[]::new, MemorySegment::ofArray);
+    }
+
+    @Override
+    public final short[] toShortArray() {
+        return toArray(short[].class, 2, short[]::new, MemorySegment::ofArray);
+    }
+
+    @Override
+    public final char[] toCharArray() {
+        return toArray(char[].class, 2, char[]::new, MemorySegment::ofArray);
+    }
+
+    @Override
+    public final int[] toIntArray() {
+        return toArray(int[].class, 4, int[]::new, MemorySegment::ofArray);
+    }
+
+    @Override
+    public final float[] toFloatArray() {
+        return toArray(float[].class, 4, float[]::new, MemorySegment::ofArray);
+    }
+
+    @Override
+    public final long[] toLongArray() {
+        return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);
+    }
+
+    @Override
+    public final double[] toDoubleArray() {
+        return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);
+    }
+
+    private <Z> Z toArray(Class<Z> arrayClass, int elemSize, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {
+        int size = checkArraySize(arrayClass.getSimpleName(), elemSize);
+        Z arr = arrayFactory.apply(size);
+        MemorySegment arrSegment = segmentFactory.apply(arr);
         arrSegment.copyFrom(this);
         return arr;
     }
 
     boolean isSmall() {
@@ -303,14 +353,19 @@
 
     private boolean isSet(int mask) {
         return (this.mask & mask) != 0;
     }
 
-    private void checkIntSize(String typeName) {
-        if (length > (Integer.MAX_VALUE - 8)) { //conservative check
+    private int checkArraySize(String typeName, int elemSize) {
+        if (length % elemSize != 0) {
+            throw new UnsupportedOperationException(String.format("Segment size is not a multiple of %d. Size: %d", elemSize, length));
+        }
+        long arraySize = length / elemSize;
+        if (arraySize > (Integer.MAX_VALUE - 8)) { //conservative check
             throw new UnsupportedOperationException(String.format("Segment is too large to wrap as %s. Size: %d", typeName, length));
         }
+        return (int)arraySize;
     }
 
     private void checkBounds(long offset, long length) {
         if (isSmall()) {
             checkBoundsSmall((int)offset, (int)length);
@@ -510,6 +565,30 @@
         @Override
         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
             throw new UnsupportedOperationException();
         }
     };
+
+    public static final AbstractMemorySegmentImpl EVERYTHING = new AbstractMemorySegmentImpl(
+            Long.MAX_VALUE, READ | WRITE, MemoryScope.createUnchecked(null, null, null)
+    ) {
+        @Override
+        ByteBuffer makeByteBuffer() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        long min() {
+            return 0;
+        }
+
+        @Override
+        Object base() {
+            return null;
+        }
+
+        @Override
+        AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
+            throw new UnsupportedOperationException();
+        }
+    };
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.incubator.foreign;
 28 
 29 import java.lang.invoke.VarHandle;
 30 import java.nio.ByteOrder;
 31 
 32 /**
 33  * This class defines useful layout constants. Some of the constants defined in this class are explicit in both
 34  * size and byte order (see {@link #BITS_64_BE}), and can therefore be used to explicitly and unambiguously specify the
 35  * contents of a memory segment. Other constants make implicit byte order assumptions (see
 36  * {@link #JAVA_INT}); as such, these constants make it easy to work with other serialization-centric APIs,
 37  * such as {@link java.nio.ByteBuffer}.
 38  */
 39 public final class MemoryLayouts {
 40 
 41     private MemoryLayouts() {
 42         //just the one, please
 43     }
 44 
 45     /**
 46      * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 47      */
 48     public static final ValueLayout BITS_8_LE = MemoryLayout.ofValueBits(8, ByteOrder.LITTLE_ENDIAN);
 49 
 50     /**
 51      * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 52      */
 53     public static final ValueLayout BITS_16_LE = MemoryLayout.ofValueBits(16, ByteOrder.LITTLE_ENDIAN);
 54 
 55     /**
 56      * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 57      */
 58     public static final ValueLayout BITS_32_LE = MemoryLayout.ofValueBits(32, ByteOrder.LITTLE_ENDIAN);
 59 
 60     /**
 61      * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 62      */
 63     public static final ValueLayout BITS_64_LE = MemoryLayout.ofValueBits(64, ByteOrder.LITTLE_ENDIAN);
 64 
<a name="1" id="anc1"></a><span class="line-removed"> 65     private static final VarHandle byte_LE_handle = indexedHandle(BITS_8_LE, byte.class);</span>
<span class="line-removed"> 66     private static final VarHandle char_LE_handle = indexedHandle(BITS_16_LE, char.class);</span>
<span class="line-removed"> 67     private static final VarHandle short_LE_handle = indexedHandle(BITS_16_LE, short.class);</span>
<span class="line-removed"> 68     private static final VarHandle int_LE_handle = indexedHandle(BITS_32_LE, int.class);</span>
<span class="line-removed"> 69     private static final VarHandle float_LE_handle = indexedHandle(BITS_32_LE, float.class);</span>
<span class="line-removed"> 70     private static final VarHandle long_LE_handle = indexedHandle(BITS_64_LE, long.class);</span>
<span class="line-removed"> 71     private static final VarHandle double_LE_handle = indexedHandle(BITS_64_LE, double.class);</span>
<span class="line-removed"> 72 </span>
<span class="line-removed"> 73     /**</span>
<span class="line-removed"> 74      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed"> 75      * &lt;p&gt;</span>
<span class="line-removed"> 76      * This is equivalent to the following code:</span>
<span class="line-removed"> 77      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed"> 78     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-removed"> 79     byte value = (byte)handle.get(addr, offset);</span>
<span class="line-removed"> 80      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed"> 81      *</span>
<span class="line-removed"> 82      * @param addr base address.</span>
<span class="line-removed"> 83      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed"> 84      * @return a byte value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed"> 85      */</span>
<span class="line-removed"> 86     public static byte getByte_LE(MemoryAddress addr, long offset) {</span>
<span class="line-removed"> 87         return (byte)byte_LE_handle.get(addr, offset);</span>
<span class="line-removed"> 88     }</span>
<span class="line-removed"> 89 </span>
<span class="line-removed"> 90     /**</span>
<span class="line-removed"> 91      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed"> 92      * &lt;p&gt;</span>
<span class="line-removed"> 93      * This is equivalent to the following code:</span>
<span class="line-removed"> 94      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed"> 95     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-removed"> 96     handle.set(addr, offset, value);</span>
<span class="line-removed"> 97      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed"> 98      * @param addr base address.</span>
<span class="line-removed"> 99      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">100      * @param value the byte value to be written.</span>
<span class="line-removed">101      */</span>
<span class="line-removed">102     public static void setByte_LE(MemoryAddress addr, long offset, byte value) {</span>
<span class="line-removed">103         byte_LE_handle.set(addr, offset, value);</span>
<span class="line-removed">104     }</span>
<span class="line-removed">105 </span>
<span class="line-removed">106     /**</span>
<span class="line-removed">107      * Read a char from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">108      * &lt;p&gt;</span>
<span class="line-removed">109      * This is equivalent to the following code:</span>
<span class="line-removed">110      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">111     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-removed">112     char value = (char)handle.get(addr, offset);</span>
<span class="line-removed">113      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">114      * @param addr base address.</span>
<span class="line-removed">115      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">116      * @return a char value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">117      */</span>
<span class="line-removed">118     public static char getChar_LE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">119         return (char)char_LE_handle.get(addr, offset);</span>
<span class="line-removed">120     }</span>
<span class="line-removed">121 </span>
<span class="line-removed">122     /**</span>
<span class="line-removed">123      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">124      * &lt;p&gt;</span>
<span class="line-removed">125      * This is equivalent to the following code:</span>
<span class="line-removed">126      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">127     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-removed">128     handle.set(addr, offset, value);</span>
<span class="line-removed">129      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">130      * @param addr base address.</span>
<span class="line-removed">131      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">132      * @param value the char value to be written.</span>
<span class="line-removed">133      */</span>
<span class="line-removed">134     public static void setChar_LE(MemoryAddress addr, long offset, char value) {</span>
<span class="line-removed">135         char_LE_handle.set(addr, offset, value);</span>
<span class="line-removed">136     }</span>
<span class="line-removed">137 </span>
<span class="line-removed">138     /**</span>
<span class="line-removed">139      * Read a short from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">140      * &lt;p&gt;</span>
<span class="line-removed">141      * This is equivalent to the following code:</span>
<span class="line-removed">142      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">143     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-removed">144     short value = (short)handle.get(addr, offset);</span>
<span class="line-removed">145      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">146      * @param addr base address.</span>
<span class="line-removed">147      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">148      * @return a short value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">149      */</span>
<span class="line-removed">150     public static short getShort_LE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">151         return (short)short_LE_handle.get(addr, offset);</span>
<span class="line-removed">152     }</span>
<span class="line-removed">153 </span>
<span class="line-removed">154     /**</span>
<span class="line-removed">155      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">156      * &lt;p&gt;</span>
<span class="line-removed">157      * This is equivalent to the following code:</span>
<span class="line-removed">158      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">159     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-removed">160     handle.set(addr, offset, value);</span>
<span class="line-removed">161      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">162      * @param addr base address.</span>
<span class="line-removed">163      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">164      * @param value the short value to be written.</span>
<span class="line-removed">165      */</span>
<span class="line-removed">166     public static void setShort_LE(MemoryAddress addr, long offset, short value) {</span>
<span class="line-removed">167         short_LE_handle.set(addr, offset, value);</span>
<span class="line-removed">168     }</span>
<span class="line-removed">169 </span>
<span class="line-removed">170     /**</span>
<span class="line-removed">171      * Read an int from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">172      * &lt;p&gt;</span>
<span class="line-removed">173      * This is equivalent to the following code:</span>
<span class="line-removed">174      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">175     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-removed">176     int value = (int)handle.get(addr, offset);</span>
<span class="line-removed">177      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">178      * @param addr base address.</span>
<span class="line-removed">179      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">180      * @return an int value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">181      */</span>
<span class="line-removed">182     public static int getInt_LE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">183         return (int)int_LE_handle.get(addr, offset);</span>
<span class="line-removed">184     }</span>
<span class="line-removed">185 </span>
<span class="line-removed">186     /**</span>
<span class="line-removed">187      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">188      * &lt;p&gt;</span>
<span class="line-removed">189      * This is equivalent to the following code:</span>
<span class="line-removed">190      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">191     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-removed">192     handle.set(addr, offset, value);</span>
<span class="line-removed">193      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">194      * @param addr base address.</span>
<span class="line-removed">195      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">196      * @param value the int value to be written.</span>
<span class="line-removed">197      */</span>
<span class="line-removed">198     public static void setInt_LE(MemoryAddress addr, long offset, int value) {</span>
<span class="line-removed">199         int_LE_handle.set(addr, offset, value);</span>
<span class="line-removed">200     }</span>
<span class="line-removed">201 </span>
<span class="line-removed">202     /**</span>
<span class="line-removed">203      * Read a float from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">204      * &lt;p&gt;</span>
<span class="line-removed">205      * This is equivalent to the following code:</span>
<span class="line-removed">206      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">207     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-removed">208     float value = (float)handle.get(addr, offset);</span>
<span class="line-removed">209      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">210      * @param addr base address.</span>
<span class="line-removed">211      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">212      * @return a float value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">213      */</span>
<span class="line-removed">214     public static float getFloat_LE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">215         return (float)float_LE_handle.get(addr, offset);</span>
<span class="line-removed">216     }</span>
<span class="line-removed">217 </span>
<span class="line-removed">218     /**</span>
<span class="line-removed">219      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">220      * &lt;p&gt;</span>
<span class="line-removed">221      * This is equivalent to the following code:</span>
<span class="line-removed">222      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">223     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-removed">224     handle.set(addr, offset, value);</span>
<span class="line-removed">225      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">226      * @param addr base address.</span>
<span class="line-removed">227      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">228      * @param value the float value to be written.</span>
<span class="line-removed">229      */</span>
<span class="line-removed">230     public static void setFloat_LE(MemoryAddress addr, long offset, float value) {</span>
<span class="line-removed">231         float_LE_handle.set(addr, offset, value);</span>
<span class="line-removed">232     }</span>
<span class="line-removed">233 </span>
<span class="line-removed">234     /**</span>
<span class="line-removed">235      * Read a long from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">236      * &lt;p&gt;</span>
<span class="line-removed">237      * This is equivalent to the following code:</span>
<span class="line-removed">238      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">239     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-removed">240     long value = (long)handle.get(addr, offset);</span>
<span class="line-removed">241      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">242      * @param addr base address.</span>
<span class="line-removed">243      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">244      * @return a long value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">245      */</span>
<span class="line-removed">246     public static long getLong_LE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">247         return (long)long_LE_handle.get(addr, offset);</span>
<span class="line-removed">248     }</span>
<span class="line-removed">249 </span>
<span class="line-removed">250     /**</span>
<span class="line-removed">251      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">252      * &lt;p&gt;</span>
<span class="line-removed">253      * This is equivalent to the following code:</span>
<span class="line-removed">254      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">255     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-removed">256     handle.set(addr, offset, value);</span>
<span class="line-removed">257      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">258      * @param addr base address.</span>
<span class="line-removed">259      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">260      * @param value the long value to be written.</span>
<span class="line-removed">261      */</span>
<span class="line-removed">262     public static void setLong_LE(MemoryAddress addr, long offset, long value) {</span>
<span class="line-removed">263         long_LE_handle.set(addr, offset, value);</span>
<span class="line-removed">264     }</span>
<span class="line-removed">265 </span>
<span class="line-removed">266     /**</span>
<span class="line-removed">267      * Read a double from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">268      * &lt;p&gt;</span>
<span class="line-removed">269      * This is equivalent to the following code:</span>
<span class="line-removed">270      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">271     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-removed">272     double value = (double)handle.get(addr, offset);</span>
<span class="line-removed">273      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">274      * @param addr base address.</span>
<span class="line-removed">275      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">276      * @return a double value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">277      */</span>
<span class="line-removed">278     public static double getDouble_LE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">279         return (double)double_LE_handle.get(addr, offset);</span>
<span class="line-removed">280     }</span>
<span class="line-removed">281 </span>
<span class="line-removed">282     /**</span>
<span class="line-removed">283      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-removed">284      * &lt;p&gt;</span>
<span class="line-removed">285      * This is equivalent to the following code:</span>
<span class="line-removed">286      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">287     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-removed">288     handle.set(addr, offset, value);</span>
<span class="line-removed">289      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">290      * @param addr base address.</span>
<span class="line-removed">291      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">292      * @param value the double value to be written.</span>
<span class="line-removed">293      */</span>
<span class="line-removed">294     public static void setDouble_LE(MemoryAddress addr, long offset, double value) {</span>
<span class="line-removed">295         double_LE_handle.set(addr, offset, value);</span>
<span class="line-removed">296     }</span>
<span class="line-removed">297 </span>
298     /**
299      * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
300      */
301     public static final ValueLayout BITS_8_BE = MemoryLayout.ofValueBits(8, ByteOrder.BIG_ENDIAN);
302 
303     /**
304      * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
305      */
306     public static final ValueLayout BITS_16_BE = MemoryLayout.ofValueBits(16, ByteOrder.BIG_ENDIAN);
307 
308     /**
309      * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
310      */
311     public static final ValueLayout BITS_32_BE = MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN);
312 
313     /**
314      * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
315      */
316     public static final ValueLayout BITS_64_BE = MemoryLayout.ofValueBits(64, ByteOrder.BIG_ENDIAN);
317 
<a name="2" id="anc2"></a><span class="line-removed">318     private static final VarHandle byte_BE_handle = indexedHandle(BITS_8_BE, byte.class);</span>
<span class="line-removed">319     private static final VarHandle char_BE_handle = indexedHandle(BITS_16_BE, char.class);</span>
<span class="line-removed">320     private static final VarHandle short_BE_handle = indexedHandle(BITS_16_BE, short.class);</span>
<span class="line-removed">321     private static final VarHandle int_BE_handle = indexedHandle(BITS_32_BE, int.class);</span>
<span class="line-removed">322     private static final VarHandle float_BE_handle = indexedHandle(BITS_32_BE, float.class);</span>
<span class="line-removed">323     private static final VarHandle long_BE_handle = indexedHandle(BITS_64_BE, long.class);</span>
<span class="line-removed">324     private static final VarHandle double_BE_handle = indexedHandle(BITS_64_BE, double.class);</span>
<span class="line-removed">325 </span>
<span class="line-removed">326     /**</span>
<span class="line-removed">327      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">328      * &lt;p&gt;</span>
<span class="line-removed">329      * This is equivalent to the following code:</span>
<span class="line-removed">330      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">331     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-removed">332     byte value = (byte)handle.get(addr, offset);</span>
<span class="line-removed">333      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">334      *</span>
<span class="line-removed">335      * @param addr base address.</span>
<span class="line-removed">336      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">337      * @return a byte value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">338      */</span>
<span class="line-removed">339     public static byte getByte_BE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">340         return (byte)byte_BE_handle.get(addr, offset);</span>
<span class="line-removed">341     }</span>
<span class="line-removed">342 </span>
<span class="line-removed">343     /**</span>
<span class="line-removed">344      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">345      * &lt;p&gt;</span>
<span class="line-removed">346      * This is equivalent to the following code:</span>
<span class="line-removed">347      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">348     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-removed">349     handle.set(addr, offset, value);</span>
<span class="line-removed">350      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">351      * @param addr base address.</span>
<span class="line-removed">352      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">353      * @param value the byte value to be written.</span>
<span class="line-removed">354      */</span>
<span class="line-removed">355     public static void setByte_BE(MemoryAddress addr, long offset, byte value) {</span>
<span class="line-removed">356         byte_BE_handle.set(addr, offset, value);</span>
<span class="line-removed">357     }</span>
<span class="line-removed">358 </span>
<span class="line-removed">359     /**</span>
<span class="line-removed">360      * Read a char from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">361      * &lt;p&gt;</span>
<span class="line-removed">362      * This is equivalent to the following code:</span>
<span class="line-removed">363      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">364     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-removed">365     char value = (char)handle.get(addr, offset);</span>
<span class="line-removed">366      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">367      * @param addr base address.</span>
<span class="line-removed">368      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">369      * @return a char value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">370      */</span>
<span class="line-removed">371     public static char getChar_BE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">372         return (char)char_BE_handle.get(addr, offset);</span>
<span class="line-removed">373     }</span>
<span class="line-removed">374 </span>
<span class="line-removed">375     /**</span>
<span class="line-removed">376      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">377      * &lt;p&gt;</span>
<span class="line-removed">378      * This is equivalent to the following code:</span>
<span class="line-removed">379      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">380     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-removed">381     handle.set(addr, offset, value);</span>
<span class="line-removed">382      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">383      * @param addr base address.</span>
<span class="line-removed">384      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">385      * @param value the char value to be written.</span>
<span class="line-removed">386      */</span>
<span class="line-removed">387     public static void setChar_BE(MemoryAddress addr, long offset, char value) {</span>
<span class="line-removed">388         char_BE_handle.set(addr, offset, value);</span>
<span class="line-removed">389     }</span>
<span class="line-removed">390 </span>
<span class="line-removed">391     /**</span>
<span class="line-removed">392      * Read a short from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">393      * &lt;p&gt;</span>
<span class="line-removed">394      * This is equivalent to the following code:</span>
<span class="line-removed">395      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">396     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-removed">397     short value = (short)handle.get(addr, offset);</span>
<span class="line-removed">398      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">399      * @param addr base address.</span>
<span class="line-removed">400      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">401      * @return a short value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">402      */</span>
<span class="line-removed">403     public static short getShort_BE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">404         return (short)short_BE_handle.get(addr, offset);</span>
<span class="line-removed">405     }</span>
<span class="line-removed">406 </span>
<span class="line-removed">407     /**</span>
<span class="line-removed">408      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">409      * &lt;p&gt;</span>
<span class="line-removed">410      * This is equivalent to the following code:</span>
<span class="line-removed">411      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">412     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-removed">413     handle.set(addr, offset, value);</span>
<span class="line-removed">414      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">415      * @param addr base address.</span>
<span class="line-removed">416      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">417      * @param value the short value to be written.</span>
<span class="line-removed">418      */</span>
<span class="line-removed">419     public static void setShort_BE(MemoryAddress addr, long offset, short value) {</span>
<span class="line-removed">420         short_BE_handle.set(addr, offset, value);</span>
<span class="line-removed">421     }</span>
<span class="line-removed">422 </span>
<span class="line-removed">423     /**</span>
<span class="line-removed">424      * Read an int from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">425      * &lt;p&gt;</span>
<span class="line-removed">426      * This is equivalent to the following code:</span>
<span class="line-removed">427      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">428     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-removed">429     int value = (int)handle.get(addr, offset);</span>
<span class="line-removed">430      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">431      * @param addr base address.</span>
<span class="line-removed">432      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">433      * @return an int value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">434      */</span>
<span class="line-removed">435     public static int getInt_BE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">436         return (int)int_BE_handle.get(addr, offset);</span>
<span class="line-removed">437     }</span>
<span class="line-removed">438 </span>
<span class="line-removed">439     /**</span>
<span class="line-removed">440      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">441      * &lt;p&gt;</span>
<span class="line-removed">442      * This is equivalent to the following code:</span>
<span class="line-removed">443      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">444     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-removed">445     handle.set(addr, offset, value);</span>
<span class="line-removed">446      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">447      * @param addr base address.</span>
<span class="line-removed">448      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">449      * @param value the int value to be written.</span>
<span class="line-removed">450      */</span>
<span class="line-removed">451     public static void setInt_BE(MemoryAddress addr, long offset, int value) {</span>
<span class="line-removed">452         int_BE_handle.set(addr, offset, value);</span>
<span class="line-removed">453     }</span>
<span class="line-removed">454 </span>
<span class="line-removed">455     /**</span>
<span class="line-removed">456      * Read a float from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">457      * &lt;p&gt;</span>
<span class="line-removed">458      * This is equivalent to the following code:</span>
<span class="line-removed">459      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">460     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-removed">461     float value = (float)handle.get(addr, offset);</span>
<span class="line-removed">462      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">463      * @param addr base address.</span>
<span class="line-removed">464      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">465      * @return a float value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">466      */</span>
<span class="line-removed">467     public static float getFloat_BE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">468         return (float)float_BE_handle.get(addr, offset);</span>
<span class="line-removed">469     }</span>
<span class="line-removed">470 </span>
<span class="line-removed">471     /**</span>
<span class="line-removed">472      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">473      * &lt;p&gt;</span>
<span class="line-removed">474      * This is equivalent to the following code:</span>
<span class="line-removed">475      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">476     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-removed">477     handle.set(addr, offset, value);</span>
<span class="line-removed">478      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">479      * @param addr base address.</span>
<span class="line-removed">480      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">481      * @param value the float value to be written.</span>
<span class="line-removed">482      */</span>
<span class="line-removed">483     public static void setFloat_BE(MemoryAddress addr, long offset, float value) {</span>
<span class="line-removed">484         float_BE_handle.set(addr, offset, value);</span>
<span class="line-removed">485     }</span>
<span class="line-removed">486 </span>
<span class="line-removed">487     /**</span>
<span class="line-removed">488      * Read a long from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">489      * &lt;p&gt;</span>
<span class="line-removed">490      * This is equivalent to the following code:</span>
<span class="line-removed">491      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">492     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-removed">493     long value = (long)handle.get(addr, offset);</span>
<span class="line-removed">494      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">495      * @param addr base address.</span>
<span class="line-removed">496      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">497      * @return a long value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">498      */</span>
<span class="line-removed">499     public static long getLong_BE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">500         return (long)long_BE_handle.get(addr, offset);</span>
<span class="line-removed">501     }</span>
<span class="line-removed">502 </span>
<span class="line-removed">503     /**</span>
<span class="line-removed">504      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">505      * &lt;p&gt;</span>
<span class="line-removed">506      * This is equivalent to the following code:</span>
<span class="line-removed">507      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">508     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-removed">509     handle.set(addr, offset, value);</span>
<span class="line-removed">510      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">511      * @param addr base address.</span>
<span class="line-removed">512      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">513      * @param value the long value to be written.</span>
<span class="line-removed">514      */</span>
<span class="line-removed">515     public static void setLong_BE(MemoryAddress addr, long offset, long value) {</span>
<span class="line-removed">516         long_BE_handle.set(addr, offset, value);</span>
<span class="line-removed">517     }</span>
<span class="line-removed">518 </span>
<span class="line-removed">519     /**</span>
<span class="line-removed">520      * Read a double from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">521      * &lt;p&gt;</span>
<span class="line-removed">522      * This is equivalent to the following code:</span>
<span class="line-removed">523      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">524     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-removed">525     double value = (double)handle.get(addr, offset);</span>
<span class="line-removed">526      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">527      * @param addr base address.</span>
<span class="line-removed">528      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">529      * @return a double value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">530      */</span>
<span class="line-removed">531     public static double getDouble_BE(MemoryAddress addr, long offset) {</span>
<span class="line-removed">532         return (double)double_BE_handle.get(addr, offset);</span>
<span class="line-removed">533     }</span>
<span class="line-removed">534 </span>
<span class="line-removed">535     /**</span>
<span class="line-removed">536      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-removed">537      * &lt;p&gt;</span>
<span class="line-removed">538      * This is equivalent to the following code:</span>
<span class="line-removed">539      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">540     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-removed">541     handle.set(addr, offset, value);</span>
<span class="line-removed">542      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">543      * @param addr base address.</span>
<span class="line-removed">544      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">545      * @param value the double value to be written.</span>
<span class="line-removed">546      */</span>
<span class="line-removed">547     public static void setDouble_BE(MemoryAddress addr, long offset, double value) {</span>
<span class="line-removed">548         double_BE_handle.set(addr, offset, value);</span>
<span class="line-removed">549     }</span>
<span class="line-removed">550 </span>
551     /**
552      * A padding layout constant with size of one byte.
553      */
554     public static final MemoryLayout PAD_8 = MemoryLayout.ofPaddingBits(8);
555 
556     /**
557      * A padding layout constant with size of two bytes.
558      */
559     public static final MemoryLayout PAD_16 = MemoryLayout.ofPaddingBits(16);
560 
561     /**
562      * A padding layout constant with size of four bytes.
563      */
564     public static final MemoryLayout PAD_32 = MemoryLayout.ofPaddingBits(32);
565 
566     /**
567      * A padding layout constant with size of eight bytes.
568      */
569     public static final MemoryLayout PAD_64 = MemoryLayout.ofPaddingBits(64);
570 
571     /**
572      * A value layout constant whose size is the same as that of a Java {@code byte}, and byte order set to {@link ByteOrder#nativeOrder()}.
573      */
574     public static final ValueLayout JAVA_BYTE = MemoryLayout.ofValueBits(8, ByteOrder.nativeOrder());
575 
576     /**
577      * A value layout constant whose size is the same as that of a Java {@code char}, and byte order set to {@link ByteOrder#nativeOrder()}.
578      */
579     public static final ValueLayout JAVA_CHAR = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder());
580 
581     /**
582      * A value layout constant whose size is the same as that of a Java {@code short}, and byte order set to {@link ByteOrder#nativeOrder()}.
583      */
584     public static final ValueLayout JAVA_SHORT = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder());
585 
586     /**
587      * A value layout constant whose size is the same as that of a Java {@code int}, and byte order set to {@link ByteOrder#nativeOrder()}.
588      */
589     public static final ValueLayout JAVA_INT = MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder());
590 
591     /**
592      * A value layout constant whose size is the same as that of a Java {@code long}, and byte order set to {@link ByteOrder#nativeOrder()}.
593      */
594     public static final ValueLayout JAVA_LONG = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());
595 
596     /**
597      * A value layout constant whose size is the same as that of a Java {@code float}, and byte order set to {@link ByteOrder#nativeOrder()}.
598      */
599     public static final ValueLayout JAVA_FLOAT = MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder());
600 
601     /**
602      * A value layout constant whose size is the same as that of a Java {@code double}, and byte order set to {@link ByteOrder#nativeOrder()}.
603      */
604     public static final ValueLayout JAVA_DOUBLE = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());
605 
<a name="3" id="anc3"></a><span class="line-removed">606     /**</span>
<span class="line-removed">607      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">608      * &lt;p&gt;</span>
<span class="line-removed">609      * This is equivalent to the following code:</span>
<span class="line-removed">610      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">611     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-removed">612     byte value = (byte)handle.get(addr, offset);</span>
<span class="line-removed">613      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">614      *</span>
<span class="line-removed">615      * @param addr base address.</span>
<span class="line-removed">616      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">617      * @return a byte value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">618      */</span>
<span class="line-removed">619     public static byte getByte(MemoryAddress addr, long offset) {</span>
<span class="line-removed">620         return (byte)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).get(addr, offset);</span>
<span class="line-removed">621     }</span>
<span class="line-removed">622 </span>
<span class="line-removed">623     /**</span>
<span class="line-removed">624      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">625      * &lt;p&gt;</span>
<span class="line-removed">626      * This is equivalent to the following code:</span>
<span class="line-removed">627      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">628     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-removed">629     handle.set(addr, offset, value);</span>
<span class="line-removed">630      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">631      * @param addr base address.</span>
<span class="line-removed">632      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">633      * @param value the byte value to be written.</span>
<span class="line-removed">634      */</span>
<span class="line-removed">635     public static void setByte(MemoryAddress addr, long offset, byte value) {</span>
<span class="line-removed">636         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).set(addr, offset, value);</span>
<span class="line-removed">637     }</span>
<span class="line-removed">638 </span>
<span class="line-removed">639     /**</span>
<span class="line-removed">640      * Read a char from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">641      * &lt;p&gt;</span>
<span class="line-removed">642      * This is equivalent to the following code:</span>
<span class="line-removed">643      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">644     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-removed">645     char value = (char)handle.get(addr, offset);</span>
<span class="line-removed">646      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">647      * @param addr base address.</span>
<span class="line-removed">648      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">649      * @return a char value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">650      */</span>
<span class="line-removed">651     public static char getChar(MemoryAddress addr, long offset) {</span>
<span class="line-removed">652         return (char)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(addr, offset);</span>
<span class="line-removed">653     }</span>
<span class="line-removed">654 </span>
<span class="line-removed">655     /**</span>
<span class="line-removed">656      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">657      * &lt;p&gt;</span>
<span class="line-removed">658      * This is equivalent to the following code:</span>
<span class="line-removed">659      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">660     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-removed">661     handle.set(addr, offset, value);</span>
<span class="line-removed">662      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">663      * @param addr base address.</span>
<span class="line-removed">664      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">665      * @param value the char value to be written.</span>
<span class="line-removed">666      */</span>
<span class="line-removed">667     public static void setChar(MemoryAddress addr, long offset, char value) {</span>
<span class="line-removed">668         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(addr, offset, value);</span>
<span class="line-removed">669     }</span>
<span class="line-removed">670 </span>
<span class="line-removed">671     /**</span>
<span class="line-removed">672      * Read a short from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">673      * &lt;p&gt;</span>
<span class="line-removed">674      * This is equivalent to the following code:</span>
<span class="line-removed">675      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">676     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-removed">677     short value = (short)handle.get(addr, offset);</span>
<span class="line-removed">678      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">679      * @param addr base address.</span>
<span class="line-removed">680      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">681      * @return a short value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">682      */</span>
<span class="line-removed">683     public static short getShort(MemoryAddress addr, long offset) {</span>
<span class="line-removed">684         return (short)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(addr, offset);</span>
<span class="line-removed">685     }</span>
<span class="line-removed">686 </span>
<span class="line-removed">687     /**</span>
<span class="line-removed">688      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">689      * &lt;p&gt;</span>
<span class="line-removed">690      * This is equivalent to the following code:</span>
<span class="line-removed">691      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">692     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-removed">693     handle.set(addr, offset, value);</span>
<span class="line-removed">694      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">695      * @param addr base address.</span>
<span class="line-removed">696      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">697      * @param value the short value to be written.</span>
<span class="line-removed">698      */</span>
<span class="line-removed">699     public static void setShort(MemoryAddress addr, long offset, short value) {</span>
<span class="line-removed">700         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(addr, offset, value);</span>
<span class="line-removed">701     }</span>
<span class="line-removed">702 </span>
<span class="line-removed">703     /**</span>
<span class="line-removed">704      * Read an int from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">705      * &lt;p&gt;</span>
<span class="line-removed">706      * This is equivalent to the following code:</span>
<span class="line-removed">707      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">708     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-removed">709     int value = (int)handle.get(addr, offset);</span>
<span class="line-removed">710      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">711      * @param addr base address.</span>
<span class="line-removed">712      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">713      * @return an int value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">714      */</span>
<span class="line-removed">715     public static int getInt(MemoryAddress addr, long offset) {</span>
<span class="line-removed">716         return (int)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(addr, offset);</span>
<span class="line-removed">717     }</span>
<span class="line-removed">718 </span>
<span class="line-removed">719     /**</span>
<span class="line-removed">720      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">721      * &lt;p&gt;</span>
<span class="line-removed">722      * This is equivalent to the following code:</span>
<span class="line-removed">723      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">724     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-removed">725     handle.set(addr, offset, value);</span>
<span class="line-removed">726      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">727      * @param addr base address.</span>
<span class="line-removed">728      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">729      * @param value the int value to be written.</span>
<span class="line-removed">730      */</span>
<span class="line-removed">731     public static void setInt(MemoryAddress addr, long offset, int value) {</span>
<span class="line-removed">732         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(addr, offset, value);</span>
<span class="line-removed">733     }</span>
<span class="line-removed">734 </span>
<span class="line-removed">735     /**</span>
<span class="line-removed">736      * Read a float from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">737      * &lt;p&gt;</span>
<span class="line-removed">738      * This is equivalent to the following code:</span>
<span class="line-removed">739      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">740     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-removed">741     float value = (float)handle.get(addr, offset);</span>
<span class="line-removed">742      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">743      * @param addr base address.</span>
<span class="line-removed">744      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">745      * @return a float value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">746      */</span>
<span class="line-removed">747     public static float getFloat(MemoryAddress addr, long offset) {</span>
<span class="line-removed">748         return (float)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(addr, offset);</span>
<span class="line-removed">749     }</span>
<span class="line-removed">750 </span>
<span class="line-removed">751     /**</span>
<span class="line-removed">752      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">753      * &lt;p&gt;</span>
<span class="line-removed">754      * This is equivalent to the following code:</span>
<span class="line-removed">755      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">756     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-removed">757     handle.set(addr, offset, value);</span>
<span class="line-removed">758      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">759      * @param addr base address.</span>
<span class="line-removed">760      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">761      * @param value the float value to be written.</span>
<span class="line-removed">762      */</span>
<span class="line-removed">763     public static void setFloat(MemoryAddress addr, long offset, float value) {</span>
<span class="line-removed">764         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(addr, offset, value);</span>
<span class="line-removed">765     }</span>
<span class="line-removed">766 </span>
<span class="line-removed">767     /**</span>
<span class="line-removed">768      * Read a long from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">769      * &lt;p&gt;</span>
<span class="line-removed">770      * This is equivalent to the following code:</span>
<span class="line-removed">771      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">772     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-removed">773     long value = (long)handle.get(addr, offset);</span>
<span class="line-removed">774      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">775      * @param addr base address.</span>
<span class="line-removed">776      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">777      * @return a long value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">778      */</span>
<span class="line-removed">779     public static long getLong(MemoryAddress addr, long offset) {</span>
<span class="line-removed">780         return (long)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(addr, offset);</span>
<span class="line-removed">781     }</span>
<span class="line-removed">782 </span>
<span class="line-removed">783     /**</span>
<span class="line-removed">784      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">785      * &lt;p&gt;</span>
<span class="line-removed">786      * This is equivalent to the following code:</span>
<span class="line-removed">787      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">788     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-removed">789     handle.set(addr, offset, value);</span>
<span class="line-removed">790      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">791      * @param addr base address.</span>
<span class="line-removed">792      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">793      * @param value the long value to be written.</span>
<span class="line-removed">794      */</span>
<span class="line-removed">795     public static void setLong(MemoryAddress addr, long offset, long value) {</span>
<span class="line-removed">796         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(addr, offset, value);</span>
<span class="line-removed">797     }</span>
<span class="line-removed">798 </span>
<span class="line-removed">799     /**</span>
<span class="line-removed">800      * Read a double from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">801      * &lt;p&gt;</span>
<span class="line-removed">802      * This is equivalent to the following code:</span>
<span class="line-removed">803      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">804     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-removed">805     double value = (double)handle.get(addr, offset);</span>
<span class="line-removed">806      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">807      * @param addr base address.</span>
<span class="line-removed">808      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">809      * @return a double value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-removed">810      */</span>
<span class="line-removed">811     public static double getDouble(MemoryAddress addr, long offset) {</span>
<span class="line-removed">812         return (double)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(addr, offset);</span>
<span class="line-removed">813     }</span>
<span class="line-removed">814 </span>
<span class="line-removed">815     /**</span>
<span class="line-removed">816      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-removed">817      * &lt;p&gt;</span>
<span class="line-removed">818      * This is equivalent to the following code:</span>
<span class="line-removed">819      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">820     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-removed">821     handle.set(addr, offset, value);</span>
<span class="line-removed">822      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">823      * @param addr base address.</span>
<span class="line-removed">824      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-removed">825      * @param value the double value to be written.</span>
<span class="line-removed">826      */</span>
<span class="line-removed">827     public static void setDouble(MemoryAddress addr, long offset, double value) {</span>
<span class="line-removed">828         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(addr, offset, value);</span>
<span class="line-removed">829     }</span>
<span class="line-removed">830 </span>
<span class="line-removed">831     private static VarHandle indexedHandle(MemoryLayout elementLayout, Class&lt;?&gt; carrier) {</span>
<span class="line-removed">832         return MemoryHandles.withStride(elementLayout.withBitAlignment(8).varHandle(carrier), 1L);</span>
<span class="line-removed">833     }</span>
834 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
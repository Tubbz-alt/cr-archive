<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.incubator.foreign;
 28 
 29 import java.lang.invoke.VarHandle;
 30 import java.nio.ByteOrder;
 31 
 32 /**
 33  * This class defines useful layout constants. Some of the constants defined in this class are explicit in both
 34  * size and byte order (see {@link #BITS_64_BE}), and can therefore be used to explicitly and unambiguously specify the
 35  * contents of a memory segment. Other constants make implicit byte order assumptions (see
 36  * {@link #JAVA_INT}); as such, these constants make it easy to work with other serialization-centric APIs,
 37  * such as {@link java.nio.ByteBuffer}.
 38  */
 39 public final class MemoryLayouts {
 40 
 41     private MemoryLayouts() {
 42         //just the one, please
 43     }
 44 
 45     /**
 46      * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 47      */
 48     public static final ValueLayout BITS_8_LE = MemoryLayout.ofValueBits(8, ByteOrder.LITTLE_ENDIAN);
 49 
 50     /**
 51      * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 52      */
 53     public static final ValueLayout BITS_16_LE = MemoryLayout.ofValueBits(16, ByteOrder.LITTLE_ENDIAN);
 54 
 55     /**
 56      * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 57      */
 58     public static final ValueLayout BITS_32_LE = MemoryLayout.ofValueBits(32, ByteOrder.LITTLE_ENDIAN);
 59 
 60     /**
 61      * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 62      */
 63     public static final ValueLayout BITS_64_LE = MemoryLayout.ofValueBits(64, ByteOrder.LITTLE_ENDIAN);
 64 
 65     private static final VarHandle byte_LE_handle = indexedHandle(BITS_8_LE, byte.class);
 66     private static final VarHandle char_LE_handle = indexedHandle(BITS_16_LE, char.class);
 67     private static final VarHandle short_LE_handle = indexedHandle(BITS_16_LE, short.class);
 68     private static final VarHandle int_LE_handle = indexedHandle(BITS_32_LE, int.class);
 69     private static final VarHandle float_LE_handle = indexedHandle(BITS_32_LE, float.class);
 70     private static final VarHandle long_LE_handle = indexedHandle(BITS_64_LE, long.class);
 71     private static final VarHandle double_LE_handle = indexedHandle(BITS_64_LE, double.class);
 72 
 73     /**
 74      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 75      * &lt;p&gt;
 76      * This is equivalent to the following code:
 77      * &lt;blockquote&gt;&lt;pre&gt;{@code
 78     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);
 79     byte value = (byte)handle.get(addr, offset);
 80      * }&lt;/pre&gt;&lt;/blockquote&gt;
 81      *
 82      * @param addr base address.
 83      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
 84      * @return a byte value read from {@code addr} at the offset specified by {@code index}.
 85      */
 86     public static byte getByte_LE(MemoryAddress addr, long offset) {
 87         return (byte)byte_LE_handle.get(addr, offset);
 88     }
 89 
 90     /**
 91      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 92      * &lt;p&gt;
 93      * This is equivalent to the following code:
 94      * &lt;blockquote&gt;&lt;pre&gt;{@code
 95     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);
 96     handle.set(addr, offset, value);
 97      * }&lt;/pre&gt;&lt;/blockquote&gt;
 98      * @param addr base address.
 99      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
100      * @param value the byte value to be written.
101      */
102     public static void setByte_LE(MemoryAddress addr, long offset, byte value) {
103         byte_LE_handle.set(addr, offset, value);
104     }
105 
106     /**
107      * Read a char from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
108      * &lt;p&gt;
109      * This is equivalent to the following code:
110      * &lt;blockquote&gt;&lt;pre&gt;{@code
111     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);
112     char value = (char)handle.get(addr, offset);
113      * }&lt;/pre&gt;&lt;/blockquote&gt;
114      * @param addr base address.
115      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
116      * @return a char value read from {@code addr} at the offset specified by {@code index}.
117      */
118     public static char getChar_LE(MemoryAddress addr, long offset) {
119         return (char)char_LE_handle.get(addr, offset);
120     }
121 
122     /**
123      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
124      * &lt;p&gt;
125      * This is equivalent to the following code:
126      * &lt;blockquote&gt;&lt;pre&gt;{@code
127     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);
128     handle.set(addr, offset, value);
129      * }&lt;/pre&gt;&lt;/blockquote&gt;
130      * @param addr base address.
131      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
132      * @param value the char value to be written.
133      */
134     public static void setChar_LE(MemoryAddress addr, long offset, char value) {
135         char_LE_handle.set(addr, offset, value);
136     }
137 
138     /**
139      * Read a short from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
140      * &lt;p&gt;
141      * This is equivalent to the following code:
142      * &lt;blockquote&gt;&lt;pre&gt;{@code
143     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);
144     short value = (short)handle.get(addr, offset);
145      * }&lt;/pre&gt;&lt;/blockquote&gt;
146      * @param addr base address.
147      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
148      * @return a short value read from {@code addr} at the offset specified by {@code index}.
149      */
150     public static short getShort_LE(MemoryAddress addr, long offset) {
151         return (short)short_LE_handle.get(addr, offset);
152     }
153 
154     /**
155      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
156      * &lt;p&gt;
157      * This is equivalent to the following code:
158      * &lt;blockquote&gt;&lt;pre&gt;{@code
159     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);
160     handle.set(addr, offset, value);
161      * }&lt;/pre&gt;&lt;/blockquote&gt;
162      * @param addr base address.
163      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
164      * @param value the short value to be written.
165      */
166     public static void setShort_LE(MemoryAddress addr, long offset, short value) {
167         short_LE_handle.set(addr, offset, value);
168     }
169 
170     /**
171      * Read an int from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
172      * &lt;p&gt;
173      * This is equivalent to the following code:
174      * &lt;blockquote&gt;&lt;pre&gt;{@code
175     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);
176     int value = (int)handle.get(addr, offset);
177      * }&lt;/pre&gt;&lt;/blockquote&gt;
178      * @param addr base address.
179      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
180      * @return an int value read from {@code addr} at the offset specified by {@code index}.
181      */
182     public static int getInt_LE(MemoryAddress addr, long offset) {
183         return (int)int_LE_handle.get(addr, offset);
184     }
185 
186     /**
187      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
188      * &lt;p&gt;
189      * This is equivalent to the following code:
190      * &lt;blockquote&gt;&lt;pre&gt;{@code
191     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);
192     handle.set(addr, offset, value);
193      * }&lt;/pre&gt;&lt;/blockquote&gt;
194      * @param addr base address.
195      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
196      * @param value the int value to be written.
197      */
198     public static void setInt_LE(MemoryAddress addr, long offset, int value) {
199         int_LE_handle.set(addr, offset, value);
200     }
201 
202     /**
203      * Read a float from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
204      * &lt;p&gt;
205      * This is equivalent to the following code:
206      * &lt;blockquote&gt;&lt;pre&gt;{@code
207     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);
208     float value = (float)handle.get(addr, offset);
209      * }&lt;/pre&gt;&lt;/blockquote&gt;
210      * @param addr base address.
211      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
212      * @return a float value read from {@code addr} at the offset specified by {@code index}.
213      */
214     public static float getFloat_LE(MemoryAddress addr, long offset) {
215         return (float)float_LE_handle.get(addr, offset);
216     }
217 
218     /**
219      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
220      * &lt;p&gt;
221      * This is equivalent to the following code:
222      * &lt;blockquote&gt;&lt;pre&gt;{@code
223     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);
224     handle.set(addr, offset, value);
225      * }&lt;/pre&gt;&lt;/blockquote&gt;
226      * @param addr base address.
227      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
228      * @param value the float value to be written.
229      */
230     public static void setFloat_LE(MemoryAddress addr, long offset, float value) {
231         float_LE_handle.set(addr, offset, value);
232     }
233 
234     /**
235      * Read a long from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
236      * &lt;p&gt;
237      * This is equivalent to the following code:
238      * &lt;blockquote&gt;&lt;pre&gt;{@code
239     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);
240     long value = (long)handle.get(addr, offset);
241      * }&lt;/pre&gt;&lt;/blockquote&gt;
242      * @param addr base address.
243      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
244      * @return a long value read from {@code addr} at the offset specified by {@code index}.
245      */
246     public static long getLong_LE(MemoryAddress addr, long offset) {
247         return (long)long_LE_handle.get(addr, offset);
248     }
249 
250     /**
251      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
252      * &lt;p&gt;
253      * This is equivalent to the following code:
254      * &lt;blockquote&gt;&lt;pre&gt;{@code
255     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);
256     handle.set(addr, offset, value);
257      * }&lt;/pre&gt;&lt;/blockquote&gt;
258      * @param addr base address.
259      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
260      * @param value the long value to be written.
261      */
262     public static void setLong_LE(MemoryAddress addr, long offset, long value) {
263         long_LE_handle.set(addr, offset, value);
264     }
265 
266     /**
267      * Read a double from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
268      * &lt;p&gt;
269      * This is equivalent to the following code:
270      * &lt;blockquote&gt;&lt;pre&gt;{@code
271     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(double.class), 1L);
272     double value = (double)handle.get(addr, offset);
273      * }&lt;/pre&gt;&lt;/blockquote&gt;
274      * @param addr base address.
275      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
276      * @return a double value read from {@code addr} at the offset specified by {@code index}.
277      */
278     public static double getDouble_LE(MemoryAddress addr, long offset) {
279         return (double)double_LE_handle.get(addr, offset);
280     }
281 
282     /**
283      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
284      * &lt;p&gt;
285      * This is equivalent to the following code:
286      * &lt;blockquote&gt;&lt;pre&gt;{@code
287     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);
288     handle.set(addr, offset, value);
289      * }&lt;/pre&gt;&lt;/blockquote&gt;
290      * @param addr base address.
291      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
292      * @param value the double value to be written.
293      */
294     public static void setDouble_LE(MemoryAddress addr, long offset, double value) {
295         double_LE_handle.set(addr, offset, value);
296     }
297 
298     /**
299      * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
300      */
301     public static final ValueLayout BITS_8_BE = MemoryLayout.ofValueBits(8, ByteOrder.BIG_ENDIAN);
302 
303     /**
304      * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
305      */
306     public static final ValueLayout BITS_16_BE = MemoryLayout.ofValueBits(16, ByteOrder.BIG_ENDIAN);
307 
308     /**
309      * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
310      */
311     public static final ValueLayout BITS_32_BE = MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN);
312 
313     /**
314      * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
315      */
316     public static final ValueLayout BITS_64_BE = MemoryLayout.ofValueBits(64, ByteOrder.BIG_ENDIAN);
317 
318     private static final VarHandle byte_BE_handle = indexedHandle(BITS_8_BE, byte.class);
319     private static final VarHandle char_BE_handle = indexedHandle(BITS_16_BE, char.class);
320     private static final VarHandle short_BE_handle = indexedHandle(BITS_16_BE, short.class);
321     private static final VarHandle int_BE_handle = indexedHandle(BITS_32_BE, int.class);
322     private static final VarHandle float_BE_handle = indexedHandle(BITS_32_BE, float.class);
323     private static final VarHandle long_BE_handle = indexedHandle(BITS_64_BE, long.class);
324     private static final VarHandle double_BE_handle = indexedHandle(BITS_64_BE, double.class);
325 
326     /**
327      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
328      * &lt;p&gt;
329      * This is equivalent to the following code:
330      * &lt;blockquote&gt;&lt;pre&gt;{@code
331     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);
332     byte value = (byte)handle.get(addr, offset);
333      * }&lt;/pre&gt;&lt;/blockquote&gt;
334      *
335      * @param addr base address.
336      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
337      * @return a byte value read from {@code addr} at the offset specified by {@code index}.
338      */
339     public static byte getByte_BE(MemoryAddress addr, long offset) {
340         return (byte)byte_BE_handle.get(addr, offset);
341     }
342 
343     /**
344      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
345      * &lt;p&gt;
346      * This is equivalent to the following code:
347      * &lt;blockquote&gt;&lt;pre&gt;{@code
348     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);
349     handle.set(addr, offset, value);
350      * }&lt;/pre&gt;&lt;/blockquote&gt;
351      * @param addr base address.
352      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
353      * @param value the byte value to be written.
354      */
355     public static void setByte_BE(MemoryAddress addr, long offset, byte value) {
356         byte_BE_handle.set(addr, offset, value);
357     }
358 
359     /**
360      * Read a char from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
361      * &lt;p&gt;
362      * This is equivalent to the following code:
363      * &lt;blockquote&gt;&lt;pre&gt;{@code
364     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);
365     char value = (char)handle.get(addr, offset);
366      * }&lt;/pre&gt;&lt;/blockquote&gt;
367      * @param addr base address.
368      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
369      * @return a char value read from {@code addr} at the offset specified by {@code index}.
370      */
371     public static char getChar_BE(MemoryAddress addr, long offset) {
372         return (char)char_BE_handle.get(addr, offset);
373     }
374 
375     /**
376      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
377      * &lt;p&gt;
378      * This is equivalent to the following code:
379      * &lt;blockquote&gt;&lt;pre&gt;{@code
380     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);
381     handle.set(addr, offset, value);
382      * }&lt;/pre&gt;&lt;/blockquote&gt;
383      * @param addr base address.
384      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
385      * @param value the char value to be written.
386      */
387     public static void setChar_BE(MemoryAddress addr, long offset, char value) {
388         char_BE_handle.set(addr, offset, value);
389     }
390 
391     /**
392      * Read a short from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
393      * &lt;p&gt;
394      * This is equivalent to the following code:
395      * &lt;blockquote&gt;&lt;pre&gt;{@code
396     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);
397     short value = (short)handle.get(addr, offset);
398      * }&lt;/pre&gt;&lt;/blockquote&gt;
399      * @param addr base address.
400      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
401      * @return a short value read from {@code addr} at the offset specified by {@code index}.
402      */
403     public static short getShort_BE(MemoryAddress addr, long offset) {
404         return (short)short_BE_handle.get(addr, offset);
405     }
406 
407     /**
408      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
409      * &lt;p&gt;
410      * This is equivalent to the following code:
411      * &lt;blockquote&gt;&lt;pre&gt;{@code
412     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);
413     handle.set(addr, offset, value);
414      * }&lt;/pre&gt;&lt;/blockquote&gt;
415      * @param addr base address.
416      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
417      * @param value the short value to be written.
418      */
419     public static void setShort_BE(MemoryAddress addr, long offset, short value) {
420         short_BE_handle.set(addr, offset, value);
421     }
422 
423     /**
424      * Read an int from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
425      * &lt;p&gt;
426      * This is equivalent to the following code:
427      * &lt;blockquote&gt;&lt;pre&gt;{@code
428     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);
429     int value = (int)handle.get(addr, offset);
430      * }&lt;/pre&gt;&lt;/blockquote&gt;
431      * @param addr base address.
432      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
433      * @return an int value read from {@code addr} at the offset specified by {@code index}.
434      */
435     public static int getInt_BE(MemoryAddress addr, long offset) {
436         return (int)int_BE_handle.get(addr, offset);
437     }
438 
439     /**
440      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
441      * &lt;p&gt;
442      * This is equivalent to the following code:
443      * &lt;blockquote&gt;&lt;pre&gt;{@code
444     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);
445     handle.set(addr, offset, value);
446      * }&lt;/pre&gt;&lt;/blockquote&gt;
447      * @param addr base address.
448      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
449      * @param value the int value to be written.
450      */
451     public static void setInt_BE(MemoryAddress addr, long offset, int value) {
452         int_BE_handle.set(addr, offset, value);
453     }
454 
455     /**
456      * Read a float from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
457      * &lt;p&gt;
458      * This is equivalent to the following code:
459      * &lt;blockquote&gt;&lt;pre&gt;{@code
460     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);
461     float value = (float)handle.get(addr, offset);
462      * }&lt;/pre&gt;&lt;/blockquote&gt;
463      * @param addr base address.
464      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
465      * @return a float value read from {@code addr} at the offset specified by {@code index}.
466      */
467     public static float getFloat_BE(MemoryAddress addr, long offset) {
468         return (float)float_BE_handle.get(addr, offset);
469     }
470 
471     /**
472      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
473      * &lt;p&gt;
474      * This is equivalent to the following code:
475      * &lt;blockquote&gt;&lt;pre&gt;{@code
476     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);
477     handle.set(addr, offset, value);
478      * }&lt;/pre&gt;&lt;/blockquote&gt;
479      * @param addr base address.
480      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
481      * @param value the float value to be written.
482      */
483     public static void setFloat_BE(MemoryAddress addr, long offset, float value) {
484         float_BE_handle.set(addr, offset, value);
485     }
486 
487     /**
488      * Read a long from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
489      * &lt;p&gt;
490      * This is equivalent to the following code:
491      * &lt;blockquote&gt;&lt;pre&gt;{@code
492     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);
493     long value = (long)handle.get(addr, offset);
494      * }&lt;/pre&gt;&lt;/blockquote&gt;
495      * @param addr base address.
496      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
497      * @return a long value read from {@code addr} at the offset specified by {@code index}.
498      */
499     public static long getLong_BE(MemoryAddress addr, long offset) {
500         return (long)long_BE_handle.get(addr, offset);
501     }
502 
503     /**
504      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
505      * &lt;p&gt;
506      * This is equivalent to the following code:
507      * &lt;blockquote&gt;&lt;pre&gt;{@code
508     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);
509     handle.set(addr, offset, value);
510      * }&lt;/pre&gt;&lt;/blockquote&gt;
511      * @param addr base address.
512      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
513      * @param value the long value to be written.
514      */
515     public static void setLong_BE(MemoryAddress addr, long offset, long value) {
516         long_BE_handle.set(addr, offset, value);
517     }
518 
519     /**
520      * Read a double from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
521      * &lt;p&gt;
522      * This is equivalent to the following code:
523      * &lt;blockquote&gt;&lt;pre&gt;{@code
524     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(double.class), 1L);
525     double value = (double)handle.get(addr, offset);
526      * }&lt;/pre&gt;&lt;/blockquote&gt;
527      * @param addr base address.
528      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
529      * @return a double value read from {@code addr} at the offset specified by {@code index}.
530      */
531     public static double getDouble_BE(MemoryAddress addr, long offset) {
532         return (double)double_BE_handle.get(addr, offset);
533     }
534 
535     /**
536      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
537      * &lt;p&gt;
538      * This is equivalent to the following code:
539      * &lt;blockquote&gt;&lt;pre&gt;{@code
540     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);
541     handle.set(addr, offset, value);
542      * }&lt;/pre&gt;&lt;/blockquote&gt;
543      * @param addr base address.
544      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
545      * @param value the double value to be written.
546      */
547     public static void setDouble_BE(MemoryAddress addr, long offset, double value) {
548         double_BE_handle.set(addr, offset, value);
549     }
550 
551     /**
552      * A padding layout constant with size of one byte.
553      */
554     public static final MemoryLayout PAD_8 = MemoryLayout.ofPaddingBits(8);
555 
556     /**
557      * A padding layout constant with size of two bytes.
558      */
559     public static final MemoryLayout PAD_16 = MemoryLayout.ofPaddingBits(16);
560 
561     /**
562      * A padding layout constant with size of four bytes.
563      */
564     public static final MemoryLayout PAD_32 = MemoryLayout.ofPaddingBits(32);
565 
566     /**
567      * A padding layout constant with size of eight bytes.
568      */
569     public static final MemoryLayout PAD_64 = MemoryLayout.ofPaddingBits(64);
570 
571     /**
572      * A value layout constant whose size is the same as that of a Java {@code byte}, and byte order set to {@link ByteOrder#nativeOrder()}.
573      */
574     public static final ValueLayout JAVA_BYTE = MemoryLayout.ofValueBits(8, ByteOrder.nativeOrder());
575 
576     /**
577      * A value layout constant whose size is the same as that of a Java {@code char}, and byte order set to {@link ByteOrder#nativeOrder()}.
578      */
579     public static final ValueLayout JAVA_CHAR = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder());
580 
581     /**
582      * A value layout constant whose size is the same as that of a Java {@code short}, and byte order set to {@link ByteOrder#nativeOrder()}.
583      */
584     public static final ValueLayout JAVA_SHORT = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder());
585 
586     /**
587      * A value layout constant whose size is the same as that of a Java {@code int}, and byte order set to {@link ByteOrder#nativeOrder()}.
588      */
589     public static final ValueLayout JAVA_INT = MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder());
590 
591     /**
592      * A value layout constant whose size is the same as that of a Java {@code long}, and byte order set to {@link ByteOrder#nativeOrder()}.
593      */
594     public static final ValueLayout JAVA_LONG = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());
595 
596     /**
597      * A value layout constant whose size is the same as that of a Java {@code float}, and byte order set to {@link ByteOrder#nativeOrder()}.
598      */
599     public static final ValueLayout JAVA_FLOAT = MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder());
600 
601     /**
602      * A value layout constant whose size is the same as that of a Java {@code double}, and byte order set to {@link ByteOrder#nativeOrder()}.
603      */
604     public static final ValueLayout JAVA_DOUBLE = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());
605 
606     /**
607      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
608      * &lt;p&gt;
609      * This is equivalent to the following code:
610      * &lt;blockquote&gt;&lt;pre&gt;{@code
611     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);
612     byte value = (byte)handle.get(addr, offset);
613      * }&lt;/pre&gt;&lt;/blockquote&gt;
614      *
615      * @param addr base address.
616      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
617      * @return a byte value read from {@code addr} at the offset specified by {@code index}.
618      */
619     public static byte getByte(MemoryAddress addr, long offset) {
620         return (byte)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).get(addr, offset);
621     }
622 
623     /**
624      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
625      * &lt;p&gt;
626      * This is equivalent to the following code:
627      * &lt;blockquote&gt;&lt;pre&gt;{@code
628     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);
629     handle.set(addr, offset, value);
630      * }&lt;/pre&gt;&lt;/blockquote&gt;
631      * @param addr base address.
632      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
633      * @param value the byte value to be written.
634      */
635     public static void setByte(MemoryAddress addr, long offset, byte value) {
636         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).set(addr, offset, value);
637     }
638 
639     /**
640      * Read a char from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
641      * &lt;p&gt;
642      * This is equivalent to the following code:
643      * &lt;blockquote&gt;&lt;pre&gt;{@code
644     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);
645     char value = (char)handle.get(addr, offset);
646      * }&lt;/pre&gt;&lt;/blockquote&gt;
647      * @param addr base address.
648      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
649      * @return a char value read from {@code addr} at the offset specified by {@code index}.
650      */
651     public static char getChar(MemoryAddress addr, long offset) {
652         return (char)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(addr, offset);
653     }
654 
655     /**
656      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
657      * &lt;p&gt;
658      * This is equivalent to the following code:
659      * &lt;blockquote&gt;&lt;pre&gt;{@code
660     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);
661     handle.set(addr, offset, value);
662      * }&lt;/pre&gt;&lt;/blockquote&gt;
663      * @param addr base address.
664      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
665      * @param value the char value to be written.
666      */
667     public static void setChar(MemoryAddress addr, long offset, char value) {
668         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(addr, offset, value);
669     }
670 
671     /**
672      * Read a short from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
673      * &lt;p&gt;
674      * This is equivalent to the following code:
675      * &lt;blockquote&gt;&lt;pre&gt;{@code
676     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);
677     short value = (short)handle.get(addr, offset);
678      * }&lt;/pre&gt;&lt;/blockquote&gt;
679      * @param addr base address.
680      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
681      * @return a short value read from {@code addr} at the offset specified by {@code index}.
682      */
683     public static short getShort(MemoryAddress addr, long offset) {
684         return (short)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(addr, offset);
685     }
686 
687     /**
688      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
689      * &lt;p&gt;
690      * This is equivalent to the following code:
691      * &lt;blockquote&gt;&lt;pre&gt;{@code
692     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);
693     handle.set(addr, offset, value);
694      * }&lt;/pre&gt;&lt;/blockquote&gt;
695      * @param addr base address.
696      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
697      * @param value the short value to be written.
698      */
699     public static void setShort(MemoryAddress addr, long offset, short value) {
700         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(addr, offset, value);
701     }
702 
703     /**
704      * Read an int from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
705      * &lt;p&gt;
706      * This is equivalent to the following code:
707      * &lt;blockquote&gt;&lt;pre&gt;{@code
708     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);
709     int value = (int)handle.get(addr, offset);
710      * }&lt;/pre&gt;&lt;/blockquote&gt;
711      * @param addr base address.
712      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
713      * @return an int value read from {@code addr} at the offset specified by {@code index}.
714      */
715     public static int getInt(MemoryAddress addr, long offset) {
716         return (int)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(addr, offset);
717     }
718 
719     /**
720      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
721      * &lt;p&gt;
722      * This is equivalent to the following code:
723      * &lt;blockquote&gt;&lt;pre&gt;{@code
724     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);
725     handle.set(addr, offset, value);
726      * }&lt;/pre&gt;&lt;/blockquote&gt;
727      * @param addr base address.
728      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
729      * @param value the int value to be written.
730      */
731     public static void setInt(MemoryAddress addr, long offset, int value) {
732         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(addr, offset, value);
733     }
734 
735     /**
736      * Read a float from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
737      * &lt;p&gt;
738      * This is equivalent to the following code:
739      * &lt;blockquote&gt;&lt;pre&gt;{@code
740     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);
741     float value = (float)handle.get(addr, offset);
742      * }&lt;/pre&gt;&lt;/blockquote&gt;
743      * @param addr base address.
744      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
745      * @return a float value read from {@code addr} at the offset specified by {@code index}.
746      */
747     public static float getFloat(MemoryAddress addr, long offset) {
748         return (float)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(addr, offset);
749     }
750 
751     /**
752      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
753      * &lt;p&gt;
754      * This is equivalent to the following code:
755      * &lt;blockquote&gt;&lt;pre&gt;{@code
756     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);
757     handle.set(addr, offset, value);
758      * }&lt;/pre&gt;&lt;/blockquote&gt;
759      * @param addr base address.
760      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
761      * @param value the float value to be written.
762      */
763     public static void setFloat(MemoryAddress addr, long offset, float value) {
764         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(addr, offset, value);
765     }
766 
767     /**
768      * Read a long from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
769      * &lt;p&gt;
770      * This is equivalent to the following code:
771      * &lt;blockquote&gt;&lt;pre&gt;{@code
772     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);
773     long value = (long)handle.get(addr, offset);
774      * }&lt;/pre&gt;&lt;/blockquote&gt;
775      * @param addr base address.
776      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
777      * @return a long value read from {@code addr} at the offset specified by {@code index}.
778      */
779     public static long getLong(MemoryAddress addr, long offset) {
780         return (long)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(addr, offset);
781     }
782 
783     /**
784      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
785      * &lt;p&gt;
786      * This is equivalent to the following code:
787      * &lt;blockquote&gt;&lt;pre&gt;{@code
788     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);
789     handle.set(addr, offset, value);
790      * }&lt;/pre&gt;&lt;/blockquote&gt;
791      * @param addr base address.
792      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
793      * @param value the long value to be written.
794      */
795     public static void setLong(MemoryAddress addr, long offset, long value) {
796         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(addr, offset, value);
797     }
798 
799     /**
800      * Read a double from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
801      * &lt;p&gt;
802      * This is equivalent to the following code:
803      * &lt;blockquote&gt;&lt;pre&gt;{@code
804     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);
805     double value = (double)handle.get(addr, offset);
806      * }&lt;/pre&gt;&lt;/blockquote&gt;
807      * @param addr base address.
808      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
809      * @return a double value read from {@code addr} at the offset specified by {@code index}.
810      */
811     public static double getDouble(MemoryAddress addr, long offset) {
812         return (double)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(addr, offset);
813     }
814 
815     /**
816      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
817      * &lt;p&gt;
818      * This is equivalent to the following code:
819      * &lt;blockquote&gt;&lt;pre&gt;{@code
820     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);
821     handle.set(addr, offset, value);
822      * }&lt;/pre&gt;&lt;/blockquote&gt;
823      * @param addr base address.
824      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
825      * @param value the double value to be written.
826      */
827     public static void setDouble(MemoryAddress addr, long offset, double value) {
828         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(addr, offset, value);
829     }
830 
831     private static VarHandle indexedHandle(MemoryLayout elementLayout, Class&lt;?&gt; carrier) {
832         return MemoryHandles.withStride(elementLayout.withBitAlignment(8).varHandle(carrier), 1L);
833     }
834 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemorySegment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.incubator.foreign;
 28 

 29 import java.nio.ByteOrder;
 30 
 31 /**
 32  * This class defines useful layout constants. Some of the constants defined in this class are explicit in both
 33  * size and byte order (see {@link #BITS_64_BE}), and can therefore be used to explicitly and unambiguously specify the
 34  * contents of a memory segment. Other constants make implicit byte order assumptions (see
 35  * {@link #JAVA_INT}); as such, these constants make it easy to work with other serialization-centric APIs,
 36  * such as {@link java.nio.ByteBuffer}.
 37  */
 38 public final class MemoryLayouts {
 39 
 40     private MemoryLayouts() {
 41         //just the one, please
 42     }
 43 
 44     /**
 45      * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 46      */
 47     public static final ValueLayout BITS_8_LE = MemoryLayout.ofValueBits(8, ByteOrder.LITTLE_ENDIAN);
 48 
 49     /**
 50      * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 51      */
 52     public static final ValueLayout BITS_16_LE = MemoryLayout.ofValueBits(16, ByteOrder.LITTLE_ENDIAN);
 53 
 54     /**
 55      * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 56      */
 57     public static final ValueLayout BITS_32_LE = MemoryLayout.ofValueBits(32, ByteOrder.LITTLE_ENDIAN);
 58 
 59     /**
 60      * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 61      */
 62     public static final ValueLayout BITS_64_LE = MemoryLayout.ofValueBits(64, ByteOrder.LITTLE_ENDIAN);
 63 









































































































































































































































 64     /**
 65      * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
 66      */
 67     public static final ValueLayout BITS_8_BE = MemoryLayout.ofValueBits(8, ByteOrder.BIG_ENDIAN);
 68 
 69     /**
 70      * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
 71      */
 72     public static final ValueLayout BITS_16_BE = MemoryLayout.ofValueBits(16, ByteOrder.BIG_ENDIAN);
 73 
 74     /**
 75      * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
 76      */
 77     public static final ValueLayout BITS_32_BE = MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN);
 78 
 79     /**
 80      * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
 81      */
 82     public static final ValueLayout BITS_64_BE = MemoryLayout.ofValueBits(64, ByteOrder.BIG_ENDIAN);
 83 









































































































































































































































 84     /**
 85      * A padding layout constant with size of one byte.
 86      */
 87     public static final MemoryLayout PAD_8 = MemoryLayout.ofPaddingBits(8);
 88 
 89     /**
 90      * A padding layout constant with size of two bytes.
 91      */
 92     public static final MemoryLayout PAD_16 = MemoryLayout.ofPaddingBits(16);
 93 
 94     /**
 95      * A padding layout constant with size of four bytes.
 96      */
 97     public static final MemoryLayout PAD_32 = MemoryLayout.ofPaddingBits(32);
 98 
 99     /**
100      * A padding layout constant with size of eight bytes.
101      */
102     public static final MemoryLayout PAD_64 = MemoryLayout.ofPaddingBits(64);
103 
</pre>
<hr />
<pre>
118 
119     /**
120      * A value layout constant whose size is the same as that of a Java {@code int}, and byte order set to {@link ByteOrder#nativeOrder()}.
121      */
122     public static final ValueLayout JAVA_INT = MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder());
123 
124     /**
125      * A value layout constant whose size is the same as that of a Java {@code long}, and byte order set to {@link ByteOrder#nativeOrder()}.
126      */
127     public static final ValueLayout JAVA_LONG = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());
128 
129     /**
130      * A value layout constant whose size is the same as that of a Java {@code float}, and byte order set to {@link ByteOrder#nativeOrder()}.
131      */
132     public static final ValueLayout JAVA_FLOAT = MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder());
133 
134     /**
135      * A value layout constant whose size is the same as that of a Java {@code double}, and byte order set to {@link ByteOrder#nativeOrder()}.
136      */
137     public static final ValueLayout JAVA_DOUBLE = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());





































































































































































































































138 }
</pre>
</td>
<td>
<hr />
<pre>
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.incubator.foreign;
 28 
<span class="line-added"> 29 import java.lang.invoke.VarHandle;</span>
 30 import java.nio.ByteOrder;
 31 
 32 /**
 33  * This class defines useful layout constants. Some of the constants defined in this class are explicit in both
 34  * size and byte order (see {@link #BITS_64_BE}), and can therefore be used to explicitly and unambiguously specify the
 35  * contents of a memory segment. Other constants make implicit byte order assumptions (see
 36  * {@link #JAVA_INT}); as such, these constants make it easy to work with other serialization-centric APIs,
 37  * such as {@link java.nio.ByteBuffer}.
 38  */
 39 public final class MemoryLayouts {
 40 
 41     private MemoryLayouts() {
 42         //just the one, please
 43     }
 44 
 45     /**
 46      * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 47      */
 48     public static final ValueLayout BITS_8_LE = MemoryLayout.ofValueBits(8, ByteOrder.LITTLE_ENDIAN);
 49 
 50     /**
 51      * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 52      */
 53     public static final ValueLayout BITS_16_LE = MemoryLayout.ofValueBits(16, ByteOrder.LITTLE_ENDIAN);
 54 
 55     /**
 56      * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 57      */
 58     public static final ValueLayout BITS_32_LE = MemoryLayout.ofValueBits(32, ByteOrder.LITTLE_ENDIAN);
 59 
 60     /**
 61      * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
 62      */
 63     public static final ValueLayout BITS_64_LE = MemoryLayout.ofValueBits(64, ByteOrder.LITTLE_ENDIAN);
 64 
<span class="line-added"> 65     private static final VarHandle byte_LE_handle = indexedHandle(BITS_8_LE, byte.class);</span>
<span class="line-added"> 66     private static final VarHandle char_LE_handle = indexedHandle(BITS_16_LE, char.class);</span>
<span class="line-added"> 67     private static final VarHandle short_LE_handle = indexedHandle(BITS_16_LE, short.class);</span>
<span class="line-added"> 68     private static final VarHandle int_LE_handle = indexedHandle(BITS_32_LE, int.class);</span>
<span class="line-added"> 69     private static final VarHandle float_LE_handle = indexedHandle(BITS_32_LE, float.class);</span>
<span class="line-added"> 70     private static final VarHandle long_LE_handle = indexedHandle(BITS_64_LE, long.class);</span>
<span class="line-added"> 71     private static final VarHandle double_LE_handle = indexedHandle(BITS_64_LE, double.class);</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73     /**</span>
<span class="line-added"> 74      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added"> 75      * &lt;p&gt;</span>
<span class="line-added"> 76      * This is equivalent to the following code:</span>
<span class="line-added"> 77      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added"> 78     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-added"> 79     byte value = (byte)handle.get(addr, offset);</span>
<span class="line-added"> 80      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added"> 81      *</span>
<span class="line-added"> 82      * @param addr base address.</span>
<span class="line-added"> 83      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added"> 84      * @return a byte value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added"> 85      */</span>
<span class="line-added"> 86     public static byte getByte_LE(MemoryAddress addr, long offset) {</span>
<span class="line-added"> 87         return (byte)byte_LE_handle.get(addr, offset);</span>
<span class="line-added"> 88     }</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90     /**</span>
<span class="line-added"> 91      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added"> 92      * &lt;p&gt;</span>
<span class="line-added"> 93      * This is equivalent to the following code:</span>
<span class="line-added"> 94      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added"> 95     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-added"> 96     handle.set(addr, offset, value);</span>
<span class="line-added"> 97      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added"> 98      * @param addr base address.</span>
<span class="line-added"> 99      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">100      * @param value the byte value to be written.</span>
<span class="line-added">101      */</span>
<span class="line-added">102     public static void setByte_LE(MemoryAddress addr, long offset, byte value) {</span>
<span class="line-added">103         byte_LE_handle.set(addr, offset, value);</span>
<span class="line-added">104     }</span>
<span class="line-added">105 </span>
<span class="line-added">106     /**</span>
<span class="line-added">107      * Read a char from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">108      * &lt;p&gt;</span>
<span class="line-added">109      * This is equivalent to the following code:</span>
<span class="line-added">110      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">111     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-added">112     char value = (char)handle.get(addr, offset);</span>
<span class="line-added">113      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">114      * @param addr base address.</span>
<span class="line-added">115      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">116      * @return a char value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">117      */</span>
<span class="line-added">118     public static char getChar_LE(MemoryAddress addr, long offset) {</span>
<span class="line-added">119         return (char)char_LE_handle.get(addr, offset);</span>
<span class="line-added">120     }</span>
<span class="line-added">121 </span>
<span class="line-added">122     /**</span>
<span class="line-added">123      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">124      * &lt;p&gt;</span>
<span class="line-added">125      * This is equivalent to the following code:</span>
<span class="line-added">126      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">127     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-added">128     handle.set(addr, offset, value);</span>
<span class="line-added">129      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">130      * @param addr base address.</span>
<span class="line-added">131      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">132      * @param value the char value to be written.</span>
<span class="line-added">133      */</span>
<span class="line-added">134     public static void setChar_LE(MemoryAddress addr, long offset, char value) {</span>
<span class="line-added">135         char_LE_handle.set(addr, offset, value);</span>
<span class="line-added">136     }</span>
<span class="line-added">137 </span>
<span class="line-added">138     /**</span>
<span class="line-added">139      * Read a short from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">140      * &lt;p&gt;</span>
<span class="line-added">141      * This is equivalent to the following code:</span>
<span class="line-added">142      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">143     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-added">144     short value = (short)handle.get(addr, offset);</span>
<span class="line-added">145      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">146      * @param addr base address.</span>
<span class="line-added">147      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">148      * @return a short value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">149      */</span>
<span class="line-added">150     public static short getShort_LE(MemoryAddress addr, long offset) {</span>
<span class="line-added">151         return (short)short_LE_handle.get(addr, offset);</span>
<span class="line-added">152     }</span>
<span class="line-added">153 </span>
<span class="line-added">154     /**</span>
<span class="line-added">155      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">156      * &lt;p&gt;</span>
<span class="line-added">157      * This is equivalent to the following code:</span>
<span class="line-added">158      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">159     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-added">160     handle.set(addr, offset, value);</span>
<span class="line-added">161      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">162      * @param addr base address.</span>
<span class="line-added">163      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">164      * @param value the short value to be written.</span>
<span class="line-added">165      */</span>
<span class="line-added">166     public static void setShort_LE(MemoryAddress addr, long offset, short value) {</span>
<span class="line-added">167         short_LE_handle.set(addr, offset, value);</span>
<span class="line-added">168     }</span>
<span class="line-added">169 </span>
<span class="line-added">170     /**</span>
<span class="line-added">171      * Read an int from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">172      * &lt;p&gt;</span>
<span class="line-added">173      * This is equivalent to the following code:</span>
<span class="line-added">174      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">175     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-added">176     int value = (int)handle.get(addr, offset);</span>
<span class="line-added">177      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">178      * @param addr base address.</span>
<span class="line-added">179      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">180      * @return an int value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">181      */</span>
<span class="line-added">182     public static int getInt_LE(MemoryAddress addr, long offset) {</span>
<span class="line-added">183         return (int)int_LE_handle.get(addr, offset);</span>
<span class="line-added">184     }</span>
<span class="line-added">185 </span>
<span class="line-added">186     /**</span>
<span class="line-added">187      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">188      * &lt;p&gt;</span>
<span class="line-added">189      * This is equivalent to the following code:</span>
<span class="line-added">190      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">191     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-added">192     handle.set(addr, offset, value);</span>
<span class="line-added">193      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">194      * @param addr base address.</span>
<span class="line-added">195      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">196      * @param value the int value to be written.</span>
<span class="line-added">197      */</span>
<span class="line-added">198     public static void setInt_LE(MemoryAddress addr, long offset, int value) {</span>
<span class="line-added">199         int_LE_handle.set(addr, offset, value);</span>
<span class="line-added">200     }</span>
<span class="line-added">201 </span>
<span class="line-added">202     /**</span>
<span class="line-added">203      * Read a float from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">204      * &lt;p&gt;</span>
<span class="line-added">205      * This is equivalent to the following code:</span>
<span class="line-added">206      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">207     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-added">208     float value = (float)handle.get(addr, offset);</span>
<span class="line-added">209      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">210      * @param addr base address.</span>
<span class="line-added">211      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">212      * @return a float value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">213      */</span>
<span class="line-added">214     public static float getFloat_LE(MemoryAddress addr, long offset) {</span>
<span class="line-added">215         return (float)float_LE_handle.get(addr, offset);</span>
<span class="line-added">216     }</span>
<span class="line-added">217 </span>
<span class="line-added">218     /**</span>
<span class="line-added">219      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">220      * &lt;p&gt;</span>
<span class="line-added">221      * This is equivalent to the following code:</span>
<span class="line-added">222      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">223     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-added">224     handle.set(addr, offset, value);</span>
<span class="line-added">225      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">226      * @param addr base address.</span>
<span class="line-added">227      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">228      * @param value the float value to be written.</span>
<span class="line-added">229      */</span>
<span class="line-added">230     public static void setFloat_LE(MemoryAddress addr, long offset, float value) {</span>
<span class="line-added">231         float_LE_handle.set(addr, offset, value);</span>
<span class="line-added">232     }</span>
<span class="line-added">233 </span>
<span class="line-added">234     /**</span>
<span class="line-added">235      * Read a long from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">236      * &lt;p&gt;</span>
<span class="line-added">237      * This is equivalent to the following code:</span>
<span class="line-added">238      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">239     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-added">240     long value = (long)handle.get(addr, offset);</span>
<span class="line-added">241      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">242      * @param addr base address.</span>
<span class="line-added">243      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">244      * @return a long value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">245      */</span>
<span class="line-added">246     public static long getLong_LE(MemoryAddress addr, long offset) {</span>
<span class="line-added">247         return (long)long_LE_handle.get(addr, offset);</span>
<span class="line-added">248     }</span>
<span class="line-added">249 </span>
<span class="line-added">250     /**</span>
<span class="line-added">251      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">252      * &lt;p&gt;</span>
<span class="line-added">253      * This is equivalent to the following code:</span>
<span class="line-added">254      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">255     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-added">256     handle.set(addr, offset, value);</span>
<span class="line-added">257      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">258      * @param addr base address.</span>
<span class="line-added">259      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">260      * @param value the long value to be written.</span>
<span class="line-added">261      */</span>
<span class="line-added">262     public static void setLong_LE(MemoryAddress addr, long offset, long value) {</span>
<span class="line-added">263         long_LE_handle.set(addr, offset, value);</span>
<span class="line-added">264     }</span>
<span class="line-added">265 </span>
<span class="line-added">266     /**</span>
<span class="line-added">267      * Read a double from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">268      * &lt;p&gt;</span>
<span class="line-added">269      * This is equivalent to the following code:</span>
<span class="line-added">270      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">271     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-added">272     double value = (double)handle.get(addr, offset);</span>
<span class="line-added">273      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">274      * @param addr base address.</span>
<span class="line-added">275      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">276      * @return a double value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">277      */</span>
<span class="line-added">278     public static double getDouble_LE(MemoryAddress addr, long offset) {</span>
<span class="line-added">279         return (double)double_LE_handle.get(addr, offset);</span>
<span class="line-added">280     }</span>
<span class="line-added">281 </span>
<span class="line-added">282     /**</span>
<span class="line-added">283      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.</span>
<span class="line-added">284      * &lt;p&gt;</span>
<span class="line-added">285      * This is equivalent to the following code:</span>
<span class="line-added">286      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">287     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-added">288     handle.set(addr, offset, value);</span>
<span class="line-added">289      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">290      * @param addr base address.</span>
<span class="line-added">291      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">292      * @param value the double value to be written.</span>
<span class="line-added">293      */</span>
<span class="line-added">294     public static void setDouble_LE(MemoryAddress addr, long offset, double value) {</span>
<span class="line-added">295         double_LE_handle.set(addr, offset, value);</span>
<span class="line-added">296     }</span>
<span class="line-added">297 </span>
298     /**
299      * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
300      */
301     public static final ValueLayout BITS_8_BE = MemoryLayout.ofValueBits(8, ByteOrder.BIG_ENDIAN);
302 
303     /**
304      * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
305      */
306     public static final ValueLayout BITS_16_BE = MemoryLayout.ofValueBits(16, ByteOrder.BIG_ENDIAN);
307 
308     /**
309      * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
310      */
311     public static final ValueLayout BITS_32_BE = MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN);
312 
313     /**
314      * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
315      */
316     public static final ValueLayout BITS_64_BE = MemoryLayout.ofValueBits(64, ByteOrder.BIG_ENDIAN);
317 
<span class="line-added">318     private static final VarHandle byte_BE_handle = indexedHandle(BITS_8_BE, byte.class);</span>
<span class="line-added">319     private static final VarHandle char_BE_handle = indexedHandle(BITS_16_BE, char.class);</span>
<span class="line-added">320     private static final VarHandle short_BE_handle = indexedHandle(BITS_16_BE, short.class);</span>
<span class="line-added">321     private static final VarHandle int_BE_handle = indexedHandle(BITS_32_BE, int.class);</span>
<span class="line-added">322     private static final VarHandle float_BE_handle = indexedHandle(BITS_32_BE, float.class);</span>
<span class="line-added">323     private static final VarHandle long_BE_handle = indexedHandle(BITS_64_BE, long.class);</span>
<span class="line-added">324     private static final VarHandle double_BE_handle = indexedHandle(BITS_64_BE, double.class);</span>
<span class="line-added">325 </span>
<span class="line-added">326     /**</span>
<span class="line-added">327      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">328      * &lt;p&gt;</span>
<span class="line-added">329      * This is equivalent to the following code:</span>
<span class="line-added">330      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">331     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-added">332     byte value = (byte)handle.get(addr, offset);</span>
<span class="line-added">333      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">334      *</span>
<span class="line-added">335      * @param addr base address.</span>
<span class="line-added">336      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">337      * @return a byte value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">338      */</span>
<span class="line-added">339     public static byte getByte_BE(MemoryAddress addr, long offset) {</span>
<span class="line-added">340         return (byte)byte_BE_handle.get(addr, offset);</span>
<span class="line-added">341     }</span>
<span class="line-added">342 </span>
<span class="line-added">343     /**</span>
<span class="line-added">344      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">345      * &lt;p&gt;</span>
<span class="line-added">346      * This is equivalent to the following code:</span>
<span class="line-added">347      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">348     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-added">349     handle.set(addr, offset, value);</span>
<span class="line-added">350      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">351      * @param addr base address.</span>
<span class="line-added">352      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">353      * @param value the byte value to be written.</span>
<span class="line-added">354      */</span>
<span class="line-added">355     public static void setByte_BE(MemoryAddress addr, long offset, byte value) {</span>
<span class="line-added">356         byte_BE_handle.set(addr, offset, value);</span>
<span class="line-added">357     }</span>
<span class="line-added">358 </span>
<span class="line-added">359     /**</span>
<span class="line-added">360      * Read a char from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">361      * &lt;p&gt;</span>
<span class="line-added">362      * This is equivalent to the following code:</span>
<span class="line-added">363      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">364     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-added">365     char value = (char)handle.get(addr, offset);</span>
<span class="line-added">366      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">367      * @param addr base address.</span>
<span class="line-added">368      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">369      * @return a char value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">370      */</span>
<span class="line-added">371     public static char getChar_BE(MemoryAddress addr, long offset) {</span>
<span class="line-added">372         return (char)char_BE_handle.get(addr, offset);</span>
<span class="line-added">373     }</span>
<span class="line-added">374 </span>
<span class="line-added">375     /**</span>
<span class="line-added">376      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">377      * &lt;p&gt;</span>
<span class="line-added">378      * This is equivalent to the following code:</span>
<span class="line-added">379      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">380     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-added">381     handle.set(addr, offset, value);</span>
<span class="line-added">382      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">383      * @param addr base address.</span>
<span class="line-added">384      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">385      * @param value the char value to be written.</span>
<span class="line-added">386      */</span>
<span class="line-added">387     public static void setChar_BE(MemoryAddress addr, long offset, char value) {</span>
<span class="line-added">388         char_BE_handle.set(addr, offset, value);</span>
<span class="line-added">389     }</span>
<span class="line-added">390 </span>
<span class="line-added">391     /**</span>
<span class="line-added">392      * Read a short from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">393      * &lt;p&gt;</span>
<span class="line-added">394      * This is equivalent to the following code:</span>
<span class="line-added">395      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">396     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-added">397     short value = (short)handle.get(addr, offset);</span>
<span class="line-added">398      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">399      * @param addr base address.</span>
<span class="line-added">400      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">401      * @return a short value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">402      */</span>
<span class="line-added">403     public static short getShort_BE(MemoryAddress addr, long offset) {</span>
<span class="line-added">404         return (short)short_BE_handle.get(addr, offset);</span>
<span class="line-added">405     }</span>
<span class="line-added">406 </span>
<span class="line-added">407     /**</span>
<span class="line-added">408      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">409      * &lt;p&gt;</span>
<span class="line-added">410      * This is equivalent to the following code:</span>
<span class="line-added">411      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">412     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-added">413     handle.set(addr, offset, value);</span>
<span class="line-added">414      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">415      * @param addr base address.</span>
<span class="line-added">416      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">417      * @param value the short value to be written.</span>
<span class="line-added">418      */</span>
<span class="line-added">419     public static void setShort_BE(MemoryAddress addr, long offset, short value) {</span>
<span class="line-added">420         short_BE_handle.set(addr, offset, value);</span>
<span class="line-added">421     }</span>
<span class="line-added">422 </span>
<span class="line-added">423     /**</span>
<span class="line-added">424      * Read an int from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">425      * &lt;p&gt;</span>
<span class="line-added">426      * This is equivalent to the following code:</span>
<span class="line-added">427      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">428     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-added">429     int value = (int)handle.get(addr, offset);</span>
<span class="line-added">430      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">431      * @param addr base address.</span>
<span class="line-added">432      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">433      * @return an int value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">434      */</span>
<span class="line-added">435     public static int getInt_BE(MemoryAddress addr, long offset) {</span>
<span class="line-added">436         return (int)int_BE_handle.get(addr, offset);</span>
<span class="line-added">437     }</span>
<span class="line-added">438 </span>
<span class="line-added">439     /**</span>
<span class="line-added">440      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">441      * &lt;p&gt;</span>
<span class="line-added">442      * This is equivalent to the following code:</span>
<span class="line-added">443      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">444     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-added">445     handle.set(addr, offset, value);</span>
<span class="line-added">446      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">447      * @param addr base address.</span>
<span class="line-added">448      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">449      * @param value the int value to be written.</span>
<span class="line-added">450      */</span>
<span class="line-added">451     public static void setInt_BE(MemoryAddress addr, long offset, int value) {</span>
<span class="line-added">452         int_BE_handle.set(addr, offset, value);</span>
<span class="line-added">453     }</span>
<span class="line-added">454 </span>
<span class="line-added">455     /**</span>
<span class="line-added">456      * Read a float from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">457      * &lt;p&gt;</span>
<span class="line-added">458      * This is equivalent to the following code:</span>
<span class="line-added">459      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">460     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-added">461     float value = (float)handle.get(addr, offset);</span>
<span class="line-added">462      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">463      * @param addr base address.</span>
<span class="line-added">464      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">465      * @return a float value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">466      */</span>
<span class="line-added">467     public static float getFloat_BE(MemoryAddress addr, long offset) {</span>
<span class="line-added">468         return (float)float_BE_handle.get(addr, offset);</span>
<span class="line-added">469     }</span>
<span class="line-added">470 </span>
<span class="line-added">471     /**</span>
<span class="line-added">472      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">473      * &lt;p&gt;</span>
<span class="line-added">474      * This is equivalent to the following code:</span>
<span class="line-added">475      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">476     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-added">477     handle.set(addr, offset, value);</span>
<span class="line-added">478      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">479      * @param addr base address.</span>
<span class="line-added">480      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">481      * @param value the float value to be written.</span>
<span class="line-added">482      */</span>
<span class="line-added">483     public static void setFloat_BE(MemoryAddress addr, long offset, float value) {</span>
<span class="line-added">484         float_BE_handle.set(addr, offset, value);</span>
<span class="line-added">485     }</span>
<span class="line-added">486 </span>
<span class="line-added">487     /**</span>
<span class="line-added">488      * Read a long from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">489      * &lt;p&gt;</span>
<span class="line-added">490      * This is equivalent to the following code:</span>
<span class="line-added">491      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">492     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-added">493     long value = (long)handle.get(addr, offset);</span>
<span class="line-added">494      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">495      * @param addr base address.</span>
<span class="line-added">496      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">497      * @return a long value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">498      */</span>
<span class="line-added">499     public static long getLong_BE(MemoryAddress addr, long offset) {</span>
<span class="line-added">500         return (long)long_BE_handle.get(addr, offset);</span>
<span class="line-added">501     }</span>
<span class="line-added">502 </span>
<span class="line-added">503     /**</span>
<span class="line-added">504      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">505      * &lt;p&gt;</span>
<span class="line-added">506      * This is equivalent to the following code:</span>
<span class="line-added">507      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">508     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-added">509     handle.set(addr, offset, value);</span>
<span class="line-added">510      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">511      * @param addr base address.</span>
<span class="line-added">512      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">513      * @param value the long value to be written.</span>
<span class="line-added">514      */</span>
<span class="line-added">515     public static void setLong_BE(MemoryAddress addr, long offset, long value) {</span>
<span class="line-added">516         long_BE_handle.set(addr, offset, value);</span>
<span class="line-added">517     }</span>
<span class="line-added">518 </span>
<span class="line-added">519     /**</span>
<span class="line-added">520      * Read a double from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">521      * &lt;p&gt;</span>
<span class="line-added">522      * This is equivalent to the following code:</span>
<span class="line-added">523      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">524     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-added">525     double value = (double)handle.get(addr, offset);</span>
<span class="line-added">526      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">527      * @param addr base address.</span>
<span class="line-added">528      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">529      * @return a double value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">530      */</span>
<span class="line-added">531     public static double getDouble_BE(MemoryAddress addr, long offset) {</span>
<span class="line-added">532         return (double)double_BE_handle.get(addr, offset);</span>
<span class="line-added">533     }</span>
<span class="line-added">534 </span>
<span class="line-added">535     /**</span>
<span class="line-added">536      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.</span>
<span class="line-added">537      * &lt;p&gt;</span>
<span class="line-added">538      * This is equivalent to the following code:</span>
<span class="line-added">539      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">540     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-added">541     handle.set(addr, offset, value);</span>
<span class="line-added">542      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">543      * @param addr base address.</span>
<span class="line-added">544      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">545      * @param value the double value to be written.</span>
<span class="line-added">546      */</span>
<span class="line-added">547     public static void setDouble_BE(MemoryAddress addr, long offset, double value) {</span>
<span class="line-added">548         double_BE_handle.set(addr, offset, value);</span>
<span class="line-added">549     }</span>
<span class="line-added">550 </span>
551     /**
552      * A padding layout constant with size of one byte.
553      */
554     public static final MemoryLayout PAD_8 = MemoryLayout.ofPaddingBits(8);
555 
556     /**
557      * A padding layout constant with size of two bytes.
558      */
559     public static final MemoryLayout PAD_16 = MemoryLayout.ofPaddingBits(16);
560 
561     /**
562      * A padding layout constant with size of four bytes.
563      */
564     public static final MemoryLayout PAD_32 = MemoryLayout.ofPaddingBits(32);
565 
566     /**
567      * A padding layout constant with size of eight bytes.
568      */
569     public static final MemoryLayout PAD_64 = MemoryLayout.ofPaddingBits(64);
570 
</pre>
<hr />
<pre>
585 
586     /**
587      * A value layout constant whose size is the same as that of a Java {@code int}, and byte order set to {@link ByteOrder#nativeOrder()}.
588      */
589     public static final ValueLayout JAVA_INT = MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder());
590 
591     /**
592      * A value layout constant whose size is the same as that of a Java {@code long}, and byte order set to {@link ByteOrder#nativeOrder()}.
593      */
594     public static final ValueLayout JAVA_LONG = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());
595 
596     /**
597      * A value layout constant whose size is the same as that of a Java {@code float}, and byte order set to {@link ByteOrder#nativeOrder()}.
598      */
599     public static final ValueLayout JAVA_FLOAT = MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder());
600 
601     /**
602      * A value layout constant whose size is the same as that of a Java {@code double}, and byte order set to {@link ByteOrder#nativeOrder()}.
603      */
604     public static final ValueLayout JAVA_DOUBLE = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());
<span class="line-added">605 </span>
<span class="line-added">606     /**</span>
<span class="line-added">607      * Read a byte from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">608      * &lt;p&gt;</span>
<span class="line-added">609      * This is equivalent to the following code:</span>
<span class="line-added">610      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">611     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-added">612     byte value = (byte)handle.get(addr, offset);</span>
<span class="line-added">613      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">614      *</span>
<span class="line-added">615      * @param addr base address.</span>
<span class="line-added">616      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">617      * @return a byte value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">618      */</span>
<span class="line-added">619     public static byte getByte(MemoryAddress addr, long offset) {</span>
<span class="line-added">620         return (byte)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).get(addr, offset);</span>
<span class="line-added">621     }</span>
<span class="line-added">622 </span>
<span class="line-added">623     /**</span>
<span class="line-added">624      * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">625      * &lt;p&gt;</span>
<span class="line-added">626      * This is equivalent to the following code:</span>
<span class="line-added">627      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">628     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);</span>
<span class="line-added">629     handle.set(addr, offset, value);</span>
<span class="line-added">630      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">631      * @param addr base address.</span>
<span class="line-added">632      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">633      * @param value the byte value to be written.</span>
<span class="line-added">634      */</span>
<span class="line-added">635     public static void setByte(MemoryAddress addr, long offset, byte value) {</span>
<span class="line-added">636         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).set(addr, offset, value);</span>
<span class="line-added">637     }</span>
<span class="line-added">638 </span>
<span class="line-added">639     /**</span>
<span class="line-added">640      * Read a char from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">641      * &lt;p&gt;</span>
<span class="line-added">642      * This is equivalent to the following code:</span>
<span class="line-added">643      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">644     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-added">645     char value = (char)handle.get(addr, offset);</span>
<span class="line-added">646      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">647      * @param addr base address.</span>
<span class="line-added">648      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">649      * @return a char value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">650      */</span>
<span class="line-added">651     public static char getChar(MemoryAddress addr, long offset) {</span>
<span class="line-added">652         return (char)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(addr, offset);</span>
<span class="line-added">653     }</span>
<span class="line-added">654 </span>
<span class="line-added">655     /**</span>
<span class="line-added">656      * Writes a char at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">657      * &lt;p&gt;</span>
<span class="line-added">658      * This is equivalent to the following code:</span>
<span class="line-added">659      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">660     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);</span>
<span class="line-added">661     handle.set(addr, offset, value);</span>
<span class="line-added">662      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">663      * @param addr base address.</span>
<span class="line-added">664      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">665      * @param value the char value to be written.</span>
<span class="line-added">666      */</span>
<span class="line-added">667     public static void setChar(MemoryAddress addr, long offset, char value) {</span>
<span class="line-added">668         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(addr, offset, value);</span>
<span class="line-added">669     }</span>
<span class="line-added">670 </span>
<span class="line-added">671     /**</span>
<span class="line-added">672      * Read a short from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">673      * &lt;p&gt;</span>
<span class="line-added">674      * This is equivalent to the following code:</span>
<span class="line-added">675      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">676     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-added">677     short value = (short)handle.get(addr, offset);</span>
<span class="line-added">678      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">679      * @param addr base address.</span>
<span class="line-added">680      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">681      * @return a short value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">682      */</span>
<span class="line-added">683     public static short getShort(MemoryAddress addr, long offset) {</span>
<span class="line-added">684         return (short)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(addr, offset);</span>
<span class="line-added">685     }</span>
<span class="line-added">686 </span>
<span class="line-added">687     /**</span>
<span class="line-added">688      * Writes a short at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">689      * &lt;p&gt;</span>
<span class="line-added">690      * This is equivalent to the following code:</span>
<span class="line-added">691      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">692     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);</span>
<span class="line-added">693     handle.set(addr, offset, value);</span>
<span class="line-added">694      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">695      * @param addr base address.</span>
<span class="line-added">696      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">697      * @param value the short value to be written.</span>
<span class="line-added">698      */</span>
<span class="line-added">699     public static void setShort(MemoryAddress addr, long offset, short value) {</span>
<span class="line-added">700         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(addr, offset, value);</span>
<span class="line-added">701     }</span>
<span class="line-added">702 </span>
<span class="line-added">703     /**</span>
<span class="line-added">704      * Read an int from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">705      * &lt;p&gt;</span>
<span class="line-added">706      * This is equivalent to the following code:</span>
<span class="line-added">707      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">708     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-added">709     int value = (int)handle.get(addr, offset);</span>
<span class="line-added">710      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">711      * @param addr base address.</span>
<span class="line-added">712      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">713      * @return an int value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">714      */</span>
<span class="line-added">715     public static int getInt(MemoryAddress addr, long offset) {</span>
<span class="line-added">716         return (int)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(addr, offset);</span>
<span class="line-added">717     }</span>
<span class="line-added">718 </span>
<span class="line-added">719     /**</span>
<span class="line-added">720      * Writes an int at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">721      * &lt;p&gt;</span>
<span class="line-added">722      * This is equivalent to the following code:</span>
<span class="line-added">723      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">724     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);</span>
<span class="line-added">725     handle.set(addr, offset, value);</span>
<span class="line-added">726      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">727      * @param addr base address.</span>
<span class="line-added">728      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">729      * @param value the int value to be written.</span>
<span class="line-added">730      */</span>
<span class="line-added">731     public static void setInt(MemoryAddress addr, long offset, int value) {</span>
<span class="line-added">732         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(addr, offset, value);</span>
<span class="line-added">733     }</span>
<span class="line-added">734 </span>
<span class="line-added">735     /**</span>
<span class="line-added">736      * Read a float from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">737      * &lt;p&gt;</span>
<span class="line-added">738      * This is equivalent to the following code:</span>
<span class="line-added">739      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">740     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-added">741     float value = (float)handle.get(addr, offset);</span>
<span class="line-added">742      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">743      * @param addr base address.</span>
<span class="line-added">744      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">745      * @return a float value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">746      */</span>
<span class="line-added">747     public static float getFloat(MemoryAddress addr, long offset) {</span>
<span class="line-added">748         return (float)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(addr, offset);</span>
<span class="line-added">749     }</span>
<span class="line-added">750 </span>
<span class="line-added">751     /**</span>
<span class="line-added">752      * Writes a float at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">753      * &lt;p&gt;</span>
<span class="line-added">754      * This is equivalent to the following code:</span>
<span class="line-added">755      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">756     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);</span>
<span class="line-added">757     handle.set(addr, offset, value);</span>
<span class="line-added">758      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">759      * @param addr base address.</span>
<span class="line-added">760      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">761      * @param value the float value to be written.</span>
<span class="line-added">762      */</span>
<span class="line-added">763     public static void setFloat(MemoryAddress addr, long offset, float value) {</span>
<span class="line-added">764         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(addr, offset, value);</span>
<span class="line-added">765     }</span>
<span class="line-added">766 </span>
<span class="line-added">767     /**</span>
<span class="line-added">768      * Read a long from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">769      * &lt;p&gt;</span>
<span class="line-added">770      * This is equivalent to the following code:</span>
<span class="line-added">771      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">772     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-added">773     long value = (long)handle.get(addr, offset);</span>
<span class="line-added">774      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">775      * @param addr base address.</span>
<span class="line-added">776      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">777      * @return a long value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">778      */</span>
<span class="line-added">779     public static long getLong(MemoryAddress addr, long offset) {</span>
<span class="line-added">780         return (long)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(addr, offset);</span>
<span class="line-added">781     }</span>
<span class="line-added">782 </span>
<span class="line-added">783     /**</span>
<span class="line-added">784      * Writes a long at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">785      * &lt;p&gt;</span>
<span class="line-added">786      * This is equivalent to the following code:</span>
<span class="line-added">787      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">788     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);</span>
<span class="line-added">789     handle.set(addr, offset, value);</span>
<span class="line-added">790      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">791      * @param addr base address.</span>
<span class="line-added">792      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">793      * @param value the long value to be written.</span>
<span class="line-added">794      */</span>
<span class="line-added">795     public static void setLong(MemoryAddress addr, long offset, long value) {</span>
<span class="line-added">796         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(addr, offset, value);</span>
<span class="line-added">797     }</span>
<span class="line-added">798 </span>
<span class="line-added">799     /**</span>
<span class="line-added">800      * Read a double from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">801      * &lt;p&gt;</span>
<span class="line-added">802      * This is equivalent to the following code:</span>
<span class="line-added">803      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">804     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-added">805     double value = (double)handle.get(addr, offset);</span>
<span class="line-added">806      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">807      * @param addr base address.</span>
<span class="line-added">808      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">809      * @return a double value read from {@code addr} at the offset specified by {@code index}.</span>
<span class="line-added">810      */</span>
<span class="line-added">811     public static double getDouble(MemoryAddress addr, long offset) {</span>
<span class="line-added">812         return (double)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(addr, offset);</span>
<span class="line-added">813     }</span>
<span class="line-added">814 </span>
<span class="line-added">815     /**</span>
<span class="line-added">816      * Writes a double at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.</span>
<span class="line-added">817      * &lt;p&gt;</span>
<span class="line-added">818      * This is equivalent to the following code:</span>
<span class="line-added">819      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">820     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);</span>
<span class="line-added">821     handle.set(addr, offset, value);</span>
<span class="line-added">822      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">823      * @param addr base address.</span>
<span class="line-added">824      * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.</span>
<span class="line-added">825      * @param value the double value to be written.</span>
<span class="line-added">826      */</span>
<span class="line-added">827     public static void setDouble(MemoryAddress addr, long offset, double value) {</span>
<span class="line-added">828         ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(addr, offset, value);</span>
<span class="line-added">829     }</span>
<span class="line-added">830 </span>
<span class="line-added">831     private static VarHandle indexedHandle(MemoryLayout elementLayout, Class&lt;?&gt; carrier) {</span>
<span class="line-added">832         return MemoryHandles.withStride(elementLayout.withBitAlignment(8).varHandle(carrier), 1L);</span>
<span class="line-added">833     }</span>
834 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemorySegment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
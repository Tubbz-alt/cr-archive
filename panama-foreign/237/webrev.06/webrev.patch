diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
@@ -27,11 +27,10 @@
 
 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.SharedUtils;
 
-import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 import java.nio.charset.Charset;
 import java.util.Objects;
 import java.util.function.Consumer;
 
@@ -54,107 +53,164 @@
         return SharedUtils.getSystemLinker();
     }
 
     /**
      * An interface that models a C {@code va_list}.
-     *
+     * <p>
+     * A va list is a stateful cursor used to iterate over a set of variadic arguments.
+     * <p>
      * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),
      * arguments to variadic calls are erased by way of 'default argument promotions',
      * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),
      * and which erases all {@code float} arguments to {@code double}.
-     *
+     * <p>
      * As such, this interface only supports reading {@code int}, {@code double},
      * and any other type that fits into a {@code long}.
      */
     public interface VaList extends AutoCloseable {
 
         /**
-         * Reads a value into an {@code int}
+         * Reads the next value as an {@code int} and advances this va list's position.
          *
          * @param layout the layout of the value
          * @return the value read as an {@code int}
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}
          */
         int vargAsInt(MemoryLayout layout);
 
         /**
-         * Reads a value into a {@code long}
+         * Reads the next value as a {@code long} and advances this va list's position.
          *
          * @param layout the layout of the value
          * @return the value read as an {@code long}
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}
          */
         long vargAsLong(MemoryLayout layout);
 
         /**
-         * Reads a value into a {@code double}
+         * Reads the next value as a {@code double} and advances this va list's position.
          *
          * @param layout the layout of the value
          * @return the value read as an {@code double}
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}
          */
         double vargAsDouble(MemoryLayout layout);
 
         /**
-         * Reads a value into a {@code MemoryAddress}
+         * Reads the next value as a {@code MemoryAddress} and advances this va list's position.
          *
          * @param layout the layout of the value
          * @return the value read as an {@code MemoryAddress}
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}
          */
         MemoryAddress vargAsAddress(MemoryLayout layout);
 
         /**
-         * Reads a value into a {@code MemorySegment}
+         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.
+         * <p>
+         * The memory segment returned by this method will be allocated using
+         * {@link MemorySegment#allocateNative(long, long)}, and will have to be closed separately.
          *
          * @param layout the layout of the value
          * @return the value read as an {@code MemorySegment}
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
          */
         MemorySegment vargAsSegment(MemoryLayout layout);
 
         /**
-         * Skips a number of va arguments with the given memory layouts.
+         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.
+         * <p>
+         * The memory segment returned by this method will be allocated using the given {@code NativeScope}.
+         *
+         * @param layout the layout of the value
+         * @param scope the scope to allocate the segment in
+         * @return the value read as an {@code MemorySegment}
+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
+         * (see {@link #close()}).
+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
+         */
+        MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);
+
+        /**
+         * Skips a number of elements with the given memory layouts, and advances this va list's position.
          *
          * @param layouts the layout of the value
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
          */
         void skip(MemoryLayout... layouts);
 
         /**
          * A predicate used to check if the memory associated with the C {@code va_list} modelled
-         * by this instance is still valid; or, in other words, if {@code close()} has been called on this
-         * instance.
+         * by this instance is still valid to use.
          *
          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
          * @see #close()
          */
         boolean isAlive();
 
         /**
-         * Releases the underlying C {@code va_list} modelled by this instance. As a result, subsequent attempts to call
-         * operations on this instance (e.g. {@link #copy()} will fail with an exception.
+         * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached
+         * to this va list that holds its elements (see {@link VaList#make(Consumer)}).
+         * <p>
+         * After calling this method, {@link #isAlive()} will return {@code false} and further attempts to read values
+         * from this va list will result in an exception.
          *
          * @see #isAlive()
          */
         void close();
 
         /**
-         * Copies this C {@code va_list}.
+         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements
+         * starting from the current position, without affecting the state of the original va list, essentially
+         * allowing the elements to be traversed multiple times.
+         * <p>
+         * If this method needs to allocate native memory for the copy, it will use
+         * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the
+         * returned va list instance to release the allocated memory.
+         * <p>
+         * This method only copies the va list cursor itself and not the memory that may be attached to the
+         * va list which holds its elements. That means that if this va list was created with the
+         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
+         * elements, making the copy unusable.
          *
          * @return a copy of this C {@code va_list}.
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
          */
         VaList copy();
 
+        /**
+         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements
+         * starting from the current position, without affecting the state of the original va list, essentially
+         * allowing the elements to be traversed multiple times.
+         * <p>
+         * If this method needs to allocate native memory for the copy, it will use
+         * the given {@code NativeScope} to do so.
+         * <p>
+         * This method only copies the va list cursor itself and not the memory that may be attached to the
+         * va list which holds its elements. That means that if this va list was created with the
+         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
+         * elements, making the copy unusable.
+         *
+         * @param scope the scope to allocate the copy in
+         * @return a copy of this C {@code va_list}.
+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
+         * (see {@link #close()}).
+         */
+        VaList copy(NativeScope scope);
+
         /**
          * Returns the memory address of the C {@code va_list} associated with this instance.
          *
          * @return the memory address of the C {@code va_list} associated with this instance.
          */
@@ -170,25 +226,52 @@
             return SharedUtils.newVaListOfAddress(address);
         }
 
         /**
          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
-         *
-         * Note that when there are no arguments added to the created va list,
+         * <p>
+         * If this method needs to allocate native memory for the va list, it will use
+         * {@link MemorySegment#allocateNative(long, long)} to do so.
+         * <p>
+         * This method will allocate native memory to hold the elements in the va list. This memory
+         * will be 'attached' to the returned va list instance, and will be released when {@link VaList#close()}
+         * is called.
+         * <p>
+         * Note that when there are no elements added to the created va list,
          * this method will return the same as {@linkplain #empty()}.
          *
-         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the contents
+         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
          *                of the underlying C {@code va_list}.
          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
          */
         static VaList make(Consumer<VaList.Builder> actions) {
-            return SharedUtils.newVaList(actions);
+            return SharedUtils.newVaList(actions, MemorySegment::allocateNative);
         }
 
         /**
-         * Returns an empty C {@code va_list} constant.
+         * Constructs a new {@code VaList} using a builder (see {@link Builder}).
+         * <p>
+         * If this method needs to allocate native memory for the va list, it will use
+         * the given {@code NativeScope} to do so.
+         * <p>
+         * This method will allocate native memory to hold the elements in the va list. This memory
+         * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.
+         * <p>
+         * Note that when there are no elements added to the created va list,
+         * this method will return the same as {@linkplain #empty()}.
          *
+         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
+         *                of the underlying C {@code va_list}.
+         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
+         */
+        static VaList make(Consumer<VaList.Builder> actions, NativeScope scope) {
+            return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
+        }
+
+        /**
+         * Returns an empty C {@code va_list} constant.
+         * <p>
          * The returned {@code VaList} can not be closed.
          *
          * @return a {@code VaList} modelling an empty C {@code va_list}.
          */
         static VaList empty() {
@@ -204,46 +287,51 @@
              * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.
              *
              * @param layout the native layout of the value.
              * @param value the value, represented as an {@code int}.
              * @return this builder.
+             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}
              */
             Builder vargFromInt(MemoryLayout layout, int value);
 
             /**
              * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.
              *
              * @param layout the native layout of the value.
              * @param value the value, represented as a {@code long}.
              * @return this builder.
+             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}
              */
             Builder vargFromLong(MemoryLayout layout, long value);
 
             /**
              * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.
              *
              * @param layout the native layout of the value.
              * @param value the value, represented as a {@code double}.
              * @return this builder.
+             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}
              */
             Builder vargFromDouble(MemoryLayout layout, double value);
 
             /**
              * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.
              *
              * @param layout the native layout of the value.
              * @param value the value, represented as a {@code MemoryAddress}.
              * @return this builder.
+             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}
              */
             Builder vargFromAddress(MemoryLayout layout, MemoryAddress value);
 
             /**
              * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.
              *
              * @param layout the native layout of the value.
              * @param value the value, represented as a {@code MemorySegment}.
              * @return this builder.
+             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
              */
             Builder vargFromSegment(MemoryLayout layout, MemorySegment value);
         }
     }
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -31,10 +31,11 @@
 import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
@@ -277,16 +278,16 @@
         }
         throw new IllegalArgumentException("String too large");
     }
 
 
-    public static VaList newVaList(Consumer<VaList.Builder> actions) {
+    public static VaList newVaList(Consumer<VaList.Builder> actions, Allocator allocator) {
         String name = CSupport.getSystemLinker().name();
         return switch(name) {
-            case Win64.NAME -> Windowsx64Linker.newVaList(actions);
-            case SysV.NAME -> SysVx64Linker.newVaList(actions);
-            case AArch64.NAME -> AArch64Linker.newVaList(actions);
+            case Win64.NAME -> Windowsx64Linker.newVaList(actions, allocator);
+            case SysV.NAME -> SysVx64Linker.newVaList(actions, allocator);
+            case AArch64.NAME -> AArch64Linker.newVaList(actions, allocator);
             default -> throw new IllegalStateException("Unknown linker name: " + name);
         };
     }
 
     public static VarHandle vhPrimitiveOrAddress(Class<?> carrier, MemoryLayout layout) {
@@ -354,10 +355,26 @@
         return cDesc.attribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME)
                 .map(Boolean.class::cast)
                 .orElse(false);
     }
 
+    public interface Allocator {
+        default MemorySegment allocate(MemoryLayout layout) {
+            return allocate(layout.byteSize(), layout.byteAlignment());
+        }
+
+        default MemorySegment allocate(long size) {
+            return allocate(size, 1);
+        }
+
+        MemorySegment allocate(long size, long align);
+
+        static Allocator ofScope(NativeScope scope) {
+            return (size, align) -> scope.allocate(size, align).segment();
+        }
+    }
+
     public static class SimpleVaArg {
         public final Class<?> carrier;
         public final MemoryLayout layout;
         public final Object value;
 
@@ -409,10 +426,15 @@
         @Override
         public MemorySegment vargAsSegment(MemoryLayout layout) {
             throw uoe();
         }
 
+        @Override
+        public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {
+            throw uoe();
+        }
+
         @Override
         public void skip(MemoryLayout... layouts) {
             throw uoe();
         }
 
@@ -429,10 +451,15 @@
         @Override
         public VaList copy() {
             return this;
         }
 
+        @Override
+        public VaList copy(NativeScope scope) {
+            throw uoe();
+        }
+
         @Override
         public MemoryAddress address() {
             return address;
         }
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
@@ -93,12 +93,12 @@
 
     static AArch64.ArgumentClass argumentClassFor(MemoryLayout layout) {
         return (AArch64.ArgumentClass)layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get();
     }
 
-    public static VaList newVaList(Consumer<VaList.Builder> actions) {
-        AArch64VaList.Builder builder = AArch64VaList.builder();
+    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {
+        AArch64VaList.Builder builder = AArch64VaList.builder(allocator);
         actions.accept(builder);
         return builder.build();
     }
 
     public static VaList newVaListOfAddress(MemoryAddress ma) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
@@ -29,10 +29,11 @@
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.misc.Unsafe;
 
@@ -104,27 +105,31 @@
     private static final Cleaner cleaner = Cleaner.create();
     private static final CSupport.VaList EMPTY
         = new SharedUtils.EmptyVaList(emptyListAddress());
 
     private final MemorySegment segment;
-    private final List<MemorySegment> slices = new ArrayList<>();
-    private final MemorySegment fpRegsArea;
     private final MemorySegment gpRegsArea;
+    private final MemorySegment fpRegsArea;
+    private final List<MemorySegment> attachedSegments;
 
-    AArch64VaList(MemorySegment segment) {
+    private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea,
+                          List<MemorySegment> attachedSegments) {
         this.segment = segment;
+        this.gpRegsArea = gpRegsArea;
+        this.fpRegsArea = fpRegsArea;
+        this.attachedSegments = attachedSegments;
+    }
 
-        gpRegsArea = MemorySegment.ofNativeRestricted(
-            grTop().addOffset(-MAX_GP_OFFSET), MAX_GP_OFFSET,
+    private static AArch64VaList readFromSegment(MemorySegment segment) {
+        MemorySegment gpRegsArea = MemorySegment.ofNativeRestricted(
+            grTop(segment).addOffset(-MAX_GP_OFFSET), MAX_GP_OFFSET,
             segment.ownerThread(), null, null);
 
-        fpRegsArea = MemorySegment.ofNativeRestricted(
-            vrTop().addOffset(-MAX_FP_OFFSET), MAX_FP_OFFSET,
+        MemorySegment fpRegsArea = MemorySegment.ofNativeRestricted(
+            vrTop(segment).addOffset(-MAX_FP_OFFSET), MAX_FP_OFFSET,
             segment.ownerThread(), null, null);
-
-        slices.add(gpRegsArea);
-        slices.add(fpRegsArea);
+        return new AArch64VaList(segment, gpRegsArea, fpRegsArea, List.of(gpRegsArea, fpRegsArea));
     }
 
     private static MemoryAddress emptyListAddress() {
         long ptr = U.allocateMemory(LAYOUT.byteSize());
         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
@@ -143,14 +148,22 @@
     public static CSupport.VaList empty() {
         return EMPTY;
     }
 
     private MemoryAddress grTop() {
+        return grTop(segment);
+    }
+
+    private static MemoryAddress grTop(MemorySegment segment) {
         return (MemoryAddress) VH_gr_top.get(segment.baseAddress());
     }
 
     private MemoryAddress vrTop() {
+        return vrTop(segment);
+    }
+
+    private static MemoryAddress vrTop(MemorySegment segment) {
         return (MemoryAddress) VH_vr_top.get(segment.baseAddress());
     }
 
     private int grOffs() {
         final int offs = (int) VH_gr_offs.get(segment.baseAddress());
@@ -231,22 +244,31 @@
     @Override
     public MemorySegment vargAsSegment(MemoryLayout layout) {
         return (MemorySegment) read(MemorySegment.class, layout);
     }
 
+    @Override
+    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {
+        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));
+    }
+
     private Object read(Class<?> carrier, MemoryLayout layout) {
+        return read(carrier, layout, MemorySegment::allocateNative);
+    }
+
+    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {
         checkCompatibleType(carrier, layout, AArch64Linker.ADDRESS_SIZE);
 
         TypeClass typeClass = TypeClass.classifyLayout(layout);
         if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {
             preAlignStack(layout);
             return switch (typeClass) {
                 case STRUCT_REGISTER, STRUCT_HFA, STRUCT_REFERENCE -> {
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
                              stackPtr(), layout.byteSize(),
                              segment.ownerThread(), null, null)) {
-                        MemorySegment seg = MemorySegment.allocateNative(layout);
+                        MemorySegment seg = allocator.allocate(layout);
                         seg.copyFrom(slice);
                         postAlignStack(layout);
                         yield seg;
                     }
                 }
@@ -263,11 +285,11 @@
             };
         } else {
             return switch (typeClass) {
                 case STRUCT_REGISTER -> {
                     // Struct is passed packed in integer registers.
-                    MemorySegment value = MemorySegment.allocateNative(layout);
+                    MemorySegment value = allocator.allocate(layout);
                     long offset = 0;
                     while (offset < layout.byteSize()) {
                         final long copy = Math.min(layout.byteSize() - offset, 8);
                         MemorySegment slice = value.asSlice(offset, copy);
                         slice.copyFrom(gpRegsArea.asSlice(currentGPOffset(), copy));
@@ -277,11 +299,11 @@
                     yield value;
                 }
                 case STRUCT_HFA -> {
                     // Struct is passed with each element in a separate floating
                     // point register.
-                    MemorySegment value = MemorySegment.allocateNative(layout);
+                    MemorySegment value = allocator.allocate(layout);
                     GroupLayout group = (GroupLayout)layout;
                     long offset = 0;
                     for (MemoryLayout elem : group.memberLayouts()) {
                         assert elem.byteSize() <= 8;
                         final long copy = elem.byteSize();
@@ -300,11 +322,11 @@
                         gpRegsArea.baseAddress().addOffset(currentGPOffset()));
                     consumeGPSlots(1);
 
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
                              ptr, layout.byteSize(), segment.ownerThread(), null, null)) {
-                        MemorySegment seg = MemorySegment.allocateNative(layout);
+                        MemorySegment seg = allocator.allocate(layout);
                         seg.copyFrom(slice);
                         yield seg;
                     }
                 }
                 case POINTER, INTEGER -> {
@@ -338,17 +360,16 @@
                 consumeGPSlots(numSlots(layout));
             }
         }
     }
 
-    static AArch64VaList.Builder builder() {
-        return new AArch64VaList.Builder();
+    static AArch64VaList.Builder builder(SharedUtils.Allocator allocator) {
+        return new AArch64VaList.Builder(allocator);
     }
 
     public static VaList ofAddress(MemoryAddress ma) {
-        return new AArch64VaList(
-            MemorySegment.ofNativeRestricted(
+        return readFromSegment(MemorySegment.ofNativeRestricted(
                 ma, LAYOUT.byteSize(), Thread.currentThread(), null, null));
     }
 
     @Override
     public boolean isAlive() {
@@ -356,18 +377,27 @@
     }
 
     @Override
     public void close() {
         segment.close();
-        slices.forEach(MemorySegment::close);
+        attachedSegments.forEach(MemorySegment::close);
     }
 
     @Override
     public VaList copy() {
-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT.byteSize());
+        return copy(MemorySegment::allocateNative);
+    }
+
+    @Override
+    public VaList copy(NativeScope scope) {
+        return copy(SharedUtils.Allocator.ofScope(scope));
+    }
+
+    private VaList copy(SharedUtils.Allocator allocator) {
+        MemorySegment copy = allocator.allocate(LAYOUT);
         copy.copyFrom(segment);
-        return new AArch64VaList(copy);
+        return new AArch64VaList(copy, gpRegsArea, fpRegsArea, List.of());
     }
 
     @Override
     public MemoryAddress address() {
         return segment.baseAddress();
@@ -398,19 +428,24 @@
             + ", __vr_offs=" + vrOffs()
             + '}';
     }
 
     static class Builder implements CSupport.VaList.Builder {
-        private final MemorySegment gpRegs
-            = MemorySegment.allocateNative(LAYOUT_GP_REGS);
-        private final MemorySegment fpRegs
-            = MemorySegment.allocateNative(LAYOUT_FP_REGS);
+        private final SharedUtils.Allocator allocator;
+        private final MemorySegment gpRegs;
+        private final MemorySegment fpRegs;
 
         private long currentGPOffset = 0;
         private long currentFPOffset = 0;
         private final List<SimpleVaArg> stackArgs = new ArrayList<>();
 
+        Builder(SharedUtils.Allocator allocator) {
+            this.allocator = allocator;
+            this.gpRegs = allocator.allocate(LAYOUT_GP_REGS);
+            this.fpRegs = allocator.allocate(LAYOUT_FP_REGS);
+        }
+
         @Override
         public Builder vargFromInt(MemoryLayout layout, int value) {
             return arg(int.class, layout, value);
         }
 
@@ -501,40 +536,39 @@
         public VaList build() {
             if (isEmpty()) {
                 return EMPTY;
             }
 
-            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT.byteSize());
-            AArch64VaList res = new AArch64VaList(vaListSegment);
-
+            MemorySegment vaListSegment = allocator.allocate(LAYOUT);
+            List<MemorySegment> attachedSegments = new ArrayList<>();
             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
             if (!stackArgs.isEmpty()) {
                 long stackArgsSize = stackArgs.stream()
                     .reduce(0L, (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), 8), Long::sum);
-                MemorySegment stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16);
+                MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
                 MemoryAddress maStackArea = stackArgsSegment.baseAddress();
                 for (SimpleVaArg arg : stackArgs) {
                     final long alignedSize = Utils.alignUp(arg.layout.byteSize(), 8);
                     maStackArea = Utils.alignUp(maStackArea, alignedSize);
                     VarHandle writer = arg.varHandle();
                     writer.set(maStackArea, arg.value);
                     maStackArea = maStackArea.addOffset(alignedSize);
                 }
                 stackArgsPtr = stackArgsSegment.baseAddress();
-                res.slices.add(stackArgsSegment);
+                attachedSegments.add(stackArgsSegment);
             }
 
             MemoryAddress vaListAddr = vaListSegment.baseAddress();
             VH_gr_top.set(vaListAddr, gpRegs.baseAddress().addOffset(gpRegs.byteSize()));
             VH_vr_top.set(vaListAddr, fpRegs.baseAddress().addOffset(fpRegs.byteSize()));
             VH_stack.set(vaListAddr, stackArgsPtr);
             VH_gr_offs.set(vaListAddr, -MAX_GP_OFFSET);
             VH_vr_offs.set(vaListAddr, -MAX_FP_OFFSET);
 
-            res.slices.add(gpRegs);
-            res.slices.add(fpRegs);
+            attachedSegments.add(gpRegs);
+            attachedSegments.add(fpRegs);
             assert gpRegs.ownerThread() == vaListSegment.ownerThread();
             assert fpRegs.ownerThread() == vaListSegment.ownerThread();
-            return res;
+            return new AArch64VaList(vaListSegment, gpRegs, fpRegs, attachedSegments);
         }
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
@@ -29,10 +29,11 @@
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.misc.Unsafe;
 
@@ -118,17 +119,22 @@
 
     private static final Cleaner cleaner = Cleaner.create();
     private static final CSupport.VaList EMPTY = new SharedUtils.EmptyVaList(emptyListAddress());
 
     private final MemorySegment segment;
-    private final List<MemorySegment> slices = new ArrayList<>();
     private final MemorySegment regSaveArea;
+    private final List<MemorySegment> attachedSegments;
 
-    SysVVaList(MemorySegment segment) {
+    private SysVVaList(MemorySegment segment, MemorySegment regSaveArea, List<MemorySegment> attachedSegments) {
         this.segment = segment;
-        regSaveArea = regSaveArea();
-        slices.add(regSaveArea);
+        this.regSaveArea = regSaveArea;
+        this.attachedSegments = attachedSegments;
+    }
+
+    private static SysVVaList readFromSegment(MemorySegment segment) {
+        MemorySegment regSaveArea = getRegSaveArea(segment);
+        return new SysVVaList(segment, regSaveArea, List.of(regSaveArea));
     }
 
     private static MemoryAddress emptyListAddress() {
         long ptr = U.allocateMemory(LAYOUT.byteSize());
         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
@@ -169,10 +175,14 @@
     private void stackPtr(MemoryAddress ptr) {
         VH_overflow_arg_area.set(segment.baseAddress(), ptr);
     }
 
     private MemorySegment regSaveArea() {
+        return getRegSaveArea(segment);
+    }
+
+    private static MemorySegment getRegSaveArea(MemorySegment segment) {
         return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment.baseAddress()),
             LAYOUT_REG_SAVE_AREA.byteSize(), segment.ownerThread(), null, null);
     }
 
     private void preAlignStack(MemoryLayout layout) {
@@ -208,21 +218,30 @@
     @Override
     public MemorySegment vargAsSegment(MemoryLayout layout) {
         return (MemorySegment) read(MemorySegment.class, layout);
     }
 
+    @Override
+    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {
+        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));
+    }
+
     private Object read(Class<?> carrier, MemoryLayout layout) {
+        return read(carrier, layout, MemorySegment::allocateNative);
+    }
+
+    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {
         checkCompatibleType(carrier, layout, SysVx64Linker.ADDRESS_SIZE);
         TypeClass typeClass = TypeClass.classifyLayout(layout);
         if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)
                 || typeClass.inMemory()) {
             preAlignStack(layout);
             return switch (typeClass.kind()) {
                 case STRUCT -> {
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),
                                                                                 segment.ownerThread(), null, null)) {
-                        MemorySegment seg = MemorySegment.allocateNative(layout);
+                        MemorySegment seg = allocator.allocate(layout);
                         seg.copyFrom(slice);
                         postAlignStack(layout);
                         yield seg;
                     }
                 }
@@ -237,11 +256,11 @@
                 }
             };
         } else {
             return switch (typeClass.kind()) {
                 case STRUCT -> {
-                    MemorySegment value = MemorySegment.allocateNative(layout);
+                    MemorySegment value = allocator.allocate(layout);
                     int classIdx = 0;
                     long offset = 0;
                     while (offset < layout.byteSize()) {
                         final long copy = Math.min(layout.byteSize() - offset, 8);
                         boolean isSSE = typeClass.classes.get(classIdx++) == ArgumentClassImpl.SSE;
@@ -285,34 +304,45 @@
                 currentFPOffset(currentFPOffset() + (((int) typeClass.nVectorRegs()) * FP_SLOT_SIZE));
             }
         }
     }
 
-    static SysVVaList.Builder builder() {
-        return new SysVVaList.Builder();
+    static SysVVaList.Builder builder(SharedUtils.Allocator allocator) {
+        return new SysVVaList.Builder(allocator);
     }
 
     public static VaList ofAddress(MemoryAddress ma) {
-        return new SysVVaList(MemorySegment.ofNativeRestricted(ma, LAYOUT.byteSize(), Thread.currentThread(), null, null));
+        MemorySegment vaListSegment
+            = MemorySegment.ofNativeRestricted(ma, LAYOUT.byteSize(), Thread.currentThread(), null, null);
+        return readFromSegment(vaListSegment);
     }
 
     @Override
     public boolean isAlive() {
         return segment.isAlive();
     }
 
     @Override
     public void close() {
         segment.close();
-        slices.forEach(MemorySegment::close);
+        attachedSegments.forEach(MemorySegment::close);
     }
 
     @Override
     public VaList copy() {
-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT.byteSize());
+        return copy(MemorySegment::allocateNative);
+    }
+
+    @Override
+    public VaList copy(NativeScope scope) {
+        return copy(SharedUtils.Allocator.ofScope(scope));
+    }
+
+    private VaList copy(SharedUtils.Allocator allocator) {
+        MemorySegment copy = allocator.allocate(LAYOUT);
         copy.copyFrom(segment);
-        return new SysVVaList(copy);
+        return new SysVVaList(copy, regSaveArea, List.of());
     }
 
     @Override
     public MemoryAddress address() {
         return segment.baseAddress();
@@ -332,15 +362,21 @@
                + ", reg_save_area=" + regSaveArea()
                + '}';
     }
 
     static class Builder implements CSupport.VaList.Builder {
-        private final MemorySegment reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA);
+        private final SharedUtils.Allocator allocator;
+        private final MemorySegment reg_save_area;
         private long currentGPOffset = 0;
         private long currentFPOffset = FP_OFFSET;
         private final List<SimpleVaArg> stackArgs = new ArrayList<>();
 
+        public Builder(SharedUtils.Allocator allocator) {
+            this.allocator = allocator;
+            this.reg_save_area = allocator.allocate(LAYOUT_REG_SAVE_AREA);
+        }
+
         @Override
         public Builder vargFromInt(MemoryLayout layout, int value) {
             return arg(int.class, layout, value);
         }
 
@@ -413,16 +449,16 @@
         public VaList build() {
             if (isEmpty()) {
                 return EMPTY;
             }
 
-            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT.byteSize());
-            SysVVaList res = new SysVVaList(vaListSegment);
+            MemorySegment vaListSegment = allocator.allocate(LAYOUT);
+            List<MemorySegment> attachedSegments = new ArrayList<>();
             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
             if (!stackArgs.isEmpty()) {
                 long stackArgsSize = stackArgs.stream().reduce(0L, (acc, e) -> acc + e.layout.byteSize(), Long::sum);
-                MemorySegment stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16);
+                MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
                 MemoryAddress maOverflowArgArea = stackArgsSegment.baseAddress();
                 for (SimpleVaArg arg : stackArgs) {
                     if (arg.layout.byteSize() > 8) {
                         maOverflowArgArea = Utils.alignUp(maOverflowArgArea, Math.min(16, arg.layout.byteSize()));
                     }
@@ -435,18 +471,18 @@
                         writer.set(maOverflowArgArea, arg.value);
                     }
                     maOverflowArgArea = maOverflowArgArea.addOffset(arg.layout.byteSize());
                 }
                 stackArgsPtr = stackArgsSegment.baseAddress();
-                res.slices.add(stackArgsSegment);
+                attachedSegments.add(stackArgsSegment);
             }
 
             MemoryAddress vaListAddr = vaListSegment.baseAddress();
             VH_fp_offset.set(vaListAddr, (int) FP_OFFSET);
             VH_overflow_arg_area.set(vaListAddr, stackArgsPtr);
             VH_reg_save_area.set(vaListAddr, reg_save_area.baseAddress());
-            res.slices.add(reg_save_area);
+            attachedSegments.add(reg_save_area);
             assert reg_save_area.ownerThread() == vaListSegment.ownerThread();
-            return res;
+            return new SysVVaList(vaListSegment, reg_save_area, attachedSegments);
         }
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
@@ -75,12 +75,12 @@
             instance = new SysVx64Linker();
         }
         return instance;
     }
 
-    public static VaList newVaList(Consumer<VaList.Builder> actions) {
-        SysVVaList.Builder builder = SysVVaList.builder();
+    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {
+        SysVVaList.Builder builder = SysVVaList.builder(allocator);
         actions.accept(builder);
         return builder.build();
     }
 
     @Override
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
@@ -23,26 +23,24 @@
  *  questions.
  *
  */
 package jdk.internal.foreign.abi.x64.windows;
 
-import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.CSupport.VaList;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;
 
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
 
 import static jdk.incubator.foreign.CSupport.Win64.C_POINTER;
-import static jdk.incubator.foreign.MemorySegment.CLOSE;
-import static jdk.incubator.foreign.MemorySegment.READ;
 
 // see vadefs.h (VC header)
 //
 // in short
 // -> va_list is just a pointer to a buffer with 64 bit entries.
@@ -63,22 +61,18 @@
     private static final long VA_SLOT_SIZE_BYTES = 8;
     private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));
 
     private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemoryAddress.NULL);
 
-    private final MemorySegment segment;
     private MemoryAddress ptr;
-    private final List<MemorySegment> copies;
+    private final List<MemorySegment> attachedSegments;
+    private final MemorySegment livenessCheck;
 
-    WinVaList(MemorySegment segment) {
-        this(segment, new ArrayList<>());
-    }
-
-    WinVaList(MemorySegment segment, List<MemorySegment> copies) {
-        this.segment = segment;
-        this.ptr = segment.baseAddress();
-        this.copies = copies;
+    private WinVaList(MemoryAddress ptr, List<MemorySegment> attachedSegments, MemorySegment livenessCheck) {
+        this.ptr = ptr;
+        this.attachedSegments = attachedSegments;
+        this.livenessCheck = livenessCheck;
     }
 
     public static final VaList empty() {
         return EMPTY;
     }
@@ -106,28 +100,37 @@
     @Override
     public MemorySegment vargAsSegment(MemoryLayout layout) {
         return (MemorySegment) read(MemorySegment.class, layout);
     }
 
+    @Override
+    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {
+        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));
+    }
+
     private Object read(Class<?> carrier, MemoryLayout layout) {
+        return read(carrier, layout, MemorySegment::allocateNative);
+    }
+
+    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {
         SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);
         Object res;
         if (carrier == MemorySegment.class) {
             TypeClass typeClass = TypeClass.typeClassFor(layout);
             res = switch (typeClass) {
                 case STRUCT_REFERENCE -> {
                     MemoryAddress structAddr = (MemoryAddress) VH_address.get(ptr);
                     try (MemorySegment struct = MemorySegment.ofNativeRestricted(structAddr, layout.byteSize(),
-                                                                            segment.ownerThread(), null, null)) {
-                        MemorySegment seg = MemorySegment.allocateNative(layout.byteSize());
+                                                                            ptr.segment().ownerThread(), null, null)) {
+                        MemorySegment seg = allocator.allocate(layout);
                         seg.copyFrom(struct);
                         yield seg;
                     }
                 }
                 case STRUCT_REGISTER -> {
-                    MemorySegment struct = MemorySegment.allocateNative(layout);
-                    struct.copyFrom(segment.asSlice(ptr.segmentOffset(), layout.byteSize()));
+                    MemorySegment struct = allocator.allocate(layout);
+                    struct.copyFrom(ptr.segment().asSlice(ptr.segmentOffset(), layout.byteSize()));
                     yield struct;
                 }
                 default -> throw new IllegalStateException("Unexpected TypeClass: " + typeClass);
             };
         } else {
@@ -142,42 +145,61 @@
     public void skip(MemoryLayout... layouts) {
         ptr = ptr.addOffset(layouts.length * VA_SLOT_SIZE_BYTES);
     }
 
     static WinVaList ofAddress(MemoryAddress addr) {
-        return new WinVaList(MemorySegment.ofNativeRestricted(addr, Long.MAX_VALUE, Thread.currentThread(), null, null));
+        MemorySegment segment = MemorySegment.ofNativeRestricted(addr, Long.MAX_VALUE, Thread.currentThread(), null, null);
+        return new WinVaList(segment.baseAddress(), List.of(segment), null);
     }
 
-    static Builder builder() {
-        return new Builder();
+    static Builder builder(SharedUtils.Allocator allocator) {
+        return new Builder(allocator);
     }
 
     @Override
     public void close() {
-        segment.close();
-        copies.forEach(MemorySegment::close);
+        if (livenessCheck != null)
+            livenessCheck.close();
+        attachedSegments.forEach(MemorySegment::close);
     }
 
     @Override
     public VaList copy() {
-        return WinVaList.ofAddress(ptr);
+        MemorySegment liveness = MemorySegment.ofNativeRestricted(
+                MemoryAddress.NULL, 1, ptr.segment().ownerThread(), null, null);
+        return new WinVaList(ptr, List.of(), liveness);
+    }
+
+    @Override
+    public VaList copy(NativeScope scope) {
+        MemorySegment liveness = MemorySegment.ofNativeRestricted(
+                MemoryAddress.NULL, 1, ptr.segment().ownerThread(), null, null);
+        liveness = scope.register(liveness);
+        return new WinVaList(ptr, List.of(), liveness);
     }
 
     @Override
     public MemoryAddress address() {
         return ptr;
     }
 
     @Override
     public boolean isAlive() {
-        return segment.isAlive();
+        if (livenessCheck != null)
+            return livenessCheck.isAlive();
+        return ptr.segment().isAlive();
     }
 
     static class Builder implements VaList.Builder {
 
+        private final SharedUtils.Allocator allocator;
         private final List<SimpleVaArg> args = new ArrayList<>();
 
+        public Builder(SharedUtils.Allocator allocator) {
+            this.allocator = allocator;
+        }
+
         private Builder arg(Class<?> carrier, MemoryLayout layout, Object value) {
             SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);
             args.add(new SimpleVaArg(carrier, layout, value));
             return this;
         }
@@ -209,23 +231,23 @@
 
         public VaList build() {
             if (args.isEmpty()) {
                 return EMPTY;
             }
-            MemorySegment ms = MemorySegment.allocateNative(VA_SLOT_SIZE_BYTES * args.size());
-            List<MemorySegment> copies = new ArrayList<>();
-
+            MemorySegment ms = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size());
+            List<MemorySegment> attachedSegments = new ArrayList<>();
+            attachedSegments.add(ms);
             MemoryAddress addr = ms.baseAddress();
             for (SimpleVaArg arg : args) {
                 if (arg.carrier == MemorySegment.class) {
                     MemorySegment msArg = ((MemorySegment) arg.value);
                     TypeClass typeClass = TypeClass.typeClassFor(arg.layout);
                     switch (typeClass) {
                         case STRUCT_REFERENCE -> {
-                            MemorySegment copy = MemorySegment.allocateNative(arg.layout);
+                            MemorySegment copy = allocator.allocate(arg.layout);
                             copy.copyFrom(msArg); // by-value
-                            copies.add(copy);
+                            attachedSegments.add(copy);
                             VH_address.set(addr, copy.baseAddress());
                         }
                         case STRUCT_REGISTER -> {
                             MemorySegment slice = ms.asSlice(addr.segmentOffset(), VA_SLOT_SIZE_BYTES);
                             slice.copyFrom(msArg);
@@ -237,9 +259,9 @@
                     writer.set(addr, arg.value);
                 }
                 addr = addr.addOffset(VA_SLOT_SIZE_BYTES);
             }
 
-            return new WinVaList(ms.withAccessModes(CLOSE | READ), copies);
+            return new WinVaList(ms.baseAddress(), attachedSegments, null);
         }
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
@@ -76,12 +76,12 @@
             instance = new Windowsx64Linker();
         }
         return instance;
     }
 
-    public static VaList newVaList(Consumer<VaList.Builder> actions) {
-        WinVaList.Builder builder = WinVaList.builder();
+    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {
+        WinVaList.Builder builder = WinVaList.builder(allocator);
         actions.accept(builder);
         return builder.build();
     }
 
     @Override
diff a/test/jdk/java/foreign/valist/VaListTest.java b/test/jdk/java/foreign/valist/VaListTest.java
--- a/test/jdk/java/foreign/valist/VaListTest.java
+++ b/test/jdk/java/foreign/valist/VaListTest.java
@@ -22,47 +22,66 @@
  *
  */
 
 /*
  * @test
+ * @modules jdk.incubator.foreign/jdk.internal.foreign.abi
+ *          jdk.incubator.foreign/jdk.internal.foreign.abi.aarch64
+ *          jdk.incubator.foreign/jdk.internal.foreign.abi.x64.windows
+ *          jdk.incubator.foreign/jdk.internal.foreign.abi.x64.sysv
  * @run testng/othervm -Dforeign.restricted=permit VaListTest
  */
 
 import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.CSupport.AArch64;
+import jdk.incubator.foreign.CSupport.SysV;
 import jdk.incubator.foreign.CSupport.VaList;
+import jdk.incubator.foreign.CSupport.Win64;
 import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
+import jdk.internal.foreign.abi.SharedUtils;
+import jdk.internal.foreign.abi.aarch64.AArch64Linker;
+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;
+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandleProxies;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.DoubleStream;
+import java.util.stream.IntStream;
 
 import static jdk.incubator.foreign.CSupport.C_DOUBLE;
 import static jdk.incubator.foreign.CSupport.C_FLOAT;
 import static jdk.incubator.foreign.CSupport.C_INT;
 import static jdk.incubator.foreign.CSupport.C_LONGLONG;
 import static jdk.incubator.foreign.CSupport.C_POINTER;
 import static jdk.incubator.foreign.CSupport.C_VA_LIST;
-import static jdk.incubator.foreign.CSupport.Win64.asVarArg;
 import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;
 import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
 
 public class VaListTest {
 
     private static final ForeignLinker abi = CSupport.getSystemLinker();
     private static final LibraryLookup lookup = LibraryLookup.ofLibrary("VaList");
 
-    private static final VarHandle VH_int = C_INT.varHandle(int.class);
-
     private static final MethodHandle MH_sumInts = link("sumInts",
             MethodType.methodType(int.class, int.class, VaList.class),
             FunctionDescriptor.of(C_INT, C_INT, CSupport.C_VA_LIST));
     private static final MethodHandle MH_sumDoubles = link("sumDoubles",
             MethodType.methodType(double.class, int.class, VaList.class),
@@ -81,33 +100,12 @@
             FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
     private static final MethodHandle MH_sumFloatStruct = link("sumFloatStruct",
             MethodType.methodType(float.class, VaList.class),
             FunctionDescriptor.of(C_FLOAT, C_VA_LIST));
     private static final MethodHandle MH_sumStack = link("sumStack",
-            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, int.class,
-                long.class, long.class, long.class, long.class,
-                long.class, long.class, long.class, long.class,
-                long.class, long.class, long.class, long.class,
-                long.class, long.class, long.class, long.class,
-                double.class, double.class, double.class, double.class,
-                double.class, double.class, double.class, double.class,
-                double.class, double.class, double.class, double.class,
-                double.class, double.class, double.class, double.class
-            ),
-            FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT,
-                asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),
-                asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),
-                asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),
-                asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),
-                asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE),
-                asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE),
-                asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE),
-                asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE)
-            ));
-
-    private static final VarHandle VH_long = C_LONGLONG.varHandle(long.class);
-    private static final VarHandle VH_double = C_DOUBLE.varHandle(double.class);
+            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, VaList.class),
+            FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_VA_LIST));
 
     private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {
         try {
             return abi.downcallHandle(lookup.lookup(symbol), mt, fd);
         } catch (NoSuchMethodException e) {
@@ -120,138 +118,390 @@
             MethodType.methodType(void.class, MemoryAddress.class),
             FunctionDescriptor.ofVoid(C_POINTER));
 
     }
 
-    private static final GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(
-        C_LONGLONG.withName("x"),
-        C_LONGLONG.withName("y")
-    );
-    private static final VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement("x"));
-    private static final VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement("y"));
-    private static final GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(
-        C_INT.withName("x"),
-        C_INT.withName("y")
-    );
-    private static final VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement("x"));
-    private static final VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement("y"));
-    private static final GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
-        C_FLOAT.withName("x"),
-        C_FLOAT.withName("y")
-    );
-    private static final VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement("x"));
-    private static final VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement("y"));
-    private static final GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
-        C_LONGLONG.withName("x"),
-        C_LONGLONG.withName("y"),
-        C_LONGLONG.withName("z")
-    );
-    private static final VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement("x"));
-    private static final VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement("y"));
-    private static final VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement("z"));
-
-    @Test
-    public void testIntSum() throws Throwable {
-        try (VaList vaList = VaList.make(b ->
-                b.vargFromInt(C_INT, 10)
-                 .vargFromInt(C_INT, 15)
-                 .vargFromInt(C_INT, 20))) {
-            int x = (int) MH_sumInts.invokeExact(3, vaList);
+    private static final Function<Consumer<VaList.Builder>, VaList> winVaListFactory
+        = actions -> Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);
+    private static final Function<Consumer<VaList.Builder>, VaList> sysvVaListFactory
+        = actions -> SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);
+    private static final Function<Consumer<VaList.Builder>, VaList> aarch64VaListFactory
+        = actions -> AArch64Linker.newVaList(actions, MemorySegment::allocateNative);
+    private static final Function<Consumer<VaList.Builder>, VaList> platformVaListFactory
+        = CSupport.VaList::make;
+
+    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> winVaListScopedFactory
+        = (actions, scope) -> Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
+    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> sysvVaListScopedFactory
+        = (actions, scope) -> SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
+    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> aarch64VaListScopedFactory
+        = (actions, scope) -> AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
+    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> platformVaListScopedFactory
+        = CSupport.VaList::make;
+
+    @DataProvider
+    @SuppressWarnings("unchecked")
+    public static Object[][] sumInts() {
+        Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->
+            (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();
+        BiFunction<Integer, VaList, Integer> sumIntsNative
+            = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
+        return new Object[][]{
+            { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
+            { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
+            { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
+            { platformVaListFactory, sumIntsNative,                        C_INT         },
+        };
+    }
+
+    @Test(dataProvider = "sumInts")
+    public void testIntSum(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                           BiFunction<Integer, VaList, Integer> sumInts,
+                           MemoryLayout intLayout) {
+        try (VaList vaList = vaListFactory.apply(b ->
+                b.vargFromInt(intLayout, 10)
+                 .vargFromInt(intLayout, 15)
+                 .vargFromInt(intLayout, 20))) {
+            int x = sumInts.apply(3, vaList);
             assertEquals(x, 45);
         }
     }
 
-    @Test
-    public void testDoubleSum() throws Throwable {
-        try (VaList vaList = VaList.make(b ->
-                b.vargFromDouble(C_DOUBLE, 3.0D)
-                 .vargFromDouble(C_DOUBLE, 4.0D)
-                 .vargFromDouble(C_DOUBLE, 5.0D))) {
-            double x = (double) MH_sumDoubles.invokeExact(3, vaList);
+    @DataProvider
+    @SuppressWarnings("unchecked")
+    public static Object[][] sumDoubles() {
+        Function<MemoryLayout, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->
+            (num, list) -> DoubleStream.generate(() -> list.vargAsDouble(layout)).limit(num).sum();
+        BiFunction<Integer, VaList, Double> sumDoublesNative
+            = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);
+        return new Object[][]{
+            { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },
+            { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },
+            { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },
+            { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },
+        };
+    }
+
+    @Test(dataProvider = "sumDoubles")
+    public void testDoubleSum(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                              BiFunction<Integer, VaList, Double> sumDoubles,
+                              MemoryLayout doubleLayout) {
+        try (VaList vaList = vaListFactory.apply(b ->
+                b.vargFromDouble(doubleLayout, 3.0D)
+                 .vargFromDouble(doubleLayout, 4.0D)
+                 .vargFromDouble(doubleLayout, 5.0D))) {
+            double x = sumDoubles.apply(3, vaList);
             assertEquals(x, 12.0D);
         }
     }
 
-    @Test
-    public void testVaListMemoryAddress() throws Throwable {
-        try (MemorySegment msInt = MemorySegment.allocateNative(C_INT)) {
-            VH_int.set(msInt.baseAddress(), 10);
-            try (VaList vaList = VaList.make(b -> b.vargFromAddress(C_POINTER, msInt.baseAddress()))) {
-                int x = (int) MH_getInt.invokeExact(vaList);
+    @DataProvider
+    @SuppressWarnings("unchecked")
+    public static Object[][] getInt() {
+        Function<MemoryLayout, Function<VaList, Integer>> getIntJavaFact = layout ->
+            list -> {
+                MemoryAddress ma = list.vargAsAddress(layout);
+                MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,
+                        C_INT.byteSize(), Thread.currentThread(), null, null);
+                return MemoryAccess.getInt(accessibleSegment.baseAddress());
+            };
+        Function<VaList, Integer> getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
+        return new Object[][]{
+            { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
+            { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },
+            { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },
+            { platformVaListFactory, getIntNative,                            C_POINTER         },
+        };
+    }
+
+    @Test(dataProvider = "getInt")
+    public void testVaListMemoryAddress(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                                        Function<VaList, Integer> getInt,
+                                        MemoryLayout pointerLayout) {
+        try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
+            MemoryAccess.setInt(msInt.baseAddress(), 10);
+            try (VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.baseAddress()))) {
+                int x = getInt.apply(vaList);
                 assertEquals(x, 10);
             }
         }
     }
 
-    @Test
-    public void testWinStructByValue() throws Throwable {
+    interface TriFunction<S, T, U, R> {
+        R apply(S s, T t, U u);
+    }
+
+    @DataProvider
+    @SuppressWarnings("unchecked")
+    public static Object[][] winStructByValue() {
+        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact
+            = (pointLayout, VH_Point_x, VH_Point_y) ->
+                list -> {
+                    MemorySegment struct = list.vargAsSegment(pointLayout);
+                    int x = (int) VH_Point_x.get(struct.baseAddress());
+                    int y = (int) VH_Point_y.get(struct.baseAddress());
+                    return x + y;
+                };
+
+        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact
+            = (pointLayout, VH_Point_x, VH_Point_y) ->
+                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);
+
+        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
+                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact
+            = (vaListFact, intLayout, sumStructFact) -> {
+                GroupLayout pointLayout =  MemoryLayout.ofStruct(
+                    intLayout.withName("x"),
+                    intLayout.withName("y")
+                );
+                VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement("x"));
+                VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement("y"));
+                return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),
+                                      pointLayout, VH_Point_x, VH_Point_y  };
+            };
+        return new Object[][]{
+            argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),
+            argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),
+            argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),
+            argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),
+        };
+    }
+
+    @Test(dataProvider = "winStructByValue")
+    public void testWinStructByValue(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                                     Function<VaList, Integer> sumStruct,
+                                     MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
             VH_Point_x.set(struct.baseAddress(), 5);
             VH_Point_y.set(struct.baseAddress(), 10);
 
-            try (VaList vaList = VaList.make(b -> b.vargFromSegment(Point_LAYOUT, struct))) {
-                int sum = (int) MH_sumStruct.invokeExact(vaList);
+            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct))) {
+                int sum = sumStruct.apply(vaList);
                 assertEquals(sum, 15);
             }
         }
     }
 
-    @Test
-    public void testWinStructByReference() throws Throwable {
+    @DataProvider
+    @SuppressWarnings("unchecked")
+    public static Object[][] winStructByReference() {
+        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact
+            = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) ->
+                list -> {
+                    MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
+                    long x = (long) VH_BigPoint_x.get(struct.baseAddress());
+                    long y = (long) VH_BigPoint_y.get(struct.baseAddress());
+                    return x + y;
+                };
+
+        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact
+            = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) ->
+                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);
+
+        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
+                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact
+            = (vaListFact, longLongLayout, sumBigStructFact) -> {
+                GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(
+                    longLongLayout.withName("x"),
+                    longLongLayout.withName("y")
+                );
+                VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement("x"));
+                VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement("y"));
+                return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),
+                                      BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };
+            };
+        return new Object[][]{
+            argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
+            argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
+            argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
+            argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
+        };
+    }
+
+    @Test(dataProvider = "winStructByReference")
+    public void testWinStructByReference(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                                         Function<VaList, Long> sumBigStruct,
+                                         MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
             VH_BigPoint_x.set(struct.baseAddress(), 5);
             VH_BigPoint_y.set(struct.baseAddress(), 10);
 
-            try (VaList vaList = VaList.make(b -> b.vargFromSegment(BigPoint_LAYOUT, struct))) {
-                long sum = (long) MH_sumBigStruct.invokeExact(vaList);
+            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct))) {
+                long sum = sumBigStruct.apply(vaList);
                 assertEquals(sum, 15);
             }
         }
     }
 
-    @Test
-    public void testFloatStructByValue() throws Throwable {
+    @DataProvider
+    @SuppressWarnings("unchecked")
+    public static Object[][] floatStructByValue() {
+        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact
+            = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) ->
+                list -> {
+                    MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
+                    float x = (float) VH_FloatPoint_x.get(struct.baseAddress());
+                    float y = (float) VH_FloatPoint_y.get(struct.baseAddress());
+                    return x + y;
+                };
+
+        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact
+            = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) ->
+                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);
+
+        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
+                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact
+            = (vaListFact, floatLayout, sumFloatStructFact) -> {
+                GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
+                    floatLayout.withName("x"),
+                    floatLayout.withName("y")
+                );
+                VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement("x"));
+                VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement("y"));
+                return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),
+                                      FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };
+            };
+        return new Object[][]{
+            argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),
+            argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),
+            argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),
+            argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),
+        };
+    }
+
+    @Test(dataProvider = "floatStructByValue")
+    public void testFloatStructByValue(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                                       Function<VaList, Float> sumFloatStruct,
+                                       MemoryLayout FloatPoint_LAYOUT,
+                                       VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
             VH_FloatPoint_x.set(struct.baseAddress(), 1.234f);
             VH_FloatPoint_y.set(struct.baseAddress(), 3.142f);
 
-            try (VaList vaList = VaList.make(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
-                float sum = (float) MH_sumFloatStruct.invokeExact(vaList);
+            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
+                float sum = sumFloatStruct.apply(vaList);
                 assertEquals(sum, 4.376f, 0.00001f);
             }
         }
     }
 
-    @Test
-    public void testHugeStructByValue() throws Throwable {
+    interface QuadFunc<T0, T1, T2, T3, R> {
+        R apply(T0 t0, T1 t1, T2 t2, T3 t3);
+    }
+
+    @DataProvider
+    @SuppressWarnings("unchecked")
+    public static Object[][] hugeStructByValue() {
+        QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact
+            = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
+                list -> {
+                    MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
+                    long x = (long) VH_HugePoint_x.get(struct.baseAddress());
+                    long y = (long) VH_HugePoint_y.get(struct.baseAddress());
+                    long z = (long) VH_HugePoint_z.get(struct.baseAddress());
+                    return x + y + z;
+                };
+
+        QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact
+            = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
+                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);
+
+        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
+                QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact
+            = (vaListFact, longLongLayout, sumBigStructFact) -> {
+                GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
+                    longLongLayout.withName("x"),
+                    longLongLayout.withName("y"),
+                    longLongLayout.withName("z")
+                );
+                VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement("x"));
+                VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement("y"));
+                VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement("z"));
+                return new Object[] { vaListFact,
+                                      sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),
+                                      HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };
+            };
+        return new Object[][]{
+            argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
+            argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
+            argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
+            argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
+        };
+    }
+
+    @Test(dataProvider = "hugeStructByValue")
+    public void testHugeStructByValue(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                                      Function<VaList, Long> sumHugeStruct,
+                                      MemoryLayout HugePoint_LAYOUT,
+                                      VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
         // On AArch64 a struct needs to be larger than 16 bytes to be
         // passed by reference.
         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
             VH_HugePoint_x.set(struct.baseAddress(), 1);
             VH_HugePoint_y.set(struct.baseAddress(), 2);
             VH_HugePoint_z.set(struct.baseAddress(), 3);
 
-            try (VaList vaList = VaList.make(b -> b.vargFromSegment(HugePoint_LAYOUT, struct))) {
-                long sum = (long) MH_sumHugeStruct.invokeExact(vaList);
+            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct))) {
+                long sum = sumHugeStruct.apply(vaList);
                 assertEquals(sum, 6);
             }
         }
     }
 
-    @Test
-    public void testStack() throws Throwable {
-       try (MemorySegment longSum = MemorySegment.allocateNative(C_LONGLONG);
-            MemorySegment doubleSum = MemorySegment.allocateNative(C_DOUBLE)) {
-            VH_long.set(longSum.baseAddress(), 0L);
-            VH_double.set(doubleSum.baseAddress(), 0D);
+    public interface SumStackFunc {
+        void invoke(MemoryAddress longSum, MemoryAddress doubleSum, VaList list);
+    }
 
-            MH_sumStack.invokeExact(longSum.baseAddress(), doubleSum.baseAddress(), 32,
-                1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L,
-                1D, 2D, 3D, 4D, 5D, 6D, 7D, 8D, 9D, 10D, 11D, 12D, 13D, 14D, 15D, 16D);
+    @DataProvider
+    public static Object[][] sumStack() {
+        BiFunction<MemoryLayout, MemoryLayout, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->
+            (longSum, doubleSum, list) -> {
+                long lSum = 0L;
+                for (int i = 0; i < 16; i++) {
+                    lSum += list.vargAsLong(longLayout);
+                }
+                MemoryAccess.setLong(longSum, lSum);
+                double dSum = 0D;
+                for (int i = 0; i < 16; i++) {
+                    dSum += list.vargAsDouble(doubleLayout);
+                }
+                MemoryAccess.setDouble(doubleSum, dSum);
+            };
+        SumStackFunc sumStackNative = MethodHandleProxies.asInterfaceInstance(SumStackFunc.class, MH_sumStack);
+        return new Object[][]{
+            { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },
+            { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },
+            { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },
+            { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },
+        };
+    }
 
-            long lSum = (long) VH_long.get(longSum.baseAddress());
-            double dSum = (double) VH_double.get(doubleSum.baseAddress());
+    @Test(dataProvider = "sumStack")
+    public void testStack(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                          SumStackFunc sumStack,
+                          MemoryLayout longLayout,
+                          MemoryLayout doubleLayout) {
+       try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);
+            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {
+            MemoryAccess.setLong(longSum.baseAddress(), 0L);
+            MemoryAccess.setDouble(doubleSum.baseAddress(), 0D);
+
+            VaList list = vaListFactory.apply(b -> {
+                for (long l = 1; l <= 16L; l++) {
+                    b.vargFromLong(longLayout, l);
+                }
+                for (double d = 1; d <= 16D; d++) {
+                    b.vargFromDouble(doubleLayout, d);
+                }
+            });
+
+            try (list) {
+                sumStack.invoke(longSum.baseAddress(), doubleSum.baseAddress(), list);
+            }
+
+            long lSum = MemoryAccess.getLong(longSum.baseAddress());
+            double dSum = MemoryAccess.getDouble(doubleSum.baseAddress());
 
             assertEquals(lSum, 136L);
             assertEquals(dSum, 136D);
         }
     }
@@ -262,26 +512,180 @@
         try (MemorySegment stub = abi.upcallStub(callback, desc)) {
             target.invokeExact(stub.baseAddress());
         }
     }
 
-    @Test(expectedExceptions = UnsupportedOperationException.class,
-          expectedExceptionsMessageRegExp = ".*Empty VaList.*")
-    public void testEmptyNotCloseable() {
-        VaList list = VaList.empty();
-        list.close();
+    @DataProvider
+    public Object[][] emptyVaLists() {
+        return new Object[][] {
+            { Windowsx64Linker.emptyVaList()      },
+            { winVaListFactory.apply(b -> {})     },
+            { SysVx64Linker.emptyVaList()         },
+            { sysvVaListFactory.apply(b -> {})    },
+            { AArch64Linker.emptyVaList()         },
+            { aarch64VaListFactory.apply(b -> {}) },
+        };
     }
 
     @Test(expectedExceptions = UnsupportedOperationException.class,
-          expectedExceptionsMessageRegExp = ".*Empty VaList.*")
-    public void testEmptyVaListFromBuilderNotCloseable() {
-        VaList list = VaList.make(b -> {});
-        list.close();
+          expectedExceptionsMessageRegExp = ".*Empty VaList.*",
+          dataProvider = "emptyVaLists")
+    public void testEmptyNotCloseable(VaList emptyList) {
+        emptyList.close();
+    }
+
+    @DataProvider
+    @SuppressWarnings("unchecked")
+    public static Object[][] sumIntsScoped() {
+        Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->
+            (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();
+        BiFunction<Integer, VaList, Integer> sumIntsNative
+            = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
+        return new Object[][]{
+            { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
+            { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
+            { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
+            { platformVaListScopedFactory, sumIntsNative,                        C_INT         },
+        };
+    }
+
+    @Test(dataProvider = "sumIntsScoped")
+    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> vaListFactory,
+                                 BiFunction<Integer, VaList, Integer> sumInts,
+                                 MemoryLayout intLayout) {
+        VaList listLeaked;
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
+                                                    .vargFromInt(intLayout, 8),
+                                               scope);
+            int x = sumInts.apply(2, list);
+            assertEquals(x, 12);
+            listLeaked = list;
+        }
+        assertFalse(listLeaked.isAlive());
+    }
+
+    @Test(dataProvider = "winStructByValue")
+    public void testScopeMSRead(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                                Function<VaList, Integer> sumStruct, // ignored
+                                MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
+        MemorySegment pointOut;
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
+                VH_Point_x.set(pointIn.baseAddress(), 3);
+                VH_Point_y.set(pointIn.baseAddress(), 6);
+                try (VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn))) {
+                    pointOut = list.vargAsSegment(Point_LAYOUT, scope);
+                    assertEquals((int) VH_Point_x.get(pointOut.baseAddress()), 3);
+                    assertEquals((int) VH_Point_y.get(pointOut.baseAddress()), 6);
+                }
+                assertTrue(pointOut.isAlive()); // after VaList freed
+            }
+            assertTrue(pointOut.isAlive()); // after input MS freed
+        }
+        assertFalse(pointOut.isAlive()); // after scope freed
+    }
+
+    @DataProvider
+    public Object[][] copy() {
+        return new Object[][] {
+            { winVaListFactory,      Win64.C_INT   },
+            { sysvVaListFactory,     SysV.C_INT    },
+            { aarch64VaListFactory,  AArch64.C_INT },
+        };
+    }
+
+    @Test(dataProvider = "copy")
+    public void testCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, MemoryLayout intLayout) {
+        try (VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
+                                                     .vargFromInt(intLayout, 8))) {
+            VaList  copy = list.copy();
+            assertEquals(copy.vargAsInt(intLayout), 4);
+            assertEquals(copy.vargAsInt(intLayout), 8);
+            copy.close();
+
+            assertFalse(copy.isAlive());
+
+            assertEquals(list.vargAsInt(intLayout), 4);
+            assertEquals(list.vargAsInt(intLayout), 8);
+        }
+    }
+
+    @Test(dataProvider = "copy")
+    public void testScopedCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, MemoryLayout intLayout) {
+        try (VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
+                                                     .vargFromInt(intLayout, 8))) {
+            VaList copy;
+            try (NativeScope scope = NativeScope.unboundedScope()) {
+                copy = list.copy(scope);
+
+                assertEquals(copy.vargAsInt(intLayout), 4);
+                assertEquals(copy.vargAsInt(intLayout), 8);
+            }
+            assertFalse(copy.isAlive());
+
+            assertEquals(list.vargAsInt(intLayout), 4);
+            assertEquals(list.vargAsInt(intLayout), 8);
+        }
+    }
+
+    @Test(dataProvider = "copy",
+          expectedExceptions = IllegalStateException.class)
+    public void testCopyUnusableAfterOriginalClosed(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                                                    MemoryLayout intLayout) {
+        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
+                                                .vargFromInt(intLayout, 8));
+        try (VaList copy = list.copy()) {
+            list.close();
+
+            copy.vargAsInt(intLayout); // should throw
+        }
+    }
+
+    @Test(dataProvider = "copy",
+          expectedExceptions = IllegalStateException.class)
+    public void testCopyUnusableAfterOriginalClosedScope(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
+                                                         MemoryLayout intLayout) {
+        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
+                                                .vargFromInt(intLayout, 8));
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            VaList copy = list.copy(scope);
+            list.close();
+
+            copy.vargAsInt(intLayout); // should throw
+        }
     }
 
     @DataProvider
     public static Object[][] upcalls() {
+        GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(
+            C_LONGLONG.withName("x"),
+            C_LONGLONG.withName("y")
+        );
+        VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement("x"));
+        VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement("y"));
+        GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(
+            C_INT.withName("x"),
+            C_INT.withName("y")
+        );
+        VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement("x"));
+        VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement("y"));
+        GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
+            C_FLOAT.withName("x"),
+            C_FLOAT.withName("y")
+        );
+        VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement("x"));
+        VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement("y"));
+        GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
+            C_LONGLONG.withName("x"),
+            C_LONGLONG.withName("y"),
+            C_LONGLONG.withName("z")
+        );
+        VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement("x"));
+        VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement("y"));
+        VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement("z"));
+
         return new Object[][]{
             { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
                     assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);
@@ -324,11 +728,11 @@
             })},
             { linkVaListCB("upcallMemoryAddress"), VaListConsumer.mh(vaList -> {
                 MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
                 MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
                                                                     Thread.currentThread(), null, null);
-                int x = (int) VH_int.get(ms.baseAddress());
+                int x = MemoryAccess.getInt(ms.baseAddress());
                 assertEquals(x, 10);
             })},
             { linkVaListCB("upcallDoubles"), VaListConsumer.mh(vaList -> {
                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
@@ -339,42 +743,16 @@
                 assertEquals(vaList.vargAsInt(C_INT), 15);
                 assertEquals(vaList.vargAsInt(C_INT), 20);
             })},
             { linkVaListCB("upcallStack"), VaListConsumer.mh(vaList -> {
                 // skip all registers
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 1L); // 1st windows arg read from shadow space
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 2L); // 2nd windows arg read from shadow space
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 3L); // windows 1st stack arg (int/float)
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 4L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 6L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 7L); // sysv 1st int stack arg
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 8L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 9L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 11L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 13L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 14L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 15L);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 16L);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 2.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 8.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 9.0D); // sysv 1st float stack arg
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 10.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 11.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 12.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 13.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 15.0D);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 16.0D);
+                for (long l = 1; l <= 16; l++) {
+                    assertEquals(vaList.vargAsLong(C_LONGLONG), l);
+                }
+                for (double d = 1; d <= 16; d++) {
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), d);
+                }
 
                 // test some arbitrary values on the stack
                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
                 assertEquals((char) vaList.vargAsInt(C_INT), 'a');
                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
diff a/test/jdk/java/foreign/valist/libVaList.c b/test/jdk/java/foreign/valist/libVaList.c
--- a/test/jdk/java/foreign/valist/libVaList.c
+++ b/test/jdk/java/foreign/valist/libVaList.c
@@ -92,24 +92,21 @@
 EXPORT float sumFloatStruct(va_list list) {
     FloatPoint point = va_arg(list, FloatPoint);
     return point.x + point.y;
 }
 
-EXPORT void sumStack(long long* longSum, double* doubleSum, int numArgs, ...) { // numArgs required by spec
-    va_list list;
-    va_start(list, numArgs);
+EXPORT void sumStack(long long* longSum, double* doubleSum, va_list list) {
     long long lSum = 0;
     for (int i = 0; i < 16; i++) {
         lSum += va_arg(list, long long);
     }
     *longSum = lSum;
     double dSum = 0.0;
     for (int i = 0; i < 16; i++) {
         dSum += va_arg(list, double);
     }
     *doubleSum = dSum;
-    va_end(list);
 }
 
 // ###### Up calls
 
 typedef void CB(va_list);

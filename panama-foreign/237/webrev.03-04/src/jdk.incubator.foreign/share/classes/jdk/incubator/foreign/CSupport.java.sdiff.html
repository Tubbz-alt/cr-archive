<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/abi/x64/windows/WinVaList.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
145          *
146          * @param layouts the layout of the value
147          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
148          * (see {@link #close()}).
149          */
150         void skip(MemoryLayout... layouts);
151 
152         /**
153          * A predicate used to check if the memory associated with the C {@code va_list} modelled
154          * by this instance is still valid to use.
155          *
156          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
157          * @see #close()
158          */
159         boolean isAlive();
160 
161         /**
162          * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached
163          * to this va list that holds its elements (see {@link VaList#make(Consumer)}).
164          * &lt;p&gt;
<span class="line-modified">165          * For some {@code VaList} instances, calling this method will have no effect. For instance: on Windows, a copy</span>
<span class="line-modified">166          * of a va list does not need any native memory, so nothing has to be released. After calling {@code close()} on</span>
<span class="line-removed">167          * such an instance {@link #isAlive()} will still return {@code true}.</span>
168          *
169          * @see #isAlive()
170          */
171         void close();
172 
173         /**
174          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
175          * starting from the current position, without affecting the state of the original va list, essentially
176          * allowing the elements to be traversed multiple times.
177          * &lt;p&gt;
178          * If this method needs to allocate native memory for the copy, it will use
179          * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the
180          * returned va list instance to release the allocated memory.
181          * &lt;p&gt;
182          * This method only copies the va list cursor itself and not the memory that may be attached to the
183          * va list which holds its elements. That means that if this va list was created with the
184          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
185          * elements, making the copy unusable.
186          *
187          * @return a copy of this C {@code va_list}.
</pre>
</td>
<td>
<hr />
<pre>
145          *
146          * @param layouts the layout of the value
147          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
148          * (see {@link #close()}).
149          */
150         void skip(MemoryLayout... layouts);
151 
152         /**
153          * A predicate used to check if the memory associated with the C {@code va_list} modelled
154          * by this instance is still valid to use.
155          *
156          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
157          * @see #close()
158          */
159         boolean isAlive();
160 
161         /**
162          * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached
163          * to this va list that holds its elements (see {@link VaList#make(Consumer)}).
164          * &lt;p&gt;
<span class="line-modified">165          * After calling this method, {@link #isAlive()} will return {@code false} and further attempts to read values</span>
<span class="line-modified">166          * from this va list will result in an exception.</span>

167          *
168          * @see #isAlive()
169          */
170         void close();
171 
172         /**
173          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
174          * starting from the current position, without affecting the state of the original va list, essentially
175          * allowing the elements to be traversed multiple times.
176          * &lt;p&gt;
177          * If this method needs to allocate native memory for the copy, it will use
178          * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the
179          * returned va list instance to release the allocated memory.
180          * &lt;p&gt;
181          * This method only copies the va list cursor itself and not the memory that may be attached to the
182          * va list which holds its elements. That means that if this va list was created with the
183          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
184          * elements, making the copy unusable.
185          *
186          * @return a copy of this C {@code va_list}.
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/abi/x64/windows/WinVaList.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
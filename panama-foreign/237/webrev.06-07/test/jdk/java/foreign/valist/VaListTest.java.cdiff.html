<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/foreign/valist/VaListTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../index.html" target="_top">index</a> <a href="libVaList.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/valist/VaListTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,66 ***</span>
   *
   */
  
  /*
   * @test
<span class="line-removed">-  * @modules jdk.incubator.foreign/jdk.internal.foreign.abi</span>
<span class="line-removed">-  *          jdk.incubator.foreign/jdk.internal.foreign.abi.aarch64</span>
<span class="line-removed">-  *          jdk.incubator.foreign/jdk.internal.foreign.abi.x64.windows</span>
<span class="line-removed">-  *          jdk.incubator.foreign/jdk.internal.foreign.abi.x64.sysv</span>
   * @run testng/othervm -Dforeign.restricted=permit VaListTest
   */
  
  import jdk.incubator.foreign.CSupport;
<span class="line-removed">- import jdk.incubator.foreign.CSupport.AArch64;</span>
<span class="line-removed">- import jdk.incubator.foreign.CSupport.SysV;</span>
  import jdk.incubator.foreign.CSupport.VaList;
<span class="line-removed">- import jdk.incubator.foreign.CSupport.Win64;</span>
  import jdk.incubator.foreign.ForeignLinker;
  import jdk.incubator.foreign.FunctionDescriptor;
  import jdk.incubator.foreign.GroupLayout;
  import jdk.incubator.foreign.LibraryLookup;
<span class="line-removed">- import jdk.incubator.foreign.MemoryAccess;</span>
  import jdk.incubator.foreign.MemoryAddress;
  import jdk.incubator.foreign.MemoryLayout;
  import jdk.incubator.foreign.MemorySegment;
  import jdk.incubator.foreign.NativeScope;
<span class="line-removed">- import jdk.internal.foreign.abi.SharedUtils;</span>
<span class="line-removed">- import jdk.internal.foreign.abi.aarch64.AArch64Linker;</span>
<span class="line-removed">- import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;</span>
<span class="line-removed">- import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;</span>
  import org.testng.annotations.DataProvider;
  import org.testng.annotations.Test;
  
  import java.lang.invoke.MethodHandle;
<span class="line-removed">- import java.lang.invoke.MethodHandleProxies;</span>
  import java.lang.invoke.MethodHandles;
  import java.lang.invoke.MethodType;
  import java.lang.invoke.VarHandle;
<span class="line-removed">- import java.util.function.BiFunction;</span>
<span class="line-removed">- import java.util.function.Consumer;</span>
<span class="line-removed">- import java.util.function.Function;</span>
<span class="line-removed">- import java.util.stream.DoubleStream;</span>
<span class="line-removed">- import java.util.stream.IntStream;</span>
  
  import static jdk.incubator.foreign.CSupport.C_DOUBLE;
  import static jdk.incubator.foreign.CSupport.C_FLOAT;
  import static jdk.incubator.foreign.CSupport.C_INT;
  import static jdk.incubator.foreign.CSupport.C_LONGLONG;
  import static jdk.incubator.foreign.CSupport.C_POINTER;
  import static jdk.incubator.foreign.CSupport.C_VA_LIST;
  import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
<span class="line-removed">- import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;</span>
  import static org.testng.Assert.assertEquals;
  import static org.testng.Assert.assertFalse;
  import static org.testng.Assert.assertTrue;
  
  public class VaListTest {
  
      private static final ForeignLinker abi = CSupport.getSystemLinker();
      private static final LibraryLookup lookup = LibraryLookup.ofLibrary(&quot;VaList&quot;);
  
      private static final MethodHandle MH_sumInts = link(&quot;sumInts&quot;,
              MethodType.methodType(int.class, int.class, VaList.class),
              FunctionDescriptor.of(C_INT, C_INT, CSupport.C_VA_LIST));
      private static final MethodHandle MH_sumDoubles = link(&quot;sumDoubles&quot;,
              MethodType.methodType(double.class, int.class, VaList.class),
<span class="line-new-header">--- 22,50 ---</span>
   *
   */
  
  /*
   * @test
   * @run testng/othervm -Dforeign.restricted=permit VaListTest
   */
  
  import jdk.incubator.foreign.CSupport;
  import jdk.incubator.foreign.CSupport.VaList;
  import jdk.incubator.foreign.ForeignLinker;
  import jdk.incubator.foreign.FunctionDescriptor;
  import jdk.incubator.foreign.GroupLayout;
  import jdk.incubator.foreign.LibraryLookup;
  import jdk.incubator.foreign.MemoryAddress;
  import jdk.incubator.foreign.MemoryLayout;
  import jdk.incubator.foreign.MemorySegment;
  import jdk.incubator.foreign.NativeScope;
  import org.testng.annotations.DataProvider;
  import org.testng.annotations.Test;
  
  import java.lang.invoke.MethodHandle;
  import java.lang.invoke.MethodHandles;
  import java.lang.invoke.MethodType;
  import java.lang.invoke.VarHandle;
  
  import static jdk.incubator.foreign.CSupport.C_DOUBLE;
  import static jdk.incubator.foreign.CSupport.C_FLOAT;
  import static jdk.incubator.foreign.CSupport.C_INT;
  import static jdk.incubator.foreign.CSupport.C_LONGLONG;
  import static jdk.incubator.foreign.CSupport.C_POINTER;
  import static jdk.incubator.foreign.CSupport.C_VA_LIST;
<span class="line-added">+ import static jdk.incubator.foreign.CSupport.Win64.asVarArg;</span>
  import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
  import static org.testng.Assert.assertEquals;
  import static org.testng.Assert.assertFalse;
  import static org.testng.Assert.assertTrue;
  
  public class VaListTest {
  
      private static final ForeignLinker abi = CSupport.getSystemLinker();
      private static final LibraryLookup lookup = LibraryLookup.ofLibrary(&quot;VaList&quot;);
  
<span class="line-added">+     private static final VarHandle VH_int = C_INT.varHandle(int.class);</span>
<span class="line-added">+ </span>
      private static final MethodHandle MH_sumInts = link(&quot;sumInts&quot;,
              MethodType.methodType(int.class, int.class, VaList.class),
              FunctionDescriptor.of(C_INT, C_INT, CSupport.C_VA_LIST));
      private static final MethodHandle MH_sumDoubles = link(&quot;sumDoubles&quot;,
              MethodType.methodType(double.class, int.class, VaList.class),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,12 ***</span>
              FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
      private static final MethodHandle MH_sumFloatStruct = link(&quot;sumFloatStruct&quot;,
              MethodType.methodType(float.class, VaList.class),
              FunctionDescriptor.of(C_FLOAT, C_VA_LIST));
      private static final MethodHandle MH_sumStack = link(&quot;sumStack&quot;,
<span class="line-modified">!             MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, VaList.class),</span>
<span class="line-modified">!             FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_VA_LIST));</span>
  
      private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {
          try {
              return abi.downcallHandle(lookup.lookup(symbol), mt, fd);
          } catch (NoSuchMethodException e) {
<span class="line-new-header">--- 84,33 ---</span>
              FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
      private static final MethodHandle MH_sumFloatStruct = link(&quot;sumFloatStruct&quot;,
              MethodType.methodType(float.class, VaList.class),
              FunctionDescriptor.of(C_FLOAT, C_VA_LIST));
      private static final MethodHandle MH_sumStack = link(&quot;sumStack&quot;,
<span class="line-modified">!             MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, int.class,</span>
<span class="line-modified">!                 long.class, long.class, long.class, long.class,</span>
<span class="line-added">+                 long.class, long.class, long.class, long.class,</span>
<span class="line-added">+                 long.class, long.class, long.class, long.class,</span>
<span class="line-added">+                 long.class, long.class, long.class, long.class,</span>
<span class="line-added">+                 double.class, double.class, double.class, double.class,</span>
<span class="line-added">+                 double.class, double.class, double.class, double.class,</span>
<span class="line-added">+                 double.class, double.class, double.class, double.class,</span>
<span class="line-added">+                 double.class, double.class, double.class, double.class</span>
<span class="line-added">+             ),</span>
<span class="line-added">+             FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT,</span>
<span class="line-added">+                 asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),</span>
<span class="line-added">+                 asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),</span>
<span class="line-added">+                 asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),</span>
<span class="line-added">+                 asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),</span>
<span class="line-added">+                 asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE),</span>
<span class="line-added">+                 asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE),</span>
<span class="line-added">+                 asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE),</span>
<span class="line-added">+                 asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE)</span>
<span class="line-added">+             ));</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final VarHandle VH_long = C_LONGLONG.varHandle(long.class);</span>
<span class="line-added">+     private static final VarHandle VH_double = C_DOUBLE.varHandle(double.class);</span>
  
      private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {
          try {
              return abi.downcallHandle(lookup.lookup(symbol), mt, fd);
          } catch (NoSuchMethodException e) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,390 ***</span>
              MethodType.methodType(void.class, MemoryAddress.class),
              FunctionDescriptor.ofVoid(C_POINTER));
  
      }
  
<span class="line-modified">!     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; winVaListFactory</span>
<span class="line-modified">!         = actions -&gt; Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
<span class="line-modified">!     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; sysvVaListFactory</span>
<span class="line-modified">!         = actions -&gt; SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
<span class="line-modified">!     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; aarch64VaListFactory</span>
<span class="line-modified">!         = actions -&gt; AArch64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
<span class="line-modified">!     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; platformVaListFactory</span>
<span class="line-modified">!         = CSupport.VaList::make;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; winVaListScopedFactory</span>
<span class="line-modified">!         = (actions, scope) -&gt; Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
<span class="line-modified">!     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; sysvVaListScopedFactory</span>
<span class="line-modified">!         = (actions, scope) -&gt; SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
<span class="line-modified">!     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; aarch64VaListScopedFactory</span>
<span class="line-modified">!         = (actions, scope) -&gt; AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
<span class="line-modified">!     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; platformVaListScopedFactory</span>
<span class="line-modified">!         = CSupport.VaList::make;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     @DataProvider</span>
<span class="line-modified">!     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">!     public static Object[][] sumInts() {</span>
<span class="line-modified">!         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;</span>
<span class="line-modified">!             (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
<span class="line-modified">!         BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative</span>
<span class="line-modified">!             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
<span class="line-modified">!         return new Object[][]{</span>
<span class="line-modified">!             { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-modified">!             { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-modified">!             { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-modified">!             { platformVaListFactory, sumIntsNative,                        C_INT         },</span>
<span class="line-modified">!         };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     @Test(dataProvider = &quot;sumInts&quot;)</span>
<span class="line-removed">-     public void testIntSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-removed">-                            BiFunction&lt;Integer, VaList, Integer&gt; sumInts,</span>
<span class="line-removed">-                            MemoryLayout intLayout) {</span>
<span class="line-removed">-         try (VaList vaList = vaListFactory.apply(b -&gt;</span>
<span class="line-removed">-                 b.vargFromInt(intLayout, 10)</span>
<span class="line-removed">-                  .vargFromInt(intLayout, 15)</span>
<span class="line-removed">-                  .vargFromInt(intLayout, 20))) {</span>
<span class="line-removed">-             int x = sumInts.apply(3, vaList);</span>
              assertEquals(x, 45);
          }
      }
  
<span class="line-modified">!     @DataProvider</span>
<span class="line-modified">!     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">!     public static Object[][] sumDoubles() {</span>
<span class="line-modified">!         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Double&gt;&gt; sumDoublesJavaFact  = layout -&gt;</span>
<span class="line-modified">!             (num, list) -&gt; DoubleStream.generate(() -&gt; list.vargAsDouble(layout)).limit(num).sum();</span>
<span class="line-modified">!         BiFunction&lt;Integer, VaList, Double&gt; sumDoublesNative</span>
<span class="line-modified">!             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);</span>
<span class="line-removed">-         return new Object[][]{</span>
<span class="line-removed">-             { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },</span>
<span class="line-removed">-             { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },</span>
<span class="line-removed">-             { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },</span>
<span class="line-removed">-             { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @Test(dataProvider = &quot;sumDoubles&quot;)</span>
<span class="line-removed">-     public void testDoubleSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-removed">-                               BiFunction&lt;Integer, VaList, Double&gt; sumDoubles,</span>
<span class="line-removed">-                               MemoryLayout doubleLayout) {</span>
<span class="line-removed">-         try (VaList vaList = vaListFactory.apply(b -&gt;</span>
<span class="line-removed">-                 b.vargFromDouble(doubleLayout, 3.0D)</span>
<span class="line-removed">-                  .vargFromDouble(doubleLayout, 4.0D)</span>
<span class="line-removed">-                  .vargFromDouble(doubleLayout, 5.0D))) {</span>
<span class="line-removed">-             double x = sumDoubles.apply(3, vaList);</span>
              assertEquals(x, 12.0D);
          }
      }
  
<span class="line-modified">!     @DataProvider</span>
<span class="line-modified">!     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">!     public static Object[][] getInt() {</span>
<span class="line-modified">!         Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;</span>
<span class="line-modified">!             list -&gt; {</span>
<span class="line-modified">!                 MemoryAddress ma = list.vargAsAddress(layout);</span>
<span class="line-removed">-                 MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,</span>
<span class="line-removed">-                         C_INT.byteSize(), Thread.currentThread(), null, null);</span>
<span class="line-removed">-                 return MemoryAccess.getInt(accessibleSegment.baseAddress());</span>
<span class="line-removed">-             };</span>
<span class="line-removed">-         Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);</span>
<span class="line-removed">-         return new Object[][]{</span>
<span class="line-removed">-             { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },</span>
<span class="line-removed">-             { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },</span>
<span class="line-removed">-             { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },</span>
<span class="line-removed">-             { platformVaListFactory, getIntNative,                            C_POINTER         },</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @Test(dataProvider = &quot;getInt&quot;)</span>
<span class="line-removed">-     public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-removed">-                                         Function&lt;VaList, Integer&gt; getInt,</span>
<span class="line-removed">-                                         MemoryLayout pointerLayout) {</span>
<span class="line-removed">-         try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {</span>
<span class="line-removed">-             MemoryAccess.setInt(msInt.baseAddress(), 10);</span>
<span class="line-removed">-             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.baseAddress()))) {</span>
<span class="line-removed">-                 int x = getInt.apply(vaList);</span>
                  assertEquals(x, 10);
              }
          }
      }
  
<span class="line-modified">!     interface TriFunction&lt;S, T, U, R&gt; {</span>
<span class="line-modified">!         R apply(S s, T t, U u);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @DataProvider</span>
<span class="line-removed">-     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">-     public static Object[][] winStructByValue() {</span>
<span class="line-removed">-         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact</span>
<span class="line-removed">-             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
<span class="line-removed">-                 list -&gt; {</span>
<span class="line-removed">-                     MemorySegment struct = list.vargAsSegment(pointLayout);</span>
<span class="line-removed">-                     int x = (int) VH_Point_x.get(struct.baseAddress());</span>
<span class="line-removed">-                     int y = (int) VH_Point_y.get(struct.baseAddress());</span>
<span class="line-removed">-                     return x + y;</span>
<span class="line-removed">-                 };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructNativeFact</span>
<span class="line-removed">-             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
<span class="line-removed">-                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,</span>
<span class="line-removed">-                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt;, Object[]&gt; argsFact</span>
<span class="line-removed">-             = (vaListFact, intLayout, sumStructFact) -&gt; {</span>
<span class="line-removed">-                 GroupLayout pointLayout =  MemoryLayout.ofStruct(</span>
<span class="line-removed">-                     intLayout.withName(&quot;x&quot;),</span>
<span class="line-removed">-                     intLayout.withName(&quot;y&quot;)</span>
<span class="line-removed">-                 );</span>
<span class="line-removed">-                 VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(&quot;x&quot;));</span>
<span class="line-removed">-                 VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(&quot;y&quot;));</span>
<span class="line-removed">-                 return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),</span>
<span class="line-removed">-                                       pointLayout, VH_Point_x, VH_Point_y  };</span>
<span class="line-removed">-             };</span>
<span class="line-removed">-         return new Object[][]{</span>
<span class="line-removed">-             argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @Test(dataProvider = &quot;winStructByValue&quot;)</span>
<span class="line-removed">-     public void testWinStructByValue(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-removed">-                                      Function&lt;VaList, Integer&gt; sumStruct,</span>
<span class="line-removed">-                                      MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
              VH_Point_x.set(struct.baseAddress(), 5);
              VH_Point_y.set(struct.baseAddress(), 10);
  
<span class="line-modified">!             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {</span>
<span class="line-modified">!                 int sum = sumStruct.apply(vaList);</span>
                  assertEquals(sum, 15);
              }
          }
      }
  
<span class="line-modified">!     @DataProvider</span>
<span class="line-modified">!     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">-     public static Object[][] winStructByReference() {</span>
<span class="line-removed">-         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact</span>
<span class="line-removed">-             = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
<span class="line-removed">-                 list -&gt; {</span>
<span class="line-removed">-                     MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);</span>
<span class="line-removed">-                     long x = (long) VH_BigPoint_x.get(struct.baseAddress());</span>
<span class="line-removed">-                     long y = (long) VH_BigPoint_y.get(struct.baseAddress());</span>
<span class="line-removed">-                     return x + y;</span>
<span class="line-removed">-                 };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact</span>
<span class="line-removed">-             = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
<span class="line-removed">-                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,</span>
<span class="line-removed">-                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact</span>
<span class="line-removed">-             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-removed">-                 GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(</span>
<span class="line-removed">-                     longLongLayout.withName(&quot;x&quot;),</span>
<span class="line-removed">-                     longLongLayout.withName(&quot;y&quot;)</span>
<span class="line-removed">-                 );</span>
<span class="line-removed">-                 VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-removed">-                 VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-removed">-                 return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),</span>
<span class="line-removed">-                                       BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };</span>
<span class="line-removed">-             };</span>
<span class="line-removed">-         return new Object[][]{</span>
<span class="line-removed">-             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @Test(dataProvider = &quot;winStructByReference&quot;)</span>
<span class="line-removed">-     public void testWinStructByReference(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-removed">-                                          Function&lt;VaList, Long&gt; sumBigStruct,</span>
<span class="line-removed">-                                          MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
              VH_BigPoint_x.set(struct.baseAddress(), 5);
              VH_BigPoint_y.set(struct.baseAddress(), 10);
  
<span class="line-modified">!             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {</span>
<span class="line-modified">!                 long sum = sumBigStruct.apply(vaList);</span>
                  assertEquals(sum, 15);
              }
          }
      }
  
<span class="line-modified">!     @DataProvider</span>
<span class="line-modified">!     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">-     public static Object[][] floatStructByValue() {</span>
<span class="line-removed">-         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact</span>
<span class="line-removed">-             = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
<span class="line-removed">-                 list -&gt; {</span>
<span class="line-removed">-                     MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);</span>
<span class="line-removed">-                     float x = (float) VH_FloatPoint_x.get(struct.baseAddress());</span>
<span class="line-removed">-                     float y = (float) VH_FloatPoint_y.get(struct.baseAddress());</span>
<span class="line-removed">-                     return x + y;</span>
<span class="line-removed">-                 };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructNativeFact</span>
<span class="line-removed">-             = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
<span class="line-removed">-                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,</span>
<span class="line-removed">-                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt;, Object[]&gt; argsFact</span>
<span class="line-removed">-             = (vaListFact, floatLayout, sumFloatStructFact) -&gt; {</span>
<span class="line-removed">-                 GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-removed">-                     floatLayout.withName(&quot;x&quot;),</span>
<span class="line-removed">-                     floatLayout.withName(&quot;y&quot;)</span>
<span class="line-removed">-                 );</span>
<span class="line-removed">-                 VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));</span>
<span class="line-removed">-                 VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));</span>
<span class="line-removed">-                 return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),</span>
<span class="line-removed">-                                       FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };</span>
<span class="line-removed">-             };</span>
<span class="line-removed">-         return new Object[][]{</span>
<span class="line-removed">-             argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @Test(dataProvider = &quot;floatStructByValue&quot;)</span>
<span class="line-removed">-     public void testFloatStructByValue(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-removed">-                                        Function&lt;VaList, Float&gt; sumFloatStruct,</span>
<span class="line-removed">-                                        MemoryLayout FloatPoint_LAYOUT,</span>
<span class="line-removed">-                                        VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
              VH_FloatPoint_x.set(struct.baseAddress(), 1.234f);
              VH_FloatPoint_y.set(struct.baseAddress(), 3.142f);
  
<span class="line-modified">!             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {</span>
<span class="line-modified">!                 float sum = sumFloatStruct.apply(vaList);</span>
                  assertEquals(sum, 4.376f, 0.00001f);
              }
          }
      }
  
<span class="line-modified">!     interface QuadFunc&lt;T0, T1, T2, T3, R&gt; {</span>
<span class="line-modified">!         R apply(T0 t0, T1 t1, T2 t2, T3 t3);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @DataProvider</span>
<span class="line-removed">-     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">-     public static Object[][] hugeStructByValue() {</span>
<span class="line-removed">-         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact</span>
<span class="line-removed">-             = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
<span class="line-removed">-                 list -&gt; {</span>
<span class="line-removed">-                     MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);</span>
<span class="line-removed">-                     long x = (long) VH_HugePoint_x.get(struct.baseAddress());</span>
<span class="line-removed">-                     long y = (long) VH_HugePoint_y.get(struct.baseAddress());</span>
<span class="line-removed">-                     long z = (long) VH_HugePoint_z.get(struct.baseAddress());</span>
<span class="line-removed">-                     return x + y + z;</span>
<span class="line-removed">-                 };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact</span>
<span class="line-removed">-             = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
<span class="line-removed">-                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,</span>
<span class="line-removed">-                 QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact</span>
<span class="line-removed">-             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-removed">-                 GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-removed">-                     longLongLayout.withName(&quot;x&quot;),</span>
<span class="line-removed">-                     longLongLayout.withName(&quot;y&quot;),</span>
<span class="line-removed">-                     longLongLayout.withName(&quot;z&quot;)</span>
<span class="line-removed">-                 );</span>
<span class="line-removed">-                 VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-removed">-                 VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-removed">-                 VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));</span>
<span class="line-removed">-                 return new Object[] { vaListFact,</span>
<span class="line-removed">-                                       sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),</span>
<span class="line-removed">-                                       HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };</span>
<span class="line-removed">-             };</span>
<span class="line-removed">-         return new Object[][]{</span>
<span class="line-removed">-             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-removed">-             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @Test(dataProvider = &quot;hugeStructByValue&quot;)</span>
<span class="line-removed">-     public void testHugeStructByValue(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-removed">-                                       Function&lt;VaList, Long&gt; sumHugeStruct,</span>
<span class="line-removed">-                                       MemoryLayout HugePoint_LAYOUT,</span>
<span class="line-removed">-                                       VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {</span>
          // On AArch64 a struct needs to be larger than 16 bytes to be
          // passed by reference.
          try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
              VH_HugePoint_x.set(struct.baseAddress(), 1);
              VH_HugePoint_y.set(struct.baseAddress(), 2);
              VH_HugePoint_z.set(struct.baseAddress(), 3);
  
<span class="line-modified">!             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {</span>
<span class="line-modified">!                 long sum = sumHugeStruct.apply(vaList);</span>
                  assertEquals(sum, 6);
              }
          }
      }
  
<span class="line-modified">!     public interface SumStackFunc {</span>
<span class="line-modified">!         void invoke(MemoryAddress longSum, MemoryAddress doubleSum, VaList list);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     @DataProvider</span>
<span class="line-modified">!     public static Object[][] sumStack() {</span>
<span class="line-removed">-         BiFunction&lt;MemoryLayout, MemoryLayout, SumStackFunc&gt; sumStackJavaFact = (longLayout, doubleLayout) -&gt;</span>
<span class="line-removed">-             (longSum, doubleSum, list) -&gt; {</span>
<span class="line-removed">-                 long lSum = 0L;</span>
<span class="line-removed">-                 for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-removed">-                     lSum += list.vargAsLong(longLayout);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 MemoryAccess.setLong(longSum, lSum);</span>
<span class="line-removed">-                 double dSum = 0D;</span>
<span class="line-removed">-                 for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-removed">-                     dSum += list.vargAsDouble(doubleLayout);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 MemoryAccess.setDouble(doubleSum, dSum);</span>
<span class="line-removed">-             };</span>
<span class="line-removed">-         SumStackFunc sumStackNative = MethodHandleProxies.asInterfaceInstance(SumStackFunc.class, MH_sumStack);</span>
<span class="line-removed">-         return new Object[][]{</span>
<span class="line-removed">-             { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },</span>
<span class="line-removed">-             { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },</span>
<span class="line-removed">-             { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },</span>
<span class="line-removed">-             { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @Test(dataProvider = &quot;sumStack&quot;)</span>
<span class="line-removed">-     public void testStack(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-removed">-                           SumStackFunc sumStack,</span>
<span class="line-removed">-                           MemoryLayout longLayout,</span>
<span class="line-removed">-                           MemoryLayout doubleLayout) {</span>
<span class="line-removed">-        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);</span>
<span class="line-removed">-             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {</span>
<span class="line-removed">-             MemoryAccess.setLong(longSum.baseAddress(), 0L);</span>
<span class="line-removed">-             MemoryAccess.setDouble(doubleSum.baseAddress(), 0D);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             VaList list = vaListFactory.apply(b -&gt; {</span>
<span class="line-removed">-                 for (long l = 1; l &lt;= 16L; l++) {</span>
<span class="line-removed">-                     b.vargFromLong(longLayout, l);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 for (double d = 1; d &lt;= 16D; d++) {</span>
<span class="line-removed">-                     b.vargFromDouble(doubleLayout, d);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             });</span>
  
<span class="line-modified">!             try (list) {</span>
<span class="line-modified">!                 sumStack.invoke(longSum.baseAddress(), doubleSum.baseAddress(), list);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             long lSum = MemoryAccess.getLong(longSum.baseAddress());</span>
<span class="line-modified">!             double dSum = MemoryAccess.getDouble(doubleSum.baseAddress());</span>
  
              assertEquals(lSum, 136L);
              assertEquals(dSum, 136D);
          }
      }
<span class="line-new-header">--- 123,138 ---</span>
              MethodType.methodType(void.class, MemoryAddress.class),
              FunctionDescriptor.ofVoid(C_POINTER));
  
      }
  
<span class="line-modified">!     private static final GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-modified">!         C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">!         C_LONGLONG.withName(&quot;y&quot;)</span>
<span class="line-modified">!     );</span>
<span class="line-modified">!     private static final VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!     private static final VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!     private static final GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-modified">!         C_INT.withName(&quot;x&quot;),</span>
<span class="line-modified">!         C_INT.withName(&quot;y&quot;)</span>
<span class="line-modified">!     );</span>
<span class="line-modified">!     private static final VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!     private static final VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!     private static final GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-modified">!         C_FLOAT.withName(&quot;x&quot;),</span>
<span class="line-modified">!         C_FLOAT.withName(&quot;y&quot;)</span>
<span class="line-modified">!     );</span>
<span class="line-modified">!     private static final VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!     private static final VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!     private static final GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-modified">!         C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">!         C_LONGLONG.withName(&quot;y&quot;),</span>
<span class="line-modified">!         C_LONGLONG.withName(&quot;z&quot;)</span>
<span class="line-modified">!     );</span>
<span class="line-modified">!     private static final VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!     private static final VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!     private static final VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testIntSum() throws Throwable {</span>
<span class="line-modified">!         try (VaList vaList = VaList.make(b -&gt;</span>
<span class="line-modified">!                 b.vargFromInt(C_INT, 10)</span>
<span class="line-modified">!                  .vargFromInt(C_INT, 15)</span>
<span class="line-modified">!                  .vargFromInt(C_INT, 20))) {</span>
<span class="line-modified">!             int x = (int) MH_sumInts.invokeExact(3, vaList);</span>
              assertEquals(x, 45);
          }
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testDoubleSum() throws Throwable {</span>
<span class="line-modified">!         try (VaList vaList = VaList.make(b -&gt;</span>
<span class="line-modified">!                 b.vargFromDouble(C_DOUBLE, 3.0D)</span>
<span class="line-modified">!                  .vargFromDouble(C_DOUBLE, 4.0D)</span>
<span class="line-modified">!                  .vargFromDouble(C_DOUBLE, 5.0D))) {</span>
<span class="line-modified">!             double x = (double) MH_sumDoubles.invokeExact(3, vaList);</span>
              assertEquals(x, 12.0D);
          }
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testVaListMemoryAddress() throws Throwable {</span>
<span class="line-modified">!         try (MemorySegment msInt = MemorySegment.allocateNative(C_INT)) {</span>
<span class="line-modified">!             VH_int.set(msInt.baseAddress(), 10);</span>
<span class="line-modified">!             try (VaList vaList = VaList.make(b -&gt; b.vargFromAddress(C_POINTER, msInt.baseAddress()))) {</span>
<span class="line-modified">!                 int x = (int) MH_getInt.invokeExact(vaList);</span>
                  assertEquals(x, 10);
              }
          }
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testWinStructByValue() throws Throwable {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
              VH_Point_x.set(struct.baseAddress(), 5);
              VH_Point_y.set(struct.baseAddress(), 10);
  
<span class="line-modified">!             try (VaList vaList = VaList.make(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {</span>
<span class="line-modified">!                 int sum = (int) MH_sumStruct.invokeExact(vaList);</span>
                  assertEquals(sum, 15);
              }
          }
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testWinStructByReference() throws Throwable {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
              VH_BigPoint_x.set(struct.baseAddress(), 5);
              VH_BigPoint_y.set(struct.baseAddress(), 10);
  
<span class="line-modified">!             try (VaList vaList = VaList.make(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {</span>
<span class="line-modified">!                 long sum = (long) MH_sumBigStruct.invokeExact(vaList);</span>
                  assertEquals(sum, 15);
              }
          }
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testFloatStructByValue() throws Throwable {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
              VH_FloatPoint_x.set(struct.baseAddress(), 1.234f);
              VH_FloatPoint_y.set(struct.baseAddress(), 3.142f);
  
<span class="line-modified">!             try (VaList vaList = VaList.make(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {</span>
<span class="line-modified">!                 float sum = (float) MH_sumFloatStruct.invokeExact(vaList);</span>
                  assertEquals(sum, 4.376f, 0.00001f);
              }
          }
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testHugeStructByValue() throws Throwable {</span>
          // On AArch64 a struct needs to be larger than 16 bytes to be
          // passed by reference.
          try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
              VH_HugePoint_x.set(struct.baseAddress(), 1);
              VH_HugePoint_y.set(struct.baseAddress(), 2);
              VH_HugePoint_z.set(struct.baseAddress(), 3);
  
<span class="line-modified">!             try (VaList vaList = VaList.make(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {</span>
<span class="line-modified">!                 long sum = (long) MH_sumHugeStruct.invokeExact(vaList);</span>
                  assertEquals(sum, 6);
              }
          }
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testStack() throws Throwable {</span>
<span class="line-modified">!        try (MemorySegment longSum = MemorySegment.allocateNative(C_LONGLONG);</span>
<span class="line-modified">!             MemorySegment doubleSum = MemorySegment.allocateNative(C_DOUBLE)) {</span>
<span class="line-modified">!             VH_long.set(longSum.baseAddress(), 0L);</span>
<span class="line-modified">!             VH_double.set(doubleSum.baseAddress(), 0D);</span>
  
<span class="line-modified">!             MH_sumStack.invokeExact(longSum.baseAddress(), doubleSum.baseAddress(), 32,</span>
<span class="line-modified">!                 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L,</span>
<span class="line-modified">!                 1D, 2D, 3D, 4D, 5D, 6D, 7D, 8D, 9D, 10D, 11D, 12D, 13D, 14D, 15D, 16D);</span>
  
<span class="line-modified">!             long lSum = (long) VH_long.get(longSum.baseAddress());</span>
<span class="line-modified">!             double dSum = (double) VH_double.get(doubleSum.baseAddress());</span>
  
              assertEquals(lSum, 136L);
              assertEquals(dSum, 136D);
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 512,70 ***</span>
          try (MemorySegment stub = abi.upcallStub(callback, desc)) {
              target.invokeExact(stub.baseAddress());
          }
      }
  
<span class="line-removed">-     @DataProvider</span>
<span class="line-removed">-     public Object[][] emptyVaLists() {</span>
<span class="line-removed">-         return new Object[][] {</span>
<span class="line-removed">-             { Windowsx64Linker.emptyVaList()      },</span>
<span class="line-removed">-             { winVaListFactory.apply(b -&gt; {})     },</span>
<span class="line-removed">-             { SysVx64Linker.emptyVaList()         },</span>
<span class="line-removed">-             { sysvVaListFactory.apply(b -&gt; {})    },</span>
<span class="line-removed">-             { AArch64Linker.emptyVaList()         },</span>
<span class="line-removed">-             { aarch64VaListFactory.apply(b -&gt; {}) },</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      @Test(expectedExceptions = UnsupportedOperationException.class,
<span class="line-modified">!           expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;,</span>
<span class="line-modified">!           dataProvider = &quot;emptyVaLists&quot;)</span>
<span class="line-modified">!     public void testEmptyNotCloseable(VaList emptyList) {</span>
<span class="line-modified">!         emptyList.close();</span>
      }
  
<span class="line-modified">!     @DataProvider</span>
<span class="line-modified">!     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">!     public static Object[][] sumIntsScoped() {</span>
<span class="line-modified">!         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;</span>
<span class="line-modified">!             (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
<span class="line-removed">-         BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative</span>
<span class="line-removed">-             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
<span class="line-removed">-         return new Object[][]{</span>
<span class="line-removed">-             { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-removed">-             { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-removed">-             { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-removed">-             { platformVaListScopedFactory, sumIntsNative,                        C_INT         },</span>
<span class="line-removed">-         };</span>
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;sumIntsScoped&quot;)</span>
<span class="line-modified">!     public void testScopedVaList(BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; vaListFactory,</span>
<span class="line-removed">-                                  BiFunction&lt;Integer, VaList, Integer&gt; sumInts,</span>
<span class="line-removed">-                                  MemoryLayout intLayout) {</span>
          VaList listLeaked;
          try (NativeScope scope = NativeScope.unboundedScope()) {
<span class="line-modified">!             VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)</span>
<span class="line-modified">!                                                     .vargFromInt(intLayout, 8),</span>
                                                 scope);
<span class="line-modified">!             int x = sumInts.apply(2, list);</span>
              assertEquals(x, 12);
              listLeaked = list;
          }
          assertFalse(listLeaked.isAlive());
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;winStructByValue&quot;)</span>
<span class="line-modified">!     public void testScopeMSRead(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-removed">-                                 Function&lt;VaList, Integer&gt; sumStruct, // ignored</span>
<span class="line-removed">-                                 MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {</span>
          MemorySegment pointOut;
          try (NativeScope scope = NativeScope.unboundedScope()) {
              try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
                  VH_Point_x.set(pointIn.baseAddress(), 3);
                  VH_Point_y.set(pointIn.baseAddress(), 6);
<span class="line-modified">!                 try (VaList list = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {</span>
                      pointOut = list.vargAsSegment(Point_LAYOUT, scope);
                      assertEquals((int) VH_Point_x.get(pointOut.baseAddress()), 3);
                      assertEquals((int) VH_Point_y.get(pointOut.baseAddress()), 6);
                  }
                  assertTrue(pointOut.isAlive()); // after VaList freed
<span class="line-new-header">--- 265,46 ---</span>
          try (MemorySegment stub = abi.upcallStub(callback, desc)) {
              target.invokeExact(stub.baseAddress());
          }
      }
  
      @Test(expectedExceptions = UnsupportedOperationException.class,
<span class="line-modified">!           expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;)</span>
<span class="line-modified">!     public void testEmptyNotCloseable() {</span>
<span class="line-modified">!         VaList list = VaList.empty();</span>
<span class="line-modified">!         list.close();</span>
      }
  
<span class="line-modified">!     @Test(expectedExceptions = UnsupportedOperationException.class,</span>
<span class="line-modified">!           expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;)</span>
<span class="line-modified">!     public void testEmptyVaListFromBuilderNotCloseable() {</span>
<span class="line-modified">!         VaList list = VaList.make(b -&gt; {});</span>
<span class="line-modified">!         list.close();</span>
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testScopedVaList() throws Throwable {</span>
          VaList listLeaked;
          try (NativeScope scope = NativeScope.unboundedScope()) {
<span class="line-modified">!             VaList list = CSupport.VaList.make(b -&gt; b.vargFromInt(C_INT, 4)</span>
<span class="line-modified">!                                                      .vargFromInt(C_INT, 8),</span>
                                                 scope);
<span class="line-modified">!             int x = (int) MH_sumInts.invokeExact(2, list);</span>
              assertEquals(x, 12);
              listLeaked = list;
          }
          assertFalse(listLeaked.isAlive());
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testScopeMSRead() {</span>
          MemorySegment pointOut;
          try (NativeScope scope = NativeScope.unboundedScope()) {
              try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
                  VH_Point_x.set(pointIn.baseAddress(), 3);
                  VH_Point_y.set(pointIn.baseAddress(), 6);
<span class="line-modified">!                 try (VaList list = CSupport.VaList.make(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {</span>
                      pointOut = list.vargAsSegment(Point_LAYOUT, scope);
                      assertEquals((int) VH_Point_x.get(pointOut.baseAddress()), 3);
                      assertEquals((int) VH_Point_y.get(pointOut.baseAddress()), 6);
                  }
                  assertTrue(pointOut.isAlive()); // after VaList freed
</pre>
<hr />
<pre>
<span class="line-old-header">*** 583,109 ***</span>
              assertTrue(pointOut.isAlive()); // after input MS freed
          }
          assertFalse(pointOut.isAlive()); // after scope freed
      }
  
<span class="line-modified">!     @DataProvider</span>
<span class="line-modified">!     public Object[][] copy() {</span>
<span class="line-modified">!         return new Object[][] {</span>
<span class="line-modified">!             { winVaListFactory,      Win64.C_INT   },</span>
<span class="line-removed">-             { sysvVaListFactory,     SysV.C_INT    },</span>
<span class="line-removed">-             { aarch64VaListFactory,  AArch64.C_INT },</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @Test(dataProvider = &quot;copy&quot;)</span>
<span class="line-removed">-     public void testCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {</span>
<span class="line-removed">-         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)</span>
<span class="line-removed">-                                                      .vargFromInt(intLayout, 8))) {</span>
              VaList  copy = list.copy();
<span class="line-modified">!             assertEquals(copy.vargAsInt(intLayout), 4);</span>
<span class="line-modified">!             assertEquals(copy.vargAsInt(intLayout), 8);</span>
              copy.close();
  
              assertFalse(copy.isAlive());
  
<span class="line-modified">!             assertEquals(list.vargAsInt(intLayout), 4);</span>
<span class="line-modified">!             assertEquals(list.vargAsInt(intLayout), 8);</span>
          }
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;copy&quot;)</span>
<span class="line-modified">!     public void testScopedCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {</span>
<span class="line-modified">!         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)</span>
<span class="line-modified">!                                                      .vargFromInt(intLayout, 8))) {</span>
              VaList copy;
              try (NativeScope scope = NativeScope.unboundedScope()) {
                  copy = list.copy(scope);
  
<span class="line-modified">!                 assertEquals(copy.vargAsInt(intLayout), 4);</span>
<span class="line-modified">!                 assertEquals(copy.vargAsInt(intLayout), 8);</span>
              }
              assertFalse(copy.isAlive());
  
<span class="line-modified">!             assertEquals(list.vargAsInt(intLayout), 4);</span>
<span class="line-modified">!             assertEquals(list.vargAsInt(intLayout), 8);</span>
          }
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;copy&quot;,</span>
<span class="line-modified">!           expectedExceptions = IllegalStateException.class)</span>
<span class="line-modified">!     public void testCopyUnusableAfterOriginalClosed(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">!                                                     MemoryLayout intLayout) {</span>
<span class="line-removed">-         VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)</span>
<span class="line-removed">-                                                 .vargFromInt(intLayout, 8));</span>
          try (VaList copy = list.copy()) {
              list.close();
  
<span class="line-modified">!             copy.vargAsInt(intLayout); // should throw</span>
          }
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;copy&quot;,</span>
<span class="line-modified">!           expectedExceptions = IllegalStateException.class)</span>
<span class="line-modified">!     public void testCopyUnusableAfterOriginalClosedScope(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">!                                                          MemoryLayout intLayout) {</span>
<span class="line-removed">-         VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)</span>
<span class="line-removed">-                                                 .vargFromInt(intLayout, 8));</span>
          try (NativeScope scope = NativeScope.unboundedScope()) {
              VaList copy = list.copy(scope);
              list.close();
  
<span class="line-modified">!             copy.vargAsInt(intLayout); // should throw</span>
          }
      }
  
      @DataProvider
      public static Object[][] upcalls() {
<span class="line-removed">-         GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-removed">-             C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-removed">-             C_LONGLONG.withName(&quot;y&quot;)</span>
<span class="line-removed">-         );</span>
<span class="line-removed">-         VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-removed">-         VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-removed">-         GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-removed">-             C_INT.withName(&quot;x&quot;),</span>
<span class="line-removed">-             C_INT.withName(&quot;y&quot;)</span>
<span class="line-removed">-         );</span>
<span class="line-removed">-         VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));</span>
<span class="line-removed">-         VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));</span>
<span class="line-removed">-         GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-removed">-             C_FLOAT.withName(&quot;x&quot;),</span>
<span class="line-removed">-             C_FLOAT.withName(&quot;y&quot;)</span>
<span class="line-removed">-         );</span>
<span class="line-removed">-         VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));</span>
<span class="line-removed">-         VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));</span>
<span class="line-removed">-         GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-removed">-             C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-removed">-             C_LONGLONG.withName(&quot;y&quot;),</span>
<span class="line-removed">-             C_LONGLONG.withName(&quot;z&quot;)</span>
<span class="line-removed">-         );</span>
<span class="line-removed">-         VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-removed">-         VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-removed">-         VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));</span>
<span class="line-removed">- </span>
          return new Object[][]{
              { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
                  try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
                      assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
                      assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);
<span class="line-new-header">--- 312,69 ---</span>
              assertTrue(pointOut.isAlive()); // after input MS freed
          }
          assertFalse(pointOut.isAlive()); // after scope freed
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testCopy() {</span>
<span class="line-modified">!         try (VaList list = VaList.make(b -&gt; b.vargFromInt(C_INT, 4)</span>
<span class="line-modified">!                                              .vargFromInt(C_INT, 8))) {</span>
              VaList  copy = list.copy();
<span class="line-modified">!             assertEquals(copy.vargAsInt(C_INT), 4);</span>
<span class="line-modified">!             assertEquals(copy.vargAsInt(C_INT), 8);</span>
              copy.close();
  
              assertFalse(copy.isAlive());
  
<span class="line-modified">!             assertEquals(list.vargAsInt(C_INT), 4);</span>
<span class="line-modified">!             assertEquals(list.vargAsInt(C_INT), 8);</span>
          }
      }
  
<span class="line-modified">!     @Test</span>
<span class="line-modified">!     public void testScopedCopy() {</span>
<span class="line-modified">!         try (VaList list = VaList.make(b -&gt; b.vargFromInt(C_INT, 4)</span>
<span class="line-modified">!                                              .vargFromInt(C_INT, 8))) {</span>
              VaList copy;
              try (NativeScope scope = NativeScope.unboundedScope()) {
                  copy = list.copy(scope);
  
<span class="line-modified">!                 assertEquals(copy.vargAsInt(C_INT), 4);</span>
<span class="line-modified">!                 assertEquals(copy.vargAsInt(C_INT), 8);</span>
              }
              assertFalse(copy.isAlive());
  
<span class="line-modified">!             assertEquals(list.vargAsInt(C_INT), 4);</span>
<span class="line-modified">!             assertEquals(list.vargAsInt(C_INT), 8);</span>
          }
      }
  
<span class="line-modified">!     @Test(expectedExceptions = IllegalStateException.class)</span>
<span class="line-modified">!     public void testCopyUnusableAfterOriginalClosed() {</span>
<span class="line-modified">!         VaList list = VaList.make(b -&gt; b.vargFromInt(C_INT, 4)</span>
<span class="line-modified">!                                         .vargFromInt(C_INT, 8));</span>
          try (VaList copy = list.copy()) {
              list.close();
  
<span class="line-modified">!             copy.vargAsInt(C_INT); // should throw</span>
          }
      }
  
<span class="line-modified">!     @Test(expectedExceptions = IllegalStateException.class)</span>
<span class="line-modified">!     public void testCopyUnusableAfterOriginalClosedScope() {</span>
<span class="line-modified">!         VaList list = VaList.make(b -&gt; b.vargFromInt(C_INT, 4)</span>
<span class="line-modified">!                                         .vargFromInt(C_INT, 8));</span>
          try (NativeScope scope = NativeScope.unboundedScope()) {
              VaList copy = list.copy(scope);
              list.close();
  
<span class="line-modified">!             copy.vargAsInt(C_INT); // should throw</span>
          }
      }
  
      @DataProvider
      public static Object[][] upcalls() {
          return new Object[][]{
              { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
                  try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
                      assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
                      assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 728,11 ***</span>
              })},
              { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {
                  MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
                  MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
                                                                      Thread.currentThread(), null, null);
<span class="line-modified">!                 int x = MemoryAccess.getInt(ms.baseAddress());</span>
                  assertEquals(x, 10);
              })},
              { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {
                  assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
                  assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
<span class="line-new-header">--- 417,11 ---</span>
              })},
              { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {
                  MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
                  MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
                                                                      Thread.currentThread(), null, null);
<span class="line-modified">!                 int x = (int) VH_int.get(ms.baseAddress());</span>
                  assertEquals(x, 10);
              })},
              { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {
                  assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
                  assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 743,16 ***</span>
                  assertEquals(vaList.vargAsInt(C_INT), 15);
                  assertEquals(vaList.vargAsInt(C_INT), 20);
              })},
              { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {
                  // skip all registers
<span class="line-modified">!                 for (long l = 1; l &lt;= 16; l++) {</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsLong(C_LONGLONG), l);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 for (double d = 1; d &lt;= 16; d++) {</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsDouble(C_DOUBLE), d);</span>
<span class="line-modified">!                 }</span>
  
                  // test some arbitrary values on the stack
                  assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
                  assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);
                  assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
<span class="line-new-header">--- 432,42 ---</span>
                  assertEquals(vaList.vargAsInt(C_INT), 15);
                  assertEquals(vaList.vargAsInt(C_INT), 20);
              })},
              { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {
                  // skip all registers
<span class="line-modified">!                 assertEquals(vaList.vargAsLong(C_LONGLONG), 1L); // 1st windows arg read from shadow space</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsLong(C_LONGLONG), 2L); // 2nd windows arg read from shadow space</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsLong(C_LONGLONG), 3L); // windows 1st stack arg (int/float)</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsLong(C_LONGLONG), 4L);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsLong(C_LONGLONG), 6L);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsLong(C_LONGLONG), 7L); // sysv 1st int stack arg</span>
<span class="line-added">+                 assertEquals(vaList.vargAsLong(C_LONGLONG), 8L);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsLong(C_LONGLONG), 9L);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsLong(C_LONGLONG), 11L);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsLong(C_LONGLONG), 13L);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsLong(C_LONGLONG), 14L);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsLong(C_LONGLONG), 15L);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsLong(C_LONGLONG), 16L);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 2.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 8.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 9.0D); // sysv 1st float stack arg</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 10.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 11.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 12.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 13.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 15.0D);</span>
<span class="line-added">+                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 16.0D);</span>
  
                  // test some arbitrary values on the stack
                  assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
                  assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);
                  assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
</pre>
<center>&lt; prev <a href="../../../../../index.html" target="_top">index</a> <a href="libVaList.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64Linker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../x64/sysv/SysVVaList.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 15  * version 2 for more details (a copy is included in the LICENSE file that
 16  * accompanied this code).
 17  *
 18  * You should have received a copy of the GNU General Public License version
 19  * 2 along with this work; if not, write to the Free Software Foundation,
 20  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 21  *
 22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 23  * or visit www.oracle.com if you need additional information or have any
 24  * questions.
 25  */
 26 package jdk.internal.foreign.abi.aarch64;
 27 
 28 import jdk.incubator.foreign.CSupport;
 29 import jdk.incubator.foreign.GroupLayout;
 30 import jdk.incubator.foreign.MemoryAddress;
 31 import jdk.incubator.foreign.MemoryHandles;
 32 import jdk.incubator.foreign.MemoryLayout;
 33 import jdk.incubator.foreign.MemorySegment;

 34 import jdk.internal.foreign.NativeMemorySegmentImpl;
 35 import jdk.internal.foreign.Utils;
 36 import jdk.internal.foreign.abi.SharedUtils;
 37 import jdk.internal.misc.Unsafe;
 38 
 39 import java.lang.invoke.VarHandle;
 40 import java.lang.ref.Cleaner;
 41 import java.nio.ByteOrder;
 42 import java.util.ArrayList;
 43 import java.util.List;
 44 
 45 import static jdk.incubator.foreign.CSupport.AArch64;
 46 import static jdk.incubator.foreign.CSupport.VaList;
 47 import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
 48 import static jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;
 49 import static jdk.internal.foreign.abi.SharedUtils.checkCompatibleType;
 50 import static jdk.internal.foreign.abi.SharedUtils.vhPrimitiveOrAddress;
 51 import static jdk.internal.foreign.abi.aarch64.CallArranger.MAX_REGISTER_ARGUMENTS;
 52 
 53 public class AArch64VaList implements VaList {
</pre>
<hr />
<pre>
 89 
 90     private static final int MAX_GP_OFFSET = (int) LAYOUT_GP_REGS.byteSize();
 91     private static final int MAX_FP_OFFSET = (int) LAYOUT_FP_REGS.byteSize();
 92 
 93     private static final VarHandle VH_stack
 94         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__stack&quot;)));
 95     private static final VarHandle VH_gr_top
 96         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__gr_top&quot;)));
 97     private static final VarHandle VH_vr_top
 98         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__vr_top&quot;)));
 99     private static final VarHandle VH_gr_offs
100         = LAYOUT.varHandle(int.class, groupElement(&quot;__gr_offs&quot;));
101     private static final VarHandle VH_vr_offs
102         = LAYOUT.varHandle(int.class, groupElement(&quot;__vr_offs&quot;));
103 
104     private static final Cleaner cleaner = Cleaner.create();
105     private static final CSupport.VaList EMPTY
106         = new SharedUtils.EmptyVaList(emptyListAddress());
107 
108     private final MemorySegment segment;
<span class="line-removed">109     private final List&lt;MemorySegment&gt; slices = new ArrayList&lt;&gt;();</span>
<span class="line-removed">110     private final MemorySegment fpRegsArea;</span>
111     private final MemorySegment gpRegsArea;


112 
<span class="line-modified">113     AArch64VaList(MemorySegment segment) {</span>

114         this.segment = segment;




115 
<span class="line-modified">116         gpRegsArea = MemorySegment.ofNativeRestricted(</span>
<span class="line-modified">117             grTop().addOffset(-MAX_GP_OFFSET), MAX_GP_OFFSET,</span>

118             segment.ownerThread(), null, null);
119 
<span class="line-modified">120         fpRegsArea = MemorySegment.ofNativeRestricted(</span>
<span class="line-modified">121             vrTop().addOffset(-MAX_FP_OFFSET), MAX_FP_OFFSET,</span>
122             segment.ownerThread(), null, null);
<span class="line-modified">123 </span>
<span class="line-removed">124         slices.add(gpRegsArea);</span>
<span class="line-removed">125         slices.add(fpRegsArea);</span>
126     }
127 
128     private static MemoryAddress emptyListAddress() {
129         long ptr = U.allocateMemory(LAYOUT.byteSize());
130         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
131                 MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null,
132                 () -&gt; U.freeMemory(ptr), null);
133         cleaner.register(AArch64VaList.class, ms::close);
134         MemoryAddress base = ms.baseAddress();
135         VH_stack.set(base, MemoryAddress.NULL);
136         VH_gr_top.set(base, MemoryAddress.NULL);
137         VH_vr_top.set(base, MemoryAddress.NULL);
138         VH_gr_offs.set(base, 0);
139         VH_vr_offs.set(base, 0);
140         return ms.withAccessModes(0).baseAddress();
141     }
142 
143     public static CSupport.VaList empty() {
144         return EMPTY;
145     }
146 
147     private MemoryAddress grTop() {




148         return (MemoryAddress) VH_gr_top.get(segment.baseAddress());
149     }
150 
151     private MemoryAddress vrTop() {




152         return (MemoryAddress) VH_vr_top.get(segment.baseAddress());
153     }
154 
155     private int grOffs() {
156         final int offs = (int) VH_gr_offs.get(segment.baseAddress());
157         assert offs &lt;= 0;
158         return offs;
159     }
160 
161     private int vrOffs() {
162         final int offs = (int) VH_vr_offs.get(segment.baseAddress());
163         assert offs &lt;= 0;
164         return offs;
165     }
166 
167     private MemoryAddress stackPtr() {
168         return (MemoryAddress) VH_stack.get(segment.baseAddress());
169     }
170 
171     private void stackPtr(MemoryAddress ptr) {
</pre>
<hr />
<pre>
216     @Override
217     public long vargAsLong(MemoryLayout layout) {
218         return (long) read(long.class, layout);
219     }
220 
221     @Override
222     public double vargAsDouble(MemoryLayout layout) {
223         return (double) read(double.class, layout);
224     }
225 
226     @Override
227     public MemoryAddress vargAsAddress(MemoryLayout layout) {
228         return (MemoryAddress) read(MemoryAddress.class, layout);
229     }
230 
231     @Override
232     public MemorySegment vargAsSegment(MemoryLayout layout) {
233         return (MemorySegment) read(MemorySegment.class, layout);
234     }
235 





236     private Object read(Class&lt;?&gt; carrier, MemoryLayout layout) {




237         checkCompatibleType(carrier, layout, AArch64Linker.ADDRESS_SIZE);
238 
239         TypeClass typeClass = TypeClass.classifyLayout(layout);
240         if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {
241             preAlignStack(layout);
242             return switch (typeClass) {
243                 case STRUCT_REGISTER, STRUCT_HFA, STRUCT_REFERENCE -&gt; {
244                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
245                              stackPtr(), layout.byteSize(),
246                              segment.ownerThread(), null, null)) {
<span class="line-modified">247                         MemorySegment seg = MemorySegment.allocateNative(layout);</span>
248                         seg.copyFrom(slice);
249                         postAlignStack(layout);
250                         yield seg;
251                     }
252                 }
253                 case POINTER, INTEGER, FLOAT -&gt; {
254                     VarHandle reader = vhPrimitiveOrAddress(carrier, layout);
255                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
256                              stackPtr(), layout.byteSize(),
257                              segment.ownerThread(), null, null)) {
258                         Object res = reader.get(slice.baseAddress());
259                         postAlignStack(layout);
260                         yield res;
261                     }
262                 }
263             };
264         } else {
265             return switch (typeClass) {
266                 case STRUCT_REGISTER -&gt; {
267                     // Struct is passed packed in integer registers.
<span class="line-modified">268                     MemorySegment value = MemorySegment.allocateNative(layout);</span>
269                     long offset = 0;
270                     while (offset &lt; layout.byteSize()) {
271                         final long copy = Math.min(layout.byteSize() - offset, 8);
272                         MemorySegment slice = value.asSlice(offset, copy);
273                         slice.copyFrom(gpRegsArea.asSlice(currentGPOffset(), copy));
274                         consumeGPSlots(1);
275                         offset += copy;
276                     }
277                     yield value;
278                 }
279                 case STRUCT_HFA -&gt; {
280                     // Struct is passed with each element in a separate floating
281                     // point register.
<span class="line-modified">282                     MemorySegment value = MemorySegment.allocateNative(layout);</span>
283                     GroupLayout group = (GroupLayout)layout;
284                     long offset = 0;
285                     for (MemoryLayout elem : group.memberLayouts()) {
286                         assert elem.byteSize() &lt;= 8;
287                         final long copy = elem.byteSize();
288                         MemorySegment slice = value.asSlice(offset, copy);
289                         slice.copyFrom(fpRegsArea.asSlice(currentFPOffset(), copy));
290                         consumeFPSlots(1);
291                         offset += copy;
292                     }
293                     yield value;
294                 }
295                 case STRUCT_REFERENCE -&gt; {
296                     // Struct is passed indirectly via a pointer in an integer register.
297                     VarHandle ptrReader
298                         = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class, AArch64.C_POINTER);
299                     MemoryAddress ptr = (MemoryAddress) ptrReader.get(
300                         gpRegsArea.baseAddress().addOffset(currentGPOffset()));
301                     consumeGPSlots(1);
302 
303                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
304                              ptr, layout.byteSize(), segment.ownerThread(), null, null)) {
<span class="line-modified">305                         MemorySegment seg = MemorySegment.allocateNative(layout);</span>
306                         seg.copyFrom(slice);
307                         yield seg;
308                     }
309                 }
310                 case POINTER, INTEGER -&gt; {
311                     VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
312                     Object res = reader.get(gpRegsArea.baseAddress().addOffset(currentGPOffset()));
313                     consumeGPSlots(1);
314                     yield res;
315                 }
316                 case FLOAT -&gt; {
317                     VarHandle reader = layout.varHandle(carrier);
318                     Object res = reader.get(fpRegsArea.baseAddress().addOffset(currentFPOffset()));
319                     consumeFPSlots(1);
320                     yield res;
321                 }
322             };
323         }
324     }
325 
326     @Override
327     public void skip(MemoryLayout... layouts) {
328         for (MemoryLayout layout : layouts) {
329             TypeClass typeClass = TypeClass.classifyLayout(layout);
330             if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {
331                 preAlignStack(layout);
332                 postAlignStack(layout);
333             } else if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {
334                 consumeFPSlots(numSlots(layout));
335             } else if (typeClass == TypeClass.STRUCT_REFERENCE) {
336                 consumeGPSlots(1);
337             } else {
338                 consumeGPSlots(numSlots(layout));
339             }
340         }
341     }
342 
<span class="line-modified">343     static AArch64VaList.Builder builder() {</span>
<span class="line-modified">344         return new AArch64VaList.Builder();</span>
345     }
346 
347     public static VaList ofAddress(MemoryAddress ma) {
<span class="line-modified">348         return new AArch64VaList(</span>
<span class="line-removed">349             MemorySegment.ofNativeRestricted(</span>
350                 ma, LAYOUT.byteSize(), Thread.currentThread(), null, null));
351     }
352 
353     @Override
354     public boolean isAlive() {
355         return segment.isAlive();
356     }
357 
358     @Override
359     public void close() {
360         segment.close();
361         slices.forEach(MemorySegment::close);
362     }
363 
364     @Override
365     public VaList copy() {
<span class="line-modified">366         MemorySegment copy = MemorySegment.allocateNative(LAYOUT.byteSize());</span>









367         copy.copyFrom(segment);
<span class="line-modified">368         return new AArch64VaList(copy);</span>
369     }
370 
371     @Override
372     public MemoryAddress address() {
373         return segment.baseAddress();
374     }
375 
376     private static int numSlots(MemoryLayout layout) {
377         return (int) Utils.alignUp(layout.byteSize(), 8) / 8;
378     }
379 
380     private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset,
381                                          TypeClass typeClass, MemoryLayout layout) {
382         if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {
383             return currentFPOffset &gt; MAX_FP_OFFSET - numSlots(layout) * FP_SLOT_SIZE;
384         } else if (typeClass == TypeClass.STRUCT_REFERENCE) {
385             return currentGPOffset &gt; MAX_GP_OFFSET - GP_SLOT_SIZE;
386         } else {
387             return currentGPOffset &gt; MAX_GP_OFFSET - numSlots(layout) * GP_SLOT_SIZE;
388         }
389     }
390 
391     @Override
392     public String toString() {
393         return &quot;AArch64VaList{&quot;
394             + &quot;__stack=&quot; + stackPtr()
395             + &quot;, __gr_top=&quot; + grTop()
396             + &quot;, __vr_top=&quot; + vrTop()
397             + &quot;, __gr_offs=&quot; + grOffs()
398             + &quot;, __vr_offs=&quot; + vrOffs()
399             + &#39;}&#39;;
400     }
401 
402     static class Builder implements CSupport.VaList.Builder {
<span class="line-modified">403         private final MemorySegment gpRegs</span>
<span class="line-modified">404             = MemorySegment.allocateNative(LAYOUT_GP_REGS);</span>
<span class="line-modified">405         private final MemorySegment fpRegs</span>
<span class="line-removed">406             = MemorySegment.allocateNative(LAYOUT_FP_REGS);</span>
407 
408         private long currentGPOffset = 0;
409         private long currentFPOffset = 0;
410         private final List&lt;SimpleVaArg&gt; stackArgs = new ArrayList&lt;&gt;();
411 






412         @Override
413         public Builder vargFromInt(MemoryLayout layout, int value) {
414             return arg(int.class, layout, value);
415         }
416 
417         @Override
418         public Builder vargFromLong(MemoryLayout layout, long value) {
419             return arg(long.class, layout, value);
420         }
421 
422         @Override
423         public Builder vargFromDouble(MemoryLayout layout, double value) {
424             return arg(double.class, layout, value);
425         }
426 
427         @Override
428         public Builder vargFromAddress(MemoryLayout layout, MemoryAddress value) {
429             return arg(MemoryAddress.class, layout, value);
430         }
431 
</pre>
<hr />
<pre>
486                     }
487                     case FLOAT -&gt; {
488                         VarHandle writer = layout.varHandle(carrier);
489                         writer.set(fpRegs.baseAddress().addOffset(currentFPOffset), value);
490                         currentFPOffset += FP_SLOT_SIZE;
491                     }
492                 }
493             }
494             return this;
495         }
496 
497         private boolean isEmpty() {
498             return currentGPOffset == 0 &amp;&amp; currentFPOffset == 0 &amp;&amp; stackArgs.isEmpty();
499         }
500 
501         public VaList build() {
502             if (isEmpty()) {
503                 return EMPTY;
504             }
505 
<span class="line-modified">506             MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT.byteSize());</span>
<span class="line-modified">507             AArch64VaList res = new AArch64VaList(vaListSegment);</span>
<span class="line-removed">508 </span>
509             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
510             if (!stackArgs.isEmpty()) {
511                 long stackArgsSize = stackArgs.stream()
512                     .reduce(0L, (acc, e) -&gt; acc + Utils.alignUp(e.layout.byteSize(), 8), Long::sum);
<span class="line-modified">513                 MemorySegment stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16);</span>
514                 MemoryAddress maStackArea = stackArgsSegment.baseAddress();
515                 for (SimpleVaArg arg : stackArgs) {
516                     final long alignedSize = Utils.alignUp(arg.layout.byteSize(), 8);
517                     maStackArea = Utils.alignUp(maStackArea, alignedSize);
518                     VarHandle writer = arg.varHandle();
519                     writer.set(maStackArea, arg.value);
520                     maStackArea = maStackArea.addOffset(alignedSize);
521                 }
522                 stackArgsPtr = stackArgsSegment.baseAddress();
<span class="line-modified">523                 res.slices.add(stackArgsSegment);</span>
524             }
525 
526             MemoryAddress vaListAddr = vaListSegment.baseAddress();
527             VH_gr_top.set(vaListAddr, gpRegs.baseAddress().addOffset(gpRegs.byteSize()));
528             VH_vr_top.set(vaListAddr, fpRegs.baseAddress().addOffset(fpRegs.byteSize()));
529             VH_stack.set(vaListAddr, stackArgsPtr);
530             VH_gr_offs.set(vaListAddr, -MAX_GP_OFFSET);
531             VH_vr_offs.set(vaListAddr, -MAX_FP_OFFSET);
532 
<span class="line-modified">533             res.slices.add(gpRegs);</span>
<span class="line-modified">534             res.slices.add(fpRegs);</span>
535             assert gpRegs.ownerThread() == vaListSegment.ownerThread();
536             assert fpRegs.ownerThread() == vaListSegment.ownerThread();
<span class="line-modified">537             return res;</span>
538         }
539     }
540 }
</pre>
</td>
<td>
<hr />
<pre>
 14  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 15  * version 2 for more details (a copy is included in the LICENSE file that
 16  * accompanied this code).
 17  *
 18  * You should have received a copy of the GNU General Public License version
 19  * 2 along with this work; if not, write to the Free Software Foundation,
 20  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 21  *
 22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 23  * or visit www.oracle.com if you need additional information or have any
 24  * questions.
 25  */
 26 package jdk.internal.foreign.abi.aarch64;
 27 
 28 import jdk.incubator.foreign.CSupport;
 29 import jdk.incubator.foreign.GroupLayout;
 30 import jdk.incubator.foreign.MemoryAddress;
 31 import jdk.incubator.foreign.MemoryHandles;
 32 import jdk.incubator.foreign.MemoryLayout;
 33 import jdk.incubator.foreign.MemorySegment;
<span class="line-added"> 34 import jdk.incubator.foreign.NativeScope;</span>
 35 import jdk.internal.foreign.NativeMemorySegmentImpl;
 36 import jdk.internal.foreign.Utils;
 37 import jdk.internal.foreign.abi.SharedUtils;
 38 import jdk.internal.misc.Unsafe;
 39 
 40 import java.lang.invoke.VarHandle;
 41 import java.lang.ref.Cleaner;
 42 import java.nio.ByteOrder;
 43 import java.util.ArrayList;
 44 import java.util.List;
 45 
 46 import static jdk.incubator.foreign.CSupport.AArch64;
 47 import static jdk.incubator.foreign.CSupport.VaList;
 48 import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
 49 import static jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;
 50 import static jdk.internal.foreign.abi.SharedUtils.checkCompatibleType;
 51 import static jdk.internal.foreign.abi.SharedUtils.vhPrimitiveOrAddress;
 52 import static jdk.internal.foreign.abi.aarch64.CallArranger.MAX_REGISTER_ARGUMENTS;
 53 
 54 public class AArch64VaList implements VaList {
</pre>
<hr />
<pre>
 90 
 91     private static final int MAX_GP_OFFSET = (int) LAYOUT_GP_REGS.byteSize();
 92     private static final int MAX_FP_OFFSET = (int) LAYOUT_FP_REGS.byteSize();
 93 
 94     private static final VarHandle VH_stack
 95         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__stack&quot;)));
 96     private static final VarHandle VH_gr_top
 97         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__gr_top&quot;)));
 98     private static final VarHandle VH_vr_top
 99         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__vr_top&quot;)));
100     private static final VarHandle VH_gr_offs
101         = LAYOUT.varHandle(int.class, groupElement(&quot;__gr_offs&quot;));
102     private static final VarHandle VH_vr_offs
103         = LAYOUT.varHandle(int.class, groupElement(&quot;__vr_offs&quot;));
104 
105     private static final Cleaner cleaner = Cleaner.create();
106     private static final CSupport.VaList EMPTY
107         = new SharedUtils.EmptyVaList(emptyListAddress());
108 
109     private final MemorySegment segment;


110     private final MemorySegment gpRegsArea;
<span class="line-added">111     private final MemorySegment fpRegsArea;</span>
<span class="line-added">112     private final List&lt;MemorySegment&gt; slices;</span>
113 
<span class="line-modified">114     private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea,</span>
<span class="line-added">115                           List&lt;MemorySegment&gt;  slices) {</span>
116         this.segment = segment;
<span class="line-added">117         this.gpRegsArea = gpRegsArea;</span>
<span class="line-added">118         this.fpRegsArea = fpRegsArea;</span>
<span class="line-added">119         this.slices = slices;</span>
<span class="line-added">120     }</span>
121 
<span class="line-modified">122     private static AArch64VaList readFromSegment(MemorySegment segment) {</span>
<span class="line-modified">123         MemorySegment gpRegsArea = MemorySegment.ofNativeRestricted(</span>
<span class="line-added">124             grTop(segment).addOffset(-MAX_GP_OFFSET), MAX_GP_OFFSET,</span>
125             segment.ownerThread(), null, null);
126 
<span class="line-modified">127         MemorySegment fpRegsArea = MemorySegment.ofNativeRestricted(</span>
<span class="line-modified">128             vrTop(segment).addOffset(-MAX_FP_OFFSET), MAX_FP_OFFSET,</span>
129             segment.ownerThread(), null, null);
<span class="line-modified">130         return new AArch64VaList(segment, gpRegsArea, fpRegsArea, List.of(gpRegsArea, fpRegsArea));</span>


131     }
132 
133     private static MemoryAddress emptyListAddress() {
134         long ptr = U.allocateMemory(LAYOUT.byteSize());
135         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
136                 MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null,
137                 () -&gt; U.freeMemory(ptr), null);
138         cleaner.register(AArch64VaList.class, ms::close);
139         MemoryAddress base = ms.baseAddress();
140         VH_stack.set(base, MemoryAddress.NULL);
141         VH_gr_top.set(base, MemoryAddress.NULL);
142         VH_vr_top.set(base, MemoryAddress.NULL);
143         VH_gr_offs.set(base, 0);
144         VH_vr_offs.set(base, 0);
145         return ms.withAccessModes(0).baseAddress();
146     }
147 
148     public static CSupport.VaList empty() {
149         return EMPTY;
150     }
151 
152     private MemoryAddress grTop() {
<span class="line-added">153         return grTop(segment);</span>
<span class="line-added">154     }</span>
<span class="line-added">155 </span>
<span class="line-added">156     private static MemoryAddress grTop(MemorySegment segment) {</span>
157         return (MemoryAddress) VH_gr_top.get(segment.baseAddress());
158     }
159 
160     private MemoryAddress vrTop() {
<span class="line-added">161         return vrTop(segment);</span>
<span class="line-added">162     }</span>
<span class="line-added">163 </span>
<span class="line-added">164     private static MemoryAddress vrTop(MemorySegment segment) {</span>
165         return (MemoryAddress) VH_vr_top.get(segment.baseAddress());
166     }
167 
168     private int grOffs() {
169         final int offs = (int) VH_gr_offs.get(segment.baseAddress());
170         assert offs &lt;= 0;
171         return offs;
172     }
173 
174     private int vrOffs() {
175         final int offs = (int) VH_vr_offs.get(segment.baseAddress());
176         assert offs &lt;= 0;
177         return offs;
178     }
179 
180     private MemoryAddress stackPtr() {
181         return (MemoryAddress) VH_stack.get(segment.baseAddress());
182     }
183 
184     private void stackPtr(MemoryAddress ptr) {
</pre>
<hr />
<pre>
229     @Override
230     public long vargAsLong(MemoryLayout layout) {
231         return (long) read(long.class, layout);
232     }
233 
234     @Override
235     public double vargAsDouble(MemoryLayout layout) {
236         return (double) read(double.class, layout);
237     }
238 
239     @Override
240     public MemoryAddress vargAsAddress(MemoryLayout layout) {
241         return (MemoryAddress) read(MemoryAddress.class, layout);
242     }
243 
244     @Override
245     public MemorySegment vargAsSegment(MemoryLayout layout) {
246         return (MemorySegment) read(MemorySegment.class, layout);
247     }
248 
<span class="line-added">249     @Override</span>
<span class="line-added">250     public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {</span>
<span class="line-added">251         return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));</span>
<span class="line-added">252     }</span>
<span class="line-added">253 </span>
254     private Object read(Class&lt;?&gt; carrier, MemoryLayout layout) {
<span class="line-added">255         return read(carrier, layout, MemorySegment::allocateNative);</span>
<span class="line-added">256     }</span>
<span class="line-added">257 </span>
<span class="line-added">258     private Object read(Class&lt;?&gt; carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {</span>
259         checkCompatibleType(carrier, layout, AArch64Linker.ADDRESS_SIZE);
260 
261         TypeClass typeClass = TypeClass.classifyLayout(layout);
262         if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {
263             preAlignStack(layout);
264             return switch (typeClass) {
265                 case STRUCT_REGISTER, STRUCT_HFA, STRUCT_REFERENCE -&gt; {
266                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
267                              stackPtr(), layout.byteSize(),
268                              segment.ownerThread(), null, null)) {
<span class="line-modified">269                         MemorySegment seg = allocator.allocate(layout);</span>
270                         seg.copyFrom(slice);
271                         postAlignStack(layout);
272                         yield seg;
273                     }
274                 }
275                 case POINTER, INTEGER, FLOAT -&gt; {
276                     VarHandle reader = vhPrimitiveOrAddress(carrier, layout);
277                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
278                              stackPtr(), layout.byteSize(),
279                              segment.ownerThread(), null, null)) {
280                         Object res = reader.get(slice.baseAddress());
281                         postAlignStack(layout);
282                         yield res;
283                     }
284                 }
285             };
286         } else {
287             return switch (typeClass) {
288                 case STRUCT_REGISTER -&gt; {
289                     // Struct is passed packed in integer registers.
<span class="line-modified">290                     MemorySegment value = allocator.allocate(layout);</span>
291                     long offset = 0;
292                     while (offset &lt; layout.byteSize()) {
293                         final long copy = Math.min(layout.byteSize() - offset, 8);
294                         MemorySegment slice = value.asSlice(offset, copy);
295                         slice.copyFrom(gpRegsArea.asSlice(currentGPOffset(), copy));
296                         consumeGPSlots(1);
297                         offset += copy;
298                     }
299                     yield value;
300                 }
301                 case STRUCT_HFA -&gt; {
302                     // Struct is passed with each element in a separate floating
303                     // point register.
<span class="line-modified">304                     MemorySegment value = allocator.allocate(layout);</span>
305                     GroupLayout group = (GroupLayout)layout;
306                     long offset = 0;
307                     for (MemoryLayout elem : group.memberLayouts()) {
308                         assert elem.byteSize() &lt;= 8;
309                         final long copy = elem.byteSize();
310                         MemorySegment slice = value.asSlice(offset, copy);
311                         slice.copyFrom(fpRegsArea.asSlice(currentFPOffset(), copy));
312                         consumeFPSlots(1);
313                         offset += copy;
314                     }
315                     yield value;
316                 }
317                 case STRUCT_REFERENCE -&gt; {
318                     // Struct is passed indirectly via a pointer in an integer register.
319                     VarHandle ptrReader
320                         = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class, AArch64.C_POINTER);
321                     MemoryAddress ptr = (MemoryAddress) ptrReader.get(
322                         gpRegsArea.baseAddress().addOffset(currentGPOffset()));
323                     consumeGPSlots(1);
324 
325                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
326                              ptr, layout.byteSize(), segment.ownerThread(), null, null)) {
<span class="line-modified">327                         MemorySegment seg = allocator.allocate(layout);</span>
328                         seg.copyFrom(slice);
329                         yield seg;
330                     }
331                 }
332                 case POINTER, INTEGER -&gt; {
333                     VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
334                     Object res = reader.get(gpRegsArea.baseAddress().addOffset(currentGPOffset()));
335                     consumeGPSlots(1);
336                     yield res;
337                 }
338                 case FLOAT -&gt; {
339                     VarHandle reader = layout.varHandle(carrier);
340                     Object res = reader.get(fpRegsArea.baseAddress().addOffset(currentFPOffset()));
341                     consumeFPSlots(1);
342                     yield res;
343                 }
344             };
345         }
346     }
347 
348     @Override
349     public void skip(MemoryLayout... layouts) {
350         for (MemoryLayout layout : layouts) {
351             TypeClass typeClass = TypeClass.classifyLayout(layout);
352             if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {
353                 preAlignStack(layout);
354                 postAlignStack(layout);
355             } else if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {
356                 consumeFPSlots(numSlots(layout));
357             } else if (typeClass == TypeClass.STRUCT_REFERENCE) {
358                 consumeGPSlots(1);
359             } else {
360                 consumeGPSlots(numSlots(layout));
361             }
362         }
363     }
364 
<span class="line-modified">365     static AArch64VaList.Builder builder(SharedUtils.Allocator allocator) {</span>
<span class="line-modified">366         return new AArch64VaList.Builder(allocator);</span>
367     }
368 
369     public static VaList ofAddress(MemoryAddress ma) {
<span class="line-modified">370         return readFromSegment(MemorySegment.ofNativeRestricted(</span>

371                 ma, LAYOUT.byteSize(), Thread.currentThread(), null, null));
372     }
373 
374     @Override
375     public boolean isAlive() {
376         return segment.isAlive();
377     }
378 
379     @Override
380     public void close() {
381         segment.close();
382         slices.forEach(MemorySegment::close);
383     }
384 
385     @Override
386     public VaList copy() {
<span class="line-modified">387         return copy(MemorySegment::allocateNative);</span>
<span class="line-added">388     }</span>
<span class="line-added">389 </span>
<span class="line-added">390     @Override</span>
<span class="line-added">391     public VaList copy(NativeScope scope) {</span>
<span class="line-added">392         return copy(SharedUtils.Allocator.ofScope(scope));</span>
<span class="line-added">393     }</span>
<span class="line-added">394 </span>
<span class="line-added">395     private VaList copy(SharedUtils.Allocator allocator) {</span>
<span class="line-added">396         MemorySegment copy = allocator.allocate(LAYOUT);</span>
397         copy.copyFrom(segment);
<span class="line-modified">398         return readFromSegment(copy);</span>
399     }
400 
401     @Override
402     public MemoryAddress address() {
403         return segment.baseAddress();
404     }
405 
406     private static int numSlots(MemoryLayout layout) {
407         return (int) Utils.alignUp(layout.byteSize(), 8) / 8;
408     }
409 
410     private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset,
411                                          TypeClass typeClass, MemoryLayout layout) {
412         if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {
413             return currentFPOffset &gt; MAX_FP_OFFSET - numSlots(layout) * FP_SLOT_SIZE;
414         } else if (typeClass == TypeClass.STRUCT_REFERENCE) {
415             return currentGPOffset &gt; MAX_GP_OFFSET - GP_SLOT_SIZE;
416         } else {
417             return currentGPOffset &gt; MAX_GP_OFFSET - numSlots(layout) * GP_SLOT_SIZE;
418         }
419     }
420 
421     @Override
422     public String toString() {
423         return &quot;AArch64VaList{&quot;
424             + &quot;__stack=&quot; + stackPtr()
425             + &quot;, __gr_top=&quot; + grTop()
426             + &quot;, __vr_top=&quot; + vrTop()
427             + &quot;, __gr_offs=&quot; + grOffs()
428             + &quot;, __vr_offs=&quot; + vrOffs()
429             + &#39;}&#39;;
430     }
431 
432     static class Builder implements CSupport.VaList.Builder {
<span class="line-modified">433         private final SharedUtils.Allocator allocator;</span>
<span class="line-modified">434         private final MemorySegment gpRegs;</span>
<span class="line-modified">435         private final MemorySegment fpRegs;</span>

436 
437         private long currentGPOffset = 0;
438         private long currentFPOffset = 0;
439         private final List&lt;SimpleVaArg&gt; stackArgs = new ArrayList&lt;&gt;();
440 
<span class="line-added">441         Builder(SharedUtils.Allocator allocator) {</span>
<span class="line-added">442             this.allocator = allocator;</span>
<span class="line-added">443             this.gpRegs = allocator.allocate(LAYOUT_GP_REGS);</span>
<span class="line-added">444             this.fpRegs = allocator.allocate(LAYOUT_FP_REGS);</span>
<span class="line-added">445         }</span>
<span class="line-added">446 </span>
447         @Override
448         public Builder vargFromInt(MemoryLayout layout, int value) {
449             return arg(int.class, layout, value);
450         }
451 
452         @Override
453         public Builder vargFromLong(MemoryLayout layout, long value) {
454             return arg(long.class, layout, value);
455         }
456 
457         @Override
458         public Builder vargFromDouble(MemoryLayout layout, double value) {
459             return arg(double.class, layout, value);
460         }
461 
462         @Override
463         public Builder vargFromAddress(MemoryLayout layout, MemoryAddress value) {
464             return arg(MemoryAddress.class, layout, value);
465         }
466 
</pre>
<hr />
<pre>
521                     }
522                     case FLOAT -&gt; {
523                         VarHandle writer = layout.varHandle(carrier);
524                         writer.set(fpRegs.baseAddress().addOffset(currentFPOffset), value);
525                         currentFPOffset += FP_SLOT_SIZE;
526                     }
527                 }
528             }
529             return this;
530         }
531 
532         private boolean isEmpty() {
533             return currentGPOffset == 0 &amp;&amp; currentFPOffset == 0 &amp;&amp; stackArgs.isEmpty();
534         }
535 
536         public VaList build() {
537             if (isEmpty()) {
538                 return EMPTY;
539             }
540 
<span class="line-modified">541             MemorySegment vaListSegment = allocator.allocate(LAYOUT);</span>
<span class="line-modified">542             List&lt;MemorySegment&gt; slices = new ArrayList&lt;&gt;();</span>

543             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
544             if (!stackArgs.isEmpty()) {
545                 long stackArgsSize = stackArgs.stream()
546                     .reduce(0L, (acc, e) -&gt; acc + Utils.alignUp(e.layout.byteSize(), 8), Long::sum);
<span class="line-modified">547                 MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);</span>
548                 MemoryAddress maStackArea = stackArgsSegment.baseAddress();
549                 for (SimpleVaArg arg : stackArgs) {
550                     final long alignedSize = Utils.alignUp(arg.layout.byteSize(), 8);
551                     maStackArea = Utils.alignUp(maStackArea, alignedSize);
552                     VarHandle writer = arg.varHandle();
553                     writer.set(maStackArea, arg.value);
554                     maStackArea = maStackArea.addOffset(alignedSize);
555                 }
556                 stackArgsPtr = stackArgsSegment.baseAddress();
<span class="line-modified">557                 slices.add(stackArgsSegment);</span>
558             }
559 
560             MemoryAddress vaListAddr = vaListSegment.baseAddress();
561             VH_gr_top.set(vaListAddr, gpRegs.baseAddress().addOffset(gpRegs.byteSize()));
562             VH_vr_top.set(vaListAddr, fpRegs.baseAddress().addOffset(fpRegs.byteSize()));
563             VH_stack.set(vaListAddr, stackArgsPtr);
564             VH_gr_offs.set(vaListAddr, -MAX_GP_OFFSET);
565             VH_vr_offs.set(vaListAddr, -MAX_FP_OFFSET);
566 
<span class="line-modified">567             slices.add(gpRegs);</span>
<span class="line-modified">568             slices.add(fpRegs);</span>
569             assert gpRegs.ownerThread() == vaListSegment.ownerThread();
570             assert fpRegs.ownerThread() == vaListSegment.ownerThread();
<span class="line-modified">571             return new AArch64VaList(vaListSegment, gpRegs, fpRegs, slices);</span>
572         }
573     }
574 }
</pre>
</td>
</tr>
</table>
<center><a href="AArch64Linker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../x64/sysv/SysVVaList.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 29 import jdk.internal.foreign.Utils;
 30 import jdk.internal.foreign.abi.SharedUtils;
 31 
<a name="1" id="anc1"></a><span class="line-removed"> 32 import java.lang.invoke.VarHandle;</span>
 33 import java.nio.ByteOrder;
 34 import java.nio.charset.Charset;
 35 import java.util.Objects;
 36 import java.util.function.Consumer;
 37 
 38 /**
 39  * A set of utilities for working with libraries using the C language/ABI
 40  */
 41 public class CSupport {
 42     /**
 43      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 44      * &lt;p&gt;
 45      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 46      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 47      * restricted methods, and use safe and supported functionalities, where possible.
 48      * @return a linker for this system.
 49      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 50      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 51      */
 52     public static ForeignLinker getSystemLinker() {
 53         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 54         return SharedUtils.getSystemLinker();
 55     }
 56 
 57     /**
 58      * An interface that models a C {@code va_list}.
<a name="2" id="anc2"></a><span class="line-modified"> 59      *</span>


 60      * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),
 61      * arguments to variadic calls are erased by way of &#39;default argument promotions&#39;,
 62      * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),
 63      * and which erases all {@code float} arguments to {@code double}.
<a name="3" id="anc3"></a><span class="line-modified"> 64      *</span>
 65      * As such, this interface only supports reading {@code int}, {@code double},
 66      * and any other type that fits into a {@code long}.
 67      */
 68     public interface VaList extends AutoCloseable {
 69 
 70         /**
<a name="4" id="anc4"></a><span class="line-modified"> 71          * Reads a value into an {@code int}</span>
 72          *
 73          * @param layout the layout of the value
 74          * @return the value read as an {@code int}
 75          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 76          * (see {@link #close()}).
<a name="5" id="anc5"></a>
 77          */
 78         int vargAsInt(MemoryLayout layout);
 79 
 80         /**
<a name="6" id="anc6"></a><span class="line-modified"> 81          * Reads a value into a {@code long}</span>
 82          *
 83          * @param layout the layout of the value
 84          * @return the value read as an {@code long}
 85          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 86          * (see {@link #close()}).
<a name="7" id="anc7"></a>
 87          */
 88         long vargAsLong(MemoryLayout layout);
 89 
 90         /**
<a name="8" id="anc8"></a><span class="line-modified"> 91          * Reads a value into a {@code double}</span>
 92          *
 93          * @param layout the layout of the value
 94          * @return the value read as an {@code double}
 95          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 96          * (see {@link #close()}).
<a name="9" id="anc9"></a>
 97          */
 98         double vargAsDouble(MemoryLayout layout);
 99 
100         /**
<a name="10" id="anc10"></a><span class="line-modified">101          * Reads a value into a {@code MemoryAddress}</span>
102          *
103          * @param layout the layout of the value
104          * @return the value read as an {@code MemoryAddress}
105          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
106          * (see {@link #close()}).
<a name="11" id="anc11"></a>
107          */
108         MemoryAddress vargAsAddress(MemoryLayout layout);
109 
110         /**
<a name="12" id="anc12"></a><span class="line-modified">111          * Reads a value into a {@code MemorySegment}</span>



112          *
113          * @param layout the layout of the value
114          * @return the value read as an {@code MemorySegment}
115          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
116          * (see {@link #close()}).
<a name="13" id="anc13"></a>
117          */
118         MemorySegment vargAsSegment(MemoryLayout layout);
119 
120         /**
<a name="14" id="anc14"></a><span class="line-modified">121          * Skips a number of va arguments with the given memory layouts.</span>














122          *
123          * @param layouts the layout of the value
124          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
125          * (see {@link #close()}).
126          */
127         void skip(MemoryLayout... layouts);
128 
129         /**
130          * A predicate used to check if the memory associated with the C {@code va_list} modelled
<a name="15" id="anc15"></a><span class="line-modified">131          * by this instance is still valid; or, in other words, if {@code close()} has been called on this</span>
<span class="line-removed">132          * instance.</span>
133          *
134          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
135          * @see #close()
136          */
137         boolean isAlive();
138 
139         /**
<a name="16" id="anc16"></a><span class="line-modified">140          * Releases the underlying C {@code va_list} modelled by this instance. As a result, subsequent attempts to call</span>
<span class="line-modified">141          * operations on this instance (e.g. {@link #copy()} will fail with an exception.</span>



142          *
143          * @see #isAlive()
144          */
145         void close();
146 
147         /**
<a name="17" id="anc17"></a><span class="line-modified">148          * Copies this C {@code va_list}.</span>











149          *
150          * @return a copy of this C {@code va_list}.
151          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
152          * (see {@link #close()}).
153          */
154         VaList copy();
155 
<a name="18" id="anc18"></a>



















156         /**
157          * Returns the memory address of the C {@code va_list} associated with this instance.
158          *
159          * @return the memory address of the C {@code va_list} associated with this instance.
160          */
161         MemoryAddress address();
162 
163         /**
164          * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.
165          *
166          * @param address a memory address pointing to an existing C {@code va_list}.
167          * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.
168          */
169         static VaList ofAddress(MemoryAddress address) {
170             return SharedUtils.newVaListOfAddress(address);
171         }
172 
173         /**
174          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
<a name="19" id="anc19"></a><span class="line-modified">175          *</span>
<span class="line-modified">176          * Note that when there are no arguments added to the created va list,</span>







177          * this method will return the same as {@linkplain #empty()}.
178          *
<a name="20" id="anc20"></a><span class="line-modified">179          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the contents</span>
180          *                of the underlying C {@code va_list}.
181          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
182          */
183         static VaList make(Consumer&lt;VaList.Builder&gt; actions) {
<a name="21" id="anc21"></a><span class="line-modified">184             return SharedUtils.newVaList(actions);</span>
185         }
186 
187         /**
<a name="22" id="anc22"></a><span class="line-modified">188          * Returns an empty C {@code va_list} constant.</span>









189          *
<a name="23" id="anc23"></a>










190          * The returned {@code VaList} can not be closed.
191          *
192          * @return a {@code VaList} modelling an empty C {@code va_list}.
193          */
194         static VaList empty() {
195             return SharedUtils.emptyVaList();
196         }
197 
198         /**
199          * A builder interface used to construct a C {@code va_list}.
200          */
201         interface Builder {
202 
203             /**
204              * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.
205              *
206              * @param layout the native layout of the value.
207              * @param value the value, represented as an {@code int}.
208              * @return this builder.
<a name="24" id="anc24"></a>
209              */
210             Builder vargFromInt(MemoryLayout layout, int value);
211 
212             /**
213              * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.
214              *
215              * @param layout the native layout of the value.
216              * @param value the value, represented as a {@code long}.
217              * @return this builder.
<a name="25" id="anc25"></a>
218              */
219             Builder vargFromLong(MemoryLayout layout, long value);
220 
221             /**
222              * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.
223              *
224              * @param layout the native layout of the value.
225              * @param value the value, represented as a {@code double}.
226              * @return this builder.
<a name="26" id="anc26"></a>
227              */
228             Builder vargFromDouble(MemoryLayout layout, double value);
229 
230             /**
231              * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.
232              *
233              * @param layout the native layout of the value.
234              * @param value the value, represented as a {@code MemoryAddress}.
235              * @return this builder.
<a name="27" id="anc27"></a>
236              */
237             Builder vargFromAddress(MemoryLayout layout, MemoryAddress value);
238 
239             /**
240              * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.
241              *
242              * @param layout the native layout of the value.
243              * @param value the value, represented as a {@code MemorySegment}.
244              * @return this builder.
<a name="28" id="anc28"></a>
245              */
246             Builder vargFromSegment(MemoryLayout layout, MemorySegment value);
247         }
248     }
249 
250     /**
251      * The {@code _Bool} native type.
252      */
253     public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
254     /**
255      * The {@code char} native type.
256      */
257     public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
258     /**
259      * The {@code short} native type.
260      */
261     public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
262     /**
263      * The {@code int} native type.
264      */
265     public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
266     /**
267      * The {@code long} native type.
268      */
269     public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
270     /**
271      * The {@code long long} native type.
272      */
273     public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
274     /**
275      * The {@code float} native type.
276      */
277     public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
278     /**
279      * The {@code double} native type.
280      */
281     public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
282     /**
283      * The {@code long double} native type.
284      */
285     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
286     /**
287      * The {@code T*} native type.
288      */
289     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
290 
291     /**
292      * The {@code va_list} native type.
293      */
294     public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);
295 
296     /**
297      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
298      */
299     public static final class SysV {
300         private SysV() {
301             //just the one
302         }
303 
304         /**
305          * The name of the SysV linker
306          * @see ForeignLinker#name
307          */
308         public static final String NAME = &quot;SysV&quot;;
309 
310         /**
311          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
312          * attribute value must be an enum constant from {@link ArgumentClass}.
313          */
314         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
315 
316         /**
317          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
318          */
319         public enum ArgumentClass {
320             /** Classification constant for integral values */
321             INTEGER,
322             /** Classification constant for floating point values */
323             SSE,
324             /** Classification constant for x87 floating point values */
325             X87,
326             /** Classification constant for {@code complex long double} values */
327             COMPLEX_87,
328             /** Classification constant for machine pointer values */
329             POINTER;
330         }
331 
332         /**
333          * The {@code _Bool} native type.
334          */
335         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
336                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
337 
338         /**
339          * The {@code char} native type.
340          */
341         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
342                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
343 
344         /**
345          * The {@code short} native type.
346          */
347         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
348                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
349 
350         /**
351          * The {@code int} native type.
352          */
353         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
354                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
355 
356         /**
357          * The {@code long} native type.
358          */
359         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
360                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
361 
362         /**
363          * The {@code long long} native type.
364          */
365         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
366                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
367 
368         /**
369          * The {@code float} native type.
370          */
371         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
372                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
373 
374         /**
375          * The {@code double} native type.
376          */
377         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
378                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
379 
380         /**
381          * The {@code long double} native type.
382          */
383         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
384                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
385 
386         /**
387          * The {@code complex long double} native type.
388          */
389         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
390                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
391 
392         /**
393          * The {@code T*} native type.
394          */
395         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
396                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
397 
398         /**
399          * The {@code va_list} native type, as it is passed to a function.
400          */
401         public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;
402     }
403 
404     /**
405      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
406      */
407     public static final class Win64 {
408 
409         private Win64() {
410             //just the one
411         }
412 
413         /**
414          * The name of the Windows linker
415          * @see ForeignLinker#name
416          */
417         public final static String NAME = &quot;Windows&quot;;
418 
419         /**
420          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The
421          * attribute value must be a boolean.
422          */
423         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
424 
425         /**
426          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
427          * attribute value must be an enum constant from {@link ArgumentClass}.
428          */
429         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
430 
431         /**
432          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
433          */
434         public enum ArgumentClass {
435             /** Classification constant for integral values */
436             INTEGER,
437             /** Classification constant for floating point values */
438             FLOAT,
439             /** Classification constant for machine pointer values */
440             POINTER;
441         }
442 
443         /**
444          * The {@code _Bool} native type.
445          */
446         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
447                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
448 
449         /**
450          * The {@code char} native type.
451          */
452         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
453                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
454 
455         /**
456          * The {@code short} native type.
457          */
458         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
459                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
460 
461         /**
462          * The {@code int} native type.
463          */
464         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
465                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
466 
467         /**
468          * The {@code long} native type.
469          */
470         public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
471                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
472 
473         /**
474          * The {@code long long} native type.
475          */
476         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
477                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
478 
479         /**
480          * The {@code float} native type.
481          */
482         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
483                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
484 
485         /**
486          * The {@code double} native type.
487          */
488         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
489                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
490 
491         /**
492          * The {@code long double} native type.
493          */
494         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
495                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
496 
497         /**
498          * The {@code T*} native type.
499          */
500         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
501                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
502 
503         /**
504          * The {@code va_list} native type, as it is passed to a function.
505          */
506         public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;
507 
508         /**
509          * Return a new memory layout which describes a variadic parameter to be passed to a function.
510          * @param layout the original parameter layout.
511          * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},
512          * which is set to {@code true}.
513          */
514         public static ValueLayout asVarArg(ValueLayout layout) {
515             return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);
516         }
517     }
518 
519     /**
520      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
521      */
522     public static final class AArch64 {
523 
524         private AArch64() {
525             //just the one
526         }
527 
528         /**
529          * The name of the AArch64 linker
530          * @see ForeignLinker#name
531          */
532         public final static String NAME = &quot;AArch64&quot;;
533 
534         /**
535          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
536          * attribute value must be an enum constant from {@link ArgumentClass}.
537          */
538         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
539 
540         /**
541          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
542          */
543         public enum ArgumentClass {
544             /** Classification constant for machine integral values */
545             INTEGER,
546             /** Classification constant for machine floating point values */
547             VECTOR,
548             /** Classification constant for machine pointer values */
549             POINTER;
550         }
551 
552         /**
553          * The {@code _Bool} native type.
554          */
555         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
556                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
557 
558         /**
559          * The {@code char} native type.
560          */
561         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
562                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
563 
564         /**
565          * The {@code short} native type.
566          */
567         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
568                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
569 
570         /**
571          * The {@code int} native type.
572          */
573         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
574                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
575 
576         /**
577          * The {@code long} native type.
578          */
579         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
580                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
581 
582         /**
583          * The {@code long long} native type.
584          */
585         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
586                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
587 
588         /**
589          * The {@code float} native type.
590          */
591         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
592                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
593 
594         /**
595          * The {@code double} native type.
596          */
597         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
598                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
599 
600         /**
601          * The {@code long double} native type.
602          */
603         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
604                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
605 
606         /**
607          * The {@code T*} native type.
608          */
609         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
610                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
611 
612         /**
613          * The {@code va_list} native type, as it is passed to a function.
614          */
615         public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;
616     }
617 
618     /**
619      * Convert a Java string into a null-terminated C string, using the
620      * platform&#39;s default charset, storing the result into a new native memory segment.
621      * &lt;p&gt;
622      * This method always replaces malformed-input and unmappable-character
623      * sequences with this charset&#39;s default replacement byte array.  The
624      * {@link java.nio.charset.CharsetEncoder} class should be used when more
625      * control over the encoding process is required.
626      *
627      * @param str the Java string to be converted into a C string.
628      * @return a new native memory segment containing the converted C string.
629      * @throws NullPointerException if either {@code str == null}.
630      */
631     public static MemorySegment toCString(String str) {
632         Objects.requireNonNull(str);
633         return toCString(str.getBytes());
634     }
635 
636     /**
637      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
638      * storing the result into a new native memory segment.
639      * &lt;p&gt;
640      * This method always replaces malformed-input and unmappable-character
641      * sequences with this charset&#39;s default replacement byte array.  The
642      * {@link java.nio.charset.CharsetEncoder} class should be used when more
643      * control over the encoding process is required.
644      *
645      * @param str the Java string to be converted into a C string.
646      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
647      * @return a new native memory segment containing the converted C string.
648      * @throws NullPointerException if either {@code str == null} or {@code charset == null}.
649      */
650     public static MemorySegment toCString(String str, Charset charset) {
651         Objects.requireNonNull(str);
652         Objects.requireNonNull(charset);
653         return toCString(str.getBytes(charset));
654     }
655 
656     /**
657      * Convert a Java string into a null-terminated C string, using the platform&#39;s default charset,
658      * storing the result into a native memory segment allocated using the provided scope.
659      * &lt;p&gt;
660      * This method always replaces malformed-input and unmappable-character
661      * sequences with this charset&#39;s default replacement byte array.  The
662      * {@link java.nio.charset.CharsetEncoder} class should be used when more
663      * control over the encoding process is required.
664      *
665      * @param str the Java string to be converted into a C string.
666      * @param scope the scope to be used for the native segment allocation.
667      * @return a new native memory segment containing the converted C string.
668      * @throws NullPointerException if either {@code str == null} or {@code scope == null}.
669      */
670     public static MemoryAddress toCString(String str, NativeScope scope) {
671         Objects.requireNonNull(str);
672         Objects.requireNonNull(scope);
673         return toCString(str.getBytes(), scope);
674     }
675 
676     /**
677      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
678      * storing the result into a new native memory segment native memory segment allocated using the provided scope.
679      * &lt;p&gt;
680      * This method always replaces malformed-input and unmappable-character
681      * sequences with this charset&#39;s default replacement byte array.  The
682      * {@link java.nio.charset.CharsetEncoder} class should be used when more
683      * control over the encoding process is required.
684      *
685      * @param str the Java string to be converted into a C string.
686      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
687      * @param scope the scope to be used for the native segment allocation.
688      * @return a new native memory segment containing the converted C string.
689      * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.
690      */
691     public static MemoryAddress toCString(String str, Charset charset, NativeScope scope) {
692         Objects.requireNonNull(str);
693         Objects.requireNonNull(charset);
694         Objects.requireNonNull(scope);
695         return toCString(str.getBytes(charset), scope);
696     }
697 
698     /**
699      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
700      * &lt;p&gt;
701      * This method always replaces malformed-input and unmappable-character
702      * sequences with this charset&#39;s default replacement string.  The {@link
703      * java.nio.charset.CharsetDecoder} class should be used when more control
704      * over the decoding process is required.
705      * &lt;p&gt;
706      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
707      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
708      * restricted methods, and use safe and supported functionalities, where possible.
709      * @param addr the address at which the string is stored.
710      * @return a Java string with the contents of the null-terminated C string at given address.
711      * @throws NullPointerException if {@code addr == null}
712      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
713      */
714     public static String toJavaStringRestricted(MemoryAddress addr) {
715         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
716         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), Charset.defaultCharset());
717     }
718 
719     /**
720      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
721      * &lt;p&gt;
722      * This method always replaces malformed-input and unmappable-character
723      * sequences with this charset&#39;s default replacement string.  The {@link
724      * java.nio.charset.CharsetDecoder} class should be used when more control
725      * over the decoding process is required.
726      * &lt;p&gt;
727      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
728      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
729      * restricted methods, and use safe and supported functionalities, where possible.
730      * @param addr the address at which the string is stored.
731      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
732      * @return a Java string with the contents of the null-terminated C string at given address.
733      * @throws NullPointerException if {@code addr == null}
734      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
735      */
736     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
737         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
738         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), charset);
739     }
740 
741     /**
742      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
743      * &lt;p&gt;
744      * This method always replaces malformed-input and unmappable-character
745      * sequences with this charset&#39;s default replacement string.  The {@link
746      * java.nio.charset.CharsetDecoder} class should be used when more control
747      * over the decoding process is required.
748      * @param addr the address at which the string is stored.
749      * @return a Java string with the contents of the null-terminated C string at given address.
750      * @throws NullPointerException if {@code addr == null}
751      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
752      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
753      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
754      */
755     public static String toJavaString(MemoryAddress addr) {
756         return SharedUtils.toJavaStringInternal(addr, Charset.defaultCharset());
757     }
758 
759     /**
760      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
761      * &lt;p&gt;
762      * This method always replaces malformed-input and unmappable-character
763      * sequences with this charset&#39;s default replacement string.  The {@link
764      * java.nio.charset.CharsetDecoder} class should be used when more control
765      * over the decoding process is required.
766      * @param addr the address at which the string is stored.
767      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
768      * @return a Java string with the contents of the null-terminated C string at given address.
769      * @throws NullPointerException if {@code addr == null}
770      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
771      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
772      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
773      */
774     public static String toJavaString(MemoryAddress addr, Charset charset) {
775         return SharedUtils.toJavaStringInternal(addr, charset);
776     }
777 
778     private static void copy(MemoryAddress addr, byte[] bytes) {
779         var heapSegment = MemorySegment.ofArray(bytes);
780         addr.segment().copyFrom(heapSegment);
781         MemoryAccess.setByte(addr, bytes.length, (byte)0);
782     }
783 
784     private static MemorySegment toCString(byte[] bytes) {
785         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
786         MemoryAddress addr = segment.baseAddress();
787         copy(addr, bytes);
788         return segment;
789     }
790 
791     private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
792         MemoryAddress addr = scope.allocate(bytes.length + 1, 1L);
793         copy(addr, bytes);
794         return addr;
795     }
796 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
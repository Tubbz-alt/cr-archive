<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 29 import jdk.internal.foreign.Utils;
 30 import jdk.internal.foreign.abi.SharedUtils;
 31 
 32 import java.nio.ByteOrder;
 33 import java.nio.charset.Charset;
 34 import java.util.Objects;
 35 import java.util.function.Consumer;
 36 
 37 /**
 38  * A set of utilities for working with libraries using the C language/ABI
 39  */
 40 public class CSupport {
 41     /**
 42      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 43      * &lt;p&gt;
 44      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 45      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 46      * restricted methods, and use safe and supported functionalities, where possible.
 47      * @return a linker for this system.
 48      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 49      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 50      */
 51     public static ForeignLinker getSystemLinker() {
 52         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 53         return SharedUtils.getSystemLinker();
 54     }
 55 
 56     /**
 57      * An interface that models a C {@code va_list}.
 58      *
 59      * A va list is a stateful cursor used to iterate over a set of variadic arguments.
 60      *
 61      * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),
 62      * arguments to variadic calls are erased by way of &#39;default argument promotions&#39;,
 63      * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),
 64      * and which erases all {@code float} arguments to {@code double}.
 65      *
 66      * As such, this interface only supports reading {@code int}, {@code double},
 67      * and any other type that fits into a {@code long}.
 68      */
 69     public interface VaList extends AutoCloseable {
 70 
 71         /**
 72          * Reads the next value into an {@code int} and advances this va list&#39;s position.
 73          *
 74          * @param layout the layout of the value
 75          * @return the value read as an {@code int}
 76          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 77          * (see {@link #close()}).
 78          */
 79         int vargAsInt(MemoryLayout layout);
 80 
 81         /**
 82          * Reads the next value into a {@code long} and advances this va list&#39;s position.
 83          *
 84          * @param layout the layout of the value
 85          * @return the value read as an {@code long}
 86          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 87          * (see {@link #close()}).
 88          */
 89         long vargAsLong(MemoryLayout layout);
 90 
 91         /**
 92          * Reads the next value into a {@code double} and advances this va list&#39;s position.
 93          *
 94          * @param layout the layout of the value
 95          * @return the value read as an {@code double}
 96          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 97          * (see {@link #close()}).
 98          */
 99         double vargAsDouble(MemoryLayout layout);
100 
101         /**
102          * Reads the next value into a {@code MemoryAddress} and advances this va list&#39;s position.
103          *
104          * @param layout the layout of the value
105          * @return the value read as an {@code MemoryAddress}
106          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
107          * (see {@link #close()}).
108          */
109         MemoryAddress vargAsAddress(MemoryLayout layout);
110 
111         /**
112          * Reads the next value into a {@code MemorySegment}, and advances this va list&#39;s position.
113          *
114          * The memory segment returned by this method will be allocated using
115          * {@link MemorySegment#allocateNative(long, long)}, and will have to be closed separately.
116          *
117          * @param layout the layout of the value
118          * @return the value read as an {@code MemorySegment}
119          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
120          * (see {@link #close()}).
121          */
122         MemorySegment vargAsSegment(MemoryLayout layout);
123 
124         /**
125          * Reads the next value into a {@code MemorySegment}, and advances this va list&#39;s position.
126          *
127          * The memory segment returned by this method will be allocated using the given {@code NativeScope}.
128          *
129          * @param layout the layout of the value
130          * @param scope the scope to allocate the segment in
131          * @return the value read as an {@code MemorySegment}
132          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
133          * (see {@link #close()}).
134          */
135         MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);
136 
137         /**
<a name="1" id="anc1"></a><span class="line-modified">138          * Skips a number of arguments with the given memory layouts, and advancing this va list&#39;s position.</span>
139          *
140          * @param layouts the layout of the value
141          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
142          * (see {@link #close()}).
143          */
144         void skip(MemoryLayout... layouts);
145 
146         /**
147          * A predicate used to check if the memory associated with the C {@code va_list} modelled
148          * by this instance is still valid to use.
149          *
150          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
151          * @see #close()
152          */
153         boolean isAlive();
154 
155         /**
156          * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached
157          * to this va list that holds its elements (see {@link VaList#make(Consumer)}).
158          *
159          * For some {@code VaList} instances, calling this method will have no effect. For instance: on Windows, a copy
160          * of a va list does not need any native memory, so nothing has to be released. After calling {@code close()} on
161          * such an instance {@link #isAlive()} will still return {@code true}.
162          *
163          * @see #isAlive()
164          */
165         void close();
166 
167         /**
168          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
169          * starting from the current position, without affecting the state of the original va list, essentially
170          * allowing the elements to be traversed multiple times.
171          *
172          * If this method needs to allocate native memory for the copy, it will use
173          * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the
174          * returned va list instance to release the allocated memory.
175          *
176          * This method only copies the va list cursor itself and not the memory that may be attached to the
177          * va list which holds its elements. That means that if this va list was created with the
178          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
179          * elements, making the copy unusable.
180          *
181          * @return a copy of this C {@code va_list}.
182          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
183          * (see {@link #close()}).
184          */
185         VaList copy();
186 
187         /**
188          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
189          * starting from the current position, without affecting the state of the original va list, essentially
190          * allowing the elements to be traversed multiple times.
191          *
192          * If this method needs to allocate native memory for the copy, it will use
193          * the given {@code NativeScope} to do so.
194          *
195          * This method only copies the va list cursor itself and not the memory that may be attached to the
196          * va list which holds its elements. That means that if this va list was created with the
197          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
198          * elements, making the copy unusable.
199          *
200          * @param scope the scope to allocate the copy in
201          * @return a copy of this C {@code va_list}.
202          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
203          * (see {@link #close()}).
204          */
205         VaList copy(NativeScope scope);
206 
207         /**
208          * Returns the memory address of the C {@code va_list} associated with this instance.
209          *
210          * @return the memory address of the C {@code va_list} associated with this instance.
211          */
212         MemoryAddress address();
213 
214         /**
215          * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.
216          *
217          * @param address a memory address pointing to an existing C {@code va_list}.
218          * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.
219          */
220         static VaList ofAddress(MemoryAddress address) {
221             return SharedUtils.newVaListOfAddress(address);
222         }
223 
224         /**
225          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
226          *
227          * If this method needs to allocate native memory for the va list, it will use
228          * {@link MemorySegment#allocateNative(long, long)} to do so.
229          *
230          * This method will allocate native memory to hold the elements in the va list. This memory
231          * will be &#39;attached&#39; to the returned va list instance, and will be released when {@link VaList#close()}
232          * is called.
233          *
234          * Note that when there are no elements added to the created va list,
235          * this method will return the same as {@linkplain #empty()}.
236          *
237          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
238          *                of the underlying C {@code va_list}.
239          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
240          */
241         static VaList make(Consumer&lt;VaList.Builder&gt; actions) {
242             return SharedUtils.newVaList(actions, MemorySegment::allocateNative);
243         }
244 
245         /**
246          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
247          *
248          * If this method needs to allocate native memory for the va list, it will use
249          * the given {@code NativeScope} to do so.
250          *
251          * This method will allocate native memory to hold the elements in the va list. This memory
252          * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.
253          *
254          * Note that when there are no elements added to the created va list,
255          * this method will return the same as {@linkplain #empty()}.
256          *
257          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
258          *                of the underlying C {@code va_list}.
259          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
260          */
261         static VaList make(Consumer&lt;VaList.Builder&gt; actions, NativeScope scope) {
262             return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
263         }
264 
265         /**
266          * Returns an empty C {@code va_list} constant.
267          *
268          * The returned {@code VaList} can not be closed.
269          *
270          * @return a {@code VaList} modelling an empty C {@code va_list}.
271          */
272         static VaList empty() {
273             return SharedUtils.emptyVaList();
274         }
275 
276         /**
277          * A builder interface used to construct a C {@code va_list}.
278          */
279         interface Builder {
280 
281             /**
282              * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.
283              *
284              * @param layout the native layout of the value.
285              * @param value the value, represented as an {@code int}.
286              * @return this builder.
287              */
288             Builder vargFromInt(MemoryLayout layout, int value);
289 
290             /**
291              * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.
292              *
293              * @param layout the native layout of the value.
294              * @param value the value, represented as a {@code long}.
295              * @return this builder.
296              */
297             Builder vargFromLong(MemoryLayout layout, long value);
298 
299             /**
300              * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.
301              *
302              * @param layout the native layout of the value.
303              * @param value the value, represented as a {@code double}.
304              * @return this builder.
305              */
306             Builder vargFromDouble(MemoryLayout layout, double value);
307 
308             /**
309              * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.
310              *
311              * @param layout the native layout of the value.
312              * @param value the value, represented as a {@code MemoryAddress}.
313              * @return this builder.
314              */
315             Builder vargFromAddress(MemoryLayout layout, MemoryAddress value);
316 
317             /**
318              * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.
319              *
320              * @param layout the native layout of the value.
321              * @param value the value, represented as a {@code MemorySegment}.
322              * @return this builder.
323              */
324             Builder vargFromSegment(MemoryLayout layout, MemorySegment value);
325         }
326     }
327 
328     /**
329      * The {@code _Bool} native type.
330      */
331     public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
332     /**
333      * The {@code char} native type.
334      */
335     public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
336     /**
337      * The {@code short} native type.
338      */
339     public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
340     /**
341      * The {@code int} native type.
342      */
343     public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
344     /**
345      * The {@code long} native type.
346      */
347     public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
348     /**
349      * The {@code long long} native type.
350      */
351     public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
352     /**
353      * The {@code float} native type.
354      */
355     public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
356     /**
357      * The {@code double} native type.
358      */
359     public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
360     /**
361      * The {@code long double} native type.
362      */
363     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
364     /**
365      * The {@code T*} native type.
366      */
367     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
368 
369     /**
370      * The {@code va_list} native type.
371      */
372     public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);
373 
374     /**
375      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
376      */
377     public static final class SysV {
378         private SysV() {
379             //just the one
380         }
381 
382         /**
383          * The name of the SysV linker
384          * @see ForeignLinker#name
385          */
386         public static final String NAME = &quot;SysV&quot;;
387 
388         /**
389          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
390          * attribute value must be an enum constant from {@link ArgumentClass}.
391          */
392         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
393 
394         /**
395          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
396          */
397         public enum ArgumentClass {
398             /** Classification constant for integral values */
399             INTEGER,
400             /** Classification constant for floating point values */
401             SSE,
402             /** Classification constant for x87 floating point values */
403             X87,
404             /** Classification constant for {@code complex long double} values */
405             COMPLEX_87,
406             /** Classification constant for machine pointer values */
407             POINTER;
408         }
409 
410         /**
411          * The {@code _Bool} native type.
412          */
413         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
414                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
415 
416         /**
417          * The {@code char} native type.
418          */
419         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
420                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
421 
422         /**
423          * The {@code short} native type.
424          */
425         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
426                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
427 
428         /**
429          * The {@code int} native type.
430          */
431         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
432                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
433 
434         /**
435          * The {@code long} native type.
436          */
437         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
438                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
439 
440         /**
441          * The {@code long long} native type.
442          */
443         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
444                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
445 
446         /**
447          * The {@code float} native type.
448          */
449         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
450                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
451 
452         /**
453          * The {@code double} native type.
454          */
455         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
456                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
457 
458         /**
459          * The {@code long double} native type.
460          */
461         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
462                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
463 
464         /**
465          * The {@code complex long double} native type.
466          */
467         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
468                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
469 
470         /**
471          * The {@code T*} native type.
472          */
473         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
474                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
475 
476         /**
477          * The {@code va_list} native type, as it is passed to a function.
478          */
479         public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;
480     }
481 
482     /**
483      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
484      */
485     public static final class Win64 {
486 
487         private Win64() {
488             //just the one
489         }
490 
491         /**
492          * The name of the Windows linker
493          * @see ForeignLinker#name
494          */
495         public final static String NAME = &quot;Windows&quot;;
496 
497         /**
498          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The
499          * attribute value must be a boolean.
500          */
501         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
502 
503         /**
504          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
505          * attribute value must be an enum constant from {@link ArgumentClass}.
506          */
507         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
508 
509         /**
510          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
511          */
512         public enum ArgumentClass {
513             /** Classification constant for integral values */
514             INTEGER,
515             /** Classification constant for floating point values */
516             FLOAT,
517             /** Classification constant for machine pointer values */
518             POINTER;
519         }
520 
521         /**
522          * The {@code _Bool} native type.
523          */
524         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
525                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
526 
527         /**
528          * The {@code char} native type.
529          */
530         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
531                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
532 
533         /**
534          * The {@code short} native type.
535          */
536         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
537                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
538 
539         /**
540          * The {@code int} native type.
541          */
542         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
543                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
544 
545         /**
546          * The {@code long} native type.
547          */
548         public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
549                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
550 
551         /**
552          * The {@code long long} native type.
553          */
554         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
555                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
556 
557         /**
558          * The {@code float} native type.
559          */
560         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
561                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
562 
563         /**
564          * The {@code double} native type.
565          */
566         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
567                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
568 
569         /**
570          * The {@code long double} native type.
571          */
572         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
573                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
574 
575         /**
576          * The {@code T*} native type.
577          */
578         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
579                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
580 
581         /**
582          * The {@code va_list} native type, as it is passed to a function.
583          */
584         public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;
585 
586         /**
587          * Return a new memory layout which describes a variadic parameter to be passed to a function.
588          * @param layout the original parameter layout.
589          * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},
590          * which is set to {@code true}.
591          */
592         public static ValueLayout asVarArg(ValueLayout layout) {
593             return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);
594         }
595     }
596 
597     /**
598      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
599      */
600     public static final class AArch64 {
601 
602         private AArch64() {
603             //just the one
604         }
605 
606         /**
607          * The name of the AArch64 linker
608          * @see ForeignLinker#name
609          */
610         public final static String NAME = &quot;AArch64&quot;;
611 
612         /**
613          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
614          * attribute value must be an enum constant from {@link ArgumentClass}.
615          */
616         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
617 
618         /**
619          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
620          */
621         public enum ArgumentClass {
622             /** Classification constant for machine integral values */
623             INTEGER,
624             /** Classification constant for machine floating point values */
625             VECTOR,
626             /** Classification constant for machine pointer values */
627             POINTER;
628         }
629 
630         /**
631          * The {@code _Bool} native type.
632          */
633         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
634                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
635 
636         /**
637          * The {@code char} native type.
638          */
639         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
640                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
641 
642         /**
643          * The {@code short} native type.
644          */
645         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
646                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
647 
648         /**
649          * The {@code int} native type.
650          */
651         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
652                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
653 
654         /**
655          * The {@code long} native type.
656          */
657         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
658                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
659 
660         /**
661          * The {@code long long} native type.
662          */
663         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
664                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
665 
666         /**
667          * The {@code float} native type.
668          */
669         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
670                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
671 
672         /**
673          * The {@code double} native type.
674          */
675         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
676                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
677 
678         /**
679          * The {@code long double} native type.
680          */
681         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
682                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
683 
684         /**
685          * The {@code T*} native type.
686          */
687         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
688                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
689 
690         /**
691          * The {@code va_list} native type, as it is passed to a function.
692          */
693         public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;
694     }
695 
696     /**
697      * Convert a Java string into a null-terminated C string, using the
698      * platform&#39;s default charset, storing the result into a new native memory segment.
699      * &lt;p&gt;
700      * This method always replaces malformed-input and unmappable-character
701      * sequences with this charset&#39;s default replacement byte array.  The
702      * {@link java.nio.charset.CharsetEncoder} class should be used when more
703      * control over the encoding process is required.
704      *
705      * @param str the Java string to be converted into a C string.
706      * @return a new native memory segment containing the converted C string.
707      * @throws NullPointerException if either {@code str == null}.
708      */
709     public static MemorySegment toCString(String str) {
710         Objects.requireNonNull(str);
711         return toCString(str.getBytes());
712     }
713 
714     /**
715      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
716      * storing the result into a new native memory segment.
717      * &lt;p&gt;
718      * This method always replaces malformed-input and unmappable-character
719      * sequences with this charset&#39;s default replacement byte array.  The
720      * {@link java.nio.charset.CharsetEncoder} class should be used when more
721      * control over the encoding process is required.
722      *
723      * @param str the Java string to be converted into a C string.
724      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
725      * @return a new native memory segment containing the converted C string.
726      * @throws NullPointerException if either {@code str == null} or {@code charset == null}.
727      */
728     public static MemorySegment toCString(String str, Charset charset) {
729         Objects.requireNonNull(str);
730         Objects.requireNonNull(charset);
731         return toCString(str.getBytes(charset));
732     }
733 
734     /**
735      * Convert a Java string into a null-terminated C string, using the platform&#39;s default charset,
736      * storing the result into a native memory segment allocated using the provided scope.
737      * &lt;p&gt;
738      * This method always replaces malformed-input and unmappable-character
739      * sequences with this charset&#39;s default replacement byte array.  The
740      * {@link java.nio.charset.CharsetEncoder} class should be used when more
741      * control over the encoding process is required.
742      *
743      * @param str the Java string to be converted into a C string.
744      * @param scope the scope to be used for the native segment allocation.
745      * @return a new native memory segment containing the converted C string.
746      * @throws NullPointerException if either {@code str == null} or {@code scope == null}.
747      */
748     public static MemoryAddress toCString(String str, NativeScope scope) {
749         Objects.requireNonNull(str);
750         Objects.requireNonNull(scope);
751         return toCString(str.getBytes(), scope);
752     }
753 
754     /**
755      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
756      * storing the result into a new native memory segment native memory segment allocated using the provided scope.
757      * &lt;p&gt;
758      * This method always replaces malformed-input and unmappable-character
759      * sequences with this charset&#39;s default replacement byte array.  The
760      * {@link java.nio.charset.CharsetEncoder} class should be used when more
761      * control over the encoding process is required.
762      *
763      * @param str the Java string to be converted into a C string.
764      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
765      * @param scope the scope to be used for the native segment allocation.
766      * @return a new native memory segment containing the converted C string.
767      * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.
768      */
769     public static MemoryAddress toCString(String str, Charset charset, NativeScope scope) {
770         Objects.requireNonNull(str);
771         Objects.requireNonNull(charset);
772         Objects.requireNonNull(scope);
773         return toCString(str.getBytes(charset), scope);
774     }
775 
776     /**
777      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
778      * &lt;p&gt;
779      * This method always replaces malformed-input and unmappable-character
780      * sequences with this charset&#39;s default replacement string.  The {@link
781      * java.nio.charset.CharsetDecoder} class should be used when more control
782      * over the decoding process is required.
783      * &lt;p&gt;
784      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
785      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
786      * restricted methods, and use safe and supported functionalities, where possible.
787      * @param addr the address at which the string is stored.
788      * @return a Java string with the contents of the null-terminated C string at given address.
789      * @throws NullPointerException if {@code addr == null}
790      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
791      */
792     public static String toJavaStringRestricted(MemoryAddress addr) {
793         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
794         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), Charset.defaultCharset());
795     }
796 
797     /**
798      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
799      * &lt;p&gt;
800      * This method always replaces malformed-input and unmappable-character
801      * sequences with this charset&#39;s default replacement string.  The {@link
802      * java.nio.charset.CharsetDecoder} class should be used when more control
803      * over the decoding process is required.
804      * &lt;p&gt;
805      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
806      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
807      * restricted methods, and use safe and supported functionalities, where possible.
808      * @param addr the address at which the string is stored.
809      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
810      * @return a Java string with the contents of the null-terminated C string at given address.
811      * @throws NullPointerException if {@code addr == null}
812      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
813      */
814     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
815         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
816         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), charset);
817     }
818 
819     /**
820      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
821      * &lt;p&gt;
822      * This method always replaces malformed-input and unmappable-character
823      * sequences with this charset&#39;s default replacement string.  The {@link
824      * java.nio.charset.CharsetDecoder} class should be used when more control
825      * over the decoding process is required.
826      * @param addr the address at which the string is stored.
827      * @return a Java string with the contents of the null-terminated C string at given address.
828      * @throws NullPointerException if {@code addr == null}
829      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
830      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
831      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
832      */
833     public static String toJavaString(MemoryAddress addr) {
834         return SharedUtils.toJavaStringInternal(addr, Charset.defaultCharset());
835     }
836 
837     /**
838      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
839      * &lt;p&gt;
840      * This method always replaces malformed-input and unmappable-character
841      * sequences with this charset&#39;s default replacement string.  The {@link
842      * java.nio.charset.CharsetDecoder} class should be used when more control
843      * over the decoding process is required.
844      * @param addr the address at which the string is stored.
845      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
846      * @return a Java string with the contents of the null-terminated C string at given address.
847      * @throws NullPointerException if {@code addr == null}
848      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
849      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
850      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
851      */
852     public static String toJavaString(MemoryAddress addr, Charset charset) {
853         return SharedUtils.toJavaStringInternal(addr, charset);
854     }
855 
856     private static void copy(MemoryAddress addr, byte[] bytes) {
857         var heapSegment = MemorySegment.ofArray(bytes);
858         addr.segment().copyFrom(heapSegment);
859         MemoryAccess.setByte(addr, bytes.length, (byte)0);
860     }
861 
862     private static MemorySegment toCString(byte[] bytes) {
863         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
864         MemoryAddress addr = segment.baseAddress();
865         copy(addr, bytes);
866         return segment;
867     }
868 
869     private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
870         MemoryAddress addr = scope.allocate(bytes.length + 1, 1L);
871         copy(addr, bytes);
872         return addr;
873     }
874 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
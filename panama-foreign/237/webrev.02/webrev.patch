diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
@@ -27,11 +27,10 @@
 
 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.SharedUtils;
 
-import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 import java.nio.charset.Charset;
 import java.util.Objects;
 import java.util.function.Consumer;
 
@@ -55,10 +54,12 @@
     }
 
     /**
      * An interface that models a C {@code va_list}.
      *
+     * A va list is a stateful cursor used to iterate over a set of variadic arguments.
+     *
      * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),
      * arguments to variadic calls are erased by way of 'default argument promotions',
      * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),
      * and which erases all {@code float} arguments to {@code double}.
      *
@@ -66,95 +67,145 @@
      * and any other type that fits into a {@code long}.
      */
     public interface VaList extends AutoCloseable {
 
         /**
-         * Reads a value into an {@code int}
+         * Reads the next value into an {@code int} and advances this va list's position.
          *
          * @param layout the layout of the value
          * @return the value read as an {@code int}
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
          */
         int vargAsInt(MemoryLayout layout);
 
         /**
-         * Reads a value into a {@code long}
+         * Reads the next value into a {@code long} and advances this va list's position.
          *
          * @param layout the layout of the value
          * @return the value read as an {@code long}
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
          */
         long vargAsLong(MemoryLayout layout);
 
         /**
-         * Reads a value into a {@code double}
+         * Reads the next value into a {@code double} and advances this va list's position.
          *
          * @param layout the layout of the value
          * @return the value read as an {@code double}
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
          */
         double vargAsDouble(MemoryLayout layout);
 
         /**
-         * Reads a value into a {@code MemoryAddress}
+         * Reads the next value into a {@code MemoryAddress} and advances this va list's position.
          *
          * @param layout the layout of the value
          * @return the value read as an {@code MemoryAddress}
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
          */
         MemoryAddress vargAsAddress(MemoryLayout layout);
 
         /**
-         * Reads a value into a {@code MemorySegment}
+         * Reads the next value into a {@code MemorySegment}, and advances this va list's position.
+         *
+         * The memory segment returned by this method will be allocated using
+         * {@link MemorySegment#allocateNative(long, long)}, and will have to be closed separately.
          *
          * @param layout the layout of the value
          * @return the value read as an {@code MemorySegment}
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
          */
         MemorySegment vargAsSegment(MemoryLayout layout);
 
         /**
-         * Skips a number of va arguments with the given memory layouts.
+         * Reads the next value into a {@code MemorySegment}, and advances this va list's position.
+         *
+         * The memory segment returned by this method will be allocated using the given {@code NativeScope}.
+         *
+         * @param layout the layout of the value
+         * @param scope the scope to allocate the segment in
+         * @return the value read as an {@code MemorySegment}
+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
+         * (see {@link #close()}).
+         */
+        MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);
+
+        /**
+         * Skips a number of elements with the given memory layouts, and advances this va list's position.
          *
          * @param layouts the layout of the value
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
          */
         void skip(MemoryLayout... layouts);
 
         /**
          * A predicate used to check if the memory associated with the C {@code va_list} modelled
-         * by this instance is still valid; or, in other words, if {@code close()} has been called on this
-         * instance.
+         * by this instance is still valid to use.
          *
          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
          * @see #close()
          */
         boolean isAlive();
 
         /**
-         * Releases the underlying C {@code va_list} modelled by this instance. As a result, subsequent attempts to call
-         * operations on this instance (e.g. {@link #copy()} will fail with an exception.
+         * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached
+         * to this va list that holds its elements (see {@link VaList#make(Consumer)}).
+         *
+         * For some {@code VaList} instances, calling this method will have no effect. For instance: on Windows, a copy
+         * of a va list does not need any native memory, so nothing has to be released. After calling {@code close()} on
+         * such an instance {@link #isAlive()} will still return {@code true}.
          *
          * @see #isAlive()
          */
         void close();
 
         /**
-         * Copies this C {@code va_list}.
+         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements
+         * starting from the current position, without affecting the state of the original va list, essentially
+         * allowing the elements to be traversed multiple times.
+         *
+         * If this method needs to allocate native memory for the copy, it will use
+         * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the
+         * returned va list instance to release the allocated memory.
+         *
+         * This method only copies the va list cursor itself and not the memory that may be attached to the
+         * va list which holds its elements. That means that if this va list was created with the
+         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
+         * elements, making the copy unusable.
          *
          * @return a copy of this C {@code va_list}.
          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
          * (see {@link #close()}).
          */
         VaList copy();
 
+        /**
+         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements
+         * starting from the current position, without affecting the state of the original va list, essentially
+         * allowing the elements to be traversed multiple times.
+         *
+         * If this method needs to allocate native memory for the copy, it will use
+         * the given {@code NativeScope} to do so.
+         *
+         * This method only copies the va list cursor itself and not the memory that may be attached to the
+         * va list which holds its elements. That means that if this va list was created with the
+         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
+         * elements, making the copy unusable.
+         *
+         * @param scope the scope to allocate the copy in
+         * @return a copy of this C {@code va_list}.
+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
+         * (see {@link #close()}).
+         */
+        VaList copy(NativeScope scope);
+
         /**
          * Returns the memory address of the C {@code va_list} associated with this instance.
          *
          * @return the memory address of the C {@code va_list} associated with this instance.
          */
@@ -171,19 +222,46 @@
         }
 
         /**
          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
          *
-         * Note that when there are no arguments added to the created va list,
+         * If this method needs to allocate native memory for the va list, it will use
+         * {@link MemorySegment#allocateNative(long, long)} to do so.
+         *
+         * This method will allocate native memory to hold the elements in the va list. This memory
+         * will be 'attached' to the returned va list instance, and will be released when {@link VaList#close()}
+         * is called.
+         *
+         * Note that when there are no elements added to the created va list,
          * this method will return the same as {@linkplain #empty()}.
          *
-         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the contents
+         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
          *                of the underlying C {@code va_list}.
          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
          */
         static VaList make(Consumer<VaList.Builder> actions) {
-            return SharedUtils.newVaList(actions);
+            return SharedUtils.newVaList(actions, MemorySegment::allocateNative);
+        }
+
+        /**
+         * Constructs a new {@code VaList} using a builder (see {@link Builder}).
+         *
+         * If this method needs to allocate native memory for the va list, it will use
+         * the given {@code NativeScope} to do so.
+         *
+         * This method will allocate native memory to hold the elements in the va list. This memory
+         * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.
+         *
+         * Note that when there are no elements added to the created va list,
+         * this method will return the same as {@linkplain #empty()}.
+         *
+         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
+         *                of the underlying C {@code va_list}.
+         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
+         */
+        static VaList make(Consumer<VaList.Builder> actions, NativeScope scope) {
+            return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
         }
 
         /**
          * Returns an empty C {@code va_list} constant.
          *
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -31,10 +31,11 @@
 import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
@@ -277,16 +278,16 @@
         }
         throw new IllegalArgumentException("String too large");
     }
 
 
-    public static VaList newVaList(Consumer<VaList.Builder> actions) {
+    public static VaList newVaList(Consumer<VaList.Builder> actions, Allocator allocator) {
         String name = CSupport.getSystemLinker().name();
         return switch(name) {
-            case Win64.NAME -> Windowsx64Linker.newVaList(actions);
-            case SysV.NAME -> SysVx64Linker.newVaList(actions);
-            case AArch64.NAME -> AArch64Linker.newVaList(actions);
+            case Win64.NAME -> Windowsx64Linker.newVaList(actions, allocator);
+            case SysV.NAME -> SysVx64Linker.newVaList(actions, allocator);
+            case AArch64.NAME -> AArch64Linker.newVaList(actions, allocator);
             default -> throw new IllegalStateException("Unknown linker name: " + name);
         };
     }
 
     public static VarHandle vhPrimitiveOrAddress(Class<?> carrier, MemoryLayout layout) {
@@ -354,10 +355,26 @@
         return cDesc.attribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME)
                 .map(Boolean.class::cast)
                 .orElse(false);
     }
 
+    public interface Allocator {
+        default MemorySegment allocate(MemoryLayout layout) {
+            return allocate(layout.byteSize(), layout.byteAlignment());
+        }
+
+        default MemorySegment allocate(long size) {
+            return allocate(size, 1);
+        }
+
+        MemorySegment allocate(long size, long align);
+
+        static Allocator ofScope(NativeScope scope) {
+            return (size, align) -> scope.allocate(size, align).segment();
+        }
+    }
+
     public static class SimpleVaArg {
         public final Class<?> carrier;
         public final MemoryLayout layout;
         public final Object value;
 
@@ -409,10 +426,15 @@
         @Override
         public MemorySegment vargAsSegment(MemoryLayout layout) {
             throw uoe();
         }
 
+        @Override
+        public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {
+            throw uoe();
+        }
+
         @Override
         public void skip(MemoryLayout... layouts) {
             throw uoe();
         }
 
@@ -429,10 +451,15 @@
         @Override
         public VaList copy() {
             return this;
         }
 
+        @Override
+        public VaList copy(NativeScope scope) {
+            throw uoe();
+        }
+
         @Override
         public MemoryAddress address() {
             return address;
         }
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
@@ -93,12 +93,12 @@
 
     static AArch64.ArgumentClass argumentClassFor(MemoryLayout layout) {
         return (AArch64.ArgumentClass)layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get();
     }
 
-    public static VaList newVaList(Consumer<VaList.Builder> actions) {
-        AArch64VaList.Builder builder = AArch64VaList.builder();
+    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {
+        AArch64VaList.Builder builder = AArch64VaList.builder(allocator);
         actions.accept(builder);
         return builder.build();
     }
 
     public static VaList newVaListOfAddress(MemoryAddress ma) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
@@ -29,10 +29,11 @@
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.misc.Unsafe;
 
@@ -104,27 +105,31 @@
     private static final Cleaner cleaner = Cleaner.create();
     private static final CSupport.VaList EMPTY
         = new SharedUtils.EmptyVaList(emptyListAddress());
 
     private final MemorySegment segment;
-    private final List<MemorySegment> slices = new ArrayList<>();
-    private final MemorySegment fpRegsArea;
     private final MemorySegment gpRegsArea;
+    private final MemorySegment fpRegsArea;
+    private final List<MemorySegment> attachedSegments;
 
-    AArch64VaList(MemorySegment segment) {
+    private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea,
+                          List<MemorySegment> attachedSegments) {
         this.segment = segment;
+        this.gpRegsArea = gpRegsArea;
+        this.fpRegsArea = fpRegsArea;
+        this.attachedSegments = attachedSegments;
+    }
 
-        gpRegsArea = MemorySegment.ofNativeRestricted(
-            grTop().addOffset(-MAX_GP_OFFSET), MAX_GP_OFFSET,
+    private static AArch64VaList readFromSegment(MemorySegment segment) {
+        MemorySegment gpRegsArea = MemorySegment.ofNativeRestricted(
+            grTop(segment).addOffset(-MAX_GP_OFFSET), MAX_GP_OFFSET,
             segment.ownerThread(), null, null);
 
-        fpRegsArea = MemorySegment.ofNativeRestricted(
-            vrTop().addOffset(-MAX_FP_OFFSET), MAX_FP_OFFSET,
+        MemorySegment fpRegsArea = MemorySegment.ofNativeRestricted(
+            vrTop(segment).addOffset(-MAX_FP_OFFSET), MAX_FP_OFFSET,
             segment.ownerThread(), null, null);
-
-        slices.add(gpRegsArea);
-        slices.add(fpRegsArea);
+        return new AArch64VaList(segment, gpRegsArea, fpRegsArea, List.of(gpRegsArea, fpRegsArea));
     }
 
     private static MemoryAddress emptyListAddress() {
         long ptr = U.allocateMemory(LAYOUT.byteSize());
         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
@@ -143,14 +148,22 @@
     public static CSupport.VaList empty() {
         return EMPTY;
     }
 
     private MemoryAddress grTop() {
+        return grTop(segment);
+    }
+
+    private static MemoryAddress grTop(MemorySegment segment) {
         return (MemoryAddress) VH_gr_top.get(segment.baseAddress());
     }
 
     private MemoryAddress vrTop() {
+        return vrTop(segment);
+    }
+
+    private static MemoryAddress vrTop(MemorySegment segment) {
         return (MemoryAddress) VH_vr_top.get(segment.baseAddress());
     }
 
     private int grOffs() {
         final int offs = (int) VH_gr_offs.get(segment.baseAddress());
@@ -231,22 +244,31 @@
     @Override
     public MemorySegment vargAsSegment(MemoryLayout layout) {
         return (MemorySegment) read(MemorySegment.class, layout);
     }
 
+    @Override
+    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {
+        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));
+    }
+
     private Object read(Class<?> carrier, MemoryLayout layout) {
+        return read(carrier, layout, MemorySegment::allocateNative);
+    }
+
+    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {
         checkCompatibleType(carrier, layout, AArch64Linker.ADDRESS_SIZE);
 
         TypeClass typeClass = TypeClass.classifyLayout(layout);
         if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {
             preAlignStack(layout);
             return switch (typeClass) {
                 case STRUCT_REGISTER, STRUCT_HFA, STRUCT_REFERENCE -> {
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
                              stackPtr(), layout.byteSize(),
                              segment.ownerThread(), null, null)) {
-                        MemorySegment seg = MemorySegment.allocateNative(layout);
+                        MemorySegment seg = allocator.allocate(layout);
                         seg.copyFrom(slice);
                         postAlignStack(layout);
                         yield seg;
                     }
                 }
@@ -263,11 +285,11 @@
             };
         } else {
             return switch (typeClass) {
                 case STRUCT_REGISTER -> {
                     // Struct is passed packed in integer registers.
-                    MemorySegment value = MemorySegment.allocateNative(layout);
+                    MemorySegment value = allocator.allocate(layout);
                     long offset = 0;
                     while (offset < layout.byteSize()) {
                         final long copy = Math.min(layout.byteSize() - offset, 8);
                         MemorySegment slice = value.asSlice(offset, copy);
                         slice.copyFrom(gpRegsArea.asSlice(currentGPOffset(), copy));
@@ -277,11 +299,11 @@
                     yield value;
                 }
                 case STRUCT_HFA -> {
                     // Struct is passed with each element in a separate floating
                     // point register.
-                    MemorySegment value = MemorySegment.allocateNative(layout);
+                    MemorySegment value = allocator.allocate(layout);
                     GroupLayout group = (GroupLayout)layout;
                     long offset = 0;
                     for (MemoryLayout elem : group.memberLayouts()) {
                         assert elem.byteSize() <= 8;
                         final long copy = elem.byteSize();
@@ -300,11 +322,11 @@
                         gpRegsArea.baseAddress().addOffset(currentGPOffset()));
                     consumeGPSlots(1);
 
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
                              ptr, layout.byteSize(), segment.ownerThread(), null, null)) {
-                        MemorySegment seg = MemorySegment.allocateNative(layout);
+                        MemorySegment seg = allocator.allocate(layout);
                         seg.copyFrom(slice);
                         yield seg;
                     }
                 }
                 case POINTER, INTEGER -> {
@@ -338,17 +360,16 @@
                 consumeGPSlots(numSlots(layout));
             }
         }
     }
 
-    static AArch64VaList.Builder builder() {
-        return new AArch64VaList.Builder();
+    static AArch64VaList.Builder builder(SharedUtils.Allocator allocator) {
+        return new AArch64VaList.Builder(allocator);
     }
 
     public static VaList ofAddress(MemoryAddress ma) {
-        return new AArch64VaList(
-            MemorySegment.ofNativeRestricted(
+        return readFromSegment(MemorySegment.ofNativeRestricted(
                 ma, LAYOUT.byteSize(), Thread.currentThread(), null, null));
     }
 
     @Override
     public boolean isAlive() {
@@ -356,18 +377,27 @@
     }
 
     @Override
     public void close() {
         segment.close();
-        slices.forEach(MemorySegment::close);
+        attachedSegments.forEach(MemorySegment::close);
     }
 
     @Override
     public VaList copy() {
-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT.byteSize());
+        return copy(MemorySegment::allocateNative);
+    }
+
+    @Override
+    public VaList copy(NativeScope scope) {
+        return copy(SharedUtils.Allocator.ofScope(scope));
+    }
+
+    private VaList copy(SharedUtils.Allocator allocator) {
+        MemorySegment copy = allocator.allocate(LAYOUT);
         copy.copyFrom(segment);
-        return new AArch64VaList(copy);
+        return new AArch64VaList(copy, gpRegsArea, fpRegsArea, List.of());
     }
 
     @Override
     public MemoryAddress address() {
         return segment.baseAddress();
@@ -398,19 +428,24 @@
             + ", __vr_offs=" + vrOffs()
             + '}';
     }
 
     static class Builder implements CSupport.VaList.Builder {
-        private final MemorySegment gpRegs
-            = MemorySegment.allocateNative(LAYOUT_GP_REGS);
-        private final MemorySegment fpRegs
-            = MemorySegment.allocateNative(LAYOUT_FP_REGS);
+        private final SharedUtils.Allocator allocator;
+        private final MemorySegment gpRegs;
+        private final MemorySegment fpRegs;
 
         private long currentGPOffset = 0;
         private long currentFPOffset = 0;
         private final List<SimpleVaArg> stackArgs = new ArrayList<>();
 
+        Builder(SharedUtils.Allocator allocator) {
+            this.allocator = allocator;
+            this.gpRegs = allocator.allocate(LAYOUT_GP_REGS);
+            this.fpRegs = allocator.allocate(LAYOUT_FP_REGS);
+        }
+
         @Override
         public Builder vargFromInt(MemoryLayout layout, int value) {
             return arg(int.class, layout, value);
         }
 
@@ -501,40 +536,39 @@
         public VaList build() {
             if (isEmpty()) {
                 return EMPTY;
             }
 
-            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT.byteSize());
-            AArch64VaList res = new AArch64VaList(vaListSegment);
-
+            MemorySegment vaListSegment = allocator.allocate(LAYOUT);
+            List<MemorySegment> attachedSegments = new ArrayList<>();
             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
             if (!stackArgs.isEmpty()) {
                 long stackArgsSize = stackArgs.stream()
                     .reduce(0L, (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), 8), Long::sum);
-                MemorySegment stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16);
+                MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
                 MemoryAddress maStackArea = stackArgsSegment.baseAddress();
                 for (SimpleVaArg arg : stackArgs) {
                     final long alignedSize = Utils.alignUp(arg.layout.byteSize(), 8);
                     maStackArea = Utils.alignUp(maStackArea, alignedSize);
                     VarHandle writer = arg.varHandle();
                     writer.set(maStackArea, arg.value);
                     maStackArea = maStackArea.addOffset(alignedSize);
                 }
                 stackArgsPtr = stackArgsSegment.baseAddress();
-                res.slices.add(stackArgsSegment);
+                attachedSegments.add(stackArgsSegment);
             }
 
             MemoryAddress vaListAddr = vaListSegment.baseAddress();
             VH_gr_top.set(vaListAddr, gpRegs.baseAddress().addOffset(gpRegs.byteSize()));
             VH_vr_top.set(vaListAddr, fpRegs.baseAddress().addOffset(fpRegs.byteSize()));
             VH_stack.set(vaListAddr, stackArgsPtr);
             VH_gr_offs.set(vaListAddr, -MAX_GP_OFFSET);
             VH_vr_offs.set(vaListAddr, -MAX_FP_OFFSET);
 
-            res.slices.add(gpRegs);
-            res.slices.add(fpRegs);
+            attachedSegments.add(gpRegs);
+            attachedSegments.add(fpRegs);
             assert gpRegs.ownerThread() == vaListSegment.ownerThread();
             assert fpRegs.ownerThread() == vaListSegment.ownerThread();
-            return res;
+            return new AArch64VaList(vaListSegment, gpRegs, fpRegs, attachedSegments);
         }
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
@@ -29,10 +29,11 @@
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.misc.Unsafe;
 
@@ -118,17 +119,22 @@
 
     private static final Cleaner cleaner = Cleaner.create();
     private static final CSupport.VaList EMPTY = new SharedUtils.EmptyVaList(emptyListAddress());
 
     private final MemorySegment segment;
-    private final List<MemorySegment> slices = new ArrayList<>();
     private final MemorySegment regSaveArea;
+    private final List<MemorySegment> attachedSegments;
 
-    SysVVaList(MemorySegment segment) {
+    private SysVVaList(MemorySegment segment, MemorySegment regSaveArea, List<MemorySegment> attachedSegments) {
         this.segment = segment;
-        regSaveArea = regSaveArea();
-        slices.add(regSaveArea);
+        this.regSaveArea = regSaveArea;
+        this.attachedSegments = attachedSegments;
+    }
+
+    private static SysVVaList readFromSegment(MemorySegment segment) {
+        MemorySegment regSaveArea = getRegSaveArea(segment);
+        return new SysVVaList(segment, regSaveArea, List.of(regSaveArea));
     }
 
     private static MemoryAddress emptyListAddress() {
         long ptr = U.allocateMemory(LAYOUT.byteSize());
         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
@@ -169,10 +175,14 @@
     private void stackPtr(MemoryAddress ptr) {
         VH_overflow_arg_area.set(segment.baseAddress(), ptr);
     }
 
     private MemorySegment regSaveArea() {
+        return getRegSaveArea(segment);
+    }
+
+    private static MemorySegment getRegSaveArea(MemorySegment segment) {
         return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment.baseAddress()),
             LAYOUT_REG_SAVE_AREA.byteSize(), segment.ownerThread(), null, null);
     }
 
     private void preAlignStack(MemoryLayout layout) {
@@ -208,21 +218,30 @@
     @Override
     public MemorySegment vargAsSegment(MemoryLayout layout) {
         return (MemorySegment) read(MemorySegment.class, layout);
     }
 
+    @Override
+    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {
+        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));
+    }
+
     private Object read(Class<?> carrier, MemoryLayout layout) {
+        return read(carrier, layout, MemorySegment::allocateNative);
+    }
+
+    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {
         checkCompatibleType(carrier, layout, SysVx64Linker.ADDRESS_SIZE);
         TypeClass typeClass = TypeClass.classifyLayout(layout);
         if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)
                 || typeClass.inMemory()) {
             preAlignStack(layout);
             return switch (typeClass.kind()) {
                 case STRUCT -> {
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),
                                                                                 segment.ownerThread(), null, null)) {
-                        MemorySegment seg = MemorySegment.allocateNative(layout);
+                        MemorySegment seg = allocator.allocate(layout);
                         seg.copyFrom(slice);
                         postAlignStack(layout);
                         yield seg;
                     }
                 }
@@ -237,11 +256,11 @@
                 }
             };
         } else {
             return switch (typeClass.kind()) {
                 case STRUCT -> {
-                    MemorySegment value = MemorySegment.allocateNative(layout);
+                    MemorySegment value = allocator.allocate(layout);
                     int classIdx = 0;
                     long offset = 0;
                     while (offset < layout.byteSize()) {
                         final long copy = Math.min(layout.byteSize() - offset, 8);
                         boolean isSSE = typeClass.classes.get(classIdx++) == ArgumentClassImpl.SSE;
@@ -285,34 +304,45 @@
                 currentFPOffset(currentFPOffset() + (((int) typeClass.nVectorRegs()) * FP_SLOT_SIZE));
             }
         }
     }
 
-    static SysVVaList.Builder builder() {
-        return new SysVVaList.Builder();
+    static SysVVaList.Builder builder(SharedUtils.Allocator allocator) {
+        return new SysVVaList.Builder(allocator);
     }
 
     public static VaList ofAddress(MemoryAddress ma) {
-        return new SysVVaList(MemorySegment.ofNativeRestricted(ma, LAYOUT.byteSize(), Thread.currentThread(), null, null));
+        MemorySegment vaListSegment
+            = MemorySegment.ofNativeRestricted(ma, LAYOUT.byteSize(), Thread.currentThread(), null, null);
+        return readFromSegment(vaListSegment);
     }
 
     @Override
     public boolean isAlive() {
         return segment.isAlive();
     }
 
     @Override
     public void close() {
         segment.close();
-        slices.forEach(MemorySegment::close);
+        attachedSegments.forEach(MemorySegment::close);
     }
 
     @Override
     public VaList copy() {
-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT.byteSize());
+        return copy(MemorySegment::allocateNative);
+    }
+
+    @Override
+    public VaList copy(NativeScope scope) {
+        return copy(SharedUtils.Allocator.ofScope(scope));
+    }
+
+    private VaList copy(SharedUtils.Allocator allocator) {
+        MemorySegment copy = allocator.allocate(LAYOUT);
         copy.copyFrom(segment);
-        return new SysVVaList(copy);
+        return new SysVVaList(copy, regSaveArea, List.of());
     }
 
     @Override
     public MemoryAddress address() {
         return segment.baseAddress();
@@ -332,15 +362,21 @@
                + ", reg_save_area=" + regSaveArea()
                + '}';
     }
 
     static class Builder implements CSupport.VaList.Builder {
-        private final MemorySegment reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA);
+        private final SharedUtils.Allocator allocator;
+        private final MemorySegment reg_save_area;
         private long currentGPOffset = 0;
         private long currentFPOffset = FP_OFFSET;
         private final List<SimpleVaArg> stackArgs = new ArrayList<>();
 
+        public Builder(SharedUtils.Allocator allocator) {
+            this.allocator = allocator;
+            this.reg_save_area = allocator.allocate(LAYOUT_REG_SAVE_AREA);
+        }
+
         @Override
         public Builder vargFromInt(MemoryLayout layout, int value) {
             return arg(int.class, layout, value);
         }
 
@@ -413,16 +449,16 @@
         public VaList build() {
             if (isEmpty()) {
                 return EMPTY;
             }
 
-            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT.byteSize());
-            SysVVaList res = new SysVVaList(vaListSegment);
+            MemorySegment vaListSegment = allocator.allocate(LAYOUT);
+            List<MemorySegment> attachedSegments = new ArrayList<>();
             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
             if (!stackArgs.isEmpty()) {
                 long stackArgsSize = stackArgs.stream().reduce(0L, (acc, e) -> acc + e.layout.byteSize(), Long::sum);
-                MemorySegment stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16);
+                MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
                 MemoryAddress maOverflowArgArea = stackArgsSegment.baseAddress();
                 for (SimpleVaArg arg : stackArgs) {
                     if (arg.layout.byteSize() > 8) {
                         maOverflowArgArea = Utils.alignUp(maOverflowArgArea, Math.min(16, arg.layout.byteSize()));
                     }
@@ -435,18 +471,18 @@
                         writer.set(maOverflowArgArea, arg.value);
                     }
                     maOverflowArgArea = maOverflowArgArea.addOffset(arg.layout.byteSize());
                 }
                 stackArgsPtr = stackArgsSegment.baseAddress();
-                res.slices.add(stackArgsSegment);
+                attachedSegments.add(stackArgsSegment);
             }
 
             MemoryAddress vaListAddr = vaListSegment.baseAddress();
             VH_fp_offset.set(vaListAddr, (int) FP_OFFSET);
             VH_overflow_arg_area.set(vaListAddr, stackArgsPtr);
             VH_reg_save_area.set(vaListAddr, reg_save_area.baseAddress());
-            res.slices.add(reg_save_area);
+            attachedSegments.add(reg_save_area);
             assert reg_save_area.ownerThread() == vaListSegment.ownerThread();
-            return res;
+            return new SysVVaList(vaListSegment, reg_save_area, attachedSegments);
         }
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
@@ -75,12 +75,12 @@
             instance = new SysVx64Linker();
         }
         return instance;
     }
 
-    public static VaList newVaList(Consumer<VaList.Builder> actions) {
-        SysVVaList.Builder builder = SysVVaList.builder();
+    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {
+        SysVVaList.Builder builder = SysVVaList.builder(allocator);
         actions.accept(builder);
         return builder.build();
     }
 
     @Override
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
@@ -23,26 +23,24 @@
  *  questions.
  *
  */
 package jdk.internal.foreign.abi.x64.windows;
 
-import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.CSupport.VaList;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;
 
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
 
 import static jdk.incubator.foreign.CSupport.Win64.C_POINTER;
-import static jdk.incubator.foreign.MemorySegment.CLOSE;
-import static jdk.incubator.foreign.MemorySegment.READ;
 
 // see vadefs.h (VC header)
 //
 // in short
 // -> va_list is just a pointer to a buffer with 64 bit entries.
@@ -63,22 +61,16 @@
     private static final long VA_SLOT_SIZE_BYTES = 8;
     private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));
 
     private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemoryAddress.NULL);
 
-    private final MemorySegment segment;
     private MemoryAddress ptr;
-    private final List<MemorySegment> copies;
+    private final List<MemorySegment> attachedSegments;
 
-    WinVaList(MemorySegment segment) {
-        this(segment, new ArrayList<>());
-    }
-
-    WinVaList(MemorySegment segment, List<MemorySegment> copies) {
-        this.segment = segment;
-        this.ptr = segment.baseAddress();
-        this.copies = copies;
+    private WinVaList(MemoryAddress ptr, List<MemorySegment> attachedSegments) {
+        this.ptr = ptr;
+        this.attachedSegments = attachedSegments;
     }
 
     public static final VaList empty() {
         return EMPTY;
     }
@@ -106,28 +98,37 @@
     @Override
     public MemorySegment vargAsSegment(MemoryLayout layout) {
         return (MemorySegment) read(MemorySegment.class, layout);
     }
 
+    @Override
+    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {
+        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));
+    }
+
     private Object read(Class<?> carrier, MemoryLayout layout) {
+        return read(carrier, layout, MemorySegment::allocateNative);
+    }
+
+    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {
         SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);
         Object res;
         if (carrier == MemorySegment.class) {
             TypeClass typeClass = TypeClass.typeClassFor(layout);
             res = switch (typeClass) {
                 case STRUCT_REFERENCE -> {
                     MemoryAddress structAddr = (MemoryAddress) VH_address.get(ptr);
                     try (MemorySegment struct = MemorySegment.ofNativeRestricted(structAddr, layout.byteSize(),
-                                                                            segment.ownerThread(), null, null)) {
-                        MemorySegment seg = MemorySegment.allocateNative(layout.byteSize());
+                                                                            ptr.segment().ownerThread(), null, null)) {
+                        MemorySegment seg = allocator.allocate(layout);
                         seg.copyFrom(struct);
                         yield seg;
                     }
                 }
                 case STRUCT_REGISTER -> {
-                    MemorySegment struct = MemorySegment.allocateNative(layout);
-                    struct.copyFrom(segment.asSlice(ptr.segmentOffset(), layout.byteSize()));
+                    MemorySegment struct = allocator.allocate(layout);
+                    struct.copyFrom(ptr.segment().asSlice(ptr.segmentOffset(), layout.byteSize()));
                     yield struct;
                 }
                 default -> throw new IllegalStateException("Unexpected TypeClass: " + typeClass);
             };
         } else {
@@ -142,42 +143,52 @@
     public void skip(MemoryLayout... layouts) {
         ptr = ptr.addOffset(layouts.length * VA_SLOT_SIZE_BYTES);
     }
 
     static WinVaList ofAddress(MemoryAddress addr) {
-        return new WinVaList(MemorySegment.ofNativeRestricted(addr, Long.MAX_VALUE, Thread.currentThread(), null, null));
+        MemorySegment segment = MemorySegment.ofNativeRestricted(addr, Long.MAX_VALUE, Thread.currentThread(), null, null);
+        return new WinVaList(segment.baseAddress(), List.of(segment));
     }
 
-    static Builder builder() {
-        return new Builder();
+    static Builder builder(SharedUtils.Allocator allocator) {
+        return new Builder(allocator);
     }
 
     @Override
     public void close() {
-        segment.close();
-        copies.forEach(MemorySegment::close);
+        attachedSegments.forEach(MemorySegment::close);
     }
 
     @Override
     public VaList copy() {
-        return WinVaList.ofAddress(ptr);
+        return new WinVaList(ptr, List.of());
+    }
+
+    @Override
+    public VaList copy(NativeScope scope) {
+        return copy(); // no need to allocate when copying on Windows
     }
 
     @Override
     public MemoryAddress address() {
         return ptr;
     }
 
     @Override
     public boolean isAlive() {
-        return segment.isAlive();
+        return ptr.segment().isAlive();
     }
 
     static class Builder implements VaList.Builder {
 
+        private final SharedUtils.Allocator allocator;
         private final List<SimpleVaArg> args = new ArrayList<>();
 
+        public Builder(SharedUtils.Allocator allocator) {
+            this.allocator = allocator;
+        }
+
         private Builder arg(Class<?> carrier, MemoryLayout layout, Object value) {
             SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);
             args.add(new SimpleVaArg(carrier, layout, value));
             return this;
         }
@@ -209,23 +220,23 @@
 
         public VaList build() {
             if (args.isEmpty()) {
                 return EMPTY;
             }
-            MemorySegment ms = MemorySegment.allocateNative(VA_SLOT_SIZE_BYTES * args.size());
-            List<MemorySegment> copies = new ArrayList<>();
-
+            MemorySegment ms = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size());
+            List<MemorySegment> attachedSegments = new ArrayList<>();
+            attachedSegments.add(ms);
             MemoryAddress addr = ms.baseAddress();
             for (SimpleVaArg arg : args) {
                 if (arg.carrier == MemorySegment.class) {
                     MemorySegment msArg = ((MemorySegment) arg.value);
                     TypeClass typeClass = TypeClass.typeClassFor(arg.layout);
                     switch (typeClass) {
                         case STRUCT_REFERENCE -> {
-                            MemorySegment copy = MemorySegment.allocateNative(arg.layout);
+                            MemorySegment copy = allocator.allocate(arg.layout);
                             copy.copyFrom(msArg); // by-value
-                            copies.add(copy);
+                            attachedSegments.add(copy);
                             VH_address.set(addr, copy.baseAddress());
                         }
                         case STRUCT_REGISTER -> {
                             MemorySegment slice = ms.asSlice(addr.segmentOffset(), VA_SLOT_SIZE_BYTES);
                             slice.copyFrom(msArg);
@@ -237,9 +248,9 @@
                     writer.set(addr, arg.value);
                 }
                 addr = addr.addOffset(VA_SLOT_SIZE_BYTES);
             }
 
-            return new WinVaList(ms.withAccessModes(CLOSE | READ), copies);
+            return new WinVaList(ms.baseAddress(), attachedSegments);
         }
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
@@ -76,12 +76,12 @@
             instance = new Windowsx64Linker();
         }
         return instance;
     }
 
-    public static VaList newVaList(Consumer<VaList.Builder> actions) {
-        WinVaList.Builder builder = WinVaList.builder();
+    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {
+        WinVaList.Builder builder = WinVaList.builder(allocator);
         actions.accept(builder);
         return builder.build();
     }
 
     @Override
diff a/test/jdk/java/foreign/valist/VaListTest.java b/test/jdk/java/foreign/valist/VaListTest.java
--- a/test/jdk/java/foreign/valist/VaListTest.java
+++ b/test/jdk/java/foreign/valist/VaListTest.java
@@ -34,10 +34,11 @@
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
@@ -51,10 +52,12 @@
 import static jdk.incubator.foreign.CSupport.C_POINTER;
 import static jdk.incubator.foreign.CSupport.C_VA_LIST;
 import static jdk.incubator.foreign.CSupport.Win64.asVarArg;
 import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
 import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
 
 public class VaListTest {
 
     private static final ForeignLinker abi = CSupport.getSystemLinker();
     private static final LibraryLookup lookup = LibraryLookup.ofLibrary("VaList");
@@ -276,10 +279,81 @@
     public void testEmptyVaListFromBuilderNotCloseable() {
         VaList list = VaList.make(b -> {});
         list.close();
     }
 
+    @Test
+    public void testScopedVaList() throws Throwable {
+        VaList listLeaked;
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            VaList list = CSupport.VaList.make(b -> b.vargFromInt(C_INT, 4)
+                                                     .vargFromInt(C_INT, 8),
+                                               scope);
+            int x = (int) MH_sumInts.invokeExact(2, list);
+            assertEquals(x, 12);
+            listLeaked = list;
+        }
+        assertFalse(listLeaked.isAlive());
+    }
+
+    @Test
+    public void testScopeMSRead() {
+        MemorySegment pointOut;
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
+                VH_Point_x.set(pointIn.baseAddress(), 3);
+                VH_Point_y.set(pointIn.baseAddress(), 6);
+                try (VaList list = CSupport.VaList.make(b -> b.vargFromSegment(Point_LAYOUT, pointIn))) {
+                    pointOut = list.vargAsSegment(Point_LAYOUT, scope);
+                    assertEquals((int) VH_Point_x.get(pointOut.baseAddress()), 3);
+                    assertEquals((int) VH_Point_y.get(pointOut.baseAddress()), 6);
+                }
+                assertTrue(pointOut.isAlive()); // after VaList freed
+            }
+            assertTrue(pointOut.isAlive()); // after input MS freed
+        }
+        assertFalse(pointOut.isAlive()); // after scope freed
+    }
+
+    @Test
+    public void testScopedCopy() {
+        try (VaList list = VaList.make(b -> b.vargFromInt(C_INT, 4)
+                                             .vargFromInt(C_INT, 8))) {
+            try (NativeScope scope = NativeScope.unboundedScope()) {
+                VaList copy = list.copy(scope);
+
+                assertEquals(copy.vargAsInt(C_INT), 4);
+                assertEquals(copy.vargAsInt(C_INT), 8);
+            }
+            assertEquals(list.vargAsInt(C_INT), 4);
+            assertEquals(list.vargAsInt(C_INT), 8);
+        }
+    }
+
+    @Test(expectedExceptions = IllegalStateException.class)
+    public void testCopyUnusableAfterOriginalClosed() {
+        VaList list = VaList.make(b -> b.vargFromInt(C_INT, 4)
+                                        .vargFromInt(C_INT, 8));
+        try (VaList copy = list.copy()) {
+            list.close();
+
+            copy.vargAsInt(C_INT); // should throw
+        }
+    }
+
+    @Test(expectedExceptions = IllegalStateException.class)
+    public void testCopyUnusableAfterOriginalClosedScope() {
+        VaList list = VaList.make(b -> b.vargFromInt(C_INT, 4)
+                                        .vargFromInt(C_INT, 8));
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            VaList copy = list.copy(scope);
+            list.close();
+
+            copy.vargAsInt(C_INT); // should throw
+        }
+    }
+
     @DataProvider
     public static Object[][] upcalls() {
         return new Object[][]{
             { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {

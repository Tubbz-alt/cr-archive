diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
@@ -107,18 +107,18 @@
         = new SharedUtils.EmptyVaList(emptyListAddress());
 
     private final MemorySegment segment;
     private final MemorySegment gpRegsArea;
     private final MemorySegment fpRegsArea;
-    private final List<MemorySegment> slices;
+    private final List<MemorySegment> attachedSegments;
 
     private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea,
-                          List<MemorySegment>  slices) {
+                          List<MemorySegment> attachedSegments) {
         this.segment = segment;
         this.gpRegsArea = gpRegsArea;
         this.fpRegsArea = fpRegsArea;
-        this.slices = slices;
+        this.attachedSegments = attachedSegments;
     }
 
     private static AArch64VaList readFromSegment(MemorySegment segment) {
         MemorySegment gpRegsArea = MemorySegment.ofNativeRestricted(
             grTop(segment).addOffset(-MAX_GP_OFFSET), MAX_GP_OFFSET,
@@ -377,11 +377,11 @@
     }
 
     @Override
     public void close() {
         segment.close();
-        slices.forEach(MemorySegment::close);
+        attachedSegments.forEach(MemorySegment::close);
     }
 
     @Override
     public VaList copy() {
         return copy(MemorySegment::allocateNative);
@@ -393,11 +393,11 @@
     }
 
     private VaList copy(SharedUtils.Allocator allocator) {
         MemorySegment copy = allocator.allocate(LAYOUT);
         copy.copyFrom(segment);
-        return readFromSegment(copy);
+        return new AArch64VaList(copy, gpRegsArea, fpRegsArea, List.of());
     }
 
     @Override
     public MemoryAddress address() {
         return segment.baseAddress();
@@ -537,11 +537,11 @@
             if (isEmpty()) {
                 return EMPTY;
             }
 
             MemorySegment vaListSegment = allocator.allocate(LAYOUT);
-            List<MemorySegment> slices = new ArrayList<>();
+            List<MemorySegment> attachedSegments = new ArrayList<>();
             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
             if (!stackArgs.isEmpty()) {
                 long stackArgsSize = stackArgs.stream()
                     .reduce(0L, (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), 8), Long::sum);
                 MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
@@ -552,23 +552,23 @@
                     VarHandle writer = arg.varHandle();
                     writer.set(maStackArea, arg.value);
                     maStackArea = maStackArea.addOffset(alignedSize);
                 }
                 stackArgsPtr = stackArgsSegment.baseAddress();
-                slices.add(stackArgsSegment);
+                attachedSegments.add(stackArgsSegment);
             }
 
             MemoryAddress vaListAddr = vaListSegment.baseAddress();
             VH_gr_top.set(vaListAddr, gpRegs.baseAddress().addOffset(gpRegs.byteSize()));
             VH_vr_top.set(vaListAddr, fpRegs.baseAddress().addOffset(fpRegs.byteSize()));
             VH_stack.set(vaListAddr, stackArgsPtr);
             VH_gr_offs.set(vaListAddr, -MAX_GP_OFFSET);
             VH_vr_offs.set(vaListAddr, -MAX_FP_OFFSET);
 
-            slices.add(gpRegs);
-            slices.add(fpRegs);
+            attachedSegments.add(gpRegs);
+            attachedSegments.add(fpRegs);
             assert gpRegs.ownerThread() == vaListSegment.ownerThread();
             assert fpRegs.ownerThread() == vaListSegment.ownerThread();
-            return new AArch64VaList(vaListSegment, gpRegs, fpRegs, slices);
+            return new AArch64VaList(vaListSegment, gpRegs, fpRegs, attachedSegments);
         }
     }
 }

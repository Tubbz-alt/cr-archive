<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../incubator/foreign/CSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../x64/sysv/SysVVaList.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 92     private static final int MAX_FP_OFFSET = (int) LAYOUT_FP_REGS.byteSize();
 93 
 94     private static final VarHandle VH_stack
 95         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__stack&quot;)));
 96     private static final VarHandle VH_gr_top
 97         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__gr_top&quot;)));
 98     private static final VarHandle VH_vr_top
 99         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__vr_top&quot;)));
100     private static final VarHandle VH_gr_offs
101         = LAYOUT.varHandle(int.class, groupElement(&quot;__gr_offs&quot;));
102     private static final VarHandle VH_vr_offs
103         = LAYOUT.varHandle(int.class, groupElement(&quot;__vr_offs&quot;));
104 
105     private static final Cleaner cleaner = Cleaner.create();
106     private static final CSupport.VaList EMPTY
107         = new SharedUtils.EmptyVaList(emptyListAddress());
108 
109     private final MemorySegment segment;
110     private final MemorySegment gpRegsArea;
111     private final MemorySegment fpRegsArea;
<span class="line-modified">112     private final List&lt;MemorySegment&gt; slices;</span>
113 
114     private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea,
<span class="line-modified">115                           List&lt;MemorySegment&gt;  slices) {</span>
116         this.segment = segment;
117         this.gpRegsArea = gpRegsArea;
118         this.fpRegsArea = fpRegsArea;
<span class="line-modified">119         this.slices = slices;</span>
120     }
121 
122     private static AArch64VaList readFromSegment(MemorySegment segment) {
123         MemorySegment gpRegsArea = MemorySegment.ofNativeRestricted(
124             grTop(segment).addOffset(-MAX_GP_OFFSET), MAX_GP_OFFSET,
125             segment.ownerThread(), null, null);
126 
127         MemorySegment fpRegsArea = MemorySegment.ofNativeRestricted(
128             vrTop(segment).addOffset(-MAX_FP_OFFSET), MAX_FP_OFFSET,
129             segment.ownerThread(), null, null);
130         return new AArch64VaList(segment, gpRegsArea, fpRegsArea, List.of(gpRegsArea, fpRegsArea));
131     }
132 
133     private static MemoryAddress emptyListAddress() {
134         long ptr = U.allocateMemory(LAYOUT.byteSize());
135         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
136                 MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null,
137                 () -&gt; U.freeMemory(ptr), null);
138         cleaner.register(AArch64VaList.class, ms::close);
139         MemoryAddress base = ms.baseAddress();
</pre>
<hr />
<pre>
362         }
363     }
364 
365     static AArch64VaList.Builder builder(SharedUtils.Allocator allocator) {
366         return new AArch64VaList.Builder(allocator);
367     }
368 
369     public static VaList ofAddress(MemoryAddress ma) {
370         return readFromSegment(MemorySegment.ofNativeRestricted(
371                 ma, LAYOUT.byteSize(), Thread.currentThread(), null, null));
372     }
373 
374     @Override
375     public boolean isAlive() {
376         return segment.isAlive();
377     }
378 
379     @Override
380     public void close() {
381         segment.close();
<span class="line-modified">382         slices.forEach(MemorySegment::close);</span>
383     }
384 
385     @Override
386     public VaList copy() {
387         return copy(MemorySegment::allocateNative);
388     }
389 
390     @Override
391     public VaList copy(NativeScope scope) {
392         return copy(SharedUtils.Allocator.ofScope(scope));
393     }
394 
395     private VaList copy(SharedUtils.Allocator allocator) {
396         MemorySegment copy = allocator.allocate(LAYOUT);
397         copy.copyFrom(segment);
<span class="line-modified">398         return readFromSegment(copy);</span>
399     }
400 
401     @Override
402     public MemoryAddress address() {
403         return segment.baseAddress();
404     }
405 
406     private static int numSlots(MemoryLayout layout) {
407         return (int) Utils.alignUp(layout.byteSize(), 8) / 8;
408     }
409 
410     private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset,
411                                          TypeClass typeClass, MemoryLayout layout) {
412         if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {
413             return currentFPOffset &gt; MAX_FP_OFFSET - numSlots(layout) * FP_SLOT_SIZE;
414         } else if (typeClass == TypeClass.STRUCT_REFERENCE) {
415             return currentGPOffset &gt; MAX_GP_OFFSET - GP_SLOT_SIZE;
416         } else {
417             return currentGPOffset &gt; MAX_GP_OFFSET - numSlots(layout) * GP_SLOT_SIZE;
418         }
</pre>
<hr />
<pre>
522                     case FLOAT -&gt; {
523                         VarHandle writer = layout.varHandle(carrier);
524                         writer.set(fpRegs.baseAddress().addOffset(currentFPOffset), value);
525                         currentFPOffset += FP_SLOT_SIZE;
526                     }
527                 }
528             }
529             return this;
530         }
531 
532         private boolean isEmpty() {
533             return currentGPOffset == 0 &amp;&amp; currentFPOffset == 0 &amp;&amp; stackArgs.isEmpty();
534         }
535 
536         public VaList build() {
537             if (isEmpty()) {
538                 return EMPTY;
539             }
540 
541             MemorySegment vaListSegment = allocator.allocate(LAYOUT);
<span class="line-modified">542             List&lt;MemorySegment&gt; slices = new ArrayList&lt;&gt;();</span>
543             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
544             if (!stackArgs.isEmpty()) {
545                 long stackArgsSize = stackArgs.stream()
546                     .reduce(0L, (acc, e) -&gt; acc + Utils.alignUp(e.layout.byteSize(), 8), Long::sum);
547                 MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
548                 MemoryAddress maStackArea = stackArgsSegment.baseAddress();
549                 for (SimpleVaArg arg : stackArgs) {
550                     final long alignedSize = Utils.alignUp(arg.layout.byteSize(), 8);
551                     maStackArea = Utils.alignUp(maStackArea, alignedSize);
552                     VarHandle writer = arg.varHandle();
553                     writer.set(maStackArea, arg.value);
554                     maStackArea = maStackArea.addOffset(alignedSize);
555                 }
556                 stackArgsPtr = stackArgsSegment.baseAddress();
<span class="line-modified">557                 slices.add(stackArgsSegment);</span>
558             }
559 
560             MemoryAddress vaListAddr = vaListSegment.baseAddress();
561             VH_gr_top.set(vaListAddr, gpRegs.baseAddress().addOffset(gpRegs.byteSize()));
562             VH_vr_top.set(vaListAddr, fpRegs.baseAddress().addOffset(fpRegs.byteSize()));
563             VH_stack.set(vaListAddr, stackArgsPtr);
564             VH_gr_offs.set(vaListAddr, -MAX_GP_OFFSET);
565             VH_vr_offs.set(vaListAddr, -MAX_FP_OFFSET);
566 
<span class="line-modified">567             slices.add(gpRegs);</span>
<span class="line-modified">568             slices.add(fpRegs);</span>
569             assert gpRegs.ownerThread() == vaListSegment.ownerThread();
570             assert fpRegs.ownerThread() == vaListSegment.ownerThread();
<span class="line-modified">571             return new AArch64VaList(vaListSegment, gpRegs, fpRegs, slices);</span>
572         }
573     }
574 }
</pre>
</td>
<td>
<hr />
<pre>
 92     private static final int MAX_FP_OFFSET = (int) LAYOUT_FP_REGS.byteSize();
 93 
 94     private static final VarHandle VH_stack
 95         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__stack&quot;)));
 96     private static final VarHandle VH_gr_top
 97         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__gr_top&quot;)));
 98     private static final VarHandle VH_vr_top
 99         = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(&quot;__vr_top&quot;)));
100     private static final VarHandle VH_gr_offs
101         = LAYOUT.varHandle(int.class, groupElement(&quot;__gr_offs&quot;));
102     private static final VarHandle VH_vr_offs
103         = LAYOUT.varHandle(int.class, groupElement(&quot;__vr_offs&quot;));
104 
105     private static final Cleaner cleaner = Cleaner.create();
106     private static final CSupport.VaList EMPTY
107         = new SharedUtils.EmptyVaList(emptyListAddress());
108 
109     private final MemorySegment segment;
110     private final MemorySegment gpRegsArea;
111     private final MemorySegment fpRegsArea;
<span class="line-modified">112     private final List&lt;MemorySegment&gt; attachedSegments;</span>
113 
114     private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea,
<span class="line-modified">115                           List&lt;MemorySegment&gt; attachedSegments) {</span>
116         this.segment = segment;
117         this.gpRegsArea = gpRegsArea;
118         this.fpRegsArea = fpRegsArea;
<span class="line-modified">119         this.attachedSegments = attachedSegments;</span>
120     }
121 
122     private static AArch64VaList readFromSegment(MemorySegment segment) {
123         MemorySegment gpRegsArea = MemorySegment.ofNativeRestricted(
124             grTop(segment).addOffset(-MAX_GP_OFFSET), MAX_GP_OFFSET,
125             segment.ownerThread(), null, null);
126 
127         MemorySegment fpRegsArea = MemorySegment.ofNativeRestricted(
128             vrTop(segment).addOffset(-MAX_FP_OFFSET), MAX_FP_OFFSET,
129             segment.ownerThread(), null, null);
130         return new AArch64VaList(segment, gpRegsArea, fpRegsArea, List.of(gpRegsArea, fpRegsArea));
131     }
132 
133     private static MemoryAddress emptyListAddress() {
134         long ptr = U.allocateMemory(LAYOUT.byteSize());
135         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
136                 MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null,
137                 () -&gt; U.freeMemory(ptr), null);
138         cleaner.register(AArch64VaList.class, ms::close);
139         MemoryAddress base = ms.baseAddress();
</pre>
<hr />
<pre>
362         }
363     }
364 
365     static AArch64VaList.Builder builder(SharedUtils.Allocator allocator) {
366         return new AArch64VaList.Builder(allocator);
367     }
368 
369     public static VaList ofAddress(MemoryAddress ma) {
370         return readFromSegment(MemorySegment.ofNativeRestricted(
371                 ma, LAYOUT.byteSize(), Thread.currentThread(), null, null));
372     }
373 
374     @Override
375     public boolean isAlive() {
376         return segment.isAlive();
377     }
378 
379     @Override
380     public void close() {
381         segment.close();
<span class="line-modified">382         attachedSegments.forEach(MemorySegment::close);</span>
383     }
384 
385     @Override
386     public VaList copy() {
387         return copy(MemorySegment::allocateNative);
388     }
389 
390     @Override
391     public VaList copy(NativeScope scope) {
392         return copy(SharedUtils.Allocator.ofScope(scope));
393     }
394 
395     private VaList copy(SharedUtils.Allocator allocator) {
396         MemorySegment copy = allocator.allocate(LAYOUT);
397         copy.copyFrom(segment);
<span class="line-modified">398         return new AArch64VaList(copy, gpRegsArea, fpRegsArea, List.of());</span>
399     }
400 
401     @Override
402     public MemoryAddress address() {
403         return segment.baseAddress();
404     }
405 
406     private static int numSlots(MemoryLayout layout) {
407         return (int) Utils.alignUp(layout.byteSize(), 8) / 8;
408     }
409 
410     private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset,
411                                          TypeClass typeClass, MemoryLayout layout) {
412         if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {
413             return currentFPOffset &gt; MAX_FP_OFFSET - numSlots(layout) * FP_SLOT_SIZE;
414         } else if (typeClass == TypeClass.STRUCT_REFERENCE) {
415             return currentGPOffset &gt; MAX_GP_OFFSET - GP_SLOT_SIZE;
416         } else {
417             return currentGPOffset &gt; MAX_GP_OFFSET - numSlots(layout) * GP_SLOT_SIZE;
418         }
</pre>
<hr />
<pre>
522                     case FLOAT -&gt; {
523                         VarHandle writer = layout.varHandle(carrier);
524                         writer.set(fpRegs.baseAddress().addOffset(currentFPOffset), value);
525                         currentFPOffset += FP_SLOT_SIZE;
526                     }
527                 }
528             }
529             return this;
530         }
531 
532         private boolean isEmpty() {
533             return currentGPOffset == 0 &amp;&amp; currentFPOffset == 0 &amp;&amp; stackArgs.isEmpty();
534         }
535 
536         public VaList build() {
537             if (isEmpty()) {
538                 return EMPTY;
539             }
540 
541             MemorySegment vaListSegment = allocator.allocate(LAYOUT);
<span class="line-modified">542             List&lt;MemorySegment&gt; attachedSegments = new ArrayList&lt;&gt;();</span>
543             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
544             if (!stackArgs.isEmpty()) {
545                 long stackArgsSize = stackArgs.stream()
546                     .reduce(0L, (acc, e) -&gt; acc + Utils.alignUp(e.layout.byteSize(), 8), Long::sum);
547                 MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
548                 MemoryAddress maStackArea = stackArgsSegment.baseAddress();
549                 for (SimpleVaArg arg : stackArgs) {
550                     final long alignedSize = Utils.alignUp(arg.layout.byteSize(), 8);
551                     maStackArea = Utils.alignUp(maStackArea, alignedSize);
552                     VarHandle writer = arg.varHandle();
553                     writer.set(maStackArea, arg.value);
554                     maStackArea = maStackArea.addOffset(alignedSize);
555                 }
556                 stackArgsPtr = stackArgsSegment.baseAddress();
<span class="line-modified">557                 attachedSegments.add(stackArgsSegment);</span>
558             }
559 
560             MemoryAddress vaListAddr = vaListSegment.baseAddress();
561             VH_gr_top.set(vaListAddr, gpRegs.baseAddress().addOffset(gpRegs.byteSize()));
562             VH_vr_top.set(vaListAddr, fpRegs.baseAddress().addOffset(fpRegs.byteSize()));
563             VH_stack.set(vaListAddr, stackArgsPtr);
564             VH_gr_offs.set(vaListAddr, -MAX_GP_OFFSET);
565             VH_vr_offs.set(vaListAddr, -MAX_FP_OFFSET);
566 
<span class="line-modified">567             attachedSegments.add(gpRegs);</span>
<span class="line-modified">568             attachedSegments.add(fpRegs);</span>
569             assert gpRegs.ownerThread() == vaListSegment.ownerThread();
570             assert fpRegs.ownerThread() == vaListSegment.ownerThread();
<span class="line-modified">571             return new AArch64VaList(vaListSegment, gpRegs, fpRegs, attachedSegments);</span>
572         }
573     }
574 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../incubator/foreign/CSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../x64/sysv/SysVVaList.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
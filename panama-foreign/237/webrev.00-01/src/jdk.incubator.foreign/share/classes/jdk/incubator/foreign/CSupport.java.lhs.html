<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 29 import jdk.internal.foreign.Utils;
 30 import jdk.internal.foreign.abi.SharedUtils;
 31 
 32 import java.nio.ByteOrder;
 33 import java.nio.charset.Charset;
 34 import java.util.Objects;
 35 import java.util.function.Consumer;
 36 
 37 /**
 38  * A set of utilities for working with libraries using the C language/ABI
 39  */
 40 public class CSupport {
 41     /**
 42      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 43      * &lt;p&gt;
 44      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 45      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 46      * restricted methods, and use safe and supported functionalities, where possible.
 47      * @return a linker for this system.
 48      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 49      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 50      */
 51     public static ForeignLinker getSystemLinker() {
 52         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 53         return SharedUtils.getSystemLinker();
 54     }
 55 
 56     /**
 57      * An interface that models a C {@code va_list}.
 58      *
<a name="1" id="anc1"></a>

 59      * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),
 60      * arguments to variadic calls are erased by way of &#39;default argument promotions&#39;,
 61      * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),
 62      * and which erases all {@code float} arguments to {@code double}.
 63      *
 64      * As such, this interface only supports reading {@code int}, {@code double},
 65      * and any other type that fits into a {@code long}.
 66      */
 67     public interface VaList extends AutoCloseable {
 68 
 69         /**
<a name="2" id="anc2"></a><span class="line-modified"> 70          * Reads a value into an {@code int}</span>
 71          *
 72          * @param layout the layout of the value
 73          * @return the value read as an {@code int}
 74          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 75          * (see {@link #close()}).
 76          */
 77         int vargAsInt(MemoryLayout layout);
 78 
 79         /**
<a name="3" id="anc3"></a><span class="line-modified"> 80          * Reads a value into a {@code long}</span>
 81          *
 82          * @param layout the layout of the value
 83          * @return the value read as an {@code long}
 84          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 85          * (see {@link #close()}).
 86          */
 87         long vargAsLong(MemoryLayout layout);
 88 
 89         /**
<a name="4" id="anc4"></a><span class="line-modified"> 90          * Reads a value into a {@code double}</span>
 91          *
 92          * @param layout the layout of the value
 93          * @return the value read as an {@code double}
 94          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 95          * (see {@link #close()}).
 96          */
 97         double vargAsDouble(MemoryLayout layout);
 98 
 99         /**
<a name="5" id="anc5"></a><span class="line-modified">100          * Reads a value into a {@code MemoryAddress}</span>
101          *
102          * @param layout the layout of the value
103          * @return the value read as an {@code MemoryAddress}
104          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
105          * (see {@link #close()}).
106          */
107         MemoryAddress vargAsAddress(MemoryLayout layout);
108 
109         /**
<a name="6" id="anc6"></a><span class="line-modified">110          * Reads a value into a {@code MemorySegment}</span>



111          *
112          * @param layout the layout of the value
113          * @return the value read as an {@code MemorySegment}
114          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
115          * (see {@link #close()}).
116          */
117         MemorySegment vargAsSegment(MemoryLayout layout);
118 
119         /**
<a name="7" id="anc7"></a><span class="line-modified">120          * Reads a value into a {@code MemorySegment}, using the given {@code NativeScope} to allocate said segment.</span>


121          *
122          * @param layout the layout of the value
123          * @param scope the scope to allocate the segment in
124          * @return the value read as an {@code MemorySegment}
125          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
126          * (see {@link #close()}).
127          */
128         MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);
129 
130         /**
<a name="8" id="anc8"></a><span class="line-modified">131          * Skips a number of va arguments with the given memory layouts.</span>
132          *
133          * @param layouts the layout of the value
134          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
135          * (see {@link #close()}).
136          */
137         void skip(MemoryLayout... layouts);
138 
139         /**
140          * A predicate used to check if the memory associated with the C {@code va_list} modelled
<a name="9" id="anc9"></a><span class="line-modified">141          * by this instance is still valid; or, in other words, if {@code close()} has been called on this</span>
<span class="line-removed">142          * instance.</span>
143          *
144          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
145          * @see #close()
146          */
147         boolean isAlive();
148 
149         /**
<a name="10" id="anc10"></a><span class="line-modified">150          * Releases the underlying C {@code va_list} modelled by this instance. As a result, subsequent attempts to call</span>
<span class="line-modified">151          * operations on this instance (e.g. {@link #copy()} will fail with an exception.</span>




152          *
153          * @see #isAlive()
154          */
155         void close();
156 
157         /**
<a name="11" id="anc11"></a><span class="line-modified">158          * Copies this C {@code va_list}.</span>






159          *
<a name="12" id="anc12"></a><span class="line-modified">160          * @apiNote that this method only copies the va list &#39;view&#39; and not any argument space it may manage.</span>
<span class="line-modified">161          * That means that if this va list was created with the {@link #make(Consumer)} method, closing</span>
<span class="line-modified">162          * this va list will also free the argument space, and make the copy unusable.</span>

163          *
164          * @return a copy of this C {@code va_list}.
165          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
166          * (see {@link #close()}).
167          */
168         VaList copy();
169 
170         /**
<a name="13" id="anc13"></a><span class="line-modified">171          * Copies this C {@code va_list}, using the given {@code NativeScope} to allocate the copy (if needed).</span>





172          *
<a name="14" id="anc14"></a><span class="line-modified">173          * @apiNote this method only copies the va list &#39;view&#39; and not any argument space it may manage.</span>
<span class="line-modified">174          * That means that if this va list was created with the {@link #make(Consumer)} method, closing</span>
<span class="line-modified">175          * this va list will also free the argument space, and make the copy unusable.</span>

176          *
177          * @param scope the scope to allocate the copy in
178          * @return a copy of this C {@code va_list}.
179          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
180          * (see {@link #close()}).
181          */
182         VaList copy(NativeScope scope);
183 
184         /**
185          * Returns the memory address of the C {@code va_list} associated with this instance.
186          *
187          * @return the memory address of the C {@code va_list} associated with this instance.
188          */
189         MemoryAddress address();
190 
191         /**
192          * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.
193          *
194          * @param address a memory address pointing to an existing C {@code va_list}.
195          * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.
196          */
197         static VaList ofAddress(MemoryAddress address) {
198             return SharedUtils.newVaListOfAddress(address);
199         }
200 
201         /**
202          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
203          *
<a name="15" id="anc15"></a><span class="line-modified">204          * Note that when there are no arguments added to the created va list,</span>
<span class="line-modified">205          * this method will return the same as {@linkplain #empty()}.</span>




206          *
<a name="16" id="anc16"></a><span class="line-modified">207          * Va lists created with this method also implicitly manage an off-heap &#39;argument space&#39; that holds</span>
<span class="line-modified">208          * the arguments in the va list. Closing the returned va list will also free the argument space.</span>
209          *
<a name="17" id="anc17"></a><span class="line-modified">210          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the contents</span>
211          *                of the underlying C {@code va_list}.
212          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
213          */
214         static VaList make(Consumer&lt;VaList.Builder&gt; actions) {
215             return SharedUtils.newVaList(actions, MemorySegment::allocateNative);
216         }
217 
218         /**
<a name="18" id="anc18"></a><span class="line-modified">219          * Constructs a new {@code VaList} using a builder (see {@link Builder}), and using the given</span>
<span class="line-modified">220          * {@code NativeScope} to do all needed allocations.</span>





221          *
<a name="19" id="anc19"></a><span class="line-modified">222          * Note that when there are no arguments added to the created va list,</span>
223          * this method will return the same as {@linkplain #empty()}.
224          *
<a name="20" id="anc20"></a><span class="line-modified">225          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the contents</span>
226          *                of the underlying C {@code va_list}.
227          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
228          */
229         static VaList make(Consumer&lt;VaList.Builder&gt; actions, NativeScope scope) {
230             return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
231         }
232 
233         /**
234          * Returns an empty C {@code va_list} constant.
235          *
236          * The returned {@code VaList} can not be closed.
237          *
238          * @return a {@code VaList} modelling an empty C {@code va_list}.
239          */
240         static VaList empty() {
241             return SharedUtils.emptyVaList();
242         }
243 
244         /**
245          * A builder interface used to construct a C {@code va_list}.
246          */
247         interface Builder {
248 
249             /**
250              * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.
251              *
252              * @param layout the native layout of the value.
253              * @param value the value, represented as an {@code int}.
254              * @return this builder.
255              */
256             Builder vargFromInt(MemoryLayout layout, int value);
257 
258             /**
259              * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.
260              *
261              * @param layout the native layout of the value.
262              * @param value the value, represented as a {@code long}.
263              * @return this builder.
264              */
265             Builder vargFromLong(MemoryLayout layout, long value);
266 
267             /**
268              * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.
269              *
270              * @param layout the native layout of the value.
271              * @param value the value, represented as a {@code double}.
272              * @return this builder.
273              */
274             Builder vargFromDouble(MemoryLayout layout, double value);
275 
276             /**
277              * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.
278              *
279              * @param layout the native layout of the value.
280              * @param value the value, represented as a {@code MemoryAddress}.
281              * @return this builder.
282              */
283             Builder vargFromAddress(MemoryLayout layout, MemoryAddress value);
284 
285             /**
286              * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.
287              *
288              * @param layout the native layout of the value.
289              * @param value the value, represented as a {@code MemorySegment}.
290              * @return this builder.
291              */
292             Builder vargFromSegment(MemoryLayout layout, MemorySegment value);
293         }
294     }
295 
296     /**
297      * The {@code _Bool} native type.
298      */
299     public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
300     /**
301      * The {@code char} native type.
302      */
303     public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
304     /**
305      * The {@code short} native type.
306      */
307     public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
308     /**
309      * The {@code int} native type.
310      */
311     public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
312     /**
313      * The {@code long} native type.
314      */
315     public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
316     /**
317      * The {@code long long} native type.
318      */
319     public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
320     /**
321      * The {@code float} native type.
322      */
323     public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
324     /**
325      * The {@code double} native type.
326      */
327     public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
328     /**
329      * The {@code long double} native type.
330      */
331     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
332     /**
333      * The {@code T*} native type.
334      */
335     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
336 
337     /**
338      * The {@code va_list} native type.
339      */
340     public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);
341 
342     /**
343      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
344      */
345     public static final class SysV {
346         private SysV() {
347             //just the one
348         }
349 
350         /**
351          * The name of the SysV linker
352          * @see ForeignLinker#name
353          */
354         public static final String NAME = &quot;SysV&quot;;
355 
356         /**
357          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
358          * attribute value must be an enum constant from {@link ArgumentClass}.
359          */
360         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
361 
362         /**
363          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
364          */
365         public enum ArgumentClass {
366             /** Classification constant for integral values */
367             INTEGER,
368             /** Classification constant for floating point values */
369             SSE,
370             /** Classification constant for x87 floating point values */
371             X87,
372             /** Classification constant for {@code complex long double} values */
373             COMPLEX_87,
374             /** Classification constant for machine pointer values */
375             POINTER;
376         }
377 
378         /**
379          * The {@code _Bool} native type.
380          */
381         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
382                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
383 
384         /**
385          * The {@code char} native type.
386          */
387         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
388                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
389 
390         /**
391          * The {@code short} native type.
392          */
393         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
394                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
395 
396         /**
397          * The {@code int} native type.
398          */
399         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
400                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
401 
402         /**
403          * The {@code long} native type.
404          */
405         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
406                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
407 
408         /**
409          * The {@code long long} native type.
410          */
411         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
412                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
413 
414         /**
415          * The {@code float} native type.
416          */
417         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
418                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
419 
420         /**
421          * The {@code double} native type.
422          */
423         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
424                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
425 
426         /**
427          * The {@code long double} native type.
428          */
429         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
430                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
431 
432         /**
433          * The {@code complex long double} native type.
434          */
435         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
436                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
437 
438         /**
439          * The {@code T*} native type.
440          */
441         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
442                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
443 
444         /**
445          * The {@code va_list} native type, as it is passed to a function.
446          */
447         public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;
448     }
449 
450     /**
451      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
452      */
453     public static final class Win64 {
454 
455         private Win64() {
456             //just the one
457         }
458 
459         /**
460          * The name of the Windows linker
461          * @see ForeignLinker#name
462          */
463         public final static String NAME = &quot;Windows&quot;;
464 
465         /**
466          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The
467          * attribute value must be a boolean.
468          */
469         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
470 
471         /**
472          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
473          * attribute value must be an enum constant from {@link ArgumentClass}.
474          */
475         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
476 
477         /**
478          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
479          */
480         public enum ArgumentClass {
481             /** Classification constant for integral values */
482             INTEGER,
483             /** Classification constant for floating point values */
484             FLOAT,
485             /** Classification constant for machine pointer values */
486             POINTER;
487         }
488 
489         /**
490          * The {@code _Bool} native type.
491          */
492         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
493                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
494 
495         /**
496          * The {@code char} native type.
497          */
498         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
499                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
500 
501         /**
502          * The {@code short} native type.
503          */
504         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
505                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
506 
507         /**
508          * The {@code int} native type.
509          */
510         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
511                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
512 
513         /**
514          * The {@code long} native type.
515          */
516         public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
517                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
518 
519         /**
520          * The {@code long long} native type.
521          */
522         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
523                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
524 
525         /**
526          * The {@code float} native type.
527          */
528         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
529                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
530 
531         /**
532          * The {@code double} native type.
533          */
534         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
535                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
536 
537         /**
538          * The {@code long double} native type.
539          */
540         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
541                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
542 
543         /**
544          * The {@code T*} native type.
545          */
546         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
547                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
548 
549         /**
550          * The {@code va_list} native type, as it is passed to a function.
551          */
552         public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;
553 
554         /**
555          * Return a new memory layout which describes a variadic parameter to be passed to a function.
556          * @param layout the original parameter layout.
557          * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},
558          * which is set to {@code true}.
559          */
560         public static ValueLayout asVarArg(ValueLayout layout) {
561             return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);
562         }
563     }
564 
565     /**
566      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
567      */
568     public static final class AArch64 {
569 
570         private AArch64() {
571             //just the one
572         }
573 
574         /**
575          * The name of the AArch64 linker
576          * @see ForeignLinker#name
577          */
578         public final static String NAME = &quot;AArch64&quot;;
579 
580         /**
581          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
582          * attribute value must be an enum constant from {@link ArgumentClass}.
583          */
584         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
585 
586         /**
587          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
588          */
589         public enum ArgumentClass {
590             /** Classification constant for machine integral values */
591             INTEGER,
592             /** Classification constant for machine floating point values */
593             VECTOR,
594             /** Classification constant for machine pointer values */
595             POINTER;
596         }
597 
598         /**
599          * The {@code _Bool} native type.
600          */
601         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
602                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
603 
604         /**
605          * The {@code char} native type.
606          */
607         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
608                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
609 
610         /**
611          * The {@code short} native type.
612          */
613         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
614                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
615 
616         /**
617          * The {@code int} native type.
618          */
619         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
620                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
621 
622         /**
623          * The {@code long} native type.
624          */
625         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
626                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
627 
628         /**
629          * The {@code long long} native type.
630          */
631         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
632                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
633 
634         /**
635          * The {@code float} native type.
636          */
637         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
638                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
639 
640         /**
641          * The {@code double} native type.
642          */
643         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
644                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
645 
646         /**
647          * The {@code long double} native type.
648          */
649         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
650                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
651 
652         /**
653          * The {@code T*} native type.
654          */
655         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
656                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
657 
658         /**
659          * The {@code va_list} native type, as it is passed to a function.
660          */
661         public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;
662     }
663 
664     /**
665      * Convert a Java string into a null-terminated C string, using the
666      * platform&#39;s default charset, storing the result into a new native memory segment.
667      * &lt;p&gt;
668      * This method always replaces malformed-input and unmappable-character
669      * sequences with this charset&#39;s default replacement byte array.  The
670      * {@link java.nio.charset.CharsetEncoder} class should be used when more
671      * control over the encoding process is required.
672      *
673      * @param str the Java string to be converted into a C string.
674      * @return a new native memory segment containing the converted C string.
675      * @throws NullPointerException if either {@code str == null}.
676      */
677     public static MemorySegment toCString(String str) {
678         Objects.requireNonNull(str);
679         return toCString(str.getBytes());
680     }
681 
682     /**
683      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
684      * storing the result into a new native memory segment.
685      * &lt;p&gt;
686      * This method always replaces malformed-input and unmappable-character
687      * sequences with this charset&#39;s default replacement byte array.  The
688      * {@link java.nio.charset.CharsetEncoder} class should be used when more
689      * control over the encoding process is required.
690      *
691      * @param str the Java string to be converted into a C string.
692      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
693      * @return a new native memory segment containing the converted C string.
694      * @throws NullPointerException if either {@code str == null} or {@code charset == null}.
695      */
696     public static MemorySegment toCString(String str, Charset charset) {
697         Objects.requireNonNull(str);
698         Objects.requireNonNull(charset);
699         return toCString(str.getBytes(charset));
700     }
701 
702     /**
703      * Convert a Java string into a null-terminated C string, using the platform&#39;s default charset,
704      * storing the result into a native memory segment allocated using the provided scope.
705      * &lt;p&gt;
706      * This method always replaces malformed-input and unmappable-character
707      * sequences with this charset&#39;s default replacement byte array.  The
708      * {@link java.nio.charset.CharsetEncoder} class should be used when more
709      * control over the encoding process is required.
710      *
711      * @param str the Java string to be converted into a C string.
712      * @param scope the scope to be used for the native segment allocation.
713      * @return a new native memory segment containing the converted C string.
714      * @throws NullPointerException if either {@code str == null} or {@code scope == null}.
715      */
716     public static MemoryAddress toCString(String str, NativeScope scope) {
717         Objects.requireNonNull(str);
718         Objects.requireNonNull(scope);
719         return toCString(str.getBytes(), scope);
720     }
721 
722     /**
723      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
724      * storing the result into a new native memory segment native memory segment allocated using the provided scope.
725      * &lt;p&gt;
726      * This method always replaces malformed-input and unmappable-character
727      * sequences with this charset&#39;s default replacement byte array.  The
728      * {@link java.nio.charset.CharsetEncoder} class should be used when more
729      * control over the encoding process is required.
730      *
731      * @param str the Java string to be converted into a C string.
732      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
733      * @param scope the scope to be used for the native segment allocation.
734      * @return a new native memory segment containing the converted C string.
735      * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.
736      */
737     public static MemoryAddress toCString(String str, Charset charset, NativeScope scope) {
738         Objects.requireNonNull(str);
739         Objects.requireNonNull(charset);
740         Objects.requireNonNull(scope);
741         return toCString(str.getBytes(charset), scope);
742     }
743 
744     /**
745      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
746      * &lt;p&gt;
747      * This method always replaces malformed-input and unmappable-character
748      * sequences with this charset&#39;s default replacement string.  The {@link
749      * java.nio.charset.CharsetDecoder} class should be used when more control
750      * over the decoding process is required.
751      * &lt;p&gt;
752      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
753      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
754      * restricted methods, and use safe and supported functionalities, where possible.
755      * @param addr the address at which the string is stored.
756      * @return a Java string with the contents of the null-terminated C string at given address.
757      * @throws NullPointerException if {@code addr == null}
758      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
759      */
760     public static String toJavaStringRestricted(MemoryAddress addr) {
761         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
762         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), Charset.defaultCharset());
763     }
764 
765     /**
766      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
767      * &lt;p&gt;
768      * This method always replaces malformed-input and unmappable-character
769      * sequences with this charset&#39;s default replacement string.  The {@link
770      * java.nio.charset.CharsetDecoder} class should be used when more control
771      * over the decoding process is required.
772      * &lt;p&gt;
773      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
774      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
775      * restricted methods, and use safe and supported functionalities, where possible.
776      * @param addr the address at which the string is stored.
777      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
778      * @return a Java string with the contents of the null-terminated C string at given address.
779      * @throws NullPointerException if {@code addr == null}
780      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
781      */
782     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
783         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
784         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), charset);
785     }
786 
787     /**
788      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
789      * &lt;p&gt;
790      * This method always replaces malformed-input and unmappable-character
791      * sequences with this charset&#39;s default replacement string.  The {@link
792      * java.nio.charset.CharsetDecoder} class should be used when more control
793      * over the decoding process is required.
794      * @param addr the address at which the string is stored.
795      * @return a Java string with the contents of the null-terminated C string at given address.
796      * @throws NullPointerException if {@code addr == null}
797      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
798      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
799      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
800      */
801     public static String toJavaString(MemoryAddress addr) {
802         return SharedUtils.toJavaStringInternal(addr, Charset.defaultCharset());
803     }
804 
805     /**
806      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
807      * &lt;p&gt;
808      * This method always replaces malformed-input and unmappable-character
809      * sequences with this charset&#39;s default replacement string.  The {@link
810      * java.nio.charset.CharsetDecoder} class should be used when more control
811      * over the decoding process is required.
812      * @param addr the address at which the string is stored.
813      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
814      * @return a Java string with the contents of the null-terminated C string at given address.
815      * @throws NullPointerException if {@code addr == null}
816      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
817      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
818      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
819      */
820     public static String toJavaString(MemoryAddress addr, Charset charset) {
821         return SharedUtils.toJavaStringInternal(addr, charset);
822     }
823 
824     private static void copy(MemoryAddress addr, byte[] bytes) {
825         var heapSegment = MemorySegment.ofArray(bytes);
826         addr.segment().copyFrom(heapSegment);
827         MemoryAccess.setByte(addr, bytes.length, (byte)0);
828     }
829 
830     private static MemorySegment toCString(byte[] bytes) {
831         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
832         MemoryAddress addr = segment.baseAddress();
833         copy(addr, bytes);
834         return segment;
835     }
836 
837     private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
838         MemoryAddress addr = scope.allocate(bytes.length + 1, 1L);
839         copy(addr, bytes);
840         return addr;
841     }
842 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
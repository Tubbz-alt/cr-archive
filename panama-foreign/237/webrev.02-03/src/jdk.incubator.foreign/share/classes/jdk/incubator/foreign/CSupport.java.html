<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 29 import jdk.internal.foreign.Utils;
 30 import jdk.internal.foreign.abi.SharedUtils;
 31 
 32 import java.nio.ByteOrder;
 33 import java.nio.charset.Charset;
 34 import java.util.Objects;
 35 import java.util.function.Consumer;
 36 
 37 /**
 38  * A set of utilities for working with libraries using the C language/ABI
 39  */
 40 public class CSupport {
 41     /**
 42      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 43      * &lt;p&gt;
 44      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 45      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 46      * restricted methods, and use safe and supported functionalities, where possible.
 47      * @return a linker for this system.
 48      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 49      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 50      */
 51     public static ForeignLinker getSystemLinker() {
 52         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 53         return SharedUtils.getSystemLinker();
 54     }
 55 
 56     /**
 57      * An interface that models a C {@code va_list}.
 58      * &lt;p&gt;
 59      * A va list is a stateful cursor used to iterate over a set of variadic arguments.
 60      * &lt;p&gt;
 61      * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),
 62      * arguments to variadic calls are erased by way of &#39;default argument promotions&#39;,
 63      * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),
 64      * and which erases all {@code float} arguments to {@code double}.
 65      * &lt;p&gt;
 66      * As such, this interface only supports reading {@code int}, {@code double},
 67      * and any other type that fits into a {@code long}.
 68      */
 69     public interface VaList extends AutoCloseable {
 70 
 71         /**
 72          * Reads the next value as an {@code int} and advances this va list&#39;s position.
 73          *
 74          * @param layout the layout of the value
 75          * @return the value read as an {@code int}
 76          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 77          * (see {@link #close()}).
 78          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}
 79          */
 80         int vargAsInt(MemoryLayout layout);
 81 
 82         /**
 83          * Reads the next value as a {@code long} and advances this va list&#39;s position.
 84          *
 85          * @param layout the layout of the value
 86          * @return the value read as an {@code long}
 87          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 88          * (see {@link #close()}).
 89          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}
 90          */
 91         long vargAsLong(MemoryLayout layout);
 92 
 93         /**
 94          * Reads the next value as a {@code double} and advances this va list&#39;s position.
 95          *
 96          * @param layout the layout of the value
 97          * @return the value read as an {@code double}
 98          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 99          * (see {@link #close()}).
100          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}
101          */
102         double vargAsDouble(MemoryLayout layout);
103 
104         /**
105          * Reads the next value as a {@code MemoryAddress} and advances this va list&#39;s position.
106          *
107          * @param layout the layout of the value
108          * @return the value read as an {@code MemoryAddress}
109          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
110          * (see {@link #close()}).
111          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}
112          */
113         MemoryAddress vargAsAddress(MemoryLayout layout);
114 
115         /**
116          * Reads the next value as a {@code MemorySegment}, and advances this va list&#39;s position.
117          * &lt;p&gt;
118          * The memory segment returned by this method will be allocated using
119          * {@link MemorySegment#allocateNative(long, long)}, and will have to be closed separately.
120          *
121          * @param layout the layout of the value
122          * @return the value read as an {@code MemorySegment}
123          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
124          * (see {@link #close()}).
125          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
126          */
127         MemorySegment vargAsSegment(MemoryLayout layout);
128 
129         /**
130          * Reads the next value as a {@code MemorySegment}, and advances this va list&#39;s position.
131          * &lt;p&gt;
132          * The memory segment returned by this method will be allocated using the given {@code NativeScope}.
133          *
134          * @param layout the layout of the value
135          * @param scope the scope to allocate the segment in
136          * @return the value read as an {@code MemorySegment}
137          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
138          * (see {@link #close()}).
139          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
140          */
141         MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);
142 
143         /**
144          * Skips a number of elements with the given memory layouts, and advances this va list&#39;s position.
145          *
146          * @param layouts the layout of the value
147          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
148          * (see {@link #close()}).
149          */
150         void skip(MemoryLayout... layouts);
151 
152         /**
153          * A predicate used to check if the memory associated with the C {@code va_list} modelled
154          * by this instance is still valid to use.
155          *
156          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
157          * @see #close()
158          */
159         boolean isAlive();
160 
161         /**
162          * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached
163          * to this va list that holds its elements (see {@link VaList#make(Consumer)}).
164          * &lt;p&gt;
165          * For some {@code VaList} instances, calling this method will have no effect. For instance: on Windows, a copy
166          * of a va list does not need any native memory, so nothing has to be released. After calling {@code close()} on
167          * such an instance {@link #isAlive()} will still return {@code true}.
168          *
169          * @see #isAlive()
170          */
171         void close();
172 
173         /**
174          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
175          * starting from the current position, without affecting the state of the original va list, essentially
176          * allowing the elements to be traversed multiple times.
177          * &lt;p&gt;
178          * If this method needs to allocate native memory for the copy, it will use
179          * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the
180          * returned va list instance to release the allocated memory.
181          * &lt;p&gt;
182          * This method only copies the va list cursor itself and not the memory that may be attached to the
183          * va list which holds its elements. That means that if this va list was created with the
184          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
185          * elements, making the copy unusable.
186          *
187          * @return a copy of this C {@code va_list}.
188          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
189          * (see {@link #close()}).
190          */
191         VaList copy();
192 
193         /**
194          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
195          * starting from the current position, without affecting the state of the original va list, essentially
196          * allowing the elements to be traversed multiple times.
197          * &lt;p&gt;
198          * If this method needs to allocate native memory for the copy, it will use
199          * the given {@code NativeScope} to do so.
200          * &lt;p&gt;
201          * This method only copies the va list cursor itself and not the memory that may be attached to the
202          * va list which holds its elements. That means that if this va list was created with the
203          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
204          * elements, making the copy unusable.
205          *
206          * @param scope the scope to allocate the copy in
207          * @return a copy of this C {@code va_list}.
208          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
209          * (see {@link #close()}).
210          */
211         VaList copy(NativeScope scope);
212 
213         /**
214          * Returns the memory address of the C {@code va_list} associated with this instance.
215          *
216          * @return the memory address of the C {@code va_list} associated with this instance.
217          */
218         MemoryAddress address();
219 
220         /**
221          * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.
222          *
223          * @param address a memory address pointing to an existing C {@code va_list}.
224          * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.
225          */
226         static VaList ofAddress(MemoryAddress address) {
227             return SharedUtils.newVaListOfAddress(address);
228         }
229 
230         /**
231          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
232          * &lt;p&gt;
233          * If this method needs to allocate native memory for the va list, it will use
234          * {@link MemorySegment#allocateNative(long, long)} to do so.
235          * &lt;p&gt;
236          * This method will allocate native memory to hold the elements in the va list. This memory
237          * will be &#39;attached&#39; to the returned va list instance, and will be released when {@link VaList#close()}
238          * is called.
239          * &lt;p&gt;
240          * Note that when there are no elements added to the created va list,
241          * this method will return the same as {@linkplain #empty()}.
242          *
243          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
244          *                of the underlying C {@code va_list}.
245          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
246          */
247         static VaList make(Consumer&lt;VaList.Builder&gt; actions) {
248             return SharedUtils.newVaList(actions, MemorySegment::allocateNative);
249         }
250 
251         /**
252          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
253          * &lt;p&gt;
254          * If this method needs to allocate native memory for the va list, it will use
255          * the given {@code NativeScope} to do so.
256          * &lt;p&gt;
257          * This method will allocate native memory to hold the elements in the va list. This memory
258          * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.
259          * &lt;p&gt;
260          * Note that when there are no elements added to the created va list,
261          * this method will return the same as {@linkplain #empty()}.
262          *
263          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
264          *                of the underlying C {@code va_list}.
265          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
266          */
267         static VaList make(Consumer&lt;VaList.Builder&gt; actions, NativeScope scope) {
268             return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
269         }
270 
271         /**
272          * Returns an empty C {@code va_list} constant.
273          * &lt;p&gt;
274          * The returned {@code VaList} can not be closed.
275          *
276          * @return a {@code VaList} modelling an empty C {@code va_list}.
277          */
278         static VaList empty() {
279             return SharedUtils.emptyVaList();
280         }
281 
282         /**
283          * A builder interface used to construct a C {@code va_list}.
284          */
285         interface Builder {
286 
287             /**
288              * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.
289              *
290              * @param layout the native layout of the value.
291              * @param value the value, represented as an {@code int}.
292              * @return this builder.
293              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}
294              */
295             Builder vargFromInt(MemoryLayout layout, int value);
296 
297             /**
298              * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.
299              *
300              * @param layout the native layout of the value.
301              * @param value the value, represented as a {@code long}.
302              * @return this builder.
303              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}
304              */
305             Builder vargFromLong(MemoryLayout layout, long value);
306 
307             /**
308              * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.
309              *
310              * @param layout the native layout of the value.
311              * @param value the value, represented as a {@code double}.
312              * @return this builder.
313              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}
314              */
315             Builder vargFromDouble(MemoryLayout layout, double value);
316 
317             /**
318              * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.
319              *
320              * @param layout the native layout of the value.
321              * @param value the value, represented as a {@code MemoryAddress}.
322              * @return this builder.
323              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}
324              */
325             Builder vargFromAddress(MemoryLayout layout, MemoryAddress value);
326 
327             /**
328              * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.
329              *
330              * @param layout the native layout of the value.
331              * @param value the value, represented as a {@code MemorySegment}.
332              * @return this builder.
333              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
334              */
335             Builder vargFromSegment(MemoryLayout layout, MemorySegment value);
336         }
337     }
338 
339     /**
340      * The {@code _Bool} native type.
341      */
342     public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
343     /**
344      * The {@code char} native type.
345      */
346     public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
347     /**
348      * The {@code short} native type.
349      */
350     public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
351     /**
352      * The {@code int} native type.
353      */
354     public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
355     /**
356      * The {@code long} native type.
357      */
358     public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
359     /**
360      * The {@code long long} native type.
361      */
362     public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
363     /**
364      * The {@code float} native type.
365      */
366     public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
367     /**
368      * The {@code double} native type.
369      */
370     public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
371     /**
372      * The {@code long double} native type.
373      */
374     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
375     /**
376      * The {@code T*} native type.
377      */
378     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
379 
380     /**
381      * The {@code va_list} native type.
382      */
383     public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);
384 
385     /**
386      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
387      */
388     public static final class SysV {
389         private SysV() {
390             //just the one
391         }
392 
393         /**
394          * The name of the SysV linker
395          * @see ForeignLinker#name
396          */
397         public static final String NAME = &quot;SysV&quot;;
398 
399         /**
400          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
401          * attribute value must be an enum constant from {@link ArgumentClass}.
402          */
403         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
404 
405         /**
406          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
407          */
408         public enum ArgumentClass {
409             /** Classification constant for integral values */
410             INTEGER,
411             /** Classification constant for floating point values */
412             SSE,
413             /** Classification constant for x87 floating point values */
414             X87,
415             /** Classification constant for {@code complex long double} values */
416             COMPLEX_87,
417             /** Classification constant for machine pointer values */
418             POINTER;
419         }
420 
421         /**
422          * The {@code _Bool} native type.
423          */
424         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
425                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
426 
427         /**
428          * The {@code char} native type.
429          */
430         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
431                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
432 
433         /**
434          * The {@code short} native type.
435          */
436         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
437                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
438 
439         /**
440          * The {@code int} native type.
441          */
442         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
443                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
444 
445         /**
446          * The {@code long} native type.
447          */
448         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
449                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
450 
451         /**
452          * The {@code long long} native type.
453          */
454         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
455                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
456 
457         /**
458          * The {@code float} native type.
459          */
460         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
461                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
462 
463         /**
464          * The {@code double} native type.
465          */
466         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
467                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
468 
469         /**
470          * The {@code long double} native type.
471          */
472         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
473                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
474 
475         /**
476          * The {@code complex long double} native type.
477          */
478         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
479                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
480 
481         /**
482          * The {@code T*} native type.
483          */
484         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
485                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
486 
487         /**
488          * The {@code va_list} native type, as it is passed to a function.
489          */
490         public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;
491     }
492 
493     /**
494      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
495      */
496     public static final class Win64 {
497 
498         private Win64() {
499             //just the one
500         }
501 
502         /**
503          * The name of the Windows linker
504          * @see ForeignLinker#name
505          */
506         public final static String NAME = &quot;Windows&quot;;
507 
508         /**
509          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The
510          * attribute value must be a boolean.
511          */
512         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
513 
514         /**
515          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
516          * attribute value must be an enum constant from {@link ArgumentClass}.
517          */
518         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
519 
520         /**
521          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
522          */
523         public enum ArgumentClass {
524             /** Classification constant for integral values */
525             INTEGER,
526             /** Classification constant for floating point values */
527             FLOAT,
528             /** Classification constant for machine pointer values */
529             POINTER;
530         }
531 
532         /**
533          * The {@code _Bool} native type.
534          */
535         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
536                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
537 
538         /**
539          * The {@code char} native type.
540          */
541         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
542                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
543 
544         /**
545          * The {@code short} native type.
546          */
547         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
548                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
549 
550         /**
551          * The {@code int} native type.
552          */
553         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
554                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
555 
556         /**
557          * The {@code long} native type.
558          */
559         public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
560                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
561 
562         /**
563          * The {@code long long} native type.
564          */
565         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
566                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
567 
568         /**
569          * The {@code float} native type.
570          */
571         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
572                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
573 
574         /**
575          * The {@code double} native type.
576          */
577         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
578                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
579 
580         /**
581          * The {@code long double} native type.
582          */
583         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
584                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
585 
586         /**
587          * The {@code T*} native type.
588          */
589         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
590                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
591 
592         /**
593          * The {@code va_list} native type, as it is passed to a function.
594          */
595         public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;
596 
597         /**
598          * Return a new memory layout which describes a variadic parameter to be passed to a function.
599          * @param layout the original parameter layout.
600          * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},
601          * which is set to {@code true}.
602          */
603         public static ValueLayout asVarArg(ValueLayout layout) {
604             return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);
605         }
606     }
607 
608     /**
609      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
610      */
611     public static final class AArch64 {
612 
613         private AArch64() {
614             //just the one
615         }
616 
617         /**
618          * The name of the AArch64 linker
619          * @see ForeignLinker#name
620          */
621         public final static String NAME = &quot;AArch64&quot;;
622 
623         /**
624          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
625          * attribute value must be an enum constant from {@link ArgumentClass}.
626          */
627         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
628 
629         /**
630          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
631          */
632         public enum ArgumentClass {
633             /** Classification constant for machine integral values */
634             INTEGER,
635             /** Classification constant for machine floating point values */
636             VECTOR,
637             /** Classification constant for machine pointer values */
638             POINTER;
639         }
640 
641         /**
642          * The {@code _Bool} native type.
643          */
644         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
645                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
646 
647         /**
648          * The {@code char} native type.
649          */
650         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
651                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
652 
653         /**
654          * The {@code short} native type.
655          */
656         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
657                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
658 
659         /**
660          * The {@code int} native type.
661          */
662         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
663                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
664 
665         /**
666          * The {@code long} native type.
667          */
668         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
669                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
670 
671         /**
672          * The {@code long long} native type.
673          */
674         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
675                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
676 
677         /**
678          * The {@code float} native type.
679          */
680         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
681                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
682 
683         /**
684          * The {@code double} native type.
685          */
686         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
687                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
688 
689         /**
690          * The {@code long double} native type.
691          */
692         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
693                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
694 
695         /**
696          * The {@code T*} native type.
697          */
698         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
699                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
700 
701         /**
702          * The {@code va_list} native type, as it is passed to a function.
703          */
704         public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;
705     }
706 
707     /**
708      * Convert a Java string into a null-terminated C string, using the
709      * platform&#39;s default charset, storing the result into a new native memory segment.
710      * &lt;p&gt;
711      * This method always replaces malformed-input and unmappable-character
712      * sequences with this charset&#39;s default replacement byte array.  The
713      * {@link java.nio.charset.CharsetEncoder} class should be used when more
714      * control over the encoding process is required.
715      *
716      * @param str the Java string to be converted into a C string.
717      * @return a new native memory segment containing the converted C string.
718      * @throws NullPointerException if either {@code str == null}.
719      */
720     public static MemorySegment toCString(String str) {
721         Objects.requireNonNull(str);
722         return toCString(str.getBytes());
723     }
724 
725     /**
726      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
727      * storing the result into a new native memory segment.
728      * &lt;p&gt;
729      * This method always replaces malformed-input and unmappable-character
730      * sequences with this charset&#39;s default replacement byte array.  The
731      * {@link java.nio.charset.CharsetEncoder} class should be used when more
732      * control over the encoding process is required.
733      *
734      * @param str the Java string to be converted into a C string.
735      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
736      * @return a new native memory segment containing the converted C string.
737      * @throws NullPointerException if either {@code str == null} or {@code charset == null}.
738      */
739     public static MemorySegment toCString(String str, Charset charset) {
740         Objects.requireNonNull(str);
741         Objects.requireNonNull(charset);
742         return toCString(str.getBytes(charset));
743     }
744 
745     /**
746      * Convert a Java string into a null-terminated C string, using the platform&#39;s default charset,
747      * storing the result into a native memory segment allocated using the provided scope.
748      * &lt;p&gt;
749      * This method always replaces malformed-input and unmappable-character
750      * sequences with this charset&#39;s default replacement byte array.  The
751      * {@link java.nio.charset.CharsetEncoder} class should be used when more
752      * control over the encoding process is required.
753      *
754      * @param str the Java string to be converted into a C string.
755      * @param scope the scope to be used for the native segment allocation.
756      * @return a new native memory segment containing the converted C string.
757      * @throws NullPointerException if either {@code str == null} or {@code scope == null}.
758      */
759     public static MemoryAddress toCString(String str, NativeScope scope) {
760         Objects.requireNonNull(str);
761         Objects.requireNonNull(scope);
762         return toCString(str.getBytes(), scope);
763     }
764 
765     /**
766      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
767      * storing the result into a new native memory segment native memory segment allocated using the provided scope.
768      * &lt;p&gt;
769      * This method always replaces malformed-input and unmappable-character
770      * sequences with this charset&#39;s default replacement byte array.  The
771      * {@link java.nio.charset.CharsetEncoder} class should be used when more
772      * control over the encoding process is required.
773      *
774      * @param str the Java string to be converted into a C string.
775      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
776      * @param scope the scope to be used for the native segment allocation.
777      * @return a new native memory segment containing the converted C string.
778      * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.
779      */
780     public static MemoryAddress toCString(String str, Charset charset, NativeScope scope) {
781         Objects.requireNonNull(str);
782         Objects.requireNonNull(charset);
783         Objects.requireNonNull(scope);
784         return toCString(str.getBytes(charset), scope);
785     }
786 
787     /**
788      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
789      * &lt;p&gt;
790      * This method always replaces malformed-input and unmappable-character
791      * sequences with this charset&#39;s default replacement string.  The {@link
792      * java.nio.charset.CharsetDecoder} class should be used when more control
793      * over the decoding process is required.
794      * &lt;p&gt;
795      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
796      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
797      * restricted methods, and use safe and supported functionalities, where possible.
798      * @param addr the address at which the string is stored.
799      * @return a Java string with the contents of the null-terminated C string at given address.
800      * @throws NullPointerException if {@code addr == null}
801      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
802      */
803     public static String toJavaStringRestricted(MemoryAddress addr) {
804         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
805         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), Charset.defaultCharset());
806     }
807 
808     /**
809      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
810      * &lt;p&gt;
811      * This method always replaces malformed-input and unmappable-character
812      * sequences with this charset&#39;s default replacement string.  The {@link
813      * java.nio.charset.CharsetDecoder} class should be used when more control
814      * over the decoding process is required.
815      * &lt;p&gt;
816      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
817      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
818      * restricted methods, and use safe and supported functionalities, where possible.
819      * @param addr the address at which the string is stored.
820      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
821      * @return a Java string with the contents of the null-terminated C string at given address.
822      * @throws NullPointerException if {@code addr == null}
823      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
824      */
825     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
826         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
827         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), charset);
828     }
829 
830     /**
831      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
832      * &lt;p&gt;
833      * This method always replaces malformed-input and unmappable-character
834      * sequences with this charset&#39;s default replacement string.  The {@link
835      * java.nio.charset.CharsetDecoder} class should be used when more control
836      * over the decoding process is required.
837      * @param addr the address at which the string is stored.
838      * @return a Java string with the contents of the null-terminated C string at given address.
839      * @throws NullPointerException if {@code addr == null}
840      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
841      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
842      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
843      */
844     public static String toJavaString(MemoryAddress addr) {
845         return SharedUtils.toJavaStringInternal(addr, Charset.defaultCharset());
846     }
847 
848     /**
849      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
850      * &lt;p&gt;
851      * This method always replaces malformed-input and unmappable-character
852      * sequences with this charset&#39;s default replacement string.  The {@link
853      * java.nio.charset.CharsetDecoder} class should be used when more control
854      * over the decoding process is required.
855      * @param addr the address at which the string is stored.
856      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
857      * @return a Java string with the contents of the null-terminated C string at given address.
858      * @throws NullPointerException if {@code addr == null}
859      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
860      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
861      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
862      */
863     public static String toJavaString(MemoryAddress addr, Charset charset) {
864         return SharedUtils.toJavaStringInternal(addr, charset);
865     }
866 
867     private static void copy(MemoryAddress addr, byte[] bytes) {
868         var heapSegment = MemorySegment.ofArray(bytes);
869         addr.segment().copyFrom(heapSegment);
870         MemoryAccess.setByte(addr, bytes.length, (byte)0);
871     }
872 
873     private static MemorySegment toCString(byte[] bytes) {
874         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
875         MemoryAddress addr = segment.baseAddress();
876         copy(addr, bytes);
877         return segment;
878     }
879 
880     private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
881         MemoryAddress addr = scope.allocate(bytes.length + 1, 1L);
882         copy(addr, bytes);
883         return addr;
884     }
885 }
    </pre>
  </body>
</html>
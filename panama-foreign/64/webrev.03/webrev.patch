diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
@@ -38,61 +38,64 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalLong;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static java.lang.constant.ConstantDescs.BSM_INVOKE;
+import static java.lang.constant.ConstantDescs.CD_String;
+import static java.lang.constant.ConstantDescs.CD_long;
 
 abstract class AbstractLayout implements MemoryLayout {
+    // memory layout attribute key for layout name
+    static final String NAME = "name";
+
     private final OptionalLong size;
     final long alignment;
-    protected final Map<String, Constable> annotations;
+    protected final Map<String, Constable> attributes;
 
-    public AbstractLayout(OptionalLong size, long alignment, Map<String, Constable> annotations) {
+    public AbstractLayout(OptionalLong size, long alignment, Map<String, Constable> attributes) {
         this.size = size;
         this.alignment = alignment;
-        this.annotations = Collections.unmodifiableMap(annotations);
+        this.attributes = Collections.unmodifiableMap(attributes);
     }
 
-    Optional<String> optName() {
-        return Optional.ofNullable((String)annotations.get(NAME));
-    }
-
-    // memory layout annotation key for abi native type
-    static final String NATIVE_TYPE = "abi/native-type";
-
-    Optional<SystemABI.Type> optABIType() {
-        return Optional.ofNullable((SystemABI.Type)annotations.get(NATIVE_TYPE));
+    @Override
+    public AbstractLayout withName(String name) {
+        return withAttribute(NAME, name);
     }
 
     @Override
-    public AbstractLayout withName(String name) {
-        return withAnnotation(NAME, name);
+    public final Optional<String> name() {
+        return attribute(NAME).map(String.class::cast);
     }
 
-    @SuppressWarnings("unchecked")
-    public <Z extends AbstractLayout> Z withAnnotation(String name, Constable value) {
-        Map<String, Constable> new_annos = new HashMap<>(annotations);
-        new_annos.put(name, value);
-        return (Z)dup(alignment, new_annos);
+    @Override
+    public Optional<Constable> attribute(String name) {
+        return Optional.ofNullable(attributes.get(name));
     }
 
     @Override
-    public final Optional<String> name() {
-        return optName();
+    public Stream<String> attributes() {
+        return attributes.keySet().stream();
     }
 
     @Override
-    public final Optional<SystemABI.Type> abiType() {
-        return optABIType();
+    public AbstractLayout withAttribute(String name, Constable value) {
+        Map<String, Constable> newAttributes = new HashMap<>(attributes);
+        newAttributes.put(name, value);
+        return dup(alignment, newAttributes);
     }
 
     abstract AbstractLayout dup(long alignment, Map<String, Constable> annos);
 
     @Override
     public AbstractLayout withBitAlignment(long alignmentBits) {
         checkAlignment(alignmentBits);
-        return dup(alignmentBits, annotations);
+        return dup(alignmentBits, attributes);
     }
 
     void checkAlignment(long alignmentBitCount) {
         if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || //alignment must be a power of two
                 (alignmentBitCount < 8)) { //alignment must be greater than 8
@@ -132,26 +135,44 @@
     private static UnsupportedOperationException badSizeException() {
         return new UnsupportedOperationException("Cannot compute size of a layout which is, or depends on a sequence layout with unspecified size");
     }
 
     String decorateLayoutString(String s) {
-        if (optName().isPresent()) {
-            s = String.format("%s(%s)", s, optName().get());
+        if (name().isPresent()) {
+            s = String.format("%s(%s)", s, name().get());
         }
         if (!hasNaturalAlignment()) {
             s = alignment + "%" + s;
         }
+        if (!attributes.isEmpty()) {
+            s += attributes.entrySet().stream()
+                                      .map(e -> e.getKey() + "=" + e.getValue())
+                                      .collect(Collectors.joining(",", "[", "]"));
+        }
         return s;
     }
 
+    <T> DynamicConstantDesc<T> decorateLayoutConstant(DynamicConstantDesc<T> desc) {
+        if (!hasNaturalAlignment()) {
+            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, "withBitAlignment", desc.constantType(), MH_WITH_BIT_ALIGNMENT,
+                    desc, bitAlignment());
+        }
+        for (var e : attributes.entrySet()) {
+            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, "withAttribute", desc.constantType(), MH_WITH_ATTRIBUTE,
+                    desc, e.getKey(), e.getValue().describeConstable().orElseThrow());
+        }
+
+        return desc;
+    }
+
     boolean hasNaturalAlignment() {
         return size.isPresent() && size.getAsLong() == alignment;
     }
 
     @Override
     public int hashCode() {
-        return annotations.hashCode() << Long.hashCode(alignment);
+        return attributes.hashCode() << Long.hashCode(alignment);
     }
 
     @Override
     public boolean equals(Object other) {
         if (this == other) {
@@ -160,23 +181,21 @@
 
         if (!(other instanceof AbstractLayout)) {
             return false;
         }
 
-        return Objects.equals(annotations, ((AbstractLayout)other).annotations) &&
-                Objects.equals(alignment, ((AbstractLayout)other).alignment);
+        return Objects.equals(attributes, ((AbstractLayout) other).attributes) &&
+                Objects.equals(alignment, ((AbstractLayout) other).alignment);
     }
 
-    static final String NAME = "name";
-
     /*** Helper constants for implementing Layout::describeConstable ***/
 
     static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL
             = ConstantDescs.ofConstantBootstrap(ConstantDescs.CD_ConstantBootstraps, "getStaticFinal",
             ConstantDescs.CD_Object, ConstantDescs.CD_Class);
 
-    static final ClassDesc CD_LAYOUT = MemoryLayout.class.describeConstable().get();
+    static final ClassDesc CD_MEMORY_LAYOUT = MemoryLayout.class.describeConstable().get();
 
     static final ClassDesc CD_VALUE_LAYOUT = ValueLayout.class.describeConstable().get();
 
     static final ClassDesc CD_SEQUENCE_LAYOUT = SequenceLayout.class.describeConstable().get();
 
@@ -184,37 +203,45 @@
 
     static final ClassDesc CD_BYTEORDER = ByteOrder.class.describeConstable().get();
 
     static final ClassDesc CD_FUNCTION_DESC = FunctionDescriptor.class.describeConstable().get();
 
+    static final ClassDesc CD_Constable = Constable.class.describeConstable().get();
+
     static final ConstantDesc BIG_ENDIAN = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "BIG_ENDIAN", CD_BYTEORDER, CD_BYTEORDER);
 
     static final ConstantDesc LITTLE_ENDIAN = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "LITTLE_ENDIAN", CD_BYTEORDER, CD_BYTEORDER);
 
     static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "TRUE", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
 
     static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "FALSE", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
 
-    static final MethodHandleDesc MH_PADDING = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofPaddingBits",
-                MethodTypeDesc.of(CD_LAYOUT, ConstantDescs.CD_long));
+    static final MethodHandleDesc MH_PADDING = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofPaddingBits",
+                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_long));
+
+    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofValueBits",
+                MethodTypeDesc.of(CD_VALUE_LAYOUT, CD_long, CD_BYTEORDER));
+
+    static final MethodHandleDesc MH_SIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofSequence",
+                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, CD_long, CD_MEMORY_LAYOUT));
 
-    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofValueBits",
-                MethodTypeDesc.of(CD_VALUE_LAYOUT, ConstantDescs.CD_long, CD_BYTEORDER));
+    static final MethodHandleDesc MH_UNSIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofSequence",
+                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, CD_MEMORY_LAYOUT));
 
-    static final MethodHandleDesc MH_SIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofSequence",
-                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, ConstantDescs.CD_long, CD_LAYOUT));
+    static final MethodHandleDesc MH_STRUCT = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofStruct",
+                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));
 
-    static final MethodHandleDesc MH_UNSIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofSequence",
-                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, CD_LAYOUT));
+    static final MethodHandleDesc MH_UNION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofUnion",
+                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));
 
-    static final MethodHandleDesc MH_STRUCT = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofStruct",
-                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_LAYOUT.arrayType()));
+    static final MethodHandleDesc MH_VOID_FUNCTION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, CD_FUNCTION_DESC, "ofVoid",
+                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_MEMORY_LAYOUT.arrayType()));
 
-    static final MethodHandleDesc MH_UNION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofUnion",
-                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_LAYOUT.arrayType()));
+    static final MethodHandleDesc MH_FUNCTION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, CD_FUNCTION_DESC, "of",
+                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_MEMORY_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));
 
-    static final MethodHandleDesc MH_VOID_FUNCTION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_FUNCTION_DESC, "ofVoid",
-                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_LAYOUT.arrayType()));
+    static final MethodHandleDesc MH_WITH_BIT_ALIGNMENT = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, "withBitAlignment",
+                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_long));
 
-    static final MethodHandleDesc MH_FUNCTION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_FUNCTION_DESC, "of",
-                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_LAYOUT, CD_LAYOUT.arrayType()));
+    static final MethodHandleDesc MH_WITH_ATTRIBUTE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, "withAttribute",
+                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_String, CD_Constable));
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/GroupLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/GroupLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/GroupLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/GroupLayout.java
@@ -29,10 +29,11 @@
 import java.lang.constant.ConstantDesc;
 import java.lang.constant.ConstantDescs;
 import java.lang.constant.DynamicConstantDesc;
 import java.lang.constant.MethodHandleDesc;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalLong;
@@ -103,12 +104,12 @@
 
     GroupLayout(Kind kind, List<MemoryLayout> elements) {
         this(kind, elements, kind.alignof(elements), Map.of());
     }
 
-    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Map<String, Constable> annotations) {
-        super(kind.sizeof(elements), alignment, annotations);
+    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Map<String, Constable> attributes) {
+        super(kind.sizeof(elements), alignment, attributes);
         this.kind = kind;
         this.elements = elements;
     }
 
     /**
@@ -168,12 +169,12 @@
     public int hashCode() {
         return Objects.hash(super.hashCode(), kind, elements);
     }
 
     @Override
-    GroupLayout dup(long alignment, Map<String, Constable> annotations) {
-        return new GroupLayout(kind, elements, alignment, annotations);
+    GroupLayout dup(long alignment, Map<String, Constable> attributes) {
+        return new GroupLayout(kind, elements, alignment, attributes);
     }
 
     @Override
     boolean hasNaturalAlignment() {
         return alignment == kind.alignof(elements);
@@ -184,13 +185,13 @@
         ConstantDesc[] constants = new ConstantDesc[1 + elements.size()];
         constants[0] = kind.mhDesc;
         for (int i = 0 ; i < elements.size() ; i++) {
             constants[i + 1] = elements.get(i).describeConstable().get();
         }
-        return Optional.of(DynamicConstantDesc.ofNamed(
+        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(
                     ConstantDescs.BSM_INVOKE, kind.name().toLowerCase(),
-                CD_GROUP_LAYOUT, constants));
+                CD_GROUP_LAYOUT, constants)));
     }
 
     //hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout
     //but that causes issues with javadoc, see JDK-8224052
 
@@ -207,6 +208,14 @@
      */
     @Override
     public GroupLayout withBitAlignment(long alignmentBits) {
         return (GroupLayout)super.withBitAlignment(alignmentBits);
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public GroupLayout withAttribute(String name, Constable value) {
+        return (GroupLayout)super.withAttribute(name, value);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
@@ -39,10 +39,11 @@
 import java.util.Optional;
 import java.util.OptionalLong;
 import java.util.Set;
 import java.util.function.Function;
 import java.util.function.UnaryOperator;
+import java.util.stream.Stream;
 
 /**
  * A memory layout can be used to describe the contents of a memory segment in a <em>language neutral</em> fashion.
  * There are two leaves in the layout hierarchy, <em>value layouts</em>, which are used to represent values of given size and kind (see
  * {@link ValueLayout}) and <em>padding layouts</em> which are used, as the name suggests, to represent a portion of a memory
@@ -224,17 +225,10 @@
      * @return the layout <em>name</em> (if any).
      * @see MemoryLayout#withName(String)
      */
     Optional<String> name();
 
-    /**
-     * Return the ABI <em>type</em> (if any) associated with this layout.
-     *
-     * @return the layout ABI <em>type</em> (if any).
-     */
-    Optional<SystemABI.Type> abiType();
-
     /**
      * Creates a new layout which features the desired layout <em>name</em>.
      *
      * @param name the layout name.
      * @return a new layout which is the same as this layout, except for the <em>name</em> associated to it.
@@ -289,10 +283,34 @@
      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than than 8.
      */
     MemoryLayout withBitAlignment(long bitAlignment);
 
+    /**
+     * Returns the attribute with the given name if it exists, or an empty optional
+     *
+     * @param name the name of the attribute
+     * @return the optional attribute
+     */
+    Optional<Constable> attribute(String name);
+
+    /**
+     * Returns a new MemoryLayout with the given additional attribute
+     *
+     * @param name the name of the attribute
+     * @param value the value of the attribute
+     * @return the new MemoryLayout
+     */
+    MemoryLayout withAttribute(String name, Constable value);
+
+    /**
+     * Returns a stream of the names of the attributes of this layout
+     *
+     * @return the stream of names
+     */
+    Stream<String> attributes();
+
     /**
      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
      * layout.
      *
      * @apiNote if the layout path has one (or more) free dimensions,
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
@@ -286,215 +286,215 @@
 
         /**
          * The {@code _Bool} native type.
          */
         public static final ValueLayout C_BOOL = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.BOOL);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.BOOL);
 
 
         /**
          * The {@code unsigned char} native type.
          */
         public static final ValueLayout C_UCHAR = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
 
 
         /**
          * The {@code signed char} native type.
          */
         public static final ValueLayout C_SCHAR = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
 
 
         /**
          * The {@code char} native type.
          */
         public static final ValueLayout C_CHAR = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.CHAR);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.CHAR);
 
         /**
          * The {@code short} native type.
          */
         public static final ValueLayout C_SHORT = SharedLayouts.BITS_16_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SHORT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SHORT);
 
         /**
          * The {@code unsigned short} native type.
          */
         public static final ValueLayout C_USHORT = SharedLayouts.BITS_16_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
 
         /**
          * The {@code int} native type.
          */
         public static final ValueLayout C_INT = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.INT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.INT);
 
         /**
          * The {@code unsigned int} native type.
          */
         public static final ValueLayout C_UINT = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
 
         /**
          * The {@code long} native type.
          */
         public static final ValueLayout C_LONG = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG);
 
         /**
          * The {@code unsigned long} native type.
          */
         public static final ValueLayout C_ULONG = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
 
 
         /**
          * The {@code long long} native type.
          */
         public static final ValueLayout C_LONGLONG = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
 
         /**
          * The {@code unsigned long long} native type.
          */
         public static final ValueLayout C_ULONGLONG = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
 
         /**
          * The {@code float} native type.
          */
         public static final ValueLayout C_FLOAT = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.FLOAT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.FLOAT);
 
         /**
          * The {@code double} native type.
          */
         public static final ValueLayout C_DOUBLE = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.DOUBLE);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.DOUBLE);
 
         /**
          * The {@code long double} native type.
          */
         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG_DOUBLE);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_DOUBLE);
 
         /**
          * The {@code complex long double} native type.
          */
         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.COMPLEX_LONG_DOUBLE);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.COMPLEX_LONG_DOUBLE);
 
         /**
          * The {@code T*} native type.
          */
         public static final ValueLayout C_POINTER = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.POINTER);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.POINTER);
     }
 
     /**
      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
      */
     public static final class WinABI {
         /**
          * The {@code _Bool} native type.
          */
         public static final ValueLayout C_BOOL = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.BOOL);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.BOOL);
 
         /**
          * The {@code unsigned char} native type.
          */
         public static final ValueLayout C_UCHAR = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
 
         /**
          * The {@code signed char} native type.
          */
         public static final ValueLayout C_SCHAR = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
 
         /**
          * The {@code char} native type.
          */
         public static final ValueLayout C_CHAR = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.CHAR);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.CHAR);
 
         /**
          * The {@code short} native type.
          */
         public static final ValueLayout C_SHORT = SharedLayouts.BITS_16_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SHORT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SHORT);
 
         /**
          * The {@code unsigned short} native type.
          */
         public static final ValueLayout C_USHORT = SharedLayouts.BITS_16_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
 
         /**
          * The {@code int} native type.
          */
         public static final ValueLayout C_INT = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.INT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.INT);
 
         /**
          * The {@code unsigned int} native type.
          */
         public static final ValueLayout C_UINT = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
 
         /**
          * The {@code long} native type.
          */
         public static final ValueLayout C_LONG = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG);
 
         /**
          * The {@code unsigned long} native type.
          */
         public static final ValueLayout C_ULONG = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
 
         /**
          * The {@code long long} native type.
          */
         public static final ValueLayout C_LONGLONG = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
 
         /**
          * The {@code unsigned long long} native type.
          */
         public static final ValueLayout C_ULONGLONG = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
 
         /**
          * The {@code float} native type.
          */
         public static final ValueLayout C_FLOAT = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.FLOAT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.FLOAT);
 
         /**
          * The {@code double} native type.
          */
         public static final ValueLayout C_DOUBLE = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.DOUBLE);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.DOUBLE);
 
         /**
          * The {@code long double} native type.
          */
         public static final ValueLayout C_LONGDOUBLE = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG_DOUBLE);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_DOUBLE);
 
         /**
          * The {@code T*} native type.
          */
         public static final ValueLayout C_POINTER = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.POINTER);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.POINTER);
 
         public static ValueLayout asVarArg(ValueLayout l) {
-           return l.withAnnotation(Windowsx64ABI.VARARGS_ANNOTATION_NAME, "true");
+           return l.withAttribute(Windowsx64ABI.VARARGS_ATTRIBUTE_NAME, "true");
         }
     }
 
     /**
      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
@@ -502,101 +502,101 @@
     public static final class AArch64ABI {
         /**
          * The {@code _Bool} native type.
          */
         public static final ValueLayout C_BOOL = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.BOOL);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.BOOL);
 
         /**
          * The {@code unsigned char} native type.
          */
         public static final ValueLayout C_UCHAR = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
 
         /**
          * The {@code signed char} native type.
          */
         public static final ValueLayout C_SCHAR = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
 
         /**
          * The {@code char} native type.
          */
         public static final ValueLayout C_CHAR = SharedLayouts.BITS_8_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.CHAR);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.CHAR);
 
         /**
          * The {@code short} native type.
          */
         public static final ValueLayout C_SHORT = SharedLayouts.BITS_16_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SHORT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SHORT);
 
         /**
          * The {@code unsigned short} native type.
          */
         public static final ValueLayout C_USHORT = SharedLayouts.BITS_16_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
 
         /**
          * The {@code int} native type.
          */
         public static final ValueLayout C_INT = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.INT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.INT);
 
         /**
          * The {@code unsigned int} native type.
          */
         public static final ValueLayout C_UINT = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
 
         /**
          * The {@code long} native type.
          */
         public static final ValueLayout C_LONG = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG);
 
         /**
          * The {@code unsigned long} native type.
          */
         public static final ValueLayout C_ULONG = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
 
         /**
          * The {@code long long} native type.
          */
         public static final ValueLayout C_LONGLONG = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
 
         /**
          * The {@code unsigned long long} native type.
          */
         public static final ValueLayout C_ULONGLONG = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
 
         /**
          * The {@code float} native type.
          */
         public static final ValueLayout C_FLOAT = SharedLayouts.BITS_32_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.FLOAT);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.FLOAT);
 
         /**
          * The {@code double} native type.
          */
         public static final ValueLayout C_DOUBLE = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.DOUBLE);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.DOUBLE);
 
         /**
          * The {@code long double} native type.
          */
         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG_DOUBLE);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_DOUBLE);
 
         /**
          * The {@code T*} native type.
          */
         public static final ValueLayout C_POINTER = SharedLayouts.BITS_64_LE
-                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.POINTER);
+                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.POINTER);
     }
 
     private static class SharedLayouts { // Separate class to prevent circular clinit references
         public static final ValueLayout BITS_8_LE = MemoryLayout.ofValueBits(8, ByteOrder.LITTLE_ENDIAN);
         public static final ValueLayout BITS_16_LE = MemoryLayout.ofValueBits(16, ByteOrder.LITTLE_ENDIAN);
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/PaddingLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/PaddingLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/PaddingLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/PaddingLayout.java
@@ -50,12 +50,12 @@
 
     PaddingLayout(long size) {
         this(size, 1, Map.of());
     }
 
-    PaddingLayout(long size, long alignment, Map<String, Constable> annotations) {
-        super(OptionalLong.of(size), alignment, annotations);
+    PaddingLayout(long size, long alignment, Map<String, Constable> attributes) {
+        super(OptionalLong.of(size), alignment, attributes);
     }
 
     @Override
     public String toString() {
         return decorateLayoutString("x" + bitSize());
@@ -80,18 +80,23 @@
     public int hashCode() {
         return Objects.hash(super.hashCode(), bitSize());
     }
 
     @Override
-    PaddingLayout dup(long alignment, Map<String, Constable> annotations) {
-        return new PaddingLayout(bitSize(), alignment, annotations);
+    PaddingLayout dup(long alignment, Map<String, Constable> attributes) {
+        return new PaddingLayout(bitSize(), alignment, attributes);
+    }
+
+    @Override
+    public boolean hasNaturalAlignment() {
+        return true;
     }
 
     @Override
     public Optional<DynamicConstantDesc<MemoryLayout>> describeConstable() {
-        return Optional.of(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "padding",
-                CD_LAYOUT, MH_PADDING, bitSize()));
+        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "padding",
+                CD_MEMORY_LAYOUT, MH_PADDING, bitSize())));
     }
 
     //hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout
     //but that causes issues with javadoc, see JDK-8224052
 
@@ -108,6 +113,14 @@
      */
     @Override
     public PaddingLayout withBitAlignment(long alignmentBits) {
         return (PaddingLayout)super.withBitAlignment(alignmentBits);
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public PaddingLayout withAttribute(String name, Constable value) {
+        return (PaddingLayout)super.withAttribute(name, value);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java
@@ -69,14 +69,14 @@
 
     SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout) {
         this(elemCount, elementLayout, elementLayout.bitAlignment(), Map.of());
     }
 
-    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Map<String, Constable> annotations) {
+    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Map<String, Constable> attributes) {
         super(elemCount.isPresent() && AbstractLayout.optSize(elementLayout).isPresent() ?
                 OptionalLong.of(elemCount.getAsLong() * elementLayout.bitSize()) :
-                OptionalLong.empty(), alignment, annotations);
+                OptionalLong.empty(), alignment, attributes);
         this.elemCount = elemCount;
         this.elementLayout = elementLayout;
     }
 
     /**
@@ -104,11 +104,11 @@
      * @return a new sequence with given element count.
      * @throws IllegalArgumentException if {@code elementCount < 0}.
      */
     public SequenceLayout withElementCount(long elementCount) {
         AbstractLayout.checkSize(elementCount, true);
-        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, annotations);
+        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, attributes);
     }
 
     @Override
     public String toString() {
         return decorateLayoutString(String.format("[%s:%s]",
@@ -134,26 +134,26 @@
     public int hashCode() {
         return Objects.hash(super.hashCode(), elemCount, elementLayout);
     }
 
     @Override
-    SequenceLayout dup(long alignment, Map<String, Constable> annotations) {
-        return new SequenceLayout(elementCount(), elementLayout, alignment, annotations);
+    SequenceLayout dup(long alignment, Map<String, Constable> attributes) {
+        return new SequenceLayout(elementCount(), elementLayout, alignment, attributes);
     }
 
     @Override
     boolean hasNaturalAlignment() {
         return alignment == elementLayout.bitAlignment();
     }
 
     @Override
     public Optional<DynamicConstantDesc<SequenceLayout>> describeConstable() {
-        return elemCount.isPresent() ?
-                Optional.of(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
-                        CD_SEQUENCE_LAYOUT, MH_SIZED_SEQUENCE, elemCount.getAsLong(), elementLayout.describeConstable().get())) :
-                Optional.of(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
-                        CD_SEQUENCE_LAYOUT, MH_UNSIZED_SEQUENCE, elementLayout.describeConstable().get()));
+        return Optional.of(decorateLayoutConstant(elemCount.isPresent() ?
+                DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
+                        CD_SEQUENCE_LAYOUT, MH_SIZED_SEQUENCE, elemCount.getAsLong(), elementLayout.describeConstable().get()) :
+                DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
+                        CD_SEQUENCE_LAYOUT, MH_UNSIZED_SEQUENCE, elementLayout.describeConstable().get())));
     }
 
     //hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout
     //but that causes issues with javadoc, see JDK-8224052
 
@@ -170,6 +170,14 @@
      */
     @Override
     public SequenceLayout withBitAlignment(long alignmentBits) {
         return (SequenceLayout)super.withBitAlignment(alignmentBits);
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public SequenceLayout withAttribute(String name, Constable value) {
+        return (SequenceLayout)super.withAttribute(name, value);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
@@ -50,10 +50,15 @@
     /**
      * The name of the AArch64 ABI
      */
     String ABI_AARCH64 = "AArch64";
 
+    /**
+     * memory layout attribute key for abi native type
+     */
+    String NATIVE_TYPE = "abi/native-type";
+
     /**
      * Obtain a method handle which can be used to call a given native function.
      *
      * @param symbol downcall symbol.
      * @param type the method type.
@@ -172,11 +177,26 @@
         COMPLEX_LONG_DOUBLE,
 
         /**
          * The {@code T*} native type.
          */
-        POINTER
+        POINTER;
+
+        /**
+         * Retrieve the ABI type attached to the given layout,
+         * or throw an {@code IllegalArgumentException} if there is none
+         *
+         * @param ml the layout to retrieve the ABI type of
+         * @return the retrieved ABI type
+         * @throws IllegalArgumentException if the given layout does not have an ABI type attribute
+         */
+        public static Type fromLayout(MemoryLayout ml) throws IllegalArgumentException {
+            return ml.attribute(NATIVE_TYPE)
+                     .filter(SystemABI.Type.class::isInstance)
+                     .map(SystemABI.Type.class::cast)
+                     .orElseThrow(() -> new IllegalArgumentException("No ABI attribute present"));
+        }
     }
 
     /**
      * Returns memory layout for the given native type if supported by the platform ABI.
      * @param type the native type for which the layout is to be retrieved.
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ValueLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ValueLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ValueLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ValueLayout.java
@@ -54,12 +54,12 @@
 
     ValueLayout(ByteOrder order, long size) {
         this(order, size, size, Map.of());
     }
 
-    ValueLayout(ByteOrder order, long size, long alignment, Map<String, Constable> annotations) {
-        super(OptionalLong.of(size), alignment, annotations);
+    ValueLayout(ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {
+        super(OptionalLong.of(size), alignment, attributes);
         this.order = order;
     }
 
     /**
      * Returns the value's byte order.
@@ -75,11 +75,11 @@
      *
      * @param order the desired byte order.
      * @return a new value layout with given byte order.
      */
     public ValueLayout withOrder(ByteOrder order) {
-        return new ValueLayout(order, bitSize(), alignment, annotations);
+        return new ValueLayout(order, bitSize(), alignment, attributes);
     }
 
     @Override
     public String toString() {
         return decorateLayoutString(String.format("%s%d",
@@ -108,18 +108,18 @@
     public int hashCode() {
         return Objects.hash(super.hashCode(), order, bitSize(), alignment);
     }
 
     @Override
-    ValueLayout dup(long alignment, Map<String, Constable> annotations) {
-        return new ValueLayout(order, bitSize(), alignment, annotations);
+    ValueLayout dup(long alignment, Map<String, Constable> attributes) {
+        return new ValueLayout(order, bitSize(), alignment, attributes);
     }
 
     @Override
     public Optional<DynamicConstantDesc<ValueLayout>> describeConstable() {
-        return Optional.of(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
-                CD_VALUE_LAYOUT, MH_VALUE, bitSize(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN));
+        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
+                CD_VALUE_LAYOUT, MH_VALUE, bitSize(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN)));
     }
 
     //hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout
     //but that causes issues with javadoc, see JDK-8224052
 
@@ -136,6 +136,14 @@
      */
     @Override
     public ValueLayout withBitAlignment(long alignmentBits) {
         return (ValueLayout)super.withBitAlignment(alignmentBits);
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public ValueLayout withAttribute(String name, Constable value) {
+        return (ValueLayout)super.withAttribute(name, value);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -115,25 +115,10 @@
 
     public static boolean isPadding(MemoryLayout layout) {
         return layout.getClass() == PADDING_CLASS;
     }
 
-    @SuppressWarnings("unchecked")
-    public static Map<String, Constable> getAnnotations(MemoryLayout layout) {
-        try {
-            Field f = ValueLayout.class.getSuperclass().getDeclaredField("annotations");
-            f.setAccessible(true);
-            return (Map<String, Constable>) f.get(layout);
-        } catch (ReflectiveOperationException ex) {
-            throw new IllegalStateException(ex);
-        }
-    }
-
-    public static Constable getAnnotation(MemoryLayout layout, String name) {
-        return getAnnotations(layout).get(name);
-    }
-
     public static MemoryAddress resizeNativeAddress(MemoryAddress base, long byteSize) {
         return new MemoryAddressImpl((MemorySegmentImpl)Utils.makeNativeSegmentUnchecked(base, byteSize), 0);
     }
 
     public static void checkCarrier(Class<?> carrier) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
@@ -28,10 +28,11 @@
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
+import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.CallingSequenceBuilder;
 import jdk.internal.foreign.abi.UpcallHandler;
 import jdk.internal.foreign.abi.ABIDescriptor;
@@ -160,14 +161,11 @@
         INTEGER,
         FLOAT,
     }
 
     private static TypeClass classifyValueType(ValueLayout type) {
-        var optAbiType = type.abiType();
-        //padding not allowed here
-        ArgumentClassImpl clazz = optAbiType.map(AArch64ABI::argumentClassFor).
-            orElseThrow(()->new IllegalStateException("Unexpected value layout: could not determine ABI class"));
+        ArgumentClassImpl clazz = AArch64ABI.argumentClassFor(SystemABI.Type.fromLayout(type));
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
 
@@ -198,18 +196,16 @@
         MemoryLayout baseType = groupLayout.memberLayouts().get(0);
 
         if (!(baseType instanceof ValueLayout))
             return false;
 
-        var optAbiType = baseType.abiType();
-        ArgumentClassImpl baseArgClass = optAbiType.map(AArch64ABI::argumentClassFor).orElse(null);
+        ArgumentClassImpl baseArgClass = AArch64ABI.argumentClassFor(SystemABI.Type.fromLayout(baseType));
         if (baseArgClass != ArgumentClassImpl.VECTOR)
            return false;
 
         for (MemoryLayout elem : groupLayout.memberLayouts()) {
-            optAbiType = elem.abiType();
-            ArgumentClassImpl argClass = optAbiType.map(AArch64ABI::argumentClassFor).orElse(null);
+            ArgumentClassImpl argClass = AArch64ABI.argumentClassFor(SystemABI.Type.fromLayout(elem));
             if (!(elem instanceof ValueLayout) ||
                     elem.bitSize() != baseType.bitSize() ||
                     elem.bitAlignment() != baseType.bitAlignment() ||
                     baseArgClass != argClass) {
                 return false;
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -30,10 +30,11 @@
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
+import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.CallingSequenceBuilder;
 import jdk.internal.foreign.abi.UpcallHandler;
 import jdk.internal.foreign.abi.ABIDescriptor;
@@ -426,14 +427,11 @@
     }
 
 
     private static List<ArgumentClassImpl> classifyValueType(ValueLayout type) {
         ArrayList<ArgumentClassImpl> classes = new ArrayList<>();
-        var optAbiType = type.abiType();
-        //padding not allowed here
-        ArgumentClassImpl clazz = optAbiType.map(SysVx64ABI::argumentClassFor).
-            orElseThrow(()->new IllegalStateException("Unexpected value layout: could not determine ABI class"));
+        ArgumentClassImpl clazz = SysVx64ABI.argumentClassFor(SystemABI.Type.fromLayout(type));
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
         classes.add(clazz);
@@ -517,13 +515,16 @@
     }
 
     // TODO: handle zero length arrays
     // TODO: Handle nested structs (and primitives)
     private static List<ArgumentClassImpl> classifyStructType(GroupLayout type) {
-        var optAbiType = type.abiType();
-        var clazz = optAbiType.map(SysVx64ABI::argumentClassFor).orElse(null);
-        if (clazz == ArgumentClassImpl.COMPLEX_X87) {
+        if (type.attribute(SystemABI.NATIVE_TYPE)
+                .filter(SystemABI.Type.class::isInstance)
+                .map(SystemABI.Type.class::cast)
+                .map(SysVx64ABI::argumentClassFor)
+                .filter(ArgumentClassImpl.COMPLEX_X87::equals)
+                .isPresent()) {
             return COMPLEX_X87_CLASSES;
         }
 
         long nWords = Utils.alignUp((type.byteSize()), 8) / 8;
         if (nWords > MAX_AGGREGATE_REGS_SIZE) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
@@ -27,10 +27,11 @@
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
+import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.CallingSequenceBuilder;
 import jdk.internal.foreign.abi.UpcallHandler;
 import jdk.internal.foreign.abi.ABIDescriptor;
@@ -40,18 +41,19 @@
 import jdk.internal.foreign.abi.ProgrammableUpcallHandler;
 import jdk.internal.foreign.abi.VMStorage;
 import jdk.internal.foreign.abi.x64.X86_64Architecture;
 import jdk.internal.foreign.abi.x64.ArgumentClassImpl;
 import jdk.internal.foreign.abi.SharedUtils;
+import jdk.internal.foreign.abi.x64.sysv.SysVx64ABI;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
 import java.util.List;
 import java.util.Optional;
 
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
-import static jdk.internal.foreign.abi.x64.windows.Windowsx64ABI.VARARGS_ANNOTATION_NAME;
+import static jdk.internal.foreign.abi.x64.windows.Windowsx64ABI.VARARGS_ATTRIBUTE_NAME;
 
 /**
  * For the Windowx x64 C ABI specifically, this class uses the ProgrammableInvoker API, namely CallingSequenceBuilder2
  * to translate a C FunctionDescriptor into a CallingSequence2, which can then be turned into a MethodHandle.
  *
@@ -159,14 +161,11 @@
         FLOAT,
         VARARG_FLOAT
     }
 
     private static TypeClass classifyValueType(ValueLayout type) {
-        var optAbiType = type.abiType();
-        //padding not allowed here
-        ArgumentClassImpl clazz = optAbiType.map(Windowsx64ABI::argumentClassFor).
-            orElseThrow(()->new IllegalStateException("Unexpected value layout: could not determine ABI class"));
+        ArgumentClassImpl clazz = Windowsx64ABI.argumentClassFor(SystemABI.Type.fromLayout(type));
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
 
@@ -182,11 +181,14 @@
         if (clazz == ArgumentClassImpl.INTEGER) {
             return TypeClass.INTEGER;
         } else if(clazz == ArgumentClassImpl.POINTER) {
             return TypeClass.POINTER;
         } else if (clazz == ArgumentClassImpl.SSE) {
-            if (Boolean.parseBoolean((String) Utils.getAnnotation(type, VARARGS_ANNOTATION_NAME))) {
+            if (type.attribute(VARARGS_ATTRIBUTE_NAME)
+                    .filter(String.class::isInstance)
+                    .map(String.class::cast)
+                    .map(Boolean::parseBoolean).orElse(false)) {
                 return TypeClass.VARARG_FLOAT;
             }
             return TypeClass.FLOAT;
         }
         throw new IllegalArgumentException("Unknown ABI class: " + clazz);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
@@ -49,11 +49,11 @@
     public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 4;
     public static final int MAX_VECTOR_RETURN_REGISTERS = 1;
     public static final int MAX_REGISTER_ARGUMENTS = 4;
     public static final int MAX_REGISTER_RETURNS = 1;
 
-    public static final String VARARGS_ANNOTATION_NAME = "abi/windows/varargs";
+    public static final String VARARGS_ATTRIBUTE_NAME = "abi/windows/varargs";
 
     private static Windowsx64ABI instance;
 
     public static Windowsx64ABI getInstance() {
         if (instance == null) {
diff a/test/jdk/java/foreign/NativeTestHelper.java b/test/jdk/java/foreign/NativeTestHelper.java
--- a/test/jdk/java/foreign/NativeTestHelper.java
+++ b/test/jdk/java/foreign/NativeTestHelper.java
@@ -36,23 +36,19 @@
 public class NativeTestHelper {
 
     public static final SystemABI ABI = Foreign.getInstance().getSystemABI();
 
     public static boolean isIntegral(MemoryLayout layout) {
-        var optAbiType = layout.abiType();
-        if (!optAbiType.isPresent()) {
-            return false;
-        }
-        return switch(optAbiType.get()) {
+        return switch(SystemABI.Type.fromLayout(layout)) {
             case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
                 INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG -> true;
             default -> false;
         };
     }
 
     public static boolean isPointer(MemoryLayout layout) {
-        return layout.abiType().filter(Predicate.isEqual(Type.POINTER)).isPresent();
+        return SystemABI.Type.fromLayout(layout) == Type.POINTER;
     }
 
     public static ValueLayout asVarArg(ValueLayout layout) {
         return ABI.name().equals(ABI_WINDOWS) ? WinABI.asVarArg(layout) : layout;
     }
diff a/test/jdk/java/foreign/TestLayoutAttributes.java b/test/jdk/java/foreign/TestLayoutAttributes.java
--- /dev/null
+++ b/test/jdk/java/foreign/TestLayoutAttributes.java
@@ -0,0 +1,72 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ */
+
+/*
+ * @test
+ * @run testng TestLayoutAttributes
+ */
+
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
+import org.testng.annotations.Test;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+public class TestLayoutAttributes {
+
+    @Test
+    public void testAttribute() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withAttribute("MyAttribute", 10L);
+        assertEquals((long) ml.attribute("MyAttribute").orElseThrow(), 10L);
+    }
+
+    @Test
+    public void testAttributeNonExistent() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withAttribute("MyAttribute", 10L);
+        assertTrue(ml.attribute("Foo").isEmpty());
+    }
+
+    @Test
+    public void testNameAttribute() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withName("foo");
+        assertEquals(ml.name().orElseThrow(), "foo");
+        assertEquals(ml.attribute("name").orElseThrow(), "foo");
+    }
+
+    @Test
+    public void testAttributesStream() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withName("foo")
+                .withAttribute("MyAttribute", 10L);
+        List<String> attribs = ml.attributes().collect(Collectors.toList());
+        assertEquals(attribs, List.of("name", "MyAttribute"));
+    }
+
+}
diff a/test/jdk/java/foreign/TestLayoutConstants.java b/test/jdk/java/foreign/TestLayoutConstants.java
--- a/test/jdk/java/foreign/TestLayoutConstants.java
+++ b/test/jdk/java/foreign/TestLayoutConstants.java
@@ -104,10 +104,13 @@
                                 MemoryLayouts.BITS_32_BE)) },
                 { MemoryLayout.ofSequence(5,
                         MemoryLayout.ofStruct(
                                 MemoryLayouts.PAD_8,
                                 MemoryLayouts.BITS_32_BE)) },
+                { MemoryLayouts.BITS_32_LE.withName("myInt") },
+                { MemoryLayouts.BITS_32_LE.withBitAlignment(8) },
+                { MemoryLayouts.BITS_32_LE.withAttribute("xyz", "abc") },
         };
     }
 
     @DataProvider(name = "functions")
     public Object[][] createFunctions() {

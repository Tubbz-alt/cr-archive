diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
@@ -177,11 +177,24 @@
         COMPLEX_LONG_DOUBLE,
 
         /**
          * The {@code T*} native type.
          */
-        POINTER
+        POINTER;
+
+        /**
+         * Retrieve the ABI type attached to the given layout,
+         * or throw an {@code IllegalArgumentException} if there is none
+         *
+         * @param ml the layout to retrieve the ABI type of
+         * @return the retrieved ABI type
+         * @throws IllegalArgumentException if the given layout does not have an ABI type annotation
+         */
+        public static Type fromLayout(MemoryLayout ml) throws IllegalArgumentException {
+            return ml.attribute(NATIVE_TYPE, SystemABI.Type.class)
+                     .orElseThrow(() -> new IllegalArgumentException("No ABI attribute present"));
+        }
     }
 
     /**
      * Returns memory layout for the given native type if supported by the platform ABI.
      * @param type the native type for which the layout is to be retrieved.
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
@@ -161,14 +161,11 @@
         INTEGER,
         FLOAT,
     }
 
     private static TypeClass classifyValueType(ValueLayout type) {
-        var optAbiType = type.attribute(SystemABI.NATIVE_TYPE, SystemABI.Type.class);
-        //padding not allowed here
-        ArgumentClassImpl clazz = optAbiType.map(AArch64ABI::argumentClassFor).
-            orElseThrow(()->new IllegalStateException("Unexpected value layout: could not determine ABI class"));
+        ArgumentClassImpl clazz = AArch64ABI.argumentClassFor(SystemABI.Type.fromLayout(type));
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
 
@@ -199,18 +196,16 @@
         MemoryLayout baseType = groupLayout.memberLayouts().get(0);
 
         if (!(baseType instanceof ValueLayout))
             return false;
 
-        var optAbiType = baseType.attribute(SystemABI.NATIVE_TYPE, SystemABI.Type.class);
-        ArgumentClassImpl baseArgClass = optAbiType.map(AArch64ABI::argumentClassFor).orElse(null);
+        ArgumentClassImpl baseArgClass = AArch64ABI.argumentClassFor(SystemABI.Type.fromLayout(baseType));
         if (baseArgClass != ArgumentClassImpl.VECTOR)
            return false;
 
         for (MemoryLayout elem : groupLayout.memberLayouts()) {
-            optAbiType = elem.attribute(SystemABI.NATIVE_TYPE, SystemABI.Type.class);
-            ArgumentClassImpl argClass = optAbiType.map(AArch64ABI::argumentClassFor).orElse(null);
+            ArgumentClassImpl argClass = AArch64ABI.argumentClassFor(SystemABI.Type.fromLayout(elem));
             if (!(elem instanceof ValueLayout) ||
                     elem.bitSize() != baseType.bitSize() ||
                     elem.bitAlignment() != baseType.bitAlignment() ||
                     baseArgClass != argClass) {
                 return false;
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -427,14 +427,11 @@
     }
 
 
     private static List<ArgumentClassImpl> classifyValueType(ValueLayout type) {
         ArrayList<ArgumentClassImpl> classes = new ArrayList<>();
-        var optAbiType = type.attribute(SystemABI.NATIVE_TYPE, SystemABI.Type.class);
-        //padding not allowed here
-        ArgumentClassImpl clazz = optAbiType.map(SysVx64ABI::argumentClassFor).
-            orElseThrow(()->new IllegalStateException("Unexpected value layout: could not determine ABI class"));
+        ArgumentClassImpl clazz = SysVx64ABI.argumentClassFor(SystemABI.Type.fromLayout(type));
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
         classes.add(clazz);
@@ -518,13 +515,14 @@
     }
 
     // TODO: handle zero length arrays
     // TODO: Handle nested structs (and primitives)
     private static List<ArgumentClassImpl> classifyStructType(GroupLayout type) {
-        var optAbiType = type.attribute(SystemABI.NATIVE_TYPE, SystemABI.Type.class);
-        var clazz = optAbiType.map(SysVx64ABI::argumentClassFor).orElse(null);
-        if (clazz == ArgumentClassImpl.COMPLEX_X87) {
+        if (type.attribute(SystemABI.NATIVE_TYPE, SystemABI.Type.class)
+                .map(SysVx64ABI::argumentClassFor)
+                .filter(ArgumentClassImpl.COMPLEX_X87::equals)
+                .isPresent()) {
             return COMPLEX_X87_CLASSES;
         }
 
         long nWords = Utils.alignUp((type.byteSize()), 8) / 8;
         if (nWords > MAX_AGGREGATE_REGS_SIZE) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
@@ -41,10 +41,11 @@
 import jdk.internal.foreign.abi.ProgrammableUpcallHandler;
 import jdk.internal.foreign.abi.VMStorage;
 import jdk.internal.foreign.abi.x64.X86_64Architecture;
 import jdk.internal.foreign.abi.x64.ArgumentClassImpl;
 import jdk.internal.foreign.abi.SharedUtils;
+import jdk.internal.foreign.abi.x64.sysv.SysVx64ABI;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
 import java.util.List;
 import java.util.Optional;
@@ -160,14 +161,11 @@
         FLOAT,
         VARARG_FLOAT
     }
 
     private static TypeClass classifyValueType(ValueLayout type) {
-        var optAbiType = type.attribute(SystemABI.NATIVE_TYPE, SystemABI.Type.class);
-        //padding not allowed here
-        ArgumentClassImpl clazz = optAbiType.map(Windowsx64ABI::argumentClassFor).
-            orElseThrow(()->new IllegalStateException("Unexpected value layout: could not determine ABI class"));
+        ArgumentClassImpl clazz = Windowsx64ABI.argumentClassFor(SystemABI.Type.fromLayout(type));
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
 
diff a/test/jdk/java/foreign/NativeTestHelper.java b/test/jdk/java/foreign/NativeTestHelper.java
--- a/test/jdk/java/foreign/NativeTestHelper.java
+++ b/test/jdk/java/foreign/NativeTestHelper.java
@@ -36,24 +36,19 @@
 public class NativeTestHelper {
 
     public static final SystemABI ABI = Foreign.getInstance().getSystemABI();
 
     public static boolean isIntegral(MemoryLayout layout) {
-        var optAbiType = layout.attribute(SystemABI.NATIVE_TYPE, SystemABI.Type.class);
-        if (!optAbiType.isPresent()) {
-            return false;
-        }
-        return switch(optAbiType.get()) {
+        return switch(SystemABI.Type.fromLayout(layout)) {
             case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
                 INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG -> true;
             default -> false;
         };
     }
 
     public static boolean isPointer(MemoryLayout layout) {
-        return layout.attribute(SystemABI.NATIVE_TYPE, SystemABI.Type.class)
-                     .filter(Predicate.isEqual(Type.POINTER)).isPresent();
+        return SystemABI.Type.fromLayout(layout) == Type.POINTER;
     }
 
     public static ValueLayout asVarArg(ValueLayout layout) {
         return ABI.name().equals(ABI_WINDOWS) ? WinABI.asVarArg(layout) : layout;
     }
diff a/test/jdk/java/foreign/TestLayoutAttributes.java b/test/jdk/java/foreign/TestLayoutAttributes.java
--- /dev/null
+++ b/test/jdk/java/foreign/TestLayoutAttributes.java
@@ -0,0 +1,81 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ */
+
+/*
+ * @test
+ * @run testng TestLayoutAttributes
+ */
+
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
+import org.testng.annotations.Test;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+public class TestLayoutAttributes {
+
+    @Test
+    public void testAttribute() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withAttribute("MyAttribute", 10L);
+        assertEquals((long) ml.attribute("MyAttribute", Long.class).orElseThrow(), 10L);
+    }
+
+    @Test
+    public void testAttributeNonExistent() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withAttribute("MyAttribute", 10L);
+        assertTrue(ml.attribute("Foo").isEmpty());
+    }
+
+    @Test
+    public void testAttributeTypeFilter() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withAttribute("MyAttribute", 10L);
+        assertTrue(ml.attribute("MyAttribute", Integer.class).isEmpty());
+        assertTrue(ml.attribute("MyAttribute", Long.class).isPresent());
+        assertTrue(ml.attribute("MyAttribute").isPresent());
+    }
+
+    @Test
+    public void testNameAttribute() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withName("foo");
+        assertEquals(ml.name().orElseThrow(), "foo");
+        assertEquals(ml.attribute("name", String.class).orElseThrow(), "foo");
+    }
+
+    @Test
+    public void testAttributesStream() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withName("foo")
+                .withAttribute("MyAttribute", 10L);
+        List<String> attribs = ml.attributes().collect(Collectors.toList());
+        assertEquals(attribs, List.of("name", "MyAttribute"));
+    }
+
+}
diff a/test/jdk/java/foreign/TestLayoutConstants.java b/test/jdk/java/foreign/TestLayoutConstants.java
--- a/test/jdk/java/foreign/TestLayoutConstants.java
+++ b/test/jdk/java/foreign/TestLayoutConstants.java
@@ -106,11 +106,11 @@
                         MemoryLayout.ofStruct(
                                 MemoryLayouts.PAD_8,
                                 MemoryLayouts.BITS_32_BE)) },
                 { MemoryLayouts.BITS_32_LE.withName("myInt") },
                 { MemoryLayouts.BITS_32_LE.withBitAlignment(8) },
-                { MemoryLayouts.BITS_32_LE.withAttribute("xyz", "xyz") },
+                { MemoryLayouts.BITS_32_LE.withAttribute("xyz", "abc") },
         };
     }
 
     @DataProvider(name = "functions")
     public Object[][] createFunctions() {

diff a/src/hotspot/cpu/x86/x86_64.ad b/src/hotspot/cpu/x86/x86_64.ad
--- a/src/hotspot/cpu/x86/x86_64.ad
+++ b/src/hotspot/cpu/x86/x86_64.ad
@@ -459,10 +459,11 @@
   return offset;
 }
 
 int MachCallNativeNode::ret_addr_offset() {
   int offset = 13; // movq r10,#addr; callq (r10)
+  offset += clear_avx_size();
   return offset;
 }
 //
 // Compute padding required for nodes which need alignment
 //
@@ -12567,13 +12568,11 @@
   match(CallNative);
   effect(USE meth);
 
   ins_cost(300);
   format %{ "call_native " %}
-  ins_encode %{
-    __ call(RuntimeAddress((address) $meth$$method));
-  %}
+  ins_encode(clear_avx, Java_To_Runtime(meth));
   ins_pipe(pipe_slow);
 %}
 
 // Call runtime without safepoint
 instruct CallLeafNoFPDirect(method meth)
diff a/src/hotspot/share/opto/output.cpp b/src/hotspot/share/opto/output.cpp
--- a/src/hotspot/share/opto/output.cpp
+++ b/src/hotspot/share/opto/output.cpp
@@ -1603,10 +1603,12 @@
       // "Normal" instruction case
       DEBUG_ONLY( uint instr_offset = cb->insts_size(); )
       n->emit(*cb, C->regalloc());
       current_offset  = cb->insts_size();
 
+      assert(!is_mcall || (call_returns[block->_pre_order] == current_offset), "ret_addr_offset() did not match size of emitted code");
+
       // Above we only verified that there is enough space in the instruction section.
       // However, the instruction may emit stubs that cause code buffer expansion.
       // Bail out here if expansion failed due to a lack of code cache space.
       if (C->failing()) {
         return;

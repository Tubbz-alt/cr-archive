<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
  360   return UseCompressedOops;
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 int MachCallNativeNode::ret_addr_offset() {
  463   int offset = 13; // movq r10,#addr; callq (r10)
  464   return offset;
  465 }
  466 //
  467 // Compute padding required for nodes which need alignment
  468 //
  469 
  470 // The address of the call instruction needs to be 4-byte aligned to
  471 // ensure that it does not span a cache line so that it can be patched.
  472 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  473 {
  474   current_offset += clear_avx_size(); // skip vzeroupper
  475   current_offset += 1; // skip call opcode byte
  476   return align_up(current_offset, alignment_required()) - current_offset;
  477 }
  478 
  479 // The address of the call instruction needs to be 4-byte aligned to
  480 // ensure that it does not span a cache line so that it can be patched.
  481 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  482 {
  483   current_offset += clear_avx_size(); // skip vzeroupper
  484   current_offset += 11; // skip movq instruction + call opcode byte
  485   return align_up(current_offset, alignment_required()) - current_offset;
  486 }
  487 
  488 // EMIT_RM()
  489 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  490   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  491   cbuf.insts()-&gt;emit_int8(c);
  492 }
  493 
  494 // EMIT_CC()
  495 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  496   unsigned char c = (unsigned char) (f1 | f2);
  497   cbuf.insts()-&gt;emit_int8(c);
  498 }
  499 
  500 // EMIT_OPCODE()
  501 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  502   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  503 }
  504 
  505 // EMIT_OPCODE() w/ relocation information
  506 void emit_opcode(CodeBuffer &amp;cbuf,
  507                  int code, relocInfo::relocType reloc, int offset, int format)
  508 {
  509   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  510   emit_opcode(cbuf, code);
  511 }
  512 
  513 // EMIT_D8()
  514 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  515   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  516 }
  517 
  518 // EMIT_D16()
  519 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  520   cbuf.insts()-&gt;emit_int16(d16);
  521 }
  522 
  523 // EMIT_D32()
  524 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  525   cbuf.insts()-&gt;emit_int32(d32);
  526 }
  527 
  528 // EMIT_D64()
  529 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  530   cbuf.insts()-&gt;emit_int64(d64);
  531 }
  532 
  533 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  534 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  535                     int d32,
  536                     relocInfo::relocType reloc,
  537                     int format)
  538 {
  539   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  540   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  541   cbuf.insts()-&gt;emit_int32(d32);
  542 }
  543 
  544 // emit 32 bit value and construct relocation entry from RelocationHolder
  545 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  546 #ifdef ASSERT
  547   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  548       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  549     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  550     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  551   }
  552 #endif
  553   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  554   cbuf.insts()-&gt;emit_int32(d32);
  555 }
  556 
  557 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  558   address next_ip = cbuf.insts_end() + 4;
  559   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  560                  external_word_Relocation::spec(addr),
  561                  RELOC_DISP32);
  562 }
  563 
  564 
  565 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  566 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  567   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  568   cbuf.insts()-&gt;emit_int64(d64);
  569 }
  570 
  571 // emit 64 bit value and construct relocation entry from RelocationHolder
  572 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  573 #ifdef ASSERT
  574   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  575       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  576     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  577     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  578   }
  579 #endif
  580   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  581   cbuf.insts()-&gt;emit_int64(d64);
  582 }
  583 
  584 // Access stack slot for load or store
  585 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  586 {
  587   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  588   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  589     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  590     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  591     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  592   } else {
  593     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  594     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  595     emit_d32(cbuf, disp);     // Displacement // R/M byte
  596   }
  597 }
  598 
  599    // rRegI ereg, memory mem) %{    // emit_reg_mem
  600 void encode_RegMem(CodeBuffer &amp;cbuf,
  601                    int reg,
  602                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  603 {
  604   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  605   int regenc = reg &amp; 7;
  606   int baseenc = base &amp; 7;
  607   int indexenc = index &amp; 7;
  608 
  609   // There is no index &amp; no scale, use form without SIB byte
  610   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  611     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  612     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  613       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  614     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  615       // If 8-bit displacement, mode 0x1
  616       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  617       emit_d8(cbuf, disp);
  618     } else {
  619       // If 32-bit displacement
  620       if (base == -1) { // Special flag for absolute address
  621         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  622         if (disp_reloc != relocInfo::none) {
  623           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  624         } else {
  625           emit_d32(cbuf, disp);
  626         }
  627       } else {
  628         // Normal base + offset
  629         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  630         if (disp_reloc != relocInfo::none) {
  631           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  632         } else {
  633           emit_d32(cbuf, disp);
  634         }
  635       }
  636     }
  637   } else {
  638     // Else, encode with the SIB byte
  639     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  640     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  641       // If no displacement
  642       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  643       emit_rm(cbuf, scale, indexenc, baseenc);
  644     } else {
  645       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  646         // If 8-bit displacement, mode 0x1
  647         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  648         emit_rm(cbuf, scale, indexenc, baseenc);
  649         emit_d8(cbuf, disp);
  650       } else {
  651         // If 32-bit displacement
  652         if (base == 0x04 ) {
  653           emit_rm(cbuf, 0x2, regenc, 0x4);
  654           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  655         } else {
  656           emit_rm(cbuf, 0x2, regenc, 0x4);
  657           emit_rm(cbuf, scale, indexenc, baseenc); // *
  658         }
  659         if (disp_reloc != relocInfo::none) {
  660           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  661         } else {
  662           emit_d32(cbuf, disp);
  663         }
  664       }
  665     }
  666   }
  667 }
  668 
  669 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  670 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  671   Label exit;
  672   __ jccb(Assembler::noParity, exit);
  673   __ pushf();
  674   //
  675   // comiss/ucomiss instructions set ZF,PF,CF flags and
  676   // zero OF,AF,SF for NaN values.
  677   // Fixup flags by zeroing ZF,PF so that compare of NaN
  678   // values returns &#39;less than&#39; result (CF is set).
  679   // Leave the rest of flags unchanged.
  680   //
  681   //    7 6 5 4 3 2 1 0
  682   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  683   //    0 0 1 0 1 0 1 1   (0x2B)
  684   //
  685   __ andq(Address(rsp, 0), 0xffffff2b);
  686   __ popf();
  687   __ bind(exit);
  688 }
  689 
  690 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  691   Label done;
  692   __ movl(dst, -1);
  693   __ jcc(Assembler::parity, done);
  694   __ jcc(Assembler::below, done);
  695   __ setb(Assembler::notEqual, dst);
  696   __ movzbl(dst, dst);
  697   __ bind(done);
  698 }
  699 
  700 // Math.min()    # Math.max()
  701 // --------------------------
  702 // ucomis[s/d]   #
  703 // ja   -&gt; b     # a
  704 // jp   -&gt; NaN   # NaN
  705 // jb   -&gt; a     # b
  706 // je            #
  707 // |-jz -&gt; a | b # a &amp; b
  708 // |    -&gt; a     #
  709 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  710                      XMMRegister a, XMMRegister b,
  711                      XMMRegister xmmt, Register rt,
  712                      bool min, bool single) {
  713 
  714   Label nan, zero, below, above, done;
  715 
  716   if (single)
  717     __ ucomiss(a, b);
  718   else
  719     __ ucomisd(a, b);
  720 
  721   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  722     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  723   else
  724     __ jccb(Assembler::above, done);
  725 
  726   __ jccb(Assembler::parity, nan);  // PF=1
  727   __ jccb(Assembler::below, below); // CF=1
  728 
  729   // equal
  730   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  731   if (single) {
  732     __ ucomiss(a, xmmt);
  733     __ jccb(Assembler::equal, zero);
  734 
  735     __ movflt(dst, a);
  736     __ jmp(done);
  737   }
  738   else {
  739     __ ucomisd(a, xmmt);
  740     __ jccb(Assembler::equal, zero);
  741 
  742     __ movdbl(dst, a);
  743     __ jmp(done);
  744   }
  745 
  746   __ bind(zero);
  747   if (min)
  748     __ vpor(dst, a, b, Assembler::AVX_128bit);
  749   else
  750     __ vpand(dst, a, b, Assembler::AVX_128bit);
  751 
  752   __ jmp(done);
  753 
  754   __ bind(above);
  755   if (single)
  756     __ movflt(dst, min ? b : a);
  757   else
  758     __ movdbl(dst, min ? b : a);
  759 
  760   __ jmp(done);
  761 
  762   __ bind(nan);
  763   if (single) {
  764     __ movl(rt, 0x7fc00000); // Float.NaN
  765     __ movdl(dst, rt);
  766   }
  767   else {
  768     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  769     __ movdq(dst, rt);
  770   }
  771   __ jmp(done);
  772 
  773   __ bind(below);
  774   if (single)
  775     __ movflt(dst, min ? a : b);
  776   else
  777     __ movdbl(dst, min ? a : b);
  778 
  779   __ bind(done);
  780 }
  781 
  782 //=============================================================================
  783 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  784 
  785 int ConstantTable::calculate_table_base_offset() const {
  786   return 0;  // absolute addressing, no offset
  787 }
  788 
  789 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  790 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  791   ShouldNotReachHere();
  792 }
  793 
  794 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  795   // Empty encoding
  796 }
  797 
  798 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  799   return 0;
  800 }
  801 
  802 #ifndef PRODUCT
  803 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  804   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  805 }
  806 #endif
  807 
  808 
  809 //=============================================================================
  810 #ifndef PRODUCT
  811 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  812   Compile* C = ra_-&gt;C;
  813 
  814   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  815   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  816   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  817   // Remove wordSize for return addr which is already pushed.
  818   framesize -= wordSize;
  819 
  820   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  821     framesize -= wordSize;
  822     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  823     st-&gt;print(&quot;\n\t&quot;);
  824     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  825     if (PreserveFramePointer) {
  826         st-&gt;print(&quot;\n\t&quot;);
  827         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  828     }
  829     if (framesize) {
  830       st-&gt;print(&quot;\n\t&quot;);
  831       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  832     }
  833   } else {
  834     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  835     st-&gt;print(&quot;\n\t&quot;);
  836     framesize -= wordSize;
  837     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  838     if (PreserveFramePointer) {
  839       st-&gt;print(&quot;\n\t&quot;);
  840       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  841       if (framesize &gt; 0) {
  842         st-&gt;print(&quot;\n\t&quot;);
  843         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  844       }
  845     }
  846   }
  847 
  848   if (VerifyStackAtCalls) {
  849     st-&gt;print(&quot;\n\t&quot;);
  850     framesize -= wordSize;
  851     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  852 #ifdef ASSERT
  853     st-&gt;print(&quot;\n\t&quot;);
  854     st-&gt;print(&quot;# stack alignment check&quot;);
  855 #endif
  856   }
  857   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  860     st-&gt;print(&quot;\n\t&quot;);
  861     st-&gt;print(&quot;je      fast_entry\t&quot;);
  862     st-&gt;print(&quot;\n\t&quot;);
  863     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  864     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  865   }
  866   st-&gt;cr();
  867 }
  868 #endif
  869 
  870 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  871   Compile* C = ra_-&gt;C;
  872   MacroAssembler _masm(&amp;cbuf);
  873 
  874   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  875   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  876 
  877   if (C-&gt;clinit_barrier_on_entry()) {
  878     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  879     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  880 
  881     Label L_skip_barrier;
  882     Register klass = rscratch1;
  883 
  884     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  885     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  886 
  887     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  888 
  889     __ bind(L_skip_barrier);
  890   }
  891 
  892   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);
  893 
  894   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  895 
  896   if (C-&gt;has_mach_constant_base_node()) {
  897     // NOTE: We set the table base offset here because users might be
  898     // emitted before MachConstantBaseNode.
  899     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  900     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  901   }
  902 }
  903 
  904 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
  905 {
  906   return MachNode::size(ra_); // too many variables; just compute it
  907                               // the hard way
  908 }
  909 
  910 int MachPrologNode::reloc() const
  911 {
  912   return 0; // a large enough number
  913 }
  914 
  915 //=============================================================================
  916 #ifndef PRODUCT
  917 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  918 {
  919   Compile* C = ra_-&gt;C;
  920   if (generate_vzeroupper(C)) {
  921     st-&gt;print(&quot;vzeroupper&quot;);
  922     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  923   }
  924 
  925   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  926   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  927   // Remove word for return adr already pushed
  928   // and RBP
  929   framesize -= 2*wordSize;
  930 
  931   if (framesize) {
  932     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  933     st-&gt;print(&quot;\t&quot;);
  934   }
  935 
  936   st-&gt;print_cr(&quot;popq    rbp&quot;);
  937   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  938     st-&gt;print(&quot;\t&quot;);
  939     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  940                  &quot;testl   rax, [rscratch1]\t&quot;
  941                  &quot;# Safepoint: poll for GC&quot;);
  942   }
  943 }
  944 #endif
  945 
  946 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  947 {
  948   Compile* C = ra_-&gt;C;
  949   MacroAssembler _masm(&amp;cbuf);
  950 
  951   if (generate_vzeroupper(C)) {
  952     // Clear upper bits of YMM registers when current compiled code uses
  953     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  954     __ vzeroupper();
  955   }
  956 
  957   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  958   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  959   // Remove word for return adr already pushed
  960   // and RBP
  961   framesize -= 2*wordSize;
  962 
  963   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  964 
  965   if (framesize) {
  966     emit_opcode(cbuf, Assembler::REX_W);
  967     if (framesize &lt; 0x80) {
  968       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
  969       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  970       emit_d8(cbuf, framesize);
  971     } else {
  972       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
  973       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  974       emit_d32(cbuf, framesize);
  975     }
  976   }
  977 
  978   // popq rbp
  979   emit_opcode(cbuf, 0x58 | RBP_enc);
  980 
  981   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  982     __ reserved_stack_check();
  983   }
  984 
  985   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  986     MacroAssembler _masm(&amp;cbuf);
  987     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  988     __ relocate(relocInfo::poll_return_type);
  989     __ testl(rax, Address(rscratch1, 0));
  990   }
  991 }
  992 
  993 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
  994 {
  995   return MachNode::size(ra_); // too many variables; just compute it
  996                               // the hard way
  997 }
  998 
  999 int MachEpilogNode::reloc() const
 1000 {
 1001   return 2; // a large enough number
 1002 }
 1003 
 1004 const Pipeline* MachEpilogNode::pipeline() const
 1005 {
 1006   return MachNode::pipeline_class();
 1007 }
 1008 
 1009 //=============================================================================
 1010 
 1011 enum RC {
 1012   rc_bad,
 1013   rc_int,
 1014   rc_float,
 1015   rc_stack
 1016 };
 1017 
 1018 static enum RC rc_class(OptoReg::Name reg)
 1019 {
 1020   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1021 
 1022   if (OptoReg::is_stack(reg)) return rc_stack;
 1023 
 1024   VMReg r = OptoReg::as_VMReg(reg);
 1025 
 1026   if (r-&gt;is_Register()) return rc_int;
 1027 
 1028   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1029   return rc_float;
 1030 }
 1031 
 1032 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1033 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1034                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1035 
 1036 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1037                      int stack_offset, int reg, uint ireg, outputStream* st);
 1038 
 1039 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1040                                       int dst_offset, uint ireg, outputStream* st) {
 1041   if (cbuf) {
 1042     MacroAssembler _masm(cbuf);
 1043     switch (ireg) {
 1044     case Op_VecS:
 1045       __ movq(Address(rsp, -8), rax);
 1046       __ movl(rax, Address(rsp, src_offset));
 1047       __ movl(Address(rsp, dst_offset), rax);
 1048       __ movq(rax, Address(rsp, -8));
 1049       break;
 1050     case Op_VecD:
 1051       __ pushq(Address(rsp, src_offset));
 1052       __ popq (Address(rsp, dst_offset));
 1053       break;
 1054     case Op_VecX:
 1055       __ pushq(Address(rsp, src_offset));
 1056       __ popq (Address(rsp, dst_offset));
 1057       __ pushq(Address(rsp, src_offset+8));
 1058       __ popq (Address(rsp, dst_offset+8));
 1059       break;
 1060     case Op_VecY:
 1061       __ vmovdqu(Address(rsp, -32), xmm0);
 1062       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1063       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1064       __ vmovdqu(xmm0, Address(rsp, -32));
 1065       break;
 1066     case Op_VecZ:
 1067       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1068       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1069       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1070       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1071       break;
 1072     default:
 1073       ShouldNotReachHere();
 1074     }
 1075 #ifndef PRODUCT
 1076   } else {
 1077     switch (ireg) {
 1078     case Op_VecS:
 1079       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1080                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1081                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1082                 &quot;movq    rax, [rsp - #8]&quot;,
 1083                 src_offset, dst_offset);
 1084       break;
 1085     case Op_VecD:
 1086       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1087                 &quot;popq    [rsp + #%d]&quot;,
 1088                 src_offset, dst_offset);
 1089       break;
 1090      case Op_VecX:
 1091       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1092                 &quot;popq    [rsp + #%d]\n\t&quot;
 1093                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1094                 &quot;popq    [rsp + #%d]&quot;,
 1095                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1096       break;
 1097     case Op_VecY:
 1098       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1099                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1100                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1101                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1102                 src_offset, dst_offset);
 1103       break;
 1104     case Op_VecZ:
 1105       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1106                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1107                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1108                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1109                 src_offset, dst_offset);
 1110       break;
 1111     default:
 1112       ShouldNotReachHere();
 1113     }
 1114 #endif
 1115   }
 1116 }
 1117 
 1118 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1119                                        PhaseRegAlloc* ra_,
 1120                                        bool do_size,
 1121                                        outputStream* st) const {
 1122   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1123   // Get registers to move
 1124   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1125   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1126   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1127   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1128 
 1129   enum RC src_second_rc = rc_class(src_second);
 1130   enum RC src_first_rc = rc_class(src_first);
 1131   enum RC dst_second_rc = rc_class(dst_second);
 1132   enum RC dst_first_rc = rc_class(dst_first);
 1133 
 1134   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1135          &quot;must move at least 1 register&quot; );
 1136 
 1137   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1138     // Self copy, no move
 1139     return 0;
 1140   }
 1141   if (bottom_type()-&gt;isa_vect() != NULL) {
 1142     uint ireg = ideal_reg();
 1143     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1144     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1145     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1146       // mem -&gt; mem
 1147       int src_offset = ra_-&gt;reg2offset(src_first);
 1148       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1149       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1150     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1151       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1152     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1153       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1154       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1155     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1156       int stack_offset = ra_-&gt;reg2offset(src_first);
 1157       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1158     } else {
 1159       ShouldNotReachHere();
 1160     }
 1161     return 0;
 1162   }
 1163   if (src_first_rc == rc_stack) {
 1164     // mem -&gt;
 1165     if (dst_first_rc == rc_stack) {
 1166       // mem -&gt; mem
 1167       assert(src_second != dst_first, &quot;overlap&quot;);
 1168       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1169           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1170         // 64-bit
 1171         int src_offset = ra_-&gt;reg2offset(src_first);
 1172         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1173         if (cbuf) {
 1174           MacroAssembler _masm(cbuf);
 1175           __ pushq(Address(rsp, src_offset));
 1176           __ popq (Address(rsp, dst_offset));
 1177 #ifndef PRODUCT
 1178         } else {
 1179           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1180                     &quot;popq    [rsp + #%d]&quot;,
 1181                      src_offset, dst_offset);
 1182 #endif
 1183         }
 1184       } else {
 1185         // 32-bit
 1186         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1187         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1188         // No pushl/popl, so:
 1189         int src_offset = ra_-&gt;reg2offset(src_first);
 1190         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1191         if (cbuf) {
 1192           MacroAssembler _masm(cbuf);
 1193           __ movq(Address(rsp, -8), rax);
 1194           __ movl(rax, Address(rsp, src_offset));
 1195           __ movl(Address(rsp, dst_offset), rax);
 1196           __ movq(rax, Address(rsp, -8));
 1197 #ifndef PRODUCT
 1198         } else {
 1199           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1200                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1201                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1202                     &quot;movq    rax, [rsp - #8]&quot;,
 1203                      src_offset, dst_offset);
 1204 #endif
 1205         }
 1206       }
 1207       return 0;
 1208     } else if (dst_first_rc == rc_int) {
 1209       // mem -&gt; gpr
 1210       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1211           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1212         // 64-bit
 1213         int offset = ra_-&gt;reg2offset(src_first);
 1214         if (cbuf) {
 1215           MacroAssembler _masm(cbuf);
 1216           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1217 #ifndef PRODUCT
 1218         } else {
 1219           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1220                      Matcher::regName[dst_first],
 1221                      offset);
 1222 #endif
 1223         }
 1224       } else {
 1225         // 32-bit
 1226         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1227         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1228         int offset = ra_-&gt;reg2offset(src_first);
 1229         if (cbuf) {
 1230           MacroAssembler _masm(cbuf);
 1231           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1232 #ifndef PRODUCT
 1233         } else {
 1234           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1235                      Matcher::regName[dst_first],
 1236                      offset);
 1237 #endif
 1238         }
 1239       }
 1240       return 0;
 1241     } else if (dst_first_rc == rc_float) {
 1242       // mem-&gt; xmm
 1243       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1244           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1245         // 64-bit
 1246         int offset = ra_-&gt;reg2offset(src_first);
 1247         if (cbuf) {
 1248           MacroAssembler _masm(cbuf);
 1249           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1250 #ifndef PRODUCT
 1251         } else {
 1252           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1253                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1254                      Matcher::regName[dst_first],
 1255                      offset);
 1256 #endif
 1257         }
 1258       } else {
 1259         // 32-bit
 1260         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1261         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1262         int offset = ra_-&gt;reg2offset(src_first);
 1263         if (cbuf) {
 1264           MacroAssembler _masm(cbuf);
 1265           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1266 #ifndef PRODUCT
 1267         } else {
 1268           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1269                      Matcher::regName[dst_first],
 1270                      offset);
 1271 #endif
 1272         }
 1273       }
 1274       return 0;
 1275     }
 1276   } else if (src_first_rc == rc_int) {
 1277     // gpr -&gt;
 1278     if (dst_first_rc == rc_stack) {
 1279       // gpr -&gt; mem
 1280       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1281           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1282         // 64-bit
 1283         int offset = ra_-&gt;reg2offset(dst_first);
 1284         if (cbuf) {
 1285           MacroAssembler _masm(cbuf);
 1286           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1287 #ifndef PRODUCT
 1288         } else {
 1289           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1290                      offset,
 1291                      Matcher::regName[src_first]);
 1292 #endif
 1293         }
 1294       } else {
 1295         // 32-bit
 1296         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1297         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1298         int offset = ra_-&gt;reg2offset(dst_first);
 1299         if (cbuf) {
 1300           MacroAssembler _masm(cbuf);
 1301           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1302 #ifndef PRODUCT
 1303         } else {
 1304           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1305                      offset,
 1306                      Matcher::regName[src_first]);
 1307 #endif
 1308         }
 1309       }
 1310       return 0;
 1311     } else if (dst_first_rc == rc_int) {
 1312       // gpr -&gt; gpr
 1313       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1314           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1315         // 64-bit
 1316         if (cbuf) {
 1317           MacroAssembler _masm(cbuf);
 1318           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1319                   as_Register(Matcher::_regEncode[src_first]));
 1320 #ifndef PRODUCT
 1321         } else {
 1322           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1323                      Matcher::regName[dst_first],
 1324                      Matcher::regName[src_first]);
 1325 #endif
 1326         }
 1327         return 0;
 1328       } else {
 1329         // 32-bit
 1330         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1331         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1332         if (cbuf) {
 1333           MacroAssembler _masm(cbuf);
 1334           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1335                   as_Register(Matcher::_regEncode[src_first]));
 1336 #ifndef PRODUCT
 1337         } else {
 1338           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1339                      Matcher::regName[dst_first],
 1340                      Matcher::regName[src_first]);
 1341 #endif
 1342         }
 1343         return 0;
 1344       }
 1345     } else if (dst_first_rc == rc_float) {
 1346       // gpr -&gt; xmm
 1347       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1348           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1349         // 64-bit
 1350         if (cbuf) {
 1351           MacroAssembler _masm(cbuf);
 1352           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1353 #ifndef PRODUCT
 1354         } else {
 1355           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1356                      Matcher::regName[dst_first],
 1357                      Matcher::regName[src_first]);
 1358 #endif
 1359         }
 1360       } else {
 1361         // 32-bit
 1362         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1363         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1364         if (cbuf) {
 1365           MacroAssembler _masm(cbuf);
 1366           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1367 #ifndef PRODUCT
 1368         } else {
 1369           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1370                      Matcher::regName[dst_first],
 1371                      Matcher::regName[src_first]);
 1372 #endif
 1373         }
 1374       }
 1375       return 0;
 1376     }
 1377   } else if (src_first_rc == rc_float) {
 1378     // xmm -&gt;
 1379     if (dst_first_rc == rc_stack) {
 1380       // xmm -&gt; mem
 1381       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1382           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1383         // 64-bit
 1384         int offset = ra_-&gt;reg2offset(dst_first);
 1385         if (cbuf) {
 1386           MacroAssembler _masm(cbuf);
 1387           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1388 #ifndef PRODUCT
 1389         } else {
 1390           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1391                      offset,
 1392                      Matcher::regName[src_first]);
 1393 #endif
 1394         }
 1395       } else {
 1396         // 32-bit
 1397         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1398         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1399         int offset = ra_-&gt;reg2offset(dst_first);
 1400         if (cbuf) {
 1401           MacroAssembler _masm(cbuf);
 1402           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1403 #ifndef PRODUCT
 1404         } else {
 1405           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1406                      offset,
 1407                      Matcher::regName[src_first]);
 1408 #endif
 1409         }
 1410       }
 1411       return 0;
 1412     } else if (dst_first_rc == rc_int) {
 1413       // xmm -&gt; gpr
 1414       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1415           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1416         // 64-bit
 1417         if (cbuf) {
 1418           MacroAssembler _masm(cbuf);
 1419           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1420 #ifndef PRODUCT
 1421         } else {
 1422           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1423                      Matcher::regName[dst_first],
 1424                      Matcher::regName[src_first]);
 1425 #endif
 1426         }
 1427       } else {
 1428         // 32-bit
 1429         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1430         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1431         if (cbuf) {
 1432           MacroAssembler _masm(cbuf);
 1433           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1434 #ifndef PRODUCT
 1435         } else {
 1436           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1437                      Matcher::regName[dst_first],
 1438                      Matcher::regName[src_first]);
 1439 #endif
 1440         }
 1441       }
 1442       return 0;
 1443     } else if (dst_first_rc == rc_float) {
 1444       // xmm -&gt; xmm
 1445       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1446           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1447         // 64-bit
 1448         if (cbuf) {
 1449           MacroAssembler _masm(cbuf);
 1450           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1451 #ifndef PRODUCT
 1452         } else {
 1453           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1454                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1455                      Matcher::regName[dst_first],
 1456                      Matcher::regName[src_first]);
 1457 #endif
 1458         }
 1459       } else {
 1460         // 32-bit
 1461         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1462         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1463         if (cbuf) {
 1464           MacroAssembler _masm(cbuf);
 1465           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1466 #ifndef PRODUCT
 1467         } else {
 1468           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1469                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1470                      Matcher::regName[dst_first],
 1471                      Matcher::regName[src_first]);
 1472 #endif
 1473         }
 1474       }
 1475       return 0;
 1476     }
 1477   }
 1478 
 1479   assert(0,&quot; foo &quot;);
 1480   Unimplemented();
 1481   return 0;
 1482 }
 1483 
 1484 #ifndef PRODUCT
 1485 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1486   implementation(NULL, ra_, false, st);
 1487 }
 1488 #endif
 1489 
 1490 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1491   implementation(&amp;cbuf, ra_, false, NULL);
 1492 }
 1493 
 1494 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1495   return MachNode::size(ra_);
 1496 }
 1497 
 1498 //=============================================================================
 1499 #ifndef PRODUCT
 1500 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1501 {
 1502   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1503   int reg = ra_-&gt;get_reg_first(this);
 1504   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1505             Matcher::regName[reg], offset);
 1506 }
 1507 #endif
 1508 
 1509 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1510 {
 1511   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1512   int reg = ra_-&gt;get_encode(this);
 1513   if (offset &gt;= 0x80) {
 1514     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1515     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1516     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1517     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1518     emit_d32(cbuf, offset);
 1519   } else {
 1520     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1521     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1522     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1523     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1524     emit_d8(cbuf, offset);
 1525   }
 1526 }
 1527 
 1528 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1529 {
 1530   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1531   return (offset &lt; 0x80) ? 5 : 8; // REX
 1532 }
 1533 
 1534 //=============================================================================
 1535 #ifndef PRODUCT
 1536 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1537 {
 1538   if (UseCompressedClassPointers) {
 1539     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1540     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1541     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1542   } else {
 1543     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1544                  &quot;# Inline cache check&quot;);
 1545   }
 1546   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1547   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1548 }
 1549 #endif
 1550 
 1551 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1552 {
 1553   MacroAssembler masm(&amp;cbuf);
 1554   uint insts_size = cbuf.insts_size();
 1555   if (UseCompressedClassPointers) {
 1556     masm.load_klass(rscratch1, j_rarg0, rscratch2);
 1557     masm.cmpptr(rax, rscratch1);
 1558   } else {
 1559     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1560   }
 1561 
 1562   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1563 
 1564   /* WARNING these NOPs are critical so that verified entry point is properly
 1565      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1566   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1567   if (OptoBreakpoint) {
 1568     // Leave space for int3
 1569     nops_cnt -= 1;
 1570   }
 1571   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1572   if (nops_cnt &gt; 0)
 1573     masm.nop(nops_cnt);
 1574 }
 1575 
 1576 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
 1577 {
 1578   return MachNode::size(ra_); // too many variables; just compute it
 1579                               // the hard way
 1580 }
 1581 
 1582 
 1583 //=============================================================================
 1584 
 1585 int Matcher::regnum_to_fpu_offset(int regnum)
 1586 {
 1587   return regnum - 32; // The FP registers are in the second chunk
 1588 }
 1589 
 1590 // This is UltraSparc specific, true just means we have fast l2f conversion
 1591 const bool Matcher::convL2FSupported(void) {
 1592   return true;
 1593 }
 1594 
 1595 // Is this branch offset short enough that a short branch can be used?
 1596 //
 1597 // NOTE: If the platform does not provide any short branch variants, then
 1598 //       this method should return false for offset 0.
 1599 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1600   // The passed offset is relative to address of the branch.
 1601   // On 86 a branch displacement is calculated relative to address
 1602   // of a next instruction.
 1603   offset -= br_size;
 1604 
 1605   // the short version of jmpConUCF2 contains multiple branches,
 1606   // making the reach slightly less
 1607   if (rule == jmpConUCF2_rule)
 1608     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1609   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1610 }
 1611 
 1612 const bool Matcher::isSimpleConstant64(jlong value) {
 1613   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1614   //return value == (int) value;  // Cf. storeImmL and immL32.
 1615 
 1616   // Probably always true, even if a temp register is required.
 1617   return true;
 1618 }
 1619 
 1620 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1621 const bool Matcher::init_array_count_is_in_bytes = false;
 1622 
 1623 // No additional cost for CMOVL.
 1624 const int Matcher::long_cmove_cost() { return 0; }
 1625 
 1626 // No CMOVF/CMOVD with SSE2
 1627 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1628 
 1629 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1630 const bool Matcher::require_postalloc_expand = false;
 1631 
 1632 // Do we need to mask the count passed to shift instructions or does
 1633 // the cpu only look at the lower 5/6 bits anyway?
 1634 const bool Matcher::need_masked_shift_count = false;
 1635 
 1636 bool Matcher::narrow_oop_use_complex_address() {
 1637   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1638   return (LogMinObjAlignmentInBytes &lt;= 3);
 1639 }
 1640 
 1641 bool Matcher::narrow_klass_use_complex_address() {
 1642   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1643   return (LogKlassAlignmentInBytes &lt;= 3);
 1644 }
 1645 
 1646 bool Matcher::const_oop_prefer_decode() {
 1647   // Prefer ConN+DecodeN over ConP.
 1648   return true;
 1649 }
 1650 
 1651 bool Matcher::const_klass_prefer_decode() {
 1652   // Prefer ConP over ConNKlass+DecodeNKlass.
 1653   return true;
 1654 }
 1655 
 1656 // Is it better to copy float constants, or load them directly from
 1657 // memory?  Intel can load a float constant from a direct address,
 1658 // requiring no extra registers.  Most RISCs will have to materialize
 1659 // an address into a register first, so they would do better to copy
 1660 // the constant from stack.
 1661 const bool Matcher::rematerialize_float_constants = true; // XXX
 1662 
 1663 // If CPU can load and store mis-aligned doubles directly then no
 1664 // fixup is needed.  Else we split the double into 2 integer pieces
 1665 // and move it piece-by-piece.  Only happens when passing doubles into
 1666 // C code as the Java calling convention forces doubles to be aligned.
 1667 const bool Matcher::misaligned_doubles_ok = true;
 1668 
 1669 // No-op on amd64
 1670 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1671 
 1672 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1673 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1674 
 1675 // Are floats conerted to double when stored to stack during deoptimization?
 1676 // On x64 it is stored without convertion so we can use normal access.
 1677 bool Matcher::float_in_double() { return false; }
 1678 
 1679 // Do ints take an entire long register or just half?
 1680 const bool Matcher::int_in_long = true;
 1681 
 1682 // Return whether or not this register is ever used as an argument.
 1683 // This function is used on startup to build the trampoline stubs in
 1684 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1685 // call in the trampoline, and arguments in those registers not be
 1686 // available to the callee.
 1687 bool Matcher::can_be_java_arg(int reg)
 1688 {
 1689   return
 1690     reg ==  RDI_num || reg == RDI_H_num ||
 1691     reg ==  RSI_num || reg == RSI_H_num ||
 1692     reg ==  RDX_num || reg == RDX_H_num ||
 1693     reg ==  RCX_num || reg == RCX_H_num ||
 1694     reg ==   R8_num || reg ==  R8_H_num ||
 1695     reg ==   R9_num || reg ==  R9_H_num ||
 1696     reg ==  R12_num || reg == R12_H_num ||
 1697     reg == XMM0_num || reg == XMM0b_num ||
 1698     reg == XMM1_num || reg == XMM1b_num ||
 1699     reg == XMM2_num || reg == XMM2b_num ||
 1700     reg == XMM3_num || reg == XMM3b_num ||
 1701     reg == XMM4_num || reg == XMM4b_num ||
 1702     reg == XMM5_num || reg == XMM5b_num ||
 1703     reg == XMM6_num || reg == XMM6b_num ||
 1704     reg == XMM7_num || reg == XMM7b_num;
 1705 }
 1706 
 1707 bool Matcher::is_spillable_arg(int reg)
 1708 {
 1709   return can_be_java_arg(reg);
 1710 }
 1711 
 1712 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1713   // In 64 bit mode a code which use multiply when
 1714   // devisor is constant is faster than hardware
 1715   // DIV instruction (it uses MulHiL).
 1716   return false;
 1717 }
 1718 
 1719 // Register for DIVI projection of divmodI
 1720 RegMask Matcher::divI_proj_mask() {
 1721   return INT_RAX_REG_mask();
 1722 }
 1723 
 1724 // Register for MODI projection of divmodI
 1725 RegMask Matcher::modI_proj_mask() {
 1726   return INT_RDX_REG_mask();
 1727 }
 1728 
 1729 // Register for DIVL projection of divmodL
 1730 RegMask Matcher::divL_proj_mask() {
 1731   return LONG_RAX_REG_mask();
 1732 }
 1733 
 1734 // Register for MODL projection of divmodL
 1735 RegMask Matcher::modL_proj_mask() {
 1736   return LONG_RDX_REG_mask();
 1737 }
 1738 
 1739 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1740 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1741     return NO_REG_mask();
 1742 }
 1743 
 1744 %}
 1745 
 1746 //----------ENCODING BLOCK-----------------------------------------------------
 1747 // This block specifies the encoding classes used by the compiler to
 1748 // output byte streams.  Encoding classes are parameterized macros
 1749 // used by Machine Instruction Nodes in order to generate the bit
 1750 // encoding of the instruction.  Operands specify their base encoding
 1751 // interface with the interface keyword.  There are currently
 1752 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1753 // COND_INTER.  REG_INTER causes an operand to generate a function
 1754 // which returns its register number when queried.  CONST_INTER causes
 1755 // an operand to generate a function which returns the value of the
 1756 // constant when queried.  MEMORY_INTER causes an operand to generate
 1757 // four functions which return the Base Register, the Index Register,
 1758 // the Scale Value, and the Offset Value of the operand when queried.
 1759 // COND_INTER causes an operand to generate six functions which return
 1760 // the encoding code (ie - encoding bits for the instruction)
 1761 // associated with each basic boolean condition for a conditional
 1762 // instruction.
 1763 //
 1764 // Instructions specify two basic values for encoding.  Again, a
 1765 // function is available to check if the constant displacement is an
 1766 // oop. They use the ins_encode keyword to specify their encoding
 1767 // classes (which must be a sequence of enc_class names, and their
 1768 // parameters, specified in the encoding block), and they use the
 1769 // opcode keyword to specify, in order, their primary, secondary, and
 1770 // tertiary opcode.  Only the opcode sections which a particular
 1771 // instruction needs for encoding need to be specified.
 1772 encode %{
 1773   // Build emit functions for each basic byte or larger field in the
 1774   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1775   // from C++ code in the enc_class source block.  Emit functions will
 1776   // live in the main source block for now.  In future, we can
 1777   // generalize this by adding a syntax that specifies the sizes of
 1778   // fields in an order, so that the adlc can build the emit functions
 1779   // automagically
 1780 
 1781   // Emit primary opcode
 1782   enc_class OpcP
 1783   %{
 1784     emit_opcode(cbuf, $primary);
 1785   %}
 1786 
 1787   // Emit secondary opcode
 1788   enc_class OpcS
 1789   %{
 1790     emit_opcode(cbuf, $secondary);
 1791   %}
 1792 
 1793   // Emit tertiary opcode
 1794   enc_class OpcT
 1795   %{
 1796     emit_opcode(cbuf, $tertiary);
 1797   %}
 1798 
 1799   // Emit opcode directly
 1800   enc_class Opcode(immI d8)
 1801   %{
 1802     emit_opcode(cbuf, $d8$$constant);
 1803   %}
 1804 
 1805   // Emit size prefix
 1806   enc_class SizePrefix
 1807   %{
 1808     emit_opcode(cbuf, 0x66);
 1809   %}
 1810 
 1811   enc_class reg(rRegI reg)
 1812   %{
 1813     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1814   %}
 1815 
 1816   enc_class reg_reg(rRegI dst, rRegI src)
 1817   %{
 1818     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1819   %}
 1820 
 1821   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1822   %{
 1823     emit_opcode(cbuf, $opcode$$constant);
 1824     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1825   %}
 1826 
 1827   enc_class cdql_enc(no_rax_rdx_RegI div)
 1828   %{
 1829     // Full implementation of Java idiv and irem; checks for
 1830     // special case as described in JVM spec., p.243 &amp; p.271.
 1831     //
 1832     //         normal case                           special case
 1833     //
 1834     // input : rax: dividend                         min_int
 1835     //         reg: divisor                          -1
 1836     //
 1837     // output: rax: quotient  (= rax idiv reg)       min_int
 1838     //         rdx: remainder (= rax irem reg)       0
 1839     //
 1840     //  Code sequnce:
 1841     //
 1842     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1843     //    5:   75 07/08                jne    e &lt;normal&gt;
 1844     //    7:   33 d2                   xor    %edx,%edx
 1845     //  [div &gt;= 8 -&gt; offset + 1]
 1846     //  [REX_B]
 1847     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1848     //    c:   74 03/04                je     11 &lt;done&gt;
 1849     // 000000000000000e &lt;normal&gt;:
 1850     //    e:   99                      cltd
 1851     //  [div &gt;= 8 -&gt; offset + 1]
 1852     //  [REX_B]
 1853     //    f:   f7 f9                   idiv   $div
 1854     // 0000000000000011 &lt;done&gt;:
 1855 
 1856     // cmp    $0x80000000,%eax
 1857     emit_opcode(cbuf, 0x3d);
 1858     emit_d8(cbuf, 0x00);
 1859     emit_d8(cbuf, 0x00);
 1860     emit_d8(cbuf, 0x00);
 1861     emit_d8(cbuf, 0x80);
 1862 
 1863     // jne    e &lt;normal&gt;
 1864     emit_opcode(cbuf, 0x75);
 1865     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1866 
 1867     // xor    %edx,%edx
 1868     emit_opcode(cbuf, 0x33);
 1869     emit_d8(cbuf, 0xD2);
 1870 
 1871     // cmp    $0xffffffffffffffff,%ecx
 1872     if ($div$$reg &gt;= 8) {
 1873       emit_opcode(cbuf, Assembler::REX_B);
 1874     }
 1875     emit_opcode(cbuf, 0x83);
 1876     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1877     emit_d8(cbuf, 0xFF);
 1878 
 1879     // je     11 &lt;done&gt;
 1880     emit_opcode(cbuf, 0x74);
 1881     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1882 
 1883     // &lt;normal&gt;
 1884     // cltd
 1885     emit_opcode(cbuf, 0x99);
 1886 
 1887     // idivl (note: must be emitted by the user of this rule)
 1888     // &lt;done&gt;
 1889   %}
 1890 
 1891   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1892   %{
 1893     // Full implementation of Java ldiv and lrem; checks for
 1894     // special case as described in JVM spec., p.243 &amp; p.271.
 1895     //
 1896     //         normal case                           special case
 1897     //
 1898     // input : rax: dividend                         min_long
 1899     //         reg: divisor                          -1
 1900     //
 1901     // output: rax: quotient  (= rax idiv reg)       min_long
 1902     //         rdx: remainder (= rax irem reg)       0
 1903     //
 1904     //  Code sequnce:
 1905     //
 1906     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1907     //    7:   00 00 80
 1908     //    a:   48 39 d0                cmp    %rdx,%rax
 1909     //    d:   75 08                   jne    17 &lt;normal&gt;
 1910     //    f:   33 d2                   xor    %edx,%edx
 1911     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1912     //   15:   74 05                   je     1c &lt;done&gt;
 1913     // 0000000000000017 &lt;normal&gt;:
 1914     //   17:   48 99                   cqto
 1915     //   19:   48 f7 f9                idiv   $div
 1916     // 000000000000001c &lt;done&gt;:
 1917 
 1918     // mov    $0x8000000000000000,%rdx
 1919     emit_opcode(cbuf, Assembler::REX_W);
 1920     emit_opcode(cbuf, 0xBA);
 1921     emit_d8(cbuf, 0x00);
 1922     emit_d8(cbuf, 0x00);
 1923     emit_d8(cbuf, 0x00);
 1924     emit_d8(cbuf, 0x00);
 1925     emit_d8(cbuf, 0x00);
 1926     emit_d8(cbuf, 0x00);
 1927     emit_d8(cbuf, 0x00);
 1928     emit_d8(cbuf, 0x80);
 1929 
 1930     // cmp    %rdx,%rax
 1931     emit_opcode(cbuf, Assembler::REX_W);
 1932     emit_opcode(cbuf, 0x39);
 1933     emit_d8(cbuf, 0xD0);
 1934 
 1935     // jne    17 &lt;normal&gt;
 1936     emit_opcode(cbuf, 0x75);
 1937     emit_d8(cbuf, 0x08);
 1938 
 1939     // xor    %edx,%edx
 1940     emit_opcode(cbuf, 0x33);
 1941     emit_d8(cbuf, 0xD2);
 1942 
 1943     // cmp    $0xffffffffffffffff,$div
 1944     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1945     emit_opcode(cbuf, 0x83);
 1946     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1947     emit_d8(cbuf, 0xFF);
 1948 
 1949     // je     1e &lt;done&gt;
 1950     emit_opcode(cbuf, 0x74);
 1951     emit_d8(cbuf, 0x05);
 1952 
 1953     // &lt;normal&gt;
 1954     // cqto
 1955     emit_opcode(cbuf, Assembler::REX_W);
 1956     emit_opcode(cbuf, 0x99);
 1957 
 1958     // idivq (note: must be emitted by the user of this rule)
 1959     // &lt;done&gt;
 1960   %}
 1961 
 1962   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1963   enc_class OpcSE(immI imm)
 1964   %{
 1965     // Emit primary opcode and set sign-extend bit
 1966     // Check for 8-bit immediate, and set sign extend bit in opcode
 1967     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1968       emit_opcode(cbuf, $primary | 0x02);
 1969     } else {
 1970       // 32-bit immediate
 1971       emit_opcode(cbuf, $primary);
 1972     }
 1973   %}
 1974 
 1975   enc_class OpcSErm(rRegI dst, immI imm)
 1976   %{
 1977     // OpcSEr/m
 1978     int dstenc = $dst$$reg;
 1979     if (dstenc &gt;= 8) {
 1980       emit_opcode(cbuf, Assembler::REX_B);
 1981       dstenc -= 8;
 1982     }
 1983     // Emit primary opcode and set sign-extend bit
 1984     // Check for 8-bit immediate, and set sign extend bit in opcode
 1985     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1986       emit_opcode(cbuf, $primary | 0x02);
 1987     } else {
 1988       // 32-bit immediate
 1989       emit_opcode(cbuf, $primary);
 1990     }
 1991     // Emit r/m byte with secondary opcode, after primary opcode.
 1992     emit_rm(cbuf, 0x3, $secondary, dstenc);
 1993   %}
 1994 
 1995   enc_class OpcSErm_wide(rRegL dst, immI imm)
 1996   %{
 1997     // OpcSEr/m
 1998     int dstenc = $dst$$reg;
 1999     if (dstenc &lt; 8) {
 2000       emit_opcode(cbuf, Assembler::REX_W);
 2001     } else {
 2002       emit_opcode(cbuf, Assembler::REX_WB);
 2003       dstenc -= 8;
 2004     }
 2005     // Emit primary opcode and set sign-extend bit
 2006     // Check for 8-bit immediate, and set sign extend bit in opcode
 2007     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2008       emit_opcode(cbuf, $primary | 0x02);
 2009     } else {
 2010       // 32-bit immediate
 2011       emit_opcode(cbuf, $primary);
 2012     }
 2013     // Emit r/m byte with secondary opcode, after primary opcode.
 2014     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2015   %}
 2016 
 2017   enc_class Con8or32(immI imm)
 2018   %{
 2019     // Check for 8-bit immediate, and set sign extend bit in opcode
 2020     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2021       $$$emit8$imm$$constant;
 2022     } else {
 2023       // 32-bit immediate
 2024       $$$emit32$imm$$constant;
 2025     }
 2026   %}
 2027 
 2028   enc_class opc2_reg(rRegI dst)
 2029   %{
 2030     // BSWAP
 2031     emit_cc(cbuf, $secondary, $dst$$reg);
 2032   %}
 2033 
 2034   enc_class opc3_reg(rRegI dst)
 2035   %{
 2036     // BSWAP
 2037     emit_cc(cbuf, $tertiary, $dst$$reg);
 2038   %}
 2039 
 2040   enc_class reg_opc(rRegI div)
 2041   %{
 2042     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2043     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2044   %}
 2045 
 2046   enc_class enc_cmov(cmpOp cop)
 2047   %{
 2048     // CMOV
 2049     $$$emit8$primary;
 2050     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2051   %}
 2052 
 2053   enc_class enc_PartialSubtypeCheck()
 2054   %{
 2055     Register Rrdi = as_Register(RDI_enc); // result register
 2056     Register Rrax = as_Register(RAX_enc); // super class
 2057     Register Rrcx = as_Register(RCX_enc); // killed
 2058     Register Rrsi = as_Register(RSI_enc); // sub class
 2059     Label miss;
 2060     const bool set_cond_codes = true;
 2061 
 2062     MacroAssembler _masm(&amp;cbuf);
 2063     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2064                                      NULL, &amp;miss,
 2065                                      /*set_cond_codes:*/ true);
 2066     if ($primary) {
 2067       __ xorptr(Rrdi, Rrdi);
 2068     }
 2069     __ bind(miss);
 2070   %}
 2071 
 2072   enc_class clear_avx %{
 2073     debug_only(int off0 = cbuf.insts_size());
 2074     if (generate_vzeroupper(Compile::current())) {
 2075       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2076       // Clear upper bits of YMM registers when current compiled code uses
 2077       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2078       MacroAssembler _masm(&amp;cbuf);
 2079       __ vzeroupper();
 2080     }
 2081     debug_only(int off1 = cbuf.insts_size());
 2082     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2083   %}
 2084 
 2085   enc_class Java_To_Runtime(method meth) %{
 2086     // No relocation needed
 2087     MacroAssembler _masm(&amp;cbuf);
 2088     __ mov64(r10, (int64_t) $meth$$method);
 2089     __ call(r10);
 2090   %}
 2091 
 2092   enc_class Java_To_Interpreter(method meth)
 2093   %{
 2094     // CALL Java_To_Interpreter
 2095     // This is the instruction starting address for relocation info.
 2096     cbuf.set_insts_mark();
 2097     $$$emit8$primary;
 2098     // CALL directly to the runtime
 2099     emit_d32_reloc(cbuf,
 2100                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2101                    runtime_call_Relocation::spec(),
 2102                    RELOC_DISP32);
 2103   %}
 2104 
 2105   enc_class Java_Static_Call(method meth)
 2106   %{
 2107     // JAVA STATIC CALL
 2108     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2109     // determine who we intended to call.
 2110     cbuf.set_insts_mark();
 2111     $$$emit8$primary;
 2112 
 2113     if (!_method) {
 2114       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2115                      runtime_call_Relocation::spec(),
 2116                      RELOC_DISP32);
 2117     } else {
 2118       int method_index = resolved_method_index(cbuf);
 2119       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2120                                                   : static_call_Relocation::spec(method_index);
 2121       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2122                      rspec, RELOC_DISP32);
 2123       // Emit stubs for static call.
 2124       address mark = cbuf.insts_mark();
 2125       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2126       if (stub == NULL) {
 2127         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2128         return;
 2129       }
 2130 #if INCLUDE_AOT
 2131       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2132 #endif
 2133     }
 2134   %}
 2135 
 2136   enc_class Java_Dynamic_Call(method meth) %{
 2137     MacroAssembler _masm(&amp;cbuf);
 2138     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2139   %}
 2140 
 2141   enc_class Java_Compiled_Call(method meth)
 2142   %{
 2143     // JAVA COMPILED CALL
 2144     int disp = in_bytes(Method:: from_compiled_offset());
 2145 
 2146     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2147     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2148 
 2149     // callq *disp(%rax)
 2150     cbuf.set_insts_mark();
 2151     $$$emit8$primary;
 2152     if (disp &lt; 0x80) {
 2153       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2154       emit_d8(cbuf, disp); // Displacement
 2155     } else {
 2156       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2157       emit_d32(cbuf, disp); // Displacement
 2158     }
 2159   %}
 2160 
 2161   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2162   %{
 2163     // SAL, SAR, SHR
 2164     int dstenc = $dst$$reg;
 2165     if (dstenc &gt;= 8) {
 2166       emit_opcode(cbuf, Assembler::REX_B);
 2167       dstenc -= 8;
 2168     }
 2169     $$$emit8$primary;
 2170     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2171     $$$emit8$shift$$constant;
 2172   %}
 2173 
 2174   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2175   %{
 2176     // SAL, SAR, SHR
 2177     int dstenc = $dst$$reg;
 2178     if (dstenc &lt; 8) {
 2179       emit_opcode(cbuf, Assembler::REX_W);
 2180     } else {
 2181       emit_opcode(cbuf, Assembler::REX_WB);
 2182       dstenc -= 8;
 2183     }
 2184     $$$emit8$primary;
 2185     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2186     $$$emit8$shift$$constant;
 2187   %}
 2188 
 2189   enc_class load_immI(rRegI dst, immI src)
 2190   %{
 2191     int dstenc = $dst$$reg;
 2192     if (dstenc &gt;= 8) {
 2193       emit_opcode(cbuf, Assembler::REX_B);
 2194       dstenc -= 8;
 2195     }
 2196     emit_opcode(cbuf, 0xB8 | dstenc);
 2197     $$$emit32$src$$constant;
 2198   %}
 2199 
 2200   enc_class load_immL(rRegL dst, immL src)
 2201   %{
 2202     int dstenc = $dst$$reg;
 2203     if (dstenc &lt; 8) {
 2204       emit_opcode(cbuf, Assembler::REX_W);
 2205     } else {
 2206       emit_opcode(cbuf, Assembler::REX_WB);
 2207       dstenc -= 8;
 2208     }
 2209     emit_opcode(cbuf, 0xB8 | dstenc);
 2210     emit_d64(cbuf, $src$$constant);
 2211   %}
 2212 
 2213   enc_class load_immUL32(rRegL dst, immUL32 src)
 2214   %{
 2215     // same as load_immI, but this time we care about zeroes in the high word
 2216     int dstenc = $dst$$reg;
 2217     if (dstenc &gt;= 8) {
 2218       emit_opcode(cbuf, Assembler::REX_B);
 2219       dstenc -= 8;
 2220     }
 2221     emit_opcode(cbuf, 0xB8 | dstenc);
 2222     $$$emit32$src$$constant;
 2223   %}
 2224 
 2225   enc_class load_immL32(rRegL dst, immL32 src)
 2226   %{
 2227     int dstenc = $dst$$reg;
 2228     if (dstenc &lt; 8) {
 2229       emit_opcode(cbuf, Assembler::REX_W);
 2230     } else {
 2231       emit_opcode(cbuf, Assembler::REX_WB);
 2232       dstenc -= 8;
 2233     }
 2234     emit_opcode(cbuf, 0xC7);
 2235     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2236     $$$emit32$src$$constant;
 2237   %}
 2238 
 2239   enc_class load_immP31(rRegP dst, immP32 src)
 2240   %{
 2241     // same as load_immI, but this time we care about zeroes in the high word
 2242     int dstenc = $dst$$reg;
 2243     if (dstenc &gt;= 8) {
 2244       emit_opcode(cbuf, Assembler::REX_B);
 2245       dstenc -= 8;
 2246     }
 2247     emit_opcode(cbuf, 0xB8 | dstenc);
 2248     $$$emit32$src$$constant;
 2249   %}
 2250 
 2251   enc_class load_immP(rRegP dst, immP src)
 2252   %{
 2253     int dstenc = $dst$$reg;
 2254     if (dstenc &lt; 8) {
 2255       emit_opcode(cbuf, Assembler::REX_W);
 2256     } else {
 2257       emit_opcode(cbuf, Assembler::REX_WB);
 2258       dstenc -= 8;
 2259     }
 2260     emit_opcode(cbuf, 0xB8 | dstenc);
 2261     // This next line should be generated from ADLC
 2262     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2263       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2264     } else {
 2265       emit_d64(cbuf, $src$$constant);
 2266     }
 2267   %}
 2268 
 2269   enc_class Con32(immI src)
 2270   %{
 2271     // Output immediate
 2272     $$$emit32$src$$constant;
 2273   %}
 2274 
 2275   enc_class Con32F_as_bits(immF src)
 2276   %{
 2277     // Output Float immediate bits
 2278     jfloat jf = $src$$constant;
 2279     jint jf_as_bits = jint_cast(jf);
 2280     emit_d32(cbuf, jf_as_bits);
 2281   %}
 2282 
 2283   enc_class Con16(immI src)
 2284   %{
 2285     // Output immediate
 2286     $$$emit16$src$$constant;
 2287   %}
 2288 
 2289   // How is this different from Con32??? XXX
 2290   enc_class Con_d32(immI src)
 2291   %{
 2292     emit_d32(cbuf,$src$$constant);
 2293   %}
 2294 
 2295   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2296     // Output immediate memory reference
 2297     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2298     emit_d32(cbuf, 0x00);
 2299   %}
 2300 
 2301   enc_class lock_prefix()
 2302   %{
 2303     emit_opcode(cbuf, 0xF0); // lock
 2304   %}
 2305 
 2306   enc_class REX_mem(memory mem)
 2307   %{
 2308     if ($mem$$base &gt;= 8) {
 2309       if ($mem$$index &lt; 8) {
 2310         emit_opcode(cbuf, Assembler::REX_B);
 2311       } else {
 2312         emit_opcode(cbuf, Assembler::REX_XB);
 2313       }
 2314     } else {
 2315       if ($mem$$index &gt;= 8) {
 2316         emit_opcode(cbuf, Assembler::REX_X);
 2317       }
 2318     }
 2319   %}
 2320 
 2321   enc_class REX_mem_wide(memory mem)
 2322   %{
 2323     if ($mem$$base &gt;= 8) {
 2324       if ($mem$$index &lt; 8) {
 2325         emit_opcode(cbuf, Assembler::REX_WB);
 2326       } else {
 2327         emit_opcode(cbuf, Assembler::REX_WXB);
 2328       }
 2329     } else {
 2330       if ($mem$$index &lt; 8) {
 2331         emit_opcode(cbuf, Assembler::REX_W);
 2332       } else {
 2333         emit_opcode(cbuf, Assembler::REX_WX);
 2334       }
 2335     }
 2336   %}
 2337 
 2338   // for byte regs
 2339   enc_class REX_breg(rRegI reg)
 2340   %{
 2341     if ($reg$$reg &gt;= 4) {
 2342       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2343     }
 2344   %}
 2345 
 2346   // for byte regs
 2347   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2348   %{
 2349     if ($dst$$reg &lt; 8) {
 2350       if ($src$$reg &gt;= 4) {
 2351         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2352       }
 2353     } else {
 2354       if ($src$$reg &lt; 8) {
 2355         emit_opcode(cbuf, Assembler::REX_R);
 2356       } else {
 2357         emit_opcode(cbuf, Assembler::REX_RB);
 2358       }
 2359     }
 2360   %}
 2361 
 2362   // for byte regs
 2363   enc_class REX_breg_mem(rRegI reg, memory mem)
 2364   %{
 2365     if ($reg$$reg &lt; 8) {
 2366       if ($mem$$base &lt; 8) {
 2367         if ($mem$$index &gt;= 8) {
 2368           emit_opcode(cbuf, Assembler::REX_X);
 2369         } else if ($reg$$reg &gt;= 4) {
 2370           emit_opcode(cbuf, Assembler::REX);
 2371         }
 2372       } else {
 2373         if ($mem$$index &lt; 8) {
 2374           emit_opcode(cbuf, Assembler::REX_B);
 2375         } else {
 2376           emit_opcode(cbuf, Assembler::REX_XB);
 2377         }
 2378       }
 2379     } else {
 2380       if ($mem$$base &lt; 8) {
 2381         if ($mem$$index &lt; 8) {
 2382           emit_opcode(cbuf, Assembler::REX_R);
 2383         } else {
 2384           emit_opcode(cbuf, Assembler::REX_RX);
 2385         }
 2386       } else {
 2387         if ($mem$$index &lt; 8) {
 2388           emit_opcode(cbuf, Assembler::REX_RB);
 2389         } else {
 2390           emit_opcode(cbuf, Assembler::REX_RXB);
 2391         }
 2392       }
 2393     }
 2394   %}
 2395 
 2396   enc_class REX_reg(rRegI reg)
 2397   %{
 2398     if ($reg$$reg &gt;= 8) {
 2399       emit_opcode(cbuf, Assembler::REX_B);
 2400     }
 2401   %}
 2402 
 2403   enc_class REX_reg_wide(rRegI reg)
 2404   %{
 2405     if ($reg$$reg &lt; 8) {
 2406       emit_opcode(cbuf, Assembler::REX_W);
 2407     } else {
 2408       emit_opcode(cbuf, Assembler::REX_WB);
 2409     }
 2410   %}
 2411 
 2412   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2413   %{
 2414     if ($dst$$reg &lt; 8) {
 2415       if ($src$$reg &gt;= 8) {
 2416         emit_opcode(cbuf, Assembler::REX_B);
 2417       }
 2418     } else {
 2419       if ($src$$reg &lt; 8) {
 2420         emit_opcode(cbuf, Assembler::REX_R);
 2421       } else {
 2422         emit_opcode(cbuf, Assembler::REX_RB);
 2423       }
 2424     }
 2425   %}
 2426 
 2427   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2428   %{
 2429     if ($dst$$reg &lt; 8) {
 2430       if ($src$$reg &lt; 8) {
 2431         emit_opcode(cbuf, Assembler::REX_W);
 2432       } else {
 2433         emit_opcode(cbuf, Assembler::REX_WB);
 2434       }
 2435     } else {
 2436       if ($src$$reg &lt; 8) {
 2437         emit_opcode(cbuf, Assembler::REX_WR);
 2438       } else {
 2439         emit_opcode(cbuf, Assembler::REX_WRB);
 2440       }
 2441     }
 2442   %}
 2443 
 2444   enc_class REX_reg_mem(rRegI reg, memory mem)
 2445   %{
 2446     if ($reg$$reg &lt; 8) {
 2447       if ($mem$$base &lt; 8) {
 2448         if ($mem$$index &gt;= 8) {
 2449           emit_opcode(cbuf, Assembler::REX_X);
 2450         }
 2451       } else {
 2452         if ($mem$$index &lt; 8) {
 2453           emit_opcode(cbuf, Assembler::REX_B);
 2454         } else {
 2455           emit_opcode(cbuf, Assembler::REX_XB);
 2456         }
 2457       }
 2458     } else {
 2459       if ($mem$$base &lt; 8) {
 2460         if ($mem$$index &lt; 8) {
 2461           emit_opcode(cbuf, Assembler::REX_R);
 2462         } else {
 2463           emit_opcode(cbuf, Assembler::REX_RX);
 2464         }
 2465       } else {
 2466         if ($mem$$index &lt; 8) {
 2467           emit_opcode(cbuf, Assembler::REX_RB);
 2468         } else {
 2469           emit_opcode(cbuf, Assembler::REX_RXB);
 2470         }
 2471       }
 2472     }
 2473   %}
 2474 
 2475   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2476   %{
 2477     if ($reg$$reg &lt; 8) {
 2478       if ($mem$$base &lt; 8) {
 2479         if ($mem$$index &lt; 8) {
 2480           emit_opcode(cbuf, Assembler::REX_W);
 2481         } else {
 2482           emit_opcode(cbuf, Assembler::REX_WX);
 2483         }
 2484       } else {
 2485         if ($mem$$index &lt; 8) {
 2486           emit_opcode(cbuf, Assembler::REX_WB);
 2487         } else {
 2488           emit_opcode(cbuf, Assembler::REX_WXB);
 2489         }
 2490       }
 2491     } else {
 2492       if ($mem$$base &lt; 8) {
 2493         if ($mem$$index &lt; 8) {
 2494           emit_opcode(cbuf, Assembler::REX_WR);
 2495         } else {
 2496           emit_opcode(cbuf, Assembler::REX_WRX);
 2497         }
 2498       } else {
 2499         if ($mem$$index &lt; 8) {
 2500           emit_opcode(cbuf, Assembler::REX_WRB);
 2501         } else {
 2502           emit_opcode(cbuf, Assembler::REX_WRXB);
 2503         }
 2504       }
 2505     }
 2506   %}
 2507 
 2508   enc_class reg_mem(rRegI ereg, memory mem)
 2509   %{
 2510     // High registers handle in encode_RegMem
 2511     int reg = $ereg$$reg;
 2512     int base = $mem$$base;
 2513     int index = $mem$$index;
 2514     int scale = $mem$$scale;
 2515     int disp = $mem$$disp;
 2516     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2517 
 2518     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2519   %}
 2520 
 2521   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2522   %{
 2523     int rm_byte_opcode = $rm_opcode$$constant;
 2524 
 2525     // High registers handle in encode_RegMem
 2526     int base = $mem$$base;
 2527     int index = $mem$$index;
 2528     int scale = $mem$$scale;
 2529     int displace = $mem$$disp;
 2530 
 2531     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2532                                             // working with static
 2533                                             // globals
 2534     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2535                   disp_reloc);
 2536   %}
 2537 
 2538   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2539   %{
 2540     int reg_encoding = $dst$$reg;
 2541     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2542     int index        = 0x04;            // 0x04 indicates no index
 2543     int scale        = 0x00;            // 0x00 indicates no scale
 2544     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2545     relocInfo::relocType disp_reloc = relocInfo::none;
 2546     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2547                   disp_reloc);
 2548   %}
 2549 
 2550   enc_class neg_reg(rRegI dst)
 2551   %{
 2552     int dstenc = $dst$$reg;
 2553     if (dstenc &gt;= 8) {
 2554       emit_opcode(cbuf, Assembler::REX_B);
 2555       dstenc -= 8;
 2556     }
 2557     // NEG $dst
 2558     emit_opcode(cbuf, 0xF7);
 2559     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2560   %}
 2561 
 2562   enc_class neg_reg_wide(rRegI dst)
 2563   %{
 2564     int dstenc = $dst$$reg;
 2565     if (dstenc &lt; 8) {
 2566       emit_opcode(cbuf, Assembler::REX_W);
 2567     } else {
 2568       emit_opcode(cbuf, Assembler::REX_WB);
 2569       dstenc -= 8;
 2570     }
 2571     // NEG $dst
 2572     emit_opcode(cbuf, 0xF7);
 2573     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2574   %}
 2575 
 2576   enc_class setLT_reg(rRegI dst)
 2577   %{
 2578     int dstenc = $dst$$reg;
 2579     if (dstenc &gt;= 8) {
 2580       emit_opcode(cbuf, Assembler::REX_B);
 2581       dstenc -= 8;
 2582     } else if (dstenc &gt;= 4) {
 2583       emit_opcode(cbuf, Assembler::REX);
 2584     }
 2585     // SETLT $dst
 2586     emit_opcode(cbuf, 0x0F);
 2587     emit_opcode(cbuf, 0x9C);
 2588     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2589   %}
 2590 
 2591   enc_class setNZ_reg(rRegI dst)
 2592   %{
 2593     int dstenc = $dst$$reg;
 2594     if (dstenc &gt;= 8) {
 2595       emit_opcode(cbuf, Assembler::REX_B);
 2596       dstenc -= 8;
 2597     } else if (dstenc &gt;= 4) {
 2598       emit_opcode(cbuf, Assembler::REX);
 2599     }
 2600     // SETNZ $dst
 2601     emit_opcode(cbuf, 0x0F);
 2602     emit_opcode(cbuf, 0x95);
 2603     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2604   %}
 2605 
 2606 
 2607   // Compare the lonogs and set -1, 0, or 1 into dst
 2608   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2609   %{
 2610     int src1enc = $src1$$reg;
 2611     int src2enc = $src2$$reg;
 2612     int dstenc = $dst$$reg;
 2613 
 2614     // cmpq $src1, $src2
 2615     if (src1enc &lt; 8) {
 2616       if (src2enc &lt; 8) {
 2617         emit_opcode(cbuf, Assembler::REX_W);
 2618       } else {
 2619         emit_opcode(cbuf, Assembler::REX_WB);
 2620       }
 2621     } else {
 2622       if (src2enc &lt; 8) {
 2623         emit_opcode(cbuf, Assembler::REX_WR);
 2624       } else {
 2625         emit_opcode(cbuf, Assembler::REX_WRB);
 2626       }
 2627     }
 2628     emit_opcode(cbuf, 0x3B);
 2629     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2630 
 2631     // movl $dst, -1
 2632     if (dstenc &gt;= 8) {
 2633       emit_opcode(cbuf, Assembler::REX_B);
 2634     }
 2635     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2636     emit_d32(cbuf, -1);
 2637 
 2638     // jl,s done
 2639     emit_opcode(cbuf, 0x7C);
 2640     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2641 
 2642     // setne $dst
 2643     if (dstenc &gt;= 4) {
 2644       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2645     }
 2646     emit_opcode(cbuf, 0x0F);
 2647     emit_opcode(cbuf, 0x95);
 2648     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2649 
 2650     // movzbl $dst, $dst
 2651     if (dstenc &gt;= 4) {
 2652       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2653     }
 2654     emit_opcode(cbuf, 0x0F);
 2655     emit_opcode(cbuf, 0xB6);
 2656     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2657   %}
 2658 
 2659   enc_class Push_ResultXD(regD dst) %{
 2660     MacroAssembler _masm(&amp;cbuf);
 2661     __ fstp_d(Address(rsp, 0));
 2662     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2663     __ addptr(rsp, 8);
 2664   %}
 2665 
 2666   enc_class Push_SrcXD(regD src) %{
 2667     MacroAssembler _masm(&amp;cbuf);
 2668     __ subptr(rsp, 8);
 2669     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2670     __ fld_d(Address(rsp, 0));
 2671   %}
 2672 
 2673 
 2674   enc_class enc_rethrow()
 2675   %{
 2676     cbuf.set_insts_mark();
 2677     emit_opcode(cbuf, 0xE9); // jmp entry
 2678     emit_d32_reloc(cbuf,
 2679                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2680                    runtime_call_Relocation::spec(),
 2681                    RELOC_DISP32);
 2682   %}
 2683 
 2684 %}
 2685 
 2686 
 2687 
 2688 //----------FRAME--------------------------------------------------------------
 2689 // Definition of frame structure and management information.
 2690 //
 2691 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2692 //                             |   (to get allocators register number
 2693 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2694 //  r   CALLER     |        |
 2695 //  o     |        +--------+      pad to even-align allocators stack-slot
 2696 //  w     V        |  pad0  |        numbers; owned by CALLER
 2697 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2698 //  h     ^        |   in   |  5
 2699 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2700 //  |     |        |        |  3
 2701 //  |     |        +--------+
 2702 //  V     |        | old out|      Empty on Intel, window on Sparc
 2703 //        |    old |preserve|      Must be even aligned.
 2704 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2705 //        |        |   in   |  3   area for Intel ret address
 2706 //     Owned by    |preserve|      Empty on Sparc.
 2707 //       SELF      +--------+
 2708 //        |        |  pad2  |  2   pad to align old SP
 2709 //        |        +--------+  1
 2710 //        |        | locks  |  0
 2711 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2712 //        |        |  pad1  | 11   pad to align new SP
 2713 //        |        +--------+
 2714 //        |        |        | 10
 2715 //        |        | spills |  9   spills
 2716 //        V        |        |  8   (pad0 slot for callee)
 2717 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2718 //        ^        |  out   |  7
 2719 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2720 //     Owned by    +--------+
 2721 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2722 //        |    new |preserve|      Must be even-aligned.
 2723 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2724 //        |        |        |
 2725 //
 2726 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2727 //         known from SELF&#39;s arguments and the Java calling convention.
 2728 //         Region 6-7 is determined per call site.
 2729 // Note 2: If the calling convention leaves holes in the incoming argument
 2730 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2731 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2732 //         incoming area, as the Java calling convention is completely under
 2733 //         the control of the AD file.  Doubles can be sorted and packed to
 2734 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2735 //         varargs C calling conventions.
 2736 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2737 //         even aligned with pad0 as needed.
 2738 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2739 //         region 6-11 is even aligned; it may be padded out more so that
 2740 //         the region from SP to FP meets the minimum stack alignment.
 2741 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2742 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2743 //         SP meets the minimum alignment.
 2744 
 2745 frame
 2746 %{
 2747   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2748   stack_direction(TOWARDS_LOW);
 2749 
 2750   // These three registers define part of the calling convention
 2751   // between compiled code and the interpreter.
 2752   inline_cache_reg(RAX);                // Inline Cache Register
 2753   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2754                                         // calling interpreter
 2755 
 2756   // Optional: name the operand used by cisc-spilling to access
 2757   // [stack_pointer + offset]
 2758   cisc_spilling_operand_name(indOffset32);
 2759 
 2760   // Number of stack slots consumed by locking an object
 2761   sync_stack_slots(2);
 2762 
 2763   // Compiled code&#39;s Frame Pointer
 2764   frame_pointer(RSP);
 2765 
 2766   // Interpreter stores its frame pointer in a register which is
 2767   // stored to the stack by I2CAdaptors.
 2768   // I2CAdaptors convert from interpreted java to compiled java.
 2769   interpreter_frame_pointer(RBP);
 2770 
 2771   // Stack alignment requirement
 2772   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2773 
 2774   // Number of stack slots between incoming argument block and the start of
 2775   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2776   // EPILOG must remove this many slots.  amd64 needs two slots for
 2777   // return address.
 2778   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2779 
 2780   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2781   // for calls to C.  Supports the var-args backing area for register parms.
 2782   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2783 
 2784   // The after-PROLOG location of the return address.  Location of
 2785   // return address specifies a type (REG or STACK) and a number
 2786   // representing the register number (i.e. - use a register name) or
 2787   // stack slot.
 2788   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2789   // Otherwise, it is above the locks and verification slot and alignment word
 2790   return_addr(STACK - 2 +
 2791               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2792                         Compile::current()-&gt;fixed_slots()),
 2793                        stack_alignment_in_slots()));
 2794 
 2795   // Body of function which returns an integer array locating
 2796   // arguments either in registers or in stack slots.  Passed an array
 2797   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2798   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2799   // arguments for a CALLEE.  Incoming stack arguments are
 2800   // automatically biased by the preserve_stack_slots field above.
 2801 
 2802   calling_convention
 2803   %{
 2804     // No difference between ingoing/outgoing just pass false
 2805     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2806   %}
 2807 
 2808   c_calling_convention
 2809   %{
 2810     // This is obviously always outgoing
 2811     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2812   %}
 2813 
 2814   // Location of compiled Java return values.  Same as C for now.
 2815   return_value
 2816   %{
 2817     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2818            &quot;only return normal values&quot;);
 2819 
 2820     static const int lo[Op_RegL + 1] = {
 2821       0,
 2822       0,
 2823       RAX_num,  // Op_RegN
 2824       RAX_num,  // Op_RegI
 2825       RAX_num,  // Op_RegP
 2826       XMM0_num, // Op_RegF
 2827       XMM0_num, // Op_RegD
 2828       RAX_num   // Op_RegL
 2829     };
 2830     static const int hi[Op_RegL + 1] = {
 2831       0,
 2832       0,
 2833       OptoReg::Bad, // Op_RegN
 2834       OptoReg::Bad, // Op_RegI
 2835       RAX_H_num,    // Op_RegP
 2836       OptoReg::Bad, // Op_RegF
 2837       XMM0b_num,    // Op_RegD
 2838       RAX_H_num     // Op_RegL
 2839     };
 2840     // Excluded flags and vector registers.
 2841     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2842     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2843   %}
 2844 %}
 2845 
 2846 //----------ATTRIBUTES---------------------------------------------------------
 2847 //----------Operand Attributes-------------------------------------------------
 2848 op_attrib op_cost(0);        // Required cost attribute
 2849 
 2850 //----------Instruction Attributes---------------------------------------------
 2851 ins_attrib ins_cost(100);       // Required cost attribute
 2852 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2853 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2854                                 // a non-matching short branch variant
 2855                                 // of some long branch?
 2856 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2857                                 // be a power of 2) specifies the
 2858                                 // alignment that some part of the
 2859                                 // instruction (not necessarily the
 2860                                 // start) requires.  If &gt; 1, a
 2861                                 // compute_padding() function must be
 2862                                 // provided for the instruction
 2863 
 2864 //----------OPERANDS-----------------------------------------------------------
 2865 // Operand definitions must precede instruction definitions for correct parsing
 2866 // in the ADLC because operands constitute user defined types which are used in
 2867 // instruction definitions.
 2868 
 2869 //----------Simple Operands----------------------------------------------------
 2870 // Immediate Operands
 2871 // Integer Immediate
 2872 operand immI()
 2873 %{
 2874   match(ConI);
 2875 
 2876   op_cost(10);
 2877   format %{ %}
 2878   interface(CONST_INTER);
 2879 %}
 2880 
 2881 // Constant for test vs zero
 2882 operand immI0()
 2883 %{
 2884   predicate(n-&gt;get_int() == 0);
 2885   match(ConI);
 2886 
 2887   op_cost(0);
 2888   format %{ %}
 2889   interface(CONST_INTER);
 2890 %}
 2891 
 2892 // Constant for increment
 2893 operand immI1()
 2894 %{
 2895   predicate(n-&gt;get_int() == 1);
 2896   match(ConI);
 2897 
 2898   op_cost(0);
 2899   format %{ %}
 2900   interface(CONST_INTER);
 2901 %}
 2902 
 2903 // Constant for decrement
 2904 operand immI_M1()
 2905 %{
 2906   predicate(n-&gt;get_int() == -1);
 2907   match(ConI);
 2908 
 2909   op_cost(0);
 2910   format %{ %}
 2911   interface(CONST_INTER);
 2912 %}
 2913 
 2914 // Valid scale values for addressing modes
 2915 operand immI2()
 2916 %{
 2917   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2918   match(ConI);
 2919 
 2920   format %{ %}
 2921   interface(CONST_INTER);
 2922 %}
 2923 
 2924 operand immI8()
 2925 %{
 2926   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2927   match(ConI);
 2928 
 2929   op_cost(5);
 2930   format %{ %}
 2931   interface(CONST_INTER);
 2932 %}
 2933 
 2934 operand immU8()
 2935 %{
 2936   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2937   match(ConI);
 2938 
 2939   op_cost(5);
 2940   format %{ %}
 2941   interface(CONST_INTER);
 2942 %}
 2943 
 2944 operand immI16()
 2945 %{
 2946   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2947   match(ConI);
 2948 
 2949   op_cost(10);
 2950   format %{ %}
 2951   interface(CONST_INTER);
 2952 %}
 2953 
 2954 // Int Immediate non-negative
 2955 operand immU31()
 2956 %{
 2957   predicate(n-&gt;get_int() &gt;= 0);
 2958   match(ConI);
 2959 
 2960   op_cost(0);
 2961   format %{ %}
 2962   interface(CONST_INTER);
 2963 %}
 2964 
 2965 // Constant for long shifts
 2966 operand immI_32()
 2967 %{
 2968   predicate( n-&gt;get_int() == 32 );
 2969   match(ConI);
 2970 
 2971   op_cost(0);
 2972   format %{ %}
 2973   interface(CONST_INTER);
 2974 %}
 2975 
 2976 // Constant for long shifts
 2977 operand immI_64()
 2978 %{
 2979   predicate( n-&gt;get_int() == 64 );
 2980   match(ConI);
 2981 
 2982   op_cost(0);
 2983   format %{ %}
 2984   interface(CONST_INTER);
 2985 %}
 2986 
 2987 // Pointer Immediate
 2988 operand immP()
 2989 %{
 2990   match(ConP);
 2991 
 2992   op_cost(10);
 2993   format %{ %}
 2994   interface(CONST_INTER);
 2995 %}
 2996 
 2997 // NULL Pointer Immediate
 2998 operand immP0()
 2999 %{
 3000   predicate(n-&gt;get_ptr() == 0);
 3001   match(ConP);
 3002 
 3003   op_cost(5);
 3004   format %{ %}
 3005   interface(CONST_INTER);
 3006 %}
 3007 
 3008 // Pointer Immediate
 3009 operand immN() %{
 3010   match(ConN);
 3011 
 3012   op_cost(10);
 3013   format %{ %}
 3014   interface(CONST_INTER);
 3015 %}
 3016 
 3017 operand immNKlass() %{
 3018   match(ConNKlass);
 3019 
 3020   op_cost(10);
 3021   format %{ %}
 3022   interface(CONST_INTER);
 3023 %}
 3024 
 3025 // NULL Pointer Immediate
 3026 operand immN0() %{
 3027   predicate(n-&gt;get_narrowcon() == 0);
 3028   match(ConN);
 3029 
 3030   op_cost(5);
 3031   format %{ %}
 3032   interface(CONST_INTER);
 3033 %}
 3034 
 3035 operand immP31()
 3036 %{
 3037   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3038             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3039   match(ConP);
 3040 
 3041   op_cost(5);
 3042   format %{ %}
 3043   interface(CONST_INTER);
 3044 %}
 3045 
 3046 
 3047 // Long Immediate
 3048 operand immL()
 3049 %{
 3050   match(ConL);
 3051 
 3052   op_cost(20);
 3053   format %{ %}
 3054   interface(CONST_INTER);
 3055 %}
 3056 
 3057 // Long Immediate 8-bit
 3058 operand immL8()
 3059 %{
 3060   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3061   match(ConL);
 3062 
 3063   op_cost(5);
 3064   format %{ %}
 3065   interface(CONST_INTER);
 3066 %}
 3067 
 3068 // Long Immediate 32-bit unsigned
 3069 operand immUL32()
 3070 %{
 3071   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3072   match(ConL);
 3073 
 3074   op_cost(10);
 3075   format %{ %}
 3076   interface(CONST_INTER);
 3077 %}
 3078 
 3079 // Long Immediate 32-bit signed
 3080 operand immL32()
 3081 %{
 3082   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3083   match(ConL);
 3084 
 3085   op_cost(15);
 3086   format %{ %}
 3087   interface(CONST_INTER);
 3088 %}
 3089 
 3090 operand immL_Pow2()
 3091 %{
 3092   predicate(is_power_of_2((julong)n-&gt;get_long()));
 3093   match(ConL);
 3094 
 3095   op_cost(15);
 3096   format %{ %}
 3097   interface(CONST_INTER);
 3098 %}
 3099 
 3100 operand immL_NotPow2()
 3101 %{
 3102   predicate(is_power_of_2((julong)~n-&gt;get_long()));
 3103   match(ConL);
 3104 
 3105   op_cost(15);
 3106   format %{ %}
 3107   interface(CONST_INTER);
 3108 %}
 3109 
 3110 // Long Immediate zero
 3111 operand immL0()
 3112 %{
 3113   predicate(n-&gt;get_long() == 0L);
 3114   match(ConL);
 3115 
 3116   op_cost(10);
 3117   format %{ %}
 3118   interface(CONST_INTER);
 3119 %}
 3120 
 3121 // Constant for increment
 3122 operand immL1()
 3123 %{
 3124   predicate(n-&gt;get_long() == 1);
 3125   match(ConL);
 3126 
 3127   format %{ %}
 3128   interface(CONST_INTER);
 3129 %}
 3130 
 3131 // Constant for decrement
 3132 operand immL_M1()
 3133 %{
 3134   predicate(n-&gt;get_long() == -1);
 3135   match(ConL);
 3136 
 3137   format %{ %}
 3138   interface(CONST_INTER);
 3139 %}
 3140 
 3141 // Long Immediate: the value 10
 3142 operand immL10()
 3143 %{
 3144   predicate(n-&gt;get_long() == 10);
 3145   match(ConL);
 3146 
 3147   format %{ %}
 3148   interface(CONST_INTER);
 3149 %}
 3150 
 3151 // Long immediate from 0 to 127.
 3152 // Used for a shorter form of long mul by 10.
 3153 operand immL_127()
 3154 %{
 3155   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3156   match(ConL);
 3157 
 3158   op_cost(10);
 3159   format %{ %}
 3160   interface(CONST_INTER);
 3161 %}
 3162 
 3163 // Long Immediate: low 32-bit mask
 3164 operand immL_32bits()
 3165 %{
 3166   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3167   match(ConL);
 3168   op_cost(20);
 3169 
 3170   format %{ %}
 3171   interface(CONST_INTER);
 3172 %}
 3173 
 3174 // Float Immediate zero
 3175 operand immF0()
 3176 %{
 3177   predicate(jint_cast(n-&gt;getf()) == 0);
 3178   match(ConF);
 3179 
 3180   op_cost(5);
 3181   format %{ %}
 3182   interface(CONST_INTER);
 3183 %}
 3184 
 3185 // Float Immediate
 3186 operand immF()
 3187 %{
 3188   match(ConF);
 3189 
 3190   op_cost(15);
 3191   format %{ %}
 3192   interface(CONST_INTER);
 3193 %}
 3194 
 3195 // Double Immediate zero
 3196 operand immD0()
 3197 %{
 3198   predicate(jlong_cast(n-&gt;getd()) == 0);
 3199   match(ConD);
 3200 
 3201   op_cost(5);
 3202   format %{ %}
 3203   interface(CONST_INTER);
 3204 %}
 3205 
 3206 // Double Immediate
 3207 operand immD()
 3208 %{
 3209   match(ConD);
 3210 
 3211   op_cost(15);
 3212   format %{ %}
 3213   interface(CONST_INTER);
 3214 %}
 3215 
 3216 // Immediates for special shifts (sign extend)
 3217 
 3218 // Constants for increment
 3219 operand immI_16()
 3220 %{
 3221   predicate(n-&gt;get_int() == 16);
 3222   match(ConI);
 3223 
 3224   format %{ %}
 3225   interface(CONST_INTER);
 3226 %}
 3227 
 3228 operand immI_24()
 3229 %{
 3230   predicate(n-&gt;get_int() == 24);
 3231   match(ConI);
 3232 
 3233   format %{ %}
 3234   interface(CONST_INTER);
 3235 %}
 3236 
 3237 // Constant for byte-wide masking
 3238 operand immI_255()
 3239 %{
 3240   predicate(n-&gt;get_int() == 255);
 3241   match(ConI);
 3242 
 3243   format %{ %}
 3244   interface(CONST_INTER);
 3245 %}
 3246 
 3247 // Constant for short-wide masking
 3248 operand immI_65535()
 3249 %{
 3250   predicate(n-&gt;get_int() == 65535);
 3251   match(ConI);
 3252 
 3253   format %{ %}
 3254   interface(CONST_INTER);
 3255 %}
 3256 
 3257 // Constant for byte-wide masking
 3258 operand immL_255()
 3259 %{
 3260   predicate(n-&gt;get_long() == 255);
 3261   match(ConL);
 3262 
 3263   format %{ %}
 3264   interface(CONST_INTER);
 3265 %}
 3266 
 3267 // Constant for short-wide masking
 3268 operand immL_65535()
 3269 %{
 3270   predicate(n-&gt;get_long() == 65535);
 3271   match(ConL);
 3272 
 3273   format %{ %}
 3274   interface(CONST_INTER);
 3275 %}
 3276 
 3277 // Register Operands
 3278 // Integer Register
 3279 operand rRegI()
 3280 %{
 3281   constraint(ALLOC_IN_RC(int_reg));
 3282   match(RegI);
 3283 
 3284   match(rax_RegI);
 3285   match(rbx_RegI);
 3286   match(rcx_RegI);
 3287   match(rdx_RegI);
 3288   match(rdi_RegI);
 3289 
 3290   format %{ %}
 3291   interface(REG_INTER);
 3292 %}
 3293 
 3294 // Special Registers
 3295 operand rax_RegI()
 3296 %{
 3297   constraint(ALLOC_IN_RC(int_rax_reg));
 3298   match(RegI);
 3299   match(rRegI);
 3300 
 3301   format %{ &quot;RAX&quot; %}
 3302   interface(REG_INTER);
 3303 %}
 3304 
 3305 // Special Registers
 3306 operand rbx_RegI()
 3307 %{
 3308   constraint(ALLOC_IN_RC(int_rbx_reg));
 3309   match(RegI);
 3310   match(rRegI);
 3311 
 3312   format %{ &quot;RBX&quot; %}
 3313   interface(REG_INTER);
 3314 %}
 3315 
 3316 operand rcx_RegI()
 3317 %{
 3318   constraint(ALLOC_IN_RC(int_rcx_reg));
 3319   match(RegI);
 3320   match(rRegI);
 3321 
 3322   format %{ &quot;RCX&quot; %}
 3323   interface(REG_INTER);
 3324 %}
 3325 
 3326 operand rdx_RegI()
 3327 %{
 3328   constraint(ALLOC_IN_RC(int_rdx_reg));
 3329   match(RegI);
 3330   match(rRegI);
 3331 
 3332   format %{ &quot;RDX&quot; %}
 3333   interface(REG_INTER);
 3334 %}
 3335 
 3336 operand rdi_RegI()
 3337 %{
 3338   constraint(ALLOC_IN_RC(int_rdi_reg));
 3339   match(RegI);
 3340   match(rRegI);
 3341 
 3342   format %{ &quot;RDI&quot; %}
 3343   interface(REG_INTER);
 3344 %}
 3345 
 3346 operand no_rcx_RegI()
 3347 %{
 3348   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3349   match(RegI);
 3350   match(rax_RegI);
 3351   match(rbx_RegI);
 3352   match(rdx_RegI);
 3353   match(rdi_RegI);
 3354 
 3355   format %{ %}
 3356   interface(REG_INTER);
 3357 %}
 3358 
 3359 operand no_rax_rdx_RegI()
 3360 %{
 3361   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3362   match(RegI);
 3363   match(rbx_RegI);
 3364   match(rcx_RegI);
 3365   match(rdi_RegI);
 3366 
 3367   format %{ %}
 3368   interface(REG_INTER);
 3369 %}
 3370 
 3371 // Pointer Register
 3372 operand any_RegP()
 3373 %{
 3374   constraint(ALLOC_IN_RC(any_reg));
 3375   match(RegP);
 3376   match(rax_RegP);
 3377   match(rbx_RegP);
 3378   match(rdi_RegP);
 3379   match(rsi_RegP);
 3380   match(rbp_RegP);
 3381   match(r15_RegP);
 3382   match(rRegP);
 3383 
 3384   format %{ %}
 3385   interface(REG_INTER);
 3386 %}
 3387 
 3388 operand rRegP()
 3389 %{
 3390   constraint(ALLOC_IN_RC(ptr_reg));
 3391   match(RegP);
 3392   match(rax_RegP);
 3393   match(rbx_RegP);
 3394   match(rdi_RegP);
 3395   match(rsi_RegP);
 3396   match(rbp_RegP);  // See Q&amp;A below about
 3397   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3398 
 3399   format %{ %}
 3400   interface(REG_INTER);
 3401 %}
 3402 
 3403 operand rRegN() %{
 3404   constraint(ALLOC_IN_RC(int_reg));
 3405   match(RegN);
 3406 
 3407   format %{ %}
 3408   interface(REG_INTER);
 3409 %}
 3410 
 3411 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3412 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3413 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3414 // The output of an instruction is controlled by the allocator, which respects
 3415 // register class masks, not match rules.  Unless an instruction mentions
 3416 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3417 // by the allocator as an input.
 3418 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3419 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3420 // result, RBP is not included in the output of the instruction either.
 3421 
 3422 operand no_rax_RegP()
 3423 %{
 3424   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3425   match(RegP);
 3426   match(rbx_RegP);
 3427   match(rsi_RegP);
 3428   match(rdi_RegP);
 3429 
 3430   format %{ %}
 3431   interface(REG_INTER);
 3432 %}
 3433 
 3434 // This operand is not allowed to use RBP even if
 3435 // RBP is not used to hold the frame pointer.
 3436 operand no_rbp_RegP()
 3437 %{
 3438   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3439   match(RegP);
 3440   match(rbx_RegP);
 3441   match(rsi_RegP);
 3442   match(rdi_RegP);
 3443 
 3444   format %{ %}
 3445   interface(REG_INTER);
 3446 %}
 3447 
 3448 operand no_rax_rbx_RegP()
 3449 %{
 3450   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3451   match(RegP);
 3452   match(rsi_RegP);
 3453   match(rdi_RegP);
 3454 
 3455   format %{ %}
 3456   interface(REG_INTER);
 3457 %}
 3458 
 3459 // Special Registers
 3460 // Return a pointer value
 3461 operand rax_RegP()
 3462 %{
 3463   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3464   match(RegP);
 3465   match(rRegP);
 3466 
 3467   format %{ %}
 3468   interface(REG_INTER);
 3469 %}
 3470 
 3471 // Special Registers
 3472 // Return a compressed pointer value
 3473 operand rax_RegN()
 3474 %{
 3475   constraint(ALLOC_IN_RC(int_rax_reg));
 3476   match(RegN);
 3477   match(rRegN);
 3478 
 3479   format %{ %}
 3480   interface(REG_INTER);
 3481 %}
 3482 
 3483 // Used in AtomicAdd
 3484 operand rbx_RegP()
 3485 %{
 3486   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3487   match(RegP);
 3488   match(rRegP);
 3489 
 3490   format %{ %}
 3491   interface(REG_INTER);
 3492 %}
 3493 
 3494 operand rsi_RegP()
 3495 %{
 3496   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3497   match(RegP);
 3498   match(rRegP);
 3499 
 3500   format %{ %}
 3501   interface(REG_INTER);
 3502 %}
 3503 
 3504 operand rbp_RegP()
 3505 %{
 3506   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3507   match(RegP);
 3508   match(rRegP);
 3509 
 3510   format %{ %}
 3511   interface(REG_INTER);
 3512 %}
 3513 
 3514 // Used in rep stosq
 3515 operand rdi_RegP()
 3516 %{
 3517   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3518   match(RegP);
 3519   match(rRegP);
 3520 
 3521   format %{ %}
 3522   interface(REG_INTER);
 3523 %}
 3524 
 3525 operand r15_RegP()
 3526 %{
 3527   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3528   match(RegP);
 3529   match(rRegP);
 3530 
 3531   format %{ %}
 3532   interface(REG_INTER);
 3533 %}
 3534 
 3535 operand rRegL()
 3536 %{
 3537   constraint(ALLOC_IN_RC(long_reg));
 3538   match(RegL);
 3539   match(rax_RegL);
 3540   match(rdx_RegL);
 3541 
 3542   format %{ %}
 3543   interface(REG_INTER);
 3544 %}
 3545 
 3546 // Special Registers
 3547 operand no_rax_rdx_RegL()
 3548 %{
 3549   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3550   match(RegL);
 3551   match(rRegL);
 3552 
 3553   format %{ %}
 3554   interface(REG_INTER);
 3555 %}
 3556 
 3557 operand no_rax_RegL()
 3558 %{
 3559   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3560   match(RegL);
 3561   match(rRegL);
 3562   match(rdx_RegL);
 3563 
 3564   format %{ %}
 3565   interface(REG_INTER);
 3566 %}
 3567 
 3568 operand no_rcx_RegL()
 3569 %{
 3570   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3571   match(RegL);
 3572   match(rRegL);
 3573 
 3574   format %{ %}
 3575   interface(REG_INTER);
 3576 %}
 3577 
 3578 operand rax_RegL()
 3579 %{
 3580   constraint(ALLOC_IN_RC(long_rax_reg));
 3581   match(RegL);
 3582   match(rRegL);
 3583 
 3584   format %{ &quot;RAX&quot; %}
 3585   interface(REG_INTER);
 3586 %}
 3587 
 3588 operand rcx_RegL()
 3589 %{
 3590   constraint(ALLOC_IN_RC(long_rcx_reg));
 3591   match(RegL);
 3592   match(rRegL);
 3593 
 3594   format %{ %}
 3595   interface(REG_INTER);
 3596 %}
 3597 
 3598 operand rdx_RegL()
 3599 %{
 3600   constraint(ALLOC_IN_RC(long_rdx_reg));
 3601   match(RegL);
 3602   match(rRegL);
 3603 
 3604   format %{ %}
 3605   interface(REG_INTER);
 3606 %}
 3607 
 3608 // Flags register, used as output of compare instructions
 3609 operand rFlagsReg()
 3610 %{
 3611   constraint(ALLOC_IN_RC(int_flags));
 3612   match(RegFlags);
 3613 
 3614   format %{ &quot;RFLAGS&quot; %}
 3615   interface(REG_INTER);
 3616 %}
 3617 
 3618 // Flags register, used as output of FLOATING POINT compare instructions
 3619 operand rFlagsRegU()
 3620 %{
 3621   constraint(ALLOC_IN_RC(int_flags));
 3622   match(RegFlags);
 3623 
 3624   format %{ &quot;RFLAGS_U&quot; %}
 3625   interface(REG_INTER);
 3626 %}
 3627 
 3628 operand rFlagsRegUCF() %{
 3629   constraint(ALLOC_IN_RC(int_flags));
 3630   match(RegFlags);
 3631   predicate(false);
 3632 
 3633   format %{ &quot;RFLAGS_U_CF&quot; %}
 3634   interface(REG_INTER);
 3635 %}
 3636 
 3637 // Float register operands
 3638 operand regF() %{
 3639    constraint(ALLOC_IN_RC(float_reg));
 3640    match(RegF);
 3641 
 3642    format %{ %}
 3643    interface(REG_INTER);
 3644 %}
 3645 
 3646 // Float register operands
 3647 operand legRegF() %{
 3648    constraint(ALLOC_IN_RC(float_reg_legacy));
 3649    match(RegF);
 3650 
 3651    format %{ %}
 3652    interface(REG_INTER);
 3653 %}
 3654 
 3655 // Float register operands
 3656 operand vlRegF() %{
 3657    constraint(ALLOC_IN_RC(float_reg_vl));
 3658    match(RegF);
 3659 
 3660    format %{ %}
 3661    interface(REG_INTER);
 3662 %}
 3663 
 3664 // Double register operands
 3665 operand regD() %{
 3666    constraint(ALLOC_IN_RC(double_reg));
 3667    match(RegD);
 3668 
 3669    format %{ %}
 3670    interface(REG_INTER);
 3671 %}
 3672 
 3673 // Double register operands
 3674 operand legRegD() %{
 3675    constraint(ALLOC_IN_RC(double_reg_legacy));
 3676    match(RegD);
 3677 
 3678    format %{ %}
 3679    interface(REG_INTER);
 3680 %}
 3681 
 3682 // Double register operands
 3683 operand vlRegD() %{
 3684    constraint(ALLOC_IN_RC(double_reg_vl));
 3685    match(RegD);
 3686 
 3687    format %{ %}
 3688    interface(REG_INTER);
 3689 %}
 3690 
 3691 //----------Memory Operands----------------------------------------------------
 3692 // Direct Memory Operand
 3693 // operand direct(immP addr)
 3694 // %{
 3695 //   match(addr);
 3696 
 3697 //   format %{ &quot;[$addr]&quot; %}
 3698 //   interface(MEMORY_INTER) %{
 3699 //     base(0xFFFFFFFF);
 3700 //     index(0x4);
 3701 //     scale(0x0);
 3702 //     disp($addr);
 3703 //   %}
 3704 // %}
 3705 
 3706 // Indirect Memory Operand
 3707 operand indirect(any_RegP reg)
 3708 %{
 3709   constraint(ALLOC_IN_RC(ptr_reg));
 3710   match(reg);
 3711 
 3712   format %{ &quot;[$reg]&quot; %}
 3713   interface(MEMORY_INTER) %{
 3714     base($reg);
 3715     index(0x4);
 3716     scale(0x0);
 3717     disp(0x0);
 3718   %}
 3719 %}
 3720 
 3721 // Indirect Memory Plus Short Offset Operand
 3722 operand indOffset8(any_RegP reg, immL8 off)
 3723 %{
 3724   constraint(ALLOC_IN_RC(ptr_reg));
 3725   match(AddP reg off);
 3726 
 3727   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3728   interface(MEMORY_INTER) %{
 3729     base($reg);
 3730     index(0x4);
 3731     scale(0x0);
 3732     disp($off);
 3733   %}
 3734 %}
 3735 
 3736 // Indirect Memory Plus Long Offset Operand
 3737 operand indOffset32(any_RegP reg, immL32 off)
 3738 %{
 3739   constraint(ALLOC_IN_RC(ptr_reg));
 3740   match(AddP reg off);
 3741 
 3742   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3743   interface(MEMORY_INTER) %{
 3744     base($reg);
 3745     index(0x4);
 3746     scale(0x0);
 3747     disp($off);
 3748   %}
 3749 %}
 3750 
 3751 // Indirect Memory Plus Index Register Plus Offset Operand
 3752 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3753 %{
 3754   constraint(ALLOC_IN_RC(ptr_reg));
 3755   match(AddP (AddP reg lreg) off);
 3756 
 3757   op_cost(10);
 3758   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3759   interface(MEMORY_INTER) %{
 3760     base($reg);
 3761     index($lreg);
 3762     scale(0x0);
 3763     disp($off);
 3764   %}
 3765 %}
 3766 
 3767 // Indirect Memory Plus Index Register Plus Offset Operand
 3768 operand indIndex(any_RegP reg, rRegL lreg)
 3769 %{
 3770   constraint(ALLOC_IN_RC(ptr_reg));
 3771   match(AddP reg lreg);
 3772 
 3773   op_cost(10);
 3774   format %{&quot;[$reg + $lreg]&quot; %}
 3775   interface(MEMORY_INTER) %{
 3776     base($reg);
 3777     index($lreg);
 3778     scale(0x0);
 3779     disp(0x0);
 3780   %}
 3781 %}
 3782 
 3783 // Indirect Memory Times Scale Plus Index Register
 3784 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3785 %{
 3786   constraint(ALLOC_IN_RC(ptr_reg));
 3787   match(AddP reg (LShiftL lreg scale));
 3788 
 3789   op_cost(10);
 3790   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3791   interface(MEMORY_INTER) %{
 3792     base($reg);
 3793     index($lreg);
 3794     scale($scale);
 3795     disp(0x0);
 3796   %}
 3797 %}
 3798 
 3799 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3800 %{
 3801   constraint(ALLOC_IN_RC(ptr_reg));
 3802   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3803   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3804 
 3805   op_cost(10);
 3806   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3807   interface(MEMORY_INTER) %{
 3808     base($reg);
 3809     index($idx);
 3810     scale($scale);
 3811     disp(0x0);
 3812   %}
 3813 %}
 3814 
 3815 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3816 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3817 %{
 3818   constraint(ALLOC_IN_RC(ptr_reg));
 3819   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3820 
 3821   op_cost(10);
 3822   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3823   interface(MEMORY_INTER) %{
 3824     base($reg);
 3825     index($lreg);
 3826     scale($scale);
 3827     disp($off);
 3828   %}
 3829 %}
 3830 
 3831 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3832 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3833 %{
 3834   constraint(ALLOC_IN_RC(ptr_reg));
 3835   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3836   match(AddP (AddP reg (ConvI2L idx)) off);
 3837 
 3838   op_cost(10);
 3839   format %{&quot;[$reg + $off + $idx]&quot; %}
 3840   interface(MEMORY_INTER) %{
 3841     base($reg);
 3842     index($idx);
 3843     scale(0x0);
 3844     disp($off);
 3845   %}
 3846 %}
 3847 
 3848 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3849 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3850 %{
 3851   constraint(ALLOC_IN_RC(ptr_reg));
 3852   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3853   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3854 
 3855   op_cost(10);
 3856   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3857   interface(MEMORY_INTER) %{
 3858     base($reg);
 3859     index($idx);
 3860     scale($scale);
 3861     disp($off);
 3862   %}
 3863 %}
 3864 
 3865 // Indirect Narrow Oop Plus Offset Operand
 3866 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3867 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3868 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3869   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3870   constraint(ALLOC_IN_RC(ptr_reg));
 3871   match(AddP (DecodeN reg) off);
 3872 
 3873   op_cost(10);
 3874   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3875   interface(MEMORY_INTER) %{
 3876     base(0xc); // R12
 3877     index($reg);
 3878     scale(0x3);
 3879     disp($off);
 3880   %}
 3881 %}
 3882 
 3883 // Indirect Memory Operand
 3884 operand indirectNarrow(rRegN reg)
 3885 %{
 3886   predicate(CompressedOops::shift() == 0);
 3887   constraint(ALLOC_IN_RC(ptr_reg));
 3888   match(DecodeN reg);
 3889 
 3890   format %{ &quot;[$reg]&quot; %}
 3891   interface(MEMORY_INTER) %{
 3892     base($reg);
 3893     index(0x4);
 3894     scale(0x0);
 3895     disp(0x0);
 3896   %}
 3897 %}
 3898 
 3899 // Indirect Memory Plus Short Offset Operand
 3900 operand indOffset8Narrow(rRegN reg, immL8 off)
 3901 %{
 3902   predicate(CompressedOops::shift() == 0);
 3903   constraint(ALLOC_IN_RC(ptr_reg));
 3904   match(AddP (DecodeN reg) off);
 3905 
 3906   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3907   interface(MEMORY_INTER) %{
 3908     base($reg);
 3909     index(0x4);
 3910     scale(0x0);
 3911     disp($off);
 3912   %}
 3913 %}
 3914 
 3915 // Indirect Memory Plus Long Offset Operand
 3916 operand indOffset32Narrow(rRegN reg, immL32 off)
 3917 %{
 3918   predicate(CompressedOops::shift() == 0);
 3919   constraint(ALLOC_IN_RC(ptr_reg));
 3920   match(AddP (DecodeN reg) off);
 3921 
 3922   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3923   interface(MEMORY_INTER) %{
 3924     base($reg);
 3925     index(0x4);
 3926     scale(0x0);
 3927     disp($off);
 3928   %}
 3929 %}
 3930 
 3931 // Indirect Memory Plus Index Register Plus Offset Operand
 3932 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3933 %{
 3934   predicate(CompressedOops::shift() == 0);
 3935   constraint(ALLOC_IN_RC(ptr_reg));
 3936   match(AddP (AddP (DecodeN reg) lreg) off);
 3937 
 3938   op_cost(10);
 3939   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3940   interface(MEMORY_INTER) %{
 3941     base($reg);
 3942     index($lreg);
 3943     scale(0x0);
 3944     disp($off);
 3945   %}
 3946 %}
 3947 
 3948 // Indirect Memory Plus Index Register Plus Offset Operand
 3949 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3950 %{
 3951   predicate(CompressedOops::shift() == 0);
 3952   constraint(ALLOC_IN_RC(ptr_reg));
 3953   match(AddP (DecodeN reg) lreg);
 3954 
 3955   op_cost(10);
 3956   format %{&quot;[$reg + $lreg]&quot; %}
 3957   interface(MEMORY_INTER) %{
 3958     base($reg);
 3959     index($lreg);
 3960     scale(0x0);
 3961     disp(0x0);
 3962   %}
 3963 %}
 3964 
 3965 // Indirect Memory Times Scale Plus Index Register
 3966 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 3967 %{
 3968   predicate(CompressedOops::shift() == 0);
 3969   constraint(ALLOC_IN_RC(ptr_reg));
 3970   match(AddP (DecodeN reg) (LShiftL lreg scale));
 3971 
 3972   op_cost(10);
 3973   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3974   interface(MEMORY_INTER) %{
 3975     base($reg);
 3976     index($lreg);
 3977     scale($scale);
 3978     disp(0x0);
 3979   %}
 3980 %}
 3981 
 3982 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3983 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 3984 %{
 3985   predicate(CompressedOops::shift() == 0);
 3986   constraint(ALLOC_IN_RC(ptr_reg));
 3987   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 3988 
 3989   op_cost(10);
 3990   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3991   interface(MEMORY_INTER) %{
 3992     base($reg);
 3993     index($lreg);
 3994     scale($scale);
 3995     disp($off);
 3996   %}
 3997 %}
 3998 
 3999 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4000 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4001 %{
 4002   constraint(ALLOC_IN_RC(ptr_reg));
 4003   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4004   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4005 
 4006   op_cost(10);
 4007   format %{&quot;[$reg + $off + $idx]&quot; %}
 4008   interface(MEMORY_INTER) %{
 4009     base($reg);
 4010     index($idx);
 4011     scale(0x0);
 4012     disp($off);
 4013   %}
 4014 %}
 4015 
 4016 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4017 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4018 %{
 4019   constraint(ALLOC_IN_RC(ptr_reg));
 4020   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4021   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4022 
 4023   op_cost(10);
 4024   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4025   interface(MEMORY_INTER) %{
 4026     base($reg);
 4027     index($idx);
 4028     scale($scale);
 4029     disp($off);
 4030   %}
 4031 %}
 4032 
 4033 //----------Special Memory Operands--------------------------------------------
 4034 // Stack Slot Operand - This operand is used for loading and storing temporary
 4035 //                      values on the stack where a match requires a value to
 4036 //                      flow through memory.
 4037 operand stackSlotP(sRegP reg)
 4038 %{
 4039   constraint(ALLOC_IN_RC(stack_slots));
 4040   // No match rule because this operand is only generated in matching
 4041 
 4042   format %{ &quot;[$reg]&quot; %}
 4043   interface(MEMORY_INTER) %{
 4044     base(0x4);   // RSP
 4045     index(0x4);  // No Index
 4046     scale(0x0);  // No Scale
 4047     disp($reg);  // Stack Offset
 4048   %}
 4049 %}
 4050 
 4051 operand stackSlotI(sRegI reg)
 4052 %{
 4053   constraint(ALLOC_IN_RC(stack_slots));
 4054   // No match rule because this operand is only generated in matching
 4055 
 4056   format %{ &quot;[$reg]&quot; %}
 4057   interface(MEMORY_INTER) %{
 4058     base(0x4);   // RSP
 4059     index(0x4);  // No Index
 4060     scale(0x0);  // No Scale
 4061     disp($reg);  // Stack Offset
 4062   %}
 4063 %}
 4064 
 4065 operand stackSlotF(sRegF reg)
 4066 %{
 4067   constraint(ALLOC_IN_RC(stack_slots));
 4068   // No match rule because this operand is only generated in matching
 4069 
 4070   format %{ &quot;[$reg]&quot; %}
 4071   interface(MEMORY_INTER) %{
 4072     base(0x4);   // RSP
 4073     index(0x4);  // No Index
 4074     scale(0x0);  // No Scale
 4075     disp($reg);  // Stack Offset
 4076   %}
 4077 %}
 4078 
 4079 operand stackSlotD(sRegD reg)
 4080 %{
 4081   constraint(ALLOC_IN_RC(stack_slots));
 4082   // No match rule because this operand is only generated in matching
 4083 
 4084   format %{ &quot;[$reg]&quot; %}
 4085   interface(MEMORY_INTER) %{
 4086     base(0x4);   // RSP
 4087     index(0x4);  // No Index
 4088     scale(0x0);  // No Scale
 4089     disp($reg);  // Stack Offset
 4090   %}
 4091 %}
 4092 operand stackSlotL(sRegL reg)
 4093 %{
 4094   constraint(ALLOC_IN_RC(stack_slots));
 4095   // No match rule because this operand is only generated in matching
 4096 
 4097   format %{ &quot;[$reg]&quot; %}
 4098   interface(MEMORY_INTER) %{
 4099     base(0x4);   // RSP
 4100     index(0x4);  // No Index
 4101     scale(0x0);  // No Scale
 4102     disp($reg);  // Stack Offset
 4103   %}
 4104 %}
 4105 
 4106 //----------Conditional Branch Operands----------------------------------------
 4107 // Comparison Op  - This is the operation of the comparison, and is limited to
 4108 //                  the following set of codes:
 4109 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4110 //
 4111 // Other attributes of the comparison, such as unsignedness, are specified
 4112 // by the comparison instruction that sets a condition code flags register.
 4113 // That result is represented by a flags operand whose subtype is appropriate
 4114 // to the unsignedness (etc.) of the comparison.
 4115 //
 4116 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4117 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4118 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4119 
 4120 // Comparision Code
 4121 operand cmpOp()
 4122 %{
 4123   match(Bool);
 4124 
 4125   format %{ &quot;&quot; %}
 4126   interface(COND_INTER) %{
 4127     equal(0x4, &quot;e&quot;);
 4128     not_equal(0x5, &quot;ne&quot;);
 4129     less(0xC, &quot;l&quot;);
 4130     greater_equal(0xD, &quot;ge&quot;);
 4131     less_equal(0xE, &quot;le&quot;);
 4132     greater(0xF, &quot;g&quot;);
 4133     overflow(0x0, &quot;o&quot;);
 4134     no_overflow(0x1, &quot;no&quot;);
 4135   %}
 4136 %}
 4137 
 4138 // Comparison Code, unsigned compare.  Used by FP also, with
 4139 // C2 (unordered) turned into GT or LT already.  The other bits
 4140 // C0 and C3 are turned into Carry &amp; Zero flags.
 4141 operand cmpOpU()
 4142 %{
 4143   match(Bool);
 4144 
 4145   format %{ &quot;&quot; %}
 4146   interface(COND_INTER) %{
 4147     equal(0x4, &quot;e&quot;);
 4148     not_equal(0x5, &quot;ne&quot;);
 4149     less(0x2, &quot;b&quot;);
 4150     greater_equal(0x3, &quot;nb&quot;);
 4151     less_equal(0x6, &quot;be&quot;);
 4152     greater(0x7, &quot;nbe&quot;);
 4153     overflow(0x0, &quot;o&quot;);
 4154     no_overflow(0x1, &quot;no&quot;);
 4155   %}
 4156 %}
 4157 
 4158 
 4159 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4160 operand cmpOpUCF() %{
 4161   match(Bool);
 4162   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4163             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4164             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4165             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4166   format %{ &quot;&quot; %}
 4167   interface(COND_INTER) %{
 4168     equal(0x4, &quot;e&quot;);
 4169     not_equal(0x5, &quot;ne&quot;);
 4170     less(0x2, &quot;b&quot;);
 4171     greater_equal(0x3, &quot;nb&quot;);
 4172     less_equal(0x6, &quot;be&quot;);
 4173     greater(0x7, &quot;nbe&quot;);
 4174     overflow(0x0, &quot;o&quot;);
 4175     no_overflow(0x1, &quot;no&quot;);
 4176   %}
 4177 %}
 4178 
 4179 
 4180 // Floating comparisons that can be fixed up with extra conditional jumps
 4181 operand cmpOpUCF2() %{
 4182   match(Bool);
 4183   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4184             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4185   format %{ &quot;&quot; %}
 4186   interface(COND_INTER) %{
 4187     equal(0x4, &quot;e&quot;);
 4188     not_equal(0x5, &quot;ne&quot;);
 4189     less(0x2, &quot;b&quot;);
 4190     greater_equal(0x3, &quot;nb&quot;);
 4191     less_equal(0x6, &quot;be&quot;);
 4192     greater(0x7, &quot;nbe&quot;);
 4193     overflow(0x0, &quot;o&quot;);
 4194     no_overflow(0x1, &quot;no&quot;);
 4195   %}
 4196 %}
 4197 
 4198 //----------OPERAND CLASSES----------------------------------------------------
 4199 // Operand Classes are groups of operands that are used as to simplify
 4200 // instruction definitions by not requiring the AD writer to specify separate
 4201 // instructions for every form of operand when the instruction accepts
 4202 // multiple operand types with the same basic encoding and format.  The classic
 4203 // case of this is memory operands.
 4204 
 4205 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4206                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4207                indCompressedOopOffset,
 4208                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4209                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4210                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4211 
 4212 //----------PIPELINE-----------------------------------------------------------
 4213 // Rules which define the behavior of the target architectures pipeline.
 4214 pipeline %{
 4215 
 4216 //----------ATTRIBUTES---------------------------------------------------------
 4217 attributes %{
 4218   variable_size_instructions;        // Fixed size instructions
 4219   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4220   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4221   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4222   instruction_fetch_units = 1;       // of 16 bytes
 4223 
 4224   // List of nop instructions
 4225   nops( MachNop );
 4226 %}
 4227 
 4228 //----------RESOURCES----------------------------------------------------------
 4229 // Resources are the functional units available to the machine
 4230 
 4231 // Generic P2/P3 pipeline
 4232 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4233 // 3 instructions decoded per cycle.
 4234 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4235 // 3 ALU op, only ALU0 handles mul instructions.
 4236 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4237            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4238            BR, FPU,
 4239            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4240 
 4241 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4242 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4243 
 4244 // Generic P2/P3 pipeline
 4245 pipe_desc(S0, S1, S2, S3, S4, S5);
 4246 
 4247 //----------PIPELINE CLASSES---------------------------------------------------
 4248 // Pipeline Classes describe the stages in which input and output are
 4249 // referenced by the hardware pipeline.
 4250 
 4251 // Naming convention: ialu or fpu
 4252 // Then: _reg
 4253 // Then: _reg if there is a 2nd register
 4254 // Then: _long if it&#39;s a pair of instructions implementing a long
 4255 // Then: _fat if it requires the big decoder
 4256 //   Or: _mem if it requires the big decoder and a memory unit.
 4257 
 4258 // Integer ALU reg operation
 4259 pipe_class ialu_reg(rRegI dst)
 4260 %{
 4261     single_instruction;
 4262     dst    : S4(write);
 4263     dst    : S3(read);
 4264     DECODE : S0;        // any decoder
 4265     ALU    : S3;        // any alu
 4266 %}
 4267 
 4268 // Long ALU reg operation
 4269 pipe_class ialu_reg_long(rRegL dst)
 4270 %{
 4271     instruction_count(2);
 4272     dst    : S4(write);
 4273     dst    : S3(read);
 4274     DECODE : S0(2);     // any 2 decoders
 4275     ALU    : S3(2);     // both alus
 4276 %}
 4277 
 4278 // Integer ALU reg operation using big decoder
 4279 pipe_class ialu_reg_fat(rRegI dst)
 4280 %{
 4281     single_instruction;
 4282     dst    : S4(write);
 4283     dst    : S3(read);
 4284     D0     : S0;        // big decoder only
 4285     ALU    : S3;        // any alu
 4286 %}
 4287 
 4288 // Long ALU reg operation using big decoder
 4289 pipe_class ialu_reg_long_fat(rRegL dst)
 4290 %{
 4291     instruction_count(2);
 4292     dst    : S4(write);
 4293     dst    : S3(read);
 4294     D0     : S0(2);     // big decoder only; twice
 4295     ALU    : S3(2);     // any 2 alus
 4296 %}
 4297 
 4298 // Integer ALU reg-reg operation
 4299 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4300 %{
 4301     single_instruction;
 4302     dst    : S4(write);
 4303     src    : S3(read);
 4304     DECODE : S0;        // any decoder
 4305     ALU    : S3;        // any alu
 4306 %}
 4307 
 4308 // Long ALU reg-reg operation
 4309 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4310 %{
 4311     instruction_count(2);
 4312     dst    : S4(write);
 4313     src    : S3(read);
 4314     DECODE : S0(2);     // any 2 decoders
 4315     ALU    : S3(2);     // both alus
 4316 %}
 4317 
 4318 // Integer ALU reg-reg operation
 4319 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4320 %{
 4321     single_instruction;
 4322     dst    : S4(write);
 4323     src    : S3(read);
 4324     D0     : S0;        // big decoder only
 4325     ALU    : S3;        // any alu
 4326 %}
 4327 
 4328 // Long ALU reg-reg operation
 4329 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4330 %{
 4331     instruction_count(2);
 4332     dst    : S4(write);
 4333     src    : S3(read);
 4334     D0     : S0(2);     // big decoder only; twice
 4335     ALU    : S3(2);     // both alus
 4336 %}
 4337 
 4338 // Integer ALU reg-mem operation
 4339 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4340 %{
 4341     single_instruction;
 4342     dst    : S5(write);
 4343     mem    : S3(read);
 4344     D0     : S0;        // big decoder only
 4345     ALU    : S4;        // any alu
 4346     MEM    : S3;        // any mem
 4347 %}
 4348 
 4349 // Integer mem operation (prefetch)
 4350 pipe_class ialu_mem(memory mem)
 4351 %{
 4352     single_instruction;
 4353     mem    : S3(read);
 4354     D0     : S0;        // big decoder only
 4355     MEM    : S3;        // any mem
 4356 %}
 4357 
 4358 // Integer Store to Memory
 4359 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4360 %{
 4361     single_instruction;
 4362     mem    : S3(read);
 4363     src    : S5(read);
 4364     D0     : S0;        // big decoder only
 4365     ALU    : S4;        // any alu
 4366     MEM    : S3;
 4367 %}
 4368 
 4369 // // Long Store to Memory
 4370 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4371 // %{
 4372 //     instruction_count(2);
 4373 //     mem    : S3(read);
 4374 //     src    : S5(read);
 4375 //     D0     : S0(2);          // big decoder only; twice
 4376 //     ALU    : S4(2);     // any 2 alus
 4377 //     MEM    : S3(2);  // Both mems
 4378 // %}
 4379 
 4380 // Integer Store to Memory
 4381 pipe_class ialu_mem_imm(memory mem)
 4382 %{
 4383     single_instruction;
 4384     mem    : S3(read);
 4385     D0     : S0;        // big decoder only
 4386     ALU    : S4;        // any alu
 4387     MEM    : S3;
 4388 %}
 4389 
 4390 // Integer ALU0 reg-reg operation
 4391 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4392 %{
 4393     single_instruction;
 4394     dst    : S4(write);
 4395     src    : S3(read);
 4396     D0     : S0;        // Big decoder only
 4397     ALU0   : S3;        // only alu0
 4398 %}
 4399 
 4400 // Integer ALU0 reg-mem operation
 4401 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4402 %{
 4403     single_instruction;
 4404     dst    : S5(write);
 4405     mem    : S3(read);
 4406     D0     : S0;        // big decoder only
 4407     ALU0   : S4;        // ALU0 only
 4408     MEM    : S3;        // any mem
 4409 %}
 4410 
 4411 // Integer ALU reg-reg operation
 4412 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4413 %{
 4414     single_instruction;
 4415     cr     : S4(write);
 4416     src1   : S3(read);
 4417     src2   : S3(read);
 4418     DECODE : S0;        // any decoder
 4419     ALU    : S3;        // any alu
 4420 %}
 4421 
 4422 // Integer ALU reg-imm operation
 4423 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4424 %{
 4425     single_instruction;
 4426     cr     : S4(write);
 4427     src1   : S3(read);
 4428     DECODE : S0;        // any decoder
 4429     ALU    : S3;        // any alu
 4430 %}
 4431 
 4432 // Integer ALU reg-mem operation
 4433 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4434 %{
 4435     single_instruction;
 4436     cr     : S4(write);
 4437     src1   : S3(read);
 4438     src2   : S3(read);
 4439     D0     : S0;        // big decoder only
 4440     ALU    : S4;        // any alu
 4441     MEM    : S3;
 4442 %}
 4443 
 4444 // Conditional move reg-reg
 4445 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4446 %{
 4447     instruction_count(4);
 4448     y      : S4(read);
 4449     q      : S3(read);
 4450     p      : S3(read);
 4451     DECODE : S0(4);     // any decoder
 4452 %}
 4453 
 4454 // Conditional move reg-reg
 4455 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4456 %{
 4457     single_instruction;
 4458     dst    : S4(write);
 4459     src    : S3(read);
 4460     cr     : S3(read);
 4461     DECODE : S0;        // any decoder
 4462 %}
 4463 
 4464 // Conditional move reg-mem
 4465 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4466 %{
 4467     single_instruction;
 4468     dst    : S4(write);
 4469     src    : S3(read);
 4470     cr     : S3(read);
 4471     DECODE : S0;        // any decoder
 4472     MEM    : S3;
 4473 %}
 4474 
 4475 // Conditional move reg-reg long
 4476 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4477 %{
 4478     single_instruction;
 4479     dst    : S4(write);
 4480     src    : S3(read);
 4481     cr     : S3(read);
 4482     DECODE : S0(2);     // any 2 decoders
 4483 %}
 4484 
 4485 // XXX
 4486 // // Conditional move double reg-reg
 4487 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4488 // %{
 4489 //     single_instruction;
 4490 //     dst    : S4(write);
 4491 //     src    : S3(read);
 4492 //     cr     : S3(read);
 4493 //     DECODE : S0;     // any decoder
 4494 // %}
 4495 
 4496 // Float reg-reg operation
 4497 pipe_class fpu_reg(regD dst)
 4498 %{
 4499     instruction_count(2);
 4500     dst    : S3(read);
 4501     DECODE : S0(2);     // any 2 decoders
 4502     FPU    : S3;
 4503 %}
 4504 
 4505 // Float reg-reg operation
 4506 pipe_class fpu_reg_reg(regD dst, regD src)
 4507 %{
 4508     instruction_count(2);
 4509     dst    : S4(write);
 4510     src    : S3(read);
 4511     DECODE : S0(2);     // any 2 decoders
 4512     FPU    : S3;
 4513 %}
 4514 
 4515 // Float reg-reg operation
 4516 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4517 %{
 4518     instruction_count(3);
 4519     dst    : S4(write);
 4520     src1   : S3(read);
 4521     src2   : S3(read);
 4522     DECODE : S0(3);     // any 3 decoders
 4523     FPU    : S3(2);
 4524 %}
 4525 
 4526 // Float reg-reg operation
 4527 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4528 %{
 4529     instruction_count(4);
 4530     dst    : S4(write);
 4531     src1   : S3(read);
 4532     src2   : S3(read);
 4533     src3   : S3(read);
 4534     DECODE : S0(4);     // any 3 decoders
 4535     FPU    : S3(2);
 4536 %}
 4537 
 4538 // Float reg-reg operation
 4539 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4540 %{
 4541     instruction_count(4);
 4542     dst    : S4(write);
 4543     src1   : S3(read);
 4544     src2   : S3(read);
 4545     src3   : S3(read);
 4546     DECODE : S1(3);     // any 3 decoders
 4547     D0     : S0;        // Big decoder only
 4548     FPU    : S3(2);
 4549     MEM    : S3;
 4550 %}
 4551 
 4552 // Float reg-mem operation
 4553 pipe_class fpu_reg_mem(regD dst, memory mem)
 4554 %{
 4555     instruction_count(2);
 4556     dst    : S5(write);
 4557     mem    : S3(read);
 4558     D0     : S0;        // big decoder only
 4559     DECODE : S1;        // any decoder for FPU POP
 4560     FPU    : S4;
 4561     MEM    : S3;        // any mem
 4562 %}
 4563 
 4564 // Float reg-mem operation
 4565 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4566 %{
 4567     instruction_count(3);
 4568     dst    : S5(write);
 4569     src1   : S3(read);
 4570     mem    : S3(read);
 4571     D0     : S0;        // big decoder only
 4572     DECODE : S1(2);     // any decoder for FPU POP
 4573     FPU    : S4;
 4574     MEM    : S3;        // any mem
 4575 %}
 4576 
 4577 // Float mem-reg operation
 4578 pipe_class fpu_mem_reg(memory mem, regD src)
 4579 %{
 4580     instruction_count(2);
 4581     src    : S5(read);
 4582     mem    : S3(read);
 4583     DECODE : S0;        // any decoder for FPU PUSH
 4584     D0     : S1;        // big decoder only
 4585     FPU    : S4;
 4586     MEM    : S3;        // any mem
 4587 %}
 4588 
 4589 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4590 %{
 4591     instruction_count(3);
 4592     src1   : S3(read);
 4593     src2   : S3(read);
 4594     mem    : S3(read);
 4595     DECODE : S0(2);     // any decoder for FPU PUSH
 4596     D0     : S1;        // big decoder only
 4597     FPU    : S4;
 4598     MEM    : S3;        // any mem
 4599 %}
 4600 
 4601 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4602 %{
 4603     instruction_count(3);
 4604     src1   : S3(read);
 4605     src2   : S3(read);
 4606     mem    : S4(read);
 4607     DECODE : S0;        // any decoder for FPU PUSH
 4608     D0     : S0(2);     // big decoder only
 4609     FPU    : S4;
 4610     MEM    : S3(2);     // any mem
 4611 %}
 4612 
 4613 pipe_class fpu_mem_mem(memory dst, memory src1)
 4614 %{
 4615     instruction_count(2);
 4616     src1   : S3(read);
 4617     dst    : S4(read);
 4618     D0     : S0(2);     // big decoder only
 4619     MEM    : S3(2);     // any mem
 4620 %}
 4621 
 4622 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4623 %{
 4624     instruction_count(3);
 4625     src1   : S3(read);
 4626     src2   : S3(read);
 4627     dst    : S4(read);
 4628     D0     : S0(3);     // big decoder only
 4629     FPU    : S4;
 4630     MEM    : S3(3);     // any mem
 4631 %}
 4632 
 4633 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4634 %{
 4635     instruction_count(3);
 4636     src1   : S4(read);
 4637     mem    : S4(read);
 4638     DECODE : S0;        // any decoder for FPU PUSH
 4639     D0     : S0(2);     // big decoder only
 4640     FPU    : S4;
 4641     MEM    : S3(2);     // any mem
 4642 %}
 4643 
 4644 // Float load constant
 4645 pipe_class fpu_reg_con(regD dst)
 4646 %{
 4647     instruction_count(2);
 4648     dst    : S5(write);
 4649     D0     : S0;        // big decoder only for the load
 4650     DECODE : S1;        // any decoder for FPU POP
 4651     FPU    : S4;
 4652     MEM    : S3;        // any mem
 4653 %}
 4654 
 4655 // Float load constant
 4656 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4657 %{
 4658     instruction_count(3);
 4659     dst    : S5(write);
 4660     src    : S3(read);
 4661     D0     : S0;        // big decoder only for the load
 4662     DECODE : S1(2);     // any decoder for FPU POP
 4663     FPU    : S4;
 4664     MEM    : S3;        // any mem
 4665 %}
 4666 
 4667 // UnConditional branch
 4668 pipe_class pipe_jmp(label labl)
 4669 %{
 4670     single_instruction;
 4671     BR   : S3;
 4672 %}
 4673 
 4674 // Conditional branch
 4675 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4676 %{
 4677     single_instruction;
 4678     cr    : S1(read);
 4679     BR    : S3;
 4680 %}
 4681 
 4682 // Allocation idiom
 4683 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4684 %{
 4685     instruction_count(1); force_serialization;
 4686     fixed_latency(6);
 4687     heap_ptr : S3(read);
 4688     DECODE   : S0(3);
 4689     D0       : S2;
 4690     MEM      : S3;
 4691     ALU      : S3(2);
 4692     dst      : S5(write);
 4693     BR       : S5;
 4694 %}
 4695 
 4696 // Generic big/slow expanded idiom
 4697 pipe_class pipe_slow()
 4698 %{
 4699     instruction_count(10); multiple_bundles; force_serialization;
 4700     fixed_latency(100);
 4701     D0  : S0(2);
 4702     MEM : S3(2);
 4703 %}
 4704 
 4705 // The real do-nothing guy
 4706 pipe_class empty()
 4707 %{
 4708     instruction_count(0);
 4709 %}
 4710 
 4711 // Define the class for the Nop node
 4712 define
 4713 %{
 4714    MachNop = empty;
 4715 %}
 4716 
 4717 %}
 4718 
 4719 //----------INSTRUCTIONS-------------------------------------------------------
 4720 //
 4721 // match      -- States which machine-independent subtree may be replaced
 4722 //               by this instruction.
 4723 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4724 //               selection to identify a minimum cost tree of machine
 4725 //               instructions that matches a tree of machine-independent
 4726 //               instructions.
 4727 // format     -- A string providing the disassembly for this instruction.
 4728 //               The value of an instruction&#39;s operand may be inserted
 4729 //               by referring to it with a &#39;$&#39; prefix.
 4730 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4731 //               to within an encode class as $primary, $secondary, and $tertiary
 4732 //               rrspectively.  The primary opcode is commonly used to
 4733 //               indicate the type of machine instruction, while secondary
 4734 //               and tertiary are often used for prefix options or addressing
 4735 //               modes.
 4736 // ins_encode -- A list of encode classes with parameters. The encode class
 4737 //               name must have been defined in an &#39;enc_class&#39; specification
 4738 //               in the encode section of the architecture description.
 4739 
 4740 
 4741 //----------Load/Store/Move Instructions---------------------------------------
 4742 //----------Load Instructions--------------------------------------------------
 4743 
 4744 // Load Byte (8 bit signed)
 4745 instruct loadB(rRegI dst, memory mem)
 4746 %{
 4747   match(Set dst (LoadB mem));
 4748 
 4749   ins_cost(125);
 4750   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4751 
 4752   ins_encode %{
 4753     __ movsbl($dst$$Register, $mem$$Address);
 4754   %}
 4755 
 4756   ins_pipe(ialu_reg_mem);
 4757 %}
 4758 
 4759 // Load Byte (8 bit signed) into Long Register
 4760 instruct loadB2L(rRegL dst, memory mem)
 4761 %{
 4762   match(Set dst (ConvI2L (LoadB mem)));
 4763 
 4764   ins_cost(125);
 4765   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4766 
 4767   ins_encode %{
 4768     __ movsbq($dst$$Register, $mem$$Address);
 4769   %}
 4770 
 4771   ins_pipe(ialu_reg_mem);
 4772 %}
 4773 
 4774 // Load Unsigned Byte (8 bit UNsigned)
 4775 instruct loadUB(rRegI dst, memory mem)
 4776 %{
 4777   match(Set dst (LoadUB mem));
 4778 
 4779   ins_cost(125);
 4780   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4781 
 4782   ins_encode %{
 4783     __ movzbl($dst$$Register, $mem$$Address);
 4784   %}
 4785 
 4786   ins_pipe(ialu_reg_mem);
 4787 %}
 4788 
 4789 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4790 instruct loadUB2L(rRegL dst, memory mem)
 4791 %{
 4792   match(Set dst (ConvI2L (LoadUB mem)));
 4793 
 4794   ins_cost(125);
 4795   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4796 
 4797   ins_encode %{
 4798     __ movzbq($dst$$Register, $mem$$Address);
 4799   %}
 4800 
 4801   ins_pipe(ialu_reg_mem);
 4802 %}
 4803 
 4804 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4805 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4806   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4807   effect(KILL cr);
 4808 
 4809   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4810             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4811   ins_encode %{
 4812     Register Rdst = $dst$$Register;
 4813     __ movzbq(Rdst, $mem$$Address);
 4814     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4815   %}
 4816   ins_pipe(ialu_reg_mem);
 4817 %}
 4818 
 4819 // Load Short (16 bit signed)
 4820 instruct loadS(rRegI dst, memory mem)
 4821 %{
 4822   match(Set dst (LoadS mem));
 4823 
 4824   ins_cost(125);
 4825   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4826 
 4827   ins_encode %{
 4828     __ movswl($dst$$Register, $mem$$Address);
 4829   %}
 4830 
 4831   ins_pipe(ialu_reg_mem);
 4832 %}
 4833 
 4834 // Load Short (16 bit signed) to Byte (8 bit signed)
 4835 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4836   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4837 
 4838   ins_cost(125);
 4839   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4840   ins_encode %{
 4841     __ movsbl($dst$$Register, $mem$$Address);
 4842   %}
 4843   ins_pipe(ialu_reg_mem);
 4844 %}
 4845 
 4846 // Load Short (16 bit signed) into Long Register
 4847 instruct loadS2L(rRegL dst, memory mem)
 4848 %{
 4849   match(Set dst (ConvI2L (LoadS mem)));
 4850 
 4851   ins_cost(125);
 4852   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4853 
 4854   ins_encode %{
 4855     __ movswq($dst$$Register, $mem$$Address);
 4856   %}
 4857 
 4858   ins_pipe(ialu_reg_mem);
 4859 %}
 4860 
 4861 // Load Unsigned Short/Char (16 bit UNsigned)
 4862 instruct loadUS(rRegI dst, memory mem)
 4863 %{
 4864   match(Set dst (LoadUS mem));
 4865 
 4866   ins_cost(125);
 4867   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4868 
 4869   ins_encode %{
 4870     __ movzwl($dst$$Register, $mem$$Address);
 4871   %}
 4872 
 4873   ins_pipe(ialu_reg_mem);
 4874 %}
 4875 
 4876 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4877 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4878   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4879 
 4880   ins_cost(125);
 4881   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4882   ins_encode %{
 4883     __ movsbl($dst$$Register, $mem$$Address);
 4884   %}
 4885   ins_pipe(ialu_reg_mem);
 4886 %}
 4887 
 4888 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4889 instruct loadUS2L(rRegL dst, memory mem)
 4890 %{
 4891   match(Set dst (ConvI2L (LoadUS mem)));
 4892 
 4893   ins_cost(125);
 4894   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4895 
 4896   ins_encode %{
 4897     __ movzwq($dst$$Register, $mem$$Address);
 4898   %}
 4899 
 4900   ins_pipe(ialu_reg_mem);
 4901 %}
 4902 
 4903 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4904 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4905   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4906 
 4907   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4908   ins_encode %{
 4909     __ movzbq($dst$$Register, $mem$$Address);
 4910   %}
 4911   ins_pipe(ialu_reg_mem);
 4912 %}
 4913 
 4914 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4915 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4916   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4917   effect(KILL cr);
 4918 
 4919   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4920             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4921   ins_encode %{
 4922     Register Rdst = $dst$$Register;
 4923     __ movzwq(Rdst, $mem$$Address);
 4924     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4925   %}
 4926   ins_pipe(ialu_reg_mem);
 4927 %}
 4928 
 4929 // Load Integer
 4930 instruct loadI(rRegI dst, memory mem)
 4931 %{
 4932   match(Set dst (LoadI mem));
 4933 
 4934   ins_cost(125);
 4935   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4936 
 4937   ins_encode %{
 4938     __ movl($dst$$Register, $mem$$Address);
 4939   %}
 4940 
 4941   ins_pipe(ialu_reg_mem);
 4942 %}
 4943 
 4944 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4945 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4946   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4947 
 4948   ins_cost(125);
 4949   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4950   ins_encode %{
 4951     __ movsbl($dst$$Register, $mem$$Address);
 4952   %}
 4953   ins_pipe(ialu_reg_mem);
 4954 %}
 4955 
 4956 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4957 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4958   match(Set dst (AndI (LoadI mem) mask));
 4959 
 4960   ins_cost(125);
 4961   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 4962   ins_encode %{
 4963     __ movzbl($dst$$Register, $mem$$Address);
 4964   %}
 4965   ins_pipe(ialu_reg_mem);
 4966 %}
 4967 
 4968 // Load Integer (32 bit signed) to Short (16 bit signed)
 4969 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 4970   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 4971 
 4972   ins_cost(125);
 4973   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 4974   ins_encode %{
 4975     __ movswl($dst$$Register, $mem$$Address);
 4976   %}
 4977   ins_pipe(ialu_reg_mem);
 4978 %}
 4979 
 4980 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 4981 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 4982   match(Set dst (AndI (LoadI mem) mask));
 4983 
 4984   ins_cost(125);
 4985   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 4986   ins_encode %{
 4987     __ movzwl($dst$$Register, $mem$$Address);
 4988   %}
 4989   ins_pipe(ialu_reg_mem);
 4990 %}
 4991 
 4992 // Load Integer into Long Register
 4993 instruct loadI2L(rRegL dst, memory mem)
 4994 %{
 4995   match(Set dst (ConvI2L (LoadI mem)));
 4996 
 4997   ins_cost(125);
 4998   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 4999 
 5000   ins_encode %{
 5001     __ movslq($dst$$Register, $mem$$Address);
 5002   %}
 5003 
 5004   ins_pipe(ialu_reg_mem);
 5005 %}
 5006 
 5007 // Load Integer with mask 0xFF into Long Register
 5008 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5009   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5010 
 5011   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5012   ins_encode %{
 5013     __ movzbq($dst$$Register, $mem$$Address);
 5014   %}
 5015   ins_pipe(ialu_reg_mem);
 5016 %}
 5017 
 5018 // Load Integer with mask 0xFFFF into Long Register
 5019 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5020   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5021 
 5022   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5023   ins_encode %{
 5024     __ movzwq($dst$$Register, $mem$$Address);
 5025   %}
 5026   ins_pipe(ialu_reg_mem);
 5027 %}
 5028 
 5029 // Load Integer with a 31-bit mask into Long Register
 5030 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5031   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5032   effect(KILL cr);
 5033 
 5034   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5035             &quot;andl    $dst, $mask&quot; %}
 5036   ins_encode %{
 5037     Register Rdst = $dst$$Register;
 5038     __ movl(Rdst, $mem$$Address);
 5039     __ andl(Rdst, $mask$$constant);
 5040   %}
 5041   ins_pipe(ialu_reg_mem);
 5042 %}
 5043 
 5044 // Load Unsigned Integer into Long Register
 5045 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5046 %{
 5047   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5048 
 5049   ins_cost(125);
 5050   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5051 
 5052   ins_encode %{
 5053     __ movl($dst$$Register, $mem$$Address);
 5054   %}
 5055 
 5056   ins_pipe(ialu_reg_mem);
 5057 %}
 5058 
 5059 // Load Long
 5060 instruct loadL(rRegL dst, memory mem)
 5061 %{
 5062   match(Set dst (LoadL mem));
 5063 
 5064   ins_cost(125);
 5065   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5066 
 5067   ins_encode %{
 5068     __ movq($dst$$Register, $mem$$Address);
 5069   %}
 5070 
 5071   ins_pipe(ialu_reg_mem); // XXX
 5072 %}
 5073 
 5074 // Load Range
 5075 instruct loadRange(rRegI dst, memory mem)
 5076 %{
 5077   match(Set dst (LoadRange mem));
 5078 
 5079   ins_cost(125); // XXX
 5080   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5081   opcode(0x8B);
 5082   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5083   ins_pipe(ialu_reg_mem);
 5084 %}
 5085 
 5086 // Load Pointer
 5087 instruct loadP(rRegP dst, memory mem)
 5088 %{
 5089   match(Set dst (LoadP mem));
 5090   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5091 
 5092   ins_cost(125); // XXX
 5093   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5094   opcode(0x8B);
 5095   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5096   ins_pipe(ialu_reg_mem); // XXX
 5097 %}
 5098 
 5099 // Load Compressed Pointer
 5100 instruct loadN(rRegN dst, memory mem)
 5101 %{
 5102    match(Set dst (LoadN mem));
 5103 
 5104    ins_cost(125); // XXX
 5105    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5106    ins_encode %{
 5107      __ movl($dst$$Register, $mem$$Address);
 5108    %}
 5109    ins_pipe(ialu_reg_mem); // XXX
 5110 %}
 5111 
 5112 
 5113 // Load Klass Pointer
 5114 instruct loadKlass(rRegP dst, memory mem)
 5115 %{
 5116   match(Set dst (LoadKlass mem));
 5117 
 5118   ins_cost(125); // XXX
 5119   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5120   opcode(0x8B);
 5121   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5122   ins_pipe(ialu_reg_mem); // XXX
 5123 %}
 5124 
 5125 // Load narrow Klass Pointer
 5126 instruct loadNKlass(rRegN dst, memory mem)
 5127 %{
 5128   match(Set dst (LoadNKlass mem));
 5129 
 5130   ins_cost(125); // XXX
 5131   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5132   ins_encode %{
 5133     __ movl($dst$$Register, $mem$$Address);
 5134   %}
 5135   ins_pipe(ialu_reg_mem); // XXX
 5136 %}
 5137 
 5138 // Load Float
 5139 instruct loadF(regF dst, memory mem)
 5140 %{
 5141   match(Set dst (LoadF mem));
 5142 
 5143   ins_cost(145); // XXX
 5144   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5145   ins_encode %{
 5146     __ movflt($dst$$XMMRegister, $mem$$Address);
 5147   %}
 5148   ins_pipe(pipe_slow); // XXX
 5149 %}
 5150 
 5151 // Load Float
 5152 instruct MoveF2VL(vlRegF dst, regF src) %{
 5153   match(Set dst src);
 5154   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5155   ins_encode %{
 5156     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5157   %}
 5158   ins_pipe( fpu_reg_reg );
 5159 %}
 5160 
 5161 // Load Float
 5162 instruct MoveF2LEG(legRegF dst, regF src) %{
 5163   match(Set dst src);
 5164   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5165   ins_encode %{
 5166     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5167   %}
 5168   ins_pipe( fpu_reg_reg );
 5169 %}
 5170 
 5171 // Load Float
 5172 instruct MoveVL2F(regF dst, vlRegF src) %{
 5173   match(Set dst src);
 5174   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5175   ins_encode %{
 5176     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5177   %}
 5178   ins_pipe( fpu_reg_reg );
 5179 %}
 5180 
 5181 // Load Float
 5182 instruct MoveLEG2F(regF dst, legRegF src) %{
 5183   match(Set dst src);
 5184   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5185   ins_encode %{
 5186     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5187   %}
 5188   ins_pipe( fpu_reg_reg );
 5189 %}
 5190 
 5191 // Load Double
 5192 instruct loadD_partial(regD dst, memory mem)
 5193 %{
 5194   predicate(!UseXmmLoadAndClearUpper);
 5195   match(Set dst (LoadD mem));
 5196 
 5197   ins_cost(145); // XXX
 5198   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5199   ins_encode %{
 5200     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5201   %}
 5202   ins_pipe(pipe_slow); // XXX
 5203 %}
 5204 
 5205 instruct loadD(regD dst, memory mem)
 5206 %{
 5207   predicate(UseXmmLoadAndClearUpper);
 5208   match(Set dst (LoadD mem));
 5209 
 5210   ins_cost(145); // XXX
 5211   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5212   ins_encode %{
 5213     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5214   %}
 5215   ins_pipe(pipe_slow); // XXX
 5216 %}
 5217 
 5218 // Load Double
 5219 instruct MoveD2VL(vlRegD dst, regD src) %{
 5220   match(Set dst src);
 5221   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5222   ins_encode %{
 5223     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5224   %}
 5225   ins_pipe( fpu_reg_reg );
 5226 %}
 5227 
 5228 // Load Double
 5229 instruct MoveD2LEG(legRegD dst, regD src) %{
 5230   match(Set dst src);
 5231   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5232   ins_encode %{
 5233     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5234   %}
 5235   ins_pipe( fpu_reg_reg );
 5236 %}
 5237 
 5238 // Load Double
 5239 instruct MoveVL2D(regD dst, vlRegD src) %{
 5240   match(Set dst src);
 5241   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5242   ins_encode %{
 5243     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5244   %}
 5245   ins_pipe( fpu_reg_reg );
 5246 %}
 5247 
 5248 // Load Double
 5249 instruct MoveLEG2D(regD dst, legRegD src) %{
 5250   match(Set dst src);
 5251   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5252   ins_encode %{
 5253     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5254   %}
 5255   ins_pipe( fpu_reg_reg );
 5256 %}
 5257 
 5258 // Following pseudo code describes the algorithm for max[FD]:
 5259 // Min algorithm is on similar lines
 5260 //  btmp = (b &lt; +0.0) ? a : b
 5261 //  atmp = (b &lt; +0.0) ? b : a
 5262 //  Tmp  = Max_Float(atmp , btmp)
 5263 //  Res  = (atmp == NaN) ? atmp : Tmp
 5264 
 5265 // max = java.lang.Math.max(float a, float b)
 5266 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5267   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5268   match(Set dst (MaxF a b));
 5269   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5270   format %{
 5271      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5272      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5273      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5274      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5275      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5276   %}
 5277   ins_encode %{
 5278     int vector_len = Assembler::AVX_128bit;
 5279     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5280     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5281     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5282     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5283     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5284  %}
 5285   ins_pipe( pipe_slow );
 5286 %}
 5287 
 5288 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5289   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5290   match(Set dst (MaxF a b));
 5291   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5292 
 5293   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5294   ins_encode %{
 5295     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5296                     false /*min*/, true /*single*/);
 5297   %}
 5298   ins_pipe( pipe_slow );
 5299 %}
 5300 
 5301 // max = java.lang.Math.max(double a, double b)
 5302 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5303   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5304   match(Set dst (MaxD a b));
 5305   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5306   format %{
 5307      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5308      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5309      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5310      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5311      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5312   %}
 5313   ins_encode %{
 5314     int vector_len = Assembler::AVX_128bit;
 5315     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5316     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5317     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5318     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5319     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5320   %}
 5321   ins_pipe( pipe_slow );
 5322 %}
 5323 
 5324 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5325   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5326   match(Set dst (MaxD a b));
 5327   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5328 
 5329   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5330   ins_encode %{
 5331     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5332                     false /*min*/, false /*single*/);
 5333   %}
 5334   ins_pipe( pipe_slow );
 5335 %}
 5336 
 5337 // min = java.lang.Math.min(float a, float b)
 5338 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5339   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5340   match(Set dst (MinF a b));
 5341   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5342   format %{
 5343      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5344      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5345      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5346      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5347      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5348   %}
 5349   ins_encode %{
 5350     int vector_len = Assembler::AVX_128bit;
 5351     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5352     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5353     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5354     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5355     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5356   %}
 5357   ins_pipe( pipe_slow );
 5358 %}
 5359 
 5360 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5361   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5362   match(Set dst (MinF a b));
 5363   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5364 
 5365   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5366   ins_encode %{
 5367     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5368                     true /*min*/, true /*single*/);
 5369   %}
 5370   ins_pipe( pipe_slow );
 5371 %}
 5372 
 5373 // min = java.lang.Math.min(double a, double b)
 5374 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5375   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5376   match(Set dst (MinD a b));
 5377   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5378   format %{
 5379      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5380      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5381      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5382      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5383      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5384   %}
 5385   ins_encode %{
 5386     int vector_len = Assembler::AVX_128bit;
 5387     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5388     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5389     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5390     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5391     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5392   %}
 5393   ins_pipe( pipe_slow );
 5394 %}
 5395 
 5396 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5397   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5398   match(Set dst (MinD a b));
 5399   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5400 
 5401   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5402   ins_encode %{
 5403     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5404                     true /*min*/, false /*single*/);
 5405   %}
 5406   ins_pipe( pipe_slow );
 5407 %}
 5408 
 5409 // Load Effective Address
 5410 instruct leaP8(rRegP dst, indOffset8 mem)
 5411 %{
 5412   match(Set dst mem);
 5413 
 5414   ins_cost(110); // XXX
 5415   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5416   opcode(0x8D);
 5417   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5418   ins_pipe(ialu_reg_reg_fat);
 5419 %}
 5420 
 5421 instruct leaP32(rRegP dst, indOffset32 mem)
 5422 %{
 5423   match(Set dst mem);
 5424 
 5425   ins_cost(110);
 5426   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5427   opcode(0x8D);
 5428   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5429   ins_pipe(ialu_reg_reg_fat);
 5430 %}
 5431 
 5432 // instruct leaPIdx(rRegP dst, indIndex mem)
 5433 // %{
 5434 //   match(Set dst mem);
 5435 
 5436 //   ins_cost(110);
 5437 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5438 //   opcode(0x8D);
 5439 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5440 //   ins_pipe(ialu_reg_reg_fat);
 5441 // %}
 5442 
 5443 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5444 %{
 5445   match(Set dst mem);
 5446 
 5447   ins_cost(110);
 5448   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5449   opcode(0x8D);
 5450   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5451   ins_pipe(ialu_reg_reg_fat);
 5452 %}
 5453 
 5454 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5455 %{
 5456   match(Set dst mem);
 5457 
 5458   ins_cost(110);
 5459   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5460   opcode(0x8D);
 5461   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5462   ins_pipe(ialu_reg_reg_fat);
 5463 %}
 5464 
 5465 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5466 %{
 5467   match(Set dst mem);
 5468 
 5469   ins_cost(110);
 5470   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5471   opcode(0x8D);
 5472   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5473   ins_pipe(ialu_reg_reg_fat);
 5474 %}
 5475 
 5476 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5477 %{
 5478   match(Set dst mem);
 5479 
 5480   ins_cost(110);
 5481   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5482   opcode(0x8D);
 5483   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5484   ins_pipe(ialu_reg_reg_fat);
 5485 %}
 5486 
 5487 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5488 %{
 5489   match(Set dst mem);
 5490 
 5491   ins_cost(110);
 5492   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5493   opcode(0x8D);
 5494   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5495   ins_pipe(ialu_reg_reg_fat);
 5496 %}
 5497 
 5498 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5499 %{
 5500   match(Set dst mem);
 5501 
 5502   ins_cost(110);
 5503   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5504   opcode(0x8D);
 5505   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5506   ins_pipe(ialu_reg_reg_fat);
 5507 %}
 5508 
 5509 // Load Effective Address which uses Narrow (32-bits) oop
 5510 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5511 %{
 5512   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5513   match(Set dst mem);
 5514 
 5515   ins_cost(110);
 5516   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5517   opcode(0x8D);
 5518   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5519   ins_pipe(ialu_reg_reg_fat);
 5520 %}
 5521 
 5522 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5523 %{
 5524   predicate(CompressedOops::shift() == 0);
 5525   match(Set dst mem);
 5526 
 5527   ins_cost(110); // XXX
 5528   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5529   opcode(0x8D);
 5530   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5531   ins_pipe(ialu_reg_reg_fat);
 5532 %}
 5533 
 5534 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5535 %{
 5536   predicate(CompressedOops::shift() == 0);
 5537   match(Set dst mem);
 5538 
 5539   ins_cost(110);
 5540   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5541   opcode(0x8D);
 5542   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5543   ins_pipe(ialu_reg_reg_fat);
 5544 %}
 5545 
 5546 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5547 %{
 5548   predicate(CompressedOops::shift() == 0);
 5549   match(Set dst mem);
 5550 
 5551   ins_cost(110);
 5552   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5553   opcode(0x8D);
 5554   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5555   ins_pipe(ialu_reg_reg_fat);
 5556 %}
 5557 
 5558 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5559 %{
 5560   predicate(CompressedOops::shift() == 0);
 5561   match(Set dst mem);
 5562 
 5563   ins_cost(110);
 5564   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5565   opcode(0x8D);
 5566   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5567   ins_pipe(ialu_reg_reg_fat);
 5568 %}
 5569 
 5570 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5571 %{
 5572   predicate(CompressedOops::shift() == 0);
 5573   match(Set dst mem);
 5574 
 5575   ins_cost(110);
 5576   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5577   opcode(0x8D);
 5578   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5579   ins_pipe(ialu_reg_reg_fat);
 5580 %}
 5581 
 5582 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5583 %{
 5584   predicate(CompressedOops::shift() == 0);
 5585   match(Set dst mem);
 5586 
 5587   ins_cost(110);
 5588   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5589   opcode(0x8D);
 5590   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5591   ins_pipe(ialu_reg_reg_fat);
 5592 %}
 5593 
 5594 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5595 %{
 5596   predicate(CompressedOops::shift() == 0);
 5597   match(Set dst mem);
 5598 
 5599   ins_cost(110);
 5600   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5601   opcode(0x8D);
 5602   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5603   ins_pipe(ialu_reg_reg_fat);
 5604 %}
 5605 
 5606 instruct loadConI(rRegI dst, immI src)
 5607 %{
 5608   match(Set dst src);
 5609 
 5610   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5611   ins_encode(load_immI(dst, src));
 5612   ins_pipe(ialu_reg_fat); // XXX
 5613 %}
 5614 
 5615 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5616 %{
 5617   match(Set dst src);
 5618   effect(KILL cr);
 5619 
 5620   ins_cost(50);
 5621   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5622   opcode(0x33); /* + rd */
 5623   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5624   ins_pipe(ialu_reg);
 5625 %}
 5626 
 5627 instruct loadConL(rRegL dst, immL src)
 5628 %{
 5629   match(Set dst src);
 5630 
 5631   ins_cost(150);
 5632   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5633   ins_encode(load_immL(dst, src));
 5634   ins_pipe(ialu_reg);
 5635 %}
 5636 
 5637 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5638 %{
 5639   match(Set dst src);
 5640   effect(KILL cr);
 5641 
 5642   ins_cost(50);
 5643   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5644   opcode(0x33); /* + rd */
 5645   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5646   ins_pipe(ialu_reg); // XXX
 5647 %}
 5648 
 5649 instruct loadConUL32(rRegL dst, immUL32 src)
 5650 %{
 5651   match(Set dst src);
 5652 
 5653   ins_cost(60);
 5654   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5655   ins_encode(load_immUL32(dst, src));
 5656   ins_pipe(ialu_reg);
 5657 %}
 5658 
 5659 instruct loadConL32(rRegL dst, immL32 src)
 5660 %{
 5661   match(Set dst src);
 5662 
 5663   ins_cost(70);
 5664   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5665   ins_encode(load_immL32(dst, src));
 5666   ins_pipe(ialu_reg);
 5667 %}
 5668 
 5669 instruct loadConP(rRegP dst, immP con) %{
 5670   match(Set dst con);
 5671 
 5672   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5673   ins_encode(load_immP(dst, con));
 5674   ins_pipe(ialu_reg_fat); // XXX
 5675 %}
 5676 
 5677 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5678 %{
 5679   match(Set dst src);
 5680   effect(KILL cr);
 5681 
 5682   ins_cost(50);
 5683   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5684   opcode(0x33); /* + rd */
 5685   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5686   ins_pipe(ialu_reg);
 5687 %}
 5688 
 5689 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5690 %{
 5691   match(Set dst src);
 5692   effect(KILL cr);
 5693 
 5694   ins_cost(60);
 5695   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5696   ins_encode(load_immP31(dst, src));
 5697   ins_pipe(ialu_reg);
 5698 %}
 5699 
 5700 instruct loadConF(regF dst, immF con) %{
 5701   match(Set dst con);
 5702   ins_cost(125);
 5703   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5704   ins_encode %{
 5705     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5706   %}
 5707   ins_pipe(pipe_slow);
 5708 %}
 5709 
 5710 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5711   match(Set dst src);
 5712   effect(KILL cr);
 5713   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5714   ins_encode %{
 5715     __ xorq($dst$$Register, $dst$$Register);
 5716   %}
 5717   ins_pipe(ialu_reg);
 5718 %}
 5719 
 5720 instruct loadConN(rRegN dst, immN src) %{
 5721   match(Set dst src);
 5722 
 5723   ins_cost(125);
 5724   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5725   ins_encode %{
 5726     address con = (address)$src$$constant;
 5727     if (con == NULL) {
 5728       ShouldNotReachHere();
 5729     } else {
 5730       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5731     }
 5732   %}
 5733   ins_pipe(ialu_reg_fat); // XXX
 5734 %}
 5735 
 5736 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5737   match(Set dst src);
 5738 
 5739   ins_cost(125);
 5740   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5741   ins_encode %{
 5742     address con = (address)$src$$constant;
 5743     if (con == NULL) {
 5744       ShouldNotReachHere();
 5745     } else {
 5746       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5747     }
 5748   %}
 5749   ins_pipe(ialu_reg_fat); // XXX
 5750 %}
 5751 
 5752 instruct loadConF0(regF dst, immF0 src)
 5753 %{
 5754   match(Set dst src);
 5755   ins_cost(100);
 5756 
 5757   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5758   ins_encode %{
 5759     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5760   %}
 5761   ins_pipe(pipe_slow);
 5762 %}
 5763 
 5764 // Use the same format since predicate() can not be used here.
 5765 instruct loadConD(regD dst, immD con) %{
 5766   match(Set dst con);
 5767   ins_cost(125);
 5768   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5769   ins_encode %{
 5770     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5771   %}
 5772   ins_pipe(pipe_slow);
 5773 %}
 5774 
 5775 instruct loadConD0(regD dst, immD0 src)
 5776 %{
 5777   match(Set dst src);
 5778   ins_cost(100);
 5779 
 5780   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5781   ins_encode %{
 5782     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5783   %}
 5784   ins_pipe(pipe_slow);
 5785 %}
 5786 
 5787 instruct loadSSI(rRegI dst, stackSlotI src)
 5788 %{
 5789   match(Set dst src);
 5790 
 5791   ins_cost(125);
 5792   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5793   opcode(0x8B);
 5794   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5795   ins_pipe(ialu_reg_mem);
 5796 %}
 5797 
 5798 instruct loadSSL(rRegL dst, stackSlotL src)
 5799 %{
 5800   match(Set dst src);
 5801 
 5802   ins_cost(125);
 5803   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5804   opcode(0x8B);
 5805   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5806   ins_pipe(ialu_reg_mem);
 5807 %}
 5808 
 5809 instruct loadSSP(rRegP dst, stackSlotP src)
 5810 %{
 5811   match(Set dst src);
 5812 
 5813   ins_cost(125);
 5814   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5815   opcode(0x8B);
 5816   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5817   ins_pipe(ialu_reg_mem);
 5818 %}
 5819 
 5820 instruct loadSSF(regF dst, stackSlotF src)
 5821 %{
 5822   match(Set dst src);
 5823 
 5824   ins_cost(125);
 5825   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5826   ins_encode %{
 5827     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5828   %}
 5829   ins_pipe(pipe_slow); // XXX
 5830 %}
 5831 
 5832 // Use the same format since predicate() can not be used here.
 5833 instruct loadSSD(regD dst, stackSlotD src)
 5834 %{
 5835   match(Set dst src);
 5836 
 5837   ins_cost(125);
 5838   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5839   ins_encode  %{
 5840     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5841   %}
 5842   ins_pipe(pipe_slow); // XXX
 5843 %}
 5844 
 5845 // Prefetch instructions for allocation.
 5846 // Must be safe to execute with invalid address (cannot fault).
 5847 
 5848 instruct prefetchAlloc( memory mem ) %{
 5849   predicate(AllocatePrefetchInstr==3);
 5850   match(PrefetchAllocation mem);
 5851   ins_cost(125);
 5852 
 5853   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5854   ins_encode %{
 5855     __ prefetchw($mem$$Address);
 5856   %}
 5857   ins_pipe(ialu_mem);
 5858 %}
 5859 
 5860 instruct prefetchAllocNTA( memory mem ) %{
 5861   predicate(AllocatePrefetchInstr==0);
 5862   match(PrefetchAllocation mem);
 5863   ins_cost(125);
 5864 
 5865   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5866   ins_encode %{
 5867     __ prefetchnta($mem$$Address);
 5868   %}
 5869   ins_pipe(ialu_mem);
 5870 %}
 5871 
 5872 instruct prefetchAllocT0( memory mem ) %{
 5873   predicate(AllocatePrefetchInstr==1);
 5874   match(PrefetchAllocation mem);
 5875   ins_cost(125);
 5876 
 5877   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5878   ins_encode %{
 5879     __ prefetcht0($mem$$Address);
 5880   %}
 5881   ins_pipe(ialu_mem);
 5882 %}
 5883 
 5884 instruct prefetchAllocT2( memory mem ) %{
 5885   predicate(AllocatePrefetchInstr==2);
 5886   match(PrefetchAllocation mem);
 5887   ins_cost(125);
 5888 
 5889   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5890   ins_encode %{
 5891     __ prefetcht2($mem$$Address);
 5892   %}
 5893   ins_pipe(ialu_mem);
 5894 %}
 5895 
 5896 //----------Store Instructions-------------------------------------------------
 5897 
 5898 // Store Byte
 5899 instruct storeB(memory mem, rRegI src)
 5900 %{
 5901   match(Set mem (StoreB mem src));
 5902 
 5903   ins_cost(125); // XXX
 5904   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5905   opcode(0x88);
 5906   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5907   ins_pipe(ialu_mem_reg);
 5908 %}
 5909 
 5910 // Store Char/Short
 5911 instruct storeC(memory mem, rRegI src)
 5912 %{
 5913   match(Set mem (StoreC mem src));
 5914 
 5915   ins_cost(125); // XXX
 5916   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5917   opcode(0x89);
 5918   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5919   ins_pipe(ialu_mem_reg);
 5920 %}
 5921 
 5922 // Store Integer
 5923 instruct storeI(memory mem, rRegI src)
 5924 %{
 5925   match(Set mem (StoreI mem src));
 5926 
 5927   ins_cost(125); // XXX
 5928   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5929   opcode(0x89);
 5930   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5931   ins_pipe(ialu_mem_reg);
 5932 %}
 5933 
 5934 // Store Long
 5935 instruct storeL(memory mem, rRegL src)
 5936 %{
 5937   match(Set mem (StoreL mem src));
 5938 
 5939   ins_cost(125); // XXX
 5940   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5941   opcode(0x89);
 5942   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5943   ins_pipe(ialu_mem_reg); // XXX
 5944 %}
 5945 
 5946 // Store Pointer
 5947 instruct storeP(memory mem, any_RegP src)
 5948 %{
 5949   match(Set mem (StoreP mem src));
 5950 
 5951   ins_cost(125); // XXX
 5952   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5953   opcode(0x89);
 5954   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5955   ins_pipe(ialu_mem_reg);
 5956 %}
 5957 
 5958 instruct storeImmP0(memory mem, immP0 zero)
 5959 %{
 5960   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 5961   match(Set mem (StoreP mem zero));
 5962 
 5963   ins_cost(125); // XXX
 5964   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5965   ins_encode %{
 5966     __ movq($mem$$Address, r12);
 5967   %}
 5968   ins_pipe(ialu_mem_reg);
 5969 %}
 5970 
 5971 // Store NULL Pointer, mark word, or other simple pointer constant.
 5972 instruct storeImmP(memory mem, immP31 src)
 5973 %{
 5974   match(Set mem (StoreP mem src));
 5975 
 5976   ins_cost(150); // XXX
 5977   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5978   opcode(0xC7); /* C7 /0 */
 5979   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5980   ins_pipe(ialu_mem_imm);
 5981 %}
 5982 
 5983 // Store Compressed Pointer
 5984 instruct storeN(memory mem, rRegN src)
 5985 %{
 5986   match(Set mem (StoreN mem src));
 5987 
 5988   ins_cost(125); // XXX
 5989   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 5990   ins_encode %{
 5991     __ movl($mem$$Address, $src$$Register);
 5992   %}
 5993   ins_pipe(ialu_mem_reg);
 5994 %}
 5995 
 5996 instruct storeNKlass(memory mem, rRegN src)
 5997 %{
 5998   match(Set mem (StoreNKlass mem src));
 5999 
 6000   ins_cost(125); // XXX
 6001   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6002   ins_encode %{
 6003     __ movl($mem$$Address, $src$$Register);
 6004   %}
 6005   ins_pipe(ialu_mem_reg);
 6006 %}
 6007 
 6008 instruct storeImmN0(memory mem, immN0 zero)
 6009 %{
 6010   predicate(CompressedOops::base() == NULL);
 6011   match(Set mem (StoreN mem zero));
 6012 
 6013   ins_cost(125); // XXX
 6014   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6015   ins_encode %{
 6016     __ movl($mem$$Address, r12);
 6017   %}
 6018   ins_pipe(ialu_mem_reg);
 6019 %}
 6020 
 6021 instruct storeImmN(memory mem, immN src)
 6022 %{
 6023   match(Set mem (StoreN mem src));
 6024 
 6025   ins_cost(150); // XXX
 6026   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6027   ins_encode %{
 6028     address con = (address)$src$$constant;
 6029     if (con == NULL) {
 6030       __ movl($mem$$Address, (int32_t)0);
 6031     } else {
 6032       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6033     }
 6034   %}
 6035   ins_pipe(ialu_mem_imm);
 6036 %}
 6037 
 6038 instruct storeImmNKlass(memory mem, immNKlass src)
 6039 %{
 6040   match(Set mem (StoreNKlass mem src));
 6041 
 6042   ins_cost(150); // XXX
 6043   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6044   ins_encode %{
 6045     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6046   %}
 6047   ins_pipe(ialu_mem_imm);
 6048 %}
 6049 
 6050 // Store Integer Immediate
 6051 instruct storeImmI0(memory mem, immI0 zero)
 6052 %{
 6053   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6054   match(Set mem (StoreI mem zero));
 6055 
 6056   ins_cost(125); // XXX
 6057   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6058   ins_encode %{
 6059     __ movl($mem$$Address, r12);
 6060   %}
 6061   ins_pipe(ialu_mem_reg);
 6062 %}
 6063 
 6064 instruct storeImmI(memory mem, immI src)
 6065 %{
 6066   match(Set mem (StoreI mem src));
 6067 
 6068   ins_cost(150);
 6069   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6070   opcode(0xC7); /* C7 /0 */
 6071   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6072   ins_pipe(ialu_mem_imm);
 6073 %}
 6074 
 6075 // Store Long Immediate
 6076 instruct storeImmL0(memory mem, immL0 zero)
 6077 %{
 6078   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6079   match(Set mem (StoreL mem zero));
 6080 
 6081   ins_cost(125); // XXX
 6082   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6083   ins_encode %{
 6084     __ movq($mem$$Address, r12);
 6085   %}
 6086   ins_pipe(ialu_mem_reg);
 6087 %}
 6088 
 6089 instruct storeImmL(memory mem, immL32 src)
 6090 %{
 6091   match(Set mem (StoreL mem src));
 6092 
 6093   ins_cost(150);
 6094   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6095   opcode(0xC7); /* C7 /0 */
 6096   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6097   ins_pipe(ialu_mem_imm);
 6098 %}
 6099 
 6100 // Store Short/Char Immediate
 6101 instruct storeImmC0(memory mem, immI0 zero)
 6102 %{
 6103   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6104   match(Set mem (StoreC mem zero));
 6105 
 6106   ins_cost(125); // XXX
 6107   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6108   ins_encode %{
 6109     __ movw($mem$$Address, r12);
 6110   %}
 6111   ins_pipe(ialu_mem_reg);
 6112 %}
 6113 
 6114 instruct storeImmI16(memory mem, immI16 src)
 6115 %{
 6116   predicate(UseStoreImmI16);
 6117   match(Set mem (StoreC mem src));
 6118 
 6119   ins_cost(150);
 6120   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6121   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6122   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6123   ins_pipe(ialu_mem_imm);
 6124 %}
 6125 
 6126 // Store Byte Immediate
 6127 instruct storeImmB0(memory mem, immI0 zero)
 6128 %{
 6129   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6130   match(Set mem (StoreB mem zero));
 6131 
 6132   ins_cost(125); // XXX
 6133   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6134   ins_encode %{
 6135     __ movb($mem$$Address, r12);
 6136   %}
 6137   ins_pipe(ialu_mem_reg);
 6138 %}
 6139 
 6140 instruct storeImmB(memory mem, immI8 src)
 6141 %{
 6142   match(Set mem (StoreB mem src));
 6143 
 6144   ins_cost(150); // XXX
 6145   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6146   opcode(0xC6); /* C6 /0 */
 6147   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6148   ins_pipe(ialu_mem_imm);
 6149 %}
 6150 
 6151 // Store CMS card-mark Immediate
 6152 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6153 %{
 6154   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6155   match(Set mem (StoreCM mem zero));
 6156 
 6157   ins_cost(125); // XXX
 6158   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6159   ins_encode %{
 6160     __ movb($mem$$Address, r12);
 6161   %}
 6162   ins_pipe(ialu_mem_reg);
 6163 %}
 6164 
 6165 instruct storeImmCM0(memory mem, immI0 src)
 6166 %{
 6167   match(Set mem (StoreCM mem src));
 6168 
 6169   ins_cost(150); // XXX
 6170   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6171   opcode(0xC6); /* C6 /0 */
 6172   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6173   ins_pipe(ialu_mem_imm);
 6174 %}
 6175 
 6176 // Store Float
 6177 instruct storeF(memory mem, regF src)
 6178 %{
 6179   match(Set mem (StoreF mem src));
 6180 
 6181   ins_cost(95); // XXX
 6182   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6183   ins_encode %{
 6184     __ movflt($mem$$Address, $src$$XMMRegister);
 6185   %}
 6186   ins_pipe(pipe_slow); // XXX
 6187 %}
 6188 
 6189 // Store immediate Float value (it is faster than store from XMM register)
 6190 instruct storeF0(memory mem, immF0 zero)
 6191 %{
 6192   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6193   match(Set mem (StoreF mem zero));
 6194 
 6195   ins_cost(25); // XXX
 6196   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6197   ins_encode %{
 6198     __ movl($mem$$Address, r12);
 6199   %}
 6200   ins_pipe(ialu_mem_reg);
 6201 %}
 6202 
 6203 instruct storeF_imm(memory mem, immF src)
 6204 %{
 6205   match(Set mem (StoreF mem src));
 6206 
 6207   ins_cost(50);
 6208   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6209   opcode(0xC7); /* C7 /0 */
 6210   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6211   ins_pipe(ialu_mem_imm);
 6212 %}
 6213 
 6214 // Store Double
 6215 instruct storeD(memory mem, regD src)
 6216 %{
 6217   match(Set mem (StoreD mem src));
 6218 
 6219   ins_cost(95); // XXX
 6220   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6221   ins_encode %{
 6222     __ movdbl($mem$$Address, $src$$XMMRegister);
 6223   %}
 6224   ins_pipe(pipe_slow); // XXX
 6225 %}
 6226 
 6227 // Store immediate double 0.0 (it is faster than store from XMM register)
 6228 instruct storeD0_imm(memory mem, immD0 src)
 6229 %{
 6230   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6231   match(Set mem (StoreD mem src));
 6232 
 6233   ins_cost(50);
 6234   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6235   opcode(0xC7); /* C7 /0 */
 6236   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6237   ins_pipe(ialu_mem_imm);
 6238 %}
 6239 
 6240 instruct storeD0(memory mem, immD0 zero)
 6241 %{
 6242   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6243   match(Set mem (StoreD mem zero));
 6244 
 6245   ins_cost(25); // XXX
 6246   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6247   ins_encode %{
 6248     __ movq($mem$$Address, r12);
 6249   %}
 6250   ins_pipe(ialu_mem_reg);
 6251 %}
 6252 
 6253 instruct storeSSI(stackSlotI dst, rRegI src)
 6254 %{
 6255   match(Set dst src);
 6256 
 6257   ins_cost(100);
 6258   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6259   opcode(0x89);
 6260   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6261   ins_pipe( ialu_mem_reg );
 6262 %}
 6263 
 6264 instruct storeSSL(stackSlotL dst, rRegL src)
 6265 %{
 6266   match(Set dst src);
 6267 
 6268   ins_cost(100);
 6269   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6270   opcode(0x89);
 6271   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6272   ins_pipe(ialu_mem_reg);
 6273 %}
 6274 
 6275 instruct storeSSP(stackSlotP dst, rRegP src)
 6276 %{
 6277   match(Set dst src);
 6278 
 6279   ins_cost(100);
 6280   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6281   opcode(0x89);
 6282   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6283   ins_pipe(ialu_mem_reg);
 6284 %}
 6285 
 6286 instruct storeSSF(stackSlotF dst, regF src)
 6287 %{
 6288   match(Set dst src);
 6289 
 6290   ins_cost(95); // XXX
 6291   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6292   ins_encode %{
 6293     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6294   %}
 6295   ins_pipe(pipe_slow); // XXX
 6296 %}
 6297 
 6298 instruct storeSSD(stackSlotD dst, regD src)
 6299 %{
 6300   match(Set dst src);
 6301 
 6302   ins_cost(95); // XXX
 6303   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6304   ins_encode %{
 6305     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6306   %}
 6307   ins_pipe(pipe_slow); // XXX
 6308 %}
 6309 
 6310 instruct cacheWB(indirect addr)
 6311 %{
 6312   predicate(VM_Version::supports_data_cache_line_flush());
 6313   match(CacheWB addr);
 6314 
 6315   ins_cost(100);
 6316   format %{&quot;cache wb $addr&quot; %}
 6317   ins_encode %{
 6318     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6319     assert($addr$$disp == 0, &quot;should be&quot;);
 6320     __ cache_wb(Address($addr$$base$$Register, 0));
 6321   %}
 6322   ins_pipe(pipe_slow); // XXX
 6323 %}
 6324 
 6325 instruct cacheWBPreSync()
 6326 %{
 6327   predicate(VM_Version::supports_data_cache_line_flush());
 6328   match(CacheWBPreSync);
 6329 
 6330   ins_cost(100);
 6331   format %{&quot;cache wb presync&quot; %}
 6332   ins_encode %{
 6333     __ cache_wbsync(true);
 6334   %}
 6335   ins_pipe(pipe_slow); // XXX
 6336 %}
 6337 
 6338 instruct cacheWBPostSync()
 6339 %{
 6340   predicate(VM_Version::supports_data_cache_line_flush());
 6341   match(CacheWBPostSync);
 6342 
 6343   ins_cost(100);
 6344   format %{&quot;cache wb postsync&quot; %}
 6345   ins_encode %{
 6346     __ cache_wbsync(false);
 6347   %}
 6348   ins_pipe(pipe_slow); // XXX
 6349 %}
 6350 
 6351 //----------BSWAP Instructions-------------------------------------------------
 6352 instruct bytes_reverse_int(rRegI dst) %{
 6353   match(Set dst (ReverseBytesI dst));
 6354 
 6355   format %{ &quot;bswapl  $dst&quot; %}
 6356   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6357   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6358   ins_pipe( ialu_reg );
 6359 %}
 6360 
 6361 instruct bytes_reverse_long(rRegL dst) %{
 6362   match(Set dst (ReverseBytesL dst));
 6363 
 6364   format %{ &quot;bswapq  $dst&quot; %}
 6365   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6366   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6367   ins_pipe( ialu_reg);
 6368 %}
 6369 
 6370 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6371   match(Set dst (ReverseBytesUS dst));
 6372   effect(KILL cr);
 6373 
 6374   format %{ &quot;bswapl  $dst\n\t&quot;
 6375             &quot;shrl    $dst,16\n\t&quot; %}
 6376   ins_encode %{
 6377     __ bswapl($dst$$Register);
 6378     __ shrl($dst$$Register, 16);
 6379   %}
 6380   ins_pipe( ialu_reg );
 6381 %}
 6382 
 6383 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6384   match(Set dst (ReverseBytesS dst));
 6385   effect(KILL cr);
 6386 
 6387   format %{ &quot;bswapl  $dst\n\t&quot;
 6388             &quot;sar     $dst,16\n\t&quot; %}
 6389   ins_encode %{
 6390     __ bswapl($dst$$Register);
 6391     __ sarl($dst$$Register, 16);
 6392   %}
 6393   ins_pipe( ialu_reg );
 6394 %}
 6395 
 6396 //---------- Zeros Count Instructions ------------------------------------------
 6397 
 6398 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6399   predicate(UseCountLeadingZerosInstruction);
 6400   match(Set dst (CountLeadingZerosI src));
 6401   effect(KILL cr);
 6402 
 6403   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6404   ins_encode %{
 6405     __ lzcntl($dst$$Register, $src$$Register);
 6406   %}
 6407   ins_pipe(ialu_reg);
 6408 %}
 6409 
 6410 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6411   predicate(!UseCountLeadingZerosInstruction);
 6412   match(Set dst (CountLeadingZerosI src));
 6413   effect(KILL cr);
 6414 
 6415   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6416             &quot;jnz     skip\n\t&quot;
 6417             &quot;movl    $dst, -1\n&quot;
 6418       &quot;skip:\n\t&quot;
 6419             &quot;negl    $dst\n\t&quot;
 6420             &quot;addl    $dst, 31&quot; %}
 6421   ins_encode %{
 6422     Register Rdst = $dst$$Register;
 6423     Register Rsrc = $src$$Register;
 6424     Label skip;
 6425     __ bsrl(Rdst, Rsrc);
 6426     __ jccb(Assembler::notZero, skip);
 6427     __ movl(Rdst, -1);
 6428     __ bind(skip);
 6429     __ negl(Rdst);
 6430     __ addl(Rdst, BitsPerInt - 1);
 6431   %}
 6432   ins_pipe(ialu_reg);
 6433 %}
 6434 
 6435 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6436   predicate(UseCountLeadingZerosInstruction);
 6437   match(Set dst (CountLeadingZerosL src));
 6438   effect(KILL cr);
 6439 
 6440   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6441   ins_encode %{
 6442     __ lzcntq($dst$$Register, $src$$Register);
 6443   %}
 6444   ins_pipe(ialu_reg);
 6445 %}
 6446 
 6447 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6448   predicate(!UseCountLeadingZerosInstruction);
 6449   match(Set dst (CountLeadingZerosL src));
 6450   effect(KILL cr);
 6451 
 6452   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6453             &quot;jnz     skip\n\t&quot;
 6454             &quot;movl    $dst, -1\n&quot;
 6455       &quot;skip:\n\t&quot;
 6456             &quot;negl    $dst\n\t&quot;
 6457             &quot;addl    $dst, 63&quot; %}
 6458   ins_encode %{
 6459     Register Rdst = $dst$$Register;
 6460     Register Rsrc = $src$$Register;
 6461     Label skip;
 6462     __ bsrq(Rdst, Rsrc);
 6463     __ jccb(Assembler::notZero, skip);
 6464     __ movl(Rdst, -1);
 6465     __ bind(skip);
 6466     __ negl(Rdst);
 6467     __ addl(Rdst, BitsPerLong - 1);
 6468   %}
 6469   ins_pipe(ialu_reg);
 6470 %}
 6471 
 6472 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6473   predicate(UseCountTrailingZerosInstruction);
 6474   match(Set dst (CountTrailingZerosI src));
 6475   effect(KILL cr);
 6476 
 6477   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6478   ins_encode %{
 6479     __ tzcntl($dst$$Register, $src$$Register);
 6480   %}
 6481   ins_pipe(ialu_reg);
 6482 %}
 6483 
 6484 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6485   predicate(!UseCountTrailingZerosInstruction);
 6486   match(Set dst (CountTrailingZerosI src));
 6487   effect(KILL cr);
 6488 
 6489   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6490             &quot;jnz     done\n\t&quot;
 6491             &quot;movl    $dst, 32\n&quot;
 6492       &quot;done:&quot; %}
 6493   ins_encode %{
 6494     Register Rdst = $dst$$Register;
 6495     Label done;
 6496     __ bsfl(Rdst, $src$$Register);
 6497     __ jccb(Assembler::notZero, done);
 6498     __ movl(Rdst, BitsPerInt);
 6499     __ bind(done);
 6500   %}
 6501   ins_pipe(ialu_reg);
 6502 %}
 6503 
 6504 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6505   predicate(UseCountTrailingZerosInstruction);
 6506   match(Set dst (CountTrailingZerosL src));
 6507   effect(KILL cr);
 6508 
 6509   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6510   ins_encode %{
 6511     __ tzcntq($dst$$Register, $src$$Register);
 6512   %}
 6513   ins_pipe(ialu_reg);
 6514 %}
 6515 
 6516 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6517   predicate(!UseCountTrailingZerosInstruction);
 6518   match(Set dst (CountTrailingZerosL src));
 6519   effect(KILL cr);
 6520 
 6521   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6522             &quot;jnz     done\n\t&quot;
 6523             &quot;movl    $dst, 64\n&quot;
 6524       &quot;done:&quot; %}
 6525   ins_encode %{
 6526     Register Rdst = $dst$$Register;
 6527     Label done;
 6528     __ bsfq(Rdst, $src$$Register);
 6529     __ jccb(Assembler::notZero, done);
 6530     __ movl(Rdst, BitsPerLong);
 6531     __ bind(done);
 6532   %}
 6533   ins_pipe(ialu_reg);
 6534 %}
 6535 
 6536 
 6537 //---------- Population Count Instructions -------------------------------------
 6538 
 6539 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6540   predicate(UsePopCountInstruction);
 6541   match(Set dst (PopCountI src));
 6542   effect(KILL cr);
 6543 
 6544   format %{ &quot;popcnt  $dst, $src&quot; %}
 6545   ins_encode %{
 6546     __ popcntl($dst$$Register, $src$$Register);
 6547   %}
 6548   ins_pipe(ialu_reg);
 6549 %}
 6550 
 6551 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6552   predicate(UsePopCountInstruction);
 6553   match(Set dst (PopCountI (LoadI mem)));
 6554   effect(KILL cr);
 6555 
 6556   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6557   ins_encode %{
 6558     __ popcntl($dst$$Register, $mem$$Address);
 6559   %}
 6560   ins_pipe(ialu_reg);
 6561 %}
 6562 
 6563 // Note: Long.bitCount(long) returns an int.
 6564 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6565   predicate(UsePopCountInstruction);
 6566   match(Set dst (PopCountL src));
 6567   effect(KILL cr);
 6568 
 6569   format %{ &quot;popcnt  $dst, $src&quot; %}
 6570   ins_encode %{
 6571     __ popcntq($dst$$Register, $src$$Register);
 6572   %}
 6573   ins_pipe(ialu_reg);
 6574 %}
 6575 
 6576 // Note: Long.bitCount(long) returns an int.
 6577 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6578   predicate(UsePopCountInstruction);
 6579   match(Set dst (PopCountL (LoadL mem)));
 6580   effect(KILL cr);
 6581 
 6582   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6583   ins_encode %{
 6584     __ popcntq($dst$$Register, $mem$$Address);
 6585   %}
 6586   ins_pipe(ialu_reg);
 6587 %}
 6588 
 6589 
 6590 //----------MemBar Instructions-----------------------------------------------
 6591 // Memory barrier flavors
 6592 
 6593 instruct membar_acquire()
 6594 %{
 6595   match(MemBarAcquire);
 6596   match(LoadFence);
 6597   ins_cost(0);
 6598 
 6599   size(0);
 6600   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6601   ins_encode();
 6602   ins_pipe(empty);
 6603 %}
 6604 
 6605 instruct membar_acquire_lock()
 6606 %{
 6607   match(MemBarAcquireLock);
 6608   ins_cost(0);
 6609 
 6610   size(0);
 6611   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6612   ins_encode();
 6613   ins_pipe(empty);
 6614 %}
 6615 
 6616 instruct membar_release()
 6617 %{
 6618   match(MemBarRelease);
 6619   match(StoreFence);
 6620   ins_cost(0);
 6621 
 6622   size(0);
 6623   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6624   ins_encode();
 6625   ins_pipe(empty);
 6626 %}
 6627 
 6628 instruct membar_release_lock()
 6629 %{
 6630   match(MemBarReleaseLock);
 6631   ins_cost(0);
 6632 
 6633   size(0);
 6634   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6635   ins_encode();
 6636   ins_pipe(empty);
 6637 %}
 6638 
 6639 instruct membar_volatile(rFlagsReg cr) %{
 6640   match(MemBarVolatile);
 6641   effect(KILL cr);
 6642   ins_cost(400);
 6643 
 6644   format %{
 6645     $$template
 6646     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6647   %}
 6648   ins_encode %{
 6649     __ membar(Assembler::StoreLoad);
 6650   %}
 6651   ins_pipe(pipe_slow);
 6652 %}
 6653 
 6654 instruct unnecessary_membar_volatile()
 6655 %{
 6656   match(MemBarVolatile);
 6657   predicate(Matcher::post_store_load_barrier(n));
 6658   ins_cost(0);
 6659 
 6660   size(0);
 6661   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6662   ins_encode();
 6663   ins_pipe(empty);
 6664 %}
 6665 
 6666 instruct membar_storestore() %{
 6667   match(MemBarStoreStore);
 6668   ins_cost(0);
 6669 
 6670   size(0);
 6671   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6672   ins_encode( );
 6673   ins_pipe(empty);
 6674 %}
 6675 
 6676 //----------Move Instructions--------------------------------------------------
 6677 
 6678 instruct castX2P(rRegP dst, rRegL src)
 6679 %{
 6680   match(Set dst (CastX2P src));
 6681 
 6682   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6683   ins_encode %{
 6684     if ($dst$$reg != $src$$reg) {
 6685       __ movptr($dst$$Register, $src$$Register);
 6686     }
 6687   %}
 6688   ins_pipe(ialu_reg_reg); // XXX
 6689 %}
 6690 
 6691 instruct castP2X(rRegL dst, rRegP src)
 6692 %{
 6693   match(Set dst (CastP2X src));
 6694 
 6695   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6696   ins_encode %{
 6697     if ($dst$$reg != $src$$reg) {
 6698       __ movptr($dst$$Register, $src$$Register);
 6699     }
 6700   %}
 6701   ins_pipe(ialu_reg_reg); // XXX
 6702 %}
 6703 
 6704 // Convert oop into int for vectors alignment masking
 6705 instruct convP2I(rRegI dst, rRegP src)
 6706 %{
 6707   match(Set dst (ConvL2I (CastP2X src)));
 6708 
 6709   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6710   ins_encode %{
 6711     __ movl($dst$$Register, $src$$Register);
 6712   %}
 6713   ins_pipe(ialu_reg_reg); // XXX
 6714 %}
 6715 
 6716 // Convert compressed oop into int for vectors alignment masking
 6717 // in case of 32bit oops (heap &lt; 4Gb).
 6718 instruct convN2I(rRegI dst, rRegN src)
 6719 %{
 6720   predicate(CompressedOops::shift() == 0);
 6721   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6722 
 6723   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6724   ins_encode %{
 6725     __ movl($dst$$Register, $src$$Register);
 6726   %}
 6727   ins_pipe(ialu_reg_reg); // XXX
 6728 %}
 6729 
 6730 // Convert oop pointer into compressed form
 6731 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6732   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6733   match(Set dst (EncodeP src));
 6734   effect(KILL cr);
 6735   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6736   ins_encode %{
 6737     Register s = $src$$Register;
 6738     Register d = $dst$$Register;
 6739     if (s != d) {
 6740       __ movq(d, s);
 6741     }
 6742     __ encode_heap_oop(d);
 6743   %}
 6744   ins_pipe(ialu_reg_long);
 6745 %}
 6746 
 6747 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6748   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6749   match(Set dst (EncodeP src));
 6750   effect(KILL cr);
 6751   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6752   ins_encode %{
 6753     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6754   %}
 6755   ins_pipe(ialu_reg_long);
 6756 %}
 6757 
 6758 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6759   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6760             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6761   match(Set dst (DecodeN src));
 6762   effect(KILL cr);
 6763   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6764   ins_encode %{
 6765     Register s = $src$$Register;
 6766     Register d = $dst$$Register;
 6767     if (s != d) {
 6768       __ movq(d, s);
 6769     }
 6770     __ decode_heap_oop(d);
 6771   %}
 6772   ins_pipe(ialu_reg_long);
 6773 %}
 6774 
 6775 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6776   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6777             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6778   match(Set dst (DecodeN src));
 6779   effect(KILL cr);
 6780   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6781   ins_encode %{
 6782     Register s = $src$$Register;
 6783     Register d = $dst$$Register;
 6784     if (s != d) {
 6785       __ decode_heap_oop_not_null(d, s);
 6786     } else {
 6787       __ decode_heap_oop_not_null(d);
 6788     }
 6789   %}
 6790   ins_pipe(ialu_reg_long);
 6791 %}
 6792 
 6793 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6794   match(Set dst (EncodePKlass src));
 6795   effect(TEMP dst, KILL cr);
 6796   format %{ &quot;encode_and_move_klass_not_null $dst,$src&quot; %}
 6797   ins_encode %{
 6798     __ encode_and_move_klass_not_null($dst$$Register, $src$$Register);
 6799   %}
 6800   ins_pipe(ialu_reg_long);
 6801 %}
 6802 
 6803 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6804   match(Set dst (DecodeNKlass src));
 6805   effect(TEMP dst, KILL cr);
 6806   format %{ &quot;decode_and_move_klass_not_null $dst,$src&quot; %}
 6807   ins_encode %{
 6808     __ decode_and_move_klass_not_null($dst$$Register, $src$$Register);
 6809   %}
 6810   ins_pipe(ialu_reg_long);
 6811 %}
 6812 
 6813 //----------Conditional Move---------------------------------------------------
 6814 // Jump
 6815 // dummy instruction for generating temp registers
 6816 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6817   match(Jump (LShiftL switch_val shift));
 6818   ins_cost(350);
 6819   predicate(false);
 6820   effect(TEMP dest);
 6821 
 6822   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6823             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6824   ins_encode %{
 6825     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6826     // to do that and the compiler is using that register as one it can allocate.
 6827     // So we build it all by hand.
 6828     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6829     // ArrayAddress dispatch(table, index);
 6830     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6831     __ lea($dest$$Register, $constantaddress);
 6832     __ jmp(dispatch);
 6833   %}
 6834   ins_pipe(pipe_jmp);
 6835 %}
 6836 
 6837 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6838   match(Jump (AddL (LShiftL switch_val shift) offset));
 6839   ins_cost(350);
 6840   effect(TEMP dest);
 6841 
 6842   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6843             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6844   ins_encode %{
 6845     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6846     // to do that and the compiler is using that register as one it can allocate.
 6847     // So we build it all by hand.
 6848     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6849     // ArrayAddress dispatch(table, index);
 6850     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6851     __ lea($dest$$Register, $constantaddress);
 6852     __ jmp(dispatch);
 6853   %}
 6854   ins_pipe(pipe_jmp);
 6855 %}
 6856 
 6857 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6858   match(Jump switch_val);
 6859   ins_cost(350);
 6860   effect(TEMP dest);
 6861 
 6862   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6863             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6864   ins_encode %{
 6865     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6866     // to do that and the compiler is using that register as one it can allocate.
 6867     // So we build it all by hand.
 6868     // Address index(noreg, switch_reg, Address::times_1);
 6869     // ArrayAddress dispatch(table, index);
 6870     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6871     __ lea($dest$$Register, $constantaddress);
 6872     __ jmp(dispatch);
 6873   %}
 6874   ins_pipe(pipe_jmp);
 6875 %}
 6876 
 6877 // Conditional move
 6878 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6879 %{
 6880   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6881 
 6882   ins_cost(200); // XXX
 6883   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6884   opcode(0x0F, 0x40);
 6885   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6886   ins_pipe(pipe_cmov_reg);
 6887 %}
 6888 
 6889 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6890   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6891 
 6892   ins_cost(200); // XXX
 6893   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6894   opcode(0x0F, 0x40);
 6895   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6896   ins_pipe(pipe_cmov_reg);
 6897 %}
 6898 
 6899 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6900   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6901   ins_cost(200);
 6902   expand %{
 6903     cmovI_regU(cop, cr, dst, src);
 6904   %}
 6905 %}
 6906 
 6907 // Conditional move
 6908 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6909   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6910 
 6911   ins_cost(250); // XXX
 6912   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6913   opcode(0x0F, 0x40);
 6914   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6915   ins_pipe(pipe_cmov_mem);
 6916 %}
 6917 
 6918 // Conditional move
 6919 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 6920 %{
 6921   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6922 
 6923   ins_cost(250); // XXX
 6924   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6925   opcode(0x0F, 0x40);
 6926   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6927   ins_pipe(pipe_cmov_mem);
 6928 %}
 6929 
 6930 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 6931   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6932   ins_cost(250);
 6933   expand %{
 6934     cmovI_memU(cop, cr, dst, src);
 6935   %}
 6936 %}
 6937 
 6938 // Conditional move
 6939 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 6940 %{
 6941   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6942 
 6943   ins_cost(200); // XXX
 6944   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 6945   opcode(0x0F, 0x40);
 6946   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6947   ins_pipe(pipe_cmov_reg);
 6948 %}
 6949 
 6950 // Conditional move
 6951 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 6952 %{
 6953   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6954 
 6955   ins_cost(200); // XXX
 6956   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 6957   opcode(0x0F, 0x40);
 6958   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6959   ins_pipe(pipe_cmov_reg);
 6960 %}
 6961 
 6962 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 6963   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6964   ins_cost(200);
 6965   expand %{
 6966     cmovN_regU(cop, cr, dst, src);
 6967   %}
 6968 %}
 6969 
 6970 // Conditional move
 6971 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 6972 %{
 6973   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6974 
 6975   ins_cost(200); // XXX
 6976   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 6977   opcode(0x0F, 0x40);
 6978   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6979   ins_pipe(pipe_cmov_reg);  // XXX
 6980 %}
 6981 
 6982 // Conditional move
 6983 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 6984 %{
 6985   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6986 
 6987   ins_cost(200); // XXX
 6988   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 6989   opcode(0x0F, 0x40);
 6990   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6991   ins_pipe(pipe_cmov_reg); // XXX
 6992 %}
 6993 
 6994 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 6995   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6996   ins_cost(200);
 6997   expand %{
 6998     cmovP_regU(cop, cr, dst, src);
 6999   %}
 7000 %}
 7001 
 7002 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7003 // correctly meets the two pointer arguments; one is an incoming
 7004 // register but the other is a memory operand.  ALSO appears to
 7005 // be buggy with implicit null checks.
 7006 //
 7007 //// Conditional move
 7008 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7009 //%{
 7010 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7011 //  ins_cost(250);
 7012 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7013 //  opcode(0x0F,0x40);
 7014 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7015 //  ins_pipe( pipe_cmov_mem );
 7016 //%}
 7017 //
 7018 //// Conditional move
 7019 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7020 //%{
 7021 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7022 //  ins_cost(250);
 7023 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7024 //  opcode(0x0F,0x40);
 7025 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7026 //  ins_pipe( pipe_cmov_mem );
 7027 //%}
 7028 
 7029 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7030 %{
 7031   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7032 
 7033   ins_cost(200); // XXX
 7034   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7035   opcode(0x0F, 0x40);
 7036   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7037   ins_pipe(pipe_cmov_reg);  // XXX
 7038 %}
 7039 
 7040 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7041 %{
 7042   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7043 
 7044   ins_cost(200); // XXX
 7045   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7046   opcode(0x0F, 0x40);
 7047   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7048   ins_pipe(pipe_cmov_mem);  // XXX
 7049 %}
 7050 
 7051 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7052 %{
 7053   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7054 
 7055   ins_cost(200); // XXX
 7056   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7057   opcode(0x0F, 0x40);
 7058   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7059   ins_pipe(pipe_cmov_reg); // XXX
 7060 %}
 7061 
 7062 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7063   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7064   ins_cost(200);
 7065   expand %{
 7066     cmovL_regU(cop, cr, dst, src);
 7067   %}
 7068 %}
 7069 
 7070 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7071 %{
 7072   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7073 
 7074   ins_cost(200); // XXX
 7075   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7076   opcode(0x0F, 0x40);
 7077   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7078   ins_pipe(pipe_cmov_mem); // XXX
 7079 %}
 7080 
 7081 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7082   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7083   ins_cost(200);
 7084   expand %{
 7085     cmovL_memU(cop, cr, dst, src);
 7086   %}
 7087 %}
 7088 
 7089 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7090 %{
 7091   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7092 
 7093   ins_cost(200); // XXX
 7094   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7095             &quot;movss     $dst, $src\n&quot;
 7096     &quot;skip:&quot; %}
 7097   ins_encode %{
 7098     Label Lskip;
 7099     // Invert sense of branch from sense of CMOV
 7100     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7101     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7102     __ bind(Lskip);
 7103   %}
 7104   ins_pipe(pipe_slow);
 7105 %}
 7106 
 7107 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7108 // %{
 7109 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7110 
 7111 //   ins_cost(200); // XXX
 7112 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7113 //             &quot;movss     $dst, $src\n&quot;
 7114 //     &quot;skip:&quot; %}
 7115 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7116 //   ins_pipe(pipe_slow);
 7117 // %}
 7118 
 7119 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7120 %{
 7121   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7122 
 7123   ins_cost(200); // XXX
 7124   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7125             &quot;movss     $dst, $src\n&quot;
 7126     &quot;skip:&quot; %}
 7127   ins_encode %{
 7128     Label Lskip;
 7129     // Invert sense of branch from sense of CMOV
 7130     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7131     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7132     __ bind(Lskip);
 7133   %}
 7134   ins_pipe(pipe_slow);
 7135 %}
 7136 
 7137 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7138   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7139   ins_cost(200);
 7140   expand %{
 7141     cmovF_regU(cop, cr, dst, src);
 7142   %}
 7143 %}
 7144 
 7145 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7146 %{
 7147   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7148 
 7149   ins_cost(200); // XXX
 7150   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7151             &quot;movsd     $dst, $src\n&quot;
 7152     &quot;skip:&quot; %}
 7153   ins_encode %{
 7154     Label Lskip;
 7155     // Invert sense of branch from sense of CMOV
 7156     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7157     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7158     __ bind(Lskip);
 7159   %}
 7160   ins_pipe(pipe_slow);
 7161 %}
 7162 
 7163 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7164 %{
 7165   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7166 
 7167   ins_cost(200); // XXX
 7168   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7169             &quot;movsd     $dst, $src\n&quot;
 7170     &quot;skip:&quot; %}
 7171   ins_encode %{
 7172     Label Lskip;
 7173     // Invert sense of branch from sense of CMOV
 7174     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7175     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7176     __ bind(Lskip);
 7177   %}
 7178   ins_pipe(pipe_slow);
 7179 %}
 7180 
 7181 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7182   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7183   ins_cost(200);
 7184   expand %{
 7185     cmovD_regU(cop, cr, dst, src);
 7186   %}
 7187 %}
 7188 
 7189 //----------Arithmetic Instructions--------------------------------------------
 7190 //----------Addition Instructions----------------------------------------------
 7191 
 7192 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7193 %{
 7194   match(Set dst (AddI dst src));
 7195   effect(KILL cr);
 7196 
 7197   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7198   opcode(0x03);
 7199   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7200   ins_pipe(ialu_reg_reg);
 7201 %}
 7202 
 7203 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7204 %{
 7205   match(Set dst (AddI dst src));
 7206   effect(KILL cr);
 7207 
 7208   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7209   opcode(0x81, 0x00); /* /0 id */
 7210   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7211   ins_pipe( ialu_reg );
 7212 %}
 7213 
 7214 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7215 %{
 7216   match(Set dst (AddI dst (LoadI src)));
 7217   effect(KILL cr);
 7218 
 7219   ins_cost(125); // XXX
 7220   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7221   opcode(0x03);
 7222   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7223   ins_pipe(ialu_reg_mem);
 7224 %}
 7225 
 7226 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7227 %{
 7228   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7229   effect(KILL cr);
 7230 
 7231   ins_cost(150); // XXX
 7232   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7233   opcode(0x01); /* Opcode 01 /r */
 7234   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7235   ins_pipe(ialu_mem_reg);
 7236 %}
 7237 
 7238 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7239 %{
 7240   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7241   effect(KILL cr);
 7242 
 7243   ins_cost(125); // XXX
 7244   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7245   opcode(0x81); /* Opcode 81 /0 id */
 7246   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7247   ins_pipe(ialu_mem_imm);
 7248 %}
 7249 
 7250 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7251 %{
 7252   predicate(UseIncDec);
 7253   match(Set dst (AddI dst src));
 7254   effect(KILL cr);
 7255 
 7256   format %{ &quot;incl    $dst\t# int&quot; %}
 7257   opcode(0xFF, 0x00); // FF /0
 7258   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7259   ins_pipe(ialu_reg);
 7260 %}
 7261 
 7262 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7263 %{
 7264   predicate(UseIncDec);
 7265   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7266   effect(KILL cr);
 7267 
 7268   ins_cost(125); // XXX
 7269   format %{ &quot;incl    $dst\t# int&quot; %}
 7270   opcode(0xFF); /* Opcode FF /0 */
 7271   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7272   ins_pipe(ialu_mem_imm);
 7273 %}
 7274 
 7275 // XXX why does that use AddI
 7276 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7277 %{
 7278   predicate(UseIncDec);
 7279   match(Set dst (AddI dst src));
 7280   effect(KILL cr);
 7281 
 7282   format %{ &quot;decl    $dst\t# int&quot; %}
 7283   opcode(0xFF, 0x01); // FF /1
 7284   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7285   ins_pipe(ialu_reg);
 7286 %}
 7287 
 7288 // XXX why does that use AddI
 7289 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7290 %{
 7291   predicate(UseIncDec);
 7292   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7293   effect(KILL cr);
 7294 
 7295   ins_cost(125); // XXX
 7296   format %{ &quot;decl    $dst\t# int&quot; %}
 7297   opcode(0xFF); /* Opcode FF /1 */
 7298   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7299   ins_pipe(ialu_mem_imm);
 7300 %}
 7301 
 7302 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7303 %{
 7304   match(Set dst (AddI src0 src1));
 7305 
 7306   ins_cost(110);
 7307   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7308   opcode(0x8D); /* 0x8D /r */
 7309   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7310   ins_pipe(ialu_reg_reg);
 7311 %}
 7312 
 7313 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7314 %{
 7315   match(Set dst (AddL dst src));
 7316   effect(KILL cr);
 7317 
 7318   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7319   opcode(0x03);
 7320   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7321   ins_pipe(ialu_reg_reg);
 7322 %}
 7323 
 7324 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7325 %{
 7326   match(Set dst (AddL dst src));
 7327   effect(KILL cr);
 7328 
 7329   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7330   opcode(0x81, 0x00); /* /0 id */
 7331   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7332   ins_pipe( ialu_reg );
 7333 %}
 7334 
 7335 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7336 %{
 7337   match(Set dst (AddL dst (LoadL src)));
 7338   effect(KILL cr);
 7339 
 7340   ins_cost(125); // XXX
 7341   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7342   opcode(0x03);
 7343   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7344   ins_pipe(ialu_reg_mem);
 7345 %}
 7346 
 7347 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7348 %{
 7349   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7350   effect(KILL cr);
 7351 
 7352   ins_cost(150); // XXX
 7353   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7354   opcode(0x01); /* Opcode 01 /r */
 7355   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7356   ins_pipe(ialu_mem_reg);
 7357 %}
 7358 
 7359 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7360 %{
 7361   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7362   effect(KILL cr);
 7363 
 7364   ins_cost(125); // XXX
 7365   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7366   opcode(0x81); /* Opcode 81 /0 id */
 7367   ins_encode(REX_mem_wide(dst),
 7368              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7369   ins_pipe(ialu_mem_imm);
 7370 %}
 7371 
 7372 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7373 %{
 7374   predicate(UseIncDec);
 7375   match(Set dst (AddL dst src));
 7376   effect(KILL cr);
 7377 
 7378   format %{ &quot;incq    $dst\t# long&quot; %}
 7379   opcode(0xFF, 0x00); // FF /0
 7380   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7381   ins_pipe(ialu_reg);
 7382 %}
 7383 
 7384 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7385 %{
 7386   predicate(UseIncDec);
 7387   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7388   effect(KILL cr);
 7389 
 7390   ins_cost(125); // XXX
 7391   format %{ &quot;incq    $dst\t# long&quot; %}
 7392   opcode(0xFF); /* Opcode FF /0 */
 7393   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7394   ins_pipe(ialu_mem_imm);
 7395 %}
 7396 
 7397 // XXX why does that use AddL
 7398 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7399 %{
 7400   predicate(UseIncDec);
 7401   match(Set dst (AddL dst src));
 7402   effect(KILL cr);
 7403 
 7404   format %{ &quot;decq    $dst\t# long&quot; %}
 7405   opcode(0xFF, 0x01); // FF /1
 7406   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7407   ins_pipe(ialu_reg);
 7408 %}
 7409 
 7410 // XXX why does that use AddL
 7411 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7412 %{
 7413   predicate(UseIncDec);
 7414   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7415   effect(KILL cr);
 7416 
 7417   ins_cost(125); // XXX
 7418   format %{ &quot;decq    $dst\t# long&quot; %}
 7419   opcode(0xFF); /* Opcode FF /1 */
 7420   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7421   ins_pipe(ialu_mem_imm);
 7422 %}
 7423 
 7424 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7425 %{
 7426   match(Set dst (AddL src0 src1));
 7427 
 7428   ins_cost(110);
 7429   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7430   opcode(0x8D); /* 0x8D /r */
 7431   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7432   ins_pipe(ialu_reg_reg);
 7433 %}
 7434 
 7435 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7436 %{
 7437   match(Set dst (AddP dst src));
 7438   effect(KILL cr);
 7439 
 7440   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7441   opcode(0x03);
 7442   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7443   ins_pipe(ialu_reg_reg);
 7444 %}
 7445 
 7446 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7447 %{
 7448   match(Set dst (AddP dst src));
 7449   effect(KILL cr);
 7450 
 7451   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7452   opcode(0x81, 0x00); /* /0 id */
 7453   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7454   ins_pipe( ialu_reg );
 7455 %}
 7456 
 7457 // XXX addP mem ops ????
 7458 
 7459 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7460 %{
 7461   match(Set dst (AddP src0 src1));
 7462 
 7463   ins_cost(110);
 7464   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7465   opcode(0x8D); /* 0x8D /r */
 7466   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7467   ins_pipe(ialu_reg_reg);
 7468 %}
 7469 
 7470 instruct checkCastPP(rRegP dst)
 7471 %{
 7472   match(Set dst (CheckCastPP dst));
 7473 
 7474   size(0);
 7475   format %{ &quot;# checkcastPP of $dst&quot; %}
 7476   ins_encode(/* empty encoding */);
 7477   ins_pipe(empty);
 7478 %}
 7479 
 7480 instruct castPP(rRegP dst)
 7481 %{
 7482   match(Set dst (CastPP dst));
 7483 
 7484   size(0);
 7485   format %{ &quot;# castPP of $dst&quot; %}
 7486   ins_encode(/* empty encoding */);
 7487   ins_pipe(empty);
 7488 %}
 7489 
 7490 instruct castII(rRegI dst)
 7491 %{
 7492   match(Set dst (CastII dst));
 7493 
 7494   size(0);
 7495   format %{ &quot;# castII of $dst&quot; %}
 7496   ins_encode(/* empty encoding */);
 7497   ins_cost(0);
 7498   ins_pipe(empty);
 7499 %}
 7500 
 7501 // LoadP-locked same as a regular LoadP when used with compare-swap
 7502 instruct loadPLocked(rRegP dst, memory mem)
 7503 %{
 7504   match(Set dst (LoadPLocked mem));
 7505 
 7506   ins_cost(125); // XXX
 7507   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7508   opcode(0x8B);
 7509   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7510   ins_pipe(ialu_reg_mem); // XXX
 7511 %}
 7512 
 7513 // Conditional-store of the updated heap-top.
 7514 // Used during allocation of the shared heap.
 7515 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7516 
 7517 instruct storePConditional(memory heap_top_ptr,
 7518                            rax_RegP oldval, rRegP newval,
 7519                            rFlagsReg cr)
 7520 %{
 7521   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7522   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7523 
 7524   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7525             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7526   opcode(0x0F, 0xB1);
 7527   ins_encode(lock_prefix,
 7528              REX_reg_mem_wide(newval, heap_top_ptr),
 7529              OpcP, OpcS,
 7530              reg_mem(newval, heap_top_ptr));
 7531   ins_pipe(pipe_cmpxchg);
 7532 %}
 7533 
 7534 // Conditional-store of an int value.
 7535 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7536 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7537 %{
 7538   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7539   effect(KILL oldval);
 7540 
 7541   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7542   opcode(0x0F, 0xB1);
 7543   ins_encode(lock_prefix,
 7544              REX_reg_mem(newval, mem),
 7545              OpcP, OpcS,
 7546              reg_mem(newval, mem));
 7547   ins_pipe(pipe_cmpxchg);
 7548 %}
 7549 
 7550 // Conditional-store of a long value.
 7551 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7552 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7553 %{
 7554   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7555   effect(KILL oldval);
 7556 
 7557   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7558   opcode(0x0F, 0xB1);
 7559   ins_encode(lock_prefix,
 7560              REX_reg_mem_wide(newval, mem),
 7561              OpcP, OpcS,
 7562              reg_mem(newval, mem));
 7563   ins_pipe(pipe_cmpxchg);
 7564 %}
 7565 
 7566 
 7567 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7568 instruct compareAndSwapP(rRegI res,
 7569                          memory mem_ptr,
 7570                          rax_RegP oldval, rRegP newval,
 7571                          rFlagsReg cr)
 7572 %{
 7573   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7574   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7575   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7576   effect(KILL cr, KILL oldval);
 7577 
 7578   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7579             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7580             &quot;sete    $res\n\t&quot;
 7581             &quot;movzbl  $res, $res&quot; %}
 7582   opcode(0x0F, 0xB1);
 7583   ins_encode(lock_prefix,
 7584              REX_reg_mem_wide(newval, mem_ptr),
 7585              OpcP, OpcS,
 7586              reg_mem(newval, mem_ptr),
 7587              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7588              REX_reg_breg(res, res), // movzbl
 7589              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7590   ins_pipe( pipe_cmpxchg );
 7591 %}
 7592 
 7593 instruct compareAndSwapL(rRegI res,
 7594                          memory mem_ptr,
 7595                          rax_RegL oldval, rRegL newval,
 7596                          rFlagsReg cr)
 7597 %{
 7598   predicate(VM_Version::supports_cx8());
 7599   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7600   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7601   effect(KILL cr, KILL oldval);
 7602 
 7603   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7604             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7605             &quot;sete    $res\n\t&quot;
 7606             &quot;movzbl  $res, $res&quot; %}
 7607   opcode(0x0F, 0xB1);
 7608   ins_encode(lock_prefix,
 7609              REX_reg_mem_wide(newval, mem_ptr),
 7610              OpcP, OpcS,
 7611              reg_mem(newval, mem_ptr),
 7612              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7613              REX_reg_breg(res, res), // movzbl
 7614              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7615   ins_pipe( pipe_cmpxchg );
 7616 %}
 7617 
 7618 instruct compareAndSwapI(rRegI res,
 7619                          memory mem_ptr,
 7620                          rax_RegI oldval, rRegI newval,
 7621                          rFlagsReg cr)
 7622 %{
 7623   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7624   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7625   effect(KILL cr, KILL oldval);
 7626 
 7627   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7628             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7629             &quot;sete    $res\n\t&quot;
 7630             &quot;movzbl  $res, $res&quot; %}
 7631   opcode(0x0F, 0xB1);
 7632   ins_encode(lock_prefix,
 7633              REX_reg_mem(newval, mem_ptr),
 7634              OpcP, OpcS,
 7635              reg_mem(newval, mem_ptr),
 7636              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7637              REX_reg_breg(res, res), // movzbl
 7638              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7639   ins_pipe( pipe_cmpxchg );
 7640 %}
 7641 
 7642 instruct compareAndSwapB(rRegI res,
 7643                          memory mem_ptr,
 7644                          rax_RegI oldval, rRegI newval,
 7645                          rFlagsReg cr)
 7646 %{
 7647   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7648   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7649   effect(KILL cr, KILL oldval);
 7650 
 7651   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7652             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7653             &quot;sete    $res\n\t&quot;
 7654             &quot;movzbl  $res, $res&quot; %}
 7655   opcode(0x0F, 0xB0);
 7656   ins_encode(lock_prefix,
 7657              REX_breg_mem(newval, mem_ptr),
 7658              OpcP, OpcS,
 7659              reg_mem(newval, mem_ptr),
 7660              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7661              REX_reg_breg(res, res), // movzbl
 7662              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7663   ins_pipe( pipe_cmpxchg );
 7664 %}
 7665 
 7666 instruct compareAndSwapS(rRegI res,
 7667                          memory mem_ptr,
 7668                          rax_RegI oldval, rRegI newval,
 7669                          rFlagsReg cr)
 7670 %{
 7671   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7672   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7673   effect(KILL cr, KILL oldval);
 7674 
 7675   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7676             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7677             &quot;sete    $res\n\t&quot;
 7678             &quot;movzbl  $res, $res&quot; %}
 7679   opcode(0x0F, 0xB1);
 7680   ins_encode(lock_prefix,
 7681              SizePrefix,
 7682              REX_reg_mem(newval, mem_ptr),
 7683              OpcP, OpcS,
 7684              reg_mem(newval, mem_ptr),
 7685              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7686              REX_reg_breg(res, res), // movzbl
 7687              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7688   ins_pipe( pipe_cmpxchg );
 7689 %}
 7690 
 7691 instruct compareAndSwapN(rRegI res,
 7692                           memory mem_ptr,
 7693                           rax_RegN oldval, rRegN newval,
 7694                           rFlagsReg cr) %{
 7695   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7696   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7697   effect(KILL cr, KILL oldval);
 7698 
 7699   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7700             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7701             &quot;sete    $res\n\t&quot;
 7702             &quot;movzbl  $res, $res&quot; %}
 7703   opcode(0x0F, 0xB1);
 7704   ins_encode(lock_prefix,
 7705              REX_reg_mem(newval, mem_ptr),
 7706              OpcP, OpcS,
 7707              reg_mem(newval, mem_ptr),
 7708              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7709              REX_reg_breg(res, res), // movzbl
 7710              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7711   ins_pipe( pipe_cmpxchg );
 7712 %}
 7713 
 7714 instruct compareAndExchangeB(
 7715                          memory mem_ptr,
 7716                          rax_RegI oldval, rRegI newval,
 7717                          rFlagsReg cr)
 7718 %{
 7719   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7720   effect(KILL cr);
 7721 
 7722   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7723             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7724   opcode(0x0F, 0xB0);
 7725   ins_encode(lock_prefix,
 7726              REX_breg_mem(newval, mem_ptr),
 7727              OpcP, OpcS,
 7728              reg_mem(newval, mem_ptr) // lock cmpxchg
 7729              );
 7730   ins_pipe( pipe_cmpxchg );
 7731 %}
 7732 
 7733 instruct compareAndExchangeS(
 7734                          memory mem_ptr,
 7735                          rax_RegI oldval, rRegI newval,
 7736                          rFlagsReg cr)
 7737 %{
 7738   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7739   effect(KILL cr);
 7740 
 7741   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7742             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7743   opcode(0x0F, 0xB1);
 7744   ins_encode(lock_prefix,
 7745              SizePrefix,
 7746              REX_reg_mem(newval, mem_ptr),
 7747              OpcP, OpcS,
 7748              reg_mem(newval, mem_ptr) // lock cmpxchg
 7749              );
 7750   ins_pipe( pipe_cmpxchg );
 7751 %}
 7752 
 7753 instruct compareAndExchangeI(
 7754                          memory mem_ptr,
 7755                          rax_RegI oldval, rRegI newval,
 7756                          rFlagsReg cr)
 7757 %{
 7758   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7759   effect(KILL cr);
 7760 
 7761   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7762             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7763   opcode(0x0F, 0xB1);
 7764   ins_encode(lock_prefix,
 7765              REX_reg_mem(newval, mem_ptr),
 7766              OpcP, OpcS,
 7767              reg_mem(newval, mem_ptr) // lock cmpxchg
 7768              );
 7769   ins_pipe( pipe_cmpxchg );
 7770 %}
 7771 
 7772 instruct compareAndExchangeL(
 7773                          memory mem_ptr,
 7774                          rax_RegL oldval, rRegL newval,
 7775                          rFlagsReg cr)
 7776 %{
 7777   predicate(VM_Version::supports_cx8());
 7778   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7779   effect(KILL cr);
 7780 
 7781   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7782             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7783   opcode(0x0F, 0xB1);
 7784   ins_encode(lock_prefix,
 7785              REX_reg_mem_wide(newval, mem_ptr),
 7786              OpcP, OpcS,
 7787              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7788             );
 7789   ins_pipe( pipe_cmpxchg );
 7790 %}
 7791 
 7792 instruct compareAndExchangeN(
 7793                           memory mem_ptr,
 7794                           rax_RegN oldval, rRegN newval,
 7795                           rFlagsReg cr) %{
 7796   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7797   effect(KILL cr);
 7798 
 7799   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7800             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7801   opcode(0x0F, 0xB1);
 7802   ins_encode(lock_prefix,
 7803              REX_reg_mem(newval, mem_ptr),
 7804              OpcP, OpcS,
 7805              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7806           );
 7807   ins_pipe( pipe_cmpxchg );
 7808 %}
 7809 
 7810 instruct compareAndExchangeP(
 7811                          memory mem_ptr,
 7812                          rax_RegP oldval, rRegP newval,
 7813                          rFlagsReg cr)
 7814 %{
 7815   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7816   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7817   effect(KILL cr);
 7818 
 7819   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7820             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7821   opcode(0x0F, 0xB1);
 7822   ins_encode(lock_prefix,
 7823              REX_reg_mem_wide(newval, mem_ptr),
 7824              OpcP, OpcS,
 7825              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7826           );
 7827   ins_pipe( pipe_cmpxchg );
 7828 %}
 7829 
 7830 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7831   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7832   match(Set dummy (GetAndAddB mem add));
 7833   effect(KILL cr);
 7834   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7835   ins_encode %{
 7836     __ lock();
 7837     __ addb($mem$$Address, $add$$constant);
 7838   %}
 7839   ins_pipe( pipe_cmpxchg );
 7840 %}
 7841 
 7842 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7843   match(Set newval (GetAndAddB mem newval));
 7844   effect(KILL cr);
 7845   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7846   ins_encode %{
 7847     __ lock();
 7848     __ xaddb($mem$$Address, $newval$$Register);
 7849   %}
 7850   ins_pipe( pipe_cmpxchg );
 7851 %}
 7852 
 7853 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7854   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7855   match(Set dummy (GetAndAddS mem add));
 7856   effect(KILL cr);
 7857   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7858   ins_encode %{
 7859     __ lock();
 7860     __ addw($mem$$Address, $add$$constant);
 7861   %}
 7862   ins_pipe( pipe_cmpxchg );
 7863 %}
 7864 
 7865 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7866   match(Set newval (GetAndAddS mem newval));
 7867   effect(KILL cr);
 7868   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7869   ins_encode %{
 7870     __ lock();
 7871     __ xaddw($mem$$Address, $newval$$Register);
 7872   %}
 7873   ins_pipe( pipe_cmpxchg );
 7874 %}
 7875 
 7876 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7877   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7878   match(Set dummy (GetAndAddI mem add));
 7879   effect(KILL cr);
 7880   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7881   ins_encode %{
 7882     __ lock();
 7883     __ addl($mem$$Address, $add$$constant);
 7884   %}
 7885   ins_pipe( pipe_cmpxchg );
 7886 %}
 7887 
 7888 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7889   match(Set newval (GetAndAddI mem newval));
 7890   effect(KILL cr);
 7891   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7892   ins_encode %{
 7893     __ lock();
 7894     __ xaddl($mem$$Address, $newval$$Register);
 7895   %}
 7896   ins_pipe( pipe_cmpxchg );
 7897 %}
 7898 
 7899 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7900   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7901   match(Set dummy (GetAndAddL mem add));
 7902   effect(KILL cr);
 7903   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 7904   ins_encode %{
 7905     __ lock();
 7906     __ addq($mem$$Address, $add$$constant);
 7907   %}
 7908   ins_pipe( pipe_cmpxchg );
 7909 %}
 7910 
 7911 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 7912   match(Set newval (GetAndAddL mem newval));
 7913   effect(KILL cr);
 7914   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 7915   ins_encode %{
 7916     __ lock();
 7917     __ xaddq($mem$$Address, $newval$$Register);
 7918   %}
 7919   ins_pipe( pipe_cmpxchg );
 7920 %}
 7921 
 7922 instruct xchgB( memory mem, rRegI newval) %{
 7923   match(Set newval (GetAndSetB mem newval));
 7924   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7925   ins_encode %{
 7926     __ xchgb($newval$$Register, $mem$$Address);
 7927   %}
 7928   ins_pipe( pipe_cmpxchg );
 7929 %}
 7930 
 7931 instruct xchgS( memory mem, rRegI newval) %{
 7932   match(Set newval (GetAndSetS mem newval));
 7933   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7934   ins_encode %{
 7935     __ xchgw($newval$$Register, $mem$$Address);
 7936   %}
 7937   ins_pipe( pipe_cmpxchg );
 7938 %}
 7939 
 7940 instruct xchgI( memory mem, rRegI newval) %{
 7941   match(Set newval (GetAndSetI mem newval));
 7942   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7943   ins_encode %{
 7944     __ xchgl($newval$$Register, $mem$$Address);
 7945   %}
 7946   ins_pipe( pipe_cmpxchg );
 7947 %}
 7948 
 7949 instruct xchgL( memory mem, rRegL newval) %{
 7950   match(Set newval (GetAndSetL mem newval));
 7951   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7952   ins_encode %{
 7953     __ xchgq($newval$$Register, $mem$$Address);
 7954   %}
 7955   ins_pipe( pipe_cmpxchg );
 7956 %}
 7957 
 7958 instruct xchgP( memory mem, rRegP newval) %{
 7959   match(Set newval (GetAndSetP mem newval));
 7960   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7961   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 7962   ins_encode %{
 7963     __ xchgq($newval$$Register, $mem$$Address);
 7964   %}
 7965   ins_pipe( pipe_cmpxchg );
 7966 %}
 7967 
 7968 instruct xchgN( memory mem, rRegN newval) %{
 7969   match(Set newval (GetAndSetN mem newval));
 7970   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 7971   ins_encode %{
 7972     __ xchgl($newval$$Register, $mem$$Address);
 7973   %}
 7974   ins_pipe( pipe_cmpxchg );
 7975 %}
 7976 
 7977 //----------Abs Instructions-------------------------------------------
 7978 
 7979 // Integer Absolute Instructions
 7980 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 7981 %{
 7982   match(Set dst (AbsI src));
 7983   effect(TEMP dst, TEMP tmp, KILL cr);
 7984   format %{ &quot;movl $tmp, $src\n\t&quot;
 7985             &quot;sarl $tmp, 31\n\t&quot;
 7986             &quot;movl $dst, $src\n\t&quot;
 7987             &quot;xorl $dst, $tmp\n\t&quot;
 7988             &quot;subl $dst, $tmp\n&quot;
 7989           %}
 7990   ins_encode %{
 7991     __ movl($tmp$$Register, $src$$Register);
 7992     __ sarl($tmp$$Register, 31);
 7993     __ movl($dst$$Register, $src$$Register);
 7994     __ xorl($dst$$Register, $tmp$$Register);
 7995     __ subl($dst$$Register, $tmp$$Register);
 7996   %}
 7997 
 7998   ins_pipe(ialu_reg_reg);
 7999 %}
 8000 
 8001 // Long Absolute Instructions
 8002 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8003 %{
 8004   match(Set dst (AbsL src));
 8005   effect(TEMP dst, TEMP tmp, KILL cr);
 8006   format %{ &quot;movq $tmp, $src\n\t&quot;
 8007             &quot;sarq $tmp, 63\n\t&quot;
 8008             &quot;movq $dst, $src\n\t&quot;
 8009             &quot;xorq $dst, $tmp\n\t&quot;
 8010             &quot;subq $dst, $tmp\n&quot;
 8011           %}
 8012   ins_encode %{
 8013     __ movq($tmp$$Register, $src$$Register);
 8014     __ sarq($tmp$$Register, 63);
 8015     __ movq($dst$$Register, $src$$Register);
 8016     __ xorq($dst$$Register, $tmp$$Register);
 8017     __ subq($dst$$Register, $tmp$$Register);
 8018   %}
 8019 
 8020   ins_pipe(ialu_reg_reg);
 8021 %}
 8022 
 8023 //----------Subtraction Instructions-------------------------------------------
 8024 
 8025 // Integer Subtraction Instructions
 8026 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8027 %{
 8028   match(Set dst (SubI dst src));
 8029   effect(KILL cr);
 8030 
 8031   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8032   opcode(0x2B);
 8033   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8034   ins_pipe(ialu_reg_reg);
 8035 %}
 8036 
 8037 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8038 %{
 8039   match(Set dst (SubI dst src));
 8040   effect(KILL cr);
 8041 
 8042   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8043   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8044   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8045   ins_pipe(ialu_reg);
 8046 %}
 8047 
 8048 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8049 %{
 8050   match(Set dst (SubI dst (LoadI src)));
 8051   effect(KILL cr);
 8052 
 8053   ins_cost(125);
 8054   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8055   opcode(0x2B);
 8056   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8057   ins_pipe(ialu_reg_mem);
 8058 %}
 8059 
 8060 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8061 %{
 8062   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8063   effect(KILL cr);
 8064 
 8065   ins_cost(150);
 8066   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8067   opcode(0x29); /* Opcode 29 /r */
 8068   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8069   ins_pipe(ialu_mem_reg);
 8070 %}
 8071 
 8072 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8073 %{
 8074   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8075   effect(KILL cr);
 8076 
 8077   ins_cost(125); // XXX
 8078   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8079   opcode(0x81); /* Opcode 81 /5 id */
 8080   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8081   ins_pipe(ialu_mem_imm);
 8082 %}
 8083 
 8084 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8085 %{
 8086   match(Set dst (SubL dst src));
 8087   effect(KILL cr);
 8088 
 8089   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8090   opcode(0x2B);
 8091   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8092   ins_pipe(ialu_reg_reg);
 8093 %}
 8094 
 8095 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8096 %{
 8097   match(Set dst (SubL dst src));
 8098   effect(KILL cr);
 8099 
 8100   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8101   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8102   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8103   ins_pipe(ialu_reg);
 8104 %}
 8105 
 8106 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8107 %{
 8108   match(Set dst (SubL dst (LoadL src)));
 8109   effect(KILL cr);
 8110 
 8111   ins_cost(125);
 8112   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8113   opcode(0x2B);
 8114   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8115   ins_pipe(ialu_reg_mem);
 8116 %}
 8117 
 8118 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8119 %{
 8120   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8121   effect(KILL cr);
 8122 
 8123   ins_cost(150);
 8124   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8125   opcode(0x29); /* Opcode 29 /r */
 8126   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8127   ins_pipe(ialu_mem_reg);
 8128 %}
 8129 
 8130 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8131 %{
 8132   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8133   effect(KILL cr);
 8134 
 8135   ins_cost(125); // XXX
 8136   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8137   opcode(0x81); /* Opcode 81 /5 id */
 8138   ins_encode(REX_mem_wide(dst),
 8139              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8140   ins_pipe(ialu_mem_imm);
 8141 %}
 8142 
 8143 // Subtract from a pointer
 8144 // XXX hmpf???
 8145 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8146 %{
 8147   match(Set dst (AddP dst (SubI zero src)));
 8148   effect(KILL cr);
 8149 
 8150   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8151   opcode(0x2B);
 8152   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8153   ins_pipe(ialu_reg_reg);
 8154 %}
 8155 
 8156 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8157 %{
 8158   match(Set dst (SubI zero dst));
 8159   effect(KILL cr);
 8160 
 8161   format %{ &quot;negl    $dst\t# int&quot; %}
 8162   opcode(0xF7, 0x03);  // Opcode F7 /3
 8163   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8164   ins_pipe(ialu_reg);
 8165 %}
 8166 
 8167 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8168 %{
 8169   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8170   effect(KILL cr);
 8171 
 8172   format %{ &quot;negl    $dst\t# int&quot; %}
 8173   opcode(0xF7, 0x03);  // Opcode F7 /3
 8174   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8175   ins_pipe(ialu_reg);
 8176 %}
 8177 
 8178 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8179 %{
 8180   match(Set dst (SubL zero dst));
 8181   effect(KILL cr);
 8182 
 8183   format %{ &quot;negq    $dst\t# long&quot; %}
 8184   opcode(0xF7, 0x03);  // Opcode F7 /3
 8185   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8186   ins_pipe(ialu_reg);
 8187 %}
 8188 
 8189 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8190 %{
 8191   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8192   effect(KILL cr);
 8193 
 8194   format %{ &quot;negq    $dst\t# long&quot; %}
 8195   opcode(0xF7, 0x03);  // Opcode F7 /3
 8196   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8197   ins_pipe(ialu_reg);
 8198 %}
 8199 
 8200 //----------Multiplication/Division Instructions-------------------------------
 8201 // Integer Multiplication Instructions
 8202 // Multiply Register
 8203 
 8204 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8205 %{
 8206   match(Set dst (MulI dst src));
 8207   effect(KILL cr);
 8208 
 8209   ins_cost(300);
 8210   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8211   opcode(0x0F, 0xAF);
 8212   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8213   ins_pipe(ialu_reg_reg_alu0);
 8214 %}
 8215 
 8216 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8217 %{
 8218   match(Set dst (MulI src imm));
 8219   effect(KILL cr);
 8220 
 8221   ins_cost(300);
 8222   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8223   opcode(0x69); /* 69 /r id */
 8224   ins_encode(REX_reg_reg(dst, src),
 8225              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8226   ins_pipe(ialu_reg_reg_alu0);
 8227 %}
 8228 
 8229 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8230 %{
 8231   match(Set dst (MulI dst (LoadI src)));
 8232   effect(KILL cr);
 8233 
 8234   ins_cost(350);
 8235   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8236   opcode(0x0F, 0xAF);
 8237   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8238   ins_pipe(ialu_reg_mem_alu0);
 8239 %}
 8240 
 8241 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8242 %{
 8243   match(Set dst (MulI (LoadI src) imm));
 8244   effect(KILL cr);
 8245 
 8246   ins_cost(300);
 8247   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8248   opcode(0x69); /* 69 /r id */
 8249   ins_encode(REX_reg_mem(dst, src),
 8250              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8251   ins_pipe(ialu_reg_mem_alu0);
 8252 %}
 8253 
 8254 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8255 %{
 8256   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8257   effect(KILL cr, KILL src2);
 8258 
 8259   expand %{ mulI_rReg(dst, src1, cr);
 8260            mulI_rReg(src2, src3, cr);
 8261            addI_rReg(dst, src2, cr); %}
 8262 %}
 8263 
 8264 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8265 %{
 8266   match(Set dst (MulL dst src));
 8267   effect(KILL cr);
 8268 
 8269   ins_cost(300);
 8270   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8271   opcode(0x0F, 0xAF);
 8272   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8273   ins_pipe(ialu_reg_reg_alu0);
 8274 %}
 8275 
 8276 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8277 %{
 8278   match(Set dst (MulL src imm));
 8279   effect(KILL cr);
 8280 
 8281   ins_cost(300);
 8282   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8283   opcode(0x69); /* 69 /r id */
 8284   ins_encode(REX_reg_reg_wide(dst, src),
 8285              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8286   ins_pipe(ialu_reg_reg_alu0);
 8287 %}
 8288 
 8289 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8290 %{
 8291   match(Set dst (MulL dst (LoadL src)));
 8292   effect(KILL cr);
 8293 
 8294   ins_cost(350);
 8295   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8296   opcode(0x0F, 0xAF);
 8297   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8298   ins_pipe(ialu_reg_mem_alu0);
 8299 %}
 8300 
 8301 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8302 %{
 8303   match(Set dst (MulL (LoadL src) imm));
 8304   effect(KILL cr);
 8305 
 8306   ins_cost(300);
 8307   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8308   opcode(0x69); /* 69 /r id */
 8309   ins_encode(REX_reg_mem_wide(dst, src),
 8310              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8311   ins_pipe(ialu_reg_mem_alu0);
 8312 %}
 8313 
 8314 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8315 %{
 8316   match(Set dst (MulHiL src rax));
 8317   effect(USE_KILL rax, KILL cr);
 8318 
 8319   ins_cost(300);
 8320   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8321   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8322   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8323   ins_pipe(ialu_reg_reg_alu0);
 8324 %}
 8325 
 8326 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8327                    rFlagsReg cr)
 8328 %{
 8329   match(Set rax (DivI rax div));
 8330   effect(KILL rdx, KILL cr);
 8331 
 8332   ins_cost(30*100+10*100); // XXX
 8333   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8334             &quot;jne,s   normal\n\t&quot;
 8335             &quot;xorl    rdx, rdx\n\t&quot;
 8336             &quot;cmpl    $div, -1\n\t&quot;
 8337             &quot;je,s    done\n&quot;
 8338     &quot;normal: cdql\n\t&quot;
 8339             &quot;idivl   $div\n&quot;
 8340     &quot;done:&quot;        %}
 8341   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8342   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8343   ins_pipe(ialu_reg_reg_alu0);
 8344 %}
 8345 
 8346 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8347                    rFlagsReg cr)
 8348 %{
 8349   match(Set rax (DivL rax div));
 8350   effect(KILL rdx, KILL cr);
 8351 
 8352   ins_cost(30*100+10*100); // XXX
 8353   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8354             &quot;cmpq    rax, rdx\n\t&quot;
 8355             &quot;jne,s   normal\n\t&quot;
 8356             &quot;xorl    rdx, rdx\n\t&quot;
 8357             &quot;cmpq    $div, -1\n\t&quot;
 8358             &quot;je,s    done\n&quot;
 8359     &quot;normal: cdqq\n\t&quot;
 8360             &quot;idivq   $div\n&quot;
 8361     &quot;done:&quot;        %}
 8362   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8363   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8364   ins_pipe(ialu_reg_reg_alu0);
 8365 %}
 8366 
 8367 // Integer DIVMOD with Register, both quotient and mod results
 8368 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8369                              rFlagsReg cr)
 8370 %{
 8371   match(DivModI rax div);
 8372   effect(KILL cr);
 8373 
 8374   ins_cost(30*100+10*100); // XXX
 8375   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8376             &quot;jne,s   normal\n\t&quot;
 8377             &quot;xorl    rdx, rdx\n\t&quot;
 8378             &quot;cmpl    $div, -1\n\t&quot;
 8379             &quot;je,s    done\n&quot;
 8380     &quot;normal: cdql\n\t&quot;
 8381             &quot;idivl   $div\n&quot;
 8382     &quot;done:&quot;        %}
 8383   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8384   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8385   ins_pipe(pipe_slow);
 8386 %}
 8387 
 8388 // Long DIVMOD with Register, both quotient and mod results
 8389 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8390                              rFlagsReg cr)
 8391 %{
 8392   match(DivModL rax div);
 8393   effect(KILL cr);
 8394 
 8395   ins_cost(30*100+10*100); // XXX
 8396   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8397             &quot;cmpq    rax, rdx\n\t&quot;
 8398             &quot;jne,s   normal\n\t&quot;
 8399             &quot;xorl    rdx, rdx\n\t&quot;
 8400             &quot;cmpq    $div, -1\n\t&quot;
 8401             &quot;je,s    done\n&quot;
 8402     &quot;normal: cdqq\n\t&quot;
 8403             &quot;idivq   $div\n&quot;
 8404     &quot;done:&quot;        %}
 8405   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8406   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8407   ins_pipe(pipe_slow);
 8408 %}
 8409 
 8410 //----------- DivL-By-Constant-Expansions--------------------------------------
 8411 // DivI cases are handled by the compiler
 8412 
 8413 // Magic constant, reciprocal of 10
 8414 instruct loadConL_0x6666666666666667(rRegL dst)
 8415 %{
 8416   effect(DEF dst);
 8417 
 8418   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8419   ins_encode(load_immL(dst, 0x6666666666666667));
 8420   ins_pipe(ialu_reg);
 8421 %}
 8422 
 8423 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8424 %{
 8425   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8426 
 8427   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8428   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8429   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8430   ins_pipe(ialu_reg_reg_alu0);
 8431 %}
 8432 
 8433 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8434 %{
 8435   effect(USE_DEF dst, KILL cr);
 8436 
 8437   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8438   opcode(0xC1, 0x7); /* C1 /7 ib */
 8439   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8440   ins_pipe(ialu_reg);
 8441 %}
 8442 
 8443 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8444 %{
 8445   effect(USE_DEF dst, KILL cr);
 8446 
 8447   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8448   opcode(0xC1, 0x7); /* C1 /7 ib */
 8449   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8450   ins_pipe(ialu_reg);
 8451 %}
 8452 
 8453 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8454 %{
 8455   match(Set dst (DivL src div));
 8456 
 8457   ins_cost((5+8)*100);
 8458   expand %{
 8459     rax_RegL rax;                     // Killed temp
 8460     rFlagsReg cr;                     // Killed
 8461     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8462     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8463     sarL_rReg_63(src, cr);            // sarq  src, 63
 8464     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8465     subL_rReg(dst, src, cr);          // subl  rdx, src
 8466   %}
 8467 %}
 8468 
 8469 //-----------------------------------------------------------------------------
 8470 
 8471 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8472                    rFlagsReg cr)
 8473 %{
 8474   match(Set rdx (ModI rax div));
 8475   effect(KILL rax, KILL cr);
 8476 
 8477   ins_cost(300); // XXX
 8478   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8479             &quot;jne,s   normal\n\t&quot;
 8480             &quot;xorl    rdx, rdx\n\t&quot;
 8481             &quot;cmpl    $div, -1\n\t&quot;
 8482             &quot;je,s    done\n&quot;
 8483     &quot;normal: cdql\n\t&quot;
 8484             &quot;idivl   $div\n&quot;
 8485     &quot;done:&quot;        %}
 8486   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8487   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8488   ins_pipe(ialu_reg_reg_alu0);
 8489 %}
 8490 
 8491 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8492                    rFlagsReg cr)
 8493 %{
 8494   match(Set rdx (ModL rax div));
 8495   effect(KILL rax, KILL cr);
 8496 
 8497   ins_cost(300); // XXX
 8498   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8499             &quot;cmpq    rax, rdx\n\t&quot;
 8500             &quot;jne,s   normal\n\t&quot;
 8501             &quot;xorl    rdx, rdx\n\t&quot;
 8502             &quot;cmpq    $div, -1\n\t&quot;
 8503             &quot;je,s    done\n&quot;
 8504     &quot;normal: cdqq\n\t&quot;
 8505             &quot;idivq   $div\n&quot;
 8506     &quot;done:&quot;        %}
 8507   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8508   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8509   ins_pipe(ialu_reg_reg_alu0);
 8510 %}
 8511 
 8512 // Integer Shift Instructions
 8513 // Shift Left by one
 8514 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8515 %{
 8516   match(Set dst (LShiftI dst shift));
 8517   effect(KILL cr);
 8518 
 8519   format %{ &quot;sall    $dst, $shift&quot; %}
 8520   opcode(0xD1, 0x4); /* D1 /4 */
 8521   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8522   ins_pipe(ialu_reg);
 8523 %}
 8524 
 8525 // Shift Left by one
 8526 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8527 %{
 8528   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8529   effect(KILL cr);
 8530 
 8531   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8532   opcode(0xD1, 0x4); /* D1 /4 */
 8533   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8534   ins_pipe(ialu_mem_imm);
 8535 %}
 8536 
 8537 // Shift Left by 8-bit immediate
 8538 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8539 %{
 8540   match(Set dst (LShiftI dst shift));
 8541   effect(KILL cr);
 8542 
 8543   format %{ &quot;sall    $dst, $shift&quot; %}
 8544   opcode(0xC1, 0x4); /* C1 /4 ib */
 8545   ins_encode(reg_opc_imm(dst, shift));
 8546   ins_pipe(ialu_reg);
 8547 %}
 8548 
 8549 // Shift Left by 8-bit immediate
 8550 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8551 %{
 8552   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8553   effect(KILL cr);
 8554 
 8555   format %{ &quot;sall    $dst, $shift&quot; %}
 8556   opcode(0xC1, 0x4); /* C1 /4 ib */
 8557   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8558   ins_pipe(ialu_mem_imm);
 8559 %}
 8560 
 8561 // Shift Left by variable
 8562 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8563 %{
 8564   match(Set dst (LShiftI dst shift));
 8565   effect(KILL cr);
 8566 
 8567   format %{ &quot;sall    $dst, $shift&quot; %}
 8568   opcode(0xD3, 0x4); /* D3 /4 */
 8569   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8570   ins_pipe(ialu_reg_reg);
 8571 %}
 8572 
 8573 // Shift Left by variable
 8574 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8575 %{
 8576   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8577   effect(KILL cr);
 8578 
 8579   format %{ &quot;sall    $dst, $shift&quot; %}
 8580   opcode(0xD3, 0x4); /* D3 /4 */
 8581   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8582   ins_pipe(ialu_mem_reg);
 8583 %}
 8584 
 8585 // Arithmetic shift right by one
 8586 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8587 %{
 8588   match(Set dst (RShiftI dst shift));
 8589   effect(KILL cr);
 8590 
 8591   format %{ &quot;sarl    $dst, $shift&quot; %}
 8592   opcode(0xD1, 0x7); /* D1 /7 */
 8593   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8594   ins_pipe(ialu_reg);
 8595 %}
 8596 
 8597 // Arithmetic shift right by one
 8598 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8599 %{
 8600   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8601   effect(KILL cr);
 8602 
 8603   format %{ &quot;sarl    $dst, $shift&quot; %}
 8604   opcode(0xD1, 0x7); /* D1 /7 */
 8605   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8606   ins_pipe(ialu_mem_imm);
 8607 %}
 8608 
 8609 // Arithmetic Shift Right by 8-bit immediate
 8610 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8611 %{
 8612   match(Set dst (RShiftI dst shift));
 8613   effect(KILL cr);
 8614 
 8615   format %{ &quot;sarl    $dst, $shift&quot; %}
 8616   opcode(0xC1, 0x7); /* C1 /7 ib */
 8617   ins_encode(reg_opc_imm(dst, shift));
 8618   ins_pipe(ialu_mem_imm);
 8619 %}
 8620 
 8621 // Arithmetic Shift Right by 8-bit immediate
 8622 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8623 %{
 8624   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8625   effect(KILL cr);
 8626 
 8627   format %{ &quot;sarl    $dst, $shift&quot; %}
 8628   opcode(0xC1, 0x7); /* C1 /7 ib */
 8629   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8630   ins_pipe(ialu_mem_imm);
 8631 %}
 8632 
 8633 // Arithmetic Shift Right by variable
 8634 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8635 %{
 8636   match(Set dst (RShiftI dst shift));
 8637   effect(KILL cr);
 8638 
 8639   format %{ &quot;sarl    $dst, $shift&quot; %}
 8640   opcode(0xD3, 0x7); /* D3 /7 */
 8641   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8642   ins_pipe(ialu_reg_reg);
 8643 %}
 8644 
 8645 // Arithmetic Shift Right by variable
 8646 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8647 %{
 8648   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8649   effect(KILL cr);
 8650 
 8651   format %{ &quot;sarl    $dst, $shift&quot; %}
 8652   opcode(0xD3, 0x7); /* D3 /7 */
 8653   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8654   ins_pipe(ialu_mem_reg);
 8655 %}
 8656 
 8657 // Logical shift right by one
 8658 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8659 %{
 8660   match(Set dst (URShiftI dst shift));
 8661   effect(KILL cr);
 8662 
 8663   format %{ &quot;shrl    $dst, $shift&quot; %}
 8664   opcode(0xD1, 0x5); /* D1 /5 */
 8665   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8666   ins_pipe(ialu_reg);
 8667 %}
 8668 
 8669 // Logical shift right by one
 8670 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8671 %{
 8672   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8673   effect(KILL cr);
 8674 
 8675   format %{ &quot;shrl    $dst, $shift&quot; %}
 8676   opcode(0xD1, 0x5); /* D1 /5 */
 8677   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8678   ins_pipe(ialu_mem_imm);
 8679 %}
 8680 
 8681 // Logical Shift Right by 8-bit immediate
 8682 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8683 %{
 8684   match(Set dst (URShiftI dst shift));
 8685   effect(KILL cr);
 8686 
 8687   format %{ &quot;shrl    $dst, $shift&quot; %}
 8688   opcode(0xC1, 0x5); /* C1 /5 ib */
 8689   ins_encode(reg_opc_imm(dst, shift));
 8690   ins_pipe(ialu_reg);
 8691 %}
 8692 
 8693 // Logical Shift Right by 8-bit immediate
 8694 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8695 %{
 8696   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8697   effect(KILL cr);
 8698 
 8699   format %{ &quot;shrl    $dst, $shift&quot; %}
 8700   opcode(0xC1, 0x5); /* C1 /5 ib */
 8701   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8702   ins_pipe(ialu_mem_imm);
 8703 %}
 8704 
 8705 // Logical Shift Right by variable
 8706 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8707 %{
 8708   match(Set dst (URShiftI dst shift));
 8709   effect(KILL cr);
 8710 
 8711   format %{ &quot;shrl    $dst, $shift&quot; %}
 8712   opcode(0xD3, 0x5); /* D3 /5 */
 8713   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8714   ins_pipe(ialu_reg_reg);
 8715 %}
 8716 
 8717 // Logical Shift Right by variable
 8718 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8719 %{
 8720   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8721   effect(KILL cr);
 8722 
 8723   format %{ &quot;shrl    $dst, $shift&quot; %}
 8724   opcode(0xD3, 0x5); /* D3 /5 */
 8725   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8726   ins_pipe(ialu_mem_reg);
 8727 %}
 8728 
 8729 // Long Shift Instructions
 8730 // Shift Left by one
 8731 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8732 %{
 8733   match(Set dst (LShiftL dst shift));
 8734   effect(KILL cr);
 8735 
 8736   format %{ &quot;salq    $dst, $shift&quot; %}
 8737   opcode(0xD1, 0x4); /* D1 /4 */
 8738   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8739   ins_pipe(ialu_reg);
 8740 %}
 8741 
 8742 // Shift Left by one
 8743 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8744 %{
 8745   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8746   effect(KILL cr);
 8747 
 8748   format %{ &quot;salq    $dst, $shift&quot; %}
 8749   opcode(0xD1, 0x4); /* D1 /4 */
 8750   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8751   ins_pipe(ialu_mem_imm);
 8752 %}
 8753 
 8754 // Shift Left by 8-bit immediate
 8755 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8756 %{
 8757   match(Set dst (LShiftL dst shift));
 8758   effect(KILL cr);
 8759 
 8760   format %{ &quot;salq    $dst, $shift&quot; %}
 8761   opcode(0xC1, 0x4); /* C1 /4 ib */
 8762   ins_encode(reg_opc_imm_wide(dst, shift));
 8763   ins_pipe(ialu_reg);
 8764 %}
 8765 
 8766 // Shift Left by 8-bit immediate
 8767 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8768 %{
 8769   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8770   effect(KILL cr);
 8771 
 8772   format %{ &quot;salq    $dst, $shift&quot; %}
 8773   opcode(0xC1, 0x4); /* C1 /4 ib */
 8774   ins_encode(REX_mem_wide(dst), OpcP,
 8775              RM_opc_mem(secondary, dst), Con8or32(shift));
 8776   ins_pipe(ialu_mem_imm);
 8777 %}
 8778 
 8779 // Shift Left by variable
 8780 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8781 %{
 8782   match(Set dst (LShiftL dst shift));
 8783   effect(KILL cr);
 8784 
 8785   format %{ &quot;salq    $dst, $shift&quot; %}
 8786   opcode(0xD3, 0x4); /* D3 /4 */
 8787   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8788   ins_pipe(ialu_reg_reg);
 8789 %}
 8790 
 8791 // Shift Left by variable
 8792 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8793 %{
 8794   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8795   effect(KILL cr);
 8796 
 8797   format %{ &quot;salq    $dst, $shift&quot; %}
 8798   opcode(0xD3, 0x4); /* D3 /4 */
 8799   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8800   ins_pipe(ialu_mem_reg);
 8801 %}
 8802 
 8803 // Arithmetic shift right by one
 8804 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8805 %{
 8806   match(Set dst (RShiftL dst shift));
 8807   effect(KILL cr);
 8808 
 8809   format %{ &quot;sarq    $dst, $shift&quot; %}
 8810   opcode(0xD1, 0x7); /* D1 /7 */
 8811   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8812   ins_pipe(ialu_reg);
 8813 %}
 8814 
 8815 // Arithmetic shift right by one
 8816 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8817 %{
 8818   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8819   effect(KILL cr);
 8820 
 8821   format %{ &quot;sarq    $dst, $shift&quot; %}
 8822   opcode(0xD1, 0x7); /* D1 /7 */
 8823   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8824   ins_pipe(ialu_mem_imm);
 8825 %}
 8826 
 8827 // Arithmetic Shift Right by 8-bit immediate
 8828 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8829 %{
 8830   match(Set dst (RShiftL dst shift));
 8831   effect(KILL cr);
 8832 
 8833   format %{ &quot;sarq    $dst, $shift&quot; %}
 8834   opcode(0xC1, 0x7); /* C1 /7 ib */
 8835   ins_encode(reg_opc_imm_wide(dst, shift));
 8836   ins_pipe(ialu_mem_imm);
 8837 %}
 8838 
 8839 // Arithmetic Shift Right by 8-bit immediate
 8840 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8841 %{
 8842   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8843   effect(KILL cr);
 8844 
 8845   format %{ &quot;sarq    $dst, $shift&quot; %}
 8846   opcode(0xC1, 0x7); /* C1 /7 ib */
 8847   ins_encode(REX_mem_wide(dst), OpcP,
 8848              RM_opc_mem(secondary, dst), Con8or32(shift));
 8849   ins_pipe(ialu_mem_imm);
 8850 %}
 8851 
 8852 // Arithmetic Shift Right by variable
 8853 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8854 %{
 8855   match(Set dst (RShiftL dst shift));
 8856   effect(KILL cr);
 8857 
 8858   format %{ &quot;sarq    $dst, $shift&quot; %}
 8859   opcode(0xD3, 0x7); /* D3 /7 */
 8860   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8861   ins_pipe(ialu_reg_reg);
 8862 %}
 8863 
 8864 // Arithmetic Shift Right by variable
 8865 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8866 %{
 8867   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8868   effect(KILL cr);
 8869 
 8870   format %{ &quot;sarq    $dst, $shift&quot; %}
 8871   opcode(0xD3, 0x7); /* D3 /7 */
 8872   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8873   ins_pipe(ialu_mem_reg);
 8874 %}
 8875 
 8876 // Logical shift right by one
 8877 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8878 %{
 8879   match(Set dst (URShiftL dst shift));
 8880   effect(KILL cr);
 8881 
 8882   format %{ &quot;shrq    $dst, $shift&quot; %}
 8883   opcode(0xD1, 0x5); /* D1 /5 */
 8884   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8885   ins_pipe(ialu_reg);
 8886 %}
 8887 
 8888 // Logical shift right by one
 8889 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8890 %{
 8891   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8892   effect(KILL cr);
 8893 
 8894   format %{ &quot;shrq    $dst, $shift&quot; %}
 8895   opcode(0xD1, 0x5); /* D1 /5 */
 8896   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8897   ins_pipe(ialu_mem_imm);
 8898 %}
 8899 
 8900 // Logical Shift Right by 8-bit immediate
 8901 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8902 %{
 8903   match(Set dst (URShiftL dst shift));
 8904   effect(KILL cr);
 8905 
 8906   format %{ &quot;shrq    $dst, $shift&quot; %}
 8907   opcode(0xC1, 0x5); /* C1 /5 ib */
 8908   ins_encode(reg_opc_imm_wide(dst, shift));
 8909   ins_pipe(ialu_reg);
 8910 %}
 8911 
 8912 
 8913 // Logical Shift Right by 8-bit immediate
 8914 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8915 %{
 8916   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8917   effect(KILL cr);
 8918 
 8919   format %{ &quot;shrq    $dst, $shift&quot; %}
 8920   opcode(0xC1, 0x5); /* C1 /5 ib */
 8921   ins_encode(REX_mem_wide(dst), OpcP,
 8922              RM_opc_mem(secondary, dst), Con8or32(shift));
 8923   ins_pipe(ialu_mem_imm);
 8924 %}
 8925 
 8926 // Logical Shift Right by variable
 8927 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8928 %{
 8929   match(Set dst (URShiftL dst shift));
 8930   effect(KILL cr);
 8931 
 8932   format %{ &quot;shrq    $dst, $shift&quot; %}
 8933   opcode(0xD3, 0x5); /* D3 /5 */
 8934   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8935   ins_pipe(ialu_reg_reg);
 8936 %}
 8937 
 8938 // Logical Shift Right by variable
 8939 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8940 %{
 8941   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8942   effect(KILL cr);
 8943 
 8944   format %{ &quot;shrq    $dst, $shift&quot; %}
 8945   opcode(0xD3, 0x5); /* D3 /5 */
 8946   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8947   ins_pipe(ialu_mem_reg);
 8948 %}
 8949 
 8950 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8951 // This idiom is used by the compiler for the i2b bytecode.
 8952 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 8953 %{
 8954   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8955 
 8956   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 8957   opcode(0x0F, 0xBE);
 8958   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8959   ins_pipe(ialu_reg_reg);
 8960 %}
 8961 
 8962 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8963 // This idiom is used by the compiler the i2s bytecode.
 8964 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 8965 %{
 8966   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8967 
 8968   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 8969   opcode(0x0F, 0xBF);
 8970   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8971   ins_pipe(ialu_reg_reg);
 8972 %}
 8973 
 8974 // ROL/ROR instructions
 8975 
 8976 // ROL expand
 8977 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 8978   effect(KILL cr, USE_DEF dst);
 8979 
 8980   format %{ &quot;roll    $dst&quot; %}
 8981   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 8982   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8983   ins_pipe(ialu_reg);
 8984 %}
 8985 
 8986 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 8987   effect(USE_DEF dst, USE shift, KILL cr);
 8988 
 8989   format %{ &quot;roll    $dst, $shift&quot; %}
 8990   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 8991   ins_encode( reg_opc_imm(dst, shift) );
 8992   ins_pipe(ialu_reg);
 8993 %}
 8994 
 8995 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 8996 %{
 8997   effect(USE_DEF dst, USE shift, KILL cr);
 8998 
 8999   format %{ &quot;roll    $dst, $shift&quot; %}
 9000   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9001   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9002   ins_pipe(ialu_reg_reg);
 9003 %}
 9004 // end of ROL expand
 9005 
 9006 // Rotate Left by one
 9007 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9008 %{
 9009   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9010 
 9011   expand %{
 9012     rolI_rReg_imm1(dst, cr);
 9013   %}
 9014 %}
 9015 
 9016 // Rotate Left by 8-bit immediate
 9017 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9018 %{
 9019   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9020   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9021 
 9022   expand %{
 9023     rolI_rReg_imm8(dst, lshift, cr);
 9024   %}
 9025 %}
 9026 
 9027 // Rotate Left by variable
 9028 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9029 %{
 9030   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9031 
 9032   expand %{
 9033     rolI_rReg_CL(dst, shift, cr);
 9034   %}
 9035 %}
 9036 
 9037 // Rotate Left by variable
 9038 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9039 %{
 9040   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9041 
 9042   expand %{
 9043     rolI_rReg_CL(dst, shift, cr);
 9044   %}
 9045 %}
 9046 
 9047 // ROR expand
 9048 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9049 %{
 9050   effect(USE_DEF dst, KILL cr);
 9051 
 9052   format %{ &quot;rorl    $dst&quot; %}
 9053   opcode(0xD1, 0x1); /* D1 /1 */
 9054   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9055   ins_pipe(ialu_reg);
 9056 %}
 9057 
 9058 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9059 %{
 9060   effect(USE_DEF dst, USE shift, KILL cr);
 9061 
 9062   format %{ &quot;rorl    $dst, $shift&quot; %}
 9063   opcode(0xC1, 0x1); /* C1 /1 ib */
 9064   ins_encode(reg_opc_imm(dst, shift));
 9065   ins_pipe(ialu_reg);
 9066 %}
 9067 
 9068 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9069 %{
 9070   effect(USE_DEF dst, USE shift, KILL cr);
 9071 
 9072   format %{ &quot;rorl    $dst, $shift&quot; %}
 9073   opcode(0xD3, 0x1); /* D3 /1 */
 9074   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9075   ins_pipe(ialu_reg_reg);
 9076 %}
 9077 // end of ROR expand
 9078 
 9079 // Rotate Right by one
 9080 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9081 %{
 9082   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9083 
 9084   expand %{
 9085     rorI_rReg_imm1(dst, cr);
 9086   %}
 9087 %}
 9088 
 9089 // Rotate Right by 8-bit immediate
 9090 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9091 %{
 9092   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9093   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9094 
 9095   expand %{
 9096     rorI_rReg_imm8(dst, rshift, cr);
 9097   %}
 9098 %}
 9099 
 9100 // Rotate Right by variable
 9101 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9102 %{
 9103   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9104 
 9105   expand %{
 9106     rorI_rReg_CL(dst, shift, cr);
 9107   %}
 9108 %}
 9109 
 9110 // Rotate Right by variable
 9111 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9112 %{
 9113   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9114 
 9115   expand %{
 9116     rorI_rReg_CL(dst, shift, cr);
 9117   %}
 9118 %}
 9119 
 9120 // for long rotate
 9121 // ROL expand
 9122 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9123   effect(USE_DEF dst, KILL cr);
 9124 
 9125   format %{ &quot;rolq    $dst&quot; %}
 9126   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9127   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9128   ins_pipe(ialu_reg);
 9129 %}
 9130 
 9131 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9132   effect(USE_DEF dst, USE shift, KILL cr);
 9133 
 9134   format %{ &quot;rolq    $dst, $shift&quot; %}
 9135   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9136   ins_encode( reg_opc_imm_wide(dst, shift) );
 9137   ins_pipe(ialu_reg);
 9138 %}
 9139 
 9140 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9141 %{
 9142   effect(USE_DEF dst, USE shift, KILL cr);
 9143 
 9144   format %{ &quot;rolq    $dst, $shift&quot; %}
 9145   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9146   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9147   ins_pipe(ialu_reg_reg);
 9148 %}
 9149 // end of ROL expand
 9150 
 9151 // Rotate Left by one
 9152 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9153 %{
 9154   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9155 
 9156   expand %{
 9157     rolL_rReg_imm1(dst, cr);
 9158   %}
 9159 %}
 9160 
 9161 // Rotate Left by 8-bit immediate
 9162 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9163 %{
 9164   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9165   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9166 
 9167   expand %{
 9168     rolL_rReg_imm8(dst, lshift, cr);
 9169   %}
 9170 %}
 9171 
 9172 // Rotate Left by variable
 9173 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9174 %{
 9175   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9176 
 9177   expand %{
 9178     rolL_rReg_CL(dst, shift, cr);
 9179   %}
 9180 %}
 9181 
 9182 // Rotate Left by variable
 9183 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9184 %{
 9185   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9186 
 9187   expand %{
 9188     rolL_rReg_CL(dst, shift, cr);
 9189   %}
 9190 %}
 9191 
 9192 // ROR expand
 9193 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9194 %{
 9195   effect(USE_DEF dst, KILL cr);
 9196 
 9197   format %{ &quot;rorq    $dst&quot; %}
 9198   opcode(0xD1, 0x1); /* D1 /1 */
 9199   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9200   ins_pipe(ialu_reg);
 9201 %}
 9202 
 9203 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9204 %{
 9205   effect(USE_DEF dst, USE shift, KILL cr);
 9206 
 9207   format %{ &quot;rorq    $dst, $shift&quot; %}
 9208   opcode(0xC1, 0x1); /* C1 /1 ib */
 9209   ins_encode(reg_opc_imm_wide(dst, shift));
 9210   ins_pipe(ialu_reg);
 9211 %}
 9212 
 9213 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9214 %{
 9215   effect(USE_DEF dst, USE shift, KILL cr);
 9216 
 9217   format %{ &quot;rorq    $dst, $shift&quot; %}
 9218   opcode(0xD3, 0x1); /* D3 /1 */
 9219   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9220   ins_pipe(ialu_reg_reg);
 9221 %}
 9222 // end of ROR expand
 9223 
 9224 // Rotate Right by one
 9225 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9226 %{
 9227   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9228 
 9229   expand %{
 9230     rorL_rReg_imm1(dst, cr);
 9231   %}
 9232 %}
 9233 
 9234 // Rotate Right by 8-bit immediate
 9235 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9236 %{
 9237   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9238   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9239 
 9240   expand %{
 9241     rorL_rReg_imm8(dst, rshift, cr);
 9242   %}
 9243 %}
 9244 
 9245 // Rotate Right by variable
 9246 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9247 %{
 9248   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9249 
 9250   expand %{
 9251     rorL_rReg_CL(dst, shift, cr);
 9252   %}
 9253 %}
 9254 
 9255 // Rotate Right by variable
 9256 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9257 %{
 9258   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9259 
 9260   expand %{
 9261     rorL_rReg_CL(dst, shift, cr);
 9262   %}
 9263 %}
 9264 
 9265 // Logical Instructions
 9266 
 9267 // Integer Logical Instructions
 9268 
 9269 // And Instructions
 9270 // And Register with Register
 9271 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9272 %{
 9273   match(Set dst (AndI dst src));
 9274   effect(KILL cr);
 9275 
 9276   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9277   opcode(0x23);
 9278   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9279   ins_pipe(ialu_reg_reg);
 9280 %}
 9281 
 9282 // And Register with Immediate 255
 9283 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9284 %{
 9285   match(Set dst (AndI dst src));
 9286 
 9287   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9288   opcode(0x0F, 0xB6);
 9289   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9290   ins_pipe(ialu_reg);
 9291 %}
 9292 
 9293 // And Register with Immediate 255 and promote to long
 9294 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9295 %{
 9296   match(Set dst (ConvI2L (AndI src mask)));
 9297 
 9298   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9299   opcode(0x0F, 0xB6);
 9300   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9301   ins_pipe(ialu_reg);
 9302 %}
 9303 
 9304 // And Register with Immediate 65535
 9305 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9306 %{
 9307   match(Set dst (AndI dst src));
 9308 
 9309   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9310   opcode(0x0F, 0xB7);
 9311   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9312   ins_pipe(ialu_reg);
 9313 %}
 9314 
 9315 // And Register with Immediate 65535 and promote to long
 9316 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9317 %{
 9318   match(Set dst (ConvI2L (AndI src mask)));
 9319 
 9320   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9321   opcode(0x0F, 0xB7);
 9322   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9323   ins_pipe(ialu_reg);
 9324 %}
 9325 
 9326 // And Register with Immediate
 9327 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9328 %{
 9329   match(Set dst (AndI dst src));
 9330   effect(KILL cr);
 9331 
 9332   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9333   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9334   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9335   ins_pipe(ialu_reg);
 9336 %}
 9337 
 9338 // And Register with Memory
 9339 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9340 %{
 9341   match(Set dst (AndI dst (LoadI src)));
 9342   effect(KILL cr);
 9343 
 9344   ins_cost(125);
 9345   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9346   opcode(0x23);
 9347   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9348   ins_pipe(ialu_reg_mem);
 9349 %}
 9350 
 9351 // And Memory with Register
 9352 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9353 %{
 9354   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9355   effect(KILL cr);
 9356 
 9357   ins_cost(150);
 9358   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9359   opcode(0x20);
 9360   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9361   ins_pipe(ialu_mem_reg);
 9362 %}
 9363 
 9364 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9365 %{
 9366   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9367   effect(KILL cr);
 9368 
 9369   ins_cost(150);
 9370   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9371   opcode(0x21); /* Opcode 21 /r */
 9372   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9373   ins_pipe(ialu_mem_reg);
 9374 %}
 9375 
 9376 // And Memory with Immediate
 9377 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9378 %{
 9379   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9380   effect(KILL cr);
 9381 
 9382   ins_cost(125);
 9383   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9384   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9385   ins_encode(REX_mem(dst), OpcSE(src),
 9386              RM_opc_mem(secondary, dst), Con8or32(src));
 9387   ins_pipe(ialu_mem_imm);
 9388 %}
 9389 
 9390 // BMI1 instructions
 9391 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9392   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9393   predicate(UseBMI1Instructions);
 9394   effect(KILL cr);
 9395 
 9396   ins_cost(125);
 9397   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9398 
 9399   ins_encode %{
 9400     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9401   %}
 9402   ins_pipe(ialu_reg_mem);
 9403 %}
 9404 
 9405 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9406   match(Set dst (AndI (XorI src1 minus_1) src2));
 9407   predicate(UseBMI1Instructions);
 9408   effect(KILL cr);
 9409 
 9410   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9411 
 9412   ins_encode %{
 9413     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9414   %}
 9415   ins_pipe(ialu_reg);
 9416 %}
 9417 
 9418 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9419   match(Set dst (AndI (SubI imm_zero src) src));
 9420   predicate(UseBMI1Instructions);
 9421   effect(KILL cr);
 9422 
 9423   format %{ &quot;blsil  $dst, $src&quot; %}
 9424 
 9425   ins_encode %{
 9426     __ blsil($dst$$Register, $src$$Register);
 9427   %}
 9428   ins_pipe(ialu_reg);
 9429 %}
 9430 
 9431 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9432   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9433   predicate(UseBMI1Instructions);
 9434   effect(KILL cr);
 9435 
 9436   ins_cost(125);
 9437   format %{ &quot;blsil  $dst, $src&quot; %}
 9438 
 9439   ins_encode %{
 9440     __ blsil($dst$$Register, $src$$Address);
 9441   %}
 9442   ins_pipe(ialu_reg_mem);
 9443 %}
 9444 
 9445 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9446 %{
 9447   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9448   predicate(UseBMI1Instructions);
 9449   effect(KILL cr);
 9450 
 9451   ins_cost(125);
 9452   format %{ &quot;blsmskl $dst, $src&quot; %}
 9453 
 9454   ins_encode %{
 9455     __ blsmskl($dst$$Register, $src$$Address);
 9456   %}
 9457   ins_pipe(ialu_reg_mem);
 9458 %}
 9459 
 9460 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9461 %{
 9462   match(Set dst (XorI (AddI src minus_1) src));
 9463   predicate(UseBMI1Instructions);
 9464   effect(KILL cr);
 9465 
 9466   format %{ &quot;blsmskl $dst, $src&quot; %}
 9467 
 9468   ins_encode %{
 9469     __ blsmskl($dst$$Register, $src$$Register);
 9470   %}
 9471 
 9472   ins_pipe(ialu_reg);
 9473 %}
 9474 
 9475 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9476 %{
 9477   match(Set dst (AndI (AddI src minus_1) src) );
 9478   predicate(UseBMI1Instructions);
 9479   effect(KILL cr);
 9480 
 9481   format %{ &quot;blsrl  $dst, $src&quot; %}
 9482 
 9483   ins_encode %{
 9484     __ blsrl($dst$$Register, $src$$Register);
 9485   %}
 9486 
 9487   ins_pipe(ialu_reg_mem);
 9488 %}
 9489 
 9490 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9491 %{
 9492   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9493   predicate(UseBMI1Instructions);
 9494   effect(KILL cr);
 9495 
 9496   ins_cost(125);
 9497   format %{ &quot;blsrl  $dst, $src&quot; %}
 9498 
 9499   ins_encode %{
 9500     __ blsrl($dst$$Register, $src$$Address);
 9501   %}
 9502 
 9503   ins_pipe(ialu_reg);
 9504 %}
 9505 
 9506 // Or Instructions
 9507 // Or Register with Register
 9508 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9509 %{
 9510   match(Set dst (OrI dst src));
 9511   effect(KILL cr);
 9512 
 9513   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9514   opcode(0x0B);
 9515   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9516   ins_pipe(ialu_reg_reg);
 9517 %}
 9518 
 9519 // Or Register with Immediate
 9520 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9521 %{
 9522   match(Set dst (OrI dst src));
 9523   effect(KILL cr);
 9524 
 9525   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9526   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9527   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9528   ins_pipe(ialu_reg);
 9529 %}
 9530 
 9531 // Or Register with Memory
 9532 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9533 %{
 9534   match(Set dst (OrI dst (LoadI src)));
 9535   effect(KILL cr);
 9536 
 9537   ins_cost(125);
 9538   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9539   opcode(0x0B);
 9540   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9541   ins_pipe(ialu_reg_mem);
 9542 %}
 9543 
 9544 // Or Memory with Register
 9545 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9546 %{
 9547   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9548   effect(KILL cr);
 9549 
 9550   ins_cost(150);
 9551   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9552   opcode(0x08);
 9553   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9554   ins_pipe(ialu_mem_reg);
 9555 %}
 9556 
 9557 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9558 %{
 9559   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9560   effect(KILL cr);
 9561 
 9562   ins_cost(150);
 9563   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9564   opcode(0x09); /* Opcode 09 /r */
 9565   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9566   ins_pipe(ialu_mem_reg);
 9567 %}
 9568 
 9569 // Or Memory with Immediate
 9570 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9571 %{
 9572   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9573   effect(KILL cr);
 9574 
 9575   ins_cost(125);
 9576   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9577   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9578   ins_encode(REX_mem(dst), OpcSE(src),
 9579              RM_opc_mem(secondary, dst), Con8or32(src));
 9580   ins_pipe(ialu_mem_imm);
 9581 %}
 9582 
 9583 // Xor Instructions
 9584 // Xor Register with Register
 9585 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9586 %{
 9587   match(Set dst (XorI dst src));
 9588   effect(KILL cr);
 9589 
 9590   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9591   opcode(0x33);
 9592   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9593   ins_pipe(ialu_reg_reg);
 9594 %}
 9595 
 9596 // Xor Register with Immediate -1
 9597 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9598   match(Set dst (XorI dst imm));
 9599 
 9600   format %{ &quot;not    $dst&quot; %}
 9601   ins_encode %{
 9602      __ notl($dst$$Register);
 9603   %}
 9604   ins_pipe(ialu_reg);
 9605 %}
 9606 
 9607 // Xor Register with Immediate
 9608 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9609 %{
 9610   match(Set dst (XorI dst src));
 9611   effect(KILL cr);
 9612 
 9613   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9614   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9615   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9616   ins_pipe(ialu_reg);
 9617 %}
 9618 
 9619 // Xor Register with Memory
 9620 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9621 %{
 9622   match(Set dst (XorI dst (LoadI src)));
 9623   effect(KILL cr);
 9624 
 9625   ins_cost(125);
 9626   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9627   opcode(0x33);
 9628   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9629   ins_pipe(ialu_reg_mem);
 9630 %}
 9631 
 9632 // Xor Memory with Register
 9633 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9634 %{
 9635   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9636   effect(KILL cr);
 9637 
 9638   ins_cost(150);
 9639   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9640   opcode(0x30);
 9641   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9642   ins_pipe(ialu_mem_reg);
 9643 %}
 9644 
 9645 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9646 %{
 9647   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9648   effect(KILL cr);
 9649 
 9650   ins_cost(150);
 9651   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9652   opcode(0x31); /* Opcode 31 /r */
 9653   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9654   ins_pipe(ialu_mem_reg);
 9655 %}
 9656 
 9657 // Xor Memory with Immediate
 9658 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9659 %{
 9660   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9661   effect(KILL cr);
 9662 
 9663   ins_cost(125);
 9664   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9665   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9666   ins_encode(REX_mem(dst), OpcSE(src),
 9667              RM_opc_mem(secondary, dst), Con8or32(src));
 9668   ins_pipe(ialu_mem_imm);
 9669 %}
 9670 
 9671 
 9672 // Long Logical Instructions
 9673 
 9674 // And Instructions
 9675 // And Register with Register
 9676 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9677 %{
 9678   match(Set dst (AndL dst src));
 9679   effect(KILL cr);
 9680 
 9681   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9682   opcode(0x23);
 9683   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9684   ins_pipe(ialu_reg_reg);
 9685 %}
 9686 
 9687 // And Register with Immediate 255
 9688 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9689 %{
 9690   match(Set dst (AndL dst src));
 9691 
 9692   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9693   opcode(0x0F, 0xB6);
 9694   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9695   ins_pipe(ialu_reg);
 9696 %}
 9697 
 9698 // And Register with Immediate 65535
 9699 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9700 %{
 9701   match(Set dst (AndL dst src));
 9702 
 9703   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9704   opcode(0x0F, 0xB7);
 9705   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9706   ins_pipe(ialu_reg);
 9707 %}
 9708 
 9709 // And Register with Immediate
 9710 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9711 %{
 9712   match(Set dst (AndL dst src));
 9713   effect(KILL cr);
 9714 
 9715   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9716   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9717   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9718   ins_pipe(ialu_reg);
 9719 %}
 9720 
 9721 // And Register with Memory
 9722 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9723 %{
 9724   match(Set dst (AndL dst (LoadL src)));
 9725   effect(KILL cr);
 9726 
 9727   ins_cost(125);
 9728   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9729   opcode(0x23);
 9730   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9731   ins_pipe(ialu_reg_mem);
 9732 %}
 9733 
 9734 // And Memory with Register
 9735 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9736 %{
 9737   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9738   effect(KILL cr);
 9739 
 9740   ins_cost(150);
 9741   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9742   opcode(0x21); /* Opcode 21 /r */
 9743   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9744   ins_pipe(ialu_mem_reg);
 9745 %}
 9746 
 9747 // And Memory with Immediate
 9748 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9749 %{
 9750   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9751   effect(KILL cr);
 9752 
 9753   ins_cost(125);
 9754   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9755   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9756   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9757              RM_opc_mem(secondary, dst), Con8or32(src));
 9758   ins_pipe(ialu_mem_imm);
 9759 %}
 9760 
 9761 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9762 %{
 9763   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9764   // because AND/OR works well enough for 8/32-bit values.
 9765   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9766 
 9767   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9768   effect(KILL cr);
 9769 
 9770   ins_cost(125);
 9771   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9772   ins_encode %{
 9773     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9774   %}
 9775   ins_pipe(ialu_mem_imm);
 9776 %}
 9777 
 9778 // BMI1 instructions
 9779 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9780   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9781   predicate(UseBMI1Instructions);
 9782   effect(KILL cr);
 9783 
 9784   ins_cost(125);
 9785   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9786 
 9787   ins_encode %{
 9788     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9789   %}
 9790   ins_pipe(ialu_reg_mem);
 9791 %}
 9792 
 9793 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9794   match(Set dst (AndL (XorL src1 minus_1) src2));
 9795   predicate(UseBMI1Instructions);
 9796   effect(KILL cr);
 9797 
 9798   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9799 
 9800   ins_encode %{
 9801   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9802   %}
 9803   ins_pipe(ialu_reg_mem);
 9804 %}
 9805 
 9806 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9807   match(Set dst (AndL (SubL imm_zero src) src));
 9808   predicate(UseBMI1Instructions);
 9809   effect(KILL cr);
 9810 
 9811   format %{ &quot;blsiq  $dst, $src&quot; %}
 9812 
 9813   ins_encode %{
 9814     __ blsiq($dst$$Register, $src$$Register);
 9815   %}
 9816   ins_pipe(ialu_reg);
 9817 %}
 9818 
 9819 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9820   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9821   predicate(UseBMI1Instructions);
 9822   effect(KILL cr);
 9823 
 9824   ins_cost(125);
 9825   format %{ &quot;blsiq  $dst, $src&quot; %}
 9826 
 9827   ins_encode %{
 9828     __ blsiq($dst$$Register, $src$$Address);
 9829   %}
 9830   ins_pipe(ialu_reg_mem);
 9831 %}
 9832 
 9833 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9834 %{
 9835   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9836   predicate(UseBMI1Instructions);
 9837   effect(KILL cr);
 9838 
 9839   ins_cost(125);
 9840   format %{ &quot;blsmskq $dst, $src&quot; %}
 9841 
 9842   ins_encode %{
 9843     __ blsmskq($dst$$Register, $src$$Address);
 9844   %}
 9845   ins_pipe(ialu_reg_mem);
 9846 %}
 9847 
 9848 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9849 %{
 9850   match(Set dst (XorL (AddL src minus_1) src));
 9851   predicate(UseBMI1Instructions);
 9852   effect(KILL cr);
 9853 
 9854   format %{ &quot;blsmskq $dst, $src&quot; %}
 9855 
 9856   ins_encode %{
 9857     __ blsmskq($dst$$Register, $src$$Register);
 9858   %}
 9859 
 9860   ins_pipe(ialu_reg);
 9861 %}
 9862 
 9863 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9864 %{
 9865   match(Set dst (AndL (AddL src minus_1) src) );
 9866   predicate(UseBMI1Instructions);
 9867   effect(KILL cr);
 9868 
 9869   format %{ &quot;blsrq  $dst, $src&quot; %}
 9870 
 9871   ins_encode %{
 9872     __ blsrq($dst$$Register, $src$$Register);
 9873   %}
 9874 
 9875   ins_pipe(ialu_reg);
 9876 %}
 9877 
 9878 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9879 %{
 9880   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9881   predicate(UseBMI1Instructions);
 9882   effect(KILL cr);
 9883 
 9884   ins_cost(125);
 9885   format %{ &quot;blsrq  $dst, $src&quot; %}
 9886 
 9887   ins_encode %{
 9888     __ blsrq($dst$$Register, $src$$Address);
 9889   %}
 9890 
 9891   ins_pipe(ialu_reg);
 9892 %}
 9893 
 9894 // Or Instructions
 9895 // Or Register with Register
 9896 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9897 %{
 9898   match(Set dst (OrL dst src));
 9899   effect(KILL cr);
 9900 
 9901   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9902   opcode(0x0B);
 9903   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9904   ins_pipe(ialu_reg_reg);
 9905 %}
 9906 
 9907 // Use any_RegP to match R15 (TLS register) without spilling.
 9908 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
 9909   match(Set dst (OrL dst (CastP2X src)));
 9910   effect(KILL cr);
 9911 
 9912   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9913   opcode(0x0B);
 9914   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9915   ins_pipe(ialu_reg_reg);
 9916 %}
 9917 
 9918 
 9919 // Or Register with Immediate
 9920 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9921 %{
 9922   match(Set dst (OrL dst src));
 9923   effect(KILL cr);
 9924 
 9925   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9926   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9927   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9928   ins_pipe(ialu_reg);
 9929 %}
 9930 
 9931 // Or Register with Memory
 9932 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9933 %{
 9934   match(Set dst (OrL dst (LoadL src)));
 9935   effect(KILL cr);
 9936 
 9937   ins_cost(125);
 9938   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9939   opcode(0x0B);
 9940   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9941   ins_pipe(ialu_reg_mem);
 9942 %}
 9943 
 9944 // Or Memory with Register
 9945 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9946 %{
 9947   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9948   effect(KILL cr);
 9949 
 9950   ins_cost(150);
 9951   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9952   opcode(0x09); /* Opcode 09 /r */
 9953   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9954   ins_pipe(ialu_mem_reg);
 9955 %}
 9956 
 9957 // Or Memory with Immediate
 9958 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9959 %{
 9960   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9961   effect(KILL cr);
 9962 
 9963   ins_cost(125);
 9964   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9965   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9966   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9967              RM_opc_mem(secondary, dst), Con8or32(src));
 9968   ins_pipe(ialu_mem_imm);
 9969 %}
 9970 
 9971 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
 9972 %{
 9973   // con should be a pure 64-bit power of 2 immediate
 9974   // because AND/OR works well enough for 8/32-bit values.
 9975   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
 9976 
 9977   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
 9978   effect(KILL cr);
 9979 
 9980   ins_cost(125);
 9981   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
 9982   ins_encode %{
 9983     __ btsq($dst$$Address, log2_long((julong)$con$$constant));
 9984   %}
 9985   ins_pipe(ialu_mem_imm);
 9986 %}
 9987 
 9988 // Xor Instructions
 9989 // Xor Register with Register
 9990 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9991 %{
 9992   match(Set dst (XorL dst src));
 9993   effect(KILL cr);
 9994 
 9995   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
 9996   opcode(0x33);
 9997   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9998   ins_pipe(ialu_reg_reg);
 9999 %}
10000 
10001 // Xor Register with Immediate -1
10002 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10003   match(Set dst (XorL dst imm));
10004 
10005   format %{ &quot;notq   $dst&quot; %}
10006   ins_encode %{
10007      __ notq($dst$$Register);
10008   %}
10009   ins_pipe(ialu_reg);
10010 %}
10011 
10012 // Xor Register with Immediate
10013 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10014 %{
10015   match(Set dst (XorL dst src));
10016   effect(KILL cr);
10017 
10018   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10019   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10020   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10021   ins_pipe(ialu_reg);
10022 %}
10023 
10024 // Xor Register with Memory
10025 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10026 %{
10027   match(Set dst (XorL dst (LoadL src)));
10028   effect(KILL cr);
10029 
10030   ins_cost(125);
10031   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10032   opcode(0x33);
10033   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10034   ins_pipe(ialu_reg_mem);
10035 %}
10036 
10037 // Xor Memory with Register
10038 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10039 %{
10040   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10041   effect(KILL cr);
10042 
10043   ins_cost(150);
10044   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10045   opcode(0x31); /* Opcode 31 /r */
10046   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10047   ins_pipe(ialu_mem_reg);
10048 %}
10049 
10050 // Xor Memory with Immediate
10051 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10052 %{
10053   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10054   effect(KILL cr);
10055 
10056   ins_cost(125);
10057   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10058   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10059   ins_encode(REX_mem_wide(dst), OpcSE(src),
10060              RM_opc_mem(secondary, dst), Con8or32(src));
10061   ins_pipe(ialu_mem_imm);
10062 %}
10063 
10064 // Convert Int to Boolean
10065 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10066 %{
10067   match(Set dst (Conv2B src));
10068   effect(KILL cr);
10069 
10070   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10071             &quot;setnz   $dst\n\t&quot;
10072             &quot;movzbl  $dst, $dst&quot; %}
10073   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10074              setNZ_reg(dst),
10075              REX_reg_breg(dst, dst), // movzbl
10076              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10077   ins_pipe(pipe_slow); // XXX
10078 %}
10079 
10080 // Convert Pointer to Boolean
10081 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10082 %{
10083   match(Set dst (Conv2B src));
10084   effect(KILL cr);
10085 
10086   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10087             &quot;setnz   $dst\n\t&quot;
10088             &quot;movzbl  $dst, $dst&quot; %}
10089   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10090              setNZ_reg(dst),
10091              REX_reg_breg(dst, dst), // movzbl
10092              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10093   ins_pipe(pipe_slow); // XXX
10094 %}
10095 
10096 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10097 %{
10098   match(Set dst (CmpLTMask p q));
10099   effect(KILL cr);
10100 
10101   ins_cost(400);
10102   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10103             &quot;setlt   $dst\n\t&quot;
10104             &quot;movzbl  $dst, $dst\n\t&quot;
10105             &quot;negl    $dst&quot; %}
10106   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10107              setLT_reg(dst),
10108              REX_reg_breg(dst, dst), // movzbl
10109              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10110              neg_reg(dst));
10111   ins_pipe(pipe_slow);
10112 %}
10113 
10114 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10115 %{
10116   match(Set dst (CmpLTMask dst zero));
10117   effect(KILL cr);
10118 
10119   ins_cost(100);
10120   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10121   ins_encode %{
10122   __ sarl($dst$$Register, 31);
10123   %}
10124   ins_pipe(ialu_reg);
10125 %}
10126 
10127 /* Better to save a register than avoid a branch */
10128 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10129 %{
10130   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10131   effect(KILL cr);
10132   ins_cost(300);
10133   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10134             &quot;jge     done\n\t&quot;
10135             &quot;addl    $p,$y\n&quot;
10136             &quot;done:   &quot; %}
10137   ins_encode %{
10138     Register Rp = $p$$Register;
10139     Register Rq = $q$$Register;
10140     Register Ry = $y$$Register;
10141     Label done;
10142     __ subl(Rp, Rq);
10143     __ jccb(Assembler::greaterEqual, done);
10144     __ addl(Rp, Ry);
10145     __ bind(done);
10146   %}
10147   ins_pipe(pipe_cmplt);
10148 %}
10149 
10150 /* Better to save a register than avoid a branch */
10151 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10152 %{
10153   match(Set y (AndI (CmpLTMask p q) y));
10154   effect(KILL cr);
10155 
10156   ins_cost(300);
10157 
10158   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10159             &quot;jlt     done\n\t&quot;
10160             &quot;xorl    $y, $y\n&quot;
10161             &quot;done:   &quot; %}
10162   ins_encode %{
10163     Register Rp = $p$$Register;
10164     Register Rq = $q$$Register;
10165     Register Ry = $y$$Register;
10166     Label done;
10167     __ cmpl(Rp, Rq);
10168     __ jccb(Assembler::less, done);
10169     __ xorl(Ry, Ry);
10170     __ bind(done);
10171   %}
10172   ins_pipe(pipe_cmplt);
10173 %}
10174 
10175 
10176 //---------- FP Instructions------------------------------------------------
10177 
10178 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10179 %{
10180   match(Set cr (CmpF src1 src2));
10181 
10182   ins_cost(145);
10183   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10184             &quot;jnp,s   exit\n\t&quot;
10185             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10186             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10187             &quot;popfq\n&quot;
10188     &quot;exit:&quot; %}
10189   ins_encode %{
10190     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10191     emit_cmpfp_fixup(_masm);
10192   %}
10193   ins_pipe(pipe_slow);
10194 %}
10195 
10196 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10197   match(Set cr (CmpF src1 src2));
10198 
10199   ins_cost(100);
10200   format %{ &quot;ucomiss $src1, $src2&quot; %}
10201   ins_encode %{
10202     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10203   %}
10204   ins_pipe(pipe_slow);
10205 %}
10206 
10207 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10208 %{
10209   match(Set cr (CmpF src1 (LoadF src2)));
10210 
10211   ins_cost(145);
10212   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10213             &quot;jnp,s   exit\n\t&quot;
10214             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10215             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10216             &quot;popfq\n&quot;
10217     &quot;exit:&quot; %}
10218   ins_encode %{
10219     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10220     emit_cmpfp_fixup(_masm);
10221   %}
10222   ins_pipe(pipe_slow);
10223 %}
10224 
10225 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10226   match(Set cr (CmpF src1 (LoadF src2)));
10227 
10228   ins_cost(100);
10229   format %{ &quot;ucomiss $src1, $src2&quot; %}
10230   ins_encode %{
10231     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10232   %}
10233   ins_pipe(pipe_slow);
10234 %}
10235 
10236 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10237   match(Set cr (CmpF src con));
10238 
10239   ins_cost(145);
10240   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10241             &quot;jnp,s   exit\n\t&quot;
10242             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10243             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10244             &quot;popfq\n&quot;
10245     &quot;exit:&quot; %}
10246   ins_encode %{
10247     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10248     emit_cmpfp_fixup(_masm);
10249   %}
10250   ins_pipe(pipe_slow);
10251 %}
10252 
10253 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10254   match(Set cr (CmpF src con));
10255   ins_cost(100);
10256   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10257   ins_encode %{
10258     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10259   %}
10260   ins_pipe(pipe_slow);
10261 %}
10262 
10263 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10264 %{
10265   match(Set cr (CmpD src1 src2));
10266 
10267   ins_cost(145);
10268   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10269             &quot;jnp,s   exit\n\t&quot;
10270             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10271             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10272             &quot;popfq\n&quot;
10273     &quot;exit:&quot; %}
10274   ins_encode %{
10275     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10276     emit_cmpfp_fixup(_masm);
10277   %}
10278   ins_pipe(pipe_slow);
10279 %}
10280 
10281 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10282   match(Set cr (CmpD src1 src2));
10283 
10284   ins_cost(100);
10285   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10286   ins_encode %{
10287     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10288   %}
10289   ins_pipe(pipe_slow);
10290 %}
10291 
10292 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10293 %{
10294   match(Set cr (CmpD src1 (LoadD src2)));
10295 
10296   ins_cost(145);
10297   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10298             &quot;jnp,s   exit\n\t&quot;
10299             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10300             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10301             &quot;popfq\n&quot;
10302     &quot;exit:&quot; %}
10303   ins_encode %{
10304     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10305     emit_cmpfp_fixup(_masm);
10306   %}
10307   ins_pipe(pipe_slow);
10308 %}
10309 
10310 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10311   match(Set cr (CmpD src1 (LoadD src2)));
10312 
10313   ins_cost(100);
10314   format %{ &quot;ucomisd $src1, $src2&quot; %}
10315   ins_encode %{
10316     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10317   %}
10318   ins_pipe(pipe_slow);
10319 %}
10320 
10321 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10322   match(Set cr (CmpD src con));
10323 
10324   ins_cost(145);
10325   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10326             &quot;jnp,s   exit\n\t&quot;
10327             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10328             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10329             &quot;popfq\n&quot;
10330     &quot;exit:&quot; %}
10331   ins_encode %{
10332     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10333     emit_cmpfp_fixup(_masm);
10334   %}
10335   ins_pipe(pipe_slow);
10336 %}
10337 
10338 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10339   match(Set cr (CmpD src con));
10340   ins_cost(100);
10341   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10342   ins_encode %{
10343     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10344   %}
10345   ins_pipe(pipe_slow);
10346 %}
10347 
10348 // Compare into -1,0,1
10349 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10350 %{
10351   match(Set dst (CmpF3 src1 src2));
10352   effect(KILL cr);
10353 
10354   ins_cost(275);
10355   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10356             &quot;movl    $dst, #-1\n\t&quot;
10357             &quot;jp,s    done\n\t&quot;
10358             &quot;jb,s    done\n\t&quot;
10359             &quot;setne   $dst\n\t&quot;
10360             &quot;movzbl  $dst, $dst\n&quot;
10361     &quot;done:&quot; %}
10362   ins_encode %{
10363     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10364     emit_cmpfp3(_masm, $dst$$Register);
10365   %}
10366   ins_pipe(pipe_slow);
10367 %}
10368 
10369 // Compare into -1,0,1
10370 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10371 %{
10372   match(Set dst (CmpF3 src1 (LoadF src2)));
10373   effect(KILL cr);
10374 
10375   ins_cost(275);
10376   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10377             &quot;movl    $dst, #-1\n\t&quot;
10378             &quot;jp,s    done\n\t&quot;
10379             &quot;jb,s    done\n\t&quot;
10380             &quot;setne   $dst\n\t&quot;
10381             &quot;movzbl  $dst, $dst\n&quot;
10382     &quot;done:&quot; %}
10383   ins_encode %{
10384     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10385     emit_cmpfp3(_masm, $dst$$Register);
10386   %}
10387   ins_pipe(pipe_slow);
10388 %}
10389 
10390 // Compare into -1,0,1
10391 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10392   match(Set dst (CmpF3 src con));
10393   effect(KILL cr);
10394 
10395   ins_cost(275);
10396   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10397             &quot;movl    $dst, #-1\n\t&quot;
10398             &quot;jp,s    done\n\t&quot;
10399             &quot;jb,s    done\n\t&quot;
10400             &quot;setne   $dst\n\t&quot;
10401             &quot;movzbl  $dst, $dst\n&quot;
10402     &quot;done:&quot; %}
10403   ins_encode %{
10404     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10405     emit_cmpfp3(_masm, $dst$$Register);
10406   %}
10407   ins_pipe(pipe_slow);
10408 %}
10409 
10410 // Compare into -1,0,1
10411 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10412 %{
10413   match(Set dst (CmpD3 src1 src2));
10414   effect(KILL cr);
10415 
10416   ins_cost(275);
10417   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10418             &quot;movl    $dst, #-1\n\t&quot;
10419             &quot;jp,s    done\n\t&quot;
10420             &quot;jb,s    done\n\t&quot;
10421             &quot;setne   $dst\n\t&quot;
10422             &quot;movzbl  $dst, $dst\n&quot;
10423     &quot;done:&quot; %}
10424   ins_encode %{
10425     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10426     emit_cmpfp3(_masm, $dst$$Register);
10427   %}
10428   ins_pipe(pipe_slow);
10429 %}
10430 
10431 // Compare into -1,0,1
10432 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10433 %{
10434   match(Set dst (CmpD3 src1 (LoadD src2)));
10435   effect(KILL cr);
10436 
10437   ins_cost(275);
10438   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10439             &quot;movl    $dst, #-1\n\t&quot;
10440             &quot;jp,s    done\n\t&quot;
10441             &quot;jb,s    done\n\t&quot;
10442             &quot;setne   $dst\n\t&quot;
10443             &quot;movzbl  $dst, $dst\n&quot;
10444     &quot;done:&quot; %}
10445   ins_encode %{
10446     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10447     emit_cmpfp3(_masm, $dst$$Register);
10448   %}
10449   ins_pipe(pipe_slow);
10450 %}
10451 
10452 // Compare into -1,0,1
10453 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10454   match(Set dst (CmpD3 src con));
10455   effect(KILL cr);
10456 
10457   ins_cost(275);
10458   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10459             &quot;movl    $dst, #-1\n\t&quot;
10460             &quot;jp,s    done\n\t&quot;
10461             &quot;jb,s    done\n\t&quot;
10462             &quot;setne   $dst\n\t&quot;
10463             &quot;movzbl  $dst, $dst\n&quot;
10464     &quot;done:&quot; %}
10465   ins_encode %{
10466     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10467     emit_cmpfp3(_masm, $dst$$Register);
10468   %}
10469   ins_pipe(pipe_slow);
10470 %}
10471 
10472 //----------Arithmetic Conversion Instructions---------------------------------
10473 
10474 instruct convF2D_reg_reg(regD dst, regF src)
10475 %{
10476   match(Set dst (ConvF2D src));
10477 
10478   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10479   ins_encode %{
10480     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10481   %}
10482   ins_pipe(pipe_slow); // XXX
10483 %}
10484 
10485 instruct convF2D_reg_mem(regD dst, memory src)
10486 %{
10487   match(Set dst (ConvF2D (LoadF src)));
10488 
10489   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10490   ins_encode %{
10491     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10492   %}
10493   ins_pipe(pipe_slow); // XXX
10494 %}
10495 
10496 instruct convD2F_reg_reg(regF dst, regD src)
10497 %{
10498   match(Set dst (ConvD2F src));
10499 
10500   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10501   ins_encode %{
10502     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10503   %}
10504   ins_pipe(pipe_slow); // XXX
10505 %}
10506 
10507 instruct convD2F_reg_mem(regF dst, memory src)
10508 %{
10509   match(Set dst (ConvD2F (LoadD src)));
10510 
10511   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10512   ins_encode %{
10513     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10514   %}
10515   ins_pipe(pipe_slow); // XXX
10516 %}
10517 
10518 // XXX do mem variants
10519 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10520 %{
10521   match(Set dst (ConvF2I src));
10522   effect(KILL cr);
10523   format %{ &quot;convert_f2i $dst,$src&quot; %}
10524   ins_encode %{
10525     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10526   %}
10527   ins_pipe(pipe_slow);
10528 %}
10529 
10530 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10531 %{
10532   match(Set dst (ConvF2L src));
10533   effect(KILL cr);
10534   format %{ &quot;convert_f2l $dst,$src&quot;%}
10535   ins_encode %{
10536     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10537   %}
10538   ins_pipe(pipe_slow);
10539 %}
10540 
10541 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10542 %{
10543   match(Set dst (ConvD2I src));
10544   effect(KILL cr);
10545   format %{ &quot;convert_d2i $dst,$src&quot;%}
10546   ins_encode %{
10547     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10548   %}
10549   ins_pipe(pipe_slow);
10550 %}
10551 
10552 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10553 %{
10554   match(Set dst (ConvD2L src));
10555   effect(KILL cr);
10556   format %{ &quot;convert_d2l $dst,$src&quot;%}
10557   ins_encode %{
10558     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10559   %}
10560   ins_pipe(pipe_slow);
10561 %}
10562 
10563 instruct convI2F_reg_reg(regF dst, rRegI src)
10564 %{
10565   predicate(!UseXmmI2F);
10566   match(Set dst (ConvI2F src));
10567 
10568   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10569   ins_encode %{
10570     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10571   %}
10572   ins_pipe(pipe_slow); // XXX
10573 %}
10574 
10575 instruct convI2F_reg_mem(regF dst, memory src)
10576 %{
10577   match(Set dst (ConvI2F (LoadI src)));
10578 
10579   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10580   ins_encode %{
10581     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10582   %}
10583   ins_pipe(pipe_slow); // XXX
10584 %}
10585 
10586 instruct convI2D_reg_reg(regD dst, rRegI src)
10587 %{
10588   predicate(!UseXmmI2D);
10589   match(Set dst (ConvI2D src));
10590 
10591   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10592   ins_encode %{
10593     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10594   %}
10595   ins_pipe(pipe_slow); // XXX
10596 %}
10597 
10598 instruct convI2D_reg_mem(regD dst, memory src)
10599 %{
10600   match(Set dst (ConvI2D (LoadI src)));
10601 
10602   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10603   ins_encode %{
10604     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10605   %}
10606   ins_pipe(pipe_slow); // XXX
10607 %}
10608 
10609 instruct convXI2F_reg(regF dst, rRegI src)
10610 %{
10611   predicate(UseXmmI2F);
10612   match(Set dst (ConvI2F src));
10613 
10614   format %{ &quot;movdl $dst, $src\n\t&quot;
10615             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10616   ins_encode %{
10617     __ movdl($dst$$XMMRegister, $src$$Register);
10618     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10619   %}
10620   ins_pipe(pipe_slow); // XXX
10621 %}
10622 
10623 instruct convXI2D_reg(regD dst, rRegI src)
10624 %{
10625   predicate(UseXmmI2D);
10626   match(Set dst (ConvI2D src));
10627 
10628   format %{ &quot;movdl $dst, $src\n\t&quot;
10629             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10630   ins_encode %{
10631     __ movdl($dst$$XMMRegister, $src$$Register);
10632     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10633   %}
10634   ins_pipe(pipe_slow); // XXX
10635 %}
10636 
10637 instruct convL2F_reg_reg(regF dst, rRegL src)
10638 %{
10639   match(Set dst (ConvL2F src));
10640 
10641   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10642   ins_encode %{
10643     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10644   %}
10645   ins_pipe(pipe_slow); // XXX
10646 %}
10647 
10648 instruct convL2F_reg_mem(regF dst, memory src)
10649 %{
10650   match(Set dst (ConvL2F (LoadL src)));
10651 
10652   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10653   ins_encode %{
10654     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10655   %}
10656   ins_pipe(pipe_slow); // XXX
10657 %}
10658 
10659 instruct convL2D_reg_reg(regD dst, rRegL src)
10660 %{
10661   match(Set dst (ConvL2D src));
10662 
10663   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10664   ins_encode %{
10665     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10666   %}
10667   ins_pipe(pipe_slow); // XXX
10668 %}
10669 
10670 instruct convL2D_reg_mem(regD dst, memory src)
10671 %{
10672   match(Set dst (ConvL2D (LoadL src)));
10673 
10674   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10675   ins_encode %{
10676     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10677   %}
10678   ins_pipe(pipe_slow); // XXX
10679 %}
10680 
10681 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10682 %{
10683   match(Set dst (ConvI2L src));
10684 
10685   ins_cost(125);
10686   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10687   ins_encode %{
10688     __ movslq($dst$$Register, $src$$Register);
10689   %}
10690   ins_pipe(ialu_reg_reg);
10691 %}
10692 
10693 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10694 // %{
10695 //   match(Set dst (ConvI2L src));
10696 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10697 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10698 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10699 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10700 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10701 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10702 
10703 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10704 //   ins_encode(enc_copy(dst, src));
10705 // //   opcode(0x63); // needs REX.W
10706 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10707 //   ins_pipe(ialu_reg_reg);
10708 // %}
10709 
10710 // Zero-extend convert int to long
10711 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10712 %{
10713   match(Set dst (AndL (ConvI2L src) mask));
10714 
10715   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10716   ins_encode %{
10717     if ($dst$$reg != $src$$reg) {
10718       __ movl($dst$$Register, $src$$Register);
10719     }
10720   %}
10721   ins_pipe(ialu_reg_reg);
10722 %}
10723 
10724 // Zero-extend convert int to long
10725 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10726 %{
10727   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10728 
10729   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10730   ins_encode %{
10731     __ movl($dst$$Register, $src$$Address);
10732   %}
10733   ins_pipe(ialu_reg_mem);
10734 %}
10735 
10736 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10737 %{
10738   match(Set dst (AndL src mask));
10739 
10740   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10741   ins_encode %{
10742     __ movl($dst$$Register, $src$$Register);
10743   %}
10744   ins_pipe(ialu_reg_reg);
10745 %}
10746 
10747 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10748 %{
10749   match(Set dst (ConvL2I src));
10750 
10751   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10752   ins_encode %{
10753     __ movl($dst$$Register, $src$$Register);
10754   %}
10755   ins_pipe(ialu_reg_reg);
10756 %}
10757 
10758 
10759 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10760   match(Set dst (MoveF2I src));
10761   effect(DEF dst, USE src);
10762 
10763   ins_cost(125);
10764   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10765   ins_encode %{
10766     __ movl($dst$$Register, Address(rsp, $src$$disp));
10767   %}
10768   ins_pipe(ialu_reg_mem);
10769 %}
10770 
10771 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10772   match(Set dst (MoveI2F src));
10773   effect(DEF dst, USE src);
10774 
10775   ins_cost(125);
10776   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10777   ins_encode %{
10778     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10779   %}
10780   ins_pipe(pipe_slow);
10781 %}
10782 
10783 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10784   match(Set dst (MoveD2L src));
10785   effect(DEF dst, USE src);
10786 
10787   ins_cost(125);
10788   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10789   ins_encode %{
10790     __ movq($dst$$Register, Address(rsp, $src$$disp));
10791   %}
10792   ins_pipe(ialu_reg_mem);
10793 %}
10794 
10795 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10796   predicate(!UseXmmLoadAndClearUpper);
10797   match(Set dst (MoveL2D src));
10798   effect(DEF dst, USE src);
10799 
10800   ins_cost(125);
10801   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10802   ins_encode %{
10803     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10804   %}
10805   ins_pipe(pipe_slow);
10806 %}
10807 
10808 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10809   predicate(UseXmmLoadAndClearUpper);
10810   match(Set dst (MoveL2D src));
10811   effect(DEF dst, USE src);
10812 
10813   ins_cost(125);
10814   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10815   ins_encode %{
10816     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10817   %}
10818   ins_pipe(pipe_slow);
10819 %}
10820 
10821 
10822 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10823   match(Set dst (MoveF2I src));
10824   effect(DEF dst, USE src);
10825 
10826   ins_cost(95); // XXX
10827   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10828   ins_encode %{
10829     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10830   %}
10831   ins_pipe(pipe_slow);
10832 %}
10833 
10834 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10835   match(Set dst (MoveI2F src));
10836   effect(DEF dst, USE src);
10837 
10838   ins_cost(100);
10839   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10840   ins_encode %{
10841     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10842   %}
10843   ins_pipe( ialu_mem_reg );
10844 %}
10845 
10846 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10847   match(Set dst (MoveD2L src));
10848   effect(DEF dst, USE src);
10849 
10850   ins_cost(95); // XXX
10851   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10852   ins_encode %{
10853     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10854   %}
10855   ins_pipe(pipe_slow);
10856 %}
10857 
10858 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10859   match(Set dst (MoveL2D src));
10860   effect(DEF dst, USE src);
10861 
10862   ins_cost(100);
10863   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10864   ins_encode %{
10865     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10866   %}
10867   ins_pipe(ialu_mem_reg);
10868 %}
10869 
10870 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10871   match(Set dst (MoveF2I src));
10872   effect(DEF dst, USE src);
10873   ins_cost(85);
10874   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10875   ins_encode %{
10876     __ movdl($dst$$Register, $src$$XMMRegister);
10877   %}
10878   ins_pipe( pipe_slow );
10879 %}
10880 
10881 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10882   match(Set dst (MoveD2L src));
10883   effect(DEF dst, USE src);
10884   ins_cost(85);
10885   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10886   ins_encode %{
10887     __ movdq($dst$$Register, $src$$XMMRegister);
10888   %}
10889   ins_pipe( pipe_slow );
10890 %}
10891 
10892 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10893   match(Set dst (MoveI2F src));
10894   effect(DEF dst, USE src);
10895   ins_cost(100);
10896   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10897   ins_encode %{
10898     __ movdl($dst$$XMMRegister, $src$$Register);
10899   %}
10900   ins_pipe( pipe_slow );
10901 %}
10902 
10903 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10904   match(Set dst (MoveL2D src));
10905   effect(DEF dst, USE src);
10906   ins_cost(100);
10907   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10908   ins_encode %{
10909      __ movdq($dst$$XMMRegister, $src$$Register);
10910   %}
10911   ins_pipe( pipe_slow );
10912 %}
10913 
10914 
10915 // =======================================================================
10916 // fast clearing of an array
10917 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
10918                   Universe dummy, rFlagsReg cr)
10919 %{
10920   predicate(!((ClearArrayNode*)n)-&gt;is_large());
10921   match(Set dummy (ClearArray cnt base));
10922   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
10923 
10924   format %{ $$template
10925     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
10926     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10927     $$emit$$&quot;jg      LARGE\n\t&quot;
10928     $$emit$$&quot;dec     rcx\n\t&quot;
10929     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10930     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10931     $$emit$$&quot;dec     rcx\n\t&quot;
10932     $$emit$$&quot;jge     LOOP\n\t&quot;
10933     $$emit$$&quot;jmp     DONE\n\t&quot;
10934     $$emit$$&quot;# LARGE:\n\t&quot;
10935     if (UseFastStosb) {
10936        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10937        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10938     } else if (UseXMMForObjInit) {
10939        $$emit$$&quot;mov     rdi,rax\n\t&quot;
10940        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
10941        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10942        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10943        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10944        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
10945        $$emit$$&quot;add     0x40,rax\n\t&quot;
10946        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10947        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10948        $$emit$$&quot;jge     L_loop\n\t&quot;
10949        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10950        $$emit$$&quot;jl      L_tail\n\t&quot;
10951        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10952        $$emit$$&quot;add     0x20,rax\n\t&quot;
10953        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
10954        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
10955        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10956        $$emit$$&quot;jle     L_end\n\t&quot;
10957        $$emit$$&quot;dec     rcx\n\t&quot;
10958        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
10959        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
10960        $$emit$$&quot;add     0x8,rax\n\t&quot;
10961        $$emit$$&quot;dec     rcx\n\t&quot;
10962        $$emit$$&quot;jge     L_sloop\n\t&quot;
10963        $$emit$$&quot;# L_end:\n\t&quot;
10964     } else {
10965        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
10966     }
10967     $$emit$$&quot;# DONE&quot;
10968   %}
10969   ins_encode %{
10970     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
10971                  $tmp$$XMMRegister, false);
10972   %}
10973   ins_pipe(pipe_slow);
10974 %}
10975 
10976 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
10977                         Universe dummy, rFlagsReg cr)
10978 %{
10979   predicate(((ClearArrayNode*)n)-&gt;is_large());
10980   match(Set dummy (ClearArray cnt base));
10981   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
10982 
10983   format %{ $$template
10984     if (UseFastStosb) {
10985        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
10986        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10987        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
10988     } else if (UseXMMForObjInit) {
10989        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;
10990        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
10991        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10992        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10993        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10994        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
10995        $$emit$$&quot;add     0x40,rax\n\t&quot;
10996        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10997        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10998        $$emit$$&quot;jge     L_loop\n\t&quot;
10999        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11000        $$emit$$&quot;jl      L_tail\n\t&quot;
11001        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11002        $$emit$$&quot;add     0x20,rax\n\t&quot;
11003        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11004        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11005        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11006        $$emit$$&quot;jle     L_end\n\t&quot;
11007        $$emit$$&quot;dec     rcx\n\t&quot;
11008        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11009        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11010        $$emit$$&quot;add     0x8,rax\n\t&quot;
11011        $$emit$$&quot;dec     rcx\n\t&quot;
11012        $$emit$$&quot;jge     L_sloop\n\t&quot;
11013        $$emit$$&quot;# L_end:\n\t&quot;
11014     } else {
11015        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11016        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11017     }
11018   %}
11019   ins_encode %{
11020     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11021                  $tmp$$XMMRegister, true);
11022   %}
11023   ins_pipe(pipe_slow);
11024 %}
11025 
11026 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11027                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11028 %{
11029   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11030   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11031   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11032 
11033   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11034   ins_encode %{
11035     __ string_compare($str1$$Register, $str2$$Register,
11036                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11037                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11038   %}
11039   ins_pipe( pipe_slow );
11040 %}
11041 
11042 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11043                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11044 %{
11045   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11046   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11047   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11048 
11049   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11050   ins_encode %{
11051     __ string_compare($str1$$Register, $str2$$Register,
11052                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11053                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11054   %}
11055   ins_pipe( pipe_slow );
11056 %}
11057 
11058 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11059                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11060 %{
11061   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11062   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11063   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11064 
11065   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11066   ins_encode %{
11067     __ string_compare($str1$$Register, $str2$$Register,
11068                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11069                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11070   %}
11071   ins_pipe( pipe_slow );
11072 %}
11073 
11074 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11075                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11076 %{
11077   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11078   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11079   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11080 
11081   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11082   ins_encode %{
11083     __ string_compare($str2$$Register, $str1$$Register,
11084                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11085                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11086   %}
11087   ins_pipe( pipe_slow );
11088 %}
11089 
11090 // fast search of substring with known size.
11091 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11092                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11093 %{
11094   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11095   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11096   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11097 
11098   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11099   ins_encode %{
11100     int icnt2 = (int)$int_cnt2$$constant;
11101     if (icnt2 &gt;= 16) {
11102       // IndexOf for constant substrings with size &gt;= 16 elements
11103       // which don&#39;t need to be loaded through stack.
11104       __ string_indexofC8($str1$$Register, $str2$$Register,
11105                           $cnt1$$Register, $cnt2$$Register,
11106                           icnt2, $result$$Register,
11107                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11108     } else {
11109       // Small strings are loaded through stack if they cross page boundary.
11110       __ string_indexof($str1$$Register, $str2$$Register,
11111                         $cnt1$$Register, $cnt2$$Register,
11112                         icnt2, $result$$Register,
11113                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11114     }
11115   %}
11116   ins_pipe( pipe_slow );
11117 %}
11118 
11119 // fast search of substring with known size.
11120 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11121                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11122 %{
11123   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11124   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11125   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11126 
11127   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11128   ins_encode %{
11129     int icnt2 = (int)$int_cnt2$$constant;
11130     if (icnt2 &gt;= 8) {
11131       // IndexOf for constant substrings with size &gt;= 8 elements
11132       // which don&#39;t need to be loaded through stack.
11133       __ string_indexofC8($str1$$Register, $str2$$Register,
11134                           $cnt1$$Register, $cnt2$$Register,
11135                           icnt2, $result$$Register,
11136                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11137     } else {
11138       // Small strings are loaded through stack if they cross page boundary.
11139       __ string_indexof($str1$$Register, $str2$$Register,
11140                         $cnt1$$Register, $cnt2$$Register,
11141                         icnt2, $result$$Register,
11142                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11143     }
11144   %}
11145   ins_pipe( pipe_slow );
11146 %}
11147 
11148 // fast search of substring with known size.
11149 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11150                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11151 %{
11152   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11153   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11154   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11155 
11156   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11157   ins_encode %{
11158     int icnt2 = (int)$int_cnt2$$constant;
11159     if (icnt2 &gt;= 8) {
11160       // IndexOf for constant substrings with size &gt;= 8 elements
11161       // which don&#39;t need to be loaded through stack.
11162       __ string_indexofC8($str1$$Register, $str2$$Register,
11163                           $cnt1$$Register, $cnt2$$Register,
11164                           icnt2, $result$$Register,
11165                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11166     } else {
11167       // Small strings are loaded through stack if they cross page boundary.
11168       __ string_indexof($str1$$Register, $str2$$Register,
11169                         $cnt1$$Register, $cnt2$$Register,
11170                         icnt2, $result$$Register,
11171                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11172     }
11173   %}
11174   ins_pipe( pipe_slow );
11175 %}
11176 
11177 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11178                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11179 %{
11180   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11181   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11182   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11183 
11184   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11185   ins_encode %{
11186     __ string_indexof($str1$$Register, $str2$$Register,
11187                       $cnt1$$Register, $cnt2$$Register,
11188                       (-1), $result$$Register,
11189                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11190   %}
11191   ins_pipe( pipe_slow );
11192 %}
11193 
11194 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11195                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11196 %{
11197   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11198   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11199   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11200 
11201   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11202   ins_encode %{
11203     __ string_indexof($str1$$Register, $str2$$Register,
11204                       $cnt1$$Register, $cnt2$$Register,
11205                       (-1), $result$$Register,
11206                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11207   %}
11208   ins_pipe( pipe_slow );
11209 %}
11210 
11211 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11212                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11213 %{
11214   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11215   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11216   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11217 
11218   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11219   ins_encode %{
11220     __ string_indexof($str1$$Register, $str2$$Register,
11221                       $cnt1$$Register, $cnt2$$Register,
11222                       (-1), $result$$Register,
11223                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11224   %}
11225   ins_pipe( pipe_slow );
11226 %}
11227 
11228 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11229                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11230 %{
11231   predicate(UseSSE42Intrinsics);
11232   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11233   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11234   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11235   ins_encode %{
11236     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11237                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11238   %}
11239   ins_pipe( pipe_slow );
11240 %}
11241 
11242 // fast string equals
11243 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11244                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11245 %{
11246   match(Set result (StrEquals (Binary str1 str2) cnt));
11247   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11248 
11249   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11250   ins_encode %{
11251     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11252                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11253                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11254   %}
11255   ins_pipe( pipe_slow );
11256 %}
11257 
11258 // fast array equals
11259 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11260                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11261 %{
11262   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11263   match(Set result (AryEq ary1 ary2));
11264   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11265 
11266   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11267   ins_encode %{
11268     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11269                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11270                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11271   %}
11272   ins_pipe( pipe_slow );
11273 %}
11274 
11275 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11276                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11277 %{
11278   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11279   match(Set result (AryEq ary1 ary2));
11280   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11281 
11282   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11283   ins_encode %{
11284     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11285                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11286                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11287   %}
11288   ins_pipe( pipe_slow );
11289 %}
11290 
11291 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11292                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11293 %{
11294   match(Set result (HasNegatives ary1 len));
11295   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11296 
11297   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11298   ins_encode %{
11299     __ has_negatives($ary1$$Register, $len$$Register,
11300                      $result$$Register, $tmp3$$Register,
11301                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11302   %}
11303   ins_pipe( pipe_slow );
11304 %}
11305 
11306 // fast char[] to byte[] compression
11307 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11308                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11309   match(Set result (StrCompressedCopy src (Binary dst len)));
11310   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11311 
11312   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11313   ins_encode %{
11314     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11315                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11316                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11317   %}
11318   ins_pipe( pipe_slow );
11319 %}
11320 
11321 // fast byte[] to char[] inflation
11322 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11323                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11324   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11325   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11326 
11327   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11328   ins_encode %{
11329     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11330                           $tmp1$$XMMRegister, $tmp2$$Register);
11331   %}
11332   ins_pipe( pipe_slow );
11333 %}
11334 
11335 // encode char[] to byte[] in ISO_8859_1
11336 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11337                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11338                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11339   match(Set result (EncodeISOArray src (Binary dst len)));
11340   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11341 
11342   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11343   ins_encode %{
11344     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11345                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11346                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11347   %}
11348   ins_pipe( pipe_slow );
11349 %}
11350 
11351 //----------Overflow Math Instructions-----------------------------------------
11352 
11353 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11354 %{
11355   match(Set cr (OverflowAddI op1 op2));
11356   effect(DEF cr, USE_KILL op1, USE op2);
11357 
11358   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11359 
11360   ins_encode %{
11361     __ addl($op1$$Register, $op2$$Register);
11362   %}
11363   ins_pipe(ialu_reg_reg);
11364 %}
11365 
11366 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11367 %{
11368   match(Set cr (OverflowAddI op1 op2));
11369   effect(DEF cr, USE_KILL op1, USE op2);
11370 
11371   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11372 
11373   ins_encode %{
11374     __ addl($op1$$Register, $op2$$constant);
11375   %}
11376   ins_pipe(ialu_reg_reg);
11377 %}
11378 
11379 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11380 %{
11381   match(Set cr (OverflowAddL op1 op2));
11382   effect(DEF cr, USE_KILL op1, USE op2);
11383 
11384   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11385   ins_encode %{
11386     __ addq($op1$$Register, $op2$$Register);
11387   %}
11388   ins_pipe(ialu_reg_reg);
11389 %}
11390 
11391 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11392 %{
11393   match(Set cr (OverflowAddL op1 op2));
11394   effect(DEF cr, USE_KILL op1, USE op2);
11395 
11396   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11397   ins_encode %{
11398     __ addq($op1$$Register, $op2$$constant);
11399   %}
11400   ins_pipe(ialu_reg_reg);
11401 %}
11402 
11403 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11404 %{
11405   match(Set cr (OverflowSubI op1 op2));
11406 
11407   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11408   ins_encode %{
11409     __ cmpl($op1$$Register, $op2$$Register);
11410   %}
11411   ins_pipe(ialu_reg_reg);
11412 %}
11413 
11414 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11415 %{
11416   match(Set cr (OverflowSubI op1 op2));
11417 
11418   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11419   ins_encode %{
11420     __ cmpl($op1$$Register, $op2$$constant);
11421   %}
11422   ins_pipe(ialu_reg_reg);
11423 %}
11424 
11425 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11426 %{
11427   match(Set cr (OverflowSubL op1 op2));
11428 
11429   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11430   ins_encode %{
11431     __ cmpq($op1$$Register, $op2$$Register);
11432   %}
11433   ins_pipe(ialu_reg_reg);
11434 %}
11435 
11436 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11437 %{
11438   match(Set cr (OverflowSubL op1 op2));
11439 
11440   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11441   ins_encode %{
11442     __ cmpq($op1$$Register, $op2$$constant);
11443   %}
11444   ins_pipe(ialu_reg_reg);
11445 %}
11446 
11447 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11448 %{
11449   match(Set cr (OverflowSubI zero op2));
11450   effect(DEF cr, USE_KILL op2);
11451 
11452   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11453   ins_encode %{
11454     __ negl($op2$$Register);
11455   %}
11456   ins_pipe(ialu_reg_reg);
11457 %}
11458 
11459 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11460 %{
11461   match(Set cr (OverflowSubL zero op2));
11462   effect(DEF cr, USE_KILL op2);
11463 
11464   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11465   ins_encode %{
11466     __ negq($op2$$Register);
11467   %}
11468   ins_pipe(ialu_reg_reg);
11469 %}
11470 
11471 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11472 %{
11473   match(Set cr (OverflowMulI op1 op2));
11474   effect(DEF cr, USE_KILL op1, USE op2);
11475 
11476   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11477   ins_encode %{
11478     __ imull($op1$$Register, $op2$$Register);
11479   %}
11480   ins_pipe(ialu_reg_reg_alu0);
11481 %}
11482 
11483 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11484 %{
11485   match(Set cr (OverflowMulI op1 op2));
11486   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11487 
11488   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11489   ins_encode %{
11490     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11491   %}
11492   ins_pipe(ialu_reg_reg_alu0);
11493 %}
11494 
11495 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11496 %{
11497   match(Set cr (OverflowMulL op1 op2));
11498   effect(DEF cr, USE_KILL op1, USE op2);
11499 
11500   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11501   ins_encode %{
11502     __ imulq($op1$$Register, $op2$$Register);
11503   %}
11504   ins_pipe(ialu_reg_reg_alu0);
11505 %}
11506 
11507 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11508 %{
11509   match(Set cr (OverflowMulL op1 op2));
11510   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11511 
11512   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11513   ins_encode %{
11514     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11515   %}
11516   ins_pipe(ialu_reg_reg_alu0);
11517 %}
11518 
11519 
11520 //----------Control Flow Instructions------------------------------------------
11521 // Signed compare Instructions
11522 
11523 // XXX more variants!!
11524 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11525 %{
11526   match(Set cr (CmpI op1 op2));
11527   effect(DEF cr, USE op1, USE op2);
11528 
11529   format %{ &quot;cmpl    $op1, $op2&quot; %}
11530   opcode(0x3B);  /* Opcode 3B /r */
11531   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11532   ins_pipe(ialu_cr_reg_reg);
11533 %}
11534 
11535 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11536 %{
11537   match(Set cr (CmpI op1 op2));
11538 
11539   format %{ &quot;cmpl    $op1, $op2&quot; %}
11540   opcode(0x81, 0x07); /* Opcode 81 /7 */
11541   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11542   ins_pipe(ialu_cr_reg_imm);
11543 %}
11544 
11545 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11546 %{
11547   match(Set cr (CmpI op1 (LoadI op2)));
11548 
11549   ins_cost(500); // XXX
11550   format %{ &quot;cmpl    $op1, $op2&quot; %}
11551   opcode(0x3B); /* Opcode 3B /r */
11552   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11553   ins_pipe(ialu_cr_reg_mem);
11554 %}
11555 
11556 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11557 %{
11558   match(Set cr (CmpI src zero));
11559 
11560   format %{ &quot;testl   $src, $src&quot; %}
11561   opcode(0x85);
11562   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11563   ins_pipe(ialu_cr_reg_imm);
11564 %}
11565 
11566 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11567 %{
11568   match(Set cr (CmpI (AndI src con) zero));
11569 
11570   format %{ &quot;testl   $src, $con&quot; %}
11571   opcode(0xF7, 0x00);
11572   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11573   ins_pipe(ialu_cr_reg_imm);
11574 %}
11575 
11576 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11577 %{
11578   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11579 
11580   format %{ &quot;testl   $src, $mem&quot; %}
11581   opcode(0x85);
11582   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11583   ins_pipe(ialu_cr_reg_mem);
11584 %}
11585 
11586 // Unsigned compare Instructions; really, same as signed except they
11587 // produce an rFlagsRegU instead of rFlagsReg.
11588 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11589 %{
11590   match(Set cr (CmpU op1 op2));
11591 
11592   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11593   opcode(0x3B); /* Opcode 3B /r */
11594   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11595   ins_pipe(ialu_cr_reg_reg);
11596 %}
11597 
11598 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11599 %{
11600   match(Set cr (CmpU op1 op2));
11601 
11602   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11603   opcode(0x81,0x07); /* Opcode 81 /7 */
11604   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11605   ins_pipe(ialu_cr_reg_imm);
11606 %}
11607 
11608 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11609 %{
11610   match(Set cr (CmpU op1 (LoadI op2)));
11611 
11612   ins_cost(500); // XXX
11613   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11614   opcode(0x3B); /* Opcode 3B /r */
11615   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11616   ins_pipe(ialu_cr_reg_mem);
11617 %}
11618 
11619 // // // Cisc-spilled version of cmpU_rReg
11620 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11621 // //%{
11622 // //  match(Set cr (CmpU (LoadI op1) op2));
11623 // //
11624 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11625 // //  ins_cost(500);
11626 // //  opcode(0x39);  /* Opcode 39 /r */
11627 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11628 // //%}
11629 
11630 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11631 %{
11632   match(Set cr (CmpU src zero));
11633 
11634   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11635   opcode(0x85);
11636   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11637   ins_pipe(ialu_cr_reg_imm);
11638 %}
11639 
11640 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11641 %{
11642   match(Set cr (CmpP op1 op2));
11643 
11644   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11645   opcode(0x3B); /* Opcode 3B /r */
11646   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11647   ins_pipe(ialu_cr_reg_reg);
11648 %}
11649 
11650 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11651 %{
11652   match(Set cr (CmpP op1 (LoadP op2)));
11653   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11654 
11655   ins_cost(500); // XXX
11656   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11657   opcode(0x3B); /* Opcode 3B /r */
11658   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11659   ins_pipe(ialu_cr_reg_mem);
11660 %}
11661 
11662 // // // Cisc-spilled version of cmpP_rReg
11663 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11664 // //%{
11665 // //  match(Set cr (CmpP (LoadP op1) op2));
11666 // //
11667 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11668 // //  ins_cost(500);
11669 // //  opcode(0x39);  /* Opcode 39 /r */
11670 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11671 // //%}
11672 
11673 // XXX this is generalized by compP_rReg_mem???
11674 // Compare raw pointer (used in out-of-heap check).
11675 // Only works because non-oop pointers must be raw pointers
11676 // and raw pointers have no anti-dependencies.
11677 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11678 %{
11679   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11680             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11681   match(Set cr (CmpP op1 (LoadP op2)));
11682 
11683   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11684   opcode(0x3B); /* Opcode 3B /r */
11685   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11686   ins_pipe(ialu_cr_reg_mem);
11687 %}
11688 
11689 // This will generate a signed flags result. This should be OK since
11690 // any compare to a zero should be eq/neq.
11691 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11692 %{
11693   match(Set cr (CmpP src zero));
11694 
11695   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11696   opcode(0x85);
11697   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11698   ins_pipe(ialu_cr_reg_imm);
11699 %}
11700 
11701 // This will generate a signed flags result. This should be OK since
11702 // any compare to a zero should be eq/neq.
11703 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11704 %{
11705   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11706             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11707   match(Set cr (CmpP (LoadP op) zero));
11708 
11709   ins_cost(500); // XXX
11710   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11711   opcode(0xF7); /* Opcode F7 /0 */
11712   ins_encode(REX_mem_wide(op),
11713              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11714   ins_pipe(ialu_cr_reg_imm);
11715 %}
11716 
11717 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11718 %{
11719   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
11720             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11721   match(Set cr (CmpP (LoadP mem) zero));
11722 
11723   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11724   ins_encode %{
11725     __ cmpq(r12, $mem$$Address);
11726   %}
11727   ins_pipe(ialu_cr_reg_mem);
11728 %}
11729 
11730 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11731 %{
11732   match(Set cr (CmpN op1 op2));
11733 
11734   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11735   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11736   ins_pipe(ialu_cr_reg_reg);
11737 %}
11738 
11739 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11740 %{
11741   match(Set cr (CmpN src (LoadN mem)));
11742 
11743   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11744   ins_encode %{
11745     __ cmpl($src$$Register, $mem$$Address);
11746   %}
11747   ins_pipe(ialu_cr_reg_mem);
11748 %}
11749 
11750 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11751   match(Set cr (CmpN op1 op2));
11752 
11753   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11754   ins_encode %{
11755     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11756   %}
11757   ins_pipe(ialu_cr_reg_imm);
11758 %}
11759 
11760 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11761 %{
11762   match(Set cr (CmpN src (LoadN mem)));
11763 
11764   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11765   ins_encode %{
11766     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11767   %}
11768   ins_pipe(ialu_cr_reg_mem);
11769 %}
11770 
11771 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11772   match(Set cr (CmpN op1 op2));
11773 
11774   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11775   ins_encode %{
11776     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11777   %}
11778   ins_pipe(ialu_cr_reg_imm);
11779 %}
11780 
11781 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11782 %{
11783   match(Set cr (CmpN src (LoadNKlass mem)));
11784 
11785   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11786   ins_encode %{
11787     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11788   %}
11789   ins_pipe(ialu_cr_reg_mem);
11790 %}
11791 
11792 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11793   match(Set cr (CmpN src zero));
11794 
11795   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11796   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11797   ins_pipe(ialu_cr_reg_imm);
11798 %}
11799 
11800 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11801 %{
11802   predicate(CompressedOops::base() != NULL);
11803   match(Set cr (CmpN (LoadN mem) zero));
11804 
11805   ins_cost(500); // XXX
11806   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11807   ins_encode %{
11808     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11809   %}
11810   ins_pipe(ialu_cr_reg_mem);
11811 %}
11812 
11813 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11814 %{
11815   predicate(CompressedOops::base() == NULL);
11816   match(Set cr (CmpN (LoadN mem) zero));
11817 
11818   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11819   ins_encode %{
11820     __ cmpl(r12, $mem$$Address);
11821   %}
11822   ins_pipe(ialu_cr_reg_mem);
11823 %}
11824 
11825 // Yanked all unsigned pointer compare operations.
11826 // Pointer compares are done with CmpP which is already unsigned.
11827 
11828 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11829 %{
11830   match(Set cr (CmpL op1 op2));
11831 
11832   format %{ &quot;cmpq    $op1, $op2&quot; %}
11833   opcode(0x3B);  /* Opcode 3B /r */
11834   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11835   ins_pipe(ialu_cr_reg_reg);
11836 %}
11837 
11838 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11839 %{
11840   match(Set cr (CmpL op1 op2));
11841 
11842   format %{ &quot;cmpq    $op1, $op2&quot; %}
11843   opcode(0x81, 0x07); /* Opcode 81 /7 */
11844   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11845   ins_pipe(ialu_cr_reg_imm);
11846 %}
11847 
11848 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
11849 %{
11850   match(Set cr (CmpL op1 (LoadL op2)));
11851 
11852   format %{ &quot;cmpq    $op1, $op2&quot; %}
11853   opcode(0x3B); /* Opcode 3B /r */
11854   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11855   ins_pipe(ialu_cr_reg_mem);
11856 %}
11857 
11858 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
11859 %{
11860   match(Set cr (CmpL src zero));
11861 
11862   format %{ &quot;testq   $src, $src&quot; %}
11863   opcode(0x85);
11864   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11865   ins_pipe(ialu_cr_reg_imm);
11866 %}
11867 
11868 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
11869 %{
11870   match(Set cr (CmpL (AndL src con) zero));
11871 
11872   format %{ &quot;testq   $src, $con\t# long&quot; %}
11873   opcode(0xF7, 0x00);
11874   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
11875   ins_pipe(ialu_cr_reg_imm);
11876 %}
11877 
11878 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11879 %{
11880   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11881 
11882   format %{ &quot;testq   $src, $mem&quot; %}
11883   opcode(0x85);
11884   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11885   ins_pipe(ialu_cr_reg_mem);
11886 %}
11887 
11888 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
11889 %{
11890   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
11891 
11892   format %{ &quot;testq   $src, $mem&quot; %}
11893   opcode(0x85);
11894   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11895   ins_pipe(ialu_cr_reg_mem);
11896 %}
11897 
11898 // Manifest a CmpL result in an integer register.  Very painful.
11899 // This is the test to avoid.
11900 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11901 %{
11902   match(Set dst (CmpL3 src1 src2));
11903   effect(KILL flags);
11904 
11905   ins_cost(275); // XXX
11906   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
11907             &quot;movl    $dst, -1\n\t&quot;
11908             &quot;jl,s    done\n\t&quot;
11909             &quot;setne   $dst\n\t&quot;
11910             &quot;movzbl  $dst, $dst\n\t&quot;
11911     &quot;done:&quot; %}
11912   ins_encode(cmpl3_flag(src1, src2, dst));
11913   ins_pipe(pipe_slow);
11914 %}
11915 
11916 // Unsigned long compare Instructions; really, same as signed long except they
11917 // produce an rFlagsRegU instead of rFlagsReg.
11918 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
11919 %{
11920   match(Set cr (CmpUL op1 op2));
11921 
11922   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11923   opcode(0x3B);  /* Opcode 3B /r */
11924   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11925   ins_pipe(ialu_cr_reg_reg);
11926 %}
11927 
11928 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
11929 %{
11930   match(Set cr (CmpUL op1 op2));
11931 
11932   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11933   opcode(0x81, 0x07); /* Opcode 81 /7 */
11934   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11935   ins_pipe(ialu_cr_reg_imm);
11936 %}
11937 
11938 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
11939 %{
11940   match(Set cr (CmpUL op1 (LoadL op2)));
11941 
11942   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11943   opcode(0x3B); /* Opcode 3B /r */
11944   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11945   ins_pipe(ialu_cr_reg_mem);
11946 %}
11947 
11948 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
11949 %{
11950   match(Set cr (CmpUL src zero));
11951 
11952   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
11953   opcode(0x85);
11954   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11955   ins_pipe(ialu_cr_reg_imm);
11956 %}
11957 
11958 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
11959 %{
11960   match(Set cr (CmpI (LoadB mem) imm));
11961 
11962   ins_cost(125);
11963   format %{ &quot;cmpb    $mem, $imm&quot; %}
11964   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
11965   ins_pipe(ialu_cr_reg_mem);
11966 %}
11967 
11968 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
11969 %{
11970   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
11971 
11972   ins_cost(125);
11973   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
11974   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
11975   ins_pipe(ialu_cr_reg_mem);
11976 %}
11977 
11978 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
11979 %{
11980   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
11981 
11982   ins_cost(125);
11983   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
11984   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
11985   ins_pipe(ialu_cr_reg_mem);
11986 %}
11987 
11988 //----------Max and Min--------------------------------------------------------
11989 // Min Instructions
11990 
11991 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
11992 %{
11993   effect(USE_DEF dst, USE src, USE cr);
11994 
11995   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
11996   opcode(0x0F, 0x4F);
11997   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11998   ins_pipe(pipe_cmov_reg);
11999 %}
12000 
12001 
12002 instruct minI_rReg(rRegI dst, rRegI src)
12003 %{
12004   match(Set dst (MinI dst src));
12005 
12006   ins_cost(200);
12007   expand %{
12008     rFlagsReg cr;
12009     compI_rReg(cr, dst, src);
12010     cmovI_reg_g(dst, src, cr);
12011   %}
12012 %}
12013 
12014 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12015 %{
12016   effect(USE_DEF dst, USE src, USE cr);
12017 
12018   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12019   opcode(0x0F, 0x4C);
12020   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12021   ins_pipe(pipe_cmov_reg);
12022 %}
12023 
12024 
12025 instruct maxI_rReg(rRegI dst, rRegI src)
12026 %{
12027   match(Set dst (MaxI dst src));
12028 
12029   ins_cost(200);
12030   expand %{
12031     rFlagsReg cr;
12032     compI_rReg(cr, dst, src);
12033     cmovI_reg_l(dst, src, cr);
12034   %}
12035 %}
12036 
12037 // ============================================================================
12038 // Branch Instructions
12039 
12040 // Jump Direct - Label defines a relative address from JMP+1
12041 instruct jmpDir(label labl)
12042 %{
12043   match(Goto);
12044   effect(USE labl);
12045 
12046   ins_cost(300);
12047   format %{ &quot;jmp     $labl&quot; %}
12048   size(5);
12049   ins_encode %{
12050     Label* L = $labl$$label;
12051     __ jmp(*L, false); // Always long jump
12052   %}
12053   ins_pipe(pipe_jmp);
12054 %}
12055 
12056 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12057 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12058 %{
12059   match(If cop cr);
12060   effect(USE labl);
12061 
12062   ins_cost(300);
12063   format %{ &quot;j$cop     $labl&quot; %}
12064   size(6);
12065   ins_encode %{
12066     Label* L = $labl$$label;
12067     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12068   %}
12069   ins_pipe(pipe_jcc);
12070 %}
12071 
12072 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12073 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12074 %{
12075   predicate(!n-&gt;has_vector_mask_set());
12076   match(CountedLoopEnd cop cr);
12077   effect(USE labl);
12078 
12079   ins_cost(300);
12080   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12081   size(6);
12082   ins_encode %{
12083     Label* L = $labl$$label;
12084     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12085   %}
12086   ins_pipe(pipe_jcc);
12087 %}
12088 
12089 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12090 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12091   predicate(!n-&gt;has_vector_mask_set());
12092   match(CountedLoopEnd cop cmp);
12093   effect(USE labl);
12094 
12095   ins_cost(300);
12096   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12097   size(6);
12098   ins_encode %{
12099     Label* L = $labl$$label;
12100     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12101   %}
12102   ins_pipe(pipe_jcc);
12103 %}
12104 
12105 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12106   predicate(!n-&gt;has_vector_mask_set());
12107   match(CountedLoopEnd cop cmp);
12108   effect(USE labl);
12109 
12110   ins_cost(200);
12111   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12112   size(6);
12113   ins_encode %{
12114     Label* L = $labl$$label;
12115     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12116   %}
12117   ins_pipe(pipe_jcc);
12118 %}
12119 
12120 // mask version
12121 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12122 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12123 %{
12124   predicate(n-&gt;has_vector_mask_set());
12125   match(CountedLoopEnd cop cr);
12126   effect(USE labl);
12127 
12128   ins_cost(400);
12129   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12130             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12131   size(10);
12132   ins_encode %{
12133     Label* L = $labl$$label;
12134     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12135     __ restorevectmask();
12136   %}
12137   ins_pipe(pipe_jcc);
12138 %}
12139 
12140 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12141 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12142   predicate(n-&gt;has_vector_mask_set());
12143   match(CountedLoopEnd cop cmp);
12144   effect(USE labl);
12145 
12146   ins_cost(400);
12147   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12148             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12149   size(10);
12150   ins_encode %{
12151     Label* L = $labl$$label;
12152     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12153     __ restorevectmask();
12154   %}
12155   ins_pipe(pipe_jcc);
12156 %}
12157 
12158 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12159   predicate(n-&gt;has_vector_mask_set());
12160   match(CountedLoopEnd cop cmp);
12161   effect(USE labl);
12162 
12163   ins_cost(300);
12164   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12165             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12166   size(10);
12167   ins_encode %{
12168     Label* L = $labl$$label;
12169     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12170     __ restorevectmask();
12171   %}
12172   ins_pipe(pipe_jcc);
12173 %}
12174 
12175 // Jump Direct Conditional - using unsigned comparison
12176 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12177   match(If cop cmp);
12178   effect(USE labl);
12179 
12180   ins_cost(300);
12181   format %{ &quot;j$cop,u   $labl&quot; %}
12182   size(6);
12183   ins_encode %{
12184     Label* L = $labl$$label;
12185     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12186   %}
12187   ins_pipe(pipe_jcc);
12188 %}
12189 
12190 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12191   match(If cop cmp);
12192   effect(USE labl);
12193 
12194   ins_cost(200);
12195   format %{ &quot;j$cop,u   $labl&quot; %}
12196   size(6);
12197   ins_encode %{
12198     Label* L = $labl$$label;
12199     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12200   %}
12201   ins_pipe(pipe_jcc);
12202 %}
12203 
12204 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12205   match(If cop cmp);
12206   effect(USE labl);
12207 
12208   ins_cost(200);
12209   format %{ $$template
12210     if ($cop$$cmpcode == Assembler::notEqual) {
12211       $$emit$$&quot;jp,u    $labl\n\t&quot;
12212       $$emit$$&quot;j$cop,u   $labl&quot;
12213     } else {
12214       $$emit$$&quot;jp,u    done\n\t&quot;
12215       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12216       $$emit$$&quot;done:&quot;
12217     }
12218   %}
12219   ins_encode %{
12220     Label* l = $labl$$label;
12221     if ($cop$$cmpcode == Assembler::notEqual) {
12222       __ jcc(Assembler::parity, *l, false);
12223       __ jcc(Assembler::notEqual, *l, false);
12224     } else if ($cop$$cmpcode == Assembler::equal) {
12225       Label done;
12226       __ jccb(Assembler::parity, done);
12227       __ jcc(Assembler::equal, *l, false);
12228       __ bind(done);
12229     } else {
12230        ShouldNotReachHere();
12231     }
12232   %}
12233   ins_pipe(pipe_jcc);
12234 %}
12235 
12236 // ============================================================================
12237 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12238 // superklass array for an instance of the superklass.  Set a hidden
12239 // internal cache on a hit (cache is checked with exposed code in
12240 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12241 // encoding ALSO sets flags.
12242 
12243 instruct partialSubtypeCheck(rdi_RegP result,
12244                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12245                              rFlagsReg cr)
12246 %{
12247   match(Set result (PartialSubtypeCheck sub super));
12248   effect(KILL rcx, KILL cr);
12249 
12250   ins_cost(1100);  // slightly larger than the next version
12251   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12252             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12253             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12254             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12255             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12256             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12257             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12258     &quot;miss:\t&quot; %}
12259 
12260   opcode(0x1); // Force a XOR of RDI
12261   ins_encode(enc_PartialSubtypeCheck());
12262   ins_pipe(pipe_slow);
12263 %}
12264 
12265 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12266                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12267                                      immP0 zero,
12268                                      rdi_RegP result)
12269 %{
12270   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12271   effect(KILL rcx, KILL result);
12272 
12273   ins_cost(1000);
12274   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12275             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12276             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12277             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12278             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12279             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12280     &quot;miss:\t&quot; %}
12281 
12282   opcode(0x0); // No need to XOR RDI
12283   ins_encode(enc_PartialSubtypeCheck());
12284   ins_pipe(pipe_slow);
12285 %}
12286 
12287 // ============================================================================
12288 // Branch Instructions -- short offset versions
12289 //
12290 // These instructions are used to replace jumps of a long offset (the default
12291 // match) with jumps of a shorter offset.  These instructions are all tagged
12292 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12293 // match rules in general matching.  Instead, the ADLC generates a conversion
12294 // method in the MachNode which can be used to do in-place replacement of the
12295 // long variant with the shorter variant.  The compiler will determine if a
12296 // branch can be taken by the is_short_branch_offset() predicate in the machine
12297 // specific code section of the file.
12298 
12299 // Jump Direct - Label defines a relative address from JMP+1
12300 instruct jmpDir_short(label labl) %{
12301   match(Goto);
12302   effect(USE labl);
12303 
12304   ins_cost(300);
12305   format %{ &quot;jmp,s   $labl&quot; %}
12306   size(2);
12307   ins_encode %{
12308     Label* L = $labl$$label;
12309     __ jmpb(*L);
12310   %}
12311   ins_pipe(pipe_jmp);
12312   ins_short_branch(1);
12313 %}
12314 
12315 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12316 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12317   match(If cop cr);
12318   effect(USE labl);
12319 
12320   ins_cost(300);
12321   format %{ &quot;j$cop,s   $labl&quot; %}
12322   size(2);
12323   ins_encode %{
12324     Label* L = $labl$$label;
12325     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12326   %}
12327   ins_pipe(pipe_jcc);
12328   ins_short_branch(1);
12329 %}
12330 
12331 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12332 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12333   match(CountedLoopEnd cop cr);
12334   effect(USE labl);
12335 
12336   ins_cost(300);
12337   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12338   size(2);
12339   ins_encode %{
12340     Label* L = $labl$$label;
12341     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12342   %}
12343   ins_pipe(pipe_jcc);
12344   ins_short_branch(1);
12345 %}
12346 
12347 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12348 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12349   match(CountedLoopEnd cop cmp);
12350   effect(USE labl);
12351 
12352   ins_cost(300);
12353   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12354   size(2);
12355   ins_encode %{
12356     Label* L = $labl$$label;
12357     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12358   %}
12359   ins_pipe(pipe_jcc);
12360   ins_short_branch(1);
12361 %}
12362 
12363 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12364   match(CountedLoopEnd cop cmp);
12365   effect(USE labl);
12366 
12367   ins_cost(300);
12368   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12369   size(2);
12370   ins_encode %{
12371     Label* L = $labl$$label;
12372     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12373   %}
12374   ins_pipe(pipe_jcc);
12375   ins_short_branch(1);
12376 %}
12377 
12378 // Jump Direct Conditional - using unsigned comparison
12379 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12380   match(If cop cmp);
12381   effect(USE labl);
12382 
12383   ins_cost(300);
12384   format %{ &quot;j$cop,us  $labl&quot; %}
12385   size(2);
12386   ins_encode %{
12387     Label* L = $labl$$label;
12388     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12389   %}
12390   ins_pipe(pipe_jcc);
12391   ins_short_branch(1);
12392 %}
12393 
12394 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12395   match(If cop cmp);
12396   effect(USE labl);
12397 
12398   ins_cost(300);
12399   format %{ &quot;j$cop,us  $labl&quot; %}
12400   size(2);
12401   ins_encode %{
12402     Label* L = $labl$$label;
12403     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12404   %}
12405   ins_pipe(pipe_jcc);
12406   ins_short_branch(1);
12407 %}
12408 
12409 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12410   match(If cop cmp);
12411   effect(USE labl);
12412 
12413   ins_cost(300);
12414   format %{ $$template
12415     if ($cop$$cmpcode == Assembler::notEqual) {
12416       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12417       $$emit$$&quot;j$cop,u,s  $labl&quot;
12418     } else {
12419       $$emit$$&quot;jp,u,s  done\n\t&quot;
12420       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12421       $$emit$$&quot;done:&quot;
12422     }
12423   %}
12424   size(4);
12425   ins_encode %{
12426     Label* l = $labl$$label;
12427     if ($cop$$cmpcode == Assembler::notEqual) {
12428       __ jccb(Assembler::parity, *l);
12429       __ jccb(Assembler::notEqual, *l);
12430     } else if ($cop$$cmpcode == Assembler::equal) {
12431       Label done;
12432       __ jccb(Assembler::parity, done);
12433       __ jccb(Assembler::equal, *l);
12434       __ bind(done);
12435     } else {
12436        ShouldNotReachHere();
12437     }
12438   %}
12439   ins_pipe(pipe_jcc);
12440   ins_short_branch(1);
12441 %}
12442 
12443 // ============================================================================
12444 // inlined locking and unlocking
12445 
12446 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12447   predicate(Compile::current()-&gt;use_rtm());
12448   match(Set cr (FastLock object box));
12449   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12450   ins_cost(300);
12451   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12452   ins_encode %{
12453     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12454                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12455                  _counters, _rtm_counters, _stack_rtm_counters,
12456                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12457                  true, ra_-&gt;C-&gt;profile_rtm());
12458   %}
12459   ins_pipe(pipe_slow);
12460 %}
12461 
12462 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr, rRegP cx1) %{
12463   predicate(!Compile::current()-&gt;use_rtm());
12464   match(Set cr (FastLock object box));
12465   effect(TEMP tmp, TEMP scr, TEMP cx1, USE_KILL box);
12466   ins_cost(300);
12467   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12468   ins_encode %{
12469     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12470                  $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);
12471   %}
12472   ins_pipe(pipe_slow);
12473 %}
12474 
12475 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12476   match(Set cr (FastUnlock object box));
12477   effect(TEMP tmp, USE_KILL box);
12478   ins_cost(300);
12479   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12480   ins_encode %{
12481     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12482   %}
12483   ins_pipe(pipe_slow);
12484 %}
12485 
12486 
12487 // ============================================================================
12488 // Safepoint Instructions
12489 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12490 %{
12491   match(SafePoint poll);
12492   effect(KILL cr, USE poll);
12493 
12494   format %{ &quot;testl   rax, [$poll]\t&quot;
12495             &quot;# Safepoint: poll for GC&quot; %}
12496   ins_cost(125);
12497   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12498   ins_encode %{
12499     __ relocate(relocInfo::poll_type);
12500     address pre_pc = __ pc();
12501     __ testl(rax, Address($poll$$Register, 0));
12502     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12503   %}
12504   ins_pipe(ialu_reg_mem);
12505 %}
12506 
12507 // ============================================================================
12508 // Procedure Call/Return Instructions
12509 // Call Java Static Instruction
12510 // Note: If this code changes, the corresponding ret_addr_offset() and
12511 //       compute_padding() functions will have to be adjusted.
12512 instruct CallStaticJavaDirect(method meth) %{
12513   match(CallStaticJava);
12514   effect(USE meth);
12515 
12516   ins_cost(300);
12517   format %{ &quot;call,static &quot; %}
12518   opcode(0xE8); /* E8 cd */
12519   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12520   ins_pipe(pipe_slow);
12521   ins_alignment(4);
12522 %}
12523 
12524 // Call Java Dynamic Instruction
12525 // Note: If this code changes, the corresponding ret_addr_offset() and
12526 //       compute_padding() functions will have to be adjusted.
12527 instruct CallDynamicJavaDirect(method meth)
12528 %{
12529   match(CallDynamicJava);
12530   effect(USE meth);
12531 
12532   ins_cost(300);
12533   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12534             &quot;call,dynamic &quot; %}
12535   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12536   ins_pipe(pipe_slow);
12537   ins_alignment(4);
12538 %}
12539 
12540 // Call Runtime Instruction
12541 instruct CallRuntimeDirect(method meth)
12542 %{
12543   match(CallRuntime);
12544   effect(USE meth);
12545 
12546   ins_cost(300);
12547   format %{ &quot;call,runtime &quot; %}
12548   ins_encode(clear_avx, Java_To_Runtime(meth));
12549   ins_pipe(pipe_slow);
12550 %}
12551 
12552 // Call runtime without safepoint
12553 instruct CallLeafDirect(method meth)
12554 %{
12555   match(CallLeaf);
12556   effect(USE meth);
12557 
12558   ins_cost(300);
12559   format %{ &quot;call_leaf,runtime &quot; %}
12560   ins_encode(clear_avx, Java_To_Runtime(meth));
12561   ins_pipe(pipe_slow);
12562 %}
12563 
12564 //
12565 instruct CallNativeDirect(method meth)
12566 %{
12567   match(CallNative);
12568   effect(USE meth);
12569 
12570   ins_cost(300);
12571   format %{ &quot;call_native &quot; %}
12572   ins_encode %{
12573     __ call(RuntimeAddress((address) $meth$$method));
12574   %}
12575   ins_pipe(pipe_slow);
12576 %}
12577 
12578 // Call runtime without safepoint
12579 instruct CallLeafNoFPDirect(method meth)
12580 %{
12581   match(CallLeafNoFP);
12582   effect(USE meth);
12583 
12584   ins_cost(300);
12585   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12586   ins_encode(clear_avx, Java_To_Runtime(meth));
12587   ins_pipe(pipe_slow);
12588 %}
12589 
12590 // Return Instruction
12591 // Remove the return address &amp; jump to it.
12592 // Notice: We always emit a nop after a ret to make sure there is room
12593 // for safepoint patching
12594 instruct Ret()
12595 %{
12596   match(Return);
12597 
12598   format %{ &quot;ret&quot; %}
12599   opcode(0xC3);
12600   ins_encode(OpcP);
12601   ins_pipe(pipe_jmp);
12602 %}
12603 
12604 // Tail Call; Jump from runtime stub to Java code.
12605 // Also known as an &#39;interprocedural jump&#39;.
12606 // Target of jump will eventually return to caller.
12607 // TailJump below removes the return address.
12608 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12609 %{
12610   match(TailCall jump_target method_oop);
12611 
12612   ins_cost(300);
12613   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12614   opcode(0xFF, 0x4); /* Opcode FF /4 */
12615   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12616   ins_pipe(pipe_jmp);
12617 %}
12618 
12619 // Tail Jump; remove the return address; jump to target.
12620 // TailCall above leaves the return address around.
12621 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12622 %{
12623   match(TailJump jump_target ex_oop);
12624 
12625   ins_cost(300);
12626   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12627             &quot;jmp     $jump_target&quot; %}
12628   opcode(0xFF, 0x4); /* Opcode FF /4 */
12629   ins_encode(Opcode(0x5a), // popq rdx
12630              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12631   ins_pipe(pipe_jmp);
12632 %}
12633 
12634 // Create exception oop: created by stack-crawling runtime code.
12635 // Created exception is now available to this handler, and is setup
12636 // just prior to jumping to this handler.  No code emitted.
12637 instruct CreateException(rax_RegP ex_oop)
12638 %{
12639   match(Set ex_oop (CreateEx));
12640 
12641   size(0);
12642   // use the following format syntax
12643   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12644   ins_encode();
12645   ins_pipe(empty);
12646 %}
12647 
12648 // Rethrow exception:
12649 // The exception oop will come in the first argument position.
12650 // Then JUMP (not call) to the rethrow stub code.
12651 instruct RethrowException()
12652 %{
12653   match(Rethrow);
12654 
12655   // use the following format syntax
12656   format %{ &quot;jmp     rethrow_stub&quot; %}
12657   ins_encode(enc_rethrow);
12658   ins_pipe(pipe_jmp);
12659 %}
12660 
12661 // ============================================================================
12662 // This name is KNOWN by the ADLC and cannot be changed.
12663 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12664 // for this guy.
12665 instruct tlsLoadP(r15_RegP dst) %{
12666   match(Set dst (ThreadLocal));
12667   effect(DEF dst);
12668 
12669   size(0);
12670   format %{ &quot;# TLS is in R15&quot; %}
12671   ins_encode( /*empty encoding*/ );
12672   ins_pipe(ialu_reg_reg);
12673 %}
12674 
12675 
12676 //----------PEEPHOLE RULES-----------------------------------------------------
12677 // These must follow all instruction definitions as they use the names
12678 // defined in the instructions definitions.
12679 //
12680 // peepmatch ( root_instr_name [preceding_instruction]* );
12681 //
12682 // peepconstraint %{
12683 // (instruction_number.operand_name relational_op instruction_number.operand_name
12684 //  [, ...] );
12685 // // instruction numbers are zero-based using left to right order in peepmatch
12686 //
12687 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12688 // // provide an instruction_number.operand_name for each operand that appears
12689 // // in the replacement instruction&#39;s match rule
12690 //
12691 // ---------VM FLAGS---------------------------------------------------------
12692 //
12693 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12694 //
12695 // Each peephole rule is given an identifying number starting with zero and
12696 // increasing by one in the order seen by the parser.  An individual peephole
12697 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12698 // on the command-line.
12699 //
12700 // ---------CURRENT LIMITATIONS----------------------------------------------
12701 //
12702 // Only match adjacent instructions in same basic block
12703 // Only equality constraints
12704 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12705 // Only one replacement instruction
12706 //
12707 // ---------EXAMPLE----------------------------------------------------------
12708 //
12709 // // pertinent parts of existing instructions in architecture description
12710 // instruct movI(rRegI dst, rRegI src)
12711 // %{
12712 //   match(Set dst (CopyI src));
12713 // %}
12714 //
12715 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12716 // %{
12717 //   match(Set dst (AddI dst src));
12718 //   effect(KILL cr);
12719 // %}
12720 //
12721 // // Change (inc mov) to lea
12722 // peephole %{
12723 //   // increment preceeded by register-register move
12724 //   peepmatch ( incI_rReg movI );
12725 //   // require that the destination register of the increment
12726 //   // match the destination register of the move
12727 //   peepconstraint ( 0.dst == 1.dst );
12728 //   // construct a replacement instruction that sets
12729 //   // the destination to ( move&#39;s source register + one )
12730 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12731 // %}
12732 //
12733 
12734 // Implementation no longer uses movX instructions since
12735 // machine-independent system no longer uses CopyX nodes.
12736 //
12737 // peephole
12738 // %{
12739 //   peepmatch (incI_rReg movI);
12740 //   peepconstraint (0.dst == 1.dst);
12741 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12742 // %}
12743 
12744 // peephole
12745 // %{
12746 //   peepmatch (decI_rReg movI);
12747 //   peepconstraint (0.dst == 1.dst);
12748 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12749 // %}
12750 
12751 // peephole
12752 // %{
12753 //   peepmatch (addI_rReg_imm movI);
12754 //   peepconstraint (0.dst == 1.dst);
12755 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12756 // %}
12757 
12758 // peephole
12759 // %{
12760 //   peepmatch (incL_rReg movL);
12761 //   peepconstraint (0.dst == 1.dst);
12762 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12763 // %}
12764 
12765 // peephole
12766 // %{
12767 //   peepmatch (decL_rReg movL);
12768 //   peepconstraint (0.dst == 1.dst);
12769 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12770 // %}
12771 
12772 // peephole
12773 // %{
12774 //   peepmatch (addL_rReg_imm movL);
12775 //   peepconstraint (0.dst == 1.dst);
12776 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12777 // %}
12778 
12779 // peephole
12780 // %{
12781 //   peepmatch (addP_rReg_imm movP);
12782 //   peepconstraint (0.dst == 1.dst);
12783 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
12784 // %}
12785 
12786 // // Change load of spilled value to only a spill
12787 // instruct storeI(memory mem, rRegI src)
12788 // %{
12789 //   match(Set mem (StoreI mem src));
12790 // %}
12791 //
12792 // instruct loadI(rRegI dst, memory mem)
12793 // %{
12794 //   match(Set dst (LoadI mem));
12795 // %}
12796 //
12797 
12798 peephole
12799 %{
12800   peepmatch (loadI storeI);
12801   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12802   peepreplace (storeI(1.mem 1.mem 1.src));
12803 %}
12804 
12805 peephole
12806 %{
12807   peepmatch (loadL storeL);
12808   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12809   peepreplace (storeL(1.mem 1.mem 1.src));
12810 %}
12811 
12812 //----------SMARTSPILL RULES---------------------------------------------------
12813 // These must follow all instruction definitions as they use the names
12814 // defined in the instructions definitions.
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../../share/opto/output.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 int MachCallNativeNode::ret_addr_offset() {
  463   int offset = 13; // movq r10,#addr; callq (r10)

  464   return offset;
  465 }
  466 //
  467 // Compute padding required for nodes which need alignment
  468 //
  469 
  470 // The address of the call instruction needs to be 4-byte aligned to
  471 // ensure that it does not span a cache line so that it can be patched.
  472 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  473 {
  474   current_offset += clear_avx_size(); // skip vzeroupper
  475   current_offset += 1; // skip call opcode byte
  476   return align_up(current_offset, alignment_required()) - current_offset;
  477 }
  478 
  479 // The address of the call instruction needs to be 4-byte aligned to
  480 // ensure that it does not span a cache line so that it can be patched.
  481 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  482 {
  483   current_offset += clear_avx_size(); // skip vzeroupper
</pre>
<hr />
<pre>
12552 // Call runtime without safepoint
12553 instruct CallLeafDirect(method meth)
12554 %{
12555   match(CallLeaf);
12556   effect(USE meth);
12557 
12558   ins_cost(300);
12559   format %{ &quot;call_leaf,runtime &quot; %}
12560   ins_encode(clear_avx, Java_To_Runtime(meth));
12561   ins_pipe(pipe_slow);
12562 %}
12563 
12564 //
12565 instruct CallNativeDirect(method meth)
12566 %{
12567   match(CallNative);
12568   effect(USE meth);
12569 
12570   ins_cost(300);
12571   format %{ &quot;call_native &quot; %}
<span class="line-modified">12572   ins_encode %{</span>
<span class="line-removed">12573     __ call(RuntimeAddress((address) $meth$$method));</span>
<span class="line-removed">12574   %}</span>
12575   ins_pipe(pipe_slow);
12576 %}
12577 
12578 // Call runtime without safepoint
12579 instruct CallLeafNoFPDirect(method meth)
12580 %{
12581   match(CallLeafNoFP);
12582   effect(USE meth);
12583 
12584   ins_cost(300);
12585   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12586   ins_encode(clear_avx, Java_To_Runtime(meth));
12587   ins_pipe(pipe_slow);
12588 %}
12589 
12590 // Return Instruction
12591 // Remove the return address &amp; jump to it.
12592 // Notice: We always emit a nop after a ret to make sure there is room
12593 // for safepoint patching
12594 instruct Ret()
</pre>
</td>
<td>
<hr />
<pre>
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 int MachCallNativeNode::ret_addr_offset() {
  463   int offset = 13; // movq r10,#addr; callq (r10)
<span class="line-added">  464   offset += clear_avx_size();</span>
  465   return offset;
  466 }
  467 //
  468 // Compute padding required for nodes which need alignment
  469 //
  470 
  471 // The address of the call instruction needs to be 4-byte aligned to
  472 // ensure that it does not span a cache line so that it can be patched.
  473 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  474 {
  475   current_offset += clear_avx_size(); // skip vzeroupper
  476   current_offset += 1; // skip call opcode byte
  477   return align_up(current_offset, alignment_required()) - current_offset;
  478 }
  479 
  480 // The address of the call instruction needs to be 4-byte aligned to
  481 // ensure that it does not span a cache line so that it can be patched.
  482 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  483 {
  484   current_offset += clear_avx_size(); // skip vzeroupper
</pre>
<hr />
<pre>
12553 // Call runtime without safepoint
12554 instruct CallLeafDirect(method meth)
12555 %{
12556   match(CallLeaf);
12557   effect(USE meth);
12558 
12559   ins_cost(300);
12560   format %{ &quot;call_leaf,runtime &quot; %}
12561   ins_encode(clear_avx, Java_To_Runtime(meth));
12562   ins_pipe(pipe_slow);
12563 %}
12564 
12565 //
12566 instruct CallNativeDirect(method meth)
12567 %{
12568   match(CallNative);
12569   effect(USE meth);
12570 
12571   ins_cost(300);
12572   format %{ &quot;call_native &quot; %}
<span class="line-modified">12573   ins_encode(clear_avx, Java_To_Runtime(meth));</span>


12574   ins_pipe(pipe_slow);
12575 %}
12576 
12577 // Call runtime without safepoint
12578 instruct CallLeafNoFPDirect(method meth)
12579 %{
12580   match(CallLeafNoFP);
12581   effect(USE meth);
12582 
12583   ins_cost(300);
12584   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12585   ins_encode(clear_avx, Java_To_Runtime(meth));
12586   ins_pipe(pipe_slow);
12587 %}
12588 
12589 // Return Instruction
12590 // Remove the return address &amp; jump to it.
12591 // Notice: We always emit a nop after a ret to make sure there is room
12592 // for safepoint patching
12593 instruct Ret()
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../../share/opto/output.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
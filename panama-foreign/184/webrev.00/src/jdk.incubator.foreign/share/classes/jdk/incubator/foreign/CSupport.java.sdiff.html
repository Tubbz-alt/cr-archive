<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/Utils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.Utils;
 29 import jdk.internal.foreign.abi.SharedUtils;
 30 
 31 import java.nio.ByteOrder;

 32 
 33 /**
 34  * A set of utilities for working with libraries using the C language/ABI
 35  */
 36 public class CSupport {
 37     /**
 38      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 39      * &lt;p&gt;
 40      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 41      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 42      * restricted methods, and use safe and supported functionalities, where possible.
 43      * @return a linker for this system.
 44      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 45      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 46      */
 47     public static ForeignLinker getSystemLinker() {
 48         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 49         return SharedUtils.getSystemLinker();
 50     }
 51 






































 52     /**
 53      * The {@code _Bool} native type.
 54      */
 55     public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
 56     /**
 57      * The {@code char} native type.
 58      */
 59     public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
 60     /**
 61      * The {@code short} native type.
 62      */
 63     public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
 64     /**
 65      * The {@code int} native type.
 66      */
 67     public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
 68     /**
 69      * The {@code long} native type.
 70      */
 71     public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
</pre>
<hr />
<pre>
 73      * The {@code long long} native type.
 74      */
 75     public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
 76     /**
 77      * The {@code float} native type.
 78      */
 79     public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
 80     /**
 81      * The {@code double} native type.
 82      */
 83     public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
 84     /**
 85      * The {@code long double} native type.
 86      */
 87     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
 88     /**
 89      * The {@code T*} native type.
 90      */
 91     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
 92 





 93     /**
 94      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
 95      */
 96     public static final class SysV {
 97         private SysV() {
 98             //just the one
 99         }
100 
101         /**
102          * The name of the SysV linker ({@see ForeignLinker#name})
103          */
104         public static final String NAME = &quot;SysV&quot;;
105 
106         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
107 
108         public enum ArgumentClass {
109             INTEGER,
110             SSE,
111             X87,
112             COMPLEX_87,
</pre>
<hr />
<pre>
161         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
162                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
163 
164         /**
165          * The {@code long double} native type.
166          */
167         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
168                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
169 
170         /**
171          * The {@code complex long double} native type.
172          */
173         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
174                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
175 
176         /**
177          * The {@code T*} native type.
178          */
179         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
180                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);





181     }
182 
183     /**
184      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
185      */
186     public static final class Win64 {
187 
188         private Win64() {
189             //just the one
190         }
191 
192         /**
193          * The name of the Windows linker ({@see ForeignLinker#name})
194          */
195         public final static String NAME = &quot;Windows&quot;;
196 
197         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
198 
199         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
200 
</pre>
<hr />
<pre>
247                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
248 
249         /**
250          * The {@code double} native type.
251          */
252         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
253                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
254 
255         /**
256          * The {@code long double} native type.
257          */
258         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
259                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
260 
261         /**
262          * The {@code T*} native type.
263          */
264         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
265                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
266 





267         public static ValueLayout asVarArg(ValueLayout l) {
268             return l.withAttribute(VARARGS_ATTRIBUTE_NAME, &quot;true&quot;);
269         }
270     }
271 
272     /**
273      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
274      */
275     public static final class AArch64 {
276 
277         private AArch64() {
278             //just the one
279         }
280 
281         /**
282          * The name of the AArch64 linker ({@see ForeignLinker#name})
283          */
284         public final static String NAME = &quot;AArch64&quot;;
285 
286         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
</pre>
</td>
<td>
<hr />
<pre>
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.Utils;
 29 import jdk.internal.foreign.abi.SharedUtils;
 30 
 31 import java.nio.ByteOrder;
<span class="line-added"> 32 import java.util.function.Consumer;</span>
 33 
 34 /**
 35  * A set of utilities for working with libraries using the C language/ABI
 36  */
 37 public class CSupport {
 38     /**
 39      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 40      * &lt;p&gt;
 41      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 42      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 43      * restricted methods, and use safe and supported functionalities, where possible.
 44      * @return a linker for this system.
 45      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 46      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 47      */
 48     public static ForeignLinker getSystemLinker() {
 49         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 50         return SharedUtils.getSystemLinker();
 51     }
 52 
<span class="line-added"> 53     public static VaList newVaList(Consumer&lt;VaList.Builder&gt; actions) {</span>
<span class="line-added"> 54         return SharedUtils.newVaList(actions);</span>
<span class="line-added"> 55     }</span>
<span class="line-added"> 56 </span>
<span class="line-added"> 57     public interface VaList extends AutoCloseable /* permits */ {</span>
<span class="line-added"> 58         Reader reader(int num);</span>
<span class="line-added"> 59         boolean isAlive();</span>
<span class="line-added"> 60         void close();</span>
<span class="line-added"> 61 </span>
<span class="line-added"> 62         /**</span>
<span class="line-added"> 63          * Reader interface used to read values from a va_list</span>
<span class="line-added"> 64          *</span>
<span class="line-added"> 65          * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),</span>
<span class="line-added"> 66          * arguments to variadic calls are erased by way of &#39;default argument promotions&#39;,</span>
<span class="line-added"> 67          * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),</span>
<span class="line-added"> 68          * and which erases all {@code float} arguments to {@code double}.</span>
<span class="line-added"> 69          *</span>
<span class="line-added"> 70          * As such, this reader interface only supports reading {@code int}, {@code double},</span>
<span class="line-added"> 71          * and any other type that fits into a {@code long} (when given it&#39;s layout).</span>
<span class="line-added"> 72          */</span>
<span class="line-added"> 73         interface Reader {</span>
<span class="line-added"> 74             int readInt(MemoryLayout layout);</span>
<span class="line-added"> 75             long readLong(MemoryLayout layout);</span>
<span class="line-added"> 76             double readDouble(MemoryLayout layout);</span>
<span class="line-added"> 77             MemoryAddress readPointer(MemoryLayout layout);</span>
<span class="line-added"> 78             MemorySegment readStructOrUnion(MemoryLayout layout);</span>
<span class="line-added"> 79             void skip(MemoryLayout...layouts);</span>
<span class="line-added"> 80         }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82         interface Builder {</span>
<span class="line-added"> 83             Builder intArg(MemoryLayout layout, int value);</span>
<span class="line-added"> 84             Builder longArg(MemoryLayout layout, long value);</span>
<span class="line-added"> 85             Builder doubleArg(MemoryLayout layout, double value);</span>
<span class="line-added"> 86             Builder memoryAddressArg(MemoryLayout layout, MemoryAddress value);</span>
<span class="line-added"> 87             Builder memorySegmentArg(MemoryLayout layout, MemorySegment value);</span>
<span class="line-added"> 88         }</span>
<span class="line-added"> 89     }</span>
<span class="line-added"> 90 </span>
 91     /**
 92      * The {@code _Bool} native type.
 93      */
 94     public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
 95     /**
 96      * The {@code char} native type.
 97      */
 98     public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
 99     /**
100      * The {@code short} native type.
101      */
102     public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
103     /**
104      * The {@code int} native type.
105      */
106     public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
107     /**
108      * The {@code long} native type.
109      */
110     public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
</pre>
<hr />
<pre>
112      * The {@code long long} native type.
113      */
114     public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
115     /**
116      * The {@code float} native type.
117      */
118     public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
119     /**
120      * The {@code double} native type.
121      */
122     public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
123     /**
124      * The {@code long double} native type.
125      */
126     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
127     /**
128      * The {@code T*} native type.
129      */
130     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
131 
<span class="line-added">132     /**</span>
<span class="line-added">133      * The {@code va_list} native type.</span>
<span class="line-added">134      */</span>
<span class="line-added">135     public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, null);</span>
<span class="line-added">136 </span>
137     /**
138      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
139      */
140     public static final class SysV {
141         private SysV() {
142             //just the one
143         }
144 
145         /**
146          * The name of the SysV linker ({@see ForeignLinker#name})
147          */
148         public static final String NAME = &quot;SysV&quot;;
149 
150         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
151 
152         public enum ArgumentClass {
153             INTEGER,
154             SSE,
155             X87,
156             COMPLEX_87,
</pre>
<hr />
<pre>
205         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
206                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
207 
208         /**
209          * The {@code long double} native type.
210          */
211         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
212                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
213 
214         /**
215          * The {@code complex long double} native type.
216          */
217         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
218                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
219 
220         /**
221          * The {@code T*} native type.
222          */
223         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
224                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
<span class="line-added">225 </span>
<span class="line-added">226         /**</span>
<span class="line-added">227          * The {@code va_list} native type, as it is passed to a function.</span>
<span class="line-added">228          */</span>
<span class="line-added">229         public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;</span>
230     }
231 
232     /**
233      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
234      */
235     public static final class Win64 {
236 
237         private Win64() {
238             //just the one
239         }
240 
241         /**
242          * The name of the Windows linker ({@see ForeignLinker#name})
243          */
244         public final static String NAME = &quot;Windows&quot;;
245 
246         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
247 
248         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
249 
</pre>
<hr />
<pre>
296                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
297 
298         /**
299          * The {@code double} native type.
300          */
301         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
302                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
303 
304         /**
305          * The {@code long double} native type.
306          */
307         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
308                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
309 
310         /**
311          * The {@code T*} native type.
312          */
313         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
314                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
315 
<span class="line-added">316         /**</span>
<span class="line-added">317          * The {@code va_list} native type, as it is passed to a function.</span>
<span class="line-added">318          */</span>
<span class="line-added">319         public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;</span>
<span class="line-added">320 </span>
321         public static ValueLayout asVarArg(ValueLayout l) {
322             return l.withAttribute(VARARGS_ATTRIBUTE_NAME, &quot;true&quot;);
323         }
324     }
325 
326     /**
327      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
328      */
329     public static final class AArch64 {
330 
331         private AArch64() {
332             //just the one
333         }
334 
335         /**
336          * The name of the AArch64 linker ({@see ForeignLinker#name})
337          */
338         public final static String NAME = &quot;AArch64&quot;;
339 
340         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/Utils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
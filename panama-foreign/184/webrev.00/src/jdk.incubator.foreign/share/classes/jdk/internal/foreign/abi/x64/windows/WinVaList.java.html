<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.internal.foreign.abi.x64.windows;
 27 
 28 import jdk.incubator.foreign.CSupport;
 29 import jdk.incubator.foreign.MemoryAddress;
 30 import jdk.incubator.foreign.MemoryHandles;
 31 import jdk.incubator.foreign.MemoryLayout;
 32 import jdk.incubator.foreign.MemorySegment;
 33 import jdk.internal.foreign.abi.SharedUtils;
 34 import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;
 35 
 36 import java.lang.invoke.VarHandle;
 37 import java.util.ArrayList;
 38 import java.util.List;
 39 
 40 import static jdk.incubator.foreign.CSupport.Win64.C_DOUBLE;
 41 import static jdk.incubator.foreign.CSupport.Win64.C_INT;
 42 import static jdk.incubator.foreign.CSupport.Win64.C_POINTER;
 43 import static jdk.incubator.foreign.MemorySegment.CLOSE;
 44 import static jdk.incubator.foreign.MemorySegment.READ;
 45 import static jdk.incubator.foreign.MemorySegment.WRITE;
 46 
 47 // see vadefs.h (VC header)
 48 //
 49 // in short
 50 // -&gt; va_list is just a pointer to a buffer with 64 bit entries.
 51 // -&gt; non-power-of-two-sized, or larger than 64 bit types passed by reference.
 52 // -&gt; other types passed in 64 bit slots by normal function calling convention.
 53 //
 54 // X64 va_arg impl:
 55 //
 56 //    typedef char* va_list;
 57 //
 58 //    #define __crt_va_arg(ap, t)                                               \
 59 //        ((sizeof(t) &gt; sizeof(__int64) || (sizeof(t) &amp; (sizeof(t) - 1)) != 0) \
 60 //            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))             \
 61 //            :  *(t* )((ap += sizeof(__int64)) - sizeof(__int64)))
 62 //
 63 class WinVaList implements CSupport.VaList {
 64     public static final Class&lt;?&gt; CARRIER = MemoryAddress.class;
 65     private static final long VA_SLOT_SIZE_BYTES = 8;
 66     private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));
 67 
 68     private final MemorySegment segment;
 69     private final List&lt;MemorySegment&gt; slices;
 70 
 71     WinVaList(MemorySegment segment) {
 72         this(segment, new ArrayList&lt;&gt;());
 73     }
 74 
 75     WinVaList(MemorySegment segment, List&lt;MemorySegment&gt; slices) {
 76         this.segment = segment;
 77         this.slices = slices;
 78     }
 79 
 80     static Builder builder() {
 81         return new Builder();
 82     }
 83 
 84     MemorySegment getSegment() {
 85         return segment;
 86     }
 87 
 88     @Override
 89     public void close() {
 90         segment.close();
 91         slices.forEach(MemorySegment::close);
 92     }
 93 
 94     @Override
 95     public Reader reader(int num) {
 96         return new Reader(num);
 97     }
 98 
 99     @Override
100     public boolean isAlive() {
101         return segment.isAlive();
102     }
103 
104     static class Builder implements CSupport.VaList.Builder {
105 
106         private final List&lt;SimpleVaArg&gt; args = new ArrayList&lt;&gt;();
107 
108         private Builder arg(Class&lt;?&gt; carrier, MemoryLayout layout, Object value) {
109             SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);
110             args.add(new SimpleVaArg(carrier, layout, value));
111             return this;
112         }
113 
114         @Override
115         public Builder intArg(MemoryLayout layout, int value) {
116             return arg(int.class, layout, value);
117         }
118 
119         @Override
120         public Builder longArg(MemoryLayout layout, long value) {
121             return arg(long.class, layout, value);
122         }
123 
124         @Override
125         public Builder doubleArg(MemoryLayout layout, double value) {
126             return arg(double.class, layout, value);
127         }
128 
129         @Override
130         public Builder memoryAddressArg(MemoryLayout layout, MemoryAddress value) {
131             return arg(MemoryAddress.class, layout, value);
132         }
133 
134         @Override
135         public Builder memorySegmentArg(MemoryLayout layout, MemorySegment value) {
136             return arg(MemorySegment.class, layout, value);
137         }
138 
139         public WinVaList build() {
140             MemorySegment ms = MemorySegment.allocateNative(VA_SLOT_SIZE_BYTES * args.size());
141             List&lt;MemorySegment&gt; slices = new ArrayList&lt;&gt;();
142 
143             MemoryAddress addr = ms.baseAddress();
144             for (SimpleVaArg arg : args) {
145                 if (arg.carrier == MemorySegment.class) {
146                     MemorySegment msArg = ((MemorySegment) arg.value);
147                     TypeClass typeClass = TypeClass.typeClassFor(arg.layout);
148                     switch (typeClass) {
149                         case STRUCT_REFERENCE -&gt; {
150                             MemorySegment copy = MemorySegment.allocateNative(arg.layout);
151                             copy.copyFrom(msArg); // by-value
152                             slices.add(copy);
153                             VH_address.set(addr, copy.baseAddress());
154                         }
155                         case STRUCT_REGISTER -&gt; {
156                             MemorySegment slice = ms.asSlice(addr.segmentOffset(), VA_SLOT_SIZE_BYTES);
157                             slice.copyFrom(msArg);
158                         }
159                         default -&gt; throw new IllegalStateException(&quot;Unexpected TypeClass: &quot; + typeClass);
160                     }
161                 } else {
162                     VarHandle writer = arg.varHandle();
163                     writer.set(addr, arg.value);
164                 }
165                 addr = addr.addOffset(VA_SLOT_SIZE_BYTES);
166             }
167 
168             return new WinVaList(ms.withAccessModes(CLOSE | READ), slices);
169         }
170     }
171 
172     class Reader implements CSupport.VaList.Reader {
173         private MemoryAddress ptr;
174 
175         public Reader(int num) {
176             ptr = segment.asSlice(0, num * VA_SLOT_SIZE_BYTES).baseAddress();
177         }
178 
179         @Override
180         public int readInt(MemoryLayout layout) {
181             return (int) read(int.class, layout);
182         }
183 
184         @Override
185         public long readLong(MemoryLayout layout) {
186             return (long) read(long.class, layout);
187         }
188 
189         @Override
190         public double readDouble(MemoryLayout layout) {
191             return (double) read(double.class, layout);
192         }
193 
194         @Override
195         public MemoryAddress readPointer(MemoryLayout layout) {
196             return (MemoryAddress) read(MemoryAddress.class, layout);
197         }
198 
199         @Override
200         public MemorySegment readStructOrUnion(MemoryLayout layout) {
201             return (MemorySegment) read(MemorySegment.class, layout);
202         }
203 
204         private Object read(Class&lt;?&gt; carrier, MemoryLayout layout) {
205             SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);
206             Object res;
207             if (carrier == MemorySegment.class) {
208                 TypeClass typeClass = TypeClass.typeClassFor(layout);
209                 switch (typeClass) {
210                     case STRUCT_REFERENCE -&gt; {
211                         MemoryAddress structAddr = (MemoryAddress) VH_address.get(ptr);
212                         MemorySegment struct = MemorySegment.ofNativeRestricted(structAddr, layout.byteSize(),
213                                                                                 segment.ownerThread(), null, null);
214                         slices.add(struct);
215                         res = struct.withAccessModes(WRITE | READ);
216                     }
217                     case STRUCT_REGISTER -&gt; {
218                         MemorySegment struct = MemorySegment.allocateNative(layout);
219                         struct.copyFrom(segment.asSlice(ptr.segmentOffset(), layout.byteSize()));
220                         slices.add(struct);
221                         res = struct.withAccessModes(WRITE | READ);
222                     }
223                     default -&gt; throw new IllegalStateException(&quot;Unexpected TypeClass: &quot; + typeClass);
224                 }
225             } else {
226                 VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
227                 res = reader.get(ptr);
228             }
229             ptr = ptr.addOffset(VA_SLOT_SIZE_BYTES);
230             return res;
231         }
232 
233         @Override
234         public void skip(MemoryLayout... layouts) {
235             ptr = ptr.addOffset(layouts.length * VA_SLOT_SIZE_BYTES);
236         }
237     }
238 }
    </pre>
  </body>
</html>
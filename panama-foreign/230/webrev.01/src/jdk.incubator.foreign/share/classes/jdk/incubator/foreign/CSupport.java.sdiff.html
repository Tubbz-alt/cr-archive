<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="FunctionDescriptor.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
285     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
286     /**
287      * The {@code T*} native type.
288      */
289     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
290 
291     /**
292      * The {@code va_list} native type.
293      */
294     public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, null);
295 
296     /**
297      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
298      */
299     public static final class SysV {
300         private SysV() {
301             //just the one
302         }
303 
304         /**
<span class="line-modified">305          * The name of the SysV linker ({@see ForeignLinker#name})</span>

306          */
307         public static final String NAME = &quot;SysV&quot;;
308 




309         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
310 



311         public enum ArgumentClass {

312             INTEGER,

313             SSE,

314             X87,

315             COMPLEX_87,

316             POINTER;
317         }
318 
319         /**
320          * The {@code _Bool} native type.
321          */
322         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
323                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
324 
325         /**
326          * The {@code char} native type.
327          */
328         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
329                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
330 
331         /**
332          * The {@code short} native type.
333          */
334         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
335                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
</pre>
<hr />
<pre>
381          */
382         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
383                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
384 
385         /**
386          * The {@code va_list} native type, as it is passed to a function.
387          */
388         public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;
389     }
390 
391     /**
392      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
393      */
394     public static final class Win64 {
395 
396         private Win64() {
397             //just the one
398         }
399 
400         /**
<span class="line-modified">401          * The name of the Windows linker ({@see ForeignLinker#name})</span>

402          */
403         public final static String NAME = &quot;Windows&quot;;
404 




405         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
406 




407         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
408 



409         public enum ArgumentClass {

410             INTEGER,

411             FLOAT,

412             POINTER;
413         }
414 
415         /**
416          * The {@code _Bool} native type.
417          */
418         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
419                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
420 
421         /**
422          * The {@code char} native type.
423          */
424         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
425                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
426 
427         /**
428          * The {@code short} native type.
429          */
430         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
431                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
</pre>
<hr />
<pre>
460         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
461                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
462 
463         /**
464          * The {@code long double} native type.
465          */
466         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
467                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
468 
469         /**
470          * The {@code T*} native type.
471          */
472         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
473                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
474 
475         /**
476          * The {@code va_list} native type, as it is passed to a function.
477          */
478         public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;
479 
<span class="line-modified">480         public static ValueLayout asVarArg(ValueLayout l) {</span>
<span class="line-modified">481             return l.withAttribute(VARARGS_ATTRIBUTE_NAME, &quot;true&quot;);</span>






482         }
483     }
484 
485     /**
486      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
487      */
488     public static final class AArch64 {
489 
490         private AArch64() {
491             //just the one
492         }
493 
494         /**
<span class="line-modified">495          * The name of the AArch64 linker ({@see ForeignLinker#name})</span>

496          */
497         public final static String NAME = &quot;AArch64&quot;;
498 




499         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
500 



501         public enum ArgumentClass {

502             INTEGER,

503             VECTOR,

504             POINTER;
505         }
506 
507         /**
508          * The {@code _Bool} native type.
509          */
510         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
511                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
512 
513         /**
514          * The {@code char} native type.
515          */
516         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
517                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
518 
519         /**
520          * The {@code short} native type.
521          */
522         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
523                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
</pre>
<hr />
<pre>
683      * @throws NullPointerException if {@code addr == null}
684      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
685      */
686     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
687         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
688         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), charset);
689     }
690 
691     /**
692      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
693      * &lt;p&gt;
694      * This method always replaces malformed-input and unmappable-character
695      * sequences with this charset&#39;s default replacement string.  The {@link
696      * java.nio.charset.CharsetDecoder} class should be used when more control
697      * over the decoding process is required.
698      * @param addr the address at which the string is stored.
699      * @return a Java string with the contents of the null-terminated C string at given address.
700      * @throws NullPointerException if {@code addr == null}
701      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
702      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
<span class="line-modified">703      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;/em&gt;not alive&lt;em&gt;.</span>
704      */
705     public static String toJavaString(MemoryAddress addr) {
706         return SharedUtils.toJavaStringInternal(addr, Charset.defaultCharset());
707     }
708 
709     /**
710      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
711      * &lt;p&gt;
712      * This method always replaces malformed-input and unmappable-character
713      * sequences with this charset&#39;s default replacement string.  The {@link
714      * java.nio.charset.CharsetDecoder} class should be used when more control
715      * over the decoding process is required.
716      * @param addr the address at which the string is stored.
717      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
718      * @return a Java string with the contents of the null-terminated C string at given address.
719      * @throws NullPointerException if {@code addr == null}
720      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
721      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
<span class="line-modified">722      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;/em&gt;not alive&lt;em&gt;.</span>
723      */
724     public static String toJavaString(MemoryAddress addr, Charset charset) {
725         return SharedUtils.toJavaStringInternal(addr, charset);
726     }
727 
728     private static void copy(MemoryAddress addr, byte[] bytes) {
729         var heapSegment = MemorySegment.ofArray(bytes);
730         addr.segment().copyFrom(heapSegment);
731         MemoryAccess.setByte(addr, bytes.length, (byte)0);
732     }
733 
734     private static MemorySegment toCString(byte[] bytes) {
735         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
736         MemoryAddress addr = segment.baseAddress();
737         copy(addr, bytes);
738         return segment;
739     }
740 
741     private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
742         MemoryAddress addr = scope.allocate(bytes.length + 1, 1L);
</pre>
</td>
<td>
<hr />
<pre>
285     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
286     /**
287      * The {@code T*} native type.
288      */
289     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
290 
291     /**
292      * The {@code va_list} native type.
293      */
294     public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, null);
295 
296     /**
297      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
298      */
299     public static final class SysV {
300         private SysV() {
301             //just the one
302         }
303 
304         /**
<span class="line-modified">305          * The name of the SysV linker</span>
<span class="line-added">306          * @see ForeignLinker#name</span>
307          */
308         public static final String NAME = &quot;SysV&quot;;
309 
<span class="line-added">310         /**</span>
<span class="line-added">311          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The</span>
<span class="line-added">312          * attribute value must be an enum constant from {@link ArgumentClass}.</span>
<span class="line-added">313          */</span>
314         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
315 
<span class="line-added">316         /**</span>
<span class="line-added">317          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.</span>
<span class="line-added">318          */</span>
319         public enum ArgumentClass {
<span class="line-added">320             /** Classification constant for integral values */</span>
321             INTEGER,
<span class="line-added">322             /** Classification constant for floating point values */</span>
323             SSE,
<span class="line-added">324             /** Classification constant for x87 floating point values */</span>
325             X87,
<span class="line-added">326             /** Classification constant for {@code complex long double} values */</span>
327             COMPLEX_87,
<span class="line-added">328             /** Classification constant for machine pointer values */</span>
329             POINTER;
330         }
331 
332         /**
333          * The {@code _Bool} native type.
334          */
335         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
336                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
337 
338         /**
339          * The {@code char} native type.
340          */
341         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
342                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
343 
344         /**
345          * The {@code short} native type.
346          */
347         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
348                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
</pre>
<hr />
<pre>
394          */
395         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
396                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
397 
398         /**
399          * The {@code va_list} native type, as it is passed to a function.
400          */
401         public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;
402     }
403 
404     /**
405      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
406      */
407     public static final class Win64 {
408 
409         private Win64() {
410             //just the one
411         }
412 
413         /**
<span class="line-modified">414          * The name of the Windows linker</span>
<span class="line-added">415          * @see ForeignLinker#name</span>
416          */
417         public final static String NAME = &quot;Windows&quot;;
418 
<span class="line-added">419         /**</span>
<span class="line-added">420          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The</span>
<span class="line-added">421          * attribute value must be a boolean.</span>
<span class="line-added">422          */</span>
423         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
424 
<span class="line-added">425         /**</span>
<span class="line-added">426          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The</span>
<span class="line-added">427          * attribute value must be an enum constant from {@link ArgumentClass}.</span>
<span class="line-added">428          */</span>
429         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
430 
<span class="line-added">431         /**</span>
<span class="line-added">432          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.</span>
<span class="line-added">433          */</span>
434         public enum ArgumentClass {
<span class="line-added">435             /** Classification constant for integral values */</span>
436             INTEGER,
<span class="line-added">437             /** Classification constant for floating point values */</span>
438             FLOAT,
<span class="line-added">439             /** Classification constant for machine pointer values */</span>
440             POINTER;
441         }
442 
443         /**
444          * The {@code _Bool} native type.
445          */
446         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
447                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
448 
449         /**
450          * The {@code char} native type.
451          */
452         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
453                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
454 
455         /**
456          * The {@code short} native type.
457          */
458         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
459                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
</pre>
<hr />
<pre>
488         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
489                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
490 
491         /**
492          * The {@code long double} native type.
493          */
494         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
495                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
496 
497         /**
498          * The {@code T*} native type.
499          */
500         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
501                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
502 
503         /**
504          * The {@code va_list} native type, as it is passed to a function.
505          */
506         public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;
507 
<span class="line-modified">508         /**</span>
<span class="line-modified">509          * Return a new memory layout which describes a variadic parameter to be passed to a function.</span>
<span class="line-added">510          * @param layout the original parameter layout.</span>
<span class="line-added">511          * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},</span>
<span class="line-added">512          * which is set to {@code true}.</span>
<span class="line-added">513          */</span>
<span class="line-added">514         public static ValueLayout asVarArg(ValueLayout layout) {</span>
<span class="line-added">515             return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, &quot;true&quot;);</span>
516         }
517     }
518 
519     /**
520      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
521      */
522     public static final class AArch64 {
523 
524         private AArch64() {
525             //just the one
526         }
527 
528         /**
<span class="line-modified">529          * The name of the AArch64 linker</span>
<span class="line-added">530          * @see ForeignLinker#name</span>
531          */
532         public final static String NAME = &quot;AArch64&quot;;
533 
<span class="line-added">534         /**</span>
<span class="line-added">535          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The</span>
<span class="line-added">536          * attribute value must be an enum constant from {@link ArgumentClass}.</span>
<span class="line-added">537          */</span>
538         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
539 
<span class="line-added">540         /**</span>
<span class="line-added">541          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.</span>
<span class="line-added">542          */</span>
543         public enum ArgumentClass {
<span class="line-added">544             /** Classification constant for machine integral values */</span>
545             INTEGER,
<span class="line-added">546             /** Classification constant for machine floating point values */</span>
547             VECTOR,
<span class="line-added">548             /** Classification constant for machine pointer values */</span>
549             POINTER;
550         }
551 
552         /**
553          * The {@code _Bool} native type.
554          */
555         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
556                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
557 
558         /**
559          * The {@code char} native type.
560          */
561         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
562                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
563 
564         /**
565          * The {@code short} native type.
566          */
567         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
568                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
</pre>
<hr />
<pre>
728      * @throws NullPointerException if {@code addr == null}
729      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
730      */
731     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
732         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
733         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), charset);
734     }
735 
736     /**
737      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
738      * &lt;p&gt;
739      * This method always replaces malformed-input and unmappable-character
740      * sequences with this charset&#39;s default replacement string.  The {@link
741      * java.nio.charset.CharsetDecoder} class should be used when more control
742      * over the decoding process is required.
743      * @param addr the address at which the string is stored.
744      * @return a Java string with the contents of the null-terminated C string at given address.
745      * @throws NullPointerException if {@code addr == null}
746      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
747      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
<span class="line-modified">748      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.</span>
749      */
750     public static String toJavaString(MemoryAddress addr) {
751         return SharedUtils.toJavaStringInternal(addr, Charset.defaultCharset());
752     }
753 
754     /**
755      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
756      * &lt;p&gt;
757      * This method always replaces malformed-input and unmappable-character
758      * sequences with this charset&#39;s default replacement string.  The {@link
759      * java.nio.charset.CharsetDecoder} class should be used when more control
760      * over the decoding process is required.
761      * @param addr the address at which the string is stored.
762      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
763      * @return a Java string with the contents of the null-terminated C string at given address.
764      * @throws NullPointerException if {@code addr == null}
765      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
766      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
<span class="line-modified">767      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.</span>
768      */
769     public static String toJavaString(MemoryAddress addr, Charset charset) {
770         return SharedUtils.toJavaStringInternal(addr, charset);
771     }
772 
773     private static void copy(MemoryAddress addr, byte[] bytes) {
774         var heapSegment = MemorySegment.ofArray(bytes);
775         addr.segment().copyFrom(heapSegment);
776         MemoryAccess.setByte(addr, bytes.length, (byte)0);
777     }
778 
779     private static MemorySegment toCString(byte[] bytes) {
780         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
781         MemoryAddress addr = segment.baseAddress();
782         copy(addr, bytes);
783         return segment;
784     }
785 
786     private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
787         MemoryAddress addr = scope.allocate(bytes.length + 1, 1L);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="FunctionDescriptor.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
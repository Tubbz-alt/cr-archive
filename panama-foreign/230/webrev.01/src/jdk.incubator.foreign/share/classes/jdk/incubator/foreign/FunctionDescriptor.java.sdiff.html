<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/FunctionDescriptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/abi/SharedUtils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/FunctionDescriptor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 import java.lang.constant.Constable;
 26 import java.lang.constant.ConstantDesc;
 27 import java.lang.constant.ConstantDescs;
 28 import java.lang.constant.DynamicConstantDesc;
 29 import java.util.ArrayList;
 30 import java.util.Arrays;
 31 import java.util.Collections;
 32 import java.util.HashMap;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Objects;
 36 import java.util.Optional;
 37 import java.util.stream.Collectors;
 38 import java.util.stream.Stream;
 39 
 40 /**
 41  * A function descriptor is made up of zero or more argument layouts and one return  A function descriptor
 42  * is used to model the signature of native functions.
 43  */
 44 public final class FunctionDescriptor implements Constable {
<span class="line-modified"> 45     public static final String IS_TRIVIAL = &quot;abi/is_trivial&quot;;</span>





 46     
 47     private final MemoryLayout resLayout;
 48     private final MemoryLayout[] argLayouts;
 49     private final Map&lt;String, Constable&gt; attributes;
 50 
 51     private FunctionDescriptor(MemoryLayout resLayout, Map&lt;String, Constable&gt; attributes, MemoryLayout... argLayouts) {
 52         this.resLayout = resLayout;
 53         this.attributes = Collections.unmodifiableMap(attributes);
 54         this.argLayouts = argLayouts;
 55     }
 56 






 57     public Optional&lt;Constable&gt; attribute(String name) {
 58         return Optional.ofNullable(attributes.get(name));
 59     }
 60 





 61     public Stream&lt;String&gt; attributes() {
 62         return attributes.keySet().stream();
 63     }
 64 









 65     public FunctionDescriptor withAttribute(String name, Constable value) {
 66         Map&lt;String, Constable&gt; newAttributes = new HashMap&lt;&gt;(attributes);
 67         newAttributes.put(name, value);
 68         return new FunctionDescriptor(resLayout, newAttributes, argLayouts);
 69     }
 70 
 71     /**
 72      * Returns the return foreign.layout associated with this function.
 73      * @return the return
 74      */
 75     public Optional&lt;MemoryLayout&gt; returnLayout() {
 76         return Optional.ofNullable(resLayout);
 77     }
 78 
 79     /**
 80      * Returns the argument layouts associated with this function.
 81      * @return the argument layouts.
 82      */
 83     public List&lt;MemoryLayout&gt; argumentLayouts() {
 84         return Arrays.asList(argLayouts);
</pre>
<hr />
<pre>
162      */
163     @Override
164     public int hashCode() {
165         int hashCode = Arrays.hashCode(argLayouts);
166         return resLayout == null ? hashCode : resLayout.hashCode() ^ hashCode;
167     }
168 
169     @Override
170     public Optional&lt;DynamicConstantDesc&lt;FunctionDescriptor&gt;&gt; describeConstable() {
171         List&lt;ConstantDesc&gt; constants = new ArrayList&lt;&gt;();
172         constants.add(resLayout == null ? AbstractLayout.MH_VOID_FUNCTION : AbstractLayout.MH_FUNCTION);
173         if (resLayout != null) {
174             constants.add(resLayout.describeConstable().get());
175         }
176         for (MemoryLayout argLayout : argLayouts) {
177             constants.add(argLayout.describeConstable().get());
178         }
179         return Optional.of(DynamicConstantDesc.ofNamed(
180                     ConstantDescs.BSM_INVOKE, &quot;function&quot;, AbstractLayout.CD_FUNCTION_DESC, constants.toArray(new ConstantDesc[0])));
181     }
<span class="line-modified">182 }</span>
</pre>
</td>
<td>
<hr />
<pre>
 25 import java.lang.constant.Constable;
 26 import java.lang.constant.ConstantDesc;
 27 import java.lang.constant.ConstantDescs;
 28 import java.lang.constant.DynamicConstantDesc;
 29 import java.util.ArrayList;
 30 import java.util.Arrays;
 31 import java.util.Collections;
 32 import java.util.HashMap;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Objects;
 36 import java.util.Optional;
 37 import java.util.stream.Collectors;
 38 import java.util.stream.Stream;
 39 
 40 /**
 41  * A function descriptor is made up of zero or more argument layouts and one return  A function descriptor
 42  * is used to model the signature of native functions.
 43  */
 44 public final class FunctionDescriptor implements Constable {
<span class="line-modified"> 45 </span>
<span class="line-added"> 46     /**</span>
<span class="line-added"> 47      * The name of the function descriptor attribute (see {@link #attributes()} used to mark trivial functions. The</span>
<span class="line-added"> 48      * attribute value must be a boolean.</span>
<span class="line-added"> 49      */</span>
<span class="line-added"> 50     public static final String TRIVIAL_ATTRIBUTE_NAME = &quot;abi/trivial&quot;;</span>
 51     
 52     private final MemoryLayout resLayout;
 53     private final MemoryLayout[] argLayouts;
 54     private final Map&lt;String, Constable&gt; attributes;
 55 
 56     private FunctionDescriptor(MemoryLayout resLayout, Map&lt;String, Constable&gt; attributes, MemoryLayout... argLayouts) {
 57         this.resLayout = resLayout;
 58         this.attributes = Collections.unmodifiableMap(attributes);
 59         this.argLayouts = argLayouts;
 60     }
 61 
<span class="line-added"> 62     /**</span>
<span class="line-added"> 63      * Returns the attribute with the given name (if it exists).</span>
<span class="line-added"> 64      *</span>
<span class="line-added"> 65      * @param name the attribute name</span>
<span class="line-added"> 66      * @return the attribute with the given name (if it exists).</span>
<span class="line-added"> 67      */</span>
 68     public Optional&lt;Constable&gt; attribute(String name) {
 69         return Optional.ofNullable(attributes.get(name));
 70     }
 71 
<span class="line-added"> 72     /**</span>
<span class="line-added"> 73      * Returns a stream of the attribute names associated with this function descriptor.</span>
<span class="line-added"> 74      *</span>
<span class="line-added"> 75      * @return a stream of the attribute names associated with this function descriptor.</span>
<span class="line-added"> 76      */</span>
 77     public Stream&lt;String&gt; attributes() {
 78         return attributes.keySet().stream();
 79     }
 80 
<span class="line-added"> 81     /**</span>
<span class="line-added"> 82      * Returns a new function descriptor which features the same attributes as this descriptor, plus the newly specified attribute.</span>
<span class="line-added"> 83      * If this descriptor already contains an attribute with the same name, the existing attribute value is overwritten in the returned</span>
<span class="line-added"> 84      * descriptor.</span>
<span class="line-added"> 85      *</span>
<span class="line-added"> 86      * @param name the attribute name.</span>
<span class="line-added"> 87      * @param value the attribute value.</span>
<span class="line-added"> 88      * @return a new function descriptor which features the same attributes as this descriptor, plus the newly specified attribute.</span>
<span class="line-added"> 89      */</span>
 90     public FunctionDescriptor withAttribute(String name, Constable value) {
 91         Map&lt;String, Constable&gt; newAttributes = new HashMap&lt;&gt;(attributes);
 92         newAttributes.put(name, value);
 93         return new FunctionDescriptor(resLayout, newAttributes, argLayouts);
 94     }
 95 
 96     /**
 97      * Returns the return foreign.layout associated with this function.
 98      * @return the return
 99      */
100     public Optional&lt;MemoryLayout&gt; returnLayout() {
101         return Optional.ofNullable(resLayout);
102     }
103 
104     /**
105      * Returns the argument layouts associated with this function.
106      * @return the argument layouts.
107      */
108     public List&lt;MemoryLayout&gt; argumentLayouts() {
109         return Arrays.asList(argLayouts);
</pre>
<hr />
<pre>
187      */
188     @Override
189     public int hashCode() {
190         int hashCode = Arrays.hashCode(argLayouts);
191         return resLayout == null ? hashCode : resLayout.hashCode() ^ hashCode;
192     }
193 
194     @Override
195     public Optional&lt;DynamicConstantDesc&lt;FunctionDescriptor&gt;&gt; describeConstable() {
196         List&lt;ConstantDesc&gt; constants = new ArrayList&lt;&gt;();
197         constants.add(resLayout == null ? AbstractLayout.MH_VOID_FUNCTION : AbstractLayout.MH_FUNCTION);
198         if (resLayout != null) {
199             constants.add(resLayout.describeConstable().get());
200         }
201         for (MemoryLayout argLayout : argLayouts) {
202             constants.add(argLayout.describeConstable().get());
203         }
204         return Optional.of(DynamicConstantDesc.ofNamed(
205                     ConstantDescs.BSM_INVOKE, &quot;function&quot;, AbstractLayout.CD_FUNCTION_DESC, constants.toArray(new ConstantDesc[0])));
206     }
<span class="line-modified">207 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="CSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/abi/SharedUtils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
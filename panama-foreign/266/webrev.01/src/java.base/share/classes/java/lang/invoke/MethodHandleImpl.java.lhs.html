<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangInvokeAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.invoke.NativeEntryPoint;
  31 import jdk.internal.org.objectweb.asm.ClassWriter;
  32 import jdk.internal.org.objectweb.asm.MethodVisitor;
  33 import jdk.internal.reflect.CallerSensitive;
  34 import jdk.internal.reflect.Reflection;
  35 import jdk.internal.vm.annotation.ForceInline;
  36 import jdk.internal.vm.annotation.Hidden;
  37 import jdk.internal.vm.annotation.Stable;
  38 import sun.invoke.empty.Empty;
  39 import sun.invoke.util.ValueConversions;
  40 import sun.invoke.util.VerifyType;
  41 import sun.invoke.util.Wrapper;
  42 
  43 import java.lang.invoke.MethodHandles.Lookup;
  44 import java.lang.reflect.Array;
  45 import java.nio.ByteOrder;
  46 import java.util.Arrays;
  47 import java.util.Collections;
  48 import java.util.HashMap;
  49 import java.util.Iterator;
  50 import java.util.List;
  51 import java.util.Map;
  52 import java.util.function.Function;
  53 import java.util.stream.Stream;
  54 
  55 import static java.lang.invoke.LambdaForm.*;
  56 import static java.lang.invoke.MethodHandleStatics.*;
  57 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  58 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  59 
  60 /**
  61  * Trusted implementation code for MethodHandle.
  62  * @author jrose
  63  */
  64 /*non-public*/
  65 abstract class MethodHandleImpl {
  66 
  67     /// Factory methods to create method handles:
  68 
  69     static MethodHandle makeArrayElementAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
  70         if (arrayClass == Object[].class) {
  71             return ArrayAccess.objectAccessor(access);
  72         }
  73         if (!arrayClass.isArray())
  74             throw newIllegalArgumentException(&quot;not an array: &quot;+arrayClass);
  75         MethodHandle[] cache = ArrayAccessor.TYPED_ACCESSORS.get(arrayClass);
  76         int cacheIndex = ArrayAccess.cacheIndex(access);
  77         MethodHandle mh = cache[cacheIndex];
  78         if (mh != null)  return mh;
  79         mh = ArrayAccessor.getAccessor(arrayClass, access);
  80         MethodType correctType = ArrayAccessor.correctType(arrayClass, access);
  81         if (mh.type() != correctType) {
  82             assert(mh.type().parameterType(0) == Object[].class);
  83             /* if access == SET */ assert(access != ArrayAccess.SET || mh.type().parameterType(2) == Object.class);
  84             /* if access == GET */ assert(access != ArrayAccess.GET ||
  85                     (mh.type().returnType() == Object.class &amp;&amp;
  86                      correctType.parameterType(0).getComponentType() == correctType.returnType()));
  87             // safe to view non-strictly, because element type follows from array type
  88             mh = mh.viewAsType(correctType, false);
  89         }
  90         mh = makeIntrinsic(mh, ArrayAccess.intrinsic(access));
  91         // Atomically update accessor cache.
  92         synchronized(cache) {
  93             if (cache[cacheIndex] == null) {
  94                 cache[cacheIndex] = mh;
  95             } else {
  96                 // Throw away newly constructed accessor and use cached version.
  97                 mh = cache[cacheIndex];
  98             }
  99         }
 100         return mh;
 101     }
 102 
 103     enum ArrayAccess {
 104         GET, SET, LENGTH;
 105 
 106         // As ArrayAccess and ArrayAccessor have a circular dependency, the ArrayAccess properties cannot be stored in
 107         // final fields.
 108 
 109         static String opName(ArrayAccess a) {
 110             switch (a) {
 111                 case GET: return &quot;getElement&quot;;
 112                 case SET: return &quot;setElement&quot;;
 113                 case LENGTH: return &quot;length&quot;;
 114             }
 115             throw unmatchedArrayAccess(a);
 116         }
 117 
 118         static MethodHandle objectAccessor(ArrayAccess a) {
 119             switch (a) {
 120                 case GET: return ArrayAccessor.OBJECT_ARRAY_GETTER;
 121                 case SET: return ArrayAccessor.OBJECT_ARRAY_SETTER;
 122                 case LENGTH: return ArrayAccessor.OBJECT_ARRAY_LENGTH;
 123             }
 124             throw unmatchedArrayAccess(a);
 125         }
 126 
 127         static int cacheIndex(ArrayAccess a) {
 128             switch (a) {
 129                 case GET: return ArrayAccessor.GETTER_INDEX;
 130                 case SET: return ArrayAccessor.SETTER_INDEX;
 131                 case LENGTH: return ArrayAccessor.LENGTH_INDEX;
 132             }
 133             throw unmatchedArrayAccess(a);
 134         }
 135 
 136         static Intrinsic intrinsic(ArrayAccess a) {
 137             switch (a) {
 138                 case GET: return Intrinsic.ARRAY_LOAD;
 139                 case SET: return Intrinsic.ARRAY_STORE;
 140                 case LENGTH: return Intrinsic.ARRAY_LENGTH;
 141             }
 142             throw unmatchedArrayAccess(a);
 143         }
 144     }
 145 
 146     static InternalError unmatchedArrayAccess(ArrayAccess a) {
 147         return newInternalError(&quot;should not reach here (unmatched ArrayAccess: &quot; + a + &quot;)&quot;);
 148     }
 149 
 150     static final class ArrayAccessor {
 151         /// Support for array element and length access
 152         static final int GETTER_INDEX = 0, SETTER_INDEX = 1, LENGTH_INDEX = 2, INDEX_LIMIT = 3;
 153         static final ClassValue&lt;MethodHandle[]&gt; TYPED_ACCESSORS
 154                 = new ClassValue&lt;MethodHandle[]&gt;() {
 155                     @Override
 156                     protected MethodHandle[] computeValue(Class&lt;?&gt; type) {
 157                         return new MethodHandle[INDEX_LIMIT];
 158                     }
 159                 };
 160         static final MethodHandle OBJECT_ARRAY_GETTER, OBJECT_ARRAY_SETTER, OBJECT_ARRAY_LENGTH;
 161         static {
 162             MethodHandle[] cache = TYPED_ACCESSORS.get(Object[].class);
 163             cache[GETTER_INDEX] = OBJECT_ARRAY_GETTER = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.GET),    Intrinsic.ARRAY_LOAD);
 164             cache[SETTER_INDEX] = OBJECT_ARRAY_SETTER = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.SET),    Intrinsic.ARRAY_STORE);
 165             cache[LENGTH_INDEX] = OBJECT_ARRAY_LENGTH = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.LENGTH), Intrinsic.ARRAY_LENGTH);
 166 
 167             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_GETTER.internalMemberName()));
 168             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_SETTER.internalMemberName()));
 169             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_LENGTH.internalMemberName()));
 170         }
 171 
 172         static int     getElementI(int[]     a, int i)            { return              a[i]; }
 173         static long    getElementJ(long[]    a, int i)            { return              a[i]; }
 174         static float   getElementF(float[]   a, int i)            { return              a[i]; }
 175         static double  getElementD(double[]  a, int i)            { return              a[i]; }
 176         static boolean getElementZ(boolean[] a, int i)            { return              a[i]; }
 177         static byte    getElementB(byte[]    a, int i)            { return              a[i]; }
 178         static short   getElementS(short[]   a, int i)            { return              a[i]; }
 179         static char    getElementC(char[]    a, int i)            { return              a[i]; }
 180         static Object  getElementL(Object[]  a, int i)            { return              a[i]; }
 181 
 182         static void    setElementI(int[]     a, int i, int     x) {              a[i] = x; }
 183         static void    setElementJ(long[]    a, int i, long    x) {              a[i] = x; }
 184         static void    setElementF(float[]   a, int i, float   x) {              a[i] = x; }
 185         static void    setElementD(double[]  a, int i, double  x) {              a[i] = x; }
 186         static void    setElementZ(boolean[] a, int i, boolean x) {              a[i] = x; }
 187         static void    setElementB(byte[]    a, int i, byte    x) {              a[i] = x; }
 188         static void    setElementS(short[]   a, int i, short   x) {              a[i] = x; }
 189         static void    setElementC(char[]    a, int i, char    x) {              a[i] = x; }
 190         static void    setElementL(Object[]  a, int i, Object  x) {              a[i] = x; }
 191 
 192         static int     lengthI(int[]     a)                       { return a.length; }
 193         static int     lengthJ(long[]    a)                       { return a.length; }
 194         static int     lengthF(float[]   a)                       { return a.length; }
 195         static int     lengthD(double[]  a)                       { return a.length; }
 196         static int     lengthZ(boolean[] a)                       { return a.length; }
 197         static int     lengthB(byte[]    a)                       { return a.length; }
 198         static int     lengthS(short[]   a)                       { return a.length; }
 199         static int     lengthC(char[]    a)                       { return a.length; }
 200         static int     lengthL(Object[]  a)                       { return a.length; }
 201 
 202         static String name(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 203             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 204             if (elemClass == null)  throw newIllegalArgumentException(&quot;not an array&quot;, arrayClass);
 205             return ArrayAccess.opName(access) + Wrapper.basicTypeChar(elemClass);
 206         }
 207         static MethodType type(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 208             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 209             Class&lt;?&gt; arrayArgClass = arrayClass;
 210             if (!elemClass.isPrimitive()) {
 211                 arrayArgClass = Object[].class;
 212                 elemClass = Object.class;
 213             }
 214             switch (access) {
 215                 case GET:    return MethodType.methodType(elemClass,  arrayArgClass, int.class);
 216                 case SET:    return MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);
 217                 case LENGTH: return MethodType.methodType(int.class,  arrayArgClass);
 218             }
 219             throw unmatchedArrayAccess(access);
 220         }
 221         static MethodType correctType(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 222             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 223             switch (access) {
 224                 case GET:    return MethodType.methodType(elemClass,  arrayClass, int.class);
 225                 case SET:    return MethodType.methodType(void.class, arrayClass, int.class, elemClass);
 226                 case LENGTH: return MethodType.methodType(int.class,  arrayClass);
 227             }
 228             throw unmatchedArrayAccess(access);
 229         }
 230         static MethodHandle getAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 231             String     name = name(arrayClass, access);
 232             MethodType type = type(arrayClass, access);
 233             try {
 234                 return IMPL_LOOKUP.findStatic(ArrayAccessor.class, name, type);
 235             } catch (ReflectiveOperationException ex) {
 236                 throw uncaughtException(ex);
 237             }
 238         }
 239     }
 240 
 241     /**
 242      * Create a JVM-level adapter method handle to conform the given method
 243      * handle to the similar newType, using only pairwise argument conversions.
 244      * For each argument, convert incoming argument to the exact type needed.
 245      * The argument conversions allowed are casting, boxing and unboxing,
 246      * integral widening or narrowing, and floating point widening or narrowing.
 247      * @param srcType required call type
 248      * @param target original method handle
 249      * @param strict if true, only asType conversions are allowed; if false, explicitCastArguments conversions allowed
 250      * @param monobox if true, unboxing conversions are assumed to be exactly typed (Integer to int only, not long or double)
 251      * @return an adapter to the original handle with the desired new type,
 252      *          or the original target if the types are already identical
 253      *          or null if the adaptation cannot be made
 254      */
 255     static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType,
 256                                             boolean strict, boolean monobox) {
 257         MethodType dstType = target.type();
 258         if (srcType == dstType)
 259             return target;
 260         return makePairwiseConvertByEditor(target, srcType, strict, monobox);
 261     }
 262 
 263     private static int countNonNull(Object[] array) {
 264         int count = 0;
 265         if (array != null) {
 266             for (Object x : array) {
 267                 if (x != null) ++count;
 268             }
 269         }
 270         return count;
 271     }
 272 
 273     static MethodHandle makePairwiseConvertByEditor(MethodHandle target, MethodType srcType,
 274                                                     boolean strict, boolean monobox) {
 275         // In method types arguments start at index 0, while the LF
 276         // editor have the MH receiver at position 0 - adjust appropriately.
 277         final int MH_RECEIVER_OFFSET = 1;
 278         Object[] convSpecs = computeValueConversions(srcType, target.type(), strict, monobox);
 279         int convCount = countNonNull(convSpecs);
 280         if (convCount == 0)
 281             return target.viewAsType(srcType, strict);
 282         MethodType basicSrcType = srcType.basicType();
 283         MethodType midType = target.type().basicType();
 284         BoundMethodHandle mh = target.rebind();
 285 
 286         // Match each unique conversion to the positions at which it is to be applied
 287         var convSpecMap = new HashMap&lt;Object, int[]&gt;(((4 * convCount) / 3) + 1);
 288         for (int i = 0; i &lt; convSpecs.length - MH_RECEIVER_OFFSET; i++) {
 289             Object convSpec = convSpecs[i];
 290             if (convSpec == null) continue;
 291             int[] positions = convSpecMap.get(convSpec);
 292             if (positions == null) {
 293                 positions = new int[] { i + MH_RECEIVER_OFFSET };
 294             } else {
 295                 positions = Arrays.copyOf(positions, positions.length + 1);
 296                 positions[positions.length - 1] = i + MH_RECEIVER_OFFSET;
 297             }
 298             convSpecMap.put(convSpec, positions);
 299         }
 300         for (var entry : convSpecMap.entrySet()) {
 301             Object convSpec = entry.getKey();
 302 
 303             MethodHandle fn;
 304             if (convSpec instanceof Class) {
 305                 fn = getConstantHandle(MH_cast).bindTo(convSpec);
 306             } else {
 307                 fn = (MethodHandle) convSpec;
 308             }
 309             int[] positions = entry.getValue();
 310             Class&lt;?&gt; newType = basicSrcType.parameterType(positions[0] - MH_RECEIVER_OFFSET);
 311             BasicType newBasicType = BasicType.basicType(newType);
 312             convCount -= positions.length;
 313             if (convCount == 0) {
 314                 midType = srcType;
 315             } else {
 316                 Class&lt;?&gt;[] ptypes = midType.ptypes().clone();
 317                 for (int pos : positions) {
 318                     ptypes[pos - 1] = newType;
 319                 }
 320                 midType = MethodType.makeImpl(midType.rtype(), ptypes, true);
 321             }
 322             LambdaForm form2;
 323             if (positions.length &gt; 1) {
 324                 form2 = mh.editor().filterRepeatedArgumentForm(newBasicType, positions);
 325             } else {
 326                 form2 = mh.editor().filterArgumentForm(positions[0], newBasicType);
 327             }
 328             mh = mh.copyWithExtendL(midType, form2, fn);
 329         }
 330         Object convSpec = convSpecs[convSpecs.length - 1];
 331         if (convSpec != null) {
 332             MethodHandle fn;
 333             if (convSpec instanceof Class) {
 334                 if (convSpec == void.class)
 335                     fn = null;
 336                 else
 337                     fn = getConstantHandle(MH_cast).bindTo(convSpec);
 338             } else {
 339                 fn = (MethodHandle) convSpec;
 340             }
 341             Class&lt;?&gt; newType = basicSrcType.returnType();
 342             assert(--convCount == 0);
 343             midType = srcType;
 344             if (fn != null) {
 345                 mh = mh.rebind();  // rebind if too complex
 346                 LambdaForm form2 = mh.editor().filterReturnForm(BasicType.basicType(newType), false);
 347                 mh = mh.copyWithExtendL(midType, form2, fn);
 348             } else {
 349                 LambdaForm form2 = mh.editor().filterReturnForm(BasicType.basicType(newType), true);
 350                 mh = mh.copyWith(midType, form2);
 351             }
 352         }
 353         assert(convCount == 0);
 354         assert(mh.type().equals(srcType));
 355         return mh;
 356     }
 357 
 358     static Object[] computeValueConversions(MethodType srcType, MethodType dstType,
 359                                             boolean strict, boolean monobox) {
 360         final int INARG_COUNT = srcType.parameterCount();
 361         Object[] convSpecs = null;
 362         for (int i = 0; i &lt;= INARG_COUNT; i++) {
 363             boolean isRet = (i == INARG_COUNT);
 364             Class&lt;?&gt; src = isRet ? dstType.returnType() : srcType.parameterType(i);
 365             Class&lt;?&gt; dst = isRet ? srcType.returnType() : dstType.parameterType(i);
 366             if (!VerifyType.isNullConversion(src, dst, /*keepInterfaces=*/ strict)) {
 367                 if (convSpecs == null) {
 368                     convSpecs = new Object[INARG_COUNT + 1];
 369                 }
 370                 convSpecs[i] = valueConversion(src, dst, strict, monobox);
 371             }
 372         }
 373         return convSpecs;
 374     }
 375     static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType,
 376                                             boolean strict) {
 377         return makePairwiseConvert(target, srcType, strict, /*monobox=*/ false);
 378     }
 379 
 380     /**
 381      * Find a conversion function from the given source to the given destination.
 382      * This conversion function will be used as a LF NamedFunction.
 383      * Return a Class object if a simple cast is needed.
 384      * Return void.class if void is involved.
 385      */
 386     static Object valueConversion(Class&lt;?&gt; src, Class&lt;?&gt; dst, boolean strict, boolean monobox) {
 387         assert(!VerifyType.isNullConversion(src, dst, /*keepInterfaces=*/ strict));  // caller responsibility
 388         if (dst == void.class)
 389             return dst;
 390         MethodHandle fn;
 391         if (src.isPrimitive()) {
 392             if (src == void.class) {
 393                 return void.class;  // caller must recognize this specially
 394             } else if (dst.isPrimitive()) {
 395                 // Examples: int-&gt;byte, byte-&gt;int, boolean-&gt;int (!strict)
 396                 fn = ValueConversions.convertPrimitive(src, dst);
 397             } else {
 398                 // Examples: int-&gt;Integer, boolean-&gt;Object, float-&gt;Number
 399                 Wrapper wsrc = Wrapper.forPrimitiveType(src);
 400                 fn = ValueConversions.boxExact(wsrc);
 401                 assert(fn.type().parameterType(0) == wsrc.primitiveType());
 402                 assert(fn.type().returnType() == wsrc.wrapperType());
 403                 if (!VerifyType.isNullConversion(wsrc.wrapperType(), dst, strict)) {
 404                     // Corner case, such as int-&gt;Long, which will probably fail.
 405                     MethodType mt = MethodType.methodType(dst, src);
 406                     if (strict)
 407                         fn = fn.asType(mt);
 408                     else
 409                         fn = MethodHandleImpl.makePairwiseConvert(fn, mt, /*strict=*/ false);
 410                 }
 411             }
 412         } else if (dst.isPrimitive()) {
 413             Wrapper wdst = Wrapper.forPrimitiveType(dst);
 414             if (monobox || src == wdst.wrapperType()) {
 415                 // Use a strongly-typed unboxer, if possible.
 416                 fn = ValueConversions.unboxExact(wdst, strict);
 417             } else {
 418                 // Examples:  Object-&gt;int, Number-&gt;int, Comparable-&gt;int, Byte-&gt;int
 419                 // must include additional conversions
 420                 // src must be examined at runtime, to detect Byte, Character, etc.
 421                 fn = (strict
 422                         ? ValueConversions.unboxWiden(wdst)
 423                         : ValueConversions.unboxCast(wdst));
 424             }
 425         } else {
 426             // Simple reference conversion.
 427             // Note:  Do not check for a class hierarchy relation
 428             // between src and dst.  In all cases a &#39;null&#39; argument
 429             // will pass the cast conversion.
 430             return dst;
 431         }
 432         assert(fn.type().parameterCount() &lt;= 1) : &quot;pc&quot;+Arrays.asList(src.getSimpleName(), dst.getSimpleName(), fn);
 433         return fn;
 434     }
 435 
 436     static MethodHandle makeVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {
 437         MethodType type = target.type();
 438         int last = type.parameterCount() - 1;
 439         if (type.parameterType(last) != arrayType)
 440             target = target.asType(type.changeParameterType(last, arrayType));
 441         target = target.asFixedArity();  // make sure this attribute is turned off
 442         return new AsVarargsCollector(target, arrayType);
 443     }
 444 
 445     private static final class AsVarargsCollector extends DelegatingMethodHandle {
 446         private final MethodHandle target;
 447         private final Class&lt;?&gt; arrayType;
 448         private @Stable MethodHandle asCollectorCache;
 449 
 450         AsVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {
 451             this(target.type(), target, arrayType);
 452         }
 453         AsVarargsCollector(MethodType type, MethodHandle target, Class&lt;?&gt; arrayType) {
 454             super(type, target);
 455             this.target = target;
 456             this.arrayType = arrayType;
 457         }
 458 
 459         @Override
 460         public boolean isVarargsCollector() {
 461             return true;
 462         }
 463 
 464         @Override
 465         protected MethodHandle getTarget() {
 466             return target;
 467         }
 468 
 469         @Override
 470         public MethodHandle asFixedArity() {
 471             return target;
 472         }
 473 
 474         @Override
 475         MethodHandle setVarargs(MemberName member) {
 476             if (member.isVarargs())  return this;
 477             return asFixedArity();
 478         }
 479 
 480         @Override
 481         public MethodHandle withVarargs(boolean makeVarargs) {
 482             if (makeVarargs)  return this;
 483             return asFixedArity();
 484         }
 485 
 486         @Override
 487         public MethodHandle asTypeUncached(MethodType newType) {
 488             MethodType type = this.type();
 489             int collectArg = type.parameterCount() - 1;
 490             int newArity = newType.parameterCount();
 491             if (newArity == collectArg+1 &amp;&amp;
 492                 type.parameterType(collectArg).isAssignableFrom(newType.parameterType(collectArg))) {
 493                 // if arity and trailing parameter are compatible, do normal thing
 494                 return asTypeCache = asFixedArity().asType(newType);
 495             }
 496             // check cache
 497             MethodHandle acc = asCollectorCache;
 498             if (acc != null &amp;&amp; acc.type().parameterCount() == newArity)
 499                 return asTypeCache = acc.asType(newType);
 500             // build and cache a collector
 501             int arrayLength = newArity - collectArg;
 502             MethodHandle collector;
 503             try {
 504                 collector = asFixedArity().asCollector(arrayType, arrayLength);
 505                 assert(collector.type().parameterCount() == newArity) : &quot;newArity=&quot;+newArity+&quot; but collector=&quot;+collector;
 506             } catch (IllegalArgumentException ex) {
 507                 throw new WrongMethodTypeException(&quot;cannot build collector&quot;, ex);
 508             }
 509             asCollectorCache = collector;
 510             return asTypeCache = collector.asType(newType);
 511         }
 512 
 513         @Override
 514         boolean viewAsTypeChecks(MethodType newType, boolean strict) {
 515             super.viewAsTypeChecks(newType, true);
 516             if (strict) return true;
 517             // extra assertion for non-strict checks:
 518             assert (type().lastParameterType().getComponentType()
 519                     .isAssignableFrom(
 520                             newType.lastParameterType().getComponentType()))
 521                     : Arrays.asList(this, newType);
 522             return true;
 523         }
 524 
 525         @Override
 526         public Object invokeWithArguments(Object... arguments) throws Throwable {
 527             MethodType type = this.type();
 528             int argc;
 529             final int MAX_SAFE = 127;  // 127 longs require 254 slots, which is safe to spread
 530             if (arguments == null
 531                     || (argc = arguments.length) &lt;= MAX_SAFE
 532                     || argc &lt; type.parameterCount()) {
 533                 return super.invokeWithArguments(arguments);
 534             }
 535 
 536             // a jumbo invocation requires more explicit reboxing of the trailing arguments
 537             int uncollected = type.parameterCount() - 1;
 538             Class&lt;?&gt; elemType = arrayType.getComponentType();
 539             int collected = argc - uncollected;
 540             Object collArgs = (elemType == Object.class)
 541                 ? new Object[collected] : Array.newInstance(elemType, collected);
 542             if (!elemType.isPrimitive()) {
 543                 // simple cast:  just do some casting
 544                 try {
 545                     System.arraycopy(arguments, uncollected, collArgs, 0, collected);
 546                 } catch (ArrayStoreException ex) {
 547                     return super.invokeWithArguments(arguments);
 548                 }
 549             } else {
 550                 // corner case of flat array requires reflection (or specialized copy loop)
 551                 MethodHandle arraySetter = MethodHandles.arrayElementSetter(arrayType);
 552                 try {
 553                     for (int i = 0; i &lt; collected; i++) {
 554                         arraySetter.invoke(collArgs, i, arguments[uncollected + i]);
 555                     }
 556                 } catch (WrongMethodTypeException|ClassCastException ex) {
 557                     return super.invokeWithArguments(arguments);
 558                 }
 559             }
 560 
 561             // chop the jumbo list down to size and call in non-varargs mode
 562             Object[] newArgs = new Object[uncollected + 1];
 563             System.arraycopy(arguments, 0, newArgs, 0, uncollected);
 564             newArgs[uncollected] = collArgs;
 565             return asFixedArity().invokeWithArguments(newArgs);
 566         }
 567     }
 568 
 569     /** Factory method:  Spread selected argument. */
 570     static MethodHandle makeSpreadArguments(MethodHandle target,
 571                                             Class&lt;?&gt; spreadArgType, int spreadArgPos, int spreadArgCount) {
 572         MethodType targetType = target.type();
 573 
 574         for (int i = 0; i &lt; spreadArgCount; i++) {
 575             Class&lt;?&gt; arg = VerifyType.spreadArgElementType(spreadArgType, i);
 576             if (arg == null)  arg = Object.class;
 577             targetType = targetType.changeParameterType(spreadArgPos + i, arg);
 578         }
 579         target = target.asType(targetType);
 580 
 581         MethodType srcType = targetType
 582                 .replaceParameterTypes(spreadArgPos, spreadArgPos + spreadArgCount, spreadArgType);
 583         // Now build a LambdaForm.
 584         MethodType lambdaType = srcType.invokerType();
 585         Name[] names = arguments(spreadArgCount + 2, lambdaType);
 586         int nameCursor = lambdaType.parameterCount();
 587         int[] indexes = new int[targetType.parameterCount()];
 588 
 589         for (int i = 0, argIndex = 1; i &lt; targetType.parameterCount() + 1; i++, argIndex++) {
 590             Class&lt;?&gt; src = lambdaType.parameterType(i);
 591             if (i == spreadArgPos) {
 592                 // Spread the array.
 593                 MethodHandle aload = MethodHandles.arrayElementGetter(spreadArgType);
 594                 Name array = names[argIndex];
 595                 names[nameCursor++] = new Name(getFunction(NF_checkSpreadArgument), array, spreadArgCount);
 596                 for (int j = 0; j &lt; spreadArgCount; i++, j++) {
 597                     indexes[i] = nameCursor;
 598                     names[nameCursor++] = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), array, j);
 599                 }
 600             } else if (i &lt; indexes.length) {
 601                 indexes[i] = argIndex;
 602             }
 603         }
 604         assert(nameCursor == names.length-1);  // leave room for the final call
 605 
 606         // Build argument array for the call.
 607         Name[] targetArgs = new Name[targetType.parameterCount()];
 608         for (int i = 0; i &lt; targetType.parameterCount(); i++) {
 609             int idx = indexes[i];
 610             targetArgs[i] = names[idx];
 611         }
 612         names[names.length - 1] = new Name(target, (Object[]) targetArgs);
 613 
 614         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.SPREAD);
 615         return SimpleMethodHandle.make(srcType, form);
 616     }
 617 
 618     static void checkSpreadArgument(Object av, int n) {
 619         if (av == null &amp;&amp; n == 0) {
 620             return;
 621         } else if (av == null) {
 622             throw new NullPointerException(&quot;null array reference&quot;);
 623         } else if (av instanceof Object[]) {
 624             int len = ((Object[])av).length;
 625             if (len == n)  return;
 626         } else {
 627             int len = java.lang.reflect.Array.getLength(av);
 628             if (len == n)  return;
 629         }
 630         // fall through to error:
 631         throw newIllegalArgumentException(&quot;array is not of length &quot;+n);
 632     }
 633 
 634     /** Factory method:  Collect or filter selected argument(s). */
 635     static MethodHandle makeCollectArguments(MethodHandle target,
 636                 MethodHandle collector, int collectArgPos, boolean retainOriginalArgs) {
 637         MethodType targetType = target.type();          // (a..., c, [b...])=&gt;r
 638         MethodType collectorType = collector.type();    // (b...)=&gt;c
 639         int collectArgCount = collectorType.parameterCount();
 640         Class&lt;?&gt; collectValType = collectorType.returnType();
 641         int collectValCount = (collectValType == void.class ? 0 : 1);
 642         MethodType srcType = targetType                 // (a..., [b...])=&gt;r
 643                 .dropParameterTypes(collectArgPos, collectArgPos+collectValCount);
 644         if (!retainOriginalArgs) {                      // (a..., b...)=&gt;r
 645             srcType = srcType.insertParameterTypes(collectArgPos, collectorType.parameterArray());
 646         }
 647         // in  arglist: [0: ...keep1 | cpos: collect...  | cpos+cacount: keep2... ]
 648         // out arglist: [0: ...keep1 | cpos: collectVal? | cpos+cvcount: keep2... ]
 649         // out(retain): [0: ...keep1 | cpos: cV? coll... | cpos+cvc+cac: keep2... ]
 650 
 651         // Now build a LambdaForm.
 652         MethodType lambdaType = srcType.invokerType();
 653         Name[] names = arguments(2, lambdaType);
 654         final int collectNamePos = names.length - 2;
 655         final int targetNamePos  = names.length - 1;
 656 
 657         Name[] collectorArgs = Arrays.copyOfRange(names, 1 + collectArgPos, 1 + collectArgPos + collectArgCount);
 658         names[collectNamePos] = new Name(collector, (Object[]) collectorArgs);
 659 
 660         // Build argument array for the target.
 661         // Incoming LF args to copy are: [ (mh) headArgs collectArgs tailArgs ].
 662         // Output argument array is [ headArgs (collectVal)? (collectArgs)? tailArgs ].
 663         Name[] targetArgs = new Name[targetType.parameterCount()];
 664         int inputArgPos  = 1;  // incoming LF args to copy to target
 665         int targetArgPos = 0;  // fill pointer for targetArgs
 666         int chunk = collectArgPos;  // |headArgs|
 667         System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 668         inputArgPos  += chunk;
 669         targetArgPos += chunk;
 670         if (collectValType != void.class) {
 671             targetArgs[targetArgPos++] = names[collectNamePos];
 672         }
 673         chunk = collectArgCount;
 674         if (retainOriginalArgs) {
 675             System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 676             targetArgPos += chunk;   // optionally pass on the collected chunk
 677         }
 678         inputArgPos += chunk;
 679         chunk = targetArgs.length - targetArgPos;  // all the rest
 680         System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 681         assert(inputArgPos + chunk == collectNamePos);  // use of rest of input args also
 682         names[targetNamePos] = new Name(target, (Object[]) targetArgs);
 683 
 684         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);
 685         return SimpleMethodHandle.make(srcType, form);
 686     }
 687 
 688     @Hidden
 689     static MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {
 690         if (testResult) {
 691             return target;
 692         } else {
 693             return fallback;
 694         }
 695     }
 696 
 697     // Intrinsified by C2. Counters are used during parsing to calculate branch frequencies.
 698     @Hidden
 699     @jdk.internal.HotSpotIntrinsicCandidate
 700     static boolean profileBoolean(boolean result, int[] counters) {
 701         // Profile is int[2] where [0] and [1] correspond to false and true occurrences respectively.
 702         int idx = result ? 1 : 0;
 703         try {
 704             counters[idx] = Math.addExact(counters[idx], 1);
 705         } catch (ArithmeticException e) {
 706             // Avoid continuous overflow by halving the problematic count.
 707             counters[idx] = counters[idx] / 2;
 708         }
 709         return result;
 710     }
 711 
 712     // Intrinsified by C2. Returns true if obj is a compile-time constant.
 713     @Hidden
 714     @jdk.internal.HotSpotIntrinsicCandidate
 715     static boolean isCompileConstant(Object obj) {
 716         return false;
 717     }
 718 
 719     static MethodHandle makeGuardWithTest(MethodHandle test,
 720                                    MethodHandle target,
 721                                    MethodHandle fallback) {
 722         MethodType type = target.type();
 723         assert(test.type().equals(type.changeReturnType(boolean.class)) &amp;&amp; fallback.type().equals(type));
 724         MethodType basicType = type.basicType();
 725         LambdaForm form = makeGuardWithTestForm(basicType);
 726         BoundMethodHandle mh;
 727         try {
 728             if (PROFILE_GWT) {
 729                 int[] counts = new int[2];
 730                 mh = (BoundMethodHandle)
 731                         BoundMethodHandle.speciesData_LLLL().factory().invokeBasic(type, form,
 732                                 (Object) test, (Object) profile(target), (Object) profile(fallback), counts);
 733             } else {
 734                 mh = (BoundMethodHandle)
 735                         BoundMethodHandle.speciesData_LLL().factory().invokeBasic(type, form,
 736                                 (Object) test, (Object) profile(target), (Object) profile(fallback));
 737             }
 738         } catch (Throwable ex) {
 739             throw uncaughtException(ex);
 740         }
 741         assert(mh.type() == type);
 742         return mh;
 743     }
 744 
 745 
 746     static MethodHandle profile(MethodHandle target) {
 747         if (DONT_INLINE_THRESHOLD &gt;= 0) {
 748             return makeBlockInliningWrapper(target);
 749         } else {
 750             return target;
 751         }
 752     }
 753 
 754     /**
 755      * Block inlining during JIT-compilation of a target method handle if it hasn&#39;t been invoked enough times.
 756      * Corresponding LambdaForm has @DontInline when compiled into bytecode.
 757      */
 758     static MethodHandle makeBlockInliningWrapper(MethodHandle target) {
 759         LambdaForm lform;
 760         if (DONT_INLINE_THRESHOLD &gt; 0) {
 761             lform = Makers.PRODUCE_BLOCK_INLINING_FORM.apply(target);
 762         } else {
 763             lform = Makers.PRODUCE_REINVOKER_FORM.apply(target);
 764         }
 765         return new CountingWrapper(target, lform,
 766                 Makers.PRODUCE_BLOCK_INLINING_FORM, Makers.PRODUCE_REINVOKER_FORM,
 767                                    DONT_INLINE_THRESHOLD);
 768     }
 769 
 770     private final static class Makers {
 771         /** Constructs reinvoker lambda form which block inlining during JIT-compilation for a particular method handle */
 772         static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_BLOCK_INLINING_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
 773             @Override
 774             public LambdaForm apply(MethodHandle target) {
 775                 return DelegatingMethodHandle.makeReinvokerForm(target,
 776                                    MethodTypeForm.LF_DELEGATE_BLOCK_INLINING, CountingWrapper.class, false,
 777                                    DelegatingMethodHandle.NF_getTarget, CountingWrapper.NF_maybeStopCounting);
 778             }
 779         };
 780 
 781         /** Constructs simple reinvoker lambda form for a particular method handle */
 782         static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_REINVOKER_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
 783             @Override
 784             public LambdaForm apply(MethodHandle target) {
 785                 return DelegatingMethodHandle.makeReinvokerForm(target,
 786                         MethodTypeForm.LF_DELEGATE, DelegatingMethodHandle.class, DelegatingMethodHandle.NF_getTarget);
 787             }
 788         };
 789 
 790         /** Maker of type-polymorphic varargs */
 791         static final ClassValue&lt;MethodHandle[]&gt; TYPED_COLLECTORS = new ClassValue&lt;MethodHandle[]&gt;() {
 792             @Override
 793             protected MethodHandle[] computeValue(Class&lt;?&gt; type) {
 794                 return new MethodHandle[MAX_JVM_ARITY + 1];
 795             }
 796         };
 797     }
 798 
 799     /**
 800      * Counting method handle. It has 2 states: counting and non-counting.
 801      * It is in counting state for the first n invocations and then transitions to non-counting state.
 802      * Behavior in counting and non-counting states is determined by lambda forms produced by
 803      * countingFormProducer &amp; nonCountingFormProducer respectively.
 804      */
 805     static class CountingWrapper extends DelegatingMethodHandle {
 806         private final MethodHandle target;
 807         private int count;
 808         private Function&lt;MethodHandle, LambdaForm&gt; countingFormProducer;
 809         private Function&lt;MethodHandle, LambdaForm&gt; nonCountingFormProducer;
 810         private volatile boolean isCounting;
 811 
 812         private CountingWrapper(MethodHandle target, LambdaForm lform,
 813                                 Function&lt;MethodHandle, LambdaForm&gt; countingFromProducer,
 814                                 Function&lt;MethodHandle, LambdaForm&gt; nonCountingFormProducer,
 815                                 int count) {
 816             super(target.type(), lform);
 817             this.target = target;
 818             this.count = count;
 819             this.countingFormProducer = countingFromProducer;
 820             this.nonCountingFormProducer = nonCountingFormProducer;
 821             this.isCounting = (count &gt; 0);
 822         }
 823 
 824         @Hidden
 825         @Override
 826         protected MethodHandle getTarget() {
 827             return target;
 828         }
 829 
 830         @Override
 831         public MethodHandle asTypeUncached(MethodType newType) {
 832             MethodHandle newTarget = target.asType(newType);
 833             MethodHandle wrapper;
 834             if (isCounting) {
 835                 LambdaForm lform;
 836                 lform = countingFormProducer.apply(newTarget);
 837                 wrapper = new CountingWrapper(newTarget, lform, countingFormProducer, nonCountingFormProducer, DONT_INLINE_THRESHOLD);
 838             } else {
 839                 wrapper = newTarget; // no need for a counting wrapper anymore
 840             }
 841             return (asTypeCache = wrapper);
 842         }
 843 
 844         // Customize target if counting happens for too long.
 845         private int invocations = CUSTOMIZE_THRESHOLD;
 846         private void maybeCustomizeTarget() {
 847             int c = invocations;
 848             if (c &gt;= 0) {
 849                 if (c == 1) {
 850                     target.customize();
 851                 }
 852                 invocations = c - 1;
 853             }
 854         }
 855 
 856         boolean countDown() {
 857             int c = count;
 858             maybeCustomizeTarget();
 859             if (c &lt;= 1) {
 860                 // Try to limit number of updates. MethodHandle.updateForm() doesn&#39;t guarantee LF update visibility.
 861                 if (isCounting) {
 862                     isCounting = false;
 863                     return true;
 864                 } else {
 865                     return false;
 866                 }
 867             } else {
 868                 count = c - 1;
 869                 return false;
 870             }
 871         }
 872 
 873         @Hidden
 874         static void maybeStopCounting(Object o1) {
 875              CountingWrapper wrapper = (CountingWrapper) o1;
 876              if (wrapper.countDown()) {
 877                  // Reached invocation threshold. Replace counting behavior with a non-counting one.
 878                  LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);
 879                  lform.compileToBytecode(); // speed up warmup by avoiding LF interpretation again after transition
 880                  wrapper.updateForm(lform);
 881              }
 882         }
 883 
 884         static final NamedFunction NF_maybeStopCounting;
 885         static {
 886             Class&lt;?&gt; THIS_CLASS = CountingWrapper.class;
 887             try {
 888                 NF_maybeStopCounting = new NamedFunction(THIS_CLASS.getDeclaredMethod(&quot;maybeStopCounting&quot;, Object.class));
 889             } catch (ReflectiveOperationException ex) {
 890                 throw newInternalError(ex);
 891             }
 892         }
 893     }
 894 
 895     static LambdaForm makeGuardWithTestForm(MethodType basicType) {
 896         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWT);
 897         if (lform != null)  return lform;
 898         final int THIS_MH      = 0;  // the BMH_LLL
 899         final int ARG_BASE     = 1;  // start of incoming arguments
 900         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
 901         int nameCursor = ARG_LIMIT;
 902         final int GET_TEST     = nameCursor++;
 903         final int GET_TARGET   = nameCursor++;
 904         final int GET_FALLBACK = nameCursor++;
 905         final int GET_COUNTERS = PROFILE_GWT ? nameCursor++ : -1;
 906         final int CALL_TEST    = nameCursor++;
 907         final int PROFILE      = (GET_COUNTERS != -1) ? nameCursor++ : -1;
 908         final int TEST         = nameCursor-1; // previous statement: either PROFILE or CALL_TEST
 909         final int SELECT_ALT   = nameCursor++;
 910         final int CALL_TARGET  = nameCursor++;
 911         assert(CALL_TARGET == SELECT_ALT+1);  // must be true to trigger IBG.emitSelectAlternative
 912 
 913         MethodType lambdaType = basicType.invokerType();
 914         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
 915 
 916         BoundMethodHandle.SpeciesData data =
 917                 (GET_COUNTERS != -1) ? BoundMethodHandle.speciesData_LLLL()
 918                                      : BoundMethodHandle.speciesData_LLL();
 919         names[THIS_MH] = names[THIS_MH].withConstraint(data);
 920         names[GET_TEST]     = new Name(data.getterFunction(0), names[THIS_MH]);
 921         names[GET_TARGET]   = new Name(data.getterFunction(1), names[THIS_MH]);
 922         names[GET_FALLBACK] = new Name(data.getterFunction(2), names[THIS_MH]);
 923         if (GET_COUNTERS != -1) {
 924             names[GET_COUNTERS] = new Name(data.getterFunction(3), names[THIS_MH]);
 925         }
 926         Object[] invokeArgs = Arrays.copyOfRange(names, 0, ARG_LIMIT, Object[].class);
 927 
 928         // call test
 929         MethodType testType = basicType.changeReturnType(boolean.class).basicType();
 930         invokeArgs[0] = names[GET_TEST];
 931         names[CALL_TEST] = new Name(testType, invokeArgs);
 932 
 933         // profile branch
 934         if (PROFILE != -1) {
 935             names[PROFILE] = new Name(getFunction(NF_profileBoolean), names[CALL_TEST], names[GET_COUNTERS]);
 936         }
 937         // call selectAlternative
 938         names[SELECT_ALT] = new Name(new NamedFunction(getConstantHandle(MH_selectAlternative), Intrinsic.SELECT_ALTERNATIVE), names[TEST], names[GET_TARGET], names[GET_FALLBACK]);
 939 
 940         // call target or fallback
 941         invokeArgs[0] = names[SELECT_ALT];
 942         names[CALL_TARGET] = new Name(basicType, invokeArgs);
 943 
 944         lform = new LambdaForm(lambdaType.parameterCount(), names, /*forceInline=*/true, Kind.GUARD);
 945 
 946         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWT, lform);
 947     }
 948 
 949     /**
 950      * The LambdaForm shape for catchException combinator is the following:
 951      * &lt;blockquote&gt;&lt;pre&gt;{@code
 952      *  guardWithCatch=Lambda(a0:L,a1:L,a2:L)=&gt;{
 953      *    t3:L=BoundMethodHandle$Species_LLLLL.argL0(a0:L);
 954      *    t4:L=BoundMethodHandle$Species_LLLLL.argL1(a0:L);
 955      *    t5:L=BoundMethodHandle$Species_LLLLL.argL2(a0:L);
 956      *    t6:L=BoundMethodHandle$Species_LLLLL.argL3(a0:L);
 957      *    t7:L=BoundMethodHandle$Species_LLLLL.argL4(a0:L);
 958      *    t8:L=MethodHandle.invokeBasic(t6:L,a1:L,a2:L);
 959      *    t9:L=MethodHandleImpl.guardWithCatch(t3:L,t4:L,t5:L,t8:L);
 960      *   t10:I=MethodHandle.invokeBasic(t7:L,t9:L);t10:I}
 961      * }&lt;/pre&gt;&lt;/blockquote&gt;
 962      *
 963      * argL0 and argL2 are target and catcher method handles. argL1 is exception class.
 964      * argL3 and argL4 are auxiliary method handles: argL3 boxes arguments and wraps them into Object[]
 965      * (ValueConversions.array()) and argL4 unboxes result if necessary (ValueConversions.unbox()).
 966      *
 967      * Having t8 and t10 passed outside and not hardcoded into a lambda form allows to share lambda forms
 968      * among catchException combinators with the same basic type.
 969      */
 970     private static LambdaForm makeGuardWithCatchForm(MethodType basicType) {
 971         MethodType lambdaType = basicType.invokerType();
 972 
 973         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWC);
 974         if (lform != null) {
 975             return lform;
 976         }
 977         final int THIS_MH      = 0;  // the BMH_LLLLL
 978         final int ARG_BASE     = 1;  // start of incoming arguments
 979         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
 980 
 981         int nameCursor = ARG_LIMIT;
 982         final int GET_TARGET       = nameCursor++;
 983         final int GET_CLASS        = nameCursor++;
 984         final int GET_CATCHER      = nameCursor++;
 985         final int GET_COLLECT_ARGS = nameCursor++;
 986         final int GET_UNBOX_RESULT = nameCursor++;
 987         final int BOXED_ARGS       = nameCursor++;
 988         final int TRY_CATCH        = nameCursor++;
 989         final int UNBOX_RESULT     = nameCursor++;
 990 
 991         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
 992 
 993         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
 994         names[THIS_MH]          = names[THIS_MH].withConstraint(data);
 995         names[GET_TARGET]       = new Name(data.getterFunction(0), names[THIS_MH]);
 996         names[GET_CLASS]        = new Name(data.getterFunction(1), names[THIS_MH]);
 997         names[GET_CATCHER]      = new Name(data.getterFunction(2), names[THIS_MH]);
 998         names[GET_COLLECT_ARGS] = new Name(data.getterFunction(3), names[THIS_MH]);
 999         names[GET_UNBOX_RESULT] = new Name(data.getterFunction(4), names[THIS_MH]);
1000 
1001         // FIXME: rework argument boxing/result unboxing logic for LF interpretation
1002 
1003         // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
1004         MethodType collectArgsType = basicType.changeReturnType(Object.class);
1005         MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
1006         Object[] args = new Object[invokeBasic.type().parameterCount()];
1007         args[0] = names[GET_COLLECT_ARGS];
1008         System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
1009         names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.GUARD_WITH_CATCH), args);
1010 
1011         // t_{i+1}:L=MethodHandleImpl.guardWithCatch(target:L,exType:L,catcher:L,t_{i}:L);
1012         Object[] gwcArgs = new Object[] {names[GET_TARGET], names[GET_CLASS], names[GET_CATCHER], names[BOXED_ARGS]};
1013         names[TRY_CATCH] = new Name(getFunction(NF_guardWithCatch), gwcArgs);
1014 
1015         // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
1016         MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
1017         Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_CATCH]};
1018         names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
1019 
1020         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.GUARD_WITH_CATCH);
1021 
1022         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWC, lform);
1023     }
1024 
1025     static MethodHandle makeGuardWithCatch(MethodHandle target,
1026                                     Class&lt;? extends Throwable&gt; exType,
1027                                     MethodHandle catcher) {
1028         MethodType type = target.type();
1029         LambdaForm form = makeGuardWithCatchForm(type.basicType());
1030 
1031         // Prepare auxiliary method handles used during LambdaForm interpretation.
1032         // Box arguments and wrap them into Object[]: ValueConversions.array().
1033         MethodType varargsType = type.changeReturnType(Object[].class);
1034         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
1035         MethodHandle unboxResult = unboxResultHandle(type.returnType());
1036 
1037         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
1038         BoundMethodHandle mh;
1039         try {
1040             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) exType,
1041                     (Object) catcher, (Object) collectArgs, (Object) unboxResult);
1042         } catch (Throwable ex) {
1043             throw uncaughtException(ex);
1044         }
1045         assert(mh.type() == type);
1046         return mh;
1047     }
1048 
1049     /**
1050      * Intrinsified during LambdaForm compilation
1051      * (see {@link InvokerBytecodeGenerator#emitGuardWithCatch emitGuardWithCatch}).
1052      */
1053     @Hidden
1054     static Object guardWithCatch(MethodHandle target, Class&lt;? extends Throwable&gt; exType, MethodHandle catcher,
1055                                  Object... av) throws Throwable {
1056         // Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
1057         try {
1058             return target.asFixedArity().invokeWithArguments(av);
1059         } catch (Throwable t) {
1060             if (!exType.isInstance(t)) throw t;
1061             return catcher.asFixedArity().invokeWithArguments(prepend(av, t));
1062         }
1063     }
1064 
1065     /** Prepend elements to an array. */
1066     @Hidden
1067     private static Object[] prepend(Object[] array, Object... elems) {
1068         int nArray = array.length;
1069         int nElems = elems.length;
1070         Object[] newArray = new Object[nArray + nElems];
1071         System.arraycopy(elems, 0, newArray, 0, nElems);
1072         System.arraycopy(array, 0, newArray, nElems, nArray);
1073         return newArray;
1074     }
1075 
1076     static MethodHandle throwException(MethodType type) {
1077         assert(Throwable.class.isAssignableFrom(type.parameterType(0)));
1078         int arity = type.parameterCount();
1079         if (arity &gt; 1) {
1080             MethodHandle mh = throwException(type.dropParameterTypes(1, arity));
1081             mh = MethodHandles.dropArguments(mh, 1, Arrays.copyOfRange(type.parameterArray(), 1, arity));
1082             return mh;
1083         }
1084         return makePairwiseConvert(getFunction(NF_throwException).resolvedHandle(), type, false, true);
1085     }
1086 
1087     static &lt;T extends Throwable&gt; Empty throwException(T t) throws T { throw t; }
1088 
1089     static MethodHandle[] FAKE_METHOD_HANDLE_INVOKE = new MethodHandle[2];
1090     static MethodHandle fakeMethodHandleInvoke(MemberName method) {
1091         int idx;
1092         assert(method.isMethodHandleInvoke());
1093         switch (method.getName()) {
1094         case &quot;invoke&quot;:       idx = 0; break;
1095         case &quot;invokeExact&quot;:  idx = 1; break;
1096         default:             throw new InternalError(method.getName());
1097         }
1098         MethodHandle mh = FAKE_METHOD_HANDLE_INVOKE[idx];
1099         if (mh != null)  return mh;
1100         MethodType type = MethodType.methodType(Object.class, UnsupportedOperationException.class,
1101                                                 MethodHandle.class, Object[].class);
1102         mh = throwException(type);
1103         mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke MethodHandle&quot;));
1104         if (!method.getInvocationType().equals(mh.type()))
1105             throw new InternalError(method.toString());
1106         mh = mh.withInternalMemberName(method, false);
1107         mh = mh.withVarargs(true);
1108         assert(method.isVarargs());
1109         FAKE_METHOD_HANDLE_INVOKE[idx] = mh;
1110         return mh;
1111     }
1112     static MethodHandle fakeVarHandleInvoke(MemberName method) {
1113         // TODO caching, is it necessary?
1114         MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,
1115                                                 VarHandle.class, Object[].class);
1116         MethodHandle mh = throwException(type);
1117         mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke VarHandle&quot;));
1118         if (!method.getInvocationType().equals(mh.type()))
1119             throw new InternalError(method.toString());
1120         mh = mh.withInternalMemberName(method, false);
1121         mh = mh.asVarargsCollector(Object[].class);
1122         assert(method.isVarargs());
1123         return mh;
1124     }
1125 
1126     /**
1127      * Create an alias for the method handle which, when called,
1128      * appears to be called from the same class loader and protection domain
1129      * as hostClass.
1130      * This is an expensive no-op unless the method which is called
1131      * is sensitive to its caller.  A small number of system methods
1132      * are in this category, including Class.forName and Method.invoke.
1133      */
1134     static MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
1135         return BindCaller.bindCaller(mh, hostClass);
1136     }
1137 
1138     // Put the whole mess into its own nested class.
1139     // That way we can lazily load the code and set up the constants.
1140     private static class BindCaller {
1141         private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
1142 
1143         static MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
1144             // Code in the boot layer should now be careful while creating method handles or
1145             // functional interface instances created from method references to @CallerSensitive  methods,
1146             // it needs to be ensured the handles or interface instances are kept safe and are not passed
1147             // from the boot layer to untrusted code.
1148             if (hostClass == null
1149                 ||    (hostClass.isArray() ||
1150                        hostClass.isPrimitive() ||
1151                        hostClass.getName().startsWith(&quot;java.lang.invoke.&quot;))) {
1152                 throw new InternalError();  // does not happen, and should not anyway
1153             }
1154             // For simplicity, convert mh to a varargs-like method.
1155             MethodHandle vamh = prepareForInvoker(mh);
1156             // Cache the result of makeInjectedInvoker once per argument class.
1157             MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);
1158             return restoreToType(bccInvoker.bindTo(vamh), mh, hostClass);
1159         }
1160 
1161         private static MethodHandle makeInjectedInvoker(Class&lt;?&gt; targetClass) {
1162             try {
1163                 /*
1164                  * The invoker class defined to the same class loader as the lookup class
1165                  * but in an unnamed package so that the class bytes can be cached and
1166                  * reused for any @CSM.
1167                  *
1168                  * @CSM must be public and exported if called by any module.
1169                  */
1170                 String name = targetClass.getName() + &quot;$$InjectedInvoker&quot;;
1171                 if (targetClass.isHidden()) {
1172                     // use the original class name
1173                     name = name.replace(&#39;/&#39;, &#39;_&#39;);
1174                 }
1175                 Class&lt;?&gt; invokerClass = new Lookup(targetClass)
1176                         .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE)
1177                         .defineClass(true);
1178                 assert checkInjectedInvoker(targetClass, invokerClass);
1179                 return IMPL_LOOKUP.findStatic(invokerClass, &quot;invoke_V&quot;, INVOKER_MT);
1180             } catch (ReflectiveOperationException ex) {
1181                 throw uncaughtException(ex);
1182             }
1183         }
1184 
1185         private static ClassValue&lt;MethodHandle&gt; CV_makeInjectedInvoker = new ClassValue&lt;MethodHandle&gt;() {
1186             @Override protected MethodHandle computeValue(Class&lt;?&gt; hostClass) {
1187                 return makeInjectedInvoker(hostClass);
1188             }
1189         };
1190 
1191         // Adapt mh so that it can be called directly from an injected invoker:
1192         private static MethodHandle prepareForInvoker(MethodHandle mh) {
1193             mh = mh.asFixedArity();
1194             MethodType mt = mh.type();
1195             int arity = mt.parameterCount();
1196             MethodHandle vamh = mh.asType(mt.generic());
1197             vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames
1198             vamh = vamh.asSpreader(Object[].class, arity);
1199             vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames
1200             return vamh;
1201         }
1202 
1203         // Undo the adapter effect of prepareForInvoker:
1204         private static MethodHandle restoreToType(MethodHandle vamh,
1205                                                   MethodHandle original,
1206                                                   Class&lt;?&gt; hostClass) {
1207             MethodType type = original.type();
1208             MethodHandle mh = vamh.asCollector(Object[].class, type.parameterCount());
1209             MemberName member = original.internalMemberName();
1210             mh = mh.asType(type);
1211             mh = new WrappedMember(mh, type, member, original.isInvokeSpecial(), hostClass);
1212             return mh;
1213         }
1214 
1215         private static boolean checkInjectedInvoker(Class&lt;?&gt; hostClass, Class&lt;?&gt; invokerClass) {
1216             assert (hostClass.getClassLoader() == invokerClass.getClassLoader()) : hostClass.getName()+&quot; (CL)&quot;;
1217             try {
1218                 assert (hostClass.getProtectionDomain() == invokerClass.getProtectionDomain()) : hostClass.getName()+&quot; (PD)&quot;;
1219             } catch (SecurityException ex) {
1220                 // Self-check was blocked by security manager. This is OK.
1221             }
1222             try {
1223                 // Test the invoker to ensure that it really injects into the right place.
1224                 MethodHandle invoker = IMPL_LOOKUP.findStatic(invokerClass, &quot;invoke_V&quot;, INVOKER_MT);
1225                 MethodHandle vamh = prepareForInvoker(MH_checkCallerClass);
1226                 return (boolean)invoker.invoke(vamh, new Object[]{ invokerClass });
1227             } catch (Throwable ex) {
1228                 throw new InternalError(ex);
1229             }
1230         }
1231 
1232         private static final MethodHandle MH_checkCallerClass;
1233         static {
1234             final Class&lt;?&gt; THIS_CLASS = BindCaller.class;
1235             assert(checkCallerClass(THIS_CLASS));
1236             try {
1237                 MH_checkCallerClass = IMPL_LOOKUP
1238                     .findStatic(THIS_CLASS, &quot;checkCallerClass&quot;,
1239                                 MethodType.methodType(boolean.class, Class.class));
1240                 assert((boolean) MH_checkCallerClass.invokeExact(THIS_CLASS));
1241             } catch (Throwable ex) {
1242                 throw new InternalError(ex);
1243             }
1244         }
1245 
1246         @CallerSensitive
1247         @ForceInline // to ensure Reflection.getCallerClass optimization
1248         private static boolean checkCallerClass(Class&lt;?&gt; expected) {
1249             // This method is called via MH_checkCallerClass and so it&#39;s correct to ask for the immediate caller here.
1250             Class&lt;?&gt; actual = Reflection.getCallerClass();
1251             if (actual != expected)
1252                 throw new InternalError(&quot;found &quot; + actual.getName() + &quot;, expected &quot; + expected.getName());
1253             return true;
1254         }
1255 
1256         private static final byte[] INJECTED_INVOKER_TEMPLATE = generateInvokerTemplate();
1257 
1258         /** Produces byte code for a class that is used as an injected invoker. */
1259         private static byte[] generateInvokerTemplate() {
1260             ClassWriter cw = new ClassWriter(0);
1261 
1262             // private static class InjectedInvoker {
1263             //     @Hidden
1264             //     static Object invoke_V(MethodHandle vamh, Object[] args) throws Throwable {
1265             //        return vamh.invokeExact(args);
1266             //     }
1267             // }
1268             cw.visit(52, ACC_PRIVATE | ACC_SUPER, &quot;InjectedInvoker&quot;, null, &quot;java/lang/Object&quot;, null);
1269 
1270             MethodVisitor mv = cw.visitMethod(ACC_STATIC, &quot;invoke_V&quot;,
1271                           &quot;(Ljava/lang/invoke/MethodHandle;[Ljava/lang/Object;)Ljava/lang/Object;&quot;,
1272                           null, null);
1273 
1274             mv.visitCode();
1275             mv.visitVarInsn(ALOAD, 0);
1276             mv.visitVarInsn(ALOAD, 1);
1277             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandle&quot;, &quot;invokeExact&quot;,
1278                                &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);
1279             mv.visitInsn(ARETURN);
1280             mv.visitMaxs(2, 2);
1281             mv.visitEnd();
1282 
1283             cw.visitEnd();
1284             return cw.toByteArray();
1285         }
1286     }
1287 
1288     /** This subclass allows a wrapped method handle to be re-associated with an arbitrary member name. */
1289     private static final class WrappedMember extends DelegatingMethodHandle {
1290         private final MethodHandle target;
1291         private final MemberName member;
1292         private final Class&lt;?&gt; callerClass;
1293         private final boolean isInvokeSpecial;
1294 
1295         private WrappedMember(MethodHandle target, MethodType type,
1296                               MemberName member, boolean isInvokeSpecial,
1297                               Class&lt;?&gt; callerClass) {
1298             super(type, target);
1299             this.target = target;
1300             this.member = member;
1301             this.callerClass = callerClass;
1302             this.isInvokeSpecial = isInvokeSpecial;
1303         }
1304 
1305         @Override
1306         MemberName internalMemberName() {
1307             return member;
1308         }
1309         @Override
1310         Class&lt;?&gt; internalCallerClass() {
1311             return callerClass;
1312         }
1313         @Override
1314         boolean isInvokeSpecial() {
1315             return isInvokeSpecial;
1316         }
1317         @Override
1318         protected MethodHandle getTarget() {
1319             return target;
1320         }
1321         @Override
1322         public MethodHandle asTypeUncached(MethodType newType) {
1323             // This MH is an alias for target, except for the MemberName
1324             // Drop the MemberName if there is any conversion.
1325             return asTypeCache = target.asType(newType);
1326         }
1327     }
1328 
1329     static MethodHandle makeWrappedMember(MethodHandle target, MemberName member, boolean isInvokeSpecial) {
1330         if (member.equals(target.internalMemberName()) &amp;&amp; isInvokeSpecial == target.isInvokeSpecial())
1331             return target;
1332         return new WrappedMember(target, target.type(), member, isInvokeSpecial, null);
1333     }
1334 
1335     /** Intrinsic IDs */
1336     /*non-public*/
1337     enum Intrinsic {
1338         SELECT_ALTERNATIVE,
1339         GUARD_WITH_CATCH,
1340         TRY_FINALLY,
1341         LOOP,
1342         NEW_ARRAY,
1343         ARRAY_LOAD,
1344         ARRAY_STORE,
1345         ARRAY_LENGTH,
1346         IDENTITY,
1347         ZERO,
1348         NONE // no intrinsic associated
1349     }
1350 
1351     /** Mark arbitrary method handle as intrinsic.
1352      * InvokerBytecodeGenerator uses this info to produce more efficient bytecode shape. */
1353     static final class IntrinsicMethodHandle extends DelegatingMethodHandle {
1354         private final MethodHandle target;
1355         private final Intrinsic intrinsicName;
1356 
1357         IntrinsicMethodHandle(MethodHandle target, Intrinsic intrinsicName) {
1358             super(target.type(), target);
1359             this.target = target;
1360             this.intrinsicName = intrinsicName;
1361         }
1362 
1363         @Override
1364         protected MethodHandle getTarget() {
1365             return target;
1366         }
1367 
1368         @Override
1369         Intrinsic intrinsicName() {
1370             return intrinsicName;
1371         }
1372 
1373         @Override
1374         public MethodHandle asTypeUncached(MethodType newType) {
1375             // This MH is an alias for target, except for the intrinsic name
1376             // Drop the name if there is any conversion.
1377             return asTypeCache = target.asType(newType);
1378         }
1379 
1380         @Override
1381         String internalProperties() {
1382             return super.internalProperties() +
1383                     &quot;\n&amp; Intrinsic=&quot;+intrinsicName;
1384         }
1385 
1386         @Override
1387         public MethodHandle asCollector(Class&lt;?&gt; arrayType, int arrayLength) {
1388             if (intrinsicName == Intrinsic.IDENTITY) {
1389                 MethodType resultType = type().asCollectorType(arrayType, type().parameterCount() - 1, arrayLength);
1390                 MethodHandle newArray = MethodHandleImpl.varargsArray(arrayType, arrayLength);
1391                 return newArray.asType(resultType);
1392             }
1393             return super.asCollector(arrayType, arrayLength);
1394         }
1395     }
1396 
1397     static MethodHandle makeIntrinsic(MethodHandle target, Intrinsic intrinsicName) {
1398         if (intrinsicName == target.intrinsicName())
1399             return target;
1400         return new IntrinsicMethodHandle(target, intrinsicName);
1401     }
1402 
1403     static MethodHandle makeIntrinsic(MethodType type, LambdaForm form, Intrinsic intrinsicName) {
1404         return new IntrinsicMethodHandle(SimpleMethodHandle.make(type, form), intrinsicName);
1405     }
1406 
1407     /// Collection of multiple arguments.
1408 
1409     private static MethodHandle findCollector(String name, int nargs, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
1410         MethodType type = MethodType.genericMethodType(nargs)
1411                 .changeReturnType(rtype)
1412                 .insertParameterTypes(0, ptypes);
1413         try {
1414             return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, name, type);
1415         } catch (ReflectiveOperationException ex) {
1416             return null;
1417         }
1418     }
1419 
1420     private static final Object[] NO_ARGS_ARRAY = {};
1421     private static Object[] makeArray(Object... args) { return args; }
1422     private static Object[] array() { return NO_ARGS_ARRAY; }
1423     private static Object[] array(Object a0)
1424                 { return makeArray(a0); }
1425     private static Object[] array(Object a0, Object a1)
1426                 { return makeArray(a0, a1); }
1427     private static Object[] array(Object a0, Object a1, Object a2)
1428                 { return makeArray(a0, a1, a2); }
1429     private static Object[] array(Object a0, Object a1, Object a2, Object a3)
1430                 { return makeArray(a0, a1, a2, a3); }
1431     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1432                                   Object a4)
1433                 { return makeArray(a0, a1, a2, a3, a4); }
1434     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1435                                   Object a4, Object a5)
1436                 { return makeArray(a0, a1, a2, a3, a4, a5); }
1437     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1438                                   Object a4, Object a5, Object a6)
1439                 { return makeArray(a0, a1, a2, a3, a4, a5, a6); }
1440     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1441                                   Object a4, Object a5, Object a6, Object a7)
1442                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7); }
1443     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1444                                   Object a4, Object a5, Object a6, Object a7,
1445                                   Object a8)
1446                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8); }
1447     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1448                                   Object a4, Object a5, Object a6, Object a7,
1449                                   Object a8, Object a9)
1450                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
1451 
1452     private static final int ARRAYS_COUNT = 11;
1453     private static final @Stable MethodHandle[] ARRAYS = new MethodHandle[MAX_ARITY + 1];
1454 
1455     // filling versions of the above:
1456     // using Integer len instead of int len and no varargs to avoid bootstrapping problems
1457     private static Object[] fillNewArray(Integer len, Object[] /*not ...*/ args) {
1458         Object[] a = new Object[len];
1459         fillWithArguments(a, 0, args);
1460         return a;
1461     }
1462     private static Object[] fillNewTypedArray(Object[] example, Integer len, Object[] /*not ...*/ args) {
1463         Object[] a = Arrays.copyOf(example, len);
1464         assert(a.getClass() != Object[].class);
1465         fillWithArguments(a, 0, args);
1466         return a;
1467     }
1468     private static void fillWithArguments(Object[] a, int pos, Object... args) {
1469         System.arraycopy(args, 0, a, pos, args.length);
1470     }
1471     // using Integer pos instead of int pos to avoid bootstrapping problems
1472     private static Object[] fillArray(Integer pos, Object[] a, Object a0)
1473                 { fillWithArguments(a, pos, a0); return a; }
1474     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1)
1475                 { fillWithArguments(a, pos, a0, a1); return a; }
1476     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2)
1477                 { fillWithArguments(a, pos, a0, a1, a2); return a; }
1478     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3)
1479                 { fillWithArguments(a, pos, a0, a1, a2, a3); return a; }
1480     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1481                                   Object a4)
1482                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4); return a; }
1483     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1484                                   Object a4, Object a5)
1485                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5); return a; }
1486     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1487                                   Object a4, Object a5, Object a6)
1488                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6); return a; }
1489     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1490                                   Object a4, Object a5, Object a6, Object a7)
1491                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7); return a; }
1492     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1493                                   Object a4, Object a5, Object a6, Object a7,
1494                                   Object a8)
1495                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8); return a; }
1496     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1497                                   Object a4, Object a5, Object a6, Object a7,
1498                                   Object a8, Object a9)
1499                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); return a; }
1500 
1501     private static final int FILL_ARRAYS_COUNT = 11; // current number of fillArray methods
1502     private static final @Stable MethodHandle[] FILL_ARRAYS = new MethodHandle[FILL_ARRAYS_COUNT];
1503 
1504     private static MethodHandle getFillArray(int count) {
1505         assert (count &gt; 0 &amp;&amp; count &lt; FILL_ARRAYS_COUNT);
1506         MethodHandle mh = FILL_ARRAYS[count];
1507         if (mh != null) {
1508             return mh;
1509         }
1510         mh = findCollector(&quot;fillArray&quot;, count, Object[].class, Integer.class, Object[].class);
1511         FILL_ARRAYS[count] = mh;
1512         return mh;
1513     }
1514 
1515     private static Object copyAsPrimitiveArray(Wrapper w, Object... boxes) {
1516         Object a = w.makeArray(boxes.length);
1517         w.copyArrayUnboxing(boxes, 0, a, 0, boxes.length);
1518         return a;
1519     }
1520 
1521     /** Return a method handle that takes the indicated number of Object
1522      *  arguments and returns an Object array of them, as if for varargs.
1523      */
1524     static MethodHandle varargsArray(int nargs) {
1525         MethodHandle mh = ARRAYS[nargs];
1526         if (mh != null) {
1527             return mh;
1528         }
1529         if (nargs &lt; ARRAYS_COUNT) {
1530             mh = findCollector(&quot;array&quot;, nargs, Object[].class);
1531         } else {
1532             mh = buildVarargsArray(getConstantHandle(MH_fillNewArray),
1533                     getConstantHandle(MH_arrayIdentity), nargs);
1534         }
1535         assert(assertCorrectArity(mh, nargs));
1536         mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
1537         return ARRAYS[nargs] = mh;
1538     }
1539 
1540     private static boolean assertCorrectArity(MethodHandle mh, int arity) {
1541         assert(mh.type().parameterCount() == arity) : &quot;arity != &quot;+arity+&quot;: &quot;+mh;
1542         return true;
1543     }
1544 
1545     // Array identity function (used as getConstantHandle(MH_arrayIdentity)).
1546     static &lt;T&gt; T[] identity(T[] x) {
1547         return x;
1548     }
1549 
1550     private static MethodHandle buildVarargsArray(MethodHandle newArray, MethodHandle finisher, int nargs) {
1551         // Build up the result mh as a sequence of fills like this:
1552         //   finisher(fill(fill(newArrayWA(23,x1..x10),10,x11..x20),20,x21..x23))
1553         // The various fill(_,10*I,___*[J]) are reusable.
1554         int leftLen = Math.min(nargs, LEFT_ARGS);  // absorb some arguments immediately
1555         int rightLen = nargs - leftLen;
1556         MethodHandle leftCollector = newArray.bindTo(nargs);
1557         leftCollector = leftCollector.asCollector(Object[].class, leftLen);
1558         MethodHandle mh = finisher;
1559         if (rightLen &gt; 0) {
1560             MethodHandle rightFiller = fillToRight(LEFT_ARGS + rightLen);
1561             if (mh.equals(getConstantHandle(MH_arrayIdentity)))
1562                 mh = rightFiller;
1563             else
1564                 mh = MethodHandles.collectArguments(mh, 0, rightFiller);
1565         }
1566         if (mh.equals(getConstantHandle(MH_arrayIdentity)))
1567             mh = leftCollector;
1568         else
1569             mh = MethodHandles.collectArguments(mh, 0, leftCollector);
1570         return mh;
1571     }
1572 
1573     private static final int LEFT_ARGS = FILL_ARRAYS_COUNT - 1;
1574     private static final @Stable MethodHandle[] FILL_ARRAY_TO_RIGHT = new MethodHandle[MAX_ARITY + 1];
1575     /** fill_array_to_right(N).invoke(a, argL..arg[N-1])
1576      *  fills a[L]..a[N-1] with corresponding arguments,
1577      *  and then returns a.  The value L is a global constant (LEFT_ARGS).
1578      */
1579     private static MethodHandle fillToRight(int nargs) {
1580         MethodHandle filler = FILL_ARRAY_TO_RIGHT[nargs];
1581         if (filler != null)  return filler;
1582         filler = buildFiller(nargs);
1583         assert(assertCorrectArity(filler, nargs - LEFT_ARGS + 1));
1584         return FILL_ARRAY_TO_RIGHT[nargs] = filler;
1585     }
1586     private static MethodHandle buildFiller(int nargs) {
1587         if (nargs &lt;= LEFT_ARGS)
1588             return getConstantHandle(MH_arrayIdentity);  // no args to fill; return the array unchanged
1589         // we need room for both mh and a in mh.invoke(a, arg*[nargs])
1590         final int CHUNK = LEFT_ARGS;
1591         int rightLen = nargs % CHUNK;
1592         int midLen = nargs - rightLen;
1593         if (rightLen == 0) {
1594             midLen = nargs - (rightLen = CHUNK);
1595             if (FILL_ARRAY_TO_RIGHT[midLen] == null) {
1596                 // build some precursors from left to right
1597                 for (int j = LEFT_ARGS % CHUNK; j &lt; midLen; j += CHUNK)
1598                     if (j &gt; LEFT_ARGS)  fillToRight(j);
1599             }
1600         }
1601         if (midLen &lt; LEFT_ARGS) rightLen = nargs - (midLen = LEFT_ARGS);
1602         assert(rightLen &gt; 0);
1603         MethodHandle midFill = fillToRight(midLen);  // recursive fill
1604         MethodHandle rightFill = getFillArray(rightLen).bindTo(midLen);  // [midLen..nargs-1]
1605         assert(midFill.type().parameterCount()   == 1 + midLen - LEFT_ARGS);
1606         assert(rightFill.type().parameterCount() == 1 + rightLen);
1607 
1608         // Combine the two fills:
1609         //   right(mid(a, x10..x19), x20..x23)
1610         // The final product will look like this:
1611         //   right(mid(newArrayLeft(24, x0..x9), x10..x19), x20..x23)
1612         if (midLen == LEFT_ARGS)
1613             return rightFill;
1614         else
1615             return MethodHandles.collectArguments(rightFill, 0, midFill);
1616     }
1617 
1618     static final int MAX_JVM_ARITY = 255;  // limit imposed by the JVM
1619 
1620     /** Return a method handle that takes the indicated number of
1621      *  typed arguments and returns an array of them.
1622      *  The type argument is the array type.
1623      */
1624     static MethodHandle varargsArray(Class&lt;?&gt; arrayType, int nargs) {
1625         Class&lt;?&gt; elemType = arrayType.getComponentType();
1626         if (elemType == null)  throw new IllegalArgumentException(&quot;not an array: &quot;+arrayType);
1627         // FIXME: Need more special casing and caching here.
1628         if (nargs &gt;= MAX_JVM_ARITY/2 - 1) {
1629             int slots = nargs;
1630             final int MAX_ARRAY_SLOTS = MAX_JVM_ARITY - 1;  // 1 for receiver MH
1631             if (slots &lt;= MAX_ARRAY_SLOTS &amp;&amp; elemType.isPrimitive())
1632                 slots *= Wrapper.forPrimitiveType(elemType).stackSlots();
1633             if (slots &gt; MAX_ARRAY_SLOTS)
1634                 throw new IllegalArgumentException(&quot;too many arguments: &quot;+arrayType.getSimpleName()+&quot;, length &quot;+nargs);
1635         }
1636         if (elemType == Object.class)
1637             return varargsArray(nargs);
1638         // other cases:  primitive arrays, subtypes of Object[]
1639         MethodHandle cache[] = Makers.TYPED_COLLECTORS.get(elemType);
1640         MethodHandle mh = nargs &lt; cache.length ? cache[nargs] : null;
1641         if (mh != null)  return mh;
1642         if (nargs == 0) {
1643             Object example = java.lang.reflect.Array.newInstance(arrayType.getComponentType(), 0);
1644             mh = MethodHandles.constant(arrayType, example);
1645         } else if (elemType.isPrimitive()) {
1646             MethodHandle builder = getConstantHandle(MH_fillNewArray);
1647             MethodHandle producer = buildArrayProducer(arrayType);
1648             mh = buildVarargsArray(builder, producer, nargs);
1649         } else {
1650             Class&lt;? extends Object[]&gt; objArrayType = arrayType.asSubclass(Object[].class);
1651             Object[] example = Arrays.copyOf(NO_ARGS_ARRAY, 0, objArrayType);
1652             MethodHandle builder = getConstantHandle(MH_fillNewTypedArray).bindTo(example);
1653             MethodHandle producer = getConstantHandle(MH_arrayIdentity); // must be weakly typed
1654             mh = buildVarargsArray(builder, producer, nargs);
1655         }
1656         mh = mh.asType(MethodType.methodType(arrayType, Collections.&lt;Class&lt;?&gt;&gt;nCopies(nargs, elemType)));
1657         mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
1658         assert(assertCorrectArity(mh, nargs));
1659         if (nargs &lt; cache.length)
1660             cache[nargs] = mh;
1661         return mh;
1662     }
1663 
1664     private static MethodHandle buildArrayProducer(Class&lt;?&gt; arrayType) {
1665         Class&lt;?&gt; elemType = arrayType.getComponentType();
1666         assert(elemType.isPrimitive());
1667         return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));
1668     }
1669 
1670     /*non-public*/
1671     static void assertSame(Object mh1, Object mh2) {
1672         if (mh1 != mh2) {
1673             String msg = String.format(&quot;mh1 != mh2: mh1 = %s (form: %s); mh2 = %s (form: %s)&quot;,
1674                     mh1, ((MethodHandle)mh1).form,
1675                     mh2, ((MethodHandle)mh2).form);
1676             throw newInternalError(msg);
1677         }
1678     }
1679 
1680     // Local constant functions:
1681 
1682     /* non-public */
1683     static final byte NF_checkSpreadArgument = 0,
1684             NF_guardWithCatch = 1,
1685             NF_throwException = 2,
1686             NF_tryFinally = 3,
1687             NF_loop = 4,
1688             NF_profileBoolean = 5,
1689             NF_LIMIT = 6;
1690 
1691     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
1692 
1693     static NamedFunction getFunction(byte func) {
1694         NamedFunction nf = NFS[func];
1695         if (nf != null) {
1696             return nf;
1697         }
1698         return NFS[func] = createFunction(func);
1699     }
1700 
1701     private static NamedFunction createFunction(byte func) {
1702         try {
1703             switch (func) {
1704                 case NF_checkSpreadArgument:
1705                     return new NamedFunction(MethodHandleImpl.class
1706                             .getDeclaredMethod(&quot;checkSpreadArgument&quot;, Object.class, int.class));
1707                 case NF_guardWithCatch:
1708                     return new NamedFunction(MethodHandleImpl.class
1709                             .getDeclaredMethod(&quot;guardWithCatch&quot;, MethodHandle.class, Class.class,
1710                                     MethodHandle.class, Object[].class));
1711                 case NF_tryFinally:
1712                     return new NamedFunction(MethodHandleImpl.class
1713                             .getDeclaredMethod(&quot;tryFinally&quot;, MethodHandle.class, MethodHandle.class, Object[].class));
1714                 case NF_loop:
1715                     return new NamedFunction(MethodHandleImpl.class
1716                             .getDeclaredMethod(&quot;loop&quot;, BasicType[].class, LoopClauses.class, Object[].class));
1717                 case NF_throwException:
1718                     return new NamedFunction(MethodHandleImpl.class
1719                             .getDeclaredMethod(&quot;throwException&quot;, Throwable.class));
1720                 case NF_profileBoolean:
1721                     return new NamedFunction(MethodHandleImpl.class
1722                             .getDeclaredMethod(&quot;profileBoolean&quot;, boolean.class, int[].class));
1723                 default:
1724                     throw new InternalError(&quot;Undefined function: &quot; + func);
1725             }
1726         } catch (ReflectiveOperationException ex) {
1727             throw newInternalError(ex);
1728         }
1729     }
1730 
1731     static {
1732         SharedSecrets.setJavaLangInvokeAccess(new JavaLangInvokeAccess() {
1733             @Override
1734             public Object newMemberName() {
1735                 return new MemberName();
1736             }
1737 
1738             @Override
1739             public String getName(Object mname) {
1740                 MemberName memberName = (MemberName)mname;
1741                 return memberName.getName();
1742             }
1743             @Override
1744             public Class&lt;?&gt; getDeclaringClass(Object mname) {
1745                 MemberName memberName = (MemberName)mname;
1746                 return memberName.getDeclaringClass();
1747             }
1748 
1749             @Override
1750             public MethodType getMethodType(Object mname) {
1751                 MemberName memberName = (MemberName)mname;
1752                 return memberName.getMethodType();
1753             }
1754 
1755             @Override
1756             public String getMethodDescriptor(Object mname) {
1757                 MemberName memberName = (MemberName)mname;
1758                 return memberName.getMethodDescriptor();
1759             }
1760 
1761             @Override
1762             public boolean isNative(Object mname) {
1763                 MemberName memberName = (MemberName)mname;
1764                 return memberName.isNative();
1765             }
1766 
1767             @Override
1768             public byte[] generateDirectMethodHandleHolderClassBytes(
1769                     String className, MethodType[] methodTypes, int[] types) {
1770                 return GenerateJLIClassesHelper
1771                         .generateDirectMethodHandleHolderClassBytes(
1772                                 className, methodTypes, types);
1773             }
1774 
1775             @Override
1776             public byte[] generateDelegatingMethodHandleHolderClassBytes(
1777                     String className, MethodType[] methodTypes) {
1778                 return GenerateJLIClassesHelper
1779                         .generateDelegatingMethodHandleHolderClassBytes(
1780                                 className, methodTypes);
1781             }
1782 
1783             @Override
1784             public Map.Entry&lt;String, byte[]&gt; generateConcreteBMHClassBytes(
1785                     final String types) {
1786                 return GenerateJLIClassesHelper
1787                         .generateConcreteBMHClassBytes(types);
1788             }
1789 
1790             @Override
1791             public byte[] generateBasicFormsClassBytes(final String className) {
1792                 return GenerateJLIClassesHelper
1793                         .generateBasicFormsClassBytes(className);
1794             }
1795 
1796             @Override
1797             public byte[] generateInvokersHolderClassBytes(final String className,
1798                     MethodType[] invokerMethodTypes,
1799                     MethodType[] callSiteMethodTypes) {
1800                 return GenerateJLIClassesHelper
1801                         .generateInvokersHolderClassBytes(className,
1802                                 invokerMethodTypes, callSiteMethodTypes);
1803             }
1804 
<a name="1" id="anc1"></a><span class="line-removed">1805             @Override</span>
<span class="line-removed">1806             public VarHandle memoryAccessVarHandle(Class&lt;?&gt; carrier, long alignmentMask,</span>
<span class="line-removed">1807                                                    ByteOrder order, long offset, long[] strides) {</span>
<span class="line-removed">1808                 return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);</span>
<span class="line-removed">1809             }</span>
<span class="line-removed">1810 </span>
<span class="line-removed">1811             @Override</span>
<span class="line-removed">1812             public Class&lt;?&gt; memoryAddressCarrier(VarHandle handle) {</span>
<span class="line-removed">1813                 return checkMemoryAccessHandle(handle).carrier();</span>
<span class="line-removed">1814             }</span>
<span class="line-removed">1815 </span>
<span class="line-removed">1816             @Override</span>
<span class="line-removed">1817             public long memoryAddressAlignmentMask(VarHandle handle) {</span>
<span class="line-removed">1818                 return checkMemoryAccessHandle(handle).alignmentMask;</span>
<span class="line-removed">1819             }</span>
<span class="line-removed">1820 </span>
<span class="line-removed">1821             @Override</span>
<span class="line-removed">1822             public ByteOrder memoryAddressByteOrder(VarHandle handle) {</span>
<span class="line-removed">1823                 return checkMemoryAccessHandle(handle).be ?</span>
<span class="line-removed">1824                         ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;</span>
<span class="line-removed">1825             }</span>
<span class="line-removed">1826 </span>
<span class="line-removed">1827             @Override</span>
<span class="line-removed">1828             public long memoryAddressOffset(VarHandle handle) {</span>
<span class="line-removed">1829                 return checkMemoryAccessHandle(handle).offset;</span>
<span class="line-removed">1830             }</span>
<span class="line-removed">1831 </span>
<span class="line-removed">1832             @Override</span>
<span class="line-removed">1833             public long[] memoryAddressStrides(VarHandle handle) {</span>
<span class="line-removed">1834                 return checkMemoryAccessHandle(handle).strides();</span>
<span class="line-removed">1835             }</span>
<span class="line-removed">1836 </span>
1837             @Override
1838             public MethodHandle nativeMethodHandle(NativeEntryPoint nep, MethodHandle fallback) {
1839                 return NativeMethodHandle.make(nep, fallback);
1840             }
1841 
1842             @Override
<a name="2" id="anc2"></a><span class="line-modified">1843             public boolean isMemoryAccessVarHandle(VarHandle handle) {</span>
<span class="line-modified">1844                 return asMemoryAccessVarHandle(handle) != null;</span>

1845             }
1846 
1847             @Override
1848             public VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {
1849                 return VarHandles.filterValue(target, filterToTarget, filterFromTarget);
1850             }
1851 
1852             @Override
1853             public VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
1854                 return VarHandles.filterCoordinates(target, pos, filters);
1855             }
1856 
1857             @Override
1858             public VarHandle dropCoordinates(VarHandle target, int pos, Class&lt;?&gt;... valueTypes) {
1859                 return VarHandles.dropCoordinates(target, pos, valueTypes);
1860             }
1861 
1862             @Override
1863             public VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder) {
1864                 return VarHandles.permuteCoordinates(target, newCoordinates, reorder);
1865             }
1866 
1867             @Override
1868             public VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {
1869                 return VarHandles.collectCoordinates(target, pos, filter);
1870             }
1871 
1872             @Override
1873             public VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
1874                 return VarHandles.insertCoordinates(target, pos, values);
1875             }
<a name="3" id="anc3"></a><span class="line-removed">1876 </span>
<span class="line-removed">1877             private MemoryAccessVarHandleBase asMemoryAccessVarHandle(VarHandle handle) {</span>
<span class="line-removed">1878                 if (handle instanceof MemoryAccessVarHandleBase) {</span>
<span class="line-removed">1879                     return (MemoryAccessVarHandleBase)handle;</span>
<span class="line-removed">1880                 } else if (handle.target() instanceof MemoryAccessVarHandleBase) {</span>
<span class="line-removed">1881                     // skip first adaptation, since we have to step over MemoryAddressProxy</span>
<span class="line-removed">1882                     // see JDK-8237349</span>
<span class="line-removed">1883                     return (MemoryAccessVarHandleBase)handle.target();</span>
<span class="line-removed">1884                 } else {</span>
<span class="line-removed">1885                     return null;</span>
<span class="line-removed">1886                 }</span>
<span class="line-removed">1887             }</span>
<span class="line-removed">1888 </span>
<span class="line-removed">1889             private MemoryAccessVarHandleBase checkMemoryAccessHandle(VarHandle handle) {</span>
<span class="line-removed">1890                 MemoryAccessVarHandleBase base = asMemoryAccessVarHandle(handle);</span>
<span class="line-removed">1891                 if (base == null) {</span>
<span class="line-removed">1892                     throw new IllegalArgumentException(&quot;Not a memory access varhandle: &quot; + handle);</span>
<span class="line-removed">1893                 }</span>
<span class="line-removed">1894                 return base;</span>
<span class="line-removed">1895             }</span>
1896         });
1897     }
1898 
1899     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
1900     private static MethodHandle unboxResultHandle(Class&lt;?&gt; returnType) {
1901         if (returnType.isPrimitive()) {
1902             if (returnType == void.class) {
1903                 return ValueConversions.ignore();
1904             } else {
1905                 Wrapper w = Wrapper.forPrimitiveType(returnType);
1906                 return ValueConversions.unboxExact(w);
1907             }
1908         } else {
1909             return MethodHandles.identity(Object.class);
1910         }
1911     }
1912 
1913     /**
1914      * Assembles a loop method handle from the given handles and type information.
1915      *
1916      * @param tloop the return type of the loop.
1917      * @param targs types of the arguments to be passed to the loop.
1918      * @param init sanitized array of initializers for loop-local variables.
1919      * @param step sanitited array of loop bodies.
1920      * @param pred sanitized array of predicates.
1921      * @param fini sanitized array of loop finalizers.
1922      *
1923      * @return a handle that, when invoked, will execute the loop.
1924      */
1925     static MethodHandle makeLoop(Class&lt;?&gt; tloop, List&lt;Class&lt;?&gt;&gt; targs, List&lt;MethodHandle&gt; init, List&lt;MethodHandle&gt; step,
1926                                  List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini) {
1927         MethodType type = MethodType.methodType(tloop, targs);
1928         BasicType[] initClauseTypes =
1929                 init.stream().map(h -&gt; h.type().returnType()).map(BasicType::basicType).toArray(BasicType[]::new);
1930         LambdaForm form = makeLoopForm(type.basicType(), initClauseTypes);
1931 
1932         // Prepare auxiliary method handles used during LambdaForm interpretation.
1933         // Box arguments and wrap them into Object[]: ValueConversions.array().
1934         MethodType varargsType = type.changeReturnType(Object[].class);
1935         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
1936         MethodHandle unboxResult = unboxResultHandle(tloop);
1937 
1938         LoopClauses clauseData =
1939                 new LoopClauses(new MethodHandle[][]{toArray(init), toArray(step), toArray(pred), toArray(fini)});
1940         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLL();
1941         BoundMethodHandle mh;
1942         try {
1943             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) clauseData,
1944                     (Object) collectArgs, (Object) unboxResult);
1945         } catch (Throwable ex) {
1946             throw uncaughtException(ex);
1947         }
1948         assert(mh.type() == type);
1949         return mh;
1950     }
1951 
1952     private static MethodHandle[] toArray(List&lt;MethodHandle&gt; l) {
1953         return l.toArray(new MethodHandle[0]);
1954     }
1955 
1956     /**
1957      * Loops introduce some complexity as they can have additional local state. Hence, LambdaForms for loops are
1958      * generated from a template. The LambdaForm template shape for the loop combinator is as follows (assuming one
1959      * reference parameter passed in {@code a1}, and a reference return type, with the return value represented by
1960      * {@code t12}):
1961      * &lt;blockquote&gt;&lt;pre&gt;{@code
1962      *  loop=Lambda(a0:L,a1:L)=&gt;{
1963      *    t2:L=BoundMethodHandle$Species_L3.argL0(a0:L);    // LoopClauses holding init, step, pred, fini handles
1964      *    t3:L=BoundMethodHandle$Species_L3.argL1(a0:L);    // helper handle to box the arguments into an Object[]
1965      *    t4:L=BoundMethodHandle$Species_L3.argL2(a0:L);    // helper handle to unbox the result
1966      *    t5:L=MethodHandle.invokeBasic(t3:L,a1:L);         // box the arguments into an Object[]
1967      *    t6:L=MethodHandleImpl.loop(null,t2:L,t3:L);       // call the loop executor
1968      *    t7:L=MethodHandle.invokeBasic(t4:L,t6:L);t7:L}    // unbox the result; return the result
1969      * }&lt;/pre&gt;&lt;/blockquote&gt;
1970      * &lt;p&gt;
1971      * {@code argL0} is a LoopClauses instance holding, in a 2-dimensional array, the init, step, pred, and fini method
1972      * handles. {@code argL1} and {@code argL2} are auxiliary method handles: {@code argL1} boxes arguments and wraps
1973      * them into {@code Object[]} ({@code ValueConversions.array()}), and {@code argL2} unboxes the result if necessary
1974      * ({@code ValueConversions.unbox()}).
1975      * &lt;p&gt;
1976      * Having {@code t3} and {@code t4} passed in via a BMH and not hardcoded in the lambda form allows to share lambda
1977      * forms among loop combinators with the same basic type.
1978      * &lt;p&gt;
1979      * The above template is instantiated by using the {@link LambdaFormEditor} to replace the {@code null} argument to
1980      * the {@code loop} invocation with the {@code BasicType} array describing the loop clause types. This argument is
1981      * ignored in the loop invoker, but will be extracted and used in {@linkplain InvokerBytecodeGenerator#emitLoop(int)
1982      * bytecode generation}.
1983      */
1984     private static LambdaForm makeLoopForm(MethodType basicType, BasicType[] localVarTypes) {
1985         MethodType lambdaType = basicType.invokerType();
1986 
1987         final int THIS_MH = 0;  // the BMH_LLL
1988         final int ARG_BASE = 1; // start of incoming arguments
1989         final int ARG_LIMIT = ARG_BASE + basicType.parameterCount();
1990 
1991         int nameCursor = ARG_LIMIT;
1992         final int GET_CLAUSE_DATA = nameCursor++;
1993         final int GET_COLLECT_ARGS = nameCursor++;
1994         final int GET_UNBOX_RESULT = nameCursor++;
1995         final int BOXED_ARGS = nameCursor++;
1996         final int LOOP = nameCursor++;
1997         final int UNBOX_RESULT = nameCursor++;
1998 
1999         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_LOOP);
2000         if (lform == null) {
2001             Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
2002 
2003             BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLL();
2004             names[THIS_MH] = names[THIS_MH].withConstraint(data);
2005             names[GET_CLAUSE_DATA] = new Name(data.getterFunction(0), names[THIS_MH]);
2006             names[GET_COLLECT_ARGS] = new Name(data.getterFunction(1), names[THIS_MH]);
2007             names[GET_UNBOX_RESULT] = new Name(data.getterFunction(2), names[THIS_MH]);
2008 
2009             // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
2010             MethodType collectArgsType = basicType.changeReturnType(Object.class);
2011             MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
2012             Object[] args = new Object[invokeBasic.type().parameterCount()];
2013             args[0] = names[GET_COLLECT_ARGS];
2014             System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT - ARG_BASE);
2015             names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.LOOP), args);
2016 
2017             // t_{i+1}:L=MethodHandleImpl.loop(localTypes:L,clauses:L,t_{i}:L);
2018             Object[] lArgs =
2019                     new Object[]{null, // placeholder for BasicType[] localTypes - will be added by LambdaFormEditor
2020                             names[GET_CLAUSE_DATA], names[BOXED_ARGS]};
2021             names[LOOP] = new Name(getFunction(NF_loop), lArgs);
2022 
2023             // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
2024             MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
2025             Object[] unboxArgs = new Object[]{names[GET_UNBOX_RESULT], names[LOOP]};
2026             names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
2027 
2028             lform = basicType.form().setCachedLambdaForm(MethodTypeForm.LF_LOOP,
2029                     new LambdaForm(lambdaType.parameterCount(), names, Kind.LOOP));
2030         }
2031 
2032         // BOXED_ARGS is the index into the names array where the loop idiom starts
2033         return lform.editor().noteLoopLocalTypesForm(BOXED_ARGS, localVarTypes);
2034     }
2035 
2036     static class LoopClauses {
2037         @Stable final MethodHandle[][] clauses;
2038         LoopClauses(MethodHandle[][] clauses) {
2039             assert clauses.length == 4;
2040             this.clauses = clauses;
2041         }
2042         @Override
2043         public String toString() {
2044             StringBuffer sb = new StringBuffer(&quot;LoopClauses -- &quot;);
2045             for (int i = 0; i &lt; 4; ++i) {
2046                 if (i &gt; 0) {
2047                     sb.append(&quot;       &quot;);
2048                 }
2049                 sb.append(&#39;&lt;&#39;).append(i).append(&quot;&gt;: &quot;);
2050                 MethodHandle[] hs = clauses[i];
2051                 for (int j = 0; j &lt; hs.length; ++j) {
2052                     if (j &gt; 0) {
2053                         sb.append(&quot;          &quot;);
2054                     }
2055                     sb.append(&#39;*&#39;).append(j).append(&quot;: &quot;).append(hs[j]).append(&#39;\n&#39;);
2056                 }
2057             }
2058             sb.append(&quot; --\n&quot;);
2059             return sb.toString();
2060         }
2061     }
2062 
2063     /**
2064      * Intrinsified during LambdaForm compilation
2065      * (see {@link InvokerBytecodeGenerator#emitLoop(int)}).
2066      */
2067     @Hidden
2068     static Object loop(BasicType[] localTypes, LoopClauses clauseData, Object... av) throws Throwable {
2069         final MethodHandle[] init = clauseData.clauses[0];
2070         final MethodHandle[] step = clauseData.clauses[1];
2071         final MethodHandle[] pred = clauseData.clauses[2];
2072         final MethodHandle[] fini = clauseData.clauses[3];
2073         int varSize = (int) Stream.of(init).filter(h -&gt; h.type().returnType() != void.class).count();
2074         int nArgs = init[0].type().parameterCount();
2075         Object[] varsAndArgs = new Object[varSize + nArgs];
2076         for (int i = 0, v = 0; i &lt; init.length; ++i) {
2077             MethodHandle ih = init[i];
2078             if (ih.type().returnType() == void.class) {
2079                 ih.invokeWithArguments(av);
2080             } else {
2081                 varsAndArgs[v++] = ih.invokeWithArguments(av);
2082             }
2083         }
2084         System.arraycopy(av, 0, varsAndArgs, varSize, nArgs);
2085         final int nSteps = step.length;
2086         for (; ; ) {
2087             for (int i = 0, v = 0; i &lt; nSteps; ++i) {
2088                 MethodHandle p = pred[i];
2089                 MethodHandle s = step[i];
2090                 MethodHandle f = fini[i];
2091                 if (s.type().returnType() == void.class) {
2092                     s.invokeWithArguments(varsAndArgs);
2093                 } else {
2094                     varsAndArgs[v++] = s.invokeWithArguments(varsAndArgs);
2095                 }
2096                 if (!(boolean) p.invokeWithArguments(varsAndArgs)) {
2097                     return f.invokeWithArguments(varsAndArgs);
2098                 }
2099             }
2100         }
2101     }
2102 
2103     /**
2104      * This method is bound as the predicate in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,
2105      * MethodHandle) counting loops}.
2106      *
2107      * @param limit the upper bound of the parameter, statically bound at loop creation time.
2108      * @param counter the counter parameter, passed in during loop execution.
2109      *
2110      * @return whether the counter has reached the limit.
2111      */
2112     static boolean countedLoopPredicate(int limit, int counter) {
2113         return counter &lt; limit;
2114     }
2115 
2116     /**
2117      * This method is bound as the step function in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,
2118      * MethodHandle) counting loops} to increment the counter.
2119      *
2120      * @param limit the upper bound of the loop counter (ignored).
2121      * @param counter the loop counter.
2122      *
2123      * @return the loop counter incremented by 1.
2124      */
2125     static int countedLoopStep(int limit, int counter) {
2126         return counter + 1;
2127     }
2128 
2129     /**
2130      * This is bound to initialize the loop-local iterator in {@linkplain MethodHandles#iteratedLoop iterating loops}.
2131      *
2132      * @param it the {@link Iterable} over which the loop iterates.
2133      *
2134      * @return an {@link Iterator} over the argument&#39;s elements.
2135      */
2136     static Iterator&lt;?&gt; initIterator(Iterable&lt;?&gt; it) {
2137         return it.iterator();
2138     }
2139 
2140     /**
2141      * This method is bound as the predicate in {@linkplain MethodHandles#iteratedLoop iterating loops}.
2142      *
2143      * @param it the iterator to be checked.
2144      *
2145      * @return {@code true} iff there are more elements to iterate over.
2146      */
2147     static boolean iteratePredicate(Iterator&lt;?&gt; it) {
2148         return it.hasNext();
2149     }
2150 
2151     /**
2152      * This method is bound as the step for retrieving the current value from the iterator in {@linkplain
2153      * MethodHandles#iteratedLoop iterating loops}.
2154      *
2155      * @param it the iterator.
2156      *
2157      * @return the next element from the iterator.
2158      */
2159     static Object iterateNext(Iterator&lt;?&gt; it) {
2160         return it.next();
2161     }
2162 
2163     /**
2164      * Makes a {@code try-finally} handle that conforms to the type constraints.
2165      *
2166      * @param target the target to execute in a {@code try-finally} block.
2167      * @param cleanup the cleanup to execute in the {@code finally} block.
2168      * @param rtype the result type of the entire construct.
2169      * @param argTypes the types of the arguments.
2170      *
2171      * @return a handle on the constructed {@code try-finally} block.
2172      */
2173     static MethodHandle makeTryFinally(MethodHandle target, MethodHandle cleanup, Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; argTypes) {
2174         MethodType type = MethodType.methodType(rtype, argTypes);
2175         LambdaForm form = makeTryFinallyForm(type.basicType());
2176 
2177         // Prepare auxiliary method handles used during LambdaForm interpretation.
2178         // Box arguments and wrap them into Object[]: ValueConversions.array().
2179         MethodType varargsType = type.changeReturnType(Object[].class);
2180         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
2181         MethodHandle unboxResult = unboxResultHandle(rtype);
2182 
2183         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();
2184         BoundMethodHandle mh;
2185         try {
2186             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) cleanup,
2187                     (Object) collectArgs, (Object) unboxResult);
2188         } catch (Throwable ex) {
2189             throw uncaughtException(ex);
2190         }
2191         assert(mh.type() == type);
2192         return mh;
2193     }
2194 
2195     /**
2196      * The LambdaForm shape for the tryFinally combinator is as follows (assuming one reference parameter passed in
2197      * {@code a1}, and a reference return type, with the return value represented by {@code t8}):
2198      * &lt;blockquote&gt;&lt;pre&gt;{@code
2199      *  tryFinally=Lambda(a0:L,a1:L)=&gt;{
2200      *    t2:L=BoundMethodHandle$Species_LLLL.argL0(a0:L);  // target method handle
2201      *    t3:L=BoundMethodHandle$Species_LLLL.argL1(a0:L);  // cleanup method handle
2202      *    t4:L=BoundMethodHandle$Species_LLLL.argL2(a0:L);  // helper handle to box the arguments into an Object[]
2203      *    t5:L=BoundMethodHandle$Species_LLLL.argL3(a0:L);  // helper handle to unbox the result
2204      *    t6:L=MethodHandle.invokeBasic(t4:L,a1:L);         // box the arguments into an Object[]
2205      *    t7:L=MethodHandleImpl.tryFinally(t2:L,t3:L,t6:L); // call the tryFinally executor
2206      *    t8:L=MethodHandle.invokeBasic(t5:L,t7:L);t8:L}    // unbox the result; return the result
2207      * }&lt;/pre&gt;&lt;/blockquote&gt;
2208      * &lt;p&gt;
2209      * {@code argL0} and {@code argL1} are the target and cleanup method handles.
2210      * {@code argL2} and {@code argL3} are auxiliary method handles: {@code argL2} boxes arguments and wraps them into
2211      * {@code Object[]} ({@code ValueConversions.array()}), and {@code argL3} unboxes the result if necessary
2212      * ({@code ValueConversions.unbox()}).
2213      * &lt;p&gt;
2214      * Having {@code t4} and {@code t5} passed in via a BMH and not hardcoded in the lambda form allows to share lambda
2215      * forms among tryFinally combinators with the same basic type.
2216      */
2217     private static LambdaForm makeTryFinallyForm(MethodType basicType) {
2218         MethodType lambdaType = basicType.invokerType();
2219 
2220         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_TF);
2221         if (lform != null) {
2222             return lform;
2223         }
2224         final int THIS_MH      = 0;  // the BMH_LLLL
2225         final int ARG_BASE     = 1;  // start of incoming arguments
2226         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
2227 
2228         int nameCursor = ARG_LIMIT;
2229         final int GET_TARGET       = nameCursor++;
2230         final int GET_CLEANUP      = nameCursor++;
2231         final int GET_COLLECT_ARGS = nameCursor++;
2232         final int GET_UNBOX_RESULT = nameCursor++;
2233         final int BOXED_ARGS       = nameCursor++;
2234         final int TRY_FINALLY      = nameCursor++;
2235         final int UNBOX_RESULT     = nameCursor++;
2236 
2237         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
2238 
2239         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();
2240         names[THIS_MH]          = names[THIS_MH].withConstraint(data);
2241         names[GET_TARGET]       = new Name(data.getterFunction(0), names[THIS_MH]);
2242         names[GET_CLEANUP]      = new Name(data.getterFunction(1), names[THIS_MH]);
2243         names[GET_COLLECT_ARGS] = new Name(data.getterFunction(2), names[THIS_MH]);
2244         names[GET_UNBOX_RESULT] = new Name(data.getterFunction(3), names[THIS_MH]);
2245 
2246         // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
2247         MethodType collectArgsType = basicType.changeReturnType(Object.class);
2248         MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
2249         Object[] args = new Object[invokeBasic.type().parameterCount()];
2250         args[0] = names[GET_COLLECT_ARGS];
2251         System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
2252         names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.TRY_FINALLY), args);
2253 
2254         // t_{i+1}:L=MethodHandleImpl.tryFinally(target:L,exType:L,catcher:L,t_{i}:L);
2255         Object[] tfArgs = new Object[] {names[GET_TARGET], names[GET_CLEANUP], names[BOXED_ARGS]};
2256         names[TRY_FINALLY] = new Name(getFunction(NF_tryFinally), tfArgs);
2257 
2258         // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
2259         MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
2260         Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_FINALLY]};
2261         names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
2262 
2263         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.TRY_FINALLY);
2264 
2265         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_TF, lform);
2266     }
2267 
2268     /**
2269      * Intrinsified during LambdaForm compilation
2270      * (see {@link InvokerBytecodeGenerator#emitTryFinally emitTryFinally}).
2271      */
2272     @Hidden
2273     static Object tryFinally(MethodHandle target, MethodHandle cleanup, Object... av) throws Throwable {
2274         Throwable t = null;
2275         Object r = null;
2276         try {
2277             r = target.invokeWithArguments(av);
2278         } catch (Throwable thrown) {
2279             t = thrown;
2280             throw t;
2281         } finally {
2282             Object[] args = target.type().returnType() == void.class ? prepend(av, t) : prepend(av, t, r);
2283             r = cleanup.invokeWithArguments(args);
2284         }
2285         return r;
2286     }
2287 
2288     // Indexes into constant method handles:
2289     static final int
2290             MH_cast                  =  0,
2291             MH_selectAlternative     =  1,
2292             MH_copyAsPrimitiveArray  =  2,
2293             MH_fillNewTypedArray     =  3,
2294             MH_fillNewArray          =  4,
2295             MH_arrayIdentity         =  5,
2296             MH_countedLoopPred       =  6,
2297             MH_countedLoopStep       =  7,
2298             MH_initIterator          =  8,
2299             MH_iteratePred           =  9,
2300             MH_iterateNext           = 10,
2301             MH_Array_newInstance     = 11,
2302             MH_LIMIT                 = 12;
2303 
2304     static MethodHandle getConstantHandle(int idx) {
2305         MethodHandle handle = HANDLES[idx];
2306         if (handle != null) {
2307             return handle;
2308         }
2309         return setCachedHandle(idx, makeConstantHandle(idx));
2310     }
2311 
2312     private static synchronized MethodHandle setCachedHandle(int idx, final MethodHandle method) {
2313         // Simulate a CAS, to avoid racy duplication of results.
2314         MethodHandle prev = HANDLES[idx];
2315         if (prev != null) {
2316             return prev;
2317         }
2318         HANDLES[idx] = method;
2319         return method;
2320     }
2321 
2322     // Local constant method handles:
2323     private static final @Stable MethodHandle[] HANDLES = new MethodHandle[MH_LIMIT];
2324 
2325     private static MethodHandle makeConstantHandle(int idx) {
2326         try {
2327             switch (idx) {
2328                 case MH_cast:
2329                     return IMPL_LOOKUP.findVirtual(Class.class, &quot;cast&quot;,
2330                             MethodType.methodType(Object.class, Object.class));
2331                 case MH_copyAsPrimitiveArray:
2332                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;copyAsPrimitiveArray&quot;,
2333                             MethodType.methodType(Object.class, Wrapper.class, Object[].class));
2334                 case MH_arrayIdentity:
2335                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;identity&quot;,
2336                             MethodType.methodType(Object[].class, Object[].class));
2337                 case MH_fillNewArray:
2338                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;fillNewArray&quot;,
2339                             MethodType.methodType(Object[].class, Integer.class, Object[].class));
2340                 case MH_fillNewTypedArray:
2341                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;fillNewTypedArray&quot;,
2342                             MethodType.methodType(Object[].class, Object[].class, Integer.class, Object[].class));
2343                 case MH_selectAlternative:
2344                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;selectAlternative&quot;,
2345                             MethodType.methodType(MethodHandle.class, boolean.class, MethodHandle.class, MethodHandle.class));
2346                 case MH_countedLoopPred:
2347                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;countedLoopPredicate&quot;,
2348                             MethodType.methodType(boolean.class, int.class, int.class));
2349                 case MH_countedLoopStep:
2350                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;countedLoopStep&quot;,
2351                             MethodType.methodType(int.class, int.class, int.class));
2352                 case MH_initIterator:
2353                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;initIterator&quot;,
2354                             MethodType.methodType(Iterator.class, Iterable.class));
2355                 case MH_iteratePred:
2356                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;iteratePredicate&quot;,
2357                             MethodType.methodType(boolean.class, Iterator.class));
2358                 case MH_iterateNext:
2359                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;iterateNext&quot;,
2360                             MethodType.methodType(Object.class, Iterator.class));
2361                 case MH_Array_newInstance:
2362                     return IMPL_LOOKUP.findStatic(Array.class, &quot;newInstance&quot;,
2363                             MethodType.methodType(Object.class, Class.class, int.class));
2364             }
2365         } catch (ReflectiveOperationException ex) {
2366             throw newInternalError(ex);
2367         }
2368         throw newInternalError(&quot;Unknown function index: &quot; + idx);
2369     }
2370 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
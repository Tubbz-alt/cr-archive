<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="VarHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaLangInvokeAccess.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.lang.invoke;
 26 
<span class="line-modified"> 27 import jdk.internal.access.foreign.MemoryAddressProxy;</span>
 28 import jdk.internal.vm.annotation.ForceInline;
 29 
 30 import java.util.Objects;
 31 
 32 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 33 
 34 #warn
 35 
<span class="line-modified"> 36 final class MemoryAccessVarHandle$Type$Helper {</span>
 37 
 38     static final boolean BE = UNSAFE.isBigEndian();
 39 
 40     static final int VM_ALIGN = $BoxType$.BYTES - 1;
 41 











 42 #if[floatingPoint]
 43     @ForceInline
 44     static $rawType$ convEndian(boolean big, $type$ v) {
 45         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
 46         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 47     }
 48 
 49     @ForceInline
 50     static $type$ convEndian(boolean big, $rawType$ rv) {
 51         rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 52         return $Type$.$rawType$BitsTo$Type$(rv);
 53     }
 54 #else[floatingPoint]
 55 #if[byte]
 56     @ForceInline
 57     static $type$ convEndian(boolean big, $type$ n) {
 58         return n;
 59     }
 60 #else[byte]
 61     @ForceInline
 62     static $type$ convEndian(boolean big, $type$ n) {
 63         return big == BE ? n : $BoxType$.reverseBytes(n);
 64     }
 65 #end[byte]
 66 #end[floatingPoint]
 67 
 68     @ForceInline
<span class="line-modified"> 69     static MemoryAddressProxy checkAddress(Object obb, long offset, long length, boolean ro) {</span>
<span class="line-modified"> 70         MemoryAddressProxy oo = (MemoryAddressProxy)Objects.requireNonNull(obb);</span>
 71         oo.checkAccess(offset, length, ro);
 72         return oo;
 73     }
 74 
 75     @ForceInline
<span class="line-modified"> 76     static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {</span>
<span class="line-modified"> 77         long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);</span>
 78         if ((address &amp; VM_ALIGN) != 0) {
 79             throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
 80         }
 81         return address;
 82     }
 83 
 84     @ForceInline
<span class="line-modified"> 85     static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {</span>
 86         long base = bb.unsafeGetOffset();
 87         long address = base + offset;
<span class="line-modified"> 88         //note: the offset portion has already been aligned-checked, by construction</span>
<span class="line-modified"> 89         if ((base &amp; alignmentMask) != 0) {</span>
<span class="line-modified"> 90             throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);</span>






 91         }
 92         return address;
 93     }
 94 
 95     @ForceInline
<span class="line-modified"> 96     static $type$ get0(VarHandle ob, Object obb, long base) {</span>
 97         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified"> 98         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);</span>
 99 #if[floatingPoint]
100         $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
101                 bb.unsafeGetBase(),
<span class="line-modified">102                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),</span>
103                 handle.be);
104         return $Type$.$rawType$BitsTo$Type$(rawValue);
105 #else[floatingPoint]
106 #if[byte]
107         return UNSAFE.get$Type$(
108                 bb.unsafeGetBase(),
<span class="line-modified">109                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask));</span>
110 #else[byte]
111         return UNSAFE.get$Type$Unaligned(
112                 bb.unsafeGetBase(),
<span class="line-modified">113                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),</span>
114                 handle.be);
115 #end[byte]
116 #end[floatingPoint]
117     }
118 
119     @ForceInline
<span class="line-modified">120     static void set0(VarHandle ob, Object obb, long base, $type$ value) {</span>
121         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">122         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
123 #if[floatingPoint]
124         UNSAFE.put$RawType$Unaligned(
125                 bb.unsafeGetBase(),
<span class="line-modified">126                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),</span>
127                 $Type$.$type$ToRaw$RawType$Bits(value),
128                 handle.be);
129 #else[floatingPoint]
130 #if[byte]
131         UNSAFE.put$Type$(
132                 bb.unsafeGetBase(),
<span class="line-modified">133                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),</span>
134                 value);
135 #else[byte]
136         UNSAFE.put$Type$Unaligned(
137                 bb.unsafeGetBase(),
<span class="line-modified">138                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),</span>
139                 value,
140                 handle.be);
141 #end[byte]
142 #end[floatingPoint]
143     }
144 
145     @ForceInline
<span class="line-modified">146     static $type$ getVolatile0(VarHandle ob, Object obb, long base) {</span>
147         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">148         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);</span>
149         return convEndian(handle.be,
150                           UNSAFE.get$RawType$Volatile(
151                                   bb.unsafeGetBase(),
<span class="line-modified">152                                   offset(bb, base, handle.alignmentMask)));</span>
153     }
154 
155     @ForceInline
<span class="line-modified">156     static void setVolatile0(VarHandle ob, Object obb, long base, $type$ value) {</span>
157         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">158         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
159         UNSAFE.put$RawType$Volatile(
160                 bb.unsafeGetBase(),
<span class="line-modified">161                 offset(bb, base, handle.alignmentMask),</span>
162                 convEndian(handle.be, value));
163     }
164 
165     @ForceInline
<span class="line-modified">166     static $type$ getAcquire0(VarHandle ob, Object obb, long base) {</span>
167         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">168         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);</span>
169         return convEndian(handle.be,
170                           UNSAFE.get$RawType$Acquire(
171                                   bb.unsafeGetBase(),
<span class="line-modified">172                                   offset(bb, base, handle.alignmentMask)));</span>
173     }
174 
175     @ForceInline
<span class="line-modified">176     static void setRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
177         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">178         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
179         UNSAFE.put$RawType$Release(
180                 bb.unsafeGetBase(),
<span class="line-modified">181                 offset(bb, base, handle.alignmentMask),</span>
182                 convEndian(handle.be, value));
183     }
184 
185     @ForceInline
<span class="line-modified">186     static $type$ getOpaque0(VarHandle ob, Object obb, long base) {</span>
187         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">188         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);</span>
189         return convEndian(handle.be,
190                           UNSAFE.get$RawType$Opaque(
191                                   bb.unsafeGetBase(),
<span class="line-modified">192                                   offset(bb, base, handle.alignmentMask)));</span>
193     }
194 
195     @ForceInline
<span class="line-modified">196     static void setOpaque0(VarHandle ob, Object obb, long base, $type$ value) {</span>
197         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">198         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
199         UNSAFE.put$RawType$Opaque(
200                 bb.unsafeGetBase(),
<span class="line-modified">201                 offset(bb, base, handle.alignmentMask),</span>
202                 convEndian(handle.be, value));
203     }
204 #if[CAS]
205 
206     @ForceInline
<span class="line-modified">207     static boolean compareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
208         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">209         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
210         return UNSAFE.compareAndSet$RawType$(
211                 bb.unsafeGetBase(),
<span class="line-modified">212                 offset(bb, base, handle.alignmentMask),</span>
213                 convEndian(handle.be, expected), convEndian(handle.be, value));
214     }
215 
216     @ForceInline
<span class="line-modified">217     static $type$ compareAndExchange0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
218         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">219         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
220         return convEndian(handle.be,
221                           UNSAFE.compareAndExchange$RawType$(
222                                   bb.unsafeGetBase(),
<span class="line-modified">223                                   offset(bb, base, handle.alignmentMask),</span>
224                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
225     }
226 
227     @ForceInline
<span class="line-modified">228     static $type$ compareAndExchangeAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
229         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">230         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
231         return convEndian(handle.be,
232                           UNSAFE.compareAndExchange$RawType$Acquire(
233                                   bb.unsafeGetBase(),
<span class="line-modified">234                                   offset(bb, base, handle.alignmentMask),</span>
235                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
236     }
237 
238     @ForceInline
<span class="line-modified">239     static $type$ compareAndExchangeRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
240         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">241         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
242         return convEndian(handle.be,
243                           UNSAFE.compareAndExchange$RawType$Release(
244                                   bb.unsafeGetBase(),
<span class="line-modified">245                                   offset(bb, base, handle.alignmentMask),</span>
246                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
247     }
248 
249     @ForceInline
<span class="line-modified">250     static boolean weakCompareAndSetPlain0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
251         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">252         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
253         return UNSAFE.weakCompareAndSet$RawType$Plain(
254                 bb.unsafeGetBase(),
<span class="line-modified">255                 offset(bb, base, handle.alignmentMask),</span>
256                 convEndian(handle.be, expected), convEndian(handle.be, value));
257     }
258 
259     @ForceInline
<span class="line-modified">260     static boolean weakCompareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
261         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">262         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
263         return UNSAFE.weakCompareAndSet$RawType$(
264                 bb.unsafeGetBase(),
<span class="line-modified">265                 offset(bb, base, handle.alignmentMask),</span>
266                 convEndian(handle.be, expected), convEndian(handle.be, value));
267     }
268 
269     @ForceInline
<span class="line-modified">270     static boolean weakCompareAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
271         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">272         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
273         return UNSAFE.weakCompareAndSet$RawType$Acquire(
274                 bb.unsafeGetBase(),
<span class="line-modified">275                 offset(bb, base, handle.alignmentMask),</span>
276                 convEndian(handle.be, expected), convEndian(handle.be, value));
277     }
278 
279     @ForceInline
<span class="line-modified">280     static boolean weakCompareAndSetRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
281         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">282         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
283         return UNSAFE.weakCompareAndSet$RawType$Release(
284                 bb.unsafeGetBase(),
<span class="line-modified">285                 offset(bb, base, handle.alignmentMask),</span>
286                 convEndian(handle.be, expected), convEndian(handle.be, value));
287     }
288 
289     @ForceInline
<span class="line-modified">290     static $type$ getAndSet0(VarHandle ob, Object obb, long base, $type$ value) {</span>
291         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">292         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
293         return convEndian(handle.be,
294                           UNSAFE.getAndSet$RawType$(
295                                   bb.unsafeGetBase(),
<span class="line-modified">296                                   offset(bb, base, handle.alignmentMask),</span>
297                                   convEndian(handle.be, value)));
298     }
299 
300     @ForceInline
<span class="line-modified">301     static $type$ getAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
302         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">303         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
304         return convEndian(handle.be,
305                           UNSAFE.getAndSet$RawType$Acquire(
306                                   bb.unsafeGetBase(),
<span class="line-modified">307                                   offset(bb, base, handle.alignmentMask),</span>
308                                   convEndian(handle.be, value)));
309     }
310 
311     @ForceInline
<span class="line-modified">312     static $type$ getAndSetRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
313         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">314         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
315         return convEndian(handle.be,
316                           UNSAFE.getAndSet$RawType$Release(
317                                   bb.unsafeGetBase(),
<span class="line-modified">318                                   offset(bb, base, handle.alignmentMask),</span>
319                                   convEndian(handle.be, value)));
320     }
321 #end[CAS]
322 #if[AtomicAdd]
323 
324     @ForceInline
<span class="line-modified">325     static $type$ getAndAdd0(VarHandle ob, Object obb, long base, $type$ delta) {</span>
326         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">327         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
328         if (handle.be == BE) {
329             return UNSAFE.getAndAdd$RawType$(
330                     bb.unsafeGetBase(),
<span class="line-modified">331                     offset(bb, base, handle.alignmentMask),</span>
332                     delta);
333         } else {
<span class="line-modified">334             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);</span>
335         }
336     }
337 
338     @ForceInline
<span class="line-modified">339     static $type$ getAndAddAcquire0(VarHandle ob, Object obb, long base, $type$ delta) {</span>
340         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">341         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
342         if (handle.be == BE) {
343             return UNSAFE.getAndAdd$RawType$Acquire(
344                     bb.unsafeGetBase(),
<span class="line-modified">345                     offset(bb, base, handle.alignmentMask),</span>
346                     delta);
347         } else {
<span class="line-modified">348             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);</span>
349         }
350     }
351 
352     @ForceInline
<span class="line-modified">353     static $type$ getAndAddRelease0(VarHandle ob, Object obb, long base, $type$ delta) {</span>
354         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">355         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
356         if (handle.be == BE) {
357             return UNSAFE.getAndAdd$RawType$Release(
358                     bb.unsafeGetBase(),
<span class="line-modified">359                     offset(bb, base, handle.alignmentMask),</span>
360                     delta);
361         } else {
<span class="line-modified">362             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);</span>
363         }
364     }
365 
366     @ForceInline
<span class="line-modified">367     static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {</span>
368         $type$ nativeExpectedValue, expectedValue;
369         Object base = bb.unsafeGetBase();
370         do {
371             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
372             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
373         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
374                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
375         return expectedValue;
376     }
377 #end[AtomicAdd]
378 #if[Bitwise]
379 
380     @ForceInline
<span class="line-modified">381     static $type$ getAndBitwiseOr0(VarHandle ob, Object obb, long base, $type$ value) {</span>
382         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">383         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
384         if (handle.be == BE) {
385             return UNSAFE.getAndBitwiseOr$RawType$(
386                     bb.unsafeGetBase(),
<span class="line-modified">387                     offset(bb, base, handle.alignmentMask),</span>
388                     value);
389         } else {
<span class="line-modified">390             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
391         }
392     }
393 
394     @ForceInline
<span class="line-modified">395     static $type$ getAndBitwiseOrRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
396         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">397         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
398         if (handle.be == BE) {
399             return UNSAFE.getAndBitwiseOr$RawType$Release(
400                     bb.unsafeGetBase(),
<span class="line-modified">401                     offset(bb, base, handle.alignmentMask),</span>
402                     value);
403         } else {
<span class="line-modified">404             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
405         }
406     }
407 
408     @ForceInline
<span class="line-modified">409     static $type$ getAndBitwiseOrAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
410         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">411         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
412         if (handle.be == BE) {
413             return UNSAFE.getAndBitwiseOr$RawType$Acquire(
414                     bb.unsafeGetBase(),
<span class="line-modified">415                     offset(bb, base, handle.alignmentMask),</span>
416                     value);
417         } else {
<span class="line-modified">418             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
419         }
420     }
421 
422     @ForceInline
<span class="line-modified">423     static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {</span>
424         $type$ nativeExpectedValue, expectedValue;
425         Object base = bb.unsafeGetBase();
426         do {
427             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
428             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
429         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
430                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
431         return expectedValue;
432     }
433 
434     @ForceInline
<span class="line-modified">435     static $type$ getAndBitwiseAnd0(VarHandle ob, Object obb, long base, $type$ value) {</span>
436         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">437         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
438         if (handle.be == BE) {
439             return UNSAFE.getAndBitwiseAnd$RawType$(
440                     bb.unsafeGetBase(),
<span class="line-modified">441                     offset(bb, base, handle.alignmentMask),</span>
442                     value);
443         } else {
<span class="line-modified">444             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
445         }
446     }
447 
448     @ForceInline
<span class="line-modified">449     static $type$ getAndBitwiseAndRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
450         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">451         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
452         if (handle.be == BE) {
453             return UNSAFE.getAndBitwiseAnd$RawType$Release(
454                     bb.unsafeGetBase(),
<span class="line-modified">455                     offset(bb, base, handle.alignmentMask),</span>
456                     value);
457         } else {
<span class="line-modified">458             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
459         }
460     }
461 
462     @ForceInline
<span class="line-modified">463     static $type$ getAndBitwiseAndAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
464         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">465         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
466         if (handle.be == BE) {
467             return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
468                     bb.unsafeGetBase(),
<span class="line-modified">469                     offset(bb, base, handle.alignmentMask),</span>
470                     value);
471         } else {
<span class="line-modified">472             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
473         }
474     }
475 
476     @ForceInline
<span class="line-modified">477     static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {</span>
478         $type$ nativeExpectedValue, expectedValue;
479         Object base = bb.unsafeGetBase();
480         do {
481             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
482             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
483         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
484                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
485         return expectedValue;
486     }
487 
488 
489     @ForceInline
<span class="line-modified">490     static $type$ getAndBitwiseXor0(VarHandle ob, Object obb, long base, $type$ value) {</span>
491         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">492         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
493         if (handle.be == BE) {
494             return UNSAFE.getAndBitwiseXor$RawType$(
495                     bb.unsafeGetBase(),
<span class="line-modified">496                     offset(bb, base, handle.alignmentMask),</span>
497                     value);
498         } else {
<span class="line-modified">499             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
500         }
501     }
502 
503     @ForceInline
<span class="line-modified">504     static $type$ getAndBitwiseXorRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
505         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">506         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
507         if (handle.be == BE) {
508             return UNSAFE.getAndBitwiseXor$RawType$Release(
509                     bb.unsafeGetBase(),
<span class="line-modified">510                     offset(bb, base, handle.alignmentMask),</span>
511                     value);
512         } else {
<span class="line-modified">513             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
514         }
515     }
516 
517     @ForceInline
<span class="line-modified">518     static $type$ getAndBitwiseXorAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
519         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">520         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
521         if (handle.be == BE) {
522             return UNSAFE.getAndBitwiseXor$RawType$Acquire(
523                     bb.unsafeGetBase(),
<span class="line-modified">524                     offset(bb, base, handle.alignmentMask),</span>
525                     value);
526         } else {
<span class="line-modified">527             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
528         }
529     }
530 
531     @ForceInline
<span class="line-modified">532     static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {</span>
533         $type$ nativeExpectedValue, expectedValue;
534         Object base = bb.unsafeGetBase();
535         do {
536             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
537             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
538         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
539                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
540         return expectedValue;
541     }
542 #end[Bitwise]
543 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.lang.invoke;
 26 
<span class="line-modified"> 27 import jdk.internal.access.foreign.MemorySegmentProxy;</span>
 28 import jdk.internal.vm.annotation.ForceInline;
 29 
 30 import java.util.Objects;
 31 
 32 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 33 
 34 #warn
 35 
<span class="line-modified"> 36 final class MemoryAccessVarHandle$Type$Helper extends MemoryAccessVarHandleBase {</span>
 37 
 38     static final boolean BE = UNSAFE.isBigEndian();
 39 
 40     static final int VM_ALIGN = $BoxType$.BYTES - 1;
 41 
<span class="line-added"> 42     static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegmentProxy.class, $type$.class, long.class);</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44     MemoryAccessVarHandle$Type$Helper(boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask) {</span>
<span class="line-added"> 45         super(FORM, skipAlignmentMaskCheck, be, length, alignmentMask);</span>
<span class="line-added"> 46     }</span>
<span class="line-added"> 47 </span>
<span class="line-added"> 48     @Override</span>
<span class="line-added"> 49     final MethodType accessModeTypeUncached(AccessMode accessMode) {</span>
<span class="line-added"> 50         return accessMode.at.accessModeType(MemorySegmentProxy.class, $type$.class, long.class);</span>
<span class="line-added"> 51     }</span>
<span class="line-added"> 52 </span>
 53 #if[floatingPoint]
 54     @ForceInline
 55     static $rawType$ convEndian(boolean big, $type$ v) {
 56         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
 57         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 58     }
 59 
 60     @ForceInline
 61     static $type$ convEndian(boolean big, $rawType$ rv) {
 62         rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 63         return $Type$.$rawType$BitsTo$Type$(rv);
 64     }
 65 #else[floatingPoint]
 66 #if[byte]
 67     @ForceInline
 68     static $type$ convEndian(boolean big, $type$ n) {
 69         return n;
 70     }
 71 #else[byte]
 72     @ForceInline
 73     static $type$ convEndian(boolean big, $type$ n) {
 74         return big == BE ? n : $BoxType$.reverseBytes(n);
 75     }
 76 #end[byte]
 77 #end[floatingPoint]
 78 
 79     @ForceInline
<span class="line-modified"> 80     static MemorySegmentProxy checkAddress(Object obb, long offset, long length, boolean ro) {</span>
<span class="line-modified"> 81         MemorySegmentProxy oo = (MemorySegmentProxy)Objects.requireNonNull(obb);</span>
 82         oo.checkAccess(offset, length, ro);
 83         return oo;
 84     }
 85 
 86     @ForceInline
<span class="line-modified"> 87     static long offset(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {</span>
<span class="line-modified"> 88         long address = offsetNoVMAlignCheck(skipAlignmentMaskCheck, bb, offset, alignmentMask);</span>
 89         if ((address &amp; VM_ALIGN) != 0) {
 90             throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
 91         }
 92         return address;
 93     }
 94 
 95     @ForceInline
<span class="line-modified"> 96     static long offsetNoVMAlignCheck(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {</span>
 97         long base = bb.unsafeGetOffset();
 98         long address = base + offset;
<span class="line-modified"> 99         if (skipAlignmentMaskCheck) {</span>
<span class="line-modified">100             //note: the offset portion has already been aligned-checked, by construction</span>
<span class="line-modified">101             if ((base &amp; alignmentMask) != 0) {</span>
<span class="line-added">102                 throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);</span>
<span class="line-added">103             }</span>
<span class="line-added">104         } else {</span>
<span class="line-added">105             if ((address &amp; alignmentMask) != 0) {</span>
<span class="line-added">106                 throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);</span>
<span class="line-added">107             }</span>
108         }
109         return address;
110     }
111 
112     @ForceInline
<span class="line-modified">113     static $type$ get(VarHandle ob, Object obb, long base) {</span>
114         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">115         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);</span>
116 #if[floatingPoint]
117         $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
118                 bb.unsafeGetBase(),
<span class="line-modified">119                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
120                 handle.be);
121         return $Type$.$rawType$BitsTo$Type$(rawValue);
122 #else[floatingPoint]
123 #if[byte]
124         return UNSAFE.get$Type$(
125                 bb.unsafeGetBase(),
<span class="line-modified">126                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask));</span>
127 #else[byte]
128         return UNSAFE.get$Type$Unaligned(
129                 bb.unsafeGetBase(),
<span class="line-modified">130                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
131                 handle.be);
132 #end[byte]
133 #end[floatingPoint]
134     }
135 
136     @ForceInline
<span class="line-modified">137     static void set(VarHandle ob, Object obb, long base, $type$ value) {</span>
138         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">139         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
140 #if[floatingPoint]
141         UNSAFE.put$RawType$Unaligned(
142                 bb.unsafeGetBase(),
<span class="line-modified">143                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
144                 $Type$.$type$ToRaw$RawType$Bits(value),
145                 handle.be);
146 #else[floatingPoint]
147 #if[byte]
148         UNSAFE.put$Type$(
149                 bb.unsafeGetBase(),
<span class="line-modified">150                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
151                 value);
152 #else[byte]
153         UNSAFE.put$Type$Unaligned(
154                 bb.unsafeGetBase(),
<span class="line-modified">155                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
156                 value,
157                 handle.be);
158 #end[byte]
159 #end[floatingPoint]
160     }
161 
162     @ForceInline
<span class="line-modified">163     static $type$ getVolatile(VarHandle ob, Object obb, long base) {</span>
164         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">165         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);</span>
166         return convEndian(handle.be,
167                           UNSAFE.get$RawType$Volatile(
168                                   bb.unsafeGetBase(),
<span class="line-modified">169                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));</span>
170     }
171 
172     @ForceInline
<span class="line-modified">173     static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {</span>
174         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">175         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
176         UNSAFE.put$RawType$Volatile(
177                 bb.unsafeGetBase(),
<span class="line-modified">178                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
179                 convEndian(handle.be, value));
180     }
181 
182     @ForceInline
<span class="line-modified">183     static $type$ getAcquire(VarHandle ob, Object obb, long base) {</span>
184         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">185         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);</span>
186         return convEndian(handle.be,
187                           UNSAFE.get$RawType$Acquire(
188                                   bb.unsafeGetBase(),
<span class="line-modified">189                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));</span>
190     }
191 
192     @ForceInline
<span class="line-modified">193     static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {</span>
194         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">195         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
196         UNSAFE.put$RawType$Release(
197                 bb.unsafeGetBase(),
<span class="line-modified">198                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
199                 convEndian(handle.be, value));
200     }
201 
202     @ForceInline
<span class="line-modified">203     static $type$ getOpaque(VarHandle ob, Object obb, long base) {</span>
204         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">205         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);</span>
206         return convEndian(handle.be,
207                           UNSAFE.get$RawType$Opaque(
208                                   bb.unsafeGetBase(),
<span class="line-modified">209                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));</span>
210     }
211 
212     @ForceInline
<span class="line-modified">213     static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {</span>
214         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">215         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
216         UNSAFE.put$RawType$Opaque(
217                 bb.unsafeGetBase(),
<span class="line-modified">218                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
219                 convEndian(handle.be, value));
220     }
221 #if[CAS]
222 
223     @ForceInline
<span class="line-modified">224     static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
225         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">226         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
227         return UNSAFE.compareAndSet$RawType$(
228                 bb.unsafeGetBase(),
<span class="line-modified">229                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
230                 convEndian(handle.be, expected), convEndian(handle.be, value));
231     }
232 
233     @ForceInline
<span class="line-modified">234     static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
235         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">236         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
237         return convEndian(handle.be,
238                           UNSAFE.compareAndExchange$RawType$(
239                                   bb.unsafeGetBase(),
<span class="line-modified">240                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
241                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
242     }
243 
244     @ForceInline
<span class="line-modified">245     static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
246         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">247         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
248         return convEndian(handle.be,
249                           UNSAFE.compareAndExchange$RawType$Acquire(
250                                   bb.unsafeGetBase(),
<span class="line-modified">251                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
252                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
253     }
254 
255     @ForceInline
<span class="line-modified">256     static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
257         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">258         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
259         return convEndian(handle.be,
260                           UNSAFE.compareAndExchange$RawType$Release(
261                                   bb.unsafeGetBase(),
<span class="line-modified">262                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
263                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
264     }
265 
266     @ForceInline
<span class="line-modified">267     static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
268         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">269         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
270         return UNSAFE.weakCompareAndSet$RawType$Plain(
271                 bb.unsafeGetBase(),
<span class="line-modified">272                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
273                 convEndian(handle.be, expected), convEndian(handle.be, value));
274     }
275 
276     @ForceInline
<span class="line-modified">277     static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
278         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">279         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
280         return UNSAFE.weakCompareAndSet$RawType$(
281                 bb.unsafeGetBase(),
<span class="line-modified">282                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
283                 convEndian(handle.be, expected), convEndian(handle.be, value));
284     }
285 
286     @ForceInline
<span class="line-modified">287     static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
288         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">289         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
290         return UNSAFE.weakCompareAndSet$RawType$Acquire(
291                 bb.unsafeGetBase(),
<span class="line-modified">292                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
293                 convEndian(handle.be, expected), convEndian(handle.be, value));
294     }
295 
296     @ForceInline
<span class="line-modified">297     static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
298         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">299         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
300         return UNSAFE.weakCompareAndSet$RawType$Release(
301                 bb.unsafeGetBase(),
<span class="line-modified">302                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
303                 convEndian(handle.be, expected), convEndian(handle.be, value));
304     }
305 
306     @ForceInline
<span class="line-modified">307     static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {</span>
308         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">309         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
310         return convEndian(handle.be,
311                           UNSAFE.getAndSet$RawType$(
312                                   bb.unsafeGetBase(),
<span class="line-modified">313                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
314                                   convEndian(handle.be, value)));
315     }
316 
317     @ForceInline
<span class="line-modified">318     static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {</span>
319         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">320         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
321         return convEndian(handle.be,
322                           UNSAFE.getAndSet$RawType$Acquire(
323                                   bb.unsafeGetBase(),
<span class="line-modified">324                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
325                                   convEndian(handle.be, value)));
326     }
327 
328     @ForceInline
<span class="line-modified">329     static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {</span>
330         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">331         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
332         return convEndian(handle.be,
333                           UNSAFE.getAndSet$RawType$Release(
334                                   bb.unsafeGetBase(),
<span class="line-modified">335                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
336                                   convEndian(handle.be, value)));
337     }
338 #end[CAS]
339 #if[AtomicAdd]
340 
341     @ForceInline
<span class="line-modified">342     static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {</span>
343         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">344         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
345         if (handle.be == BE) {
346             return UNSAFE.getAndAdd$RawType$(
347                     bb.unsafeGetBase(),
<span class="line-modified">348                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
349                     delta);
350         } else {
<span class="line-modified">351             return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);</span>
352         }
353     }
354 
355     @ForceInline
<span class="line-modified">356     static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {</span>
357         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">358         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
359         if (handle.be == BE) {
360             return UNSAFE.getAndAdd$RawType$Acquire(
361                     bb.unsafeGetBase(),
<span class="line-modified">362                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
363                     delta);
364         } else {
<span class="line-modified">365             return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);</span>
366         }
367     }
368 
369     @ForceInline
<span class="line-modified">370     static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {</span>
371         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">372         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
373         if (handle.be == BE) {
374             return UNSAFE.getAndAdd$RawType$Release(
375                     bb.unsafeGetBase(),
<span class="line-modified">376                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
377                     delta);
378         } else {
<span class="line-modified">379             return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);</span>
380         }
381     }
382 
383     @ForceInline
<span class="line-modified">384     static $type$ getAndAddConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ delta) {</span>
385         $type$ nativeExpectedValue, expectedValue;
386         Object base = bb.unsafeGetBase();
387         do {
388             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
389             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
390         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
391                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
392         return expectedValue;
393     }
394 #end[AtomicAdd]
395 #if[Bitwise]
396 
397     @ForceInline
<span class="line-modified">398     static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {</span>
399         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">400         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
401         if (handle.be == BE) {
402             return UNSAFE.getAndBitwiseOr$RawType$(
403                     bb.unsafeGetBase(),
<span class="line-modified">404                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
405                     value);
406         } else {
<span class="line-modified">407             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
408         }
409     }
410 
411     @ForceInline
<span class="line-modified">412     static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {</span>
413         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">414         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
415         if (handle.be == BE) {
416             return UNSAFE.getAndBitwiseOr$RawType$Release(
417                     bb.unsafeGetBase(),
<span class="line-modified">418                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
419                     value);
420         } else {
<span class="line-modified">421             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
422         }
423     }
424 
425     @ForceInline
<span class="line-modified">426     static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {</span>
427         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">428         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
429         if (handle.be == BE) {
430             return UNSAFE.getAndBitwiseOr$RawType$Acquire(
431                     bb.unsafeGetBase(),
<span class="line-modified">432                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
433                     value);
434         } else {
<span class="line-modified">435             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
436         }
437     }
438 
439     @ForceInline
<span class="line-modified">440     static $type$ getAndBitwiseOrConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {</span>
441         $type$ nativeExpectedValue, expectedValue;
442         Object base = bb.unsafeGetBase();
443         do {
444             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
445             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
446         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
447                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
448         return expectedValue;
449     }
450 
451     @ForceInline
<span class="line-modified">452     static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {</span>
453         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">454         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
455         if (handle.be == BE) {
456             return UNSAFE.getAndBitwiseAnd$RawType$(
457                     bb.unsafeGetBase(),
<span class="line-modified">458                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
459                     value);
460         } else {
<span class="line-modified">461             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
462         }
463     }
464 
465     @ForceInline
<span class="line-modified">466     static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {</span>
467         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">468         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
469         if (handle.be == BE) {
470             return UNSAFE.getAndBitwiseAnd$RawType$Release(
471                     bb.unsafeGetBase(),
<span class="line-modified">472                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
473                     value);
474         } else {
<span class="line-modified">475             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
476         }
477     }
478 
479     @ForceInline
<span class="line-modified">480     static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {</span>
481         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">482         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
483         if (handle.be == BE) {
484             return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
485                     bb.unsafeGetBase(),
<span class="line-modified">486                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
487                     value);
488         } else {
<span class="line-modified">489             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
490         }
491     }
492 
493     @ForceInline
<span class="line-modified">494     static $type$ getAndBitwiseAndConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {</span>
495         $type$ nativeExpectedValue, expectedValue;
496         Object base = bb.unsafeGetBase();
497         do {
498             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
499             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
500         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
501                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
502         return expectedValue;
503     }
504 
505 
506     @ForceInline
<span class="line-modified">507     static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {</span>
508         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">509         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
510         if (handle.be == BE) {
511             return UNSAFE.getAndBitwiseXor$RawType$(
512                     bb.unsafeGetBase(),
<span class="line-modified">513                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
514                     value);
515         } else {
<span class="line-modified">516             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
517         }
518     }
519 
520     @ForceInline
<span class="line-modified">521     static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {</span>
522         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">523         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
524         if (handle.be == BE) {
525             return UNSAFE.getAndBitwiseXor$RawType$Release(
526                     bb.unsafeGetBase(),
<span class="line-modified">527                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
528                     value);
529         } else {
<span class="line-modified">530             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
531         }
532     }
533 
534     @ForceInline
<span class="line-modified">535     static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {</span>
536         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">537         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
538         if (handle.be == BE) {
539             return UNSAFE.getAndBitwiseXor$RawType$Acquire(
540                     bb.unsafeGetBase(),
<span class="line-modified">541                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
542                     value);
543         } else {
<span class="line-modified">544             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
545         }
546     }
547 
548     @ForceInline
<span class="line-modified">549     static $type$ getAndBitwiseXorConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {</span>
550         $type$ nativeExpectedValue, expectedValue;
551         Object base = bb.unsafeGetBase();
552         do {
553             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
554             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
555         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
556                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
557         return expectedValue;
558     }
559 #end[Bitwise]
560 }
</pre>
</td>
</tr>
</table>
<center><a href="VarHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaLangInvokeAccess.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -25,17 +25,17 @@
  */
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.CSupport;
-import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.ValueLayout;
-import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.misc.VM;
 import sun.invoke.util.Wrapper;
 
 import java.lang.invoke.MethodHandle;
@@ -55,12 +55,12 @@
 
     private static final MethodHandle ADDRESS_FILTER;
 
     static {
         try {
-            ADDRESS_FILTER = MethodHandles.lookup().findStatic(Utils.class, "filterAddress",
-                    MethodType.methodType(MemoryAddressProxy.class, MemoryAddress.class));
+            ADDRESS_FILTER = MethodHandles.lookup().findStatic(Utils.class, "filterSegment",
+                    MethodType.methodType(MemorySegmentProxy.class, MemorySegment.class));
         } catch (Throwable ex) {
             throw new ExceptionInInitializerError(ex);
         }
     }
 
@@ -71,10 +71,15 @@
     public static MemoryAddress alignUp(MemoryAddress ma, long alignment) {
         long offset = ma.toRawLongValue();
         return ma.addOffset(alignUp(offset, alignment) - offset);
     }
 
+    public static MemorySegment alignUp(MemorySegment ms, long alignment) {
+        long offset = ms.address().toRawLongValue();
+        return ms.asSlice(alignUp(offset, alignment) - offset);
+    }
+
     public static long bitsToBytesOrThrow(long bits, Supplier<RuntimeException> exFactory) {
         if (bits % 8 == 0) {
             return bits / 8;
         } else {
             throw exFactory.get();
@@ -85,12 +90,12 @@
         // This adaptation is required, otherwise the memory access var handle will have type MemoryAddressProxy,
         // and not MemoryAddress (which the user expects), which causes performance issues with asType() adaptations.
         return MemoryHandles.filterCoordinates(handle, 0, ADDRESS_FILTER);
     }
 
-    private static MemoryAddressProxy filterAddress(MemoryAddress addr) {
-        return (MemoryAddressImpl)addr;
+    private static MemorySegmentProxy filterSegment(MemorySegment segment) {
+        return (AbstractMemorySegmentImpl)segment;
     }
 
     public static void checkRestrictedAccess(String method) {
         switch (foreignRestrictedAccess) {
             case "deny" -> throwIllegalAccessError(foreignRestrictedAccess, method);

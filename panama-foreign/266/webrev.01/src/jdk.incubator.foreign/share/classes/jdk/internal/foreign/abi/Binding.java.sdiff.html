<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../Utils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BufferLayout.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
265         }
266         MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);
267         int[] reorder = new int[oldType.parameterCount()];
268         assert destIndex &gt; sourceIndex;
269         for (int i = 0, index = 0; i &lt; reorder.length; i++) {
270             if (i != destIndex) {
271                 reorder[i] = index++;
272             } else {
273                 reorder[i] = sourceIndex;
274             }
275         }
276         return permuteArguments(mh, newType, reorder);
277     }
278 
279     private static void checkType(Class&lt;?&gt; type) {
280         if (!type.isPrimitive() || type == void.class || type == boolean.class)
281             throw new IllegalArgumentException(&quot;Illegal type: &quot; + type);
282     }
283 
284     private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, NativeScope allocator) {
<span class="line-modified">285         MemorySegment copy = allocator.allocate(size, alignment).segment();</span>
286         copy.copyFrom(operand.asSlice(0, size));
287         return copy;
288     }
289 
290     public static Move move(VMStorage storage, Class&lt;?&gt; type) {
291         checkType(type);
292         return new Move(storage, type);
293     }
294 
295     public static Dereference dereference(long offset, Class&lt;?&gt; type) {
296         checkType(type);
297         if (offset &lt; 0)
298             throw new IllegalArgumentException(&quot;Negative offset: &quot; + offset);
299         return new Dereference(offset, type);
300     }
301 
302     public static Copy copy(MemoryLayout layout) {
303         return new Copy(layout.byteSize(), layout.byteAlignment());
304     }
305 
</pre>
<hr />
<pre>
501 
502         @Override
503         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
504             Class&lt;?&gt; actualType = stack.pop();
505             SharedUtils.checkType(actualType, MemorySegment.class);
506             Class&lt;?&gt; newType = type;
507             stack.push(newType);
508         }
509 
510         @Override
511         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
512             Class&lt;?&gt; storeType = stack.pop();
513             SharedUtils.checkType(storeType, type);
514             Class&lt;?&gt; segmentType = stack.pop();
515             SharedUtils.checkType(segmentType, MemorySegment.class);
516         }
517 
518         @Override
519         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
520             MemorySegment operand = (MemorySegment) stack.pop();
<span class="line-modified">521             MemoryAddress baseAddress = operand.address();</span>
<span class="line-removed">522             MemoryAddress readAddress = baseAddress.addOffset(offset);</span>
523             stack.push(SharedUtils.read(readAddress, type));
524         }
525 
526         @Override
527         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
528             Object value = stack.pop();
529             MemorySegment operand = (MemorySegment) stack.pop();
<span class="line-modified">530             MemoryAddress baseAddress = operand.address();</span>
<span class="line-removed">531             MemoryAddress writeAddress = baseAddress.addOffset(offset);</span>
532             SharedUtils.write(writeAddress, type, value);
533         }
534 
535         private VarHandle varHandle() {
<span class="line-modified">536             return MemoryHandles.withOffset(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), offset);</span>
537         }
538 
539         @Override
540         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
<span class="line-modified">541             MethodHandle filter = filterArguments(</span>
<span class="line-removed">542                 varHandle()</span>
543                     .toMethodHandle(VarHandle.AccessMode.GET)
<span class="line-modified">544                     .asType(methodType(type, MemoryAddress.class)), 0, MH_BASE_ADDRESS);</span>
545             return filterArguments(specializedHandle, insertPos, filter);
546         }
547 
548         @Override
549         public MethodHandle specializeBox(MethodHandle returnFilter) {
550             MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);
<span class="line-modified">551             setter = filterArguments(</span>
<span class="line-removed">552                 setter.asType(methodType(void.class, MemoryAddress.class, type)),</span>
<span class="line-removed">553                 0, MH_BASE_ADDRESS);</span>
554             return collectArguments(returnFilter, returnFilter.type().parameterCount(), setter);
555         }
556     }
557 
558     /**
559      * COPY([size], [alignment])
560      *   Creates a new MemorySegment with the given [size] and [alignment],
561      *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,
562      *     and pushes the new buffer onto the operand stack
563      */
564     public static class Copy extends Binding {
565         private final long size;
566         private final long alignment;
567 
568         private Copy(long size, long alignment) {
569             super(Tag.COPY_BUFFER);
570             this.size = size;
571             this.alignment = alignment;
572         }
573 
</pre>
<hr />
<pre>
602             return Objects.hash(tag(), size, alignment);
603         }
604 
605         @Override
606         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
607             Class&lt;?&gt; actualType = stack.pop();
608             SharedUtils.checkType(actualType, MemorySegment.class);
609             stack.push(MemorySegment.class);
610         }
611 
612         @Override
613         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
614             Class&lt;?&gt; actualType = stack.pop();
615             SharedUtils.checkType(actualType, MemoryAddress.class);
616             stack.push(MemorySegment.class);
617         }
618 
619         @Override
620         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
621             MemorySegment operand = (MemorySegment) stack.pop();
<span class="line-modified">622             MemorySegment copy = scope.allocate(size, alignment).segment();</span>
623             copy.copyFrom(operand.asSlice(0, size));
624             stack.push(copy);
625         }
626 
627         @Override
628         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
629             MemoryAddress operand = (MemoryAddress) stack.pop();
<span class="line-modified">630             operand = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);</span>
631             MemorySegment copy = MemorySegment.allocateNative(size, alignment);
<span class="line-modified">632             copy.copyFrom(operand.segment().asSlice(0, size));</span>
633             stack.push(copy); // leaked
634         }
635 
636         @Override
637         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
638             MethodHandle filter = insertArguments(MH_COPY_BUFFER, 1, size, alignment);
639             specializedHandle = collectArguments(specializedHandle, insertPos, filter);
640             return mergeArguments(specializedHandle, 0, insertPos + 1);
641         }
642 
643         @Override
644         public MethodHandle specializeBox(MethodHandle returnFilter) {
645             throw new UnsupportedOperationException();
646         }
647     }
648 
649     /**
650      * ALLOCATE([size], [alignment])
651      *   Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.
652      */
</pre>
<hr />
<pre>
752             if (this == o) return true;
753             return o != null &amp;&amp; getClass() == o.getClass();
754         }
755 
756         @Override
757         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
758             Class&lt;?&gt; actualType = stack.pop();
759             SharedUtils.checkType(actualType, MemoryAddress.class);
760             stack.push(long.class);
761         }
762 
763         @Override
764         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
765             Class&lt;?&gt; actualType = stack.pop();
766             SharedUtils.checkType(actualType, long.class);
767             stack.push(MemoryAddress.class);
768         }
769 
770         @Override
771         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
<span class="line-modified">772             stack.push(((MemoryAddress) stack.pop()).toRawLongValue());</span>
773         }
774 
775         @Override
776         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
777             stack.push(MemoryAddress.ofLong((long) stack.pop()));
778         }
779 
780         @Override
781         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
782             return filterArguments(specializedHandle, insertPos, MH_UNBOX_ADDRESS);
783         }
784 
785         @Override
786         public MethodHandle specializeBox(MethodHandle returnFilter) {
787             return filterArguments(returnFilter, 0, MH_BOX_ADDRESS);
788         }
789     }
790 
791     /**
792      * BASE_ADDRESS()
</pre>
</td>
<td>
<hr />
<pre>
265         }
266         MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);
267         int[] reorder = new int[oldType.parameterCount()];
268         assert destIndex &gt; sourceIndex;
269         for (int i = 0, index = 0; i &lt; reorder.length; i++) {
270             if (i != destIndex) {
271                 reorder[i] = index++;
272             } else {
273                 reorder[i] = sourceIndex;
274             }
275         }
276         return permuteArguments(mh, newType, reorder);
277     }
278 
279     private static void checkType(Class&lt;?&gt; type) {
280         if (!type.isPrimitive() || type == void.class || type == boolean.class)
281             throw new IllegalArgumentException(&quot;Illegal type: &quot; + type);
282     }
283 
284     private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, NativeScope allocator) {
<span class="line-modified">285         MemorySegment copy = allocator.allocate(size, alignment);</span>
286         copy.copyFrom(operand.asSlice(0, size));
287         return copy;
288     }
289 
290     public static Move move(VMStorage storage, Class&lt;?&gt; type) {
291         checkType(type);
292         return new Move(storage, type);
293     }
294 
295     public static Dereference dereference(long offset, Class&lt;?&gt; type) {
296         checkType(type);
297         if (offset &lt; 0)
298             throw new IllegalArgumentException(&quot;Negative offset: &quot; + offset);
299         return new Dereference(offset, type);
300     }
301 
302     public static Copy copy(MemoryLayout layout) {
303         return new Copy(layout.byteSize(), layout.byteAlignment());
304     }
305 
</pre>
<hr />
<pre>
501 
502         @Override
503         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
504             Class&lt;?&gt; actualType = stack.pop();
505             SharedUtils.checkType(actualType, MemorySegment.class);
506             Class&lt;?&gt; newType = type;
507             stack.push(newType);
508         }
509 
510         @Override
511         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
512             Class&lt;?&gt; storeType = stack.pop();
513             SharedUtils.checkType(storeType, type);
514             Class&lt;?&gt; segmentType = stack.pop();
515             SharedUtils.checkType(segmentType, MemorySegment.class);
516         }
517 
518         @Override
519         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
520             MemorySegment operand = (MemorySegment) stack.pop();
<span class="line-modified">521             MemorySegment readAddress = operand.asSlice(offset);</span>

522             stack.push(SharedUtils.read(readAddress, type));
523         }
524 
525         @Override
526         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
527             Object value = stack.pop();
528             MemorySegment operand = (MemorySegment) stack.pop();
<span class="line-modified">529             MemorySegment writeAddress = operand.asSlice(offset);</span>

530             SharedUtils.write(writeAddress, type, value);
531         }
532 
533         private VarHandle varHandle() {
<span class="line-modified">534             return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), 1, offset);</span>
535         }
536 
537         @Override
538         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
<span class="line-modified">539             MethodHandle filter = varHandle()</span>

540                     .toMethodHandle(VarHandle.AccessMode.GET)
<span class="line-modified">541                     .asType(methodType(type, MemorySegment.class));</span>
542             return filterArguments(specializedHandle, insertPos, filter);
543         }
544 
545         @Override
546         public MethodHandle specializeBox(MethodHandle returnFilter) {
547             MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);
<span class="line-modified">548             setter = setter.asType(methodType(void.class, MemorySegment.class, type));</span>


549             return collectArguments(returnFilter, returnFilter.type().parameterCount(), setter);
550         }
551     }
552 
553     /**
554      * COPY([size], [alignment])
555      *   Creates a new MemorySegment with the given [size] and [alignment],
556      *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,
557      *     and pushes the new buffer onto the operand stack
558      */
559     public static class Copy extends Binding {
560         private final long size;
561         private final long alignment;
562 
563         private Copy(long size, long alignment) {
564             super(Tag.COPY_BUFFER);
565             this.size = size;
566             this.alignment = alignment;
567         }
568 
</pre>
<hr />
<pre>
597             return Objects.hash(tag(), size, alignment);
598         }
599 
600         @Override
601         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
602             Class&lt;?&gt; actualType = stack.pop();
603             SharedUtils.checkType(actualType, MemorySegment.class);
604             stack.push(MemorySegment.class);
605         }
606 
607         @Override
608         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
609             Class&lt;?&gt; actualType = stack.pop();
610             SharedUtils.checkType(actualType, MemoryAddress.class);
611             stack.push(MemorySegment.class);
612         }
613 
614         @Override
615         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
616             MemorySegment operand = (MemorySegment) stack.pop();
<span class="line-modified">617             MemorySegment copy = scope.allocate(size, alignment);</span>
618             copy.copyFrom(operand.asSlice(0, size));
619             stack.push(copy);
620         }
621 
622         @Override
623         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
624             MemoryAddress operand = (MemoryAddress) stack.pop();
<span class="line-modified">625             MemorySegment segment = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);</span>
626             MemorySegment copy = MemorySegment.allocateNative(size, alignment);
<span class="line-modified">627             copy.copyFrom(segment);</span>
628             stack.push(copy); // leaked
629         }
630 
631         @Override
632         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
633             MethodHandle filter = insertArguments(MH_COPY_BUFFER, 1, size, alignment);
634             specializedHandle = collectArguments(specializedHandle, insertPos, filter);
635             return mergeArguments(specializedHandle, 0, insertPos + 1);
636         }
637 
638         @Override
639         public MethodHandle specializeBox(MethodHandle returnFilter) {
640             throw new UnsupportedOperationException();
641         }
642     }
643 
644     /**
645      * ALLOCATE([size], [alignment])
646      *   Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.
647      */
</pre>
<hr />
<pre>
747             if (this == o) return true;
748             return o != null &amp;&amp; getClass() == o.getClass();
749         }
750 
751         @Override
752         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
753             Class&lt;?&gt; actualType = stack.pop();
754             SharedUtils.checkType(actualType, MemoryAddress.class);
755             stack.push(long.class);
756         }
757 
758         @Override
759         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
760             Class&lt;?&gt; actualType = stack.pop();
761             SharedUtils.checkType(actualType, long.class);
762             stack.push(MemoryAddress.class);
763         }
764 
765         @Override
766         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
<span class="line-modified">767             stack.push(((MemoryAddress)stack.pop()).toRawLongValue());</span>
768         }
769 
770         @Override
771         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
772             stack.push(MemoryAddress.ofLong((long) stack.pop()));
773         }
774 
775         @Override
776         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
777             return filterArguments(specializedHandle, insertPos, MH_UNBOX_ADDRESS);
778         }
779 
780         @Override
781         public MethodHandle specializeBox(MethodHandle returnFilter) {
782             return filterArguments(returnFilter, 0, MH_BOX_ADDRESS);
783         }
784     }
785 
786     /**
787      * BASE_ADDRESS()
</pre>
</td>
</tr>
</table>
<center><a href="../Utils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BufferLayout.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 
 25 import jdk.incubator.foreign.MemoryAddress;
 26 import jdk.incubator.foreign.MemoryHandles;
 27 import jdk.incubator.foreign.MemoryLayout;
 28 import jdk.incubator.foreign.MemorySegment;
 29 import jdk.incubator.foreign.NativeScope;
 30 import jdk.internal.foreign.MemoryAddressImpl;
 31 
 32 import java.lang.invoke.MethodHandle;
 33 import java.lang.invoke.MethodHandles;
 34 import java.lang.invoke.MethodType;
 35 import java.util.ArrayList;
 36 import java.util.Deque;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.Objects;
 40 
 41 import java.lang.invoke.VarHandle;
 42 import java.nio.ByteOrder;
 43 import java.util.concurrent.ConcurrentHashMap;
 44 
 45 import static java.lang.invoke.MethodHandles.collectArguments;
 46 import static java.lang.invoke.MethodHandles.filterArguments;
 47 import static java.lang.invoke.MethodHandles.insertArguments;
 48 import static java.lang.invoke.MethodHandles.permuteArguments;
 49 import static java.lang.invoke.MethodType.methodType;
 50 
 51 /**
 52  * The binding operators defined in the Binding class can be combined into argument and return value processing &#39;recipes&#39;.
 53  *
 54  * The binding operators are interpreted using a stack-base interpreter. Operators can either consume operands from the
 55  * stack, or push them onto the stack.
 56  *
 57  * In the description of each binding we talk about &#39;boxing&#39; and &#39;unboxing&#39;.
 58  *  - Unboxing is the process of taking a Java value and decomposing it, and storing components into machine
 59  *    storage locations. As such, the binding interpreter stack starts with the Java value on it, and should end empty.
 60  *  - Boxing is the process of re-composing a Java value by pulling components from machine storage locations.
 61  *    If a MemorySegment is needed to store the result, one should be allocated using the ALLOCATE_BUFFER operator.
 62  *    The binding interpreter stack starts off empty, and ends with the value to be returned as the only value on it.
 63  * A binding operator can be interpreted differently based on whether we are boxing or unboxing a value. For example,
 64  * the CONVERT_ADDRESS operator &#39;unboxes&#39; a MemoryAddress to a long, but &#39;boxes&#39; a long to a MemoryAddress.
 65  *
 66  * Here are some examples of binding recipes derived from C declarations, and according to the Windows ABI (recipes are
 67  * ABI-specific). Note that each argument has it&#39;s own recipe, which is indicated by &#39;[number]:&#39; (though, the only
 68  * example that has multiple arguments is the one using varargs).
 69  *
 70  * --------------------
 71  *
 72  * void f(int i);
 73  *
 74  * Argument bindings:
 75  * 0: MOVE(rcx, int.class) // move an &#39;int&#39; into the RCX register
 76  *
 77  * Return bindings:
 78  * none
 79  *
 80  * --------------------
 81  *
 82  * void f(int* i);
 83  *
 84  * Argument bindings:
 85  * 0: CONVERT_ADDRESS // the &#39;MemoryAddress&#39; is converted into a &#39;long&#39;
 86  *    MOVE(rcx, long.class) // the &#39;long&#39; is moved into the RCX register
 87  *
 88  * Return bindings:
 89  * none
 90  *
 91  * --------------------
 92  *
 93  * int* f();
 94  *
 95  * Argument bindings:
 96  * none
 97  *
 98  * Return bindings:
 99  * 0: MOVE(rax, long) // load a &#39;long&#39; from the RAX register
100  *    CONVERT_ADDRESS // convert the &#39;long&#39; into a &#39;MemoryAddress&#39;
101  *
102  * --------------------
103  *
104  * typedef struct { // fits into single register
105  *   int x;
106  *   int y;
107  * } MyStruct;
108  *
109  * void f(MyStruct ms);
110  *
111  * Argument bindings:
112  * 0: DEREFERENCE(0, long.class) // From the struct&#39;s memory region, load a &#39;long&#39; from offset &#39;0&#39;
113  *    MOVE(rcx, long.class) // and copy that into the RCX register
114  *
115  * Return bindings:
116  * none
117  *
118  * --------------------
119  *
120  * typedef struct { // does not fit into single register
121  *   long long x;
122  *   long long y;
123  * } MyStruct;
124  *
125  * void f(MyStruct ms);
126  *
127  * For the Windows ABI:
128  *
129  * Argument bindings:
130  * 0: COPY(16, 8) // copy the memory region containing the struct
131  *    BASE_ADDRESS // take the base address of the copy
132  *    CONVERT_ADDRESS // converts the base address to a &#39;long&#39;
133  *    MOVE(rcx, long.class) // moves the &#39;long&#39; into the RCX register
134  *
135  * Return bindings:
136  * none
137  *
138  * For the SysV ABI:
139  *
140  * Argument bindings:
141  * 0: DUP // duplicates the MemoryRegion operand
142  *    DEREFERENCE(0, long.class) // loads a &#39;long&#39; from offset &#39;0&#39;
143  *    MOVE(rdx, long.class) // moves the long into the RDX register
144  *    DEREFERENCE(8, long.class) // loads a &#39;long&#39; from offset &#39;8&#39;
145  *    MOVE(rcx, long.class) // moves the long into the RCX register
146  *
147  * Return bindings:
148  * none
149  *
150  * --------------------
151  *
152  * typedef struct { // fits into single register
153  *   int x;
154  *   int y;
155  * } MyStruct;
156  *
157  * MyStruct f();
158  *
159  * Argument bindings:
160  * none
161  *
162  * Return bindings:
163  * 0: ALLOCATE(GroupLayout(C_INT, C_INT)) // allocate a buffer with the memory layout of the struct
164  *    DUP // duplicate the allocated buffer
165  *    MOVE(rax, long.class) // loads a &#39;long&#39; from rax
166  *    DEREFERENCE(0, long.class) // stores a &#39;long&#39; at offset 0
167  *
168  * --------------------
169  *
170  * typedef struct { // does not fit into single register
171  *   long long x;
172  *   long long y;
173  * } MyStruct;
174  *
175  * MyStruct f();
176  *
177  * !! uses synthetic argument, which is a pointer to a pre-allocated buffer
178  *
179  * Argument bindings:
180  * 0: CONVERT_ADDRESS // unbox the MemoryAddress synthetic argument
181  *    MOVE(rcx, long.class) // moves the &#39;long&#39; into the RCX register
182  *
183  * Return bindings:
184  * none
185  *
186  * --------------------
187  *
188  * void f(int dummy, ...); // varargs
189  *
190  * f(0, 10f); // passing a float
191  *
192  * Argument bindings:
193  * 0: MOVE(rcx, int.class) // moves the &#39;int dummy&#39; into the RCX register
194  *
195  * 1: DUP // duplicates the &#39;10f&#39; argument
196  *    MOVE(rdx, float.class) // move one copy into the RDX register
197  *    MOVE(xmm1, float.class) // moves the other copy into the xmm2 register
198  *
199  * Return bindings:
200  * none
201  *
202  * --------------------
203  */
204 public abstract class Binding {
205     private static final MethodHandle MH_UNBOX_ADDRESS;
206     private static final MethodHandle MH_BOX_ADDRESS;
207     private static final MethodHandle MH_BASE_ADDRESS;
208     private static final MethodHandle MH_COPY_BUFFER;
209     private static final MethodHandle MH_ALLOCATE_BUFFER;
210 
211     static {
212         try {
213             MethodHandles.Lookup lookup = MethodHandles.lookup();
214             MH_UNBOX_ADDRESS = lookup.findVirtual(MemoryAddress.class, &quot;toRawLongValue&quot;,
215                     methodType(long.class));
216             MH_BOX_ADDRESS = lookup.findStatic(MemoryAddress.class, &quot;ofLong&quot;,
217                     methodType(MemoryAddress.class, long.class));
218             MH_BASE_ADDRESS = lookup.findVirtual(MemorySegment.class, &quot;address&quot;,
219                     methodType(MemoryAddress.class));
220             MH_COPY_BUFFER = lookup.findStatic(Binding.class, &quot;copyBuffer&quot;,
221                     methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, NativeScope.class));
222             MH_ALLOCATE_BUFFER = lookup.findStatic(MemorySegment.class, &quot;allocateNative&quot;,
223                     methodType(MemorySegment.class, long.class, long.class));
224         } catch (ReflectiveOperationException e) {
225             throw new RuntimeException(e);
226         }
227     }
228 
229     enum Tag {
230         MOVE,
231         DEREFERENCE,
232         COPY_BUFFER,
233         ALLOC_BUFFER,
234         CONVERT_ADDRESS,
235         BASE_ADDRESS,
236         DUP
237     }
238 
239     private final Tag tag;
240 
241     private Binding(Tag tag) {
242         this.tag = tag;
243     }
244 
245     public Tag tag() {
246         return tag;
247     }
248 
249     public abstract void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack);
250     public abstract void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack);
251 
252     public abstract void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope);
253     public abstract void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc);
254 
255     public abstract MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos);
256     public abstract MethodHandle specializeBox(MethodHandle returnFilter);
257 
258     private static MethodHandle mergeArguments(MethodHandle mh, int sourceIndex, int destIndex) {
259         MethodType oldType = mh.type();
260         Class&lt;?&gt; sourceType = oldType.parameterType(sourceIndex);
261         Class&lt;?&gt; destType = oldType.parameterType(destIndex);
262         if (sourceType != destType) {
263             // TODO meet?
264             throw new IllegalArgumentException(&quot;Parameter types differ: &quot; + sourceType + &quot; != &quot; + destType);
265         }
266         MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);
267         int[] reorder = new int[oldType.parameterCount()];
268         assert destIndex &gt; sourceIndex;
269         for (int i = 0, index = 0; i &lt; reorder.length; i++) {
270             if (i != destIndex) {
271                 reorder[i] = index++;
272             } else {
273                 reorder[i] = sourceIndex;
274             }
275         }
276         return permuteArguments(mh, newType, reorder);
277     }
278 
279     private static void checkType(Class&lt;?&gt; type) {
280         if (!type.isPrimitive() || type == void.class || type == boolean.class)
281             throw new IllegalArgumentException(&quot;Illegal type: &quot; + type);
282     }
283 
284     private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, NativeScope allocator) {
<a name="1" id="anc1"></a><span class="line-modified">285         MemorySegment copy = allocator.allocate(size, alignment);</span>
286         copy.copyFrom(operand.asSlice(0, size));
287         return copy;
288     }
289 
290     public static Move move(VMStorage storage, Class&lt;?&gt; type) {
291         checkType(type);
292         return new Move(storage, type);
293     }
294 
295     public static Dereference dereference(long offset, Class&lt;?&gt; type) {
296         checkType(type);
297         if (offset &lt; 0)
298             throw new IllegalArgumentException(&quot;Negative offset: &quot; + offset);
299         return new Dereference(offset, type);
300     }
301 
302     public static Copy copy(MemoryLayout layout) {
303         return new Copy(layout.byteSize(), layout.byteAlignment());
304     }
305 
306     public static Allocate allocate(MemoryLayout layout) {
307         return new Allocate(layout.byteSize(), layout.byteAlignment());
308     }
309 
310     public static ConvertAddress convertAddress() {
311         return ConvertAddress.INSTANCE;
312     }
313 
314     public static BaseAddress baseAddress() {
315         return BaseAddress.INSTANCE;
316     }
317 
318     public static Dup dup() {
319         return Dup.INSTANCE;
320     }
321 
322 
323     public static Binding.Builder builder() {
324         return new Binding.Builder();
325     }
326 
327     /**
328      * A builder helper class for generating lists of Bindings
329      */
330     public static class Builder {
331         private final List&lt;Binding&gt; bindings = new ArrayList&lt;&gt;();
332 
333         public Binding.Builder move(VMStorage storage, Class&lt;?&gt; type) {
334             bindings.add(Binding.move(storage, type));
335             return this;
336         }
337 
338         public Binding.Builder dereference(long offset, Class&lt;?&gt; type) {
339             bindings.add(Binding.dereference(offset, type));
340             return this;
341         }
342 
343         public Binding.Builder copy(MemoryLayout layout) {
344             bindings.add(Binding.copy(layout));
345             return this;
346         }
347 
348         public Binding.Builder allocate(MemoryLayout layout) {
349             bindings.add(Binding.allocate(layout));
350             return this;
351         }
352 
353         public Binding.Builder convertAddress() {
354             bindings.add(Binding.convertAddress());
355             return this;
356         }
357 
358         public Binding.Builder baseAddress() {
359             bindings.add(Binding.baseAddress());
360             return this;
361         }
362 
363         public Binding.Builder dup() {
364             bindings.add(Binding.dup());
365             return this;
366         }
367 
368         public List&lt;Binding&gt; build() {
369             return new ArrayList&lt;&gt;(bindings);
370         }
371     }
372 
373     /**
374      * MOVE([storage location], [type])
375      *   When unboxing: pops a [type] from the operand stack, and moves it to [storage location]
376      *   When boxing: loads a [type] from [storage location], and pushes it onto the operand stack
377      * The [type] must be one of byte, short, char, int, long, float, or double
378      */
379     public static class Move extends Binding {
380         private final VMStorage storage;
381         private final Class&lt;?&gt; type;
382 
383         private Move(VMStorage storage, Class&lt;?&gt; type) {
384             super(Tag.MOVE);
385             this.storage = storage;
386             this.type = type;
387         }
388 
389         public VMStorage storage() {
390             return storage;
391         }
392 
393         public Class&lt;?&gt; type() {
394             return type;
395         }
396 
397         @Override
398         public String toString() {
399             return &quot;Move{&quot; +
400                     &quot;tag=&quot; + tag() +
401                     &quot;, storage=&quot; + storage +
402                     &quot;, type=&quot; + type +
403                     &#39;}&#39;;
404         }
405 
406         @Override
407         public boolean equals(Object o) {
408             if (this == o) return true;
409             if (o == null || getClass() != o.getClass()) return false;
410             Move move = (Move) o;
411             return storage.equals(move.storage) &amp;&amp;
412                     type.equals(move.type);
413         }
414 
415         @Override
416         public int hashCode() {
417             return Objects.hash(tag(), storage, type);
418         }
419 
420         @Override
421         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
422             Class&lt;?&gt; actualType = stack.pop();
423             Class&lt;?&gt; expectedType = type;
424             SharedUtils.checkType(actualType, expectedType);
425         }
426 
427         @Override
428         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
429             stack.push(type);
430         }
431 
432         @Override
433         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
434             storeFunc.store(storage, type, stack.pop());
435         }
436 
437         @Override
438         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
439             stack.push(loadFunc.load(storage, type));
440         }
441 
442         @Override
443         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
444             return specializedHandle; // no-op
445         }
446 
447         @Override
448         public MethodHandle specializeBox(MethodHandle returnFilter) {
449             return returnFilter; // no-op
450         }
451     }
452 
453     /**
454      * DEREFERENCE([offset into memory region], [type])
455      *   When unboxing: pops a MemorySegment from the operand stack,
456      *     loads a [type] from [offset into memory region] from it, and pushes it onto the operand stack
457      *   When boxing: pops a [type], and then a MemorySegment from the operand stack,
458      *     and then stores [type] to [offset into memory region] of the MemorySegment
459      * The [type] must be one of byte, short, char, int, long, float, or double
460      */
461     public static class Dereference extends Binding {
462         private final long offset;
463         private final Class&lt;?&gt; type;
464 
465         private Dereference(long offset, Class&lt;?&gt; type) {
466             super(Tag.DEREFERENCE);
467             this.offset = offset;
468             this.type = type;
469         }
470 
471         public long offset() {
472             return offset;
473         }
474 
475         public Class&lt;?&gt; type() {
476             return type;
477         }
478 
479         @Override
480         public String toString() {
481             return &quot;Dereference{&quot; +
482                     &quot;tag=&quot; + tag() +
483                     &quot;, offset=&quot; + offset +
484                     &quot;, type=&quot; + type +
485                     &#39;}&#39;;
486         }
487 
488         @Override
489         public boolean equals(Object o) {
490             if (this == o) return true;
491             if (o == null || getClass() != o.getClass()) return false;
492             Dereference that = (Dereference) o;
493             return offset == that.offset &amp;&amp;
494                     type.equals(that.type);
495         }
496 
497         @Override
498         public int hashCode() {
499             return Objects.hash(tag(), offset, type);
500         }
501 
502         @Override
503         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
504             Class&lt;?&gt; actualType = stack.pop();
505             SharedUtils.checkType(actualType, MemorySegment.class);
506             Class&lt;?&gt; newType = type;
507             stack.push(newType);
508         }
509 
510         @Override
511         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
512             Class&lt;?&gt; storeType = stack.pop();
513             SharedUtils.checkType(storeType, type);
514             Class&lt;?&gt; segmentType = stack.pop();
515             SharedUtils.checkType(segmentType, MemorySegment.class);
516         }
517 
518         @Override
519         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
520             MemorySegment operand = (MemorySegment) stack.pop();
<a name="2" id="anc2"></a><span class="line-modified">521             MemorySegment readAddress = operand.asSlice(offset);</span>

522             stack.push(SharedUtils.read(readAddress, type));
523         }
524 
525         @Override
526         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
527             Object value = stack.pop();
528             MemorySegment operand = (MemorySegment) stack.pop();
<a name="3" id="anc3"></a><span class="line-modified">529             MemorySegment writeAddress = operand.asSlice(offset);</span>

530             SharedUtils.write(writeAddress, type, value);
531         }
532 
533         private VarHandle varHandle() {
<a name="4" id="anc4"></a><span class="line-modified">534             return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), 1, offset);</span>
535         }
536 
537         @Override
538         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
<a name="5" id="anc5"></a><span class="line-modified">539             MethodHandle filter = varHandle()</span>

540                     .toMethodHandle(VarHandle.AccessMode.GET)
<a name="6" id="anc6"></a><span class="line-modified">541                     .asType(methodType(type, MemorySegment.class));</span>
542             return filterArguments(specializedHandle, insertPos, filter);
543         }
544 
545         @Override
546         public MethodHandle specializeBox(MethodHandle returnFilter) {
547             MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);
<a name="7" id="anc7"></a><span class="line-modified">548             setter = setter.asType(methodType(void.class, MemorySegment.class, type));</span>


549             return collectArguments(returnFilter, returnFilter.type().parameterCount(), setter);
550         }
551     }
552 
553     /**
554      * COPY([size], [alignment])
555      *   Creates a new MemorySegment with the given [size] and [alignment],
556      *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,
557      *     and pushes the new buffer onto the operand stack
558      */
559     public static class Copy extends Binding {
560         private final long size;
561         private final long alignment;
562 
563         private Copy(long size, long alignment) {
564             super(Tag.COPY_BUFFER);
565             this.size = size;
566             this.alignment = alignment;
567         }
568 
569         public long size() {
570             return size;
571         }
572 
573         public long alignment() {
574             return alignment;
575         }
576 
577         @Override
578         public String toString() {
579             return &quot;Copy{&quot; +
580                     &quot;tag=&quot; + tag() +
581                     &quot;, size=&quot; + size +
582                     &quot;, alignment=&quot; + alignment +
583                     &#39;}&#39;;
584         }
585 
586         @Override
587         public boolean equals(Object o) {
588             if (this == o) return true;
589             if (o == null || getClass() != o.getClass()) return false;
590             Copy copy = (Copy) o;
591             return size == copy.size &amp;&amp;
592                     alignment == copy.alignment;
593         }
594 
595         @Override
596         public int hashCode() {
597             return Objects.hash(tag(), size, alignment);
598         }
599 
600         @Override
601         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
602             Class&lt;?&gt; actualType = stack.pop();
603             SharedUtils.checkType(actualType, MemorySegment.class);
604             stack.push(MemorySegment.class);
605         }
606 
607         @Override
608         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
609             Class&lt;?&gt; actualType = stack.pop();
610             SharedUtils.checkType(actualType, MemoryAddress.class);
611             stack.push(MemorySegment.class);
612         }
613 
614         @Override
615         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
616             MemorySegment operand = (MemorySegment) stack.pop();
<a name="8" id="anc8"></a><span class="line-modified">617             MemorySegment copy = scope.allocate(size, alignment);</span>
618             copy.copyFrom(operand.asSlice(0, size));
619             stack.push(copy);
620         }
621 
622         @Override
623         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
624             MemoryAddress operand = (MemoryAddress) stack.pop();
<a name="9" id="anc9"></a><span class="line-modified">625             MemorySegment segment = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);</span>
626             MemorySegment copy = MemorySegment.allocateNative(size, alignment);
<a name="10" id="anc10"></a><span class="line-modified">627             copy.copyFrom(segment);</span>
628             stack.push(copy); // leaked
629         }
630 
631         @Override
632         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
633             MethodHandle filter = insertArguments(MH_COPY_BUFFER, 1, size, alignment);
634             specializedHandle = collectArguments(specializedHandle, insertPos, filter);
635             return mergeArguments(specializedHandle, 0, insertPos + 1);
636         }
637 
638         @Override
639         public MethodHandle specializeBox(MethodHandle returnFilter) {
640             throw new UnsupportedOperationException();
641         }
642     }
643 
644     /**
645      * ALLOCATE([size], [alignment])
646      *   Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.
647      */
648     public static class Allocate extends Binding {
649         private final long size;
650         private final long alignment;
651 
652         private Allocate(long size, long alignment) {
653             super(Tag.ALLOC_BUFFER);
654             this.size = size;
655             this.alignment = alignment;
656         }
657 
658         public long size() {
659             return size;
660         }
661 
662         public long alignment() {
663             return alignment;
664         }
665 
666         @Override
667         public String toString() {
668             return &quot;AllocateBuffer{&quot; +
669                     &quot;tag=&quot; + tag() +
670                     &quot;size=&quot; + size +
671                     &quot;, alignment=&quot; + alignment +
672                     &#39;}&#39;;
673         }
674 
675         @Override
676         public boolean equals(Object o) {
677             if (this == o) return true;
678             if (o == null || getClass() != o.getClass()) return false;
679             Allocate that = (Allocate) o;
680             return size == that.size &amp;&amp;
681                     alignment == that.alignment;
682         }
683 
684         @Override
685         public int hashCode() {
686             return Objects.hash(tag(), size, alignment);
687         }
688 
689         @Override
690         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
691             throw new UnsupportedOperationException();
692         }
693 
694         @Override
695         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
696             stack.push(MemorySegment.class);
697         }
698 
699         @Override
700         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
701             throw new UnsupportedOperationException();
702         }
703 
704         @Override
705         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
706             stack.push(MemorySegment.allocateNative(size, alignment));
707         }
708 
709         @Override
710         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
711             throw new UnsupportedOperationException();
712         }
713 
714         @Override
715         public MethodHandle specializeBox(MethodHandle returnFilter) {
716             return collectArguments(returnFilter, 0, insertArguments(MH_ALLOCATE_BUFFER, 0, size, alignment));
717         }
718     }
719 
720     /**
721      * CONVERT_ADDRESS()
722      *   When unboxing: pops a &#39;MemoryAddress&#39; from the operand stack, converts it to a &#39;long&#39;,
723      *     and pushes that onto the operand stack
724      *   When boxing: pops a &#39;long&#39; from the operand stack, converts it to a &#39;MemoryAddress&#39;,
725      *     and pushes that onto the operand stack
726      */
727     public static class ConvertAddress extends Binding {
728         private static final ConvertAddress INSTANCE = new ConvertAddress();
729         private ConvertAddress() {
730             super(Tag.CONVERT_ADDRESS);
731         }
732 
733         @Override
734         public String toString() {
735             return &quot;BoxAddress{&quot; +
736                     &quot;tag=&quot; + tag() +
737                     &quot;}&quot;;
738         }
739 
740         @Override
741         public int hashCode() {
742             return tag().hashCode();
743         }
744 
745         @Override
746         public boolean equals(Object o) {
747             if (this == o) return true;
748             return o != null &amp;&amp; getClass() == o.getClass();
749         }
750 
751         @Override
752         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
753             Class&lt;?&gt; actualType = stack.pop();
754             SharedUtils.checkType(actualType, MemoryAddress.class);
755             stack.push(long.class);
756         }
757 
758         @Override
759         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
760             Class&lt;?&gt; actualType = stack.pop();
761             SharedUtils.checkType(actualType, long.class);
762             stack.push(MemoryAddress.class);
763         }
764 
765         @Override
766         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
<a name="11" id="anc11"></a><span class="line-modified">767             stack.push(((MemoryAddress)stack.pop()).toRawLongValue());</span>
768         }
769 
770         @Override
771         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
772             stack.push(MemoryAddress.ofLong((long) stack.pop()));
773         }
774 
775         @Override
776         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
777             return filterArguments(specializedHandle, insertPos, MH_UNBOX_ADDRESS);
778         }
779 
780         @Override
781         public MethodHandle specializeBox(MethodHandle returnFilter) {
782             return filterArguments(returnFilter, 0, MH_BOX_ADDRESS);
783         }
784     }
785 
786     /**
787      * BASE_ADDRESS()
788      *   Pops a MemorySegment from the operand stack, and takes the base address of the segment
789      *   (the MemoryAddress that points to the start), and pushes that onto the operand stack
790      */
791     public static class BaseAddress extends Binding {
792         private static final BaseAddress INSTANCE = new BaseAddress();
793         private BaseAddress() {
794             super(Tag.BASE_ADDRESS);
795         }
796 
797         @Override
798         public String toString() {
799             return &quot;BaseAddress{&quot; +
800                     &quot;tag=&quot; + tag() +
801                     &quot;}&quot;;
802         }
803 
804         @Override
805         public int hashCode() {
806             return tag().hashCode();
807         }
808 
809         @Override
810         public boolean equals(Object o) {
811             if (this == o) return true;
812             return o != null &amp;&amp; getClass() == o.getClass();
813         }
814 
815         @Override
816         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
817             Class&lt;?&gt; actualType = stack.pop();
818             SharedUtils.checkType(actualType, MemorySegment.class);
819             stack.push(MemoryAddress.class);
820         }
821 
822         @Override
823         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
824             Class&lt;?&gt; actualType = stack.pop();
825             SharedUtils.checkType(actualType, MemorySegment.class);
826             stack.push(MemoryAddress.class);
827         }
828 
829         @Override
830         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
831             stack.push(((MemorySegment) stack.pop()).address());
832         }
833 
834         @Override
835         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
836             stack.push(((MemorySegment) stack.pop()).address());
837         }
838 
839         @Override
840         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
841             return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);
842         }
843 
844         @Override
845         public MethodHandle specializeBox(MethodHandle returnFilter) {
846             throw new UnsupportedOperationException();
847         }
848     }
849 
850     /**
851      * DUP()
852      *   Duplicates the value on the top of the operand stack (without popping it!),
853      *   and pushes the duplicate onto the operand stack
854      */
855     public static class Dup extends Binding {
856         private static final Dup INSTANCE = new Dup();
857         private Dup() {
858             super(Tag.DUP);
859         }
860 
861         @Override
862         public String toString() {
863             return &quot;Dup{&quot; +
864                     &quot;tag=&quot; + tag() +
865                     &quot;}&quot;;
866         }
867 
868         @Override
869         public int hashCode() {
870             return tag().hashCode();
871         }
872 
873         @Override
874         public boolean equals(Object o) {
875             if (this == o) return true;
876             return o != null &amp;&amp; getClass() == o.getClass();
877         }
878 
879         @Override
880         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
881             stack.push(stack.peekLast());
882         }
883 
884         @Override
885         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
886             stack.push(stack.peekLast());
887         }
888 
889         @Override
890         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
891             stack.push(stack.peekLast());
892         }
893 
894         @Override
895         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
896             stack.push(stack.peekLast());
897         }
898 
899         /*
900          * Fixes up Y-shaped data graphs (produced by DEREFERENCE):
901          *
902          * 1. DUP()
903          * 2. DEREFERENCE(0, int.class)
904          * 3. MOVE  (ignored)
905          * 4. DEREFERENCE(4, int.class)
906          * 5. MOVE  (ignored)
907          *
908          * (specialized in reverse!)
909          *
910          * 5. (int, int) -&gt; void                       insertPos = 1
911          * 4. (MemorySegment, int) -&gt; void             insertPos = 1
912          * 3. (MemorySegment, int) -&gt; void             insertPos = 0
913          * 2. (MemorySegment, MemorySegment) -&gt; void   insertPos = 0
914          * 1. (MemorySegment) -&gt; void                  insertPos = 0
915          *
916          */
917         @Override
918         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
919             return mergeArguments(specializedHandle, insertPos, insertPos + 1);
920         }
921 
922         /*
923          * Fixes up Y-shaped data graphs (produced by DEREFERENCE):
924          *
925          * 1. ALLOCATE_BUFFER(4, 4)
926          * 2. DUP
927          * 3. MOVE  (ignored)
928          * 4. DEREFERNCE(0, int.class)
929          *
930          * (specialized in reverse!)
931          *
932          * input: (MemorySegment) -&gt; MemorySegment (identity function of high-level return)
933          * 4. (MemorySegment, MemorySegment, int) -&gt; MemorySegment
934          * 3. (MemorySegment, MemorySegment, int) -&gt; MemorySegment
935          * 2. (MemorySegment, int) -&gt; MemorySegment
936          * 1. (int) -&gt; MemorySegment
937          *
938          */
939         @Override
940         public MethodHandle specializeBox(MethodHandle returnFilter) {
941             // assumes shape like: (MS, ..., MS, T) R
942             return mergeArguments(returnFilter, 0, returnFilter.type().parameterCount() - 2);
943         }
944     }
945 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
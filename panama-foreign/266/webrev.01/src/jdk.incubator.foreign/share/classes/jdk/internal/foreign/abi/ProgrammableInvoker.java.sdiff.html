<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BufferLayout.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProgrammableUpcallHandler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 
 25 import jdk.incubator.foreign.Addressable;
 26 import jdk.incubator.foreign.MemoryAddress;
 27 import jdk.incubator.foreign.MemoryHandles;

 28 import jdk.incubator.foreign.MemorySegment;
 29 import jdk.incubator.foreign.NativeScope;
 30 import jdk.internal.access.JavaLangInvokeAccess;
 31 import jdk.internal.access.SharedSecrets;
 32 import jdk.internal.foreign.MemoryAddressImpl;
 33 import jdk.internal.foreign.Utils;
 34 import jdk.internal.invoke.NativeEntryPoint;
 35 import jdk.internal.invoke.VMStorageProxy;
 36 import sun.security.action.GetPropertyAction;
 37 
 38 import java.lang.invoke.MethodHandle;
 39 import java.lang.invoke.MethodHandles;
 40 import java.lang.invoke.MethodType;
 41 import java.lang.invoke.VarHandle;
 42 import java.nio.ByteOrder;
 43 import java.util.Arrays;
 44 import java.util.List;
 45 import java.util.Map;
 46 import java.util.concurrent.ConcurrentHashMap;
 47 import java.util.stream.Collectors;
</pre>
<hr />
<pre>
 54 import static java.lang.invoke.MethodHandles.insertArguments;
 55 import static java.lang.invoke.MethodHandles.tryFinally;
 56 import static java.lang.invoke.MethodType.methodType;
 57 import static sun.security.action.GetBooleanAction.privilegedGetProperty;
 58 
 59 /**
 60  * This class implements native call invocation through a so called &#39;universal adapter&#39;. A universal adapter takes
 61  * an array of longs together with a call &#39;recipe&#39;, which is used to move the arguments in the right places as
 62  * expected by the system ABI.
 63  */
 64 public class ProgrammableInvoker {
 65     private static final boolean DEBUG =
 66         privilegedGetProperty(&quot;jdk.internal.foreign.ProgrammableInvoker.DEBUG&quot;);
 67     private static final boolean USE_SPEC = Boolean.parseBoolean(
 68         GetPropertyAction.privilegedGetProperty(&quot;jdk.internal.foreign.ProgrammableInvoker.USE_SPEC&quot;, &quot;true&quot;));
 69     private static final boolean USE_INTRINSICS = Boolean.parseBoolean(
 70         GetPropertyAction.privilegedGetProperty(&quot;jdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS&quot;, &quot;false&quot;));
 71 
 72     private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();
 73 
<span class="line-modified"> 74     private static final VarHandle VH_LONG = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());</span>
 75 
 76     private static final MethodHandle MH_INVOKE_MOVES;
 77     private static final MethodHandle MH_INVOKE_INTERP_BINDINGS;
 78 
 79     private static final MethodHandle MH_MAKE_ALLOCATOR;
 80     private static final MethodHandle MH_CLOSE_ALLOCATOR;
 81 
 82     private static final Map&lt;ABIDescriptor, Long&gt; adapterStubs = new ConcurrentHashMap&lt;&gt;();
 83 
 84     static {
 85         try {
 86             MethodHandles.Lookup lookup = MethodHandles.lookup();
 87             MH_INVOKE_MOVES = lookup.findVirtual(ProgrammableInvoker.class, &quot;invokeMoves&quot;,
 88                     methodType(Object.class, Object[].class, Binding.Move[].class, Binding.Move[].class));
 89             MH_INVOKE_INTERP_BINDINGS = lookup.findVirtual(ProgrammableInvoker.class, &quot;invokeInterpBindings&quot;,
 90                     methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class));
 91             MH_MAKE_ALLOCATOR = lookup.findStatic(NativeScope.class, &quot;boundedScope&quot;,
 92                     methodType(NativeScope.class, long.class));
 93             MH_CLOSE_ALLOCATOR = lookup.findVirtual(NativeScope.class, &quot;close&quot;,
 94                     methodType(void.class));
</pre>
<hr />
<pre>
250     }
251 
252     private Map&lt;VMStorage, Integer&gt; indexMap(Binding.Move[] moves) {
253         return IntStream.range(0, moves.length)
254                         .boxed()
255                         .collect(Collectors.toMap(i -&gt; moves[i].storage(), i -&gt; i));
256     }
257 
258     /**
259      * Does a native invocation by moving primitive values from the arg array into an intermediate buffer
260      * and calling the assembly stub that forwards arguments from the buffer to the target function
261      *
262      * @param args an array of primitive values to be copied in to the buffer
263      * @param argBindings Binding.Move values describing how arguments should be copied
264      * @param returnBindings Binding.Move values describing how return values should be copied
265      * @return null, a single primitive value, or an Object[] of primitive values
266      */
267     Object invokeMoves(Object[] args, Binding.Move[] argBindings, Binding.Move[] returnBindings) {
268         MemorySegment stackArgsSeg = null;
269         try (MemorySegment argBuffer = MemorySegment.allocateNative(layout.size, 64)) {
<span class="line-removed">270             MemoryAddress argsPtr = argBuffer.address();</span>
<span class="line-removed">271             MemoryAddress stackArgs;</span>
272             if (stackArgsBytes &gt; 0) {
273                 stackArgsSeg = MemorySegment.allocateNative(stackArgsBytes, 8);
<span class="line-removed">274                 stackArgs = stackArgsSeg.address();</span>
<span class="line-removed">275             } else {</span>
<span class="line-removed">276                 stackArgs = MemoryAddressImpl.NULL;</span>
277             }
278 
<span class="line-modified">279             VH_LONG.set(argsPtr.addOffset(layout.arguments_next_pc), addr.address().toRawLongValue());</span>
<span class="line-modified">280             VH_LONG.set(argsPtr.addOffset(layout.stack_args_bytes), stackArgsBytes);</span>
<span class="line-modified">281             VH_LONG.set(argsPtr.addOffset(layout.stack_args), stackArgs.toRawLongValue());</span>
282 
283             for (int i = 0; i &lt; argBindings.length; i++) {
284                 Binding.Move binding = argBindings[i];
285                 VMStorage storage = binding.storage();
<span class="line-modified">286                 MemoryAddress ptr = abi.arch.isStackType(storage.type())</span>
<span class="line-modified">287                     ? stackArgs.addOffset(storage.index() * abi.arch.typeSize(abi.arch.stackType()))</span>
<span class="line-modified">288                     : argsPtr.addOffset(layout.argOffset(storage));</span>
289                 SharedUtils.writeOverSized(ptr, binding.type(), args[i]);
290             }
291 
292             if (DEBUG) {
293                 System.err.println(&quot;Buffer state before:&quot;);
<span class="line-modified">294                 layout.dump(abi.arch, argsPtr, System.err);</span>
295             }
296 
<span class="line-modified">297             invokeNative(stubAddress, argsPtr.toRawLongValue());</span>
298 
299             if (DEBUG) {
300                 System.err.println(&quot;Buffer state after:&quot;);
<span class="line-modified">301                 layout.dump(abi.arch, argsPtr, System.err);</span>
302             }
303 
304             if (returnBindings.length == 0) {
305                 return null;
306             } else if (returnBindings.length == 1) {
307                 Binding.Move move = returnBindings[0];
308                 VMStorage storage = move.storage();
<span class="line-modified">309                 return SharedUtils.read(argsPtr.addOffset(layout.retOffset(storage)), move.type());</span>
310             } else { // length &gt; 1
311                 Object[] returns = new Object[returnBindings.length];
312                 for (int i = 0; i &lt; returnBindings.length; i++) {
313                     Binding.Move move = returnBindings[i];
314                     VMStorage storage = move.storage();
<span class="line-modified">315                     returns[i] = SharedUtils.read(argsPtr.addOffset(layout.retOffset(storage)), move.type());</span>
316                 }
317                 return returns;
318             }
319         } finally {
320             if (stackArgsSeg != null) {
321                 stackArgsSeg.close();
322             }
323         }
324     }
325 
326     Object invokeInterpBindings(Object[] args, MethodHandle leaf,
327                                 Map&lt;VMStorage, Integer&gt; argIndexMap,
328                                 Map&lt;VMStorage, Integer&gt; retIndexMap) throws Throwable {
329         NativeScope scope = bufferCopySize != 0 ? NativeScope.boundedScope(bufferCopySize) : null;
330         try {
331             // do argument processing, get Object[] as result
332             Object[] moves = new Object[leaf.type().parameterCount()];
333             for (int i = 0; i &lt; args.length; i++) {
334                 Object arg = args[i];
335                 BindingInterpreter.unbox(arg, callingSequence.argumentBindings(i),
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 
 25 import jdk.incubator.foreign.Addressable;
 26 import jdk.incubator.foreign.MemoryAddress;
 27 import jdk.incubator.foreign.MemoryHandles;
<span class="line-added"> 28 import jdk.incubator.foreign.MemoryLayouts;</span>
 29 import jdk.incubator.foreign.MemorySegment;
 30 import jdk.incubator.foreign.NativeScope;
 31 import jdk.internal.access.JavaLangInvokeAccess;
 32 import jdk.internal.access.SharedSecrets;
 33 import jdk.internal.foreign.MemoryAddressImpl;
 34 import jdk.internal.foreign.Utils;
 35 import jdk.internal.invoke.NativeEntryPoint;
 36 import jdk.internal.invoke.VMStorageProxy;
 37 import sun.security.action.GetPropertyAction;
 38 
 39 import java.lang.invoke.MethodHandle;
 40 import java.lang.invoke.MethodHandles;
 41 import java.lang.invoke.MethodType;
 42 import java.lang.invoke.VarHandle;
 43 import java.nio.ByteOrder;
 44 import java.util.Arrays;
 45 import java.util.List;
 46 import java.util.Map;
 47 import java.util.concurrent.ConcurrentHashMap;
 48 import java.util.stream.Collectors;
</pre>
<hr />
<pre>
 55 import static java.lang.invoke.MethodHandles.insertArguments;
 56 import static java.lang.invoke.MethodHandles.tryFinally;
 57 import static java.lang.invoke.MethodType.methodType;
 58 import static sun.security.action.GetBooleanAction.privilegedGetProperty;
 59 
 60 /**
 61  * This class implements native call invocation through a so called &#39;universal adapter&#39;. A universal adapter takes
 62  * an array of longs together with a call &#39;recipe&#39;, which is used to move the arguments in the right places as
 63  * expected by the system ABI.
 64  */
 65 public class ProgrammableInvoker {
 66     private static final boolean DEBUG =
 67         privilegedGetProperty(&quot;jdk.internal.foreign.ProgrammableInvoker.DEBUG&quot;);
 68     private static final boolean USE_SPEC = Boolean.parseBoolean(
 69         GetPropertyAction.privilegedGetProperty(&quot;jdk.internal.foreign.ProgrammableInvoker.USE_SPEC&quot;, &quot;true&quot;));
 70     private static final boolean USE_INTRINSICS = Boolean.parseBoolean(
 71         GetPropertyAction.privilegedGetProperty(&quot;jdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS&quot;, &quot;false&quot;));
 72 
 73     private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();
 74 
<span class="line-modified"> 75     private static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);</span>
 76 
 77     private static final MethodHandle MH_INVOKE_MOVES;
 78     private static final MethodHandle MH_INVOKE_INTERP_BINDINGS;
 79 
 80     private static final MethodHandle MH_MAKE_ALLOCATOR;
 81     private static final MethodHandle MH_CLOSE_ALLOCATOR;
 82 
 83     private static final Map&lt;ABIDescriptor, Long&gt; adapterStubs = new ConcurrentHashMap&lt;&gt;();
 84 
 85     static {
 86         try {
 87             MethodHandles.Lookup lookup = MethodHandles.lookup();
 88             MH_INVOKE_MOVES = lookup.findVirtual(ProgrammableInvoker.class, &quot;invokeMoves&quot;,
 89                     methodType(Object.class, Object[].class, Binding.Move[].class, Binding.Move[].class));
 90             MH_INVOKE_INTERP_BINDINGS = lookup.findVirtual(ProgrammableInvoker.class, &quot;invokeInterpBindings&quot;,
 91                     methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class));
 92             MH_MAKE_ALLOCATOR = lookup.findStatic(NativeScope.class, &quot;boundedScope&quot;,
 93                     methodType(NativeScope.class, long.class));
 94             MH_CLOSE_ALLOCATOR = lookup.findVirtual(NativeScope.class, &quot;close&quot;,
 95                     methodType(void.class));
</pre>
<hr />
<pre>
251     }
252 
253     private Map&lt;VMStorage, Integer&gt; indexMap(Binding.Move[] moves) {
254         return IntStream.range(0, moves.length)
255                         .boxed()
256                         .collect(Collectors.toMap(i -&gt; moves[i].storage(), i -&gt; i));
257     }
258 
259     /**
260      * Does a native invocation by moving primitive values from the arg array into an intermediate buffer
261      * and calling the assembly stub that forwards arguments from the buffer to the target function
262      *
263      * @param args an array of primitive values to be copied in to the buffer
264      * @param argBindings Binding.Move values describing how arguments should be copied
265      * @param returnBindings Binding.Move values describing how return values should be copied
266      * @return null, a single primitive value, or an Object[] of primitive values
267      */
268     Object invokeMoves(Object[] args, Binding.Move[] argBindings, Binding.Move[] returnBindings) {
269         MemorySegment stackArgsSeg = null;
270         try (MemorySegment argBuffer = MemorySegment.allocateNative(layout.size, 64)) {


271             if (stackArgsBytes &gt; 0) {
272                 stackArgsSeg = MemorySegment.allocateNative(stackArgsBytes, 8);



273             }
274 
<span class="line-modified">275             VH_LONG.set(argBuffer.asSlice(layout.arguments_next_pc), addr.address().toRawLongValue());</span>
<span class="line-modified">276             VH_LONG.set(argBuffer.asSlice(layout.stack_args_bytes), stackArgsBytes);</span>
<span class="line-modified">277             VH_LONG.set(argBuffer.asSlice(layout.stack_args), stackArgsSeg == null ? 0L : stackArgsSeg.address().toRawLongValue());</span>
278 
279             for (int i = 0; i &lt; argBindings.length; i++) {
280                 Binding.Move binding = argBindings[i];
281                 VMStorage storage = binding.storage();
<span class="line-modified">282                 MemorySegment ptr = abi.arch.isStackType(storage.type())</span>
<span class="line-modified">283                     ? stackArgsSeg.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))</span>
<span class="line-modified">284                     : argBuffer.asSlice(layout.argOffset(storage));</span>
285                 SharedUtils.writeOverSized(ptr, binding.type(), args[i]);
286             }
287 
288             if (DEBUG) {
289                 System.err.println(&quot;Buffer state before:&quot;);
<span class="line-modified">290                 layout.dump(abi.arch, argBuffer, System.err);</span>
291             }
292 
<span class="line-modified">293             invokeNative(stubAddress, argBuffer.address().toRawLongValue());</span>
294 
295             if (DEBUG) {
296                 System.err.println(&quot;Buffer state after:&quot;);
<span class="line-modified">297                 layout.dump(abi.arch, argBuffer, System.err);</span>
298             }
299 
300             if (returnBindings.length == 0) {
301                 return null;
302             } else if (returnBindings.length == 1) {
303                 Binding.Move move = returnBindings[0];
304                 VMStorage storage = move.storage();
<span class="line-modified">305                 return SharedUtils.read(argBuffer.asSlice(layout.retOffset(storage)), move.type());</span>
306             } else { // length &gt; 1
307                 Object[] returns = new Object[returnBindings.length];
308                 for (int i = 0; i &lt; returnBindings.length; i++) {
309                     Binding.Move move = returnBindings[i];
310                     VMStorage storage = move.storage();
<span class="line-modified">311                     returns[i] = SharedUtils.read(argBuffer.asSlice(layout.retOffset(storage)), move.type());</span>
312                 }
313                 return returns;
314             }
315         } finally {
316             if (stackArgsSeg != null) {
317                 stackArgsSeg.close();
318             }
319         }
320     }
321 
322     Object invokeInterpBindings(Object[] args, MethodHandle leaf,
323                                 Map&lt;VMStorage, Integer&gt; argIndexMap,
324                                 Map&lt;VMStorage, Integer&gt; retIndexMap) throws Throwable {
325         NativeScope scope = bufferCopySize != 0 ? NativeScope.boundedScope(bufferCopySize) : null;
326         try {
327             // do argument processing, get Object[] as result
328             Object[] moves = new Object[leaf.type().parameterCount()];
329             for (int i = 0; i &lt; args.length; i++) {
330                 Object arg = args[i];
331                 BindingInterpreter.unbox(arg, callingSequence.argumentBindings(i),
</pre>
</td>
</tr>
</table>
<center><a href="BufferLayout.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProgrammableUpcallHandler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
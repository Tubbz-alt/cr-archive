diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -35,21 +35,19 @@
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.NativeScope;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.MemoryAddressImpl;
-import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.aarch64.AArch64Linker;
 import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;
 import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
 import java.nio.charset.Charset;
 import java.util.List;
 import java.util.function.Consumer;
 import java.util.stream.IntStream;
 
@@ -64,18 +62,10 @@
 
     private static final MethodHandle MH_ALLOC_BUFFER;
     private static final MethodHandle MH_BASEADDRESS;
     private static final MethodHandle MH_BUFFER_COPY;
 
-    private static final VarHandle VH_BYTE = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_CHAR = MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_SHORT = MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_INT = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_LONG = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_FLOAT = MemoryHandles.varHandle(float.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_DOUBLE = MemoryHandles.varHandle(double.class, ByteOrder.nativeOrder());
-
     static {
         try {
             var lookup = MethodHandles.lookup();
             MH_ALLOC_BUFFER = lookup.findStatic(SharedUtils.class, "allocateNative",
                     methodType(MemorySegment.class, MemoryLayout.class));
@@ -196,12 +186,11 @@
 
         return target;
     }
 
     private static MemoryAddress bufferCopy(MemoryAddress dest, MemorySegment buffer) {
-        MemoryAddressImpl.ofLongUnchecked(dest.toRawLongValue(), buffer.byteSize())
-                .segment().copyFrom(buffer);
+        MemoryAddressImpl.ofLongUnchecked(dest.toRawLongValue(), buffer.byteSize()).copyFrom(buffer);
         return dest;
     }
 
     public static void checkCompatibleType(Class<?> carrier, MemoryLayout layout, long addressSize) {
         if (carrier.isPrimitive()) {
@@ -258,22 +247,22 @@
             return AArch64Linker.getInstance();
         }
         throw new UnsupportedOperationException("Unsupported os or arch: " + os + ", " + arch);
     }
 
-    public static String toJavaStringInternal(MemoryAddress addr, Charset charset) {
-        int len = strlen(addr);
+    public static String toJavaStringInternal(MemorySegment segment, long start, Charset charset) {
+        int len = strlen(segment, start);
         byte[] bytes = new byte[len];
         MemorySegment.ofArray(bytes)
-                .copyFrom(NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, len, null, null, null));
+                .copyFrom(segment.asSlice(start, len));
         return new String(bytes, charset);
     }
 
-    private static int strlen(MemoryAddress address) {
+    private static int strlen(MemorySegment segment, long start) {
         // iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)
         for (int offset = 0; offset >= 0; offset++) {
-            byte curr = MemoryAccess.getByteAtOffset(address, offset);
+            byte curr = MemoryAccess.getByteAtOffset(segment, start + offset);
             if (curr == 0) {
                 return offset;
             }
         }
         throw new IllegalArgumentException("String too large");
@@ -367,11 +356,11 @@
         }
 
         MemorySegment allocate(long size, long align);
 
         static Allocator ofScope(NativeScope scope) {
-            return (size, align) -> scope.allocate(size, align).segment();
+            return scope::allocate;
         }
     }
 
     public static class SimpleVaArg {
         public final Class<?> carrier;
@@ -462,66 +451,66 @@
         public MemoryAddress address() {
             return address;
         }
     }
 
-    static void writeOverSized(MemoryAddress ptr, Class<?> type, Object o) {
+    static void writeOverSized(MemorySegment ptr, Class<?> type, Object o) {
         // use VH_LONG for integers to zero out the whole register in the process
         if (type == long.class) {
-            VH_LONG.set(ptr, (long) o);
+            MemoryAccess.setLong(ptr, (long) o);
         } else if (type == int.class) {
-            VH_LONG.set(ptr, (long) (int) o);
+            MemoryAccess.setLong(ptr, (int) o);
         } else if (type == short.class) {
-            VH_LONG.set(ptr, (long) (short) o);
+            MemoryAccess.setLong(ptr, (short) o);
         } else if (type == char.class) {
-            VH_LONG.set(ptr, (long) (char) o);
+            MemoryAccess.setLong(ptr, (char) o);
         } else if (type == byte.class) {
-            VH_LONG.set(ptr, (long) (byte) o);
+            MemoryAccess.setLong(ptr, (byte) o);
         } else if (type == float.class) {
-            VH_FLOAT.set(ptr, (float) o);
+            MemoryAccess.setFloat(ptr, (float) o);
         } else if (type == double.class) {
-            VH_DOUBLE.set(ptr, (double) o);
+            MemoryAccess.setDouble(ptr, (double) o);
         } else {
             throw new IllegalArgumentException("Unsupported carrier: " + type);
         }
     }
 
-    static void write(MemoryAddress ptr, Class<?> type, Object o) {
+    static void write(MemorySegment ptr, Class<?> type, Object o) {
         if (type == long.class) {
-            VH_LONG.set(ptr, (long) o);
+            MemoryAccess.setLong(ptr, (long) o);
         } else if (type == int.class) {
-            VH_INT.set(ptr, (int) o);
+            MemoryAccess.setInt(ptr, (int) o);
         } else if (type == short.class) {
-            VH_SHORT.set(ptr, (short) o);
+            MemoryAccess.setShort(ptr, (short) o);
         } else if (type == char.class) {
-            VH_CHAR.set(ptr, (char) o);
+            MemoryAccess.setChar(ptr, (char) o);
         } else if (type == byte.class) {
-            VH_BYTE.set(ptr, (byte) o);
+            MemoryAccess.setByte(ptr, (byte) o);
         } else if (type == float.class) {
-            VH_FLOAT.set(ptr, (float) o);
+            MemoryAccess.setFloat(ptr, (float) o);
         } else if (type == double.class) {
-            VH_DOUBLE.set(ptr, (double) o);
+            MemoryAccess.setDouble(ptr, (double) o);
         } else {
             throw new IllegalArgumentException("Unsupported carrier: " + type);
         }
     }
 
-    static Object read(MemoryAddress ptr, Class<?> type) {
+    static Object read(MemorySegment ptr, Class<?> type) {
         if (type == long.class) {
-            return (long) VH_LONG.get(ptr);
+            return MemoryAccess.getLong(ptr);
         } else if (type == int.class) {
-            return (int) VH_INT.get(ptr);
+            return MemoryAccess.getInt(ptr);
         } else if (type == short.class) {
-            return (short) VH_SHORT.get(ptr);
+            return MemoryAccess.getShort(ptr);
         } else if (type == char.class) {
-            return (char) VH_CHAR.get(ptr);
+            return MemoryAccess.getChar(ptr);
         } else if (type == byte.class) {
-            return (byte) VH_BYTE.get(ptr);
+            return MemoryAccess.getByte(ptr);
         } else if (type == float.class) {
-            return (float) VH_FLOAT.get(ptr);
+            return MemoryAccess.getFloat(ptr);
         } else if (type == double.class) {
-            return (double) VH_DOUBLE.get(ptr);
+            return MemoryAccess.getDouble(ptr);
         } else {
             throw new IllegalArgumentException("Unsupported carrier: " + type);
         }
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../incubator/foreign/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="AbstractNativeScope.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 86     abstract long min();
 87 
 88     abstract Object base();
 89 
 90     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);
 91 
 92     abstract ByteBuffer makeByteBuffer();
 93 
 94     static int defaultAccessModes(long size) {
 95         return (enableSmallSegments &amp;&amp; size &lt; Integer.MAX_VALUE) ?
 96                 ALL_ACCESS | SMALL :
 97                 ALL_ACCESS;
 98     }
 99 
100     @Override
101     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
102         checkBounds(offset, newSize);
103         return asSliceNoCheck(offset, newSize);
104     }
105 






106     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
107         return dup(offset, newSize, mask, scope);
108     }
109 
110     @SuppressWarnings(&quot;unchecked&quot;)
111     public static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout sequenceLayout) {
112         ((AbstractMemorySegmentImpl)segment).checkValidState();
113         if (sequenceLayout.byteSize() != segment.byteSize()) {
114             throw new IllegalArgumentException();
115         }
116         return (Spliterator&lt;S&gt;)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
117                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
118     }
119 
120     @Override
121     public final MemorySegment fill(byte value){
<span class="line-modified">122         checkRange(0, length, true);</span>
123         UNSAFE.setMemory(base(), min(), length, value);
124         return this;
125     }
126 
127     public void copyFrom(MemorySegment src) {
128         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
129         long size = that.byteSize();
<span class="line-modified">130         checkRange(0, size, true);</span>
<span class="line-modified">131         that.checkRange(0, size, false);</span>
132         UNSAFE.copyMemory(
133                 that.base(), that.min(),
134                 base(), min(), size);
135     }
136 
137     public void copyFromSwap(MemorySegment src, long elemSize) {
138         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
139         long size = that.byteSize();
<span class="line-modified">140         checkRange(0, size, true);</span>
<span class="line-modified">141         that.checkRange(0, size, false);</span>
142         UNSAFE.copySwapMemory(
143                 that.base(), that.min(),
144                 base(), min(), size, elemSize);
145     }
146 
147     private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
148             .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
149 
150     @Override
151     public long mismatch(MemorySegment other) {
152         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
153         final long thisSize = this.byteSize();
154         final long thatSize = that.byteSize();
155         final long length = Math.min(thisSize, thatSize);
<span class="line-modified">156         this.checkRange(0, length, false);</span>
<span class="line-modified">157         that.checkRange(0, length, false);</span>
158         if (this == other) {
159             return -1;
160         }
161 
162         long i = 0;
163         if (length &gt; 7) {
<span class="line-modified">164             if ((byte) BYTE_HANDLE.get(this.address(), 0) != (byte) BYTE_HANDLE.get(that.address(), 0)) {</span>
165                 return 0;
166             }
167             i = ArraysSupport.vectorizedMismatchLargeForBytes(
168                     this.base(), this.min(),
169                     that.base(), that.min(),
170                     length);
171             if (i &gt;= 0) {
172                 return i;
173             }
174             long remaining = ~i;
175             assert remaining &lt; 8 : &quot;remaining greater than 7: &quot; + remaining;
176             i = length - remaining;
177         }
<span class="line-removed">178         MemoryAddress thisAddress = this.address();</span>
<span class="line-removed">179         MemoryAddress thatAddress = that.address();</span>
180         for (; i &lt; length; i++) {
<span class="line-modified">181             if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {</span>
182                 return i;
183             }
184         }
185         return thisSize != thatSize ? length : -1;
186     }
187 
188     @Override
189     @ForceInline
190     public final MemoryAddress address() {
<span class="line-modified">191         return new MemoryAddressImpl(this, 0);</span>

192     }
193 
194     @Override
195     public final ByteBuffer asByteBuffer() {
196         if (!isSet(READ)) {
197             throw unsupportedAccessMode(READ);
198         }
199         checkArraySize(&quot;ByteBuffer&quot;, 1);
200         ByteBuffer _bb = makeByteBuffer();
201         if (!isSet(WRITE)) {
202             //scope is IMMUTABLE - obtain a RO byte buffer
203             _bb = _bb.asReadOnlyBuffer();
204         }
205         return _bb;
206     }
207 
208     @Override
209     public final int accessModes() {
210         return mask &amp; ALL_ACCESS;
211     }
</pre>
<hr />
<pre>
313     }
314 
315     @Override
316     public final long[] toLongArray() {
317         return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);
318     }
319 
320     @Override
321     public final double[] toDoubleArray() {
322         return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);
323     }
324 
325     private &lt;Z&gt; Z toArray(Class&lt;Z&gt; arrayClass, int elemSize, IntFunction&lt;Z&gt; arrayFactory, Function&lt;Z, MemorySegment&gt; segmentFactory) {
326         int size = checkArraySize(arrayClass.getSimpleName(), elemSize);
327         Z arr = arrayFactory.apply(size);
328         MemorySegment arrSegment = segmentFactory.apply(arr);
329         arrSegment.copyFrom(this);
330         return arr;
331     }
332 
<span class="line-modified">333     boolean isSmall() {</span>

334         return isSet(SMALL);
335     }
336 
<span class="line-modified">337     void checkRange(long offset, long length, boolean writeAccess) {</span>

338         scope.checkValidState();
<span class="line-modified">339         if (writeAccess &amp;&amp; !isSet(WRITE)) {</span>
340             throw unsupportedAccessMode(WRITE);
<span class="line-modified">341         } else if (!writeAccess &amp;&amp; !isSet(READ)) {</span>
342             throw unsupportedAccessMode(READ);
343         }
344         checkBounds(offset, length);
345     }
346 










347     @Override
348     public final void checkValidState() {
349         scope.checkValidState();
350     }
351 
352     // Helper methods
353 
354     private boolean isSet(int mask) {
355         return (this.mask &amp; mask) != 0;
356     }
357 
358     private int checkArraySize(String typeName, int elemSize) {
359         if (length % elemSize != 0) {
360             throw new UnsupportedOperationException(String.format(&quot;Segment size is not a multiple of %d. Size: %d&quot;, elemSize, length));
361         }
362         long arraySize = length / elemSize;
363         if (arraySize &gt; (Integer.MAX_VALUE - 8)) { //conservative check
364             throw new UnsupportedOperationException(String.format(&quot;Segment is too large to wrap as %s. Size: %d&quot;, typeName, length));
365         }
366         return (int)arraySize;
</pre>
<hr />
<pre>
551         ByteBuffer makeByteBuffer() {
552             throw new UnsupportedOperationException();
553         }
554 
555         @Override
556         long min() {
557             return 0;
558         }
559 
560         @Override
561         Object base() {
562             return null;
563         }
564 
565         @Override
566         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
567             throw new UnsupportedOperationException();
568         }
569     };
570 
<span class="line-removed">571     public static final AbstractMemorySegmentImpl EVERYTHING = new AbstractMemorySegmentImpl(</span>
<span class="line-removed">572             Long.MAX_VALUE, READ | WRITE, MemoryScope.createUnchecked(null, null, null)</span>
<span class="line-removed">573     ) {</span>
<span class="line-removed">574         @Override</span>
<span class="line-removed">575         ByteBuffer makeByteBuffer() {</span>
<span class="line-removed">576             throw new UnsupportedOperationException();</span>
<span class="line-removed">577         }</span>
<span class="line-removed">578 </span>
<span class="line-removed">579         @Override</span>
<span class="line-removed">580         long min() {</span>
<span class="line-removed">581             return 0;</span>
<span class="line-removed">582         }</span>
<span class="line-removed">583 </span>
<span class="line-removed">584         @Override</span>
<span class="line-removed">585         Object base() {</span>
<span class="line-removed">586             return null;</span>
<span class="line-removed">587         }</span>
<span class="line-removed">588 </span>
<span class="line-removed">589         @Override</span>
<span class="line-removed">590         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {</span>
<span class="line-removed">591             throw new UnsupportedOperationException();</span>
<span class="line-removed">592         }</span>
<span class="line-removed">593     };</span>
594 }
</pre>
</td>
<td>
<hr />
<pre>
 86     abstract long min();
 87 
 88     abstract Object base();
 89 
 90     abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);
 91 
 92     abstract ByteBuffer makeByteBuffer();
 93 
 94     static int defaultAccessModes(long size) {
 95         return (enableSmallSegments &amp;&amp; size &lt; Integer.MAX_VALUE) ?
 96                 ALL_ACCESS | SMALL :
 97                 ALL_ACCESS;
 98     }
 99 
100     @Override
101     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
102         checkBounds(offset, newSize);
103         return asSliceNoCheck(offset, newSize);
104     }
105 
<span class="line-added">106     @Override</span>
<span class="line-added">107     public AbstractMemorySegmentImpl asSlice(long offset) {</span>
<span class="line-added">108         checkBounds(offset, 0);</span>
<span class="line-added">109         return asSliceNoCheck(offset, length - offset);</span>
<span class="line-added">110     }</span>
<span class="line-added">111 </span>
112     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
113         return dup(offset, newSize, mask, scope);
114     }
115 
116     @SuppressWarnings(&quot;unchecked&quot;)
117     public static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout sequenceLayout) {
118         ((AbstractMemorySegmentImpl)segment).checkValidState();
119         if (sequenceLayout.byteSize() != segment.byteSize()) {
120             throw new IllegalArgumentException();
121         }
122         return (Spliterator&lt;S&gt;)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
123                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
124     }
125 
126     @Override
127     public final MemorySegment fill(byte value){
<span class="line-modified">128         checkAccess(0, length, false);</span>
129         UNSAFE.setMemory(base(), min(), length, value);
130         return this;
131     }
132 
133     public void copyFrom(MemorySegment src) {
134         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
135         long size = that.byteSize();
<span class="line-modified">136         checkAccess(0, size, false);</span>
<span class="line-modified">137         that.checkAccess(0, size, true);</span>
138         UNSAFE.copyMemory(
139                 that.base(), that.min(),
140                 base(), min(), size);
141     }
142 
143     public void copyFromSwap(MemorySegment src, long elemSize) {
144         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
145         long size = that.byteSize();
<span class="line-modified">146         checkAccess(0, size, true);</span>
<span class="line-modified">147         that.checkAccess(0, size, false);</span>
148         UNSAFE.copySwapMemory(
149                 that.base(), that.min(),
150                 base(), min(), size, elemSize);
151     }
152 
153     private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
154             .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
155 
156     @Override
157     public long mismatch(MemorySegment other) {
158         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
159         final long thisSize = this.byteSize();
160         final long thatSize = that.byteSize();
161         final long length = Math.min(thisSize, thatSize);
<span class="line-modified">162         this.checkAccess(0, length, true);</span>
<span class="line-modified">163         that.checkAccess(0, length, true);</span>
164         if (this == other) {
165             return -1;
166         }
167 
168         long i = 0;
169         if (length &gt; 7) {
<span class="line-modified">170             if ((byte) BYTE_HANDLE.get(this, 0) != (byte) BYTE_HANDLE.get(that, 0)) {</span>
171                 return 0;
172             }
173             i = ArraysSupport.vectorizedMismatchLargeForBytes(
174                     this.base(), this.min(),
175                     that.base(), that.min(),
176                     length);
177             if (i &gt;= 0) {
178                 return i;
179             }
180             long remaining = ~i;
181             assert remaining &lt; 8 : &quot;remaining greater than 7: &quot; + remaining;
182             i = length - remaining;
183         }


184         for (; i &lt; length; i++) {
<span class="line-modified">185             if ((byte) BYTE_HANDLE.get(this, i) != (byte) BYTE_HANDLE.get(that, i)) {</span>
186                 return i;
187             }
188         }
189         return thisSize != thatSize ? length : -1;
190     }
191 
192     @Override
193     @ForceInline
194     public final MemoryAddress address() {
<span class="line-modified">195         checkValidState();</span>
<span class="line-added">196         return new MemoryAddressImpl(base(), min());</span>
197     }
198 
199     @Override
200     public final ByteBuffer asByteBuffer() {
201         if (!isSet(READ)) {
202             throw unsupportedAccessMode(READ);
203         }
204         checkArraySize(&quot;ByteBuffer&quot;, 1);
205         ByteBuffer _bb = makeByteBuffer();
206         if (!isSet(WRITE)) {
207             //scope is IMMUTABLE - obtain a RO byte buffer
208             _bb = _bb.asReadOnlyBuffer();
209         }
210         return _bb;
211     }
212 
213     @Override
214     public final int accessModes() {
215         return mask &amp; ALL_ACCESS;
216     }
</pre>
<hr />
<pre>
318     }
319 
320     @Override
321     public final long[] toLongArray() {
322         return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);
323     }
324 
325     @Override
326     public final double[] toDoubleArray() {
327         return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);
328     }
329 
330     private &lt;Z&gt; Z toArray(Class&lt;Z&gt; arrayClass, int elemSize, IntFunction&lt;Z&gt; arrayFactory, Function&lt;Z, MemorySegment&gt; segmentFactory) {
331         int size = checkArraySize(arrayClass.getSimpleName(), elemSize);
332         Z arr = arrayFactory.apply(size);
333         MemorySegment arrSegment = segmentFactory.apply(arr);
334         arrSegment.copyFrom(this);
335         return arr;
336     }
337 
<span class="line-modified">338     @Override</span>
<span class="line-added">339     public boolean isSmall() {</span>
340         return isSet(SMALL);
341     }
342 
<span class="line-modified">343     @Override</span>
<span class="line-added">344     public void checkAccess(long offset, long length, boolean readOnly) {</span>
345         scope.checkValidState();
<span class="line-modified">346         if (!readOnly &amp;&amp; !isSet(WRITE)) {</span>
347             throw unsupportedAccessMode(WRITE);
<span class="line-modified">348         } else if (readOnly &amp;&amp; !isSet(READ)) {</span>
349             throw unsupportedAccessMode(READ);
350         }
351         checkBounds(offset, length);
352     }
353 
<span class="line-added">354     @Override</span>
<span class="line-added">355     public long unsafeGetOffset() {</span>
<span class="line-added">356         return min();</span>
<span class="line-added">357     }</span>
<span class="line-added">358 </span>
<span class="line-added">359     @Override</span>
<span class="line-added">360     public Object unsafeGetBase() {</span>
<span class="line-added">361         return base();</span>
<span class="line-added">362     }</span>
<span class="line-added">363 </span>
364     @Override
365     public final void checkValidState() {
366         scope.checkValidState();
367     }
368 
369     // Helper methods
370 
371     private boolean isSet(int mask) {
372         return (this.mask &amp; mask) != 0;
373     }
374 
375     private int checkArraySize(String typeName, int elemSize) {
376         if (length % elemSize != 0) {
377             throw new UnsupportedOperationException(String.format(&quot;Segment size is not a multiple of %d. Size: %d&quot;, elemSize, length));
378         }
379         long arraySize = length / elemSize;
380         if (arraySize &gt; (Integer.MAX_VALUE - 8)) { //conservative check
381             throw new UnsupportedOperationException(String.format(&quot;Segment is too large to wrap as %s. Size: %d&quot;, typeName, length));
382         }
383         return (int)arraySize;
</pre>
<hr />
<pre>
568         ByteBuffer makeByteBuffer() {
569             throw new UnsupportedOperationException();
570         }
571 
572         @Override
573         long min() {
574             return 0;
575         }
576 
577         @Override
578         Object base() {
579             return null;
580         }
581 
582         @Override
583         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
584             throw new UnsupportedOperationException();
585         }
586     };
587 























588 }
</pre>
</td>
</tr>
</table>
<center><a href="../../incubator/foreign/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="AbstractNativeScope.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
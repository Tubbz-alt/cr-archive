<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestMemoryAccess.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="TestLayouts.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestMemoryAlignment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestMemoryAccess.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess
 27  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess
 28  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess
 29  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess
 30  */
 31 
 32 import jdk.incubator.foreign.GroupLayout;
 33 import jdk.incubator.foreign.MemoryLayouts;
 34 import jdk.incubator.foreign.MemoryLayout;
 35 import jdk.incubator.foreign.MemoryLayout.PathElement;
 36 import jdk.incubator.foreign.MemorySegment;
 37 import jdk.incubator.foreign.SequenceLayout;
 38 import jdk.incubator.foreign.ValueLayout;
<span class="line-modified"> 39 import jdk.incubator.foreign.MemoryAddress;</span>
 40 import java.lang.invoke.VarHandle;
 41 import java.util.function.Function;
 42 
 43 import org.testng.annotations.*;
 44 import static org.testng.Assert.*;
 45 
 46 public class TestMemoryAccess {
 47 
 48     @Test(dataProvider = &quot;elements&quot;)
 49     public void testAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, ValueLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 50         ValueLayout layout = elemLayout.withName(&quot;elem&quot;);
 51         testAccessInternal(viewFactory, layout, layout.varHandle(carrier), checker);
 52     }
 53 
 54     @Test(dataProvider = &quot;elements&quot;)
 55     public void testPaddedAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 56         GroupLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;));
 57         testAccessInternal(viewFactory, layout, layout.varHandle(carrier, PathElement.groupElement(&quot;elem&quot;)), checker);
 58     }
 59 
</pre>
<hr />
<pre>
 65 
 66     @Test(dataProvider = &quot;arrayElements&quot;)
 67     public void testArrayAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 68         SequenceLayout seq = MemoryLayout.ofSequence(10, elemLayout.withName(&quot;elem&quot;));
 69         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement()), checker);
 70     }
 71 
 72     @Test(dataProvider = &quot;arrayElements&quot;)
 73     public void testPaddedArrayAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 74         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;)));
 75         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(&quot;elem&quot;)), checker);
 76     }
 77 
 78     @Test(dataProvider = &quot;arrayElements&quot;)
 79     public void testPaddedArrayAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 80         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout));
 81         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);
 82     }
 83 
 84     private void testAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
<span class="line-modified"> 85         MemoryAddress outer_address;</span>
 86         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {
 87             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
<span class="line-removed"> 88             MemoryAddress addr = segment.address();</span>
 89             try {
<span class="line-modified"> 90                 checker.check(handle, addr);</span>
 91                 if (isRO) {
 92                     throw new AssertionError(); //not ok, memory should be immutable
 93                 }
 94             } catch (UnsupportedOperationException ex) {
 95                 if (!isRO) {
 96                     throw new AssertionError(); //we should not have failed!
 97                 }
 98                 return;
 99             }
100             try {
<span class="line-modified">101                 checker.check(handle, addr.addOffset(layout.byteSize()));</span>
102                 throw new AssertionError(); //not ok, out of bounds
103             } catch (IndexOutOfBoundsException ex) {
104                 //ok, should fail (out of bounds)
105             }
<span class="line-modified">106             outer_address = addr; //leak!</span>
107         }
108         try {
<span class="line-modified">109             checker.check(handle, outer_address);</span>
110             throw new AssertionError(); //not ok, scope is closed
111         } catch (IllegalStateException ex) {
112             //ok, should fail (scope is closed)
113         }
114     }
115 
116     private void testArrayAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
<span class="line-modified">117         MemoryAddress outer_address;</span>
118         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
119             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
<span class="line-removed">120             MemoryAddress addr = segment.address();</span>
121             try {
122                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
<span class="line-modified">123                     checker.check(handle, addr, i);</span>
124                 }
125                 if (isRO) {
126                     throw new AssertionError(); //not ok, memory should be immutable
127                 }
128             } catch (UnsupportedOperationException ex) {
129                 if (!isRO) {
130                     throw new AssertionError(); //we should not have failed!
131                 }
132                 return;
133             }
134             try {
<span class="line-modified">135                 checker.check(handle, addr, seq.elementCount().getAsLong());</span>
136                 throw new AssertionError(); //not ok, out of bounds
137             } catch (IndexOutOfBoundsException ex) {
138                 //ok, should fail (out of bounds)
139             }
<span class="line-modified">140             outer_address = addr; //leak!</span>
141         }
142         try {
<span class="line-modified">143             checker.check(handle, outer_address, 0);</span>
144             throw new AssertionError(); //not ok, scope is closed
145         } catch (IllegalStateException ex) {
146             //ok, should fail (scope is closed)
147         }
148     }
149 
150     @Test(dataProvider = &quot;matrixElements&quot;)
151     public void testMatrixAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
152         SequenceLayout seq = MemoryLayout.ofSequence(20,
153                 MemoryLayout.ofSequence(10, elemLayout.withName(&quot;elem&quot;)));
154         testMatrixAccessInternal(viewFactory, seq, seq.varHandle(carrier,
155                 PathElement.sequenceElement(), PathElement.sequenceElement()), checker);
156     }
157 
158     @Test(dataProvider = &quot;matrixElements&quot;)
159     public void testPaddedMatrixAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
160         SequenceLayout seq = MemoryLayout.ofSequence(20,
161                 MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;))));
162         testMatrixAccessInternal(viewFactory, seq,
163                 seq.varHandle(carrier,
</pre>
<hr />
<pre>
166     }
167 
168     @Test(dataProvider = &quot;matrixElements&quot;)
169     public void testPaddedMatrixAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
170         SequenceLayout seq = MemoryLayout.ofSequence(20,
171                 MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout)));
172         testMatrixAccessInternal(viewFactory, seq,
173                 seq.varHandle(carrier,
174                         PathElement.sequenceElement(), PathElement.sequenceElement(), PathElement.sequenceElement(1)),
175                 checker);
176     }
177 
178     @Test(dataProvider = &quot;badCarriers&quot;,
179           expectedExceptions = IllegalArgumentException.class)
180     public void testBadCarriers(Class&lt;?&gt; carrier) {
181         ValueLayout l = MemoryLayouts.BITS_32_LE.withName(&quot;elem&quot;);
182         l.varHandle(carrier);
183     }
184 
185     private void testMatrixAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
<span class="line-modified">186         MemoryAddress outer_address;</span>
187         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
188             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
<span class="line-removed">189             MemoryAddress addr = segment.address();</span>
190             try {
191                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
192                     for (int j = 0; j &lt; ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
<span class="line-modified">193                         checker.check(handle, addr, i, j);</span>
194                     }
195                 }
196                 if (isRO) {
197                     throw new AssertionError(); //not ok, memory should be immutable
198                 }
199             } catch (UnsupportedOperationException ex) {
200                 if (!isRO) {
201                     throw new AssertionError(); //we should not have failed!
202                 }
203                 return;
204             }
205             try {
<span class="line-modified">206                 checker.check(handle, addr, seq.elementCount().getAsLong(),</span>
207                         ((SequenceLayout)seq.elementLayout()).elementCount().getAsLong());
208                 throw new AssertionError(); //not ok, out of bounds
209             } catch (IndexOutOfBoundsException ex) {
210                 //ok, should fail (out of bounds)
211             }
<span class="line-modified">212             outer_address = addr; //leak!</span>
213         }
214         try {
<span class="line-modified">215             checker.check(handle, outer_address, 0, 0);</span>
216             throw new AssertionError(); //not ok, scope is closed
217         } catch (IllegalStateException ex) {
218             //ok, should fail (scope is closed)
219         }
220     }
221 
222     static Function&lt;MemorySegment, MemorySegment&gt; ID = Function.identity();
223     static Function&lt;MemorySegment, MemorySegment&gt; IMMUTABLE = ms -&gt; ms.withAccessModes(MemorySegment.READ | MemorySegment.CLOSE);
224 
225     @DataProvider(name = &quot;elements&quot;)
226     public Object[][] createData() {
227         return new Object[][] {
228                 //BE, RW
229                 { ID, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },
230                 { ID, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },
231                 { ID, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },
232                 { ID, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },
233                 { ID, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },
234                 { ID, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },
235                 { ID, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },
</pre>
<hr />
<pre>
244                 //LE, RW
245                 { ID, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },
246                 { ID, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },
247                 { ID, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },
248                 { ID, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },
249                 { ID, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },
250                 { ID, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },
251                 { ID, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },
252                 //LE, RO
253                 { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },
254                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },
255                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },
256                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },
257                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },
258                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },
259                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },
260         };
261     }
262 
263     interface Checker {
<span class="line-modified">264         void check(VarHandle handle, MemoryAddress addr);</span>
265 
<span class="line-modified">266         Checker BYTE = (handle, addr) -&gt; {</span>
<span class="line-modified">267             handle.set(addr, (byte)42);</span>
<span class="line-modified">268             assertEquals(42, (byte)handle.get(addr));</span>
269         };
270 
<span class="line-modified">271         Checker SHORT = (handle, addr) -&gt; {</span>
<span class="line-modified">272             handle.set(addr, (short)42);</span>
<span class="line-modified">273             assertEquals(42, (short)handle.get(addr));</span>
274         };
275 
<span class="line-modified">276         Checker CHAR = (handle, addr) -&gt; {</span>
<span class="line-modified">277             handle.set(addr, (char)42);</span>
<span class="line-modified">278             assertEquals(42, (char)handle.get(addr));</span>
279         };
280 
<span class="line-modified">281         Checker INT = (handle, addr) -&gt; {</span>
<span class="line-modified">282             handle.set(addr, 42);</span>
<span class="line-modified">283             assertEquals(42, (int)handle.get(addr));</span>
284         };
285 
<span class="line-modified">286         Checker LONG = (handle, addr) -&gt; {</span>
<span class="line-modified">287             handle.set(addr, (long)42);</span>
<span class="line-modified">288             assertEquals(42, (long)handle.get(addr));</span>
289         };
290 
<span class="line-modified">291         Checker FLOAT = (handle, addr) -&gt; {</span>
<span class="line-modified">292             handle.set(addr, (float)42);</span>
<span class="line-modified">293             assertEquals((float)42, (float)handle.get(addr));</span>
294         };
295 
<span class="line-modified">296         Checker DOUBLE = (handle, addr) -&gt; {</span>
<span class="line-modified">297             handle.set(addr, (double)42);</span>
<span class="line-modified">298             assertEquals((double)42, (double)handle.get(addr));</span>
299         };
300     }
301 
302     @DataProvider(name = &quot;arrayElements&quot;)
303     public Object[][] createArrayData() {
304         return new Object[][] {
305                 //BE, RW
306                 { ID, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },
307                 { ID, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },
308                 { ID, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },
309                 { ID, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },
310                 { ID, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },
311                 { ID, MemoryLayouts.BITS_32_BE, float.class, ArrayChecker.FLOAT },
312                 { ID, MemoryLayouts.BITS_64_BE, double.class, ArrayChecker.DOUBLE },
313                 //BE, RO
314                 { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },
315                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },
316                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },
317                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },
318                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },
</pre>
<hr />
<pre>
321                 //LE, RW
322                 { ID, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },
323                 { ID, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },
324                 { ID, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },
325                 { ID, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },
326                 { ID, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },
327                 { ID, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },
328                 { ID, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },
329                 //LE, RO
330                 { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },
331                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },
332                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },
333                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },
334                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },
335                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },
336                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },
337         };
338     }
339 
340     interface ArrayChecker {
<span class="line-modified">341         void check(VarHandle handle, MemoryAddress addr, long index);</span>
342 
<span class="line-modified">343         ArrayChecker BYTE = (handle, addr, i) -&gt; {</span>
<span class="line-modified">344             handle.set(addr, i, (byte)i);</span>
<span class="line-modified">345             assertEquals(i, (byte)handle.get(addr, i));</span>
346         };
347 
<span class="line-modified">348         ArrayChecker SHORT = (handle, addr, i) -&gt; {</span>
<span class="line-modified">349             handle.set(addr, i, (short)i);</span>
<span class="line-modified">350             assertEquals(i, (short)handle.get(addr, i));</span>
351         };
352 
<span class="line-modified">353         ArrayChecker CHAR = (handle, addr, i) -&gt; {</span>
<span class="line-modified">354             handle.set(addr, i, (char)i);</span>
<span class="line-modified">355             assertEquals(i, (char)handle.get(addr, i));</span>
356         };
357 
<span class="line-modified">358         ArrayChecker INT = (handle, addr, i) -&gt; {</span>
<span class="line-modified">359             handle.set(addr, i, (int)i);</span>
<span class="line-modified">360             assertEquals(i, (int)handle.get(addr, i));</span>
361         };
362 
<span class="line-modified">363         ArrayChecker LONG = (handle, addr, i) -&gt; {</span>
<span class="line-modified">364             handle.set(addr, i, (long)i);</span>
<span class="line-modified">365             assertEquals(i, (long)handle.get(addr, i));</span>
366         };
367 
<span class="line-modified">368         ArrayChecker FLOAT = (handle, addr, i) -&gt; {</span>
<span class="line-modified">369             handle.set(addr, i, (float)i);</span>
<span class="line-modified">370             assertEquals((float)i, (float)handle.get(addr, i));</span>
371         };
372 
<span class="line-modified">373         ArrayChecker DOUBLE = (handle, addr, i) -&gt; {</span>
<span class="line-modified">374             handle.set(addr, i, (double)i);</span>
<span class="line-modified">375             assertEquals((double)i, (double)handle.get(addr, i));</span>
376         };
377     }
378 
379     @DataProvider(name = &quot;matrixElements&quot;)
380     public Object[][] createMatrixData() {
381         return new Object[][] {
382                 //BE, RW
383                 { ID, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },
384                 { ID, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },
385                 { ID, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },
386                 { ID, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },
387                 { ID, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },
388                 { ID, MemoryLayouts.BITS_32_BE, float.class, MatrixChecker.FLOAT },
389                 { ID, MemoryLayouts.BITS_64_BE, double.class, MatrixChecker.DOUBLE },
390                 //BE, RO
391                 { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },
392                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },
393                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },
394                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },
395                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },
</pre>
<hr />
<pre>
398                 //LE, RW
399                 { ID, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },
400                 { ID, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },
401                 { ID, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },
402                 { ID, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },
403                 { ID, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },
404                 { ID, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },
405                 { ID, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },
406                 //LE, RO
407                 { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },
408                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },
409                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },
410                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },
411                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },
412                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },
413                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },
414         };
415     }
416 
417     interface MatrixChecker {
<span class="line-modified">418         void check(VarHandle handle, MemoryAddress addr, long row, long col);</span>
419 
<span class="line-modified">420         MatrixChecker BYTE = (handle, addr, r, c) -&gt; {</span>
<span class="line-modified">421             handle.set(addr, r, c, (byte)(r + c));</span>
<span class="line-modified">422             assertEquals(r + c, (byte)handle.get(addr, r, c));</span>
423         };
424 
<span class="line-modified">425         MatrixChecker SHORT = (handle, addr, r, c) -&gt; {</span>
<span class="line-modified">426             handle.set(addr, r, c, (short)(r + c));</span>
<span class="line-modified">427             assertEquals(r + c, (short)handle.get(addr, r, c));</span>
428         };
429 
<span class="line-modified">430         MatrixChecker CHAR = (handle, addr, r, c) -&gt; {</span>
<span class="line-modified">431             handle.set(addr, r, c, (char)(r + c));</span>
<span class="line-modified">432             assertEquals(r + c, (char)handle.get(addr, r, c));</span>
433         };
434 
<span class="line-modified">435         MatrixChecker INT = (handle, addr, r, c) -&gt; {</span>
<span class="line-modified">436             handle.set(addr, r, c, (int)(r + c));</span>
<span class="line-modified">437             assertEquals(r + c, (int)handle.get(addr, r, c));</span>
438         };
439 
<span class="line-modified">440         MatrixChecker LONG = (handle, addr, r, c) -&gt; {</span>
<span class="line-modified">441             handle.set(addr, r, c, r + c);</span>
<span class="line-modified">442             assertEquals(r + c, (long)handle.get(addr, r, c));</span>
443         };
444 
<span class="line-modified">445         MatrixChecker FLOAT = (handle, addr, r, c) -&gt; {</span>
<span class="line-modified">446             handle.set(addr, r, c, (float)(r + c));</span>
<span class="line-modified">447             assertEquals((float)(r + c), (float)handle.get(addr, r, c));</span>
448         };
449 
<span class="line-modified">450         MatrixChecker DOUBLE = (handle, addr, r, c) -&gt; {</span>
<span class="line-modified">451             handle.set(addr, r, c, (double)(r + c));</span>
<span class="line-modified">452             assertEquals((double)(r + c), (double)handle.get(addr, r, c));</span>
453         };
454     }
455 
456     @DataProvider(name = &quot;badCarriers&quot;)
457     public Object[][] createBadCarriers() {
458         return new Object[][] {
459                 { void.class },
460                 { boolean.class },
461                 { Object.class },
462                 { int[].class }
463         };
464     }
465 }
</pre>
</td>
<td>
<hr />
<pre>
 19  *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess
 27  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess
 28  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess
 29  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess
 30  */
 31 
 32 import jdk.incubator.foreign.GroupLayout;
 33 import jdk.incubator.foreign.MemoryLayouts;
 34 import jdk.incubator.foreign.MemoryLayout;
 35 import jdk.incubator.foreign.MemoryLayout.PathElement;
 36 import jdk.incubator.foreign.MemorySegment;
 37 import jdk.incubator.foreign.SequenceLayout;
 38 import jdk.incubator.foreign.ValueLayout;
<span class="line-modified"> 39 </span>
 40 import java.lang.invoke.VarHandle;
 41 import java.util.function.Function;
 42 
 43 import org.testng.annotations.*;
 44 import static org.testng.Assert.*;
 45 
 46 public class TestMemoryAccess {
 47 
 48     @Test(dataProvider = &quot;elements&quot;)
 49     public void testAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, ValueLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 50         ValueLayout layout = elemLayout.withName(&quot;elem&quot;);
 51         testAccessInternal(viewFactory, layout, layout.varHandle(carrier), checker);
 52     }
 53 
 54     @Test(dataProvider = &quot;elements&quot;)
 55     public void testPaddedAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
 56         GroupLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;));
 57         testAccessInternal(viewFactory, layout, layout.varHandle(carrier, PathElement.groupElement(&quot;elem&quot;)), checker);
 58     }
 59 
</pre>
<hr />
<pre>
 65 
 66     @Test(dataProvider = &quot;arrayElements&quot;)
 67     public void testArrayAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 68         SequenceLayout seq = MemoryLayout.ofSequence(10, elemLayout.withName(&quot;elem&quot;));
 69         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement()), checker);
 70     }
 71 
 72     @Test(dataProvider = &quot;arrayElements&quot;)
 73     public void testPaddedArrayAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 74         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;)));
 75         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(&quot;elem&quot;)), checker);
 76     }
 77 
 78     @Test(dataProvider = &quot;arrayElements&quot;)
 79     public void testPaddedArrayAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 80         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout));
 81         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);
 82     }
 83 
 84     private void testAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
<span class="line-modified"> 85         MemorySegment outer_segment;</span>
 86         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {
 87             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);

 88             try {
<span class="line-modified"> 89                 checker.check(handle, segment);</span>
 90                 if (isRO) {
 91                     throw new AssertionError(); //not ok, memory should be immutable
 92                 }
 93             } catch (UnsupportedOperationException ex) {
 94                 if (!isRO) {
 95                     throw new AssertionError(); //we should not have failed!
 96                 }
 97                 return;
 98             }
 99             try {
<span class="line-modified">100                 checker.check(handle, segment.asSlice(layout.byteSize()));</span>
101                 throw new AssertionError(); //not ok, out of bounds
102             } catch (IndexOutOfBoundsException ex) {
103                 //ok, should fail (out of bounds)
104             }
<span class="line-modified">105             outer_segment = segment; //leak!</span>
106         }
107         try {
<span class="line-modified">108             checker.check(handle, outer_segment);</span>
109             throw new AssertionError(); //not ok, scope is closed
110         } catch (IllegalStateException ex) {
111             //ok, should fail (scope is closed)
112         }
113     }
114 
115     private void testArrayAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
<span class="line-modified">116         MemorySegment outer_segment;</span>
117         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
118             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);

119             try {
120                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
<span class="line-modified">121                     checker.check(handle, segment, i);</span>
122                 }
123                 if (isRO) {
124                     throw new AssertionError(); //not ok, memory should be immutable
125                 }
126             } catch (UnsupportedOperationException ex) {
127                 if (!isRO) {
128                     throw new AssertionError(); //we should not have failed!
129                 }
130                 return;
131             }
132             try {
<span class="line-modified">133                 checker.check(handle, segment, seq.elementCount().getAsLong());</span>
134                 throw new AssertionError(); //not ok, out of bounds
135             } catch (IndexOutOfBoundsException ex) {
136                 //ok, should fail (out of bounds)
137             }
<span class="line-modified">138             outer_segment = segment; //leak!</span>
139         }
140         try {
<span class="line-modified">141             checker.check(handle, outer_segment, 0);</span>
142             throw new AssertionError(); //not ok, scope is closed
143         } catch (IllegalStateException ex) {
144             //ok, should fail (scope is closed)
145         }
146     }
147 
148     @Test(dataProvider = &quot;matrixElements&quot;)
149     public void testMatrixAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
150         SequenceLayout seq = MemoryLayout.ofSequence(20,
151                 MemoryLayout.ofSequence(10, elemLayout.withName(&quot;elem&quot;)));
152         testMatrixAccessInternal(viewFactory, seq, seq.varHandle(carrier,
153                 PathElement.sequenceElement(), PathElement.sequenceElement()), checker);
154     }
155 
156     @Test(dataProvider = &quot;matrixElements&quot;)
157     public void testPaddedMatrixAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
158         SequenceLayout seq = MemoryLayout.ofSequence(20,
159                 MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;))));
160         testMatrixAccessInternal(viewFactory, seq,
161                 seq.varHandle(carrier,
</pre>
<hr />
<pre>
164     }
165 
166     @Test(dataProvider = &quot;matrixElements&quot;)
167     public void testPaddedMatrixAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
168         SequenceLayout seq = MemoryLayout.ofSequence(20,
169                 MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout)));
170         testMatrixAccessInternal(viewFactory, seq,
171                 seq.varHandle(carrier,
172                         PathElement.sequenceElement(), PathElement.sequenceElement(), PathElement.sequenceElement(1)),
173                 checker);
174     }
175 
176     @Test(dataProvider = &quot;badCarriers&quot;,
177           expectedExceptions = IllegalArgumentException.class)
178     public void testBadCarriers(Class&lt;?&gt; carrier) {
179         ValueLayout l = MemoryLayouts.BITS_32_LE.withName(&quot;elem&quot;);
180         l.varHandle(carrier);
181     }
182 
183     private void testMatrixAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
<span class="line-modified">184         MemorySegment outer_segment;</span>
185         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
186             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);

187             try {
188                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
189                     for (int j = 0; j &lt; ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
<span class="line-modified">190                         checker.check(handle, segment, i, j);</span>
191                     }
192                 }
193                 if (isRO) {
194                     throw new AssertionError(); //not ok, memory should be immutable
195                 }
196             } catch (UnsupportedOperationException ex) {
197                 if (!isRO) {
198                     throw new AssertionError(); //we should not have failed!
199                 }
200                 return;
201             }
202             try {
<span class="line-modified">203                 checker.check(handle, segment, seq.elementCount().getAsLong(),</span>
204                         ((SequenceLayout)seq.elementLayout()).elementCount().getAsLong());
205                 throw new AssertionError(); //not ok, out of bounds
206             } catch (IndexOutOfBoundsException ex) {
207                 //ok, should fail (out of bounds)
208             }
<span class="line-modified">209             outer_segment = segment; //leak!</span>
210         }
211         try {
<span class="line-modified">212             checker.check(handle, outer_segment, 0, 0);</span>
213             throw new AssertionError(); //not ok, scope is closed
214         } catch (IllegalStateException ex) {
215             //ok, should fail (scope is closed)
216         }
217     }
218 
219     static Function&lt;MemorySegment, MemorySegment&gt; ID = Function.identity();
220     static Function&lt;MemorySegment, MemorySegment&gt; IMMUTABLE = ms -&gt; ms.withAccessModes(MemorySegment.READ | MemorySegment.CLOSE);
221 
222     @DataProvider(name = &quot;elements&quot;)
223     public Object[][] createData() {
224         return new Object[][] {
225                 //BE, RW
226                 { ID, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },
227                 { ID, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },
228                 { ID, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },
229                 { ID, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },
230                 { ID, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },
231                 { ID, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },
232                 { ID, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },
</pre>
<hr />
<pre>
241                 //LE, RW
242                 { ID, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },
243                 { ID, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },
244                 { ID, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },
245                 { ID, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },
246                 { ID, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },
247                 { ID, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },
248                 { ID, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },
249                 //LE, RO
250                 { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },
251                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },
252                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },
253                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },
254                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },
255                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },
256                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },
257         };
258     }
259 
260     interface Checker {
<span class="line-modified">261         void check(VarHandle handle, MemorySegment segment);</span>
262 
<span class="line-modified">263         Checker BYTE = (handle, segment) -&gt; {</span>
<span class="line-modified">264             handle.set(segment, (byte)42);</span>
<span class="line-modified">265             assertEquals(42, (byte)handle.get(segment));</span>
266         };
267 
<span class="line-modified">268         Checker SHORT = (handle, segment) -&gt; {</span>
<span class="line-modified">269             handle.set(segment, (short)42);</span>
<span class="line-modified">270             assertEquals(42, (short)handle.get(segment));</span>
271         };
272 
<span class="line-modified">273         Checker CHAR = (handle, segment) -&gt; {</span>
<span class="line-modified">274             handle.set(segment, (char)42);</span>
<span class="line-modified">275             assertEquals(42, (char)handle.get(segment));</span>
276         };
277 
<span class="line-modified">278         Checker INT = (handle, segment) -&gt; {</span>
<span class="line-modified">279             handle.set(segment, 42);</span>
<span class="line-modified">280             assertEquals(42, (int)handle.get(segment));</span>
281         };
282 
<span class="line-modified">283         Checker LONG = (handle, segment) -&gt; {</span>
<span class="line-modified">284             handle.set(segment, (long)42);</span>
<span class="line-modified">285             assertEquals(42, (long)handle.get(segment));</span>
286         };
287 
<span class="line-modified">288         Checker FLOAT = (handle, segment) -&gt; {</span>
<span class="line-modified">289             handle.set(segment, (float)42);</span>
<span class="line-modified">290             assertEquals((float)42, (float)handle.get(segment));</span>
291         };
292 
<span class="line-modified">293         Checker DOUBLE = (handle, segment) -&gt; {</span>
<span class="line-modified">294             handle.set(segment, (double)42);</span>
<span class="line-modified">295             assertEquals((double)42, (double)handle.get(segment));</span>
296         };
297     }
298 
299     @DataProvider(name = &quot;arrayElements&quot;)
300     public Object[][] createArrayData() {
301         return new Object[][] {
302                 //BE, RW
303                 { ID, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },
304                 { ID, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },
305                 { ID, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },
306                 { ID, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },
307                 { ID, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },
308                 { ID, MemoryLayouts.BITS_32_BE, float.class, ArrayChecker.FLOAT },
309                 { ID, MemoryLayouts.BITS_64_BE, double.class, ArrayChecker.DOUBLE },
310                 //BE, RO
311                 { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },
312                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },
313                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },
314                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },
315                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },
</pre>
<hr />
<pre>
318                 //LE, RW
319                 { ID, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },
320                 { ID, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },
321                 { ID, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },
322                 { ID, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },
323                 { ID, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },
324                 { ID, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },
325                 { ID, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },
326                 //LE, RO
327                 { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },
328                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },
329                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },
330                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },
331                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },
332                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },
333                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },
334         };
335     }
336 
337     interface ArrayChecker {
<span class="line-modified">338         void check(VarHandle handle, MemorySegment segment, long index);</span>
339 
<span class="line-modified">340         ArrayChecker BYTE = (handle, segment, i) -&gt; {</span>
<span class="line-modified">341             handle.set(segment, i, (byte)i);</span>
<span class="line-modified">342             assertEquals(i, (byte)handle.get(segment, i));</span>
343         };
344 
<span class="line-modified">345         ArrayChecker SHORT = (handle, segment, i) -&gt; {</span>
<span class="line-modified">346             handle.set(segment, i, (short)i);</span>
<span class="line-modified">347             assertEquals(i, (short)handle.get(segment, i));</span>
348         };
349 
<span class="line-modified">350         ArrayChecker CHAR = (handle, segment, i) -&gt; {</span>
<span class="line-modified">351             handle.set(segment, i, (char)i);</span>
<span class="line-modified">352             assertEquals(i, (char)handle.get(segment, i));</span>
353         };
354 
<span class="line-modified">355         ArrayChecker INT = (handle, segment, i) -&gt; {</span>
<span class="line-modified">356             handle.set(segment, i, (int)i);</span>
<span class="line-modified">357             assertEquals(i, (int)handle.get(segment, i));</span>
358         };
359 
<span class="line-modified">360         ArrayChecker LONG = (handle, segment, i) -&gt; {</span>
<span class="line-modified">361             handle.set(segment, i, (long)i);</span>
<span class="line-modified">362             assertEquals(i, (long)handle.get(segment, i));</span>
363         };
364 
<span class="line-modified">365         ArrayChecker FLOAT = (handle, segment, i) -&gt; {</span>
<span class="line-modified">366             handle.set(segment, i, (float)i);</span>
<span class="line-modified">367             assertEquals((float)i, (float)handle.get(segment, i));</span>
368         };
369 
<span class="line-modified">370         ArrayChecker DOUBLE = (handle, segment, i) -&gt; {</span>
<span class="line-modified">371             handle.set(segment, i, (double)i);</span>
<span class="line-modified">372             assertEquals((double)i, (double)handle.get(segment, i));</span>
373         };
374     }
375 
376     @DataProvider(name = &quot;matrixElements&quot;)
377     public Object[][] createMatrixData() {
378         return new Object[][] {
379                 //BE, RW
380                 { ID, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },
381                 { ID, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },
382                 { ID, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },
383                 { ID, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },
384                 { ID, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },
385                 { ID, MemoryLayouts.BITS_32_BE, float.class, MatrixChecker.FLOAT },
386                 { ID, MemoryLayouts.BITS_64_BE, double.class, MatrixChecker.DOUBLE },
387                 //BE, RO
388                 { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },
389                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },
390                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },
391                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },
392                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },
</pre>
<hr />
<pre>
395                 //LE, RW
396                 { ID, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },
397                 { ID, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },
398                 { ID, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },
399                 { ID, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },
400                 { ID, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },
401                 { ID, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },
402                 { ID, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },
403                 //LE, RO
404                 { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },
405                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },
406                 { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },
407                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },
408                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },
409                 { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },
410                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },
411         };
412     }
413 
414     interface MatrixChecker {
<span class="line-modified">415         void check(VarHandle handle, MemorySegment segment, long row, long col);</span>
416 
<span class="line-modified">417         MatrixChecker BYTE = (handle, segment, r, c) -&gt; {</span>
<span class="line-modified">418             handle.set(segment, r, c, (byte)(r + c));</span>
<span class="line-modified">419             assertEquals(r + c, (byte)handle.get(segment, r, c));</span>
420         };
421 
<span class="line-modified">422         MatrixChecker SHORT = (handle, segment, r, c) -&gt; {</span>
<span class="line-modified">423             handle.set(segment, r, c, (short)(r + c));</span>
<span class="line-modified">424             assertEquals(r + c, (short)handle.get(segment, r, c));</span>
425         };
426 
<span class="line-modified">427         MatrixChecker CHAR = (handle, segment, r, c) -&gt; {</span>
<span class="line-modified">428             handle.set(segment, r, c, (char)(r + c));</span>
<span class="line-modified">429             assertEquals(r + c, (char)handle.get(segment, r, c));</span>
430         };
431 
<span class="line-modified">432         MatrixChecker INT = (handle, segment, r, c) -&gt; {</span>
<span class="line-modified">433             handle.set(segment, r, c, (int)(r + c));</span>
<span class="line-modified">434             assertEquals(r + c, (int)handle.get(segment, r, c));</span>
435         };
436 
<span class="line-modified">437         MatrixChecker LONG = (handle, segment, r, c) -&gt; {</span>
<span class="line-modified">438             handle.set(segment, r, c, r + c);</span>
<span class="line-modified">439             assertEquals(r + c, (long)handle.get(segment, r, c));</span>
440         };
441 
<span class="line-modified">442         MatrixChecker FLOAT = (handle, segment, r, c) -&gt; {</span>
<span class="line-modified">443             handle.set(segment, r, c, (float)(r + c));</span>
<span class="line-modified">444             assertEquals((float)(r + c), (float)handle.get(segment, r, c));</span>
445         };
446 
<span class="line-modified">447         MatrixChecker DOUBLE = (handle, segment, r, c) -&gt; {</span>
<span class="line-modified">448             handle.set(segment, r, c, (double)(r + c));</span>
<span class="line-modified">449             assertEquals((double)(r + c), (double)handle.get(segment, r, c));</span>
450         };
451     }
452 
453     @DataProvider(name = &quot;badCarriers&quot;)
454     public Object[][] createBadCarriers() {
455         return new Object[][] {
456                 { void.class },
457                 { boolean.class },
458                 { Object.class },
459                 { int[].class }
460         };
461     }
462 }
</pre>
</td>
</tr>
</table>
<center><a href="TestLayouts.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestMemoryAlignment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
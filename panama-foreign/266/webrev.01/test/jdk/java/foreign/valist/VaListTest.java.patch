diff a/test/jdk/java/foreign/valist/VaListTest.java b/test/jdk/java/foreign/valist/VaListTest.java
--- a/test/jdk/java/foreign/valist/VaListTest.java
+++ b/test/jdk/java/foreign/valist/VaListTest.java
@@ -113,114 +113,112 @@
         }
     }
 
     private static MethodHandle linkVaListCB(String symbol) {
         return link(symbol,
-            MethodType.methodType(void.class, MemoryAddress.class),
-            FunctionDescriptor.ofVoid(C_POINTER));
+                MethodType.methodType(void.class, MemoryAddress.class),
+                FunctionDescriptor.ofVoid(C_POINTER));
 
     }
 
     private static final Function<Consumer<VaList.Builder>, VaList> winVaListFactory
-        = actions -> Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);
+            = actions -> Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);
     private static final Function<Consumer<VaList.Builder>, VaList> sysvVaListFactory
-        = actions -> SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);
+            = actions -> SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);
     private static final Function<Consumer<VaList.Builder>, VaList> aarch64VaListFactory
-        = actions -> AArch64Linker.newVaList(actions, MemorySegment::allocateNative);
+            = actions -> AArch64Linker.newVaList(actions, MemorySegment::allocateNative);
     private static final Function<Consumer<VaList.Builder>, VaList> platformVaListFactory
-        = CSupport.VaList::make;
+            = CSupport.VaList::make;
 
     private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> winVaListScopedFactory
-        = (actions, scope) -> Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
+            = (actions, scope) -> Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
     private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> sysvVaListScopedFactory
-        = (actions, scope) -> SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
+            = (actions, scope) -> SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
     private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> aarch64VaListScopedFactory
-        = (actions, scope) -> AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
+            = (actions, scope) -> AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
     private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> platformVaListScopedFactory
-        = CSupport.VaList::make;
+            = CSupport.VaList::make;
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] sumInts() {
         Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->
-            (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();
+                (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();
         BiFunction<Integer, VaList, Integer> sumIntsNative
-            = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
+                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
         return new Object[][]{
-            { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
-            { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
-            { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
-            { platformVaListFactory, sumIntsNative,                        C_INT         },
+                { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
+                { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
+                { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
+                { platformVaListFactory, sumIntsNative,                        C_INT         },
         };
     }
 
     @Test(dataProvider = "sumInts")
     public void testIntSum(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                            BiFunction<Integer, VaList, Integer> sumInts,
                            MemoryLayout intLayout) {
         try (VaList vaList = vaListFactory.apply(b ->
                 b.vargFromInt(intLayout, 10)
-                 .vargFromInt(intLayout, 15)
-                 .vargFromInt(intLayout, 20))) {
+                        .vargFromInt(intLayout, 15)
+                        .vargFromInt(intLayout, 20))) {
             int x = sumInts.apply(3, vaList);
             assertEquals(x, 45);
         }
     }
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] sumDoubles() {
         Function<MemoryLayout, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->
-            (num, list) -> DoubleStream.generate(() -> list.vargAsDouble(layout)).limit(num).sum();
+                (num, list) -> DoubleStream.generate(() -> list.vargAsDouble(layout)).limit(num).sum();
         BiFunction<Integer, VaList, Double> sumDoublesNative
-            = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);
+                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);
         return new Object[][]{
-            { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },
-            { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },
-            { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },
-            { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },
+                { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },
+                { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },
+                { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },
+                { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },
         };
     }
 
     @Test(dataProvider = "sumDoubles")
     public void testDoubleSum(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                               BiFunction<Integer, VaList, Double> sumDoubles,
                               MemoryLayout doubleLayout) {
         try (VaList vaList = vaListFactory.apply(b ->
                 b.vargFromDouble(doubleLayout, 3.0D)
-                 .vargFromDouble(doubleLayout, 4.0D)
-                 .vargFromDouble(doubleLayout, 5.0D))) {
+                        .vargFromDouble(doubleLayout, 4.0D)
+                        .vargFromDouble(doubleLayout, 5.0D))) {
             double x = sumDoubles.apply(3, vaList);
             assertEquals(x, 12.0D);
         }
     }
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] pointers() {
         Function<MemoryLayout, Function<VaList, Integer>> getIntJavaFact = layout ->
-            list -> {
-                MemoryAddress ma = list.vargAsAddress(layout);
-                MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,
-                        4, Thread.currentThread(), null, null);
-                return MemoryAccess.getInt(accessibleSegment.address());
-            };
+                list -> {
+                    MemoryAddress ma = list.vargAsAddress(layout);
+                    return MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), ma.toRawLongValue());
+                };
         Function<VaList, Integer> getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
         return new Object[][]{
-            { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
-            { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },
-            { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },
-            { platformVaListFactory, getIntNative,                            C_POINTER         },
+                { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
+                { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },
+                { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },
+                { platformVaListFactory, getIntNative,                            C_POINTER         },
         };
     }
 
     @Test(dataProvider = "pointers")
     public void testVaListMemoryAddress(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                                         Function<VaList, Integer> getFromPointer,
                                         MemoryLayout pointerLayout) {
         try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
-            MemoryAccess.setInt(msInt.address(), 10);
+            MemoryAccess.setInt(msInt, 10);
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.address()))) {
                 int x = getFromPointer.apply(vaList);
                 assertEquals(x, 10);
             }
         }
@@ -232,49 +230,49 @@
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] structs() {
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact
-            = (pointLayout, VH_Point_x, VH_Point_y) ->
+                = (pointLayout, VH_Point_x, VH_Point_y) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(pointLayout);
-                    int x = (int) VH_Point_x.get(struct.address());
-                    int y = (int) VH_Point_y.get(struct.address());
+                    int x = (int) VH_Point_x.get(struct);
+                    int y = (int) VH_Point_y.get(struct);
                     return x + y;
                 };
 
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact
-            = (pointLayout, VH_Point_x, VH_Point_y) ->
+                = (pointLayout, VH_Point_x, VH_Point_y) ->
                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);
 
         TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
                 TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact
-            = (vaListFact, intLayout, sumStructFact) -> {
-                GroupLayout pointLayout =  MemoryLayout.ofStruct(
+                = (vaListFact, intLayout, sumStructFact) -> {
+            GroupLayout pointLayout =  MemoryLayout.ofStruct(
                     intLayout.withName("x"),
                     intLayout.withName("y")
-                );
-                VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement("x"));
-                VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement("y"));
-                return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),
-                                      pointLayout, VH_Point_x, VH_Point_y  };
-            };
+            );
+            VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement("x"));
+            VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement("y"));
+            return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),
+                    pointLayout, VH_Point_x, VH_Point_y  };
+        };
         return new Object[][]{
-            argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),
-            argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),
-            argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),
-            argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),
+                argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),
+                argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),
+                argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),
+                argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),
         };
     }
 
     @Test(dataProvider = "structs")
     public void testStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                            Function<VaList, Integer> sumStruct,
                            MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
-            VH_Point_x.set(struct.address(), 5);
-            VH_Point_y.set(struct.address(), 10);
+            VH_Point_x.set(struct, 5);
+            VH_Point_y.set(struct, 10);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct))) {
                 int sum = sumStruct.apply(vaList);
                 assertEquals(sum, 15);
             }
@@ -283,49 +281,49 @@
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] bigStructs() {
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact
-            = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) ->
+                = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
-                    long x = (long) VH_BigPoint_x.get(struct.address());
-                    long y = (long) VH_BigPoint_y.get(struct.address());
+                    long x = (long) VH_BigPoint_x.get(struct);
+                    long y = (long) VH_BigPoint_y.get(struct);
                     return x + y;
                 };
 
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact
-            = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) ->
+                = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) ->
                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);
 
         TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
                 TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact
-            = (vaListFact, longLongLayout, sumBigStructFact) -> {
-                GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(
+                = (vaListFact, longLongLayout, sumBigStructFact) -> {
+            GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(
                     longLongLayout.withName("x"),
                     longLongLayout.withName("y")
-                );
-                VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement("x"));
-                VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement("y"));
-                return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),
-                                      BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };
-            };
+            );
+            VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement("x"));
+            VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement("y"));
+            return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),
+                    BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };
+        };
         return new Object[][]{
-            argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
-            argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
-            argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
-            argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
+                argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
+                argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
+                argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
+                argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
         };
     }
 
     @Test(dataProvider = "bigStructs")
     public void testBigStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                               Function<VaList, Long> sumBigStruct,
                               MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
-            VH_BigPoint_x.set(struct.address(), 5);
-            VH_BigPoint_y.set(struct.address(), 10);
+            VH_BigPoint_x.set(struct, 5);
+            VH_BigPoint_y.set(struct, 10);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct))) {
                 long sum = sumBigStruct.apply(vaList);
                 assertEquals(sum, 15);
             }
@@ -334,50 +332,50 @@
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] floatStructs() {
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact
-            = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) ->
+                = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
-                    float x = (float) VH_FloatPoint_x.get(struct.address());
-                    float y = (float) VH_FloatPoint_y.get(struct.address());
+                    float x = (float) VH_FloatPoint_x.get(struct);
+                    float y = (float) VH_FloatPoint_y.get(struct);
                     return x + y;
                 };
 
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact
-            = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) ->
+                = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) ->
                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);
 
         TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
                 TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact
-            = (vaListFact, floatLayout, sumFloatStructFact) -> {
-                GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
+                = (vaListFact, floatLayout, sumFloatStructFact) -> {
+            GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
                     floatLayout.withName("x"),
                     floatLayout.withName("y")
-                );
-                VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement("x"));
-                VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement("y"));
-                return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),
-                                      FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };
-            };
+            );
+            VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement("x"));
+            VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement("y"));
+            return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),
+                    FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };
+        };
         return new Object[][]{
-            argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),
-            argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),
-            argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),
-            argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),
+                argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),
+                argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),
+                argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),
+                argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),
         };
     }
 
     @Test(dataProvider = "floatStructs")
     public void testFloatStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                                 Function<VaList, Float> sumFloatStruct,
                                 MemoryLayout FloatPoint_LAYOUT,
                                 VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
-            VH_FloatPoint_x.set(struct.address(), 1.234f);
-            VH_FloatPoint_y.set(struct.address(), 3.142f);
+            VH_FloatPoint_x.set(struct, 1.234f);
+            VH_FloatPoint_y.set(struct, 3.142f);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
                 float sum = sumFloatStruct.apply(vaList);
                 assertEquals(sum, 4.376f, 0.00001f);
             }
@@ -390,43 +388,43 @@
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] hugeStructs() {
         QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact
-            = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
+                = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
-                    long x = (long) VH_HugePoint_x.get(struct.address());
-                    long y = (long) VH_HugePoint_y.get(struct.address());
-                    long z = (long) VH_HugePoint_z.get(struct.address());
+                    long x = (long) VH_HugePoint_x.get(struct);
+                    long y = (long) VH_HugePoint_y.get(struct);
+                    long z = (long) VH_HugePoint_z.get(struct);
                     return x + y + z;
                 };
 
         QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact
-            = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
+                = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);
 
         TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
                 QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact
-            = (vaListFact, longLongLayout, sumBigStructFact) -> {
-                GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
+                = (vaListFact, longLongLayout, sumBigStructFact) -> {
+            GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
                     longLongLayout.withName("x"),
                     longLongLayout.withName("y"),
                     longLongLayout.withName("z")
-                );
-                VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement("x"));
-                VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement("y"));
-                VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement("z"));
-                return new Object[] { vaListFact,
-                                      sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),
-                                      HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };
-            };
+            );
+            VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement("x"));
+            VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement("y"));
+            VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement("z"));
+            return new Object[] { vaListFact,
+                    sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),
+                    HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };
+        };
         return new Object[][]{
-            argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
-            argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
-            argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
-            argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
+                argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
+                argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
+                argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
+                argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
         };
     }
 
     @Test(dataProvider = "hugeStructs")
     public void testHugeStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
@@ -434,58 +432,64 @@
                                MemoryLayout HugePoint_LAYOUT,
                                VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
         // On AArch64 a struct needs to be larger than 16 bytes to be
         // passed by reference.
         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
-            VH_HugePoint_x.set(struct.address(), 1);
-            VH_HugePoint_y.set(struct.address(), 2);
-            VH_HugePoint_z.set(struct.address(), 3);
+            VH_HugePoint_x.set(struct, 1);
+            VH_HugePoint_y.set(struct, 2);
+            VH_HugePoint_z.set(struct, 3);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct))) {
                 long sum = sumHugeStruct.apply(vaList);
                 assertEquals(sum, 6);
             }
         }
     }
 
     public interface SumStackFunc {
-        void invoke(MemoryAddress longSum, MemoryAddress doubleSum, VaList list);
+        void invoke(MemorySegment longSum, MemorySegment doubleSum, VaList list);
     }
 
     @DataProvider
     public static Object[][] sumStack() {
         BiFunction<MemoryLayout, MemoryLayout, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->
-            (longSum, doubleSum, list) -> {
-                long lSum = 0L;
-                for (int i = 0; i < 16; i++) {
-                    lSum += list.vargAsLong(longLayout);
-                }
-                MemoryAccess.setLong(longSum, lSum);
-                double dSum = 0D;
-                for (int i = 0; i < 16; i++) {
-                    dSum += list.vargAsDouble(doubleLayout);
-                }
-                MemoryAccess.setDouble(doubleSum, dSum);
-            };
-        SumStackFunc sumStackNative = MethodHandleProxies.asInterfaceInstance(SumStackFunc.class, MH_sumStack);
+                (longSum, doubleSum, list) -> {
+                    long lSum = 0L;
+                    for (int i = 0; i < 16; i++) {
+                        lSum += list.vargAsLong(longLayout);
+                    }
+                    MemoryAccess.setLong(longSum, lSum);
+                    double dSum = 0D;
+                    for (int i = 0; i < 16; i++) {
+                        dSum += list.vargAsDouble(doubleLayout);
+                    }
+                    MemoryAccess.setDouble(doubleSum, dSum);
+                };
+        SumStackFunc sumStackNative = (longSum, doubleSum, list) -> {
+            try {
+                MH_sumStack.invokeExact(longSum.address(), doubleSum.address(), list);
+            } catch (Throwable ex) {
+                throw new AssertionError(ex);
+            }
+        };
         return new Object[][]{
-            { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },
-            { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },
-            { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },
-            { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },
+                { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },
+                { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },
+                { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },
+                { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },
         };
     }
 
     @Test(dataProvider = "sumStack")
     public void testStack(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                           SumStackFunc sumStack,
                           MemoryLayout longLayout,
                           MemoryLayout doubleLayout) {
-       try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);
-            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {
-            MemoryAccess.setLong(longSum.address(), 0L);
-            MemoryAccess.setDouble(doubleSum.address(), 0D);
+        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);
+             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {
+            MemoryAccess.setLong(longSum, 0L);
+            MemoryAccess.setDouble(doubleSum, 0D);
 
             VaList list = vaListFactory.apply(b -> {
                 for (long l = 1; l <= 16L; l++) {
                     b.vargFromLong(longLayout, l);
                 }
@@ -493,15 +497,15 @@
                     b.vargFromDouble(doubleLayout, d);
                 }
             });
 
             try (list) {
-                sumStack.invoke(longSum.address(), doubleSum.address(), list);
+                sumStack.invoke(longSum, doubleSum, list);
             }
 
-            long lSum = MemoryAccess.getLong(longSum.address());
-            double dSum = MemoryAccess.getDouble(doubleSum.address());
+            long lSum = MemoryAccess.getLong(longSum);
+            double dSum = MemoryAccess.getDouble(doubleSum);
 
             assertEquals(lSum, 136L);
             assertEquals(dSum, 136D);
         }
     }
@@ -515,50 +519,50 @@
     }
 
     @DataProvider
     public Object[][] emptyVaLists() {
         return new Object[][] {
-            { Windowsx64Linker.emptyVaList()      },
-            { winVaListFactory.apply(b -> {})     },
-            { SysVx64Linker.emptyVaList()         },
-            { sysvVaListFactory.apply(b -> {})    },
-            { AArch64Linker.emptyVaList()         },
-            { aarch64VaListFactory.apply(b -> {}) },
+                { Windowsx64Linker.emptyVaList()      },
+                { winVaListFactory.apply(b -> {})     },
+                { SysVx64Linker.emptyVaList()         },
+                { sysvVaListFactory.apply(b -> {})    },
+                { AArch64Linker.emptyVaList()         },
+                { aarch64VaListFactory.apply(b -> {}) },
         };
     }
 
     @Test(expectedExceptions = UnsupportedOperationException.class,
-          expectedExceptionsMessageRegExp = ".*Empty VaList.*",
-          dataProvider = "emptyVaLists")
+            expectedExceptionsMessageRegExp = ".*Empty VaList.*",
+            dataProvider = "emptyVaLists")
     public void testEmptyNotCloseable(VaList emptyList) {
         emptyList.close();
     }
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] sumIntsScoped() {
         Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->
-            (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();
+                (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();
         BiFunction<Integer, VaList, Integer> sumIntsNative
-            = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
+                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
         return new Object[][]{
-            { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
-            { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
-            { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
-            { platformVaListScopedFactory, sumIntsNative,                        C_INT         },
+                { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
+                { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
+                { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
+                { platformVaListScopedFactory, sumIntsNative,                        C_INT         },
         };
     }
 
     @Test(dataProvider = "sumIntsScoped")
     public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> vaListFactory,
                                  BiFunction<Integer, VaList, Integer> sumInts,
                                  MemoryLayout intLayout) {
         VaList listLeaked;
         try (NativeScope scope = NativeScope.unboundedScope()) {
             VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
-                                                    .vargFromInt(intLayout, 8),
-                                               scope);
+                            .vargFromInt(intLayout, 8),
+                    scope);
             int x = sumInts.apply(2, list);
             assertEquals(x, 12);
             listLeaked = list;
         }
         assertFalse(listLeaked.isAlive());
@@ -569,16 +573,16 @@
                                 Function<VaList, Integer> sumStruct, // ignored
                                 MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
         MemorySegment pointOut;
         try (NativeScope scope = NativeScope.unboundedScope()) {
             try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
-                VH_Point_x.set(pointIn.address(), 3);
-                VH_Point_y.set(pointIn.address(), 6);
+                VH_Point_x.set(pointIn, 3);
+                VH_Point_y.set(pointIn, 6);
                 try (VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn))) {
                     pointOut = list.vargAsSegment(Point_LAYOUT, scope);
-                    assertEquals((int) VH_Point_x.get(pointOut.address()), 3);
-                    assertEquals((int) VH_Point_y.get(pointOut.address()), 6);
+                    assertEquals((int) VH_Point_x.get(pointOut), 3);
+                    assertEquals((int) VH_Point_y.get(pointOut), 6);
                 }
                 assertTrue(pointOut.isAlive()); // after VaList freed
             }
             assertTrue(pointOut.isAlive()); // after input MS freed
         }
@@ -586,20 +590,20 @@
     }
 
     @DataProvider
     public Object[][] copy() {
         return new Object[][] {
-            { winVaListFactory,      Win64.C_INT   },
-            { sysvVaListFactory,     SysV.C_INT    },
-            { aarch64VaListFactory,  AArch64.C_INT },
+                { winVaListFactory,      Win64.C_INT   },
+                { sysvVaListFactory,     SysV.C_INT    },
+                { aarch64VaListFactory,  AArch64.C_INT },
         };
     }
 
     @Test(dataProvider = "copy")
     public void testCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, MemoryLayout intLayout) {
         try (VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
-                                                     .vargFromInt(intLayout, 8))) {
+                .vargFromInt(intLayout, 8))) {
             VaList  copy = list.copy();
             assertEquals(copy.vargAsInt(intLayout), 4);
             assertEquals(copy.vargAsInt(intLayout), 8);
             copy.close();
 
@@ -611,11 +615,11 @@
     }
 
     @Test(dataProvider = "copy")
     public void testScopedCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, MemoryLayout intLayout) {
         try (VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
-                                                     .vargFromInt(intLayout, 8))) {
+                .vargFromInt(intLayout, 8))) {
             VaList copy;
             try (NativeScope scope = NativeScope.unboundedScope()) {
                 copy = list.copy(scope);
 
                 assertEquals(copy.vargAsInt(intLayout), 4);
@@ -627,28 +631,28 @@
             assertEquals(list.vargAsInt(intLayout), 8);
         }
     }
 
     @Test(dataProvider = "copy",
-          expectedExceptions = IllegalStateException.class)
+            expectedExceptions = IllegalStateException.class)
     public void testCopyUnusableAfterOriginalClosed(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                                                     MemoryLayout intLayout) {
         VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
-                                                .vargFromInt(intLayout, 8));
+                .vargFromInt(intLayout, 8));
         try (VaList copy = list.copy()) {
             list.close();
 
             copy.vargAsInt(intLayout); // should throw
         }
     }
 
     @Test(dataProvider = "copy",
-          expectedExceptions = IllegalStateException.class)
+            expectedExceptions = IllegalStateException.class)
     public void testCopyUnusableAfterOriginalClosedScope(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                                                          MemoryLayout intLayout) {
         VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
-                                                .vargFromInt(intLayout, 8));
+                .vargFromInt(intLayout, 8));
         try (NativeScope scope = NativeScope.unboundedScope()) {
             VaList copy = list.copy(scope);
             list.close();
 
             copy.vargAsInt(intLayout); // should throw
@@ -656,161 +660,161 @@
     }
 
     @DataProvider
     public static Object[][] upcalls() {
         GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(
-            C_LONGLONG.withName("x"),
-            C_LONGLONG.withName("y")
+                C_LONGLONG.withName("x"),
+                C_LONGLONG.withName("y")
         );
         VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement("x"));
         VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement("y"));
         GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(
-            C_INT.withName("x"),
-            C_INT.withName("y")
+                C_INT.withName("x"),
+                C_INT.withName("y")
         );
         VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement("x"));
         VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement("y"));
         GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
-            C_FLOAT.withName("x"),
-            C_FLOAT.withName("y")
+                C_FLOAT.withName("x"),
+                C_FLOAT.withName("y")
         );
         VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement("x"));
         VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement("y"));
         GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
-            C_LONGLONG.withName("x"),
-            C_LONGLONG.withName("y"),
-            C_LONGLONG.withName("z")
+                C_LONGLONG.withName("x"),
+                C_LONGLONG.withName("y"),
+                C_LONGLONG.withName("z")
         );
         VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement("x"));
         VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement("y"));
         VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement("z"));
 
         return new Object[][]{
-            { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
-                try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);
-                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);
-                }
-            })},
-            { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
-                VaList copy = vaList.copy();
-                try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);
-                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);
-
-                    VH_BigPoint_x.set(struct.address(), 0);
-                    VH_BigPoint_y.set(struct.address(), 0);
-                }
-
-                // should be independent
-                try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);
-                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);
-                }
-            })},
-            { linkVaListCB("upcallStruct"), VaListConsumer.mh(vaList -> {
-                try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {
-                    assertEquals((int) VH_Point_x.get(struct.address()), 5);
-                    assertEquals((int) VH_Point_y.get(struct.address()), 10);
-                }
-            })},
-            { linkVaListCB("upcallHugeStruct"), VaListConsumer.mh(vaList -> {
-                try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {
-                    assertEquals((long) VH_HugePoint_x.get(struct.address()), 1);
-                    assertEquals((long) VH_HugePoint_y.get(struct.address()), 2);
-                    assertEquals((long) VH_HugePoint_z.get(struct.address()), 3);
-                }
-            })},
-            { linkVaListCB("upcallFloatStruct"), VaListConsumer.mh(vaList -> {
-                try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {
-                    assertEquals((float) VH_FloatPoint_x.get(struct.address()), 1.0f);
-                    assertEquals((float) VH_FloatPoint_y.get(struct.address()), 2.0f);
-                }
-            })},
-            { linkVaListCB("upcallMemoryAddress"), VaListConsumer.mh(vaList -> {
-                MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
-                MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
-                                                                    Thread.currentThread(), null, null);
-                int x = MemoryAccess.getInt(ms.address());
-                assertEquals(x, 10);
-            })},
-            { linkVaListCB("upcallDoubles"), VaListConsumer.mh(vaList -> {
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);
-            })},
-            { linkVaListCB("upcallInts"), VaListConsumer.mh(vaList -> {
-                assertEquals(vaList.vargAsInt(C_INT), 10);
-                assertEquals(vaList.vargAsInt(C_INT), 15);
-                assertEquals(vaList.vargAsInt(C_INT), 20);
-            })},
-            { linkVaListCB("upcallStack"), VaListConsumer.mh(vaList -> {
-                // skip all registers
-                for (long l = 1; l <= 16; l++) {
-                    assertEquals(vaList.vargAsLong(C_LONGLONG), l);
-                }
-                for (double d = 1; d <= 16; d++) {
-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), d);
-                }
-
-                // test some arbitrary values on the stack
-                assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
-                assertEquals((char) vaList.vargAsInt(C_INT), 'a');
-                assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
-                assertEquals(vaList.vargAsInt(C_INT), 4);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
-                assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);
-                assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);
-                assertEquals((char) vaList.vargAsInt(C_INT), 'b');
-                assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);
-                assertEquals(vaList.vargAsInt(C_INT), 11);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
-                assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
-
-                try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {
-                    assertEquals((int) VH_Point_x.get(point.address()), 5);
-                    assertEquals((int) VH_Point_y.get(point.address()), 10);
-                }
-
-                VaList copy = vaList.copy();
-                try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(bigPoint.address()), 15);
-                    assertEquals((long) VH_BigPoint_y.get(bigPoint.address()), 20);
-
-                    VH_BigPoint_x.set(bigPoint.address(), 0);
-                    VH_BigPoint_y.set(bigPoint.address(), 0);
-                }
-
-                // should be independent
-                try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 15);
-                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 20);
-                }
-            })},
-            // test skip
-            { linkVaListCB("upcallStack"), VaListConsumer.mh(vaList -> {
-                vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
-                vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);
-                vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);
-                vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);
-            })},
+                { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
+                    try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
+                        assertEquals((long) VH_BigPoint_x.get(struct), 8);
+                        assertEquals((long) VH_BigPoint_y.get(struct), 16);
+                    }
+                })},
+                { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
+                    VaList copy = vaList.copy();
+                    try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
+                        assertEquals((long) VH_BigPoint_x.get(struct), 8);
+                        assertEquals((long) VH_BigPoint_y.get(struct), 16);
+
+                        VH_BigPoint_x.set(struct, 0);
+                        VH_BigPoint_y.set(struct, 0);
+                    }
+
+                    // should be independent
+                    try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
+                        assertEquals((long) VH_BigPoint_x.get(struct), 8);
+                        assertEquals((long) VH_BigPoint_y.get(struct), 16);
+                    }
+                })},
+                { linkVaListCB("upcallStruct"), VaListConsumer.mh(vaList -> {
+                    try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {
+                        assertEquals((int) VH_Point_x.get(struct), 5);
+                        assertEquals((int) VH_Point_y.get(struct), 10);
+                    }
+                })},
+                { linkVaListCB("upcallHugeStruct"), VaListConsumer.mh(vaList -> {
+                    try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {
+                        assertEquals((long) VH_HugePoint_x.get(struct), 1);
+                        assertEquals((long) VH_HugePoint_y.get(struct), 2);
+                        assertEquals((long) VH_HugePoint_z.get(struct), 3);
+                    }
+                })},
+                { linkVaListCB("upcallFloatStruct"), VaListConsumer.mh(vaList -> {
+                    try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {
+                        assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);
+                        assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);
+                    }
+                })},
+                { linkVaListCB("upcallMemoryAddress"), VaListConsumer.mh(vaList -> {
+                    MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
+                    MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
+                            Thread.currentThread(), null, null);
+                    int x = MemoryAccess.getInt(ms);
+                    assertEquals(x, 10);
+                })},
+                { linkVaListCB("upcallDoubles"), VaListConsumer.mh(vaList -> {
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);
+                })},
+                { linkVaListCB("upcallInts"), VaListConsumer.mh(vaList -> {
+                    assertEquals(vaList.vargAsInt(C_INT), 10);
+                    assertEquals(vaList.vargAsInt(C_INT), 15);
+                    assertEquals(vaList.vargAsInt(C_INT), 20);
+                })},
+                { linkVaListCB("upcallStack"), VaListConsumer.mh(vaList -> {
+                    // skip all registers
+                    for (long l = 1; l <= 16; l++) {
+                        assertEquals(vaList.vargAsLong(C_LONGLONG), l);
+                    }
+                    for (double d = 1; d <= 16; d++) {
+                        assertEquals(vaList.vargAsDouble(C_DOUBLE), d);
+                    }
+
+                    // test some arbitrary values on the stack
+                    assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
+                    assertEquals((char) vaList.vargAsInt(C_INT), 'a');
+                    assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
+                    assertEquals(vaList.vargAsInt(C_INT), 4);
+                    assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
+                    assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);
+                    assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);
+                    assertEquals((char) vaList.vargAsInt(C_INT), 'b');
+                    assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);
+                    assertEquals(vaList.vargAsInt(C_INT), 11);
+                    assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
+                    assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
+
+                    try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {
+                        assertEquals((int) VH_Point_x.get(point), 5);
+                        assertEquals((int) VH_Point_y.get(point), 10);
+                    }
+
+                    VaList copy = vaList.copy();
+                    try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {
+                        assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);
+                        assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);
+
+                        VH_BigPoint_x.set(bigPoint, 0);
+                        VH_BigPoint_y.set(bigPoint, 0);
+                    }
+
+                    // should be independent
+                    try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
+                        assertEquals((long) VH_BigPoint_x.get(struct), 15);
+                        assertEquals((long) VH_BigPoint_y.get(struct), 20);
+                    }
+                })},
+                // test skip
+                { linkVaListCB("upcallStack"), VaListConsumer.mh(vaList -> {
+                    vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
+                    assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
+                    vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
+                    assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);
+                    vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);
+                    vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);
+                })},
         };
     }
 
     interface VaListConsumer {
         void accept(CSupport.VaList list);
 
         static MethodHandle mh(VaListConsumer instance) {
             try {
                 return MethodHandles.lookup().findVirtual(VaListConsumer.class, "accept",
-                    MethodType.methodType(void.class, VaList.class)).bindTo(instance);
+                        MethodType.methodType(void.class, VaList.class)).bindTo(instance);
             } catch (ReflectiveOperationException e) {
                 throw new InternalError(e);
             }
         }
     }

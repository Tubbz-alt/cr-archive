<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/foreign/valist/VaListTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../TestVarHandleCombinators.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/valist/VaListTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 113,114 ***</span>
          }
      }
  
      private static MethodHandle linkVaListCB(String symbol) {
          return link(symbol,
<span class="line-modified">!             MethodType.methodType(void.class, MemoryAddress.class),</span>
<span class="line-modified">!             FunctionDescriptor.ofVoid(C_POINTER));</span>
  
      }
  
      private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; winVaListFactory
<span class="line-modified">!         = actions -&gt; Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
      private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; sysvVaListFactory
<span class="line-modified">!         = actions -&gt; SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
      private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; aarch64VaListFactory
<span class="line-modified">!         = actions -&gt; AArch64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
      private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; platformVaListFactory
<span class="line-modified">!         = CSupport.VaList::make;</span>
  
      private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; winVaListScopedFactory
<span class="line-modified">!         = (actions, scope) -&gt; Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
      private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; sysvVaListScopedFactory
<span class="line-modified">!         = (actions, scope) -&gt; SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
      private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; aarch64VaListScopedFactory
<span class="line-modified">!         = (actions, scope) -&gt; AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
      private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; platformVaListScopedFactory
<span class="line-modified">!         = CSupport.VaList::make;</span>
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] sumInts() {
          Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;
<span class="line-modified">!             (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
          BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative
<span class="line-modified">!             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
          return new Object[][]{
<span class="line-modified">!             { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-modified">!             { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-modified">!             { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-modified">!             { platformVaListFactory, sumIntsNative,                        C_INT         },</span>
          };
      }
  
      @Test(dataProvider = &quot;sumInts&quot;)
      public void testIntSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                             BiFunction&lt;Integer, VaList, Integer&gt; sumInts,
                             MemoryLayout intLayout) {
          try (VaList vaList = vaListFactory.apply(b -&gt;
                  b.vargFromInt(intLayout, 10)
<span class="line-modified">!                  .vargFromInt(intLayout, 15)</span>
<span class="line-modified">!                  .vargFromInt(intLayout, 20))) {</span>
              int x = sumInts.apply(3, vaList);
              assertEquals(x, 45);
          }
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] sumDoubles() {
          Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Double&gt;&gt; sumDoublesJavaFact  = layout -&gt;
<span class="line-modified">!             (num, list) -&gt; DoubleStream.generate(() -&gt; list.vargAsDouble(layout)).limit(num).sum();</span>
          BiFunction&lt;Integer, VaList, Double&gt; sumDoublesNative
<span class="line-modified">!             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);</span>
          return new Object[][]{
<span class="line-modified">!             { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },</span>
<span class="line-modified">!             { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },</span>
<span class="line-modified">!             { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },</span>
<span class="line-modified">!             { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },</span>
          };
      }
  
      @Test(dataProvider = &quot;sumDoubles&quot;)
      public void testDoubleSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                BiFunction&lt;Integer, VaList, Double&gt; sumDoubles,
                                MemoryLayout doubleLayout) {
          try (VaList vaList = vaListFactory.apply(b -&gt;
                  b.vargFromDouble(doubleLayout, 3.0D)
<span class="line-modified">!                  .vargFromDouble(doubleLayout, 4.0D)</span>
<span class="line-modified">!                  .vargFromDouble(doubleLayout, 5.0D))) {</span>
              double x = sumDoubles.apply(3, vaList);
              assertEquals(x, 12.0D);
          }
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] pointers() {
          Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;
<span class="line-modified">!             list -&gt; {</span>
<span class="line-modified">!                 MemoryAddress ma = list.vargAsAddress(layout);</span>
<span class="line-modified">!                 MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,</span>
<span class="line-modified">!                         4, Thread.currentThread(), null, null);</span>
<span class="line-removed">-                 return MemoryAccess.getInt(accessibleSegment.address());</span>
<span class="line-removed">-             };</span>
          Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
          return new Object[][]{
<span class="line-modified">!             { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },</span>
<span class="line-modified">!             { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },</span>
<span class="line-modified">!             { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },</span>
<span class="line-modified">!             { platformVaListFactory, getIntNative,                            C_POINTER         },</span>
          };
      }
  
      @Test(dataProvider = &quot;pointers&quot;)
      public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                          Function&lt;VaList, Integer&gt; getFromPointer,
                                          MemoryLayout pointerLayout) {
          try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
<span class="line-modified">!             MemoryAccess.setInt(msInt.address(), 10);</span>
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.address()))) {
                  int x = getFromPointer.apply(vaList);
                  assertEquals(x, 10);
              }
          }
<span class="line-new-header">--- 113,112 ---</span>
          }
      }
  
      private static MethodHandle linkVaListCB(String symbol) {
          return link(symbol,
<span class="line-modified">!                 MethodType.methodType(void.class, MemoryAddress.class),</span>
<span class="line-modified">!                 FunctionDescriptor.ofVoid(C_POINTER));</span>
  
      }
  
      private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; winVaListFactory
<span class="line-modified">!             = actions -&gt; Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
      private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; sysvVaListFactory
<span class="line-modified">!             = actions -&gt; SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
      private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; aarch64VaListFactory
<span class="line-modified">!             = actions -&gt; AArch64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
      private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; platformVaListFactory
<span class="line-modified">!             = CSupport.VaList::make;</span>
  
      private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; winVaListScopedFactory
<span class="line-modified">!             = (actions, scope) -&gt; Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
      private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; sysvVaListScopedFactory
<span class="line-modified">!             = (actions, scope) -&gt; SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
      private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; aarch64VaListScopedFactory
<span class="line-modified">!             = (actions, scope) -&gt; AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
      private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; platformVaListScopedFactory
<span class="line-modified">!             = CSupport.VaList::make;</span>
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] sumInts() {
          Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;
<span class="line-modified">!                 (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
          BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative
<span class="line-modified">!                 = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
          return new Object[][]{
<span class="line-modified">!                 { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-modified">!                 { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-modified">!                 { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-modified">!                 { platformVaListFactory, sumIntsNative,                        C_INT         },</span>
          };
      }
  
      @Test(dataProvider = &quot;sumInts&quot;)
      public void testIntSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                             BiFunction&lt;Integer, VaList, Integer&gt; sumInts,
                             MemoryLayout intLayout) {
          try (VaList vaList = vaListFactory.apply(b -&gt;
                  b.vargFromInt(intLayout, 10)
<span class="line-modified">!                         .vargFromInt(intLayout, 15)</span>
<span class="line-modified">!                         .vargFromInt(intLayout, 20))) {</span>
              int x = sumInts.apply(3, vaList);
              assertEquals(x, 45);
          }
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] sumDoubles() {
          Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Double&gt;&gt; sumDoublesJavaFact  = layout -&gt;
<span class="line-modified">!                 (num, list) -&gt; DoubleStream.generate(() -&gt; list.vargAsDouble(layout)).limit(num).sum();</span>
          BiFunction&lt;Integer, VaList, Double&gt; sumDoublesNative
<span class="line-modified">!                 = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);</span>
          return new Object[][]{
<span class="line-modified">!                 { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },</span>
<span class="line-modified">!                 { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },</span>
<span class="line-modified">!                 { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },</span>
<span class="line-modified">!                 { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },</span>
          };
      }
  
      @Test(dataProvider = &quot;sumDoubles&quot;)
      public void testDoubleSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                BiFunction&lt;Integer, VaList, Double&gt; sumDoubles,
                                MemoryLayout doubleLayout) {
          try (VaList vaList = vaListFactory.apply(b -&gt;
                  b.vargFromDouble(doubleLayout, 3.0D)
<span class="line-modified">!                         .vargFromDouble(doubleLayout, 4.0D)</span>
<span class="line-modified">!                         .vargFromDouble(doubleLayout, 5.0D))) {</span>
              double x = sumDoubles.apply(3, vaList);
              assertEquals(x, 12.0D);
          }
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] pointers() {
          Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;
<span class="line-modified">!                 list -&gt; {</span>
<span class="line-modified">!                     MemoryAddress ma = list.vargAsAddress(layout);</span>
<span class="line-modified">!                     return MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), ma.toRawLongValue());</span>
<span class="line-modified">!                 };</span>
          Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
          return new Object[][]{
<span class="line-modified">!                 { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },</span>
<span class="line-modified">!                 { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },</span>
<span class="line-modified">!                 { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },</span>
<span class="line-modified">!                 { platformVaListFactory, getIntNative,                            C_POINTER         },</span>
          };
      }
  
      @Test(dataProvider = &quot;pointers&quot;)
      public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                          Function&lt;VaList, Integer&gt; getFromPointer,
                                          MemoryLayout pointerLayout) {
          try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
<span class="line-modified">!             MemoryAccess.setInt(msInt, 10);</span>
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.address()))) {
                  int x = getFromPointer.apply(vaList);
                  assertEquals(x, 10);
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,49 ***</span>
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] structs() {
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact
<span class="line-modified">!             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(pointLayout);
<span class="line-modified">!                     int x = (int) VH_Point_x.get(struct.address());</span>
<span class="line-modified">!                     int y = (int) VH_Point_y.get(struct.address());</span>
                      return x + y;
                  };
  
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructNativeFact
<span class="line-modified">!             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
                  MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);
  
          TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
                  TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">!             = (vaListFact, intLayout, sumStructFact) -&gt; {</span>
<span class="line-modified">!                 GroupLayout pointLayout =  MemoryLayout.ofStruct(</span>
                      intLayout.withName(&quot;x&quot;),
                      intLayout.withName(&quot;y&quot;)
<span class="line-modified">!                 );</span>
<span class="line-modified">!                 VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!                 VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!                 return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),</span>
<span class="line-modified">!                                       pointLayout, VH_Point_x, VH_Point_y  };</span>
<span class="line-modified">!             };</span>
          return new Object[][]{
<span class="line-modified">!             argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),</span>
          };
      }
  
      @Test(dataProvider = &quot;structs&quot;)
      public void testStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                             Function&lt;VaList, Integer&gt; sumStruct,
                             MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
          try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">!             VH_Point_x.set(struct.address(), 5);</span>
<span class="line-modified">!             VH_Point_y.set(struct.address(), 10);</span>
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {
                  int sum = sumStruct.apply(vaList);
                  assertEquals(sum, 15);
              }
<span class="line-new-header">--- 230,49 ---</span>
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] structs() {
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact
<span class="line-modified">!                 = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(pointLayout);
<span class="line-modified">!                     int x = (int) VH_Point_x.get(struct);</span>
<span class="line-modified">!                     int y = (int) VH_Point_y.get(struct);</span>
                      return x + y;
                  };
  
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructNativeFact
<span class="line-modified">!                 = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
                  MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);
  
          TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
                  TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">!                 = (vaListFact, intLayout, sumStructFact) -&gt; {</span>
<span class="line-modified">!             GroupLayout pointLayout =  MemoryLayout.ofStruct(</span>
                      intLayout.withName(&quot;x&quot;),
                      intLayout.withName(&quot;y&quot;)
<span class="line-modified">!             );</span>
<span class="line-modified">!             VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!             VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!             return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),</span>
<span class="line-modified">!                     pointLayout, VH_Point_x, VH_Point_y  };</span>
<span class="line-modified">!         };</span>
          return new Object[][]{
<span class="line-modified">!                 argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),</span>
          };
      }
  
      @Test(dataProvider = &quot;structs&quot;)
      public void testStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                             Function&lt;VaList, Integer&gt; sumStruct,
                             MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
          try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">!             VH_Point_x.set(struct, 5);</span>
<span class="line-modified">!             VH_Point_y.set(struct, 10);</span>
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {
                  int sum = sumStruct.apply(vaList);
                  assertEquals(sum, 15);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,49 ***</span>
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] bigStructs() {
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
<span class="line-modified">!             = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
<span class="line-modified">!                     long x = (long) VH_BigPoint_x.get(struct.address());</span>
<span class="line-modified">!                     long y = (long) VH_BigPoint_y.get(struct.address());</span>
                      return x + y;
                  };
  
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
<span class="line-modified">!             = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
                  MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);
  
          TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
                  TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">!             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-modified">!                 GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(</span>
                      longLongLayout.withName(&quot;x&quot;),
                      longLongLayout.withName(&quot;y&quot;)
<span class="line-modified">!                 );</span>
<span class="line-modified">!                 VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!                 VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!                 return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),</span>
<span class="line-modified">!                                       BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };</span>
<span class="line-modified">!             };</span>
          return new Object[][]{
<span class="line-modified">!             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
          };
      }
  
      @Test(dataProvider = &quot;bigStructs&quot;)
      public void testBigStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                Function&lt;VaList, Long&gt; sumBigStruct,
                                MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
          try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
<span class="line-modified">!             VH_BigPoint_x.set(struct.address(), 5);</span>
<span class="line-modified">!             VH_BigPoint_y.set(struct.address(), 10);</span>
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {
                  long sum = sumBigStruct.apply(vaList);
                  assertEquals(sum, 15);
              }
<span class="line-new-header">--- 281,49 ---</span>
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] bigStructs() {
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
<span class="line-modified">!                 = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
<span class="line-modified">!                     long x = (long) VH_BigPoint_x.get(struct);</span>
<span class="line-modified">!                     long y = (long) VH_BigPoint_y.get(struct);</span>
                      return x + y;
                  };
  
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
<span class="line-modified">!                 = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
                  MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);
  
          TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
                  TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">!                 = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-modified">!             GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(</span>
                      longLongLayout.withName(&quot;x&quot;),
                      longLongLayout.withName(&quot;y&quot;)
<span class="line-modified">!             );</span>
<span class="line-modified">!             VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!             VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!             return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),</span>
<span class="line-modified">!                     BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };</span>
<span class="line-modified">!         };</span>
          return new Object[][]{
<span class="line-modified">!                 argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
          };
      }
  
      @Test(dataProvider = &quot;bigStructs&quot;)
      public void testBigStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                Function&lt;VaList, Long&gt; sumBigStruct,
                                MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
          try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
<span class="line-modified">!             VH_BigPoint_x.set(struct, 5);</span>
<span class="line-modified">!             VH_BigPoint_y.set(struct, 10);</span>
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {
                  long sum = sumBigStruct.apply(vaList);
                  assertEquals(sum, 15);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,50 ***</span>
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] floatStructs() {
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact
<span class="line-modified">!             = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
<span class="line-modified">!                     float x = (float) VH_FloatPoint_x.get(struct.address());</span>
<span class="line-modified">!                     float y = (float) VH_FloatPoint_y.get(struct.address());</span>
                      return x + y;
                  };
  
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructNativeFact
<span class="line-modified">!             = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
                  MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);
  
          TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
                  TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">!             = (vaListFact, floatLayout, sumFloatStructFact) -&gt; {</span>
<span class="line-modified">!                 GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(</span>
                      floatLayout.withName(&quot;x&quot;),
                      floatLayout.withName(&quot;y&quot;)
<span class="line-modified">!                 );</span>
<span class="line-modified">!                 VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!                 VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!                 return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),</span>
<span class="line-modified">!                                       FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };</span>
<span class="line-modified">!             };</span>
          return new Object[][]{
<span class="line-modified">!             argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),</span>
          };
      }
  
      @Test(dataProvider = &quot;floatStructs&quot;)
      public void testFloatStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                  Function&lt;VaList, Float&gt; sumFloatStruct,
                                  MemoryLayout FloatPoint_LAYOUT,
                                  VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
          try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
<span class="line-modified">!             VH_FloatPoint_x.set(struct.address(), 1.234f);</span>
<span class="line-modified">!             VH_FloatPoint_y.set(struct.address(), 3.142f);</span>
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
                  float sum = sumFloatStruct.apply(vaList);
                  assertEquals(sum, 4.376f, 0.00001f);
              }
<span class="line-new-header">--- 332,50 ---</span>
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] floatStructs() {
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact
<span class="line-modified">!                 = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
<span class="line-modified">!                     float x = (float) VH_FloatPoint_x.get(struct);</span>
<span class="line-modified">!                     float y = (float) VH_FloatPoint_y.get(struct);</span>
                      return x + y;
                  };
  
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructNativeFact
<span class="line-modified">!                 = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
                  MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);
  
          TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
                  TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">!                 = (vaListFact, floatLayout, sumFloatStructFact) -&gt; {</span>
<span class="line-modified">!             GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(</span>
                      floatLayout.withName(&quot;x&quot;),
                      floatLayout.withName(&quot;y&quot;)
<span class="line-modified">!             );</span>
<span class="line-modified">!             VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!             VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!             return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),</span>
<span class="line-modified">!                     FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };</span>
<span class="line-modified">!         };</span>
          return new Object[][]{
<span class="line-modified">!                 argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),</span>
          };
      }
  
      @Test(dataProvider = &quot;floatStructs&quot;)
      public void testFloatStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                  Function&lt;VaList, Float&gt; sumFloatStruct,
                                  MemoryLayout FloatPoint_LAYOUT,
                                  VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
          try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
<span class="line-modified">!             VH_FloatPoint_x.set(struct, 1.234f);</span>
<span class="line-modified">!             VH_FloatPoint_y.set(struct, 3.142f);</span>
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
                  float sum = sumFloatStruct.apply(vaList);
                  assertEquals(sum, 4.376f, 0.00001f);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,43 ***</span>
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] hugeStructs() {
          QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
<span class="line-modified">!             = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
<span class="line-modified">!                     long x = (long) VH_HugePoint_x.get(struct.address());</span>
<span class="line-modified">!                     long y = (long) VH_HugePoint_y.get(struct.address());</span>
<span class="line-modified">!                     long z = (long) VH_HugePoint_z.get(struct.address());</span>
                      return x + y + z;
                  };
  
          QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
<span class="line-modified">!             = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
                  MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);
  
          TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
                  QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">!             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-modified">!                 GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(</span>
                      longLongLayout.withName(&quot;x&quot;),
                      longLongLayout.withName(&quot;y&quot;),
                      longLongLayout.withName(&quot;z&quot;)
<span class="line-modified">!                 );</span>
<span class="line-modified">!                 VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!                 VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!                 VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));</span>
<span class="line-modified">!                 return new Object[] { vaListFact,</span>
<span class="line-modified">!                                       sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),</span>
<span class="line-modified">!                                       HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };</span>
<span class="line-modified">!             };</span>
          return new Object[][]{
<span class="line-modified">!             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-modified">!             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
          };
      }
  
      @Test(dataProvider = &quot;hugeStructs&quot;)
      public void testHugeStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
<span class="line-new-header">--- 388,43 ---</span>
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] hugeStructs() {
          QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
<span class="line-modified">!                 = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
<span class="line-modified">!                     long x = (long) VH_HugePoint_x.get(struct);</span>
<span class="line-modified">!                     long y = (long) VH_HugePoint_y.get(struct);</span>
<span class="line-modified">!                     long z = (long) VH_HugePoint_z.get(struct);</span>
                      return x + y + z;
                  };
  
          QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
<span class="line-modified">!                 = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
                  MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);
  
          TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
                  QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">!                 = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-modified">!             GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(</span>
                      longLongLayout.withName(&quot;x&quot;),
                      longLongLayout.withName(&quot;y&quot;),
                      longLongLayout.withName(&quot;z&quot;)
<span class="line-modified">!             );</span>
<span class="line-modified">!             VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">!             VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">!             VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));</span>
<span class="line-modified">!             return new Object[] { vaListFact,</span>
<span class="line-modified">!                     sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),</span>
<span class="line-modified">!                     HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };</span>
<span class="line-modified">!         };</span>
          return new Object[][]{
<span class="line-modified">!                 argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-modified">!                 argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
          };
      }
  
      @Test(dataProvider = &quot;hugeStructs&quot;)
      public void testHugeStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,58 ***</span>
                                 MemoryLayout HugePoint_LAYOUT,
                                 VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
          // On AArch64 a struct needs to be larger than 16 bytes to be
          // passed by reference.
          try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
<span class="line-modified">!             VH_HugePoint_x.set(struct.address(), 1);</span>
<span class="line-modified">!             VH_HugePoint_y.set(struct.address(), 2);</span>
<span class="line-modified">!             VH_HugePoint_z.set(struct.address(), 3);</span>
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {
                  long sum = sumHugeStruct.apply(vaList);
                  assertEquals(sum, 6);
              }
          }
      }
  
      public interface SumStackFunc {
<span class="line-modified">!         void invoke(MemoryAddress longSum, MemoryAddress doubleSum, VaList list);</span>
      }
  
      @DataProvider
      public static Object[][] sumStack() {
          BiFunction&lt;MemoryLayout, MemoryLayout, SumStackFunc&gt; sumStackJavaFact = (longLayout, doubleLayout) -&gt;
<span class="line-modified">!             (longSum, doubleSum, list) -&gt; {</span>
<span class="line-modified">!                 long lSum = 0L;</span>
<span class="line-modified">!                 for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-modified">!                     lSum += list.vargAsLong(longLayout);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 MemoryAccess.setLong(longSum, lSum);</span>
<span class="line-modified">!                 double dSum = 0D;</span>
<span class="line-modified">!                 for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-modified">!                     dSum += list.vargAsDouble(doubleLayout);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 MemoryAccess.setDouble(doubleSum, dSum);</span>
<span class="line-modified">!             };</span>
<span class="line-modified">!         SumStackFunc sumStackNative = MethodHandleProxies.asInterfaceInstance(SumStackFunc.class, MH_sumStack);</span>
          return new Object[][]{
<span class="line-modified">!             { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },</span>
<span class="line-modified">!             { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },</span>
<span class="line-modified">!             { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },</span>
<span class="line-modified">!             { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },</span>
          };
      }
  
      @Test(dataProvider = &quot;sumStack&quot;)
      public void testStack(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                            SumStackFunc sumStack,
                            MemoryLayout longLayout,
                            MemoryLayout doubleLayout) {
<span class="line-modified">!        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);</span>
<span class="line-modified">!             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {</span>
<span class="line-modified">!             MemoryAccess.setLong(longSum.address(), 0L);</span>
<span class="line-modified">!             MemoryAccess.setDouble(doubleSum.address(), 0D);</span>
  
              VaList list = vaListFactory.apply(b -&gt; {
                  for (long l = 1; l &lt;= 16L; l++) {
                      b.vargFromLong(longLayout, l);
                  }
<span class="line-new-header">--- 432,64 ---</span>
                                 MemoryLayout HugePoint_LAYOUT,
                                 VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
          // On AArch64 a struct needs to be larger than 16 bytes to be
          // passed by reference.
          try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
<span class="line-modified">!             VH_HugePoint_x.set(struct, 1);</span>
<span class="line-modified">!             VH_HugePoint_y.set(struct, 2);</span>
<span class="line-modified">!             VH_HugePoint_z.set(struct, 3);</span>
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {
                  long sum = sumHugeStruct.apply(vaList);
                  assertEquals(sum, 6);
              }
          }
      }
  
      public interface SumStackFunc {
<span class="line-modified">!         void invoke(MemorySegment longSum, MemorySegment doubleSum, VaList list);</span>
      }
  
      @DataProvider
      public static Object[][] sumStack() {
          BiFunction&lt;MemoryLayout, MemoryLayout, SumStackFunc&gt; sumStackJavaFact = (longLayout, doubleLayout) -&gt;
<span class="line-modified">!                 (longSum, doubleSum, list) -&gt; {</span>
<span class="line-modified">!                     long lSum = 0L;</span>
<span class="line-modified">!                     for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-modified">!                         lSum += list.vargAsLong(longLayout);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     MemoryAccess.setLong(longSum, lSum);</span>
<span class="line-modified">!                     double dSum = 0D;</span>
<span class="line-modified">!                     for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-modified">!                         dSum += list.vargAsDouble(doubleLayout);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     MemoryAccess.setDouble(doubleSum, dSum);</span>
<span class="line-modified">!                 };</span>
<span class="line-modified">!         SumStackFunc sumStackNative = (longSum, doubleSum, list) -&gt; {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 MH_sumStack.invokeExact(longSum.address(), doubleSum.address(), list);</span>
<span class="line-added">+             } catch (Throwable ex) {</span>
<span class="line-added">+                 throw new AssertionError(ex);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         };</span>
          return new Object[][]{
<span class="line-modified">!                 { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },</span>
<span class="line-modified">!                 { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },</span>
<span class="line-modified">!                 { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },</span>
<span class="line-modified">!                 { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },</span>
          };
      }
  
      @Test(dataProvider = &quot;sumStack&quot;)
      public void testStack(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                            SumStackFunc sumStack,
                            MemoryLayout longLayout,
                            MemoryLayout doubleLayout) {
<span class="line-modified">!         try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);</span>
<span class="line-modified">!              MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {</span>
<span class="line-modified">!             MemoryAccess.setLong(longSum, 0L);</span>
<span class="line-modified">!             MemoryAccess.setDouble(doubleSum, 0D);</span>
  
              VaList list = vaListFactory.apply(b -&gt; {
                  for (long l = 1; l &lt;= 16L; l++) {
                      b.vargFromLong(longLayout, l);
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 493,15 ***</span>
                      b.vargFromDouble(doubleLayout, d);
                  }
              });
  
              try (list) {
<span class="line-modified">!                 sumStack.invoke(longSum.address(), doubleSum.address(), list);</span>
              }
  
<span class="line-modified">!             long lSum = MemoryAccess.getLong(longSum.address());</span>
<span class="line-modified">!             double dSum = MemoryAccess.getDouble(doubleSum.address());</span>
  
              assertEquals(lSum, 136L);
              assertEquals(dSum, 136D);
          }
      }
<span class="line-new-header">--- 497,15 ---</span>
                      b.vargFromDouble(doubleLayout, d);
                  }
              });
  
              try (list) {
<span class="line-modified">!                 sumStack.invoke(longSum, doubleSum, list);</span>
              }
  
<span class="line-modified">!             long lSum = MemoryAccess.getLong(longSum);</span>
<span class="line-modified">!             double dSum = MemoryAccess.getDouble(doubleSum);</span>
  
              assertEquals(lSum, 136L);
              assertEquals(dSum, 136D);
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 515,50 ***</span>
      }
  
      @DataProvider
      public Object[][] emptyVaLists() {
          return new Object[][] {
<span class="line-modified">!             { Windowsx64Linker.emptyVaList()      },</span>
<span class="line-modified">!             { winVaListFactory.apply(b -&gt; {})     },</span>
<span class="line-modified">!             { SysVx64Linker.emptyVaList()         },</span>
<span class="line-modified">!             { sysvVaListFactory.apply(b -&gt; {})    },</span>
<span class="line-modified">!             { AArch64Linker.emptyVaList()         },</span>
<span class="line-modified">!             { aarch64VaListFactory.apply(b -&gt; {}) },</span>
          };
      }
  
      @Test(expectedExceptions = UnsupportedOperationException.class,
<span class="line-modified">!           expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;,</span>
<span class="line-modified">!           dataProvider = &quot;emptyVaLists&quot;)</span>
      public void testEmptyNotCloseable(VaList emptyList) {
          emptyList.close();
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] sumIntsScoped() {
          Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;
<span class="line-modified">!             (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
          BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative
<span class="line-modified">!             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
          return new Object[][]{
<span class="line-modified">!             { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-modified">!             { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-modified">!             { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-modified">!             { platformVaListScopedFactory, sumIntsNative,                        C_INT         },</span>
          };
      }
  
      @Test(dataProvider = &quot;sumIntsScoped&quot;)
      public void testScopedVaList(BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; vaListFactory,
                                   BiFunction&lt;Integer, VaList, Integer&gt; sumInts,
                                   MemoryLayout intLayout) {
          VaList listLeaked;
          try (NativeScope scope = NativeScope.unboundedScope()) {
              VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">!                                                     .vargFromInt(intLayout, 8),</span>
<span class="line-modified">!                                                scope);</span>
              int x = sumInts.apply(2, list);
              assertEquals(x, 12);
              listLeaked = list;
          }
          assertFalse(listLeaked.isAlive());
<span class="line-new-header">--- 519,50 ---</span>
      }
  
      @DataProvider
      public Object[][] emptyVaLists() {
          return new Object[][] {
<span class="line-modified">!                 { Windowsx64Linker.emptyVaList()      },</span>
<span class="line-modified">!                 { winVaListFactory.apply(b -&gt; {})     },</span>
<span class="line-modified">!                 { SysVx64Linker.emptyVaList()         },</span>
<span class="line-modified">!                 { sysvVaListFactory.apply(b -&gt; {})    },</span>
<span class="line-modified">!                 { AArch64Linker.emptyVaList()         },</span>
<span class="line-modified">!                 { aarch64VaListFactory.apply(b -&gt; {}) },</span>
          };
      }
  
      @Test(expectedExceptions = UnsupportedOperationException.class,
<span class="line-modified">!             expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;,</span>
<span class="line-modified">!             dataProvider = &quot;emptyVaLists&quot;)</span>
      public void testEmptyNotCloseable(VaList emptyList) {
          emptyList.close();
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
      public static Object[][] sumIntsScoped() {
          Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;
<span class="line-modified">!                 (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
          BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative
<span class="line-modified">!                 = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
          return new Object[][]{
<span class="line-modified">!                 { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-modified">!                 { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-modified">!                 { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-modified">!                 { platformVaListScopedFactory, sumIntsNative,                        C_INT         },</span>
          };
      }
  
      @Test(dataProvider = &quot;sumIntsScoped&quot;)
      public void testScopedVaList(BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; vaListFactory,
                                   BiFunction&lt;Integer, VaList, Integer&gt; sumInts,
                                   MemoryLayout intLayout) {
          VaList listLeaked;
          try (NativeScope scope = NativeScope.unboundedScope()) {
              VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">!                             .vargFromInt(intLayout, 8),</span>
<span class="line-modified">!                     scope);</span>
              int x = sumInts.apply(2, list);
              assertEquals(x, 12);
              listLeaked = list;
          }
          assertFalse(listLeaked.isAlive());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 569,16 ***</span>
                                  Function&lt;VaList, Integer&gt; sumStruct, // ignored
                                  MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
          MemorySegment pointOut;
          try (NativeScope scope = NativeScope.unboundedScope()) {
              try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">!                 VH_Point_x.set(pointIn.address(), 3);</span>
<span class="line-modified">!                 VH_Point_y.set(pointIn.address(), 6);</span>
                  try (VaList list = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {
                      pointOut = list.vargAsSegment(Point_LAYOUT, scope);
<span class="line-modified">!                     assertEquals((int) VH_Point_x.get(pointOut.address()), 3);</span>
<span class="line-modified">!                     assertEquals((int) VH_Point_y.get(pointOut.address()), 6);</span>
                  }
                  assertTrue(pointOut.isAlive()); // after VaList freed
              }
              assertTrue(pointOut.isAlive()); // after input MS freed
          }
<span class="line-new-header">--- 573,16 ---</span>
                                  Function&lt;VaList, Integer&gt; sumStruct, // ignored
                                  MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
          MemorySegment pointOut;
          try (NativeScope scope = NativeScope.unboundedScope()) {
              try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">!                 VH_Point_x.set(pointIn, 3);</span>
<span class="line-modified">!                 VH_Point_y.set(pointIn, 6);</span>
                  try (VaList list = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {
                      pointOut = list.vargAsSegment(Point_LAYOUT, scope);
<span class="line-modified">!                     assertEquals((int) VH_Point_x.get(pointOut), 3);</span>
<span class="line-modified">!                     assertEquals((int) VH_Point_y.get(pointOut), 6);</span>
                  }
                  assertTrue(pointOut.isAlive()); // after VaList freed
              }
              assertTrue(pointOut.isAlive()); // after input MS freed
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 586,20 ***</span>
      }
  
      @DataProvider
      public Object[][] copy() {
          return new Object[][] {
<span class="line-modified">!             { winVaListFactory,      Win64.C_INT   },</span>
<span class="line-modified">!             { sysvVaListFactory,     SysV.C_INT    },</span>
<span class="line-modified">!             { aarch64VaListFactory,  AArch64.C_INT },</span>
          };
      }
  
      @Test(dataProvider = &quot;copy&quot;)
      public void testCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
          try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">!                                                      .vargFromInt(intLayout, 8))) {</span>
              VaList  copy = list.copy();
              assertEquals(copy.vargAsInt(intLayout), 4);
              assertEquals(copy.vargAsInt(intLayout), 8);
              copy.close();
  
<span class="line-new-header">--- 590,20 ---</span>
      }
  
      @DataProvider
      public Object[][] copy() {
          return new Object[][] {
<span class="line-modified">!                 { winVaListFactory,      Win64.C_INT   },</span>
<span class="line-modified">!                 { sysvVaListFactory,     SysV.C_INT    },</span>
<span class="line-modified">!                 { aarch64VaListFactory,  AArch64.C_INT },</span>
          };
      }
  
      @Test(dataProvider = &quot;copy&quot;)
      public void testCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
          try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">!                 .vargFromInt(intLayout, 8))) {</span>
              VaList  copy = list.copy();
              assertEquals(copy.vargAsInt(intLayout), 4);
              assertEquals(copy.vargAsInt(intLayout), 8);
              copy.close();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,11 ***</span>
      }
  
      @Test(dataProvider = &quot;copy&quot;)
      public void testScopedCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
          try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">!                                                      .vargFromInt(intLayout, 8))) {</span>
              VaList copy;
              try (NativeScope scope = NativeScope.unboundedScope()) {
                  copy = list.copy(scope);
  
                  assertEquals(copy.vargAsInt(intLayout), 4);
<span class="line-new-header">--- 615,11 ---</span>
      }
  
      @Test(dataProvider = &quot;copy&quot;)
      public void testScopedCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
          try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">!                 .vargFromInt(intLayout, 8))) {</span>
              VaList copy;
              try (NativeScope scope = NativeScope.unboundedScope()) {
                  copy = list.copy(scope);
  
                  assertEquals(copy.vargAsInt(intLayout), 4);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 627,28 ***</span>
              assertEquals(list.vargAsInt(intLayout), 8);
          }
      }
  
      @Test(dataProvider = &quot;copy&quot;,
<span class="line-modified">!           expectedExceptions = IllegalStateException.class)</span>
      public void testCopyUnusableAfterOriginalClosed(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                                      MemoryLayout intLayout) {
          VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">!                                                 .vargFromInt(intLayout, 8));</span>
          try (VaList copy = list.copy()) {
              list.close();
  
              copy.vargAsInt(intLayout); // should throw
          }
      }
  
      @Test(dataProvider = &quot;copy&quot;,
<span class="line-modified">!           expectedExceptions = IllegalStateException.class)</span>
      public void testCopyUnusableAfterOriginalClosedScope(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                                           MemoryLayout intLayout) {
          VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">!                                                 .vargFromInt(intLayout, 8));</span>
          try (NativeScope scope = NativeScope.unboundedScope()) {
              VaList copy = list.copy(scope);
              list.close();
  
              copy.vargAsInt(intLayout); // should throw
<span class="line-new-header">--- 631,28 ---</span>
              assertEquals(list.vargAsInt(intLayout), 8);
          }
      }
  
      @Test(dataProvider = &quot;copy&quot;,
<span class="line-modified">!             expectedExceptions = IllegalStateException.class)</span>
      public void testCopyUnusableAfterOriginalClosed(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                                      MemoryLayout intLayout) {
          VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">!                 .vargFromInt(intLayout, 8));</span>
          try (VaList copy = list.copy()) {
              list.close();
  
              copy.vargAsInt(intLayout); // should throw
          }
      }
  
      @Test(dataProvider = &quot;copy&quot;,
<span class="line-modified">!             expectedExceptions = IllegalStateException.class)</span>
      public void testCopyUnusableAfterOriginalClosedScope(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                                           MemoryLayout intLayout) {
          VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">!                 .vargFromInt(intLayout, 8));</span>
          try (NativeScope scope = NativeScope.unboundedScope()) {
              VaList copy = list.copy(scope);
              list.close();
  
              copy.vargAsInt(intLayout); // should throw
</pre>
<hr />
<pre>
<span class="line-old-header">*** 656,161 ***</span>
      }
  
      @DataProvider
      public static Object[][] upcalls() {
          GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">!             C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">!             C_LONGLONG.withName(&quot;y&quot;)</span>
          );
          VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
          VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
          GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">!             C_INT.withName(&quot;x&quot;),</span>
<span class="line-modified">!             C_INT.withName(&quot;y&quot;)</span>
          );
          VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));
          VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));
          GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">!             C_FLOAT.withName(&quot;x&quot;),</span>
<span class="line-modified">!             C_FLOAT.withName(&quot;y&quot;)</span>
          );
          VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));
          VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));
          GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">!             C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">!             C_LONGLONG.withName(&quot;y&quot;),</span>
<span class="line-modified">!             C_LONGLONG.withName(&quot;z&quot;)</span>
          );
          VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
          VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
          VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));
  
          return new Object[][]{
<span class="line-modified">!             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">!                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);</span>
<span class="line-modified">!                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             })},</span>
<span class="line-modified">!             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                 VaList copy = vaList.copy();</span>
<span class="line-modified">!                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">!                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);</span>
<span class="line-modified">!                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     VH_BigPoint_x.set(struct.address(), 0);</span>
<span class="line-modified">!                     VH_BigPoint_y.set(struct.address(), 0);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // should be independent</span>
<span class="line-modified">!                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">!                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);</span>
<span class="line-modified">!                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             })},</span>
<span class="line-modified">!             { linkVaListCB(&quot;upcallStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                 try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {</span>
<span class="line-modified">!                     assertEquals((int) VH_Point_x.get(struct.address()), 5);</span>
<span class="line-modified">!                     assertEquals((int) VH_Point_y.get(struct.address()), 10);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             })},</span>
<span class="line-modified">!             { linkVaListCB(&quot;upcallHugeStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                 try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {</span>
<span class="line-modified">!                     assertEquals((long) VH_HugePoint_x.get(struct.address()), 1);</span>
<span class="line-modified">!                     assertEquals((long) VH_HugePoint_y.get(struct.address()), 2);</span>
<span class="line-modified">!                     assertEquals((long) VH_HugePoint_z.get(struct.address()), 3);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             })},</span>
<span class="line-modified">!             { linkVaListCB(&quot;upcallFloatStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                 try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {</span>
<span class="line-modified">!                     assertEquals((float) VH_FloatPoint_x.get(struct.address()), 1.0f);</span>
<span class="line-modified">!                     assertEquals((float) VH_FloatPoint_y.get(struct.address()), 2.0f);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             })},</span>
<span class="line-modified">!             { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                 MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);</span>
<span class="line-modified">!                 MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),</span>
<span class="line-modified">!                                                                     Thread.currentThread(), null, null);</span>
<span class="line-modified">!                 int x = MemoryAccess.getInt(ms.address());</span>
<span class="line-modified">!                 assertEquals(x, 10);</span>
<span class="line-modified">!             })},</span>
<span class="line-modified">!             { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);</span>
<span class="line-modified">!             })},</span>
<span class="line-modified">!             { linkVaListCB(&quot;upcallInts&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsInt(C_INT), 10);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsInt(C_INT), 15);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsInt(C_INT), 20);</span>
<span class="line-modified">!             })},</span>
<span class="line-modified">!             { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                 // skip all registers</span>
<span class="line-modified">!                 for (long l = 1; l &lt;= 16; l++) {</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsLong(C_LONGLONG), l);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 for (double d = 1; d &lt;= 16; d++) {</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsDouble(C_DOUBLE), d);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // test some arbitrary values on the stack</span>
<span class="line-modified">!                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);</span>
<span class="line-modified">!                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);</span>
<span class="line-modified">!                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsInt(C_INT), 4);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);</span>
<span class="line-modified">!                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);</span>
<span class="line-modified">!                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);</span>
<span class="line-modified">!                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;b&#39;);</span>
<span class="line-modified">!                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsInt(C_INT), 11);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);</span>
<span class="line-modified">!                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {</span>
<span class="line-modified">!                     assertEquals((int) VH_Point_x.get(point.address()), 5);</span>
<span class="line-modified">!                     assertEquals((int) VH_Point_y.get(point.address()), 10);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 VaList copy = vaList.copy();</span>
<span class="line-modified">!                 try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">!                     assertEquals((long) VH_BigPoint_x.get(bigPoint.address()), 15);</span>
<span class="line-modified">!                     assertEquals((long) VH_BigPoint_y.get(bigPoint.address()), 20);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     VH_BigPoint_x.set(bigPoint.address(), 0);</span>
<span class="line-modified">!                     VH_BigPoint_y.set(bigPoint.address(), 0);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // should be independent</span>
<span class="line-modified">!                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">!                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 15);</span>
<span class="line-modified">!                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 20);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             })},</span>
<span class="line-modified">!             // test skip</span>
<span class="line-modified">!             { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);</span>
<span class="line-modified">!                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);</span>
<span class="line-modified">!                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);</span>
<span class="line-modified">!                 vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);</span>
<span class="line-modified">!                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);</span>
<span class="line-modified">!             })},</span>
          };
      }
  
      interface VaListConsumer {
          void accept(CSupport.VaList list);
  
          static MethodHandle mh(VaListConsumer instance) {
              try {
                  return MethodHandles.lookup().findVirtual(VaListConsumer.class, &quot;accept&quot;,
<span class="line-modified">!                     MethodType.methodType(void.class, VaList.class)).bindTo(instance);</span>
              } catch (ReflectiveOperationException e) {
                  throw new InternalError(e);
              }
          }
      }
<span class="line-new-header">--- 660,161 ---</span>
      }
  
      @DataProvider
      public static Object[][] upcalls() {
          GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">!                 C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">!                 C_LONGLONG.withName(&quot;y&quot;)</span>
          );
          VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
          VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
          GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">!                 C_INT.withName(&quot;x&quot;),</span>
<span class="line-modified">!                 C_INT.withName(&quot;y&quot;)</span>
          );
          VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));
          VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));
          GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">!                 C_FLOAT.withName(&quot;x&quot;),</span>
<span class="line-modified">!                 C_FLOAT.withName(&quot;y&quot;)</span>
          );
          VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));
          VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));
          GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">!                 C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">!                 C_LONGLONG.withName(&quot;y&quot;),</span>
<span class="line-modified">!                 C_LONGLONG.withName(&quot;z&quot;)</span>
          );
          VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
          VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
          VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));
  
          return new Object[][]{
<span class="line-modified">!                 { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                     try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">!                         assertEquals((long) VH_BigPoint_x.get(struct), 8);</span>
<span class="line-modified">!                         assertEquals((long) VH_BigPoint_y.get(struct), 16);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 })},</span>
<span class="line-modified">!                 { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                     VaList copy = vaList.copy();</span>
<span class="line-modified">!                     try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">!                         assertEquals((long) VH_BigPoint_x.get(struct), 8);</span>
<span class="line-modified">!                         assertEquals((long) VH_BigPoint_y.get(struct), 16);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         VH_BigPoint_x.set(struct, 0);</span>
<span class="line-modified">!                         VH_BigPoint_y.set(struct, 0);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // should be independent</span>
<span class="line-modified">!                     try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">!                         assertEquals((long) VH_BigPoint_x.get(struct), 8);</span>
<span class="line-modified">!                         assertEquals((long) VH_BigPoint_y.get(struct), 16);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 })},</span>
<span class="line-modified">!                 { linkVaListCB(&quot;upcallStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                     try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {</span>
<span class="line-modified">!                         assertEquals((int) VH_Point_x.get(struct), 5);</span>
<span class="line-modified">!                         assertEquals((int) VH_Point_y.get(struct), 10);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 })},</span>
<span class="line-modified">!                 { linkVaListCB(&quot;upcallHugeStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                     try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {</span>
<span class="line-modified">!                         assertEquals((long) VH_HugePoint_x.get(struct), 1);</span>
<span class="line-modified">!                         assertEquals((long) VH_HugePoint_y.get(struct), 2);</span>
<span class="line-modified">!                         assertEquals((long) VH_HugePoint_z.get(struct), 3);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 })},</span>
<span class="line-modified">!                 { linkVaListCB(&quot;upcallFloatStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                     try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {</span>
<span class="line-modified">!                         assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);</span>
<span class="line-modified">!                         assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 })},</span>
<span class="line-modified">!                 { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                     MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);</span>
<span class="line-modified">!                     MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),</span>
<span class="line-modified">!                             Thread.currentThread(), null, null);</span>
<span class="line-modified">!                     int x = MemoryAccess.getInt(ms);</span>
<span class="line-modified">!                     assertEquals(x, 10);</span>
<span class="line-modified">!                 })},</span>
<span class="line-modified">!                 { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);</span>
<span class="line-modified">!                 })},</span>
<span class="line-modified">!                 { linkVaListCB(&quot;upcallInts&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsInt(C_INT), 10);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsInt(C_INT), 15);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsInt(C_INT), 20);</span>
<span class="line-modified">!                 })},</span>
<span class="line-modified">!                 { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                     // skip all registers</span>
<span class="line-modified">!                     for (long l = 1; l &lt;= 16; l++) {</span>
<span class="line-modified">!                         assertEquals(vaList.vargAsLong(C_LONGLONG), l);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     for (double d = 1; d &lt;= 16; d++) {</span>
<span class="line-modified">!                         assertEquals(vaList.vargAsDouble(C_DOUBLE), d);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // test some arbitrary values on the stack</span>
<span class="line-modified">!                     assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);</span>
<span class="line-modified">!                     assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);</span>
<span class="line-modified">!                     assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsInt(C_INT), 4);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);</span>
<span class="line-modified">!                     assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);</span>
<span class="line-modified">!                     assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);</span>
<span class="line-modified">!                     assertEquals((char) vaList.vargAsInt(C_INT), &#39;b&#39;);</span>
<span class="line-modified">!                     assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsInt(C_INT), 11);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);</span>
<span class="line-modified">!                     assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {</span>
<span class="line-modified">!                         assertEquals((int) VH_Point_x.get(point), 5);</span>
<span class="line-modified">!                         assertEquals((int) VH_Point_y.get(point), 10);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     VaList copy = vaList.copy();</span>
<span class="line-modified">!                     try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">!                         assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);</span>
<span class="line-modified">!                         assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         VH_BigPoint_x.set(bigPoint, 0);</span>
<span class="line-modified">!                         VH_BigPoint_y.set(bigPoint, 0);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // should be independent</span>
<span class="line-modified">!                     try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">!                         assertEquals((long) VH_BigPoint_x.get(struct), 15);</span>
<span class="line-modified">!                         assertEquals((long) VH_BigPoint_y.get(struct), 20);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 })},</span>
<span class="line-modified">!                 // test skip</span>
<span class="line-modified">!                 { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">!                     vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);</span>
<span class="line-modified">!                     vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);</span>
<span class="line-modified">!                     vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);</span>
<span class="line-modified">!                     vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);</span>
<span class="line-modified">!                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);</span>
<span class="line-modified">!                 })},</span>
          };
      }
  
      interface VaListConsumer {
          void accept(CSupport.VaList list);
  
          static MethodHandle mh(VaListConsumer instance) {
              try {
                  return MethodHandles.lookup().findVirtual(VaListConsumer.class, &quot;accept&quot;,
<span class="line-modified">!                         MethodType.methodType(void.class, VaList.class)).bindTo(instance);</span>
              } catch (ReflectiveOperationException e) {
                  throw new InternalError(e);
              }
          }
      }
</pre>
<center><a href="../TestVarHandleCombinators.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
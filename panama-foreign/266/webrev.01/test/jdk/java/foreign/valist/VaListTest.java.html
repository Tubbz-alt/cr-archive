<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/foreign/valist/VaListTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.
  8  *
  9  *  This code is distributed in the hope that it will be useful, but WITHOUT
 10  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  *  version 2 for more details (a copy is included in the LICENSE file that
 13  *  accompanied this code).
 14  *
 15  *  You should have received a copy of the GNU General Public License version
 16  *  2 along with this work; if not, write to the Free Software Foundation,
 17  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
 27  * @modules jdk.incubator.foreign/jdk.internal.foreign.abi
 28  *          jdk.incubator.foreign/jdk.internal.foreign.abi.aarch64
 29  *          jdk.incubator.foreign/jdk.internal.foreign.abi.x64.windows
 30  *          jdk.incubator.foreign/jdk.internal.foreign.abi.x64.sysv
 31  * @run testng/othervm -Dforeign.restricted=permit VaListTest
 32  */
 33 
 34 import jdk.incubator.foreign.CSupport;
 35 import jdk.incubator.foreign.CSupport.AArch64;
 36 import jdk.incubator.foreign.CSupport.SysV;
 37 import jdk.incubator.foreign.CSupport.VaList;
 38 import jdk.incubator.foreign.CSupport.Win64;
 39 import jdk.incubator.foreign.ForeignLinker;
 40 import jdk.incubator.foreign.FunctionDescriptor;
 41 import jdk.incubator.foreign.GroupLayout;
 42 import jdk.incubator.foreign.LibraryLookup;
 43 import jdk.incubator.foreign.MemoryAccess;
 44 import jdk.incubator.foreign.MemoryAddress;
 45 import jdk.incubator.foreign.MemoryLayout;
 46 import jdk.incubator.foreign.MemorySegment;
 47 import jdk.incubator.foreign.NativeScope;
 48 import jdk.internal.foreign.abi.SharedUtils;
 49 import jdk.internal.foreign.abi.aarch64.AArch64Linker;
 50 import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;
 51 import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;
 52 import org.testng.annotations.DataProvider;
 53 import org.testng.annotations.Test;
 54 
 55 import java.lang.invoke.MethodHandle;
 56 import java.lang.invoke.MethodHandleProxies;
 57 import java.lang.invoke.MethodHandles;
 58 import java.lang.invoke.MethodType;
 59 import java.lang.invoke.VarHandle;
 60 import java.util.function.BiFunction;
 61 import java.util.function.Consumer;
 62 import java.util.function.Function;
 63 import java.util.stream.DoubleStream;
 64 import java.util.stream.IntStream;
 65 
 66 import static jdk.incubator.foreign.CSupport.C_DOUBLE;
 67 import static jdk.incubator.foreign.CSupport.C_FLOAT;
 68 import static jdk.incubator.foreign.CSupport.C_INT;
 69 import static jdk.incubator.foreign.CSupport.C_LONGLONG;
 70 import static jdk.incubator.foreign.CSupport.C_POINTER;
 71 import static jdk.incubator.foreign.CSupport.C_VA_LIST;
 72 import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
 73 import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;
 74 import static org.testng.Assert.assertEquals;
 75 import static org.testng.Assert.assertFalse;
 76 import static org.testng.Assert.assertTrue;
 77 
 78 public class VaListTest {
 79 
 80     private static final ForeignLinker abi = CSupport.getSystemLinker();
 81     private static final LibraryLookup lookup = LibraryLookup.ofLibrary(&quot;VaList&quot;);
 82 
 83     private static final MethodHandle MH_sumInts = link(&quot;sumInts&quot;,
 84             MethodType.methodType(int.class, int.class, VaList.class),
 85             FunctionDescriptor.of(C_INT, C_INT, CSupport.C_VA_LIST));
 86     private static final MethodHandle MH_sumDoubles = link(&quot;sumDoubles&quot;,
 87             MethodType.methodType(double.class, int.class, VaList.class),
 88             FunctionDescriptor.of(C_DOUBLE, C_INT, CSupport.C_VA_LIST));
 89     private static final MethodHandle MH_getInt = link(&quot;getInt&quot;,
 90             MethodType.methodType(int.class, VaList.class),
 91             FunctionDescriptor.of(C_INT, C_VA_LIST));
 92     private static final MethodHandle MH_sumStruct = link(&quot;sumStruct&quot;,
 93             MethodType.methodType(int.class, VaList.class),
 94             FunctionDescriptor.of(C_INT, C_VA_LIST));
 95     private static final MethodHandle MH_sumBigStruct = link(&quot;sumBigStruct&quot;,
 96             MethodType.methodType(long.class, VaList.class),
 97             FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
 98     private static final MethodHandle MH_sumHugeStruct = link(&quot;sumHugeStruct&quot;,
 99             MethodType.methodType(long.class, VaList.class),
100             FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
101     private static final MethodHandle MH_sumFloatStruct = link(&quot;sumFloatStruct&quot;,
102             MethodType.methodType(float.class, VaList.class),
103             FunctionDescriptor.of(C_FLOAT, C_VA_LIST));
104     private static final MethodHandle MH_sumStack = link(&quot;sumStack&quot;,
105             MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, VaList.class),
106             FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_VA_LIST));
107 
108     private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {
109         try {
110             return abi.downcallHandle(lookup.lookup(symbol), mt, fd);
111         } catch (NoSuchMethodException e) {
112             throw new NoSuchMethodError(e.getMessage());
113         }
114     }
115 
116     private static MethodHandle linkVaListCB(String symbol) {
117         return link(symbol,
118                 MethodType.methodType(void.class, MemoryAddress.class),
119                 FunctionDescriptor.ofVoid(C_POINTER));
120 
121     }
122 
123     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; winVaListFactory
124             = actions -&gt; Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);
125     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; sysvVaListFactory
126             = actions -&gt; SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);
127     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; aarch64VaListFactory
128             = actions -&gt; AArch64Linker.newVaList(actions, MemorySegment::allocateNative);
129     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; platformVaListFactory
130             = CSupport.VaList::make;
131 
132     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; winVaListScopedFactory
133             = (actions, scope) -&gt; Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
134     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; sysvVaListScopedFactory
135             = (actions, scope) -&gt; SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
136     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; aarch64VaListScopedFactory
137             = (actions, scope) -&gt; AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
138     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; platformVaListScopedFactory
139             = CSupport.VaList::make;
140 
141     @DataProvider
142     @SuppressWarnings(&quot;unchecked&quot;)
143     public static Object[][] sumInts() {
144         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;
145                 (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();
146         BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative
147                 = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
148         return new Object[][]{
149                 { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
150                 { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
151                 { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
152                 { platformVaListFactory, sumIntsNative,                        C_INT         },
153         };
154     }
155 
156     @Test(dataProvider = &quot;sumInts&quot;)
157     public void testIntSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
158                            BiFunction&lt;Integer, VaList, Integer&gt; sumInts,
159                            MemoryLayout intLayout) {
160         try (VaList vaList = vaListFactory.apply(b -&gt;
161                 b.vargFromInt(intLayout, 10)
162                         .vargFromInt(intLayout, 15)
163                         .vargFromInt(intLayout, 20))) {
164             int x = sumInts.apply(3, vaList);
165             assertEquals(x, 45);
166         }
167     }
168 
169     @DataProvider
170     @SuppressWarnings(&quot;unchecked&quot;)
171     public static Object[][] sumDoubles() {
172         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Double&gt;&gt; sumDoublesJavaFact  = layout -&gt;
173                 (num, list) -&gt; DoubleStream.generate(() -&gt; list.vargAsDouble(layout)).limit(num).sum();
174         BiFunction&lt;Integer, VaList, Double&gt; sumDoublesNative
175                 = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);
176         return new Object[][]{
177                 { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },
178                 { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },
179                 { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },
180                 { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },
181         };
182     }
183 
184     @Test(dataProvider = &quot;sumDoubles&quot;)
185     public void testDoubleSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
186                               BiFunction&lt;Integer, VaList, Double&gt; sumDoubles,
187                               MemoryLayout doubleLayout) {
188         try (VaList vaList = vaListFactory.apply(b -&gt;
189                 b.vargFromDouble(doubleLayout, 3.0D)
190                         .vargFromDouble(doubleLayout, 4.0D)
191                         .vargFromDouble(doubleLayout, 5.0D))) {
192             double x = sumDoubles.apply(3, vaList);
193             assertEquals(x, 12.0D);
194         }
195     }
196 
197     @DataProvider
198     @SuppressWarnings(&quot;unchecked&quot;)
199     public static Object[][] pointers() {
200         Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;
201                 list -&gt; {
202                     MemoryAddress ma = list.vargAsAddress(layout);
203                     return MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), ma.toRawLongValue());
204                 };
205         Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
206         return new Object[][]{
207                 { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
208                 { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },
209                 { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },
210                 { platformVaListFactory, getIntNative,                            C_POINTER         },
211         };
212     }
213 
214     @Test(dataProvider = &quot;pointers&quot;)
215     public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
216                                         Function&lt;VaList, Integer&gt; getFromPointer,
217                                         MemoryLayout pointerLayout) {
218         try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
219             MemoryAccess.setInt(msInt, 10);
220             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.address()))) {
221                 int x = getFromPointer.apply(vaList);
222                 assertEquals(x, 10);
223             }
224         }
225     }
226 
227     interface TriFunction&lt;S, T, U, R&gt; {
228         R apply(S s, T t, U u);
229     }
230 
231     @DataProvider
232     @SuppressWarnings(&quot;unchecked&quot;)
233     public static Object[][] structs() {
234         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact
235                 = (pointLayout, VH_Point_x, VH_Point_y) -&gt;
236                 list -&gt; {
237                     MemorySegment struct = list.vargAsSegment(pointLayout);
238                     int x = (int) VH_Point_x.get(struct);
239                     int y = (int) VH_Point_y.get(struct);
240                     return x + y;
241                 };
242 
243         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructNativeFact
244                 = (pointLayout, VH_Point_x, VH_Point_y) -&gt;
245                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);
246 
247         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
248                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt;, Object[]&gt; argsFact
249                 = (vaListFact, intLayout, sumStructFact) -&gt; {
250             GroupLayout pointLayout =  MemoryLayout.ofStruct(
251                     intLayout.withName(&quot;x&quot;),
252                     intLayout.withName(&quot;y&quot;)
253             );
254             VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(&quot;x&quot;));
255             VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(&quot;y&quot;));
256             return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),
257                     pointLayout, VH_Point_x, VH_Point_y  };
258         };
259         return new Object[][]{
260                 argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),
261                 argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),
262                 argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),
263                 argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),
264         };
265     }
266 
267     @Test(dataProvider = &quot;structs&quot;)
268     public void testStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
269                            Function&lt;VaList, Integer&gt; sumStruct,
270                            MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
271         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
272             VH_Point_x.set(struct, 5);
273             VH_Point_y.set(struct, 10);
274 
275             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {
276                 int sum = sumStruct.apply(vaList);
277                 assertEquals(sum, 15);
278             }
279         }
280     }
281 
282     @DataProvider
283     @SuppressWarnings(&quot;unchecked&quot;)
284     public static Object[][] bigStructs() {
285         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
286                 = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;
287                 list -&gt; {
288                     MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
289                     long x = (long) VH_BigPoint_x.get(struct);
290                     long y = (long) VH_BigPoint_y.get(struct);
291                     return x + y;
292                 };
293 
294         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
295                 = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) -&gt;
296                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);
297 
298         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
299                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
300                 = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {
301             GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(
302                     longLongLayout.withName(&quot;x&quot;),
303                     longLongLayout.withName(&quot;y&quot;)
304             );
305             VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
306             VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
307             return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),
308                     BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };
309         };
310         return new Object[][]{
311                 argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
312                 argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
313                 argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
314                 argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
315         };
316     }
317 
318     @Test(dataProvider = &quot;bigStructs&quot;)
319     public void testBigStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
320                               Function&lt;VaList, Long&gt; sumBigStruct,
321                               MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
322         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
323             VH_BigPoint_x.set(struct, 5);
324             VH_BigPoint_y.set(struct, 10);
325 
326             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {
327                 long sum = sumBigStruct.apply(vaList);
328                 assertEquals(sum, 15);
329             }
330         }
331     }
332 
333     @DataProvider
334     @SuppressWarnings(&quot;unchecked&quot;)
335     public static Object[][] floatStructs() {
336         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact
337                 = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;
338                 list -&gt; {
339                     MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
340                     float x = (float) VH_FloatPoint_x.get(struct);
341                     float y = (float) VH_FloatPoint_y.get(struct);
342                     return x + y;
343                 };
344 
345         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructNativeFact
346                 = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;
347                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);
348 
349         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
350                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt;, Object[]&gt; argsFact
351                 = (vaListFact, floatLayout, sumFloatStructFact) -&gt; {
352             GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
353                     floatLayout.withName(&quot;x&quot;),
354                     floatLayout.withName(&quot;y&quot;)
355             );
356             VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));
357             VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));
358             return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),
359                     FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };
360         };
361         return new Object[][]{
362                 argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),
363                 argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),
364                 argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),
365                 argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),
366         };
367     }
368 
369     @Test(dataProvider = &quot;floatStructs&quot;)
370     public void testFloatStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
371                                 Function&lt;VaList, Float&gt; sumFloatStruct,
372                                 MemoryLayout FloatPoint_LAYOUT,
373                                 VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
374         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
375             VH_FloatPoint_x.set(struct, 1.234f);
376             VH_FloatPoint_y.set(struct, 3.142f);
377 
378             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
379                 float sum = sumFloatStruct.apply(vaList);
380                 assertEquals(sum, 4.376f, 0.00001f);
381             }
382         }
383     }
384 
385     interface QuadFunc&lt;T0, T1, T2, T3, R&gt; {
386         R apply(T0 t0, T1 t1, T2 t2, T3 t3);
387     }
388 
389     @DataProvider
390     @SuppressWarnings(&quot;unchecked&quot;)
391     public static Object[][] hugeStructs() {
392         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
393                 = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;
394                 list -&gt; {
395                     MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
396                     long x = (long) VH_HugePoint_x.get(struct);
397                     long y = (long) VH_HugePoint_y.get(struct);
398                     long z = (long) VH_HugePoint_z.get(struct);
399                     return x + y + z;
400                 };
401 
402         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
403                 = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;
404                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);
405 
406         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
407                 QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
408                 = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {
409             GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
410                     longLongLayout.withName(&quot;x&quot;),
411                     longLongLayout.withName(&quot;y&quot;),
412                     longLongLayout.withName(&quot;z&quot;)
413             );
414             VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
415             VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
416             VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));
417             return new Object[] { vaListFact,
418                     sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),
419                     HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };
420         };
421         return new Object[][]{
422                 argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
423                 argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
424                 argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
425                 argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
426         };
427     }
428 
429     @Test(dataProvider = &quot;hugeStructs&quot;)
430     public void testHugeStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
431                                Function&lt;VaList, Long&gt; sumHugeStruct,
432                                MemoryLayout HugePoint_LAYOUT,
433                                VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
434         // On AArch64 a struct needs to be larger than 16 bytes to be
435         // passed by reference.
436         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
437             VH_HugePoint_x.set(struct, 1);
438             VH_HugePoint_y.set(struct, 2);
439             VH_HugePoint_z.set(struct, 3);
440 
441             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {
442                 long sum = sumHugeStruct.apply(vaList);
443                 assertEquals(sum, 6);
444             }
445         }
446     }
447 
448     public interface SumStackFunc {
449         void invoke(MemorySegment longSum, MemorySegment doubleSum, VaList list);
450     }
451 
452     @DataProvider
453     public static Object[][] sumStack() {
454         BiFunction&lt;MemoryLayout, MemoryLayout, SumStackFunc&gt; sumStackJavaFact = (longLayout, doubleLayout) -&gt;
455                 (longSum, doubleSum, list) -&gt; {
456                     long lSum = 0L;
457                     for (int i = 0; i &lt; 16; i++) {
458                         lSum += list.vargAsLong(longLayout);
459                     }
460                     MemoryAccess.setLong(longSum, lSum);
461                     double dSum = 0D;
462                     for (int i = 0; i &lt; 16; i++) {
463                         dSum += list.vargAsDouble(doubleLayout);
464                     }
465                     MemoryAccess.setDouble(doubleSum, dSum);
466                 };
467         SumStackFunc sumStackNative = (longSum, doubleSum, list) -&gt; {
468             try {
469                 MH_sumStack.invokeExact(longSum.address(), doubleSum.address(), list);
470             } catch (Throwable ex) {
471                 throw new AssertionError(ex);
472             }
473         };
474         return new Object[][]{
475                 { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },
476                 { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },
477                 { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },
478                 { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },
479         };
480     }
481 
482     @Test(dataProvider = &quot;sumStack&quot;)
483     public void testStack(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
484                           SumStackFunc sumStack,
485                           MemoryLayout longLayout,
486                           MemoryLayout doubleLayout) {
487         try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);
488              MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {
489             MemoryAccess.setLong(longSum, 0L);
490             MemoryAccess.setDouble(doubleSum, 0D);
491 
492             VaList list = vaListFactory.apply(b -&gt; {
493                 for (long l = 1; l &lt;= 16L; l++) {
494                     b.vargFromLong(longLayout, l);
495                 }
496                 for (double d = 1; d &lt;= 16D; d++) {
497                     b.vargFromDouble(doubleLayout, d);
498                 }
499             });
500 
501             try (list) {
502                 sumStack.invoke(longSum, doubleSum, list);
503             }
504 
505             long lSum = MemoryAccess.getLong(longSum);
506             double dSum = MemoryAccess.getDouble(doubleSum);
507 
508             assertEquals(lSum, 136L);
509             assertEquals(dSum, 136D);
510         }
511     }
512 
513     @Test(dataProvider = &quot;upcalls&quot;)
514     public void testUpcall(MethodHandle target, MethodHandle callback) throws Throwable {
515         FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);
516         try (MemorySegment stub = abi.upcallStub(callback, desc)) {
517             target.invokeExact(stub.address());
518         }
519     }
520 
521     @DataProvider
522     public Object[][] emptyVaLists() {
523         return new Object[][] {
524                 { Windowsx64Linker.emptyVaList()      },
525                 { winVaListFactory.apply(b -&gt; {})     },
526                 { SysVx64Linker.emptyVaList()         },
527                 { sysvVaListFactory.apply(b -&gt; {})    },
528                 { AArch64Linker.emptyVaList()         },
529                 { aarch64VaListFactory.apply(b -&gt; {}) },
530         };
531     }
532 
533     @Test(expectedExceptions = UnsupportedOperationException.class,
534             expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;,
535             dataProvider = &quot;emptyVaLists&quot;)
536     public void testEmptyNotCloseable(VaList emptyList) {
537         emptyList.close();
538     }
539 
540     @DataProvider
541     @SuppressWarnings(&quot;unchecked&quot;)
542     public static Object[][] sumIntsScoped() {
543         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;
544                 (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();
545         BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative
546                 = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
547         return new Object[][]{
548                 { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
549                 { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
550                 { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
551                 { platformVaListScopedFactory, sumIntsNative,                        C_INT         },
552         };
553     }
554 
555     @Test(dataProvider = &quot;sumIntsScoped&quot;)
556     public void testScopedVaList(BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; vaListFactory,
557                                  BiFunction&lt;Integer, VaList, Integer&gt; sumInts,
558                                  MemoryLayout intLayout) {
559         VaList listLeaked;
560         try (NativeScope scope = NativeScope.unboundedScope()) {
561             VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
562                             .vargFromInt(intLayout, 8),
563                     scope);
564             int x = sumInts.apply(2, list);
565             assertEquals(x, 12);
566             listLeaked = list;
567         }
568         assertFalse(listLeaked.isAlive());
569     }
570 
571     @Test(dataProvider = &quot;structs&quot;)
572     public void testScopeMSRead(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
573                                 Function&lt;VaList, Integer&gt; sumStruct, // ignored
574                                 MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
575         MemorySegment pointOut;
576         try (NativeScope scope = NativeScope.unboundedScope()) {
577             try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
578                 VH_Point_x.set(pointIn, 3);
579                 VH_Point_y.set(pointIn, 6);
580                 try (VaList list = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {
581                     pointOut = list.vargAsSegment(Point_LAYOUT, scope);
582                     assertEquals((int) VH_Point_x.get(pointOut), 3);
583                     assertEquals((int) VH_Point_y.get(pointOut), 6);
584                 }
585                 assertTrue(pointOut.isAlive()); // after VaList freed
586             }
587             assertTrue(pointOut.isAlive()); // after input MS freed
588         }
589         assertFalse(pointOut.isAlive()); // after scope freed
590     }
591 
592     @DataProvider
593     public Object[][] copy() {
594         return new Object[][] {
595                 { winVaListFactory,      Win64.C_INT   },
596                 { sysvVaListFactory,     SysV.C_INT    },
597                 { aarch64VaListFactory,  AArch64.C_INT },
598         };
599     }
600 
601     @Test(dataProvider = &quot;copy&quot;)
602     public void testCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
603         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
604                 .vargFromInt(intLayout, 8))) {
605             VaList  copy = list.copy();
606             assertEquals(copy.vargAsInt(intLayout), 4);
607             assertEquals(copy.vargAsInt(intLayout), 8);
608             copy.close();
609 
610             assertFalse(copy.isAlive());
611 
612             assertEquals(list.vargAsInt(intLayout), 4);
613             assertEquals(list.vargAsInt(intLayout), 8);
614         }
615     }
616 
617     @Test(dataProvider = &quot;copy&quot;)
618     public void testScopedCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
619         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
620                 .vargFromInt(intLayout, 8))) {
621             VaList copy;
622             try (NativeScope scope = NativeScope.unboundedScope()) {
623                 copy = list.copy(scope);
624 
625                 assertEquals(copy.vargAsInt(intLayout), 4);
626                 assertEquals(copy.vargAsInt(intLayout), 8);
627             }
628             assertFalse(copy.isAlive());
629 
630             assertEquals(list.vargAsInt(intLayout), 4);
631             assertEquals(list.vargAsInt(intLayout), 8);
632         }
633     }
634 
635     @Test(dataProvider = &quot;copy&quot;,
636             expectedExceptions = IllegalStateException.class)
637     public void testCopyUnusableAfterOriginalClosed(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
638                                                     MemoryLayout intLayout) {
639         VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
640                 .vargFromInt(intLayout, 8));
641         try (VaList copy = list.copy()) {
642             list.close();
643 
644             copy.vargAsInt(intLayout); // should throw
645         }
646     }
647 
648     @Test(dataProvider = &quot;copy&quot;,
649             expectedExceptions = IllegalStateException.class)
650     public void testCopyUnusableAfterOriginalClosedScope(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
651                                                          MemoryLayout intLayout) {
652         VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
653                 .vargFromInt(intLayout, 8));
654         try (NativeScope scope = NativeScope.unboundedScope()) {
655             VaList copy = list.copy(scope);
656             list.close();
657 
658             copy.vargAsInt(intLayout); // should throw
659         }
660     }
661 
662     @DataProvider
663     public static Object[][] upcalls() {
664         GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(
665                 C_LONGLONG.withName(&quot;x&quot;),
666                 C_LONGLONG.withName(&quot;y&quot;)
667         );
668         VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
669         VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
670         GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(
671                 C_INT.withName(&quot;x&quot;),
672                 C_INT.withName(&quot;y&quot;)
673         );
674         VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));
675         VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));
676         GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
677                 C_FLOAT.withName(&quot;x&quot;),
678                 C_FLOAT.withName(&quot;y&quot;)
679         );
680         VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));
681         VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));
682         GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
683                 C_LONGLONG.withName(&quot;x&quot;),
684                 C_LONGLONG.withName(&quot;y&quot;),
685                 C_LONGLONG.withName(&quot;z&quot;)
686         );
687         VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
688         VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
689         VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));
690 
691         return new Object[][]{
692                 { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
693                     try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
694                         assertEquals((long) VH_BigPoint_x.get(struct), 8);
695                         assertEquals((long) VH_BigPoint_y.get(struct), 16);
696                     }
697                 })},
698                 { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
699                     VaList copy = vaList.copy();
700                     try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
701                         assertEquals((long) VH_BigPoint_x.get(struct), 8);
702                         assertEquals((long) VH_BigPoint_y.get(struct), 16);
703 
704                         VH_BigPoint_x.set(struct, 0);
705                         VH_BigPoint_y.set(struct, 0);
706                     }
707 
708                     // should be independent
709                     try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
710                         assertEquals((long) VH_BigPoint_x.get(struct), 8);
711                         assertEquals((long) VH_BigPoint_y.get(struct), 16);
712                     }
713                 })},
714                 { linkVaListCB(&quot;upcallStruct&quot;), VaListConsumer.mh(vaList -&gt; {
715                     try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {
716                         assertEquals((int) VH_Point_x.get(struct), 5);
717                         assertEquals((int) VH_Point_y.get(struct), 10);
718                     }
719                 })},
720                 { linkVaListCB(&quot;upcallHugeStruct&quot;), VaListConsumer.mh(vaList -&gt; {
721                     try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {
722                         assertEquals((long) VH_HugePoint_x.get(struct), 1);
723                         assertEquals((long) VH_HugePoint_y.get(struct), 2);
724                         assertEquals((long) VH_HugePoint_z.get(struct), 3);
725                     }
726                 })},
727                 { linkVaListCB(&quot;upcallFloatStruct&quot;), VaListConsumer.mh(vaList -&gt; {
728                     try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {
729                         assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);
730                         assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);
731                     }
732                 })},
733                 { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {
734                     MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
735                     MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
736                             Thread.currentThread(), null, null);
737                     int x = MemoryAccess.getInt(ms);
738                     assertEquals(x, 10);
739                 })},
740                 { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {
741                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
742                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
743                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);
744                 })},
745                 { linkVaListCB(&quot;upcallInts&quot;), VaListConsumer.mh(vaList -&gt; {
746                     assertEquals(vaList.vargAsInt(C_INT), 10);
747                     assertEquals(vaList.vargAsInt(C_INT), 15);
748                     assertEquals(vaList.vargAsInt(C_INT), 20);
749                 })},
750                 { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {
751                     // skip all registers
752                     for (long l = 1; l &lt;= 16; l++) {
753                         assertEquals(vaList.vargAsLong(C_LONGLONG), l);
754                     }
755                     for (double d = 1; d &lt;= 16; d++) {
756                         assertEquals(vaList.vargAsDouble(C_DOUBLE), d);
757                     }
758 
759                     // test some arbitrary values on the stack
760                     assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
761                     assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);
762                     assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
763                     assertEquals(vaList.vargAsInt(C_INT), 4);
764                     assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
765                     assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);
766                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);
767                     assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);
768                     assertEquals((char) vaList.vargAsInt(C_INT), &#39;b&#39;);
769                     assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);
770                     assertEquals(vaList.vargAsInt(C_INT), 11);
771                     assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
772                     assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);
773                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
774 
775                     try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {
776                         assertEquals((int) VH_Point_x.get(point), 5);
777                         assertEquals((int) VH_Point_y.get(point), 10);
778                     }
779 
780                     VaList copy = vaList.copy();
781                     try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {
782                         assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);
783                         assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);
784 
785                         VH_BigPoint_x.set(bigPoint, 0);
786                         VH_BigPoint_y.set(bigPoint, 0);
787                     }
788 
789                     // should be independent
790                     try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
791                         assertEquals((long) VH_BigPoint_x.get(struct), 15);
792                         assertEquals((long) VH_BigPoint_y.get(struct), 20);
793                     }
794                 })},
795                 // test skip
796                 { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {
797                     vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
798                     assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
799                     vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
800                     assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);
801                     vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
802                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);
803                     vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);
804                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);
805                 })},
806         };
807     }
808 
809     interface VaListConsumer {
810         void accept(CSupport.VaList list);
811 
812         static MethodHandle mh(VaListConsumer instance) {
813             try {
814                 return MethodHandles.lookup().findVirtual(VaListConsumer.class, &quot;accept&quot;,
815                         MethodType.methodType(void.class, VaList.class)).bindTo(instance);
816             } catch (ReflectiveOperationException e) {
817                 throw new InternalError(e);
818             }
819         }
820     }
821 
822 }
    </pre>
  </body>
</html>
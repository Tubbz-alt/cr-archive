<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/valist/VaListTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../TestVarHandleCombinators.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/valist/VaListTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 98     private static final MethodHandle MH_sumHugeStruct = link(&quot;sumHugeStruct&quot;,
 99             MethodType.methodType(long.class, VaList.class),
100             FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
101     private static final MethodHandle MH_sumFloatStruct = link(&quot;sumFloatStruct&quot;,
102             MethodType.methodType(float.class, VaList.class),
103             FunctionDescriptor.of(C_FLOAT, C_VA_LIST));
104     private static final MethodHandle MH_sumStack = link(&quot;sumStack&quot;,
105             MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, VaList.class),
106             FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_VA_LIST));
107 
108     private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {
109         try {
110             return abi.downcallHandle(lookup.lookup(symbol), mt, fd);
111         } catch (NoSuchMethodException e) {
112             throw new NoSuchMethodError(e.getMessage());
113         }
114     }
115 
116     private static MethodHandle linkVaListCB(String symbol) {
117         return link(symbol,
<span class="line-modified">118             MethodType.methodType(void.class, MemoryAddress.class),</span>
<span class="line-modified">119             FunctionDescriptor.ofVoid(C_POINTER));</span>
120 
121     }
122 
123     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; winVaListFactory
<span class="line-modified">124         = actions -&gt; Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
125     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; sysvVaListFactory
<span class="line-modified">126         = actions -&gt; SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
127     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; aarch64VaListFactory
<span class="line-modified">128         = actions -&gt; AArch64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
129     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; platformVaListFactory
<span class="line-modified">130         = CSupport.VaList::make;</span>
131 
132     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; winVaListScopedFactory
<span class="line-modified">133         = (actions, scope) -&gt; Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
134     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; sysvVaListScopedFactory
<span class="line-modified">135         = (actions, scope) -&gt; SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
136     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; aarch64VaListScopedFactory
<span class="line-modified">137         = (actions, scope) -&gt; AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
138     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; platformVaListScopedFactory
<span class="line-modified">139         = CSupport.VaList::make;</span>
140 
141     @DataProvider
142     @SuppressWarnings(&quot;unchecked&quot;)
143     public static Object[][] sumInts() {
144         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;
<span class="line-modified">145             (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
146         BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative
<span class="line-modified">147             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
148         return new Object[][]{
<span class="line-modified">149             { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-modified">150             { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-modified">151             { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-modified">152             { platformVaListFactory, sumIntsNative,                        C_INT         },</span>
153         };
154     }
155 
156     @Test(dataProvider = &quot;sumInts&quot;)
157     public void testIntSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
158                            BiFunction&lt;Integer, VaList, Integer&gt; sumInts,
159                            MemoryLayout intLayout) {
160         try (VaList vaList = vaListFactory.apply(b -&gt;
161                 b.vargFromInt(intLayout, 10)
<span class="line-modified">162                  .vargFromInt(intLayout, 15)</span>
<span class="line-modified">163                  .vargFromInt(intLayout, 20))) {</span>
164             int x = sumInts.apply(3, vaList);
165             assertEquals(x, 45);
166         }
167     }
168 
169     @DataProvider
170     @SuppressWarnings(&quot;unchecked&quot;)
171     public static Object[][] sumDoubles() {
172         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Double&gt;&gt; sumDoublesJavaFact  = layout -&gt;
<span class="line-modified">173             (num, list) -&gt; DoubleStream.generate(() -&gt; list.vargAsDouble(layout)).limit(num).sum();</span>
174         BiFunction&lt;Integer, VaList, Double&gt; sumDoublesNative
<span class="line-modified">175             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);</span>
176         return new Object[][]{
<span class="line-modified">177             { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },</span>
<span class="line-modified">178             { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },</span>
<span class="line-modified">179             { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },</span>
<span class="line-modified">180             { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },</span>
181         };
182     }
183 
184     @Test(dataProvider = &quot;sumDoubles&quot;)
185     public void testDoubleSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
186                               BiFunction&lt;Integer, VaList, Double&gt; sumDoubles,
187                               MemoryLayout doubleLayout) {
188         try (VaList vaList = vaListFactory.apply(b -&gt;
189                 b.vargFromDouble(doubleLayout, 3.0D)
<span class="line-modified">190                  .vargFromDouble(doubleLayout, 4.0D)</span>
<span class="line-modified">191                  .vargFromDouble(doubleLayout, 5.0D))) {</span>
192             double x = sumDoubles.apply(3, vaList);
193             assertEquals(x, 12.0D);
194         }
195     }
196 
197     @DataProvider
198     @SuppressWarnings(&quot;unchecked&quot;)
199     public static Object[][] pointers() {
200         Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;
<span class="line-modified">201             list -&gt; {</span>
<span class="line-modified">202                 MemoryAddress ma = list.vargAsAddress(layout);</span>
<span class="line-modified">203                 MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,</span>
<span class="line-modified">204                         4, Thread.currentThread(), null, null);</span>
<span class="line-removed">205                 return MemoryAccess.getInt(accessibleSegment.address());</span>
<span class="line-removed">206             };</span>
207         Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
208         return new Object[][]{
<span class="line-modified">209             { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },</span>
<span class="line-modified">210             { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },</span>
<span class="line-modified">211             { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },</span>
<span class="line-modified">212             { platformVaListFactory, getIntNative,                            C_POINTER         },</span>
213         };
214     }
215 
216     @Test(dataProvider = &quot;pointers&quot;)
217     public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
218                                         Function&lt;VaList, Integer&gt; getFromPointer,
219                                         MemoryLayout pointerLayout) {
220         try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
<span class="line-modified">221             MemoryAccess.setInt(msInt.address(), 10);</span>
222             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.address()))) {
223                 int x = getFromPointer.apply(vaList);
224                 assertEquals(x, 10);
225             }
226         }
227     }
228 
229     interface TriFunction&lt;S, T, U, R&gt; {
230         R apply(S s, T t, U u);
231     }
232 
233     @DataProvider
234     @SuppressWarnings(&quot;unchecked&quot;)
235     public static Object[][] structs() {
236         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact
<span class="line-modified">237             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
238                 list -&gt; {
239                     MemorySegment struct = list.vargAsSegment(pointLayout);
<span class="line-modified">240                     int x = (int) VH_Point_x.get(struct.address());</span>
<span class="line-modified">241                     int y = (int) VH_Point_y.get(struct.address());</span>
242                     return x + y;
243                 };
244 
245         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructNativeFact
<span class="line-modified">246             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
247                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);
248 
249         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
250                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">251             = (vaListFact, intLayout, sumStructFact) -&gt; {</span>
<span class="line-modified">252                 GroupLayout pointLayout =  MemoryLayout.ofStruct(</span>
253                     intLayout.withName(&quot;x&quot;),
254                     intLayout.withName(&quot;y&quot;)
<span class="line-modified">255                 );</span>
<span class="line-modified">256                 VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">257                 VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">258                 return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),</span>
<span class="line-modified">259                                       pointLayout, VH_Point_x, VH_Point_y  };</span>
<span class="line-modified">260             };</span>
261         return new Object[][]{
<span class="line-modified">262             argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),</span>
<span class="line-modified">263             argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),</span>
<span class="line-modified">264             argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),</span>
<span class="line-modified">265             argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),</span>
266         };
267     }
268 
269     @Test(dataProvider = &quot;structs&quot;)
270     public void testStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
271                            Function&lt;VaList, Integer&gt; sumStruct,
272                            MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
273         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">274             VH_Point_x.set(struct.address(), 5);</span>
<span class="line-modified">275             VH_Point_y.set(struct.address(), 10);</span>
276 
277             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {
278                 int sum = sumStruct.apply(vaList);
279                 assertEquals(sum, 15);
280             }
281         }
282     }
283 
284     @DataProvider
285     @SuppressWarnings(&quot;unchecked&quot;)
286     public static Object[][] bigStructs() {
287         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
<span class="line-modified">288             = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
289                 list -&gt; {
290                     MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
<span class="line-modified">291                     long x = (long) VH_BigPoint_x.get(struct.address());</span>
<span class="line-modified">292                     long y = (long) VH_BigPoint_y.get(struct.address());</span>
293                     return x + y;
294                 };
295 
296         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
<span class="line-modified">297             = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
298                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);
299 
300         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
301                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">302             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-modified">303                 GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(</span>
304                     longLongLayout.withName(&quot;x&quot;),
305                     longLongLayout.withName(&quot;y&quot;)
<span class="line-modified">306                 );</span>
<span class="line-modified">307                 VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">308                 VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">309                 return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),</span>
<span class="line-modified">310                                       BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };</span>
<span class="line-modified">311             };</span>
312         return new Object[][]{
<span class="line-modified">313             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-modified">314             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-modified">315             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-modified">316             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
317         };
318     }
319 
320     @Test(dataProvider = &quot;bigStructs&quot;)
321     public void testBigStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
322                               Function&lt;VaList, Long&gt; sumBigStruct,
323                               MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
324         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
<span class="line-modified">325             VH_BigPoint_x.set(struct.address(), 5);</span>
<span class="line-modified">326             VH_BigPoint_y.set(struct.address(), 10);</span>
327 
328             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {
329                 long sum = sumBigStruct.apply(vaList);
330                 assertEquals(sum, 15);
331             }
332         }
333     }
334 
335     @DataProvider
336     @SuppressWarnings(&quot;unchecked&quot;)
337     public static Object[][] floatStructs() {
338         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact
<span class="line-modified">339             = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
340                 list -&gt; {
341                     MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
<span class="line-modified">342                     float x = (float) VH_FloatPoint_x.get(struct.address());</span>
<span class="line-modified">343                     float y = (float) VH_FloatPoint_y.get(struct.address());</span>
344                     return x + y;
345                 };
346 
347         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructNativeFact
<span class="line-modified">348             = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
349                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);
350 
351         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
352                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">353             = (vaListFact, floatLayout, sumFloatStructFact) -&gt; {</span>
<span class="line-modified">354                 GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(</span>
355                     floatLayout.withName(&quot;x&quot;),
356                     floatLayout.withName(&quot;y&quot;)
<span class="line-modified">357                 );</span>
<span class="line-modified">358                 VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">359                 VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">360                 return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),</span>
<span class="line-modified">361                                       FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };</span>
<span class="line-modified">362             };</span>
363         return new Object[][]{
<span class="line-modified">364             argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),</span>
<span class="line-modified">365             argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),</span>
<span class="line-modified">366             argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),</span>
<span class="line-modified">367             argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),</span>
368         };
369     }
370 
371     @Test(dataProvider = &quot;floatStructs&quot;)
372     public void testFloatStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
373                                 Function&lt;VaList, Float&gt; sumFloatStruct,
374                                 MemoryLayout FloatPoint_LAYOUT,
375                                 VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
376         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
<span class="line-modified">377             VH_FloatPoint_x.set(struct.address(), 1.234f);</span>
<span class="line-modified">378             VH_FloatPoint_y.set(struct.address(), 3.142f);</span>
379 
380             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
381                 float sum = sumFloatStruct.apply(vaList);
382                 assertEquals(sum, 4.376f, 0.00001f);
383             }
384         }
385     }
386 
387     interface QuadFunc&lt;T0, T1, T2, T3, R&gt; {
388         R apply(T0 t0, T1 t1, T2 t2, T3 t3);
389     }
390 
391     @DataProvider
392     @SuppressWarnings(&quot;unchecked&quot;)
393     public static Object[][] hugeStructs() {
394         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
<span class="line-modified">395             = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
396                 list -&gt; {
397                     MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
<span class="line-modified">398                     long x = (long) VH_HugePoint_x.get(struct.address());</span>
<span class="line-modified">399                     long y = (long) VH_HugePoint_y.get(struct.address());</span>
<span class="line-modified">400                     long z = (long) VH_HugePoint_z.get(struct.address());</span>
401                     return x + y + z;
402                 };
403 
404         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
<span class="line-modified">405             = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
406                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);
407 
408         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
409                 QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">410             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-modified">411                 GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(</span>
412                     longLongLayout.withName(&quot;x&quot;),
413                     longLongLayout.withName(&quot;y&quot;),
414                     longLongLayout.withName(&quot;z&quot;)
<span class="line-modified">415                 );</span>
<span class="line-modified">416                 VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">417                 VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">418                 VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));</span>
<span class="line-modified">419                 return new Object[] { vaListFact,</span>
<span class="line-modified">420                                       sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),</span>
<span class="line-modified">421                                       HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };</span>
<span class="line-modified">422             };</span>
423         return new Object[][]{
<span class="line-modified">424             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-modified">425             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-modified">426             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-modified">427             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
428         };
429     }
430 
431     @Test(dataProvider = &quot;hugeStructs&quot;)
432     public void testHugeStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
433                                Function&lt;VaList, Long&gt; sumHugeStruct,
434                                MemoryLayout HugePoint_LAYOUT,
435                                VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
436         // On AArch64 a struct needs to be larger than 16 bytes to be
437         // passed by reference.
438         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
<span class="line-modified">439             VH_HugePoint_x.set(struct.address(), 1);</span>
<span class="line-modified">440             VH_HugePoint_y.set(struct.address(), 2);</span>
<span class="line-modified">441             VH_HugePoint_z.set(struct.address(), 3);</span>
442 
443             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {
444                 long sum = sumHugeStruct.apply(vaList);
445                 assertEquals(sum, 6);
446             }
447         }
448     }
449 
450     public interface SumStackFunc {
<span class="line-modified">451         void invoke(MemoryAddress longSum, MemoryAddress doubleSum, VaList list);</span>
452     }
453 
454     @DataProvider
455     public static Object[][] sumStack() {
456         BiFunction&lt;MemoryLayout, MemoryLayout, SumStackFunc&gt; sumStackJavaFact = (longLayout, doubleLayout) -&gt;
<span class="line-modified">457             (longSum, doubleSum, list) -&gt; {</span>
<span class="line-modified">458                 long lSum = 0L;</span>
<span class="line-modified">459                 for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-modified">460                     lSum += list.vargAsLong(longLayout);</span>
<span class="line-modified">461                 }</span>
<span class="line-modified">462                 MemoryAccess.setLong(longSum, lSum);</span>
<span class="line-modified">463                 double dSum = 0D;</span>
<span class="line-modified">464                 for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-modified">465                     dSum += list.vargAsDouble(doubleLayout);</span>
<span class="line-modified">466                 }</span>
<span class="line-modified">467                 MemoryAccess.setDouble(doubleSum, dSum);</span>
<span class="line-modified">468             };</span>
<span class="line-modified">469         SumStackFunc sumStackNative = MethodHandleProxies.asInterfaceInstance(SumStackFunc.class, MH_sumStack);</span>






470         return new Object[][]{
<span class="line-modified">471             { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },</span>
<span class="line-modified">472             { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },</span>
<span class="line-modified">473             { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },</span>
<span class="line-modified">474             { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },</span>
475         };
476     }
477 
478     @Test(dataProvider = &quot;sumStack&quot;)
479     public void testStack(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
480                           SumStackFunc sumStack,
481                           MemoryLayout longLayout,
482                           MemoryLayout doubleLayout) {
<span class="line-modified">483        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);</span>
<span class="line-modified">484             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {</span>
<span class="line-modified">485             MemoryAccess.setLong(longSum.address(), 0L);</span>
<span class="line-modified">486             MemoryAccess.setDouble(doubleSum.address(), 0D);</span>
487 
488             VaList list = vaListFactory.apply(b -&gt; {
489                 for (long l = 1; l &lt;= 16L; l++) {
490                     b.vargFromLong(longLayout, l);
491                 }
492                 for (double d = 1; d &lt;= 16D; d++) {
493                     b.vargFromDouble(doubleLayout, d);
494                 }
495             });
496 
497             try (list) {
<span class="line-modified">498                 sumStack.invoke(longSum.address(), doubleSum.address(), list);</span>
499             }
500 
<span class="line-modified">501             long lSum = MemoryAccess.getLong(longSum.address());</span>
<span class="line-modified">502             double dSum = MemoryAccess.getDouble(doubleSum.address());</span>
503 
504             assertEquals(lSum, 136L);
505             assertEquals(dSum, 136D);
506         }
507     }
508 
509     @Test(dataProvider = &quot;upcalls&quot;)
510     public void testUpcall(MethodHandle target, MethodHandle callback) throws Throwable {
511         FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);
512         try (MemorySegment stub = abi.upcallStub(callback, desc)) {
513             target.invokeExact(stub.address());
514         }
515     }
516 
517     @DataProvider
518     public Object[][] emptyVaLists() {
519         return new Object[][] {
<span class="line-modified">520             { Windowsx64Linker.emptyVaList()      },</span>
<span class="line-modified">521             { winVaListFactory.apply(b -&gt; {})     },</span>
<span class="line-modified">522             { SysVx64Linker.emptyVaList()         },</span>
<span class="line-modified">523             { sysvVaListFactory.apply(b -&gt; {})    },</span>
<span class="line-modified">524             { AArch64Linker.emptyVaList()         },</span>
<span class="line-modified">525             { aarch64VaListFactory.apply(b -&gt; {}) },</span>
526         };
527     }
528 
529     @Test(expectedExceptions = UnsupportedOperationException.class,
<span class="line-modified">530           expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;,</span>
<span class="line-modified">531           dataProvider = &quot;emptyVaLists&quot;)</span>
532     public void testEmptyNotCloseable(VaList emptyList) {
533         emptyList.close();
534     }
535 
536     @DataProvider
537     @SuppressWarnings(&quot;unchecked&quot;)
538     public static Object[][] sumIntsScoped() {
539         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;
<span class="line-modified">540             (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
541         BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative
<span class="line-modified">542             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
543         return new Object[][]{
<span class="line-modified">544             { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-modified">545             { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-modified">546             { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-modified">547             { platformVaListScopedFactory, sumIntsNative,                        C_INT         },</span>
548         };
549     }
550 
551     @Test(dataProvider = &quot;sumIntsScoped&quot;)
552     public void testScopedVaList(BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; vaListFactory,
553                                  BiFunction&lt;Integer, VaList, Integer&gt; sumInts,
554                                  MemoryLayout intLayout) {
555         VaList listLeaked;
556         try (NativeScope scope = NativeScope.unboundedScope()) {
557             VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">558                                                     .vargFromInt(intLayout, 8),</span>
<span class="line-modified">559                                                scope);</span>
560             int x = sumInts.apply(2, list);
561             assertEquals(x, 12);
562             listLeaked = list;
563         }
564         assertFalse(listLeaked.isAlive());
565     }
566 
567     @Test(dataProvider = &quot;structs&quot;)
568     public void testScopeMSRead(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
569                                 Function&lt;VaList, Integer&gt; sumStruct, // ignored
570                                 MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
571         MemorySegment pointOut;
572         try (NativeScope scope = NativeScope.unboundedScope()) {
573             try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">574                 VH_Point_x.set(pointIn.address(), 3);</span>
<span class="line-modified">575                 VH_Point_y.set(pointIn.address(), 6);</span>
576                 try (VaList list = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {
577                     pointOut = list.vargAsSegment(Point_LAYOUT, scope);
<span class="line-modified">578                     assertEquals((int) VH_Point_x.get(pointOut.address()), 3);</span>
<span class="line-modified">579                     assertEquals((int) VH_Point_y.get(pointOut.address()), 6);</span>
580                 }
581                 assertTrue(pointOut.isAlive()); // after VaList freed
582             }
583             assertTrue(pointOut.isAlive()); // after input MS freed
584         }
585         assertFalse(pointOut.isAlive()); // after scope freed
586     }
587 
588     @DataProvider
589     public Object[][] copy() {
590         return new Object[][] {
<span class="line-modified">591             { winVaListFactory,      Win64.C_INT   },</span>
<span class="line-modified">592             { sysvVaListFactory,     SysV.C_INT    },</span>
<span class="line-modified">593             { aarch64VaListFactory,  AArch64.C_INT },</span>
594         };
595     }
596 
597     @Test(dataProvider = &quot;copy&quot;)
598     public void testCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
599         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">600                                                      .vargFromInt(intLayout, 8))) {</span>
601             VaList  copy = list.copy();
602             assertEquals(copy.vargAsInt(intLayout), 4);
603             assertEquals(copy.vargAsInt(intLayout), 8);
604             copy.close();
605 
606             assertFalse(copy.isAlive());
607 
608             assertEquals(list.vargAsInt(intLayout), 4);
609             assertEquals(list.vargAsInt(intLayout), 8);
610         }
611     }
612 
613     @Test(dataProvider = &quot;copy&quot;)
614     public void testScopedCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
615         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">616                                                      .vargFromInt(intLayout, 8))) {</span>
617             VaList copy;
618             try (NativeScope scope = NativeScope.unboundedScope()) {
619                 copy = list.copy(scope);
620 
621                 assertEquals(copy.vargAsInt(intLayout), 4);
622                 assertEquals(copy.vargAsInt(intLayout), 8);
623             }
624             assertFalse(copy.isAlive());
625 
626             assertEquals(list.vargAsInt(intLayout), 4);
627             assertEquals(list.vargAsInt(intLayout), 8);
628         }
629     }
630 
631     @Test(dataProvider = &quot;copy&quot;,
<span class="line-modified">632           expectedExceptions = IllegalStateException.class)</span>
633     public void testCopyUnusableAfterOriginalClosed(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
634                                                     MemoryLayout intLayout) {
635         VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">636                                                 .vargFromInt(intLayout, 8));</span>
637         try (VaList copy = list.copy()) {
638             list.close();
639 
640             copy.vargAsInt(intLayout); // should throw
641         }
642     }
643 
644     @Test(dataProvider = &quot;copy&quot;,
<span class="line-modified">645           expectedExceptions = IllegalStateException.class)</span>
646     public void testCopyUnusableAfterOriginalClosedScope(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
647                                                          MemoryLayout intLayout) {
648         VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">649                                                 .vargFromInt(intLayout, 8));</span>
650         try (NativeScope scope = NativeScope.unboundedScope()) {
651             VaList copy = list.copy(scope);
652             list.close();
653 
654             copy.vargAsInt(intLayout); // should throw
655         }
656     }
657 
658     @DataProvider
659     public static Object[][] upcalls() {
660         GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">661             C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">662             C_LONGLONG.withName(&quot;y&quot;)</span>
663         );
664         VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
665         VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
666         GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">667             C_INT.withName(&quot;x&quot;),</span>
<span class="line-modified">668             C_INT.withName(&quot;y&quot;)</span>
669         );
670         VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));
671         VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));
672         GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">673             C_FLOAT.withName(&quot;x&quot;),</span>
<span class="line-modified">674             C_FLOAT.withName(&quot;y&quot;)</span>
675         );
676         VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));
677         VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));
678         GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">679             C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">680             C_LONGLONG.withName(&quot;y&quot;),</span>
<span class="line-modified">681             C_LONGLONG.withName(&quot;z&quot;)</span>
682         );
683         VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
684         VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
685         VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));
686 
687         return new Object[][]{
<span class="line-modified">688             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">689                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">690                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);</span>
<span class="line-modified">691                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);</span>
<span class="line-modified">692                 }</span>
<span class="line-modified">693             })},</span>
<span class="line-modified">694             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">695                 VaList copy = vaList.copy();</span>
<span class="line-modified">696                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">697                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);</span>
<span class="line-modified">698                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);</span>
<span class="line-modified">699 </span>
<span class="line-modified">700                     VH_BigPoint_x.set(struct.address(), 0);</span>
<span class="line-modified">701                     VH_BigPoint_y.set(struct.address(), 0);</span>
<span class="line-modified">702                 }</span>
<span class="line-modified">703 </span>
<span class="line-modified">704                 // should be independent</span>
<span class="line-modified">705                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">706                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);</span>
<span class="line-modified">707                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);</span>
<span class="line-modified">708                 }</span>
<span class="line-modified">709             })},</span>
<span class="line-modified">710             { linkVaListCB(&quot;upcallStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">711                 try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {</span>
<span class="line-modified">712                     assertEquals((int) VH_Point_x.get(struct.address()), 5);</span>
<span class="line-modified">713                     assertEquals((int) VH_Point_y.get(struct.address()), 10);</span>
<span class="line-modified">714                 }</span>
<span class="line-modified">715             })},</span>
<span class="line-modified">716             { linkVaListCB(&quot;upcallHugeStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">717                 try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {</span>
<span class="line-modified">718                     assertEquals((long) VH_HugePoint_x.get(struct.address()), 1);</span>
<span class="line-modified">719                     assertEquals((long) VH_HugePoint_y.get(struct.address()), 2);</span>
<span class="line-modified">720                     assertEquals((long) VH_HugePoint_z.get(struct.address()), 3);</span>
<span class="line-modified">721                 }</span>
<span class="line-modified">722             })},</span>
<span class="line-modified">723             { linkVaListCB(&quot;upcallFloatStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">724                 try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {</span>
<span class="line-modified">725                     assertEquals((float) VH_FloatPoint_x.get(struct.address()), 1.0f);</span>
<span class="line-modified">726                     assertEquals((float) VH_FloatPoint_y.get(struct.address()), 2.0f);</span>
<span class="line-modified">727                 }</span>
<span class="line-modified">728             })},</span>
<span class="line-modified">729             { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">730                 MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);</span>
<span class="line-modified">731                 MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),</span>
<span class="line-modified">732                                                                     Thread.currentThread(), null, null);</span>
<span class="line-modified">733                 int x = MemoryAccess.getInt(ms.address());</span>
<span class="line-modified">734                 assertEquals(x, 10);</span>
<span class="line-modified">735             })},</span>
<span class="line-modified">736             { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">737                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);</span>
<span class="line-modified">738                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);</span>
<span class="line-modified">739                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);</span>
<span class="line-modified">740             })},</span>
<span class="line-modified">741             { linkVaListCB(&quot;upcallInts&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">742                 assertEquals(vaList.vargAsInt(C_INT), 10);</span>
<span class="line-modified">743                 assertEquals(vaList.vargAsInt(C_INT), 15);</span>
<span class="line-modified">744                 assertEquals(vaList.vargAsInt(C_INT), 20);</span>
<span class="line-modified">745             })},</span>
<span class="line-modified">746             { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">747                 // skip all registers</span>
<span class="line-modified">748                 for (long l = 1; l &lt;= 16; l++) {</span>
<span class="line-modified">749                     assertEquals(vaList.vargAsLong(C_LONGLONG), l);</span>
<span class="line-modified">750                 }</span>
<span class="line-modified">751                 for (double d = 1; d &lt;= 16; d++) {</span>
<span class="line-modified">752                     assertEquals(vaList.vargAsDouble(C_DOUBLE), d);</span>
<span class="line-modified">753                 }</span>
<span class="line-modified">754 </span>
<span class="line-modified">755                 // test some arbitrary values on the stack</span>
<span class="line-modified">756                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);</span>
<span class="line-modified">757                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);</span>
<span class="line-modified">758                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);</span>
<span class="line-modified">759                 assertEquals(vaList.vargAsInt(C_INT), 4);</span>
<span class="line-modified">760                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);</span>
<span class="line-modified">761                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);</span>
<span class="line-modified">762                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);</span>
<span class="line-modified">763                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);</span>
<span class="line-modified">764                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;b&#39;);</span>
<span class="line-modified">765                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);</span>
<span class="line-modified">766                 assertEquals(vaList.vargAsInt(C_INT), 11);</span>
<span class="line-modified">767                 assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);</span>
<span class="line-modified">768                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);</span>
<span class="line-modified">769                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);</span>
<span class="line-modified">770 </span>
<span class="line-modified">771                 try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {</span>
<span class="line-modified">772                     assertEquals((int) VH_Point_x.get(point.address()), 5);</span>
<span class="line-modified">773                     assertEquals((int) VH_Point_y.get(point.address()), 10);</span>
<span class="line-modified">774                 }</span>
<span class="line-modified">775 </span>
<span class="line-modified">776                 VaList copy = vaList.copy();</span>
<span class="line-modified">777                 try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">778                     assertEquals((long) VH_BigPoint_x.get(bigPoint.address()), 15);</span>
<span class="line-modified">779                     assertEquals((long) VH_BigPoint_y.get(bigPoint.address()), 20);</span>
<span class="line-modified">780 </span>
<span class="line-modified">781                     VH_BigPoint_x.set(bigPoint.address(), 0);</span>
<span class="line-modified">782                     VH_BigPoint_y.set(bigPoint.address(), 0);</span>
<span class="line-modified">783                 }</span>
<span class="line-modified">784 </span>
<span class="line-modified">785                 // should be independent</span>
<span class="line-modified">786                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">787                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 15);</span>
<span class="line-modified">788                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 20);</span>
<span class="line-modified">789                 }</span>
<span class="line-modified">790             })},</span>
<span class="line-modified">791             // test skip</span>
<span class="line-modified">792             { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">793                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">794                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);</span>
<span class="line-modified">795                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">796                 assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);</span>
<span class="line-modified">797                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">798                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);</span>
<span class="line-modified">799                 vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);</span>
<span class="line-modified">800                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);</span>
<span class="line-modified">801             })},</span>
802         };
803     }
804 
805     interface VaListConsumer {
806         void accept(CSupport.VaList list);
807 
808         static MethodHandle mh(VaListConsumer instance) {
809             try {
810                 return MethodHandles.lookup().findVirtual(VaListConsumer.class, &quot;accept&quot;,
<span class="line-modified">811                     MethodType.methodType(void.class, VaList.class)).bindTo(instance);</span>
812             } catch (ReflectiveOperationException e) {
813                 throw new InternalError(e);
814             }
815         }
816     }
817 
818 }
</pre>
</td>
<td>
<hr />
<pre>
 98     private static final MethodHandle MH_sumHugeStruct = link(&quot;sumHugeStruct&quot;,
 99             MethodType.methodType(long.class, VaList.class),
100             FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
101     private static final MethodHandle MH_sumFloatStruct = link(&quot;sumFloatStruct&quot;,
102             MethodType.methodType(float.class, VaList.class),
103             FunctionDescriptor.of(C_FLOAT, C_VA_LIST));
104     private static final MethodHandle MH_sumStack = link(&quot;sumStack&quot;,
105             MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, VaList.class),
106             FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_VA_LIST));
107 
108     private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {
109         try {
110             return abi.downcallHandle(lookup.lookup(symbol), mt, fd);
111         } catch (NoSuchMethodException e) {
112             throw new NoSuchMethodError(e.getMessage());
113         }
114     }
115 
116     private static MethodHandle linkVaListCB(String symbol) {
117         return link(symbol,
<span class="line-modified">118                 MethodType.methodType(void.class, MemoryAddress.class),</span>
<span class="line-modified">119                 FunctionDescriptor.ofVoid(C_POINTER));</span>
120 
121     }
122 
123     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; winVaListFactory
<span class="line-modified">124             = actions -&gt; Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
125     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; sysvVaListFactory
<span class="line-modified">126             = actions -&gt; SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
127     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; aarch64VaListFactory
<span class="line-modified">128             = actions -&gt; AArch64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
129     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; platformVaListFactory
<span class="line-modified">130             = CSupport.VaList::make;</span>
131 
132     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; winVaListScopedFactory
<span class="line-modified">133             = (actions, scope) -&gt; Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
134     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; sysvVaListScopedFactory
<span class="line-modified">135             = (actions, scope) -&gt; SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
136     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; aarch64VaListScopedFactory
<span class="line-modified">137             = (actions, scope) -&gt; AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
138     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; platformVaListScopedFactory
<span class="line-modified">139             = CSupport.VaList::make;</span>
140 
141     @DataProvider
142     @SuppressWarnings(&quot;unchecked&quot;)
143     public static Object[][] sumInts() {
144         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;
<span class="line-modified">145                 (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
146         BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative
<span class="line-modified">147                 = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
148         return new Object[][]{
<span class="line-modified">149                 { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-modified">150                 { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-modified">151                 { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-modified">152                 { platformVaListFactory, sumIntsNative,                        C_INT         },</span>
153         };
154     }
155 
156     @Test(dataProvider = &quot;sumInts&quot;)
157     public void testIntSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
158                            BiFunction&lt;Integer, VaList, Integer&gt; sumInts,
159                            MemoryLayout intLayout) {
160         try (VaList vaList = vaListFactory.apply(b -&gt;
161                 b.vargFromInt(intLayout, 10)
<span class="line-modified">162                         .vargFromInt(intLayout, 15)</span>
<span class="line-modified">163                         .vargFromInt(intLayout, 20))) {</span>
164             int x = sumInts.apply(3, vaList);
165             assertEquals(x, 45);
166         }
167     }
168 
169     @DataProvider
170     @SuppressWarnings(&quot;unchecked&quot;)
171     public static Object[][] sumDoubles() {
172         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Double&gt;&gt; sumDoublesJavaFact  = layout -&gt;
<span class="line-modified">173                 (num, list) -&gt; DoubleStream.generate(() -&gt; list.vargAsDouble(layout)).limit(num).sum();</span>
174         BiFunction&lt;Integer, VaList, Double&gt; sumDoublesNative
<span class="line-modified">175                 = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);</span>
176         return new Object[][]{
<span class="line-modified">177                 { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },</span>
<span class="line-modified">178                 { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },</span>
<span class="line-modified">179                 { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },</span>
<span class="line-modified">180                 { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },</span>
181         };
182     }
183 
184     @Test(dataProvider = &quot;sumDoubles&quot;)
185     public void testDoubleSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
186                               BiFunction&lt;Integer, VaList, Double&gt; sumDoubles,
187                               MemoryLayout doubleLayout) {
188         try (VaList vaList = vaListFactory.apply(b -&gt;
189                 b.vargFromDouble(doubleLayout, 3.0D)
<span class="line-modified">190                         .vargFromDouble(doubleLayout, 4.0D)</span>
<span class="line-modified">191                         .vargFromDouble(doubleLayout, 5.0D))) {</span>
192             double x = sumDoubles.apply(3, vaList);
193             assertEquals(x, 12.0D);
194         }
195     }
196 
197     @DataProvider
198     @SuppressWarnings(&quot;unchecked&quot;)
199     public static Object[][] pointers() {
200         Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;
<span class="line-modified">201                 list -&gt; {</span>
<span class="line-modified">202                     MemoryAddress ma = list.vargAsAddress(layout);</span>
<span class="line-modified">203                     return MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), ma.toRawLongValue());</span>
<span class="line-modified">204                 };</span>


205         Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
206         return new Object[][]{
<span class="line-modified">207                 { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },</span>
<span class="line-modified">208                 { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },</span>
<span class="line-modified">209                 { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },</span>
<span class="line-modified">210                 { platformVaListFactory, getIntNative,                            C_POINTER         },</span>
211         };
212     }
213 
214     @Test(dataProvider = &quot;pointers&quot;)
215     public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
216                                         Function&lt;VaList, Integer&gt; getFromPointer,
217                                         MemoryLayout pointerLayout) {
218         try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
<span class="line-modified">219             MemoryAccess.setInt(msInt, 10);</span>
220             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.address()))) {
221                 int x = getFromPointer.apply(vaList);
222                 assertEquals(x, 10);
223             }
224         }
225     }
226 
227     interface TriFunction&lt;S, T, U, R&gt; {
228         R apply(S s, T t, U u);
229     }
230 
231     @DataProvider
232     @SuppressWarnings(&quot;unchecked&quot;)
233     public static Object[][] structs() {
234         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact
<span class="line-modified">235                 = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
236                 list -&gt; {
237                     MemorySegment struct = list.vargAsSegment(pointLayout);
<span class="line-modified">238                     int x = (int) VH_Point_x.get(struct);</span>
<span class="line-modified">239                     int y = (int) VH_Point_y.get(struct);</span>
240                     return x + y;
241                 };
242 
243         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructNativeFact
<span class="line-modified">244                 = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
245                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);
246 
247         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
248                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">249                 = (vaListFact, intLayout, sumStructFact) -&gt; {</span>
<span class="line-modified">250             GroupLayout pointLayout =  MemoryLayout.ofStruct(</span>
251                     intLayout.withName(&quot;x&quot;),
252                     intLayout.withName(&quot;y&quot;)
<span class="line-modified">253             );</span>
<span class="line-modified">254             VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">255             VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">256             return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),</span>
<span class="line-modified">257                     pointLayout, VH_Point_x, VH_Point_y  };</span>
<span class="line-modified">258         };</span>
259         return new Object[][]{
<span class="line-modified">260                 argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),</span>
<span class="line-modified">261                 argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),</span>
<span class="line-modified">262                 argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),</span>
<span class="line-modified">263                 argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),</span>
264         };
265     }
266 
267     @Test(dataProvider = &quot;structs&quot;)
268     public void testStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
269                            Function&lt;VaList, Integer&gt; sumStruct,
270                            MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
271         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">272             VH_Point_x.set(struct, 5);</span>
<span class="line-modified">273             VH_Point_y.set(struct, 10);</span>
274 
275             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {
276                 int sum = sumStruct.apply(vaList);
277                 assertEquals(sum, 15);
278             }
279         }
280     }
281 
282     @DataProvider
283     @SuppressWarnings(&quot;unchecked&quot;)
284     public static Object[][] bigStructs() {
285         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
<span class="line-modified">286                 = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
287                 list -&gt; {
288                     MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
<span class="line-modified">289                     long x = (long) VH_BigPoint_x.get(struct);</span>
<span class="line-modified">290                     long y = (long) VH_BigPoint_y.get(struct);</span>
291                     return x + y;
292                 };
293 
294         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
<span class="line-modified">295                 = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
296                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);
297 
298         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
299                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">300                 = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-modified">301             GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(</span>
302                     longLongLayout.withName(&quot;x&quot;),
303                     longLongLayout.withName(&quot;y&quot;)
<span class="line-modified">304             );</span>
<span class="line-modified">305             VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">306             VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">307             return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),</span>
<span class="line-modified">308                     BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };</span>
<span class="line-modified">309         };</span>
310         return new Object[][]{
<span class="line-modified">311                 argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-modified">312                 argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-modified">313                 argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-modified">314                 argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
315         };
316     }
317 
318     @Test(dataProvider = &quot;bigStructs&quot;)
319     public void testBigStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
320                               Function&lt;VaList, Long&gt; sumBigStruct,
321                               MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
322         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
<span class="line-modified">323             VH_BigPoint_x.set(struct, 5);</span>
<span class="line-modified">324             VH_BigPoint_y.set(struct, 10);</span>
325 
326             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {
327                 long sum = sumBigStruct.apply(vaList);
328                 assertEquals(sum, 15);
329             }
330         }
331     }
332 
333     @DataProvider
334     @SuppressWarnings(&quot;unchecked&quot;)
335     public static Object[][] floatStructs() {
336         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact
<span class="line-modified">337                 = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
338                 list -&gt; {
339                     MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
<span class="line-modified">340                     float x = (float) VH_FloatPoint_x.get(struct);</span>
<span class="line-modified">341                     float y = (float) VH_FloatPoint_y.get(struct);</span>
342                     return x + y;
343                 };
344 
345         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructNativeFact
<span class="line-modified">346                 = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
347                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);
348 
349         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
350                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">351                 = (vaListFact, floatLayout, sumFloatStructFact) -&gt; {</span>
<span class="line-modified">352             GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(</span>
353                     floatLayout.withName(&quot;x&quot;),
354                     floatLayout.withName(&quot;y&quot;)
<span class="line-modified">355             );</span>
<span class="line-modified">356             VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">357             VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">358             return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),</span>
<span class="line-modified">359                     FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };</span>
<span class="line-modified">360         };</span>
361         return new Object[][]{
<span class="line-modified">362                 argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),</span>
<span class="line-modified">363                 argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),</span>
<span class="line-modified">364                 argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),</span>
<span class="line-modified">365                 argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),</span>
366         };
367     }
368 
369     @Test(dataProvider = &quot;floatStructs&quot;)
370     public void testFloatStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
371                                 Function&lt;VaList, Float&gt; sumFloatStruct,
372                                 MemoryLayout FloatPoint_LAYOUT,
373                                 VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
374         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
<span class="line-modified">375             VH_FloatPoint_x.set(struct, 1.234f);</span>
<span class="line-modified">376             VH_FloatPoint_y.set(struct, 3.142f);</span>
377 
378             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
379                 float sum = sumFloatStruct.apply(vaList);
380                 assertEquals(sum, 4.376f, 0.00001f);
381             }
382         }
383     }
384 
385     interface QuadFunc&lt;T0, T1, T2, T3, R&gt; {
386         R apply(T0 t0, T1 t1, T2 t2, T3 t3);
387     }
388 
389     @DataProvider
390     @SuppressWarnings(&quot;unchecked&quot;)
391     public static Object[][] hugeStructs() {
392         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
<span class="line-modified">393                 = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
394                 list -&gt; {
395                     MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
<span class="line-modified">396                     long x = (long) VH_HugePoint_x.get(struct);</span>
<span class="line-modified">397                     long y = (long) VH_HugePoint_y.get(struct);</span>
<span class="line-modified">398                     long z = (long) VH_HugePoint_z.get(struct);</span>
399                     return x + y + z;
400                 };
401 
402         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
<span class="line-modified">403                 = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
404                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);
405 
406         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
407                 QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
<span class="line-modified">408                 = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-modified">409             GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(</span>
410                     longLongLayout.withName(&quot;x&quot;),
411                     longLongLayout.withName(&quot;y&quot;),
412                     longLongLayout.withName(&quot;z&quot;)
<span class="line-modified">413             );</span>
<span class="line-modified">414             VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">415             VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">416             VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));</span>
<span class="line-modified">417             return new Object[] { vaListFact,</span>
<span class="line-modified">418                     sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),</span>
<span class="line-modified">419                     HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };</span>
<span class="line-modified">420         };</span>
421         return new Object[][]{
<span class="line-modified">422                 argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-modified">423                 argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-modified">424                 argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-modified">425                 argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
426         };
427     }
428 
429     @Test(dataProvider = &quot;hugeStructs&quot;)
430     public void testHugeStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
431                                Function&lt;VaList, Long&gt; sumHugeStruct,
432                                MemoryLayout HugePoint_LAYOUT,
433                                VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
434         // On AArch64 a struct needs to be larger than 16 bytes to be
435         // passed by reference.
436         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
<span class="line-modified">437             VH_HugePoint_x.set(struct, 1);</span>
<span class="line-modified">438             VH_HugePoint_y.set(struct, 2);</span>
<span class="line-modified">439             VH_HugePoint_z.set(struct, 3);</span>
440 
441             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {
442                 long sum = sumHugeStruct.apply(vaList);
443                 assertEquals(sum, 6);
444             }
445         }
446     }
447 
448     public interface SumStackFunc {
<span class="line-modified">449         void invoke(MemorySegment longSum, MemorySegment doubleSum, VaList list);</span>
450     }
451 
452     @DataProvider
453     public static Object[][] sumStack() {
454         BiFunction&lt;MemoryLayout, MemoryLayout, SumStackFunc&gt; sumStackJavaFact = (longLayout, doubleLayout) -&gt;
<span class="line-modified">455                 (longSum, doubleSum, list) -&gt; {</span>
<span class="line-modified">456                     long lSum = 0L;</span>
<span class="line-modified">457                     for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-modified">458                         lSum += list.vargAsLong(longLayout);</span>
<span class="line-modified">459                     }</span>
<span class="line-modified">460                     MemoryAccess.setLong(longSum, lSum);</span>
<span class="line-modified">461                     double dSum = 0D;</span>
<span class="line-modified">462                     for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-modified">463                         dSum += list.vargAsDouble(doubleLayout);</span>
<span class="line-modified">464                     }</span>
<span class="line-modified">465                     MemoryAccess.setDouble(doubleSum, dSum);</span>
<span class="line-modified">466                 };</span>
<span class="line-modified">467         SumStackFunc sumStackNative = (longSum, doubleSum, list) -&gt; {</span>
<span class="line-added">468             try {</span>
<span class="line-added">469                 MH_sumStack.invokeExact(longSum.address(), doubleSum.address(), list);</span>
<span class="line-added">470             } catch (Throwable ex) {</span>
<span class="line-added">471                 throw new AssertionError(ex);</span>
<span class="line-added">472             }</span>
<span class="line-added">473         };</span>
474         return new Object[][]{
<span class="line-modified">475                 { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },</span>
<span class="line-modified">476                 { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },</span>
<span class="line-modified">477                 { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },</span>
<span class="line-modified">478                 { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },</span>
479         };
480     }
481 
482     @Test(dataProvider = &quot;sumStack&quot;)
483     public void testStack(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
484                           SumStackFunc sumStack,
485                           MemoryLayout longLayout,
486                           MemoryLayout doubleLayout) {
<span class="line-modified">487         try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);</span>
<span class="line-modified">488              MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {</span>
<span class="line-modified">489             MemoryAccess.setLong(longSum, 0L);</span>
<span class="line-modified">490             MemoryAccess.setDouble(doubleSum, 0D);</span>
491 
492             VaList list = vaListFactory.apply(b -&gt; {
493                 for (long l = 1; l &lt;= 16L; l++) {
494                     b.vargFromLong(longLayout, l);
495                 }
496                 for (double d = 1; d &lt;= 16D; d++) {
497                     b.vargFromDouble(doubleLayout, d);
498                 }
499             });
500 
501             try (list) {
<span class="line-modified">502                 sumStack.invoke(longSum, doubleSum, list);</span>
503             }
504 
<span class="line-modified">505             long lSum = MemoryAccess.getLong(longSum);</span>
<span class="line-modified">506             double dSum = MemoryAccess.getDouble(doubleSum);</span>
507 
508             assertEquals(lSum, 136L);
509             assertEquals(dSum, 136D);
510         }
511     }
512 
513     @Test(dataProvider = &quot;upcalls&quot;)
514     public void testUpcall(MethodHandle target, MethodHandle callback) throws Throwable {
515         FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);
516         try (MemorySegment stub = abi.upcallStub(callback, desc)) {
517             target.invokeExact(stub.address());
518         }
519     }
520 
521     @DataProvider
522     public Object[][] emptyVaLists() {
523         return new Object[][] {
<span class="line-modified">524                 { Windowsx64Linker.emptyVaList()      },</span>
<span class="line-modified">525                 { winVaListFactory.apply(b -&gt; {})     },</span>
<span class="line-modified">526                 { SysVx64Linker.emptyVaList()         },</span>
<span class="line-modified">527                 { sysvVaListFactory.apply(b -&gt; {})    },</span>
<span class="line-modified">528                 { AArch64Linker.emptyVaList()         },</span>
<span class="line-modified">529                 { aarch64VaListFactory.apply(b -&gt; {}) },</span>
530         };
531     }
532 
533     @Test(expectedExceptions = UnsupportedOperationException.class,
<span class="line-modified">534             expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;,</span>
<span class="line-modified">535             dataProvider = &quot;emptyVaLists&quot;)</span>
536     public void testEmptyNotCloseable(VaList emptyList) {
537         emptyList.close();
538     }
539 
540     @DataProvider
541     @SuppressWarnings(&quot;unchecked&quot;)
542     public static Object[][] sumIntsScoped() {
543         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;
<span class="line-modified">544                 (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
545         BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative
<span class="line-modified">546                 = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
547         return new Object[][]{
<span class="line-modified">548                 { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-modified">549                 { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-modified">550                 { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-modified">551                 { platformVaListScopedFactory, sumIntsNative,                        C_INT         },</span>
552         };
553     }
554 
555     @Test(dataProvider = &quot;sumIntsScoped&quot;)
556     public void testScopedVaList(BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; vaListFactory,
557                                  BiFunction&lt;Integer, VaList, Integer&gt; sumInts,
558                                  MemoryLayout intLayout) {
559         VaList listLeaked;
560         try (NativeScope scope = NativeScope.unboundedScope()) {
561             VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">562                             .vargFromInt(intLayout, 8),</span>
<span class="line-modified">563                     scope);</span>
564             int x = sumInts.apply(2, list);
565             assertEquals(x, 12);
566             listLeaked = list;
567         }
568         assertFalse(listLeaked.isAlive());
569     }
570 
571     @Test(dataProvider = &quot;structs&quot;)
572     public void testScopeMSRead(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
573                                 Function&lt;VaList, Integer&gt; sumStruct, // ignored
574                                 MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
575         MemorySegment pointOut;
576         try (NativeScope scope = NativeScope.unboundedScope()) {
577             try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">578                 VH_Point_x.set(pointIn, 3);</span>
<span class="line-modified">579                 VH_Point_y.set(pointIn, 6);</span>
580                 try (VaList list = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {
581                     pointOut = list.vargAsSegment(Point_LAYOUT, scope);
<span class="line-modified">582                     assertEquals((int) VH_Point_x.get(pointOut), 3);</span>
<span class="line-modified">583                     assertEquals((int) VH_Point_y.get(pointOut), 6);</span>
584                 }
585                 assertTrue(pointOut.isAlive()); // after VaList freed
586             }
587             assertTrue(pointOut.isAlive()); // after input MS freed
588         }
589         assertFalse(pointOut.isAlive()); // after scope freed
590     }
591 
592     @DataProvider
593     public Object[][] copy() {
594         return new Object[][] {
<span class="line-modified">595                 { winVaListFactory,      Win64.C_INT   },</span>
<span class="line-modified">596                 { sysvVaListFactory,     SysV.C_INT    },</span>
<span class="line-modified">597                 { aarch64VaListFactory,  AArch64.C_INT },</span>
598         };
599     }
600 
601     @Test(dataProvider = &quot;copy&quot;)
602     public void testCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
603         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">604                 .vargFromInt(intLayout, 8))) {</span>
605             VaList  copy = list.copy();
606             assertEquals(copy.vargAsInt(intLayout), 4);
607             assertEquals(copy.vargAsInt(intLayout), 8);
608             copy.close();
609 
610             assertFalse(copy.isAlive());
611 
612             assertEquals(list.vargAsInt(intLayout), 4);
613             assertEquals(list.vargAsInt(intLayout), 8);
614         }
615     }
616 
617     @Test(dataProvider = &quot;copy&quot;)
618     public void testScopedCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
619         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">620                 .vargFromInt(intLayout, 8))) {</span>
621             VaList copy;
622             try (NativeScope scope = NativeScope.unboundedScope()) {
623                 copy = list.copy(scope);
624 
625                 assertEquals(copy.vargAsInt(intLayout), 4);
626                 assertEquals(copy.vargAsInt(intLayout), 8);
627             }
628             assertFalse(copy.isAlive());
629 
630             assertEquals(list.vargAsInt(intLayout), 4);
631             assertEquals(list.vargAsInt(intLayout), 8);
632         }
633     }
634 
635     @Test(dataProvider = &quot;copy&quot;,
<span class="line-modified">636             expectedExceptions = IllegalStateException.class)</span>
637     public void testCopyUnusableAfterOriginalClosed(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
638                                                     MemoryLayout intLayout) {
639         VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">640                 .vargFromInt(intLayout, 8));</span>
641         try (VaList copy = list.copy()) {
642             list.close();
643 
644             copy.vargAsInt(intLayout); // should throw
645         }
646     }
647 
648     @Test(dataProvider = &quot;copy&quot;,
<span class="line-modified">649             expectedExceptions = IllegalStateException.class)</span>
650     public void testCopyUnusableAfterOriginalClosedScope(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
651                                                          MemoryLayout intLayout) {
652         VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
<span class="line-modified">653                 .vargFromInt(intLayout, 8));</span>
654         try (NativeScope scope = NativeScope.unboundedScope()) {
655             VaList copy = list.copy(scope);
656             list.close();
657 
658             copy.vargAsInt(intLayout); // should throw
659         }
660     }
661 
662     @DataProvider
663     public static Object[][] upcalls() {
664         GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">665                 C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">666                 C_LONGLONG.withName(&quot;y&quot;)</span>
667         );
668         VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
669         VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
670         GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">671                 C_INT.withName(&quot;x&quot;),</span>
<span class="line-modified">672                 C_INT.withName(&quot;y&quot;)</span>
673         );
674         VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));
675         VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));
676         GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">677                 C_FLOAT.withName(&quot;x&quot;),</span>
<span class="line-modified">678                 C_FLOAT.withName(&quot;y&quot;)</span>
679         );
680         VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));
681         VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));
682         GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
<span class="line-modified">683                 C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">684                 C_LONGLONG.withName(&quot;y&quot;),</span>
<span class="line-modified">685                 C_LONGLONG.withName(&quot;z&quot;)</span>
686         );
687         VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
688         VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
689         VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));
690 
691         return new Object[][]{
<span class="line-modified">692                 { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">693                     try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">694                         assertEquals((long) VH_BigPoint_x.get(struct), 8);</span>
<span class="line-modified">695                         assertEquals((long) VH_BigPoint_y.get(struct), 16);</span>
<span class="line-modified">696                     }</span>
<span class="line-modified">697                 })},</span>
<span class="line-modified">698                 { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">699                     VaList copy = vaList.copy();</span>
<span class="line-modified">700                     try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">701                         assertEquals((long) VH_BigPoint_x.get(struct), 8);</span>
<span class="line-modified">702                         assertEquals((long) VH_BigPoint_y.get(struct), 16);</span>
<span class="line-modified">703 </span>
<span class="line-modified">704                         VH_BigPoint_x.set(struct, 0);</span>
<span class="line-modified">705                         VH_BigPoint_y.set(struct, 0);</span>
<span class="line-modified">706                     }</span>
<span class="line-modified">707 </span>
<span class="line-modified">708                     // should be independent</span>
<span class="line-modified">709                     try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">710                         assertEquals((long) VH_BigPoint_x.get(struct), 8);</span>
<span class="line-modified">711                         assertEquals((long) VH_BigPoint_y.get(struct), 16);</span>
<span class="line-modified">712                     }</span>
<span class="line-modified">713                 })},</span>
<span class="line-modified">714                 { linkVaListCB(&quot;upcallStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">715                     try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {</span>
<span class="line-modified">716                         assertEquals((int) VH_Point_x.get(struct), 5);</span>
<span class="line-modified">717                         assertEquals((int) VH_Point_y.get(struct), 10);</span>
<span class="line-modified">718                     }</span>
<span class="line-modified">719                 })},</span>
<span class="line-modified">720                 { linkVaListCB(&quot;upcallHugeStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">721                     try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {</span>
<span class="line-modified">722                         assertEquals((long) VH_HugePoint_x.get(struct), 1);</span>
<span class="line-modified">723                         assertEquals((long) VH_HugePoint_y.get(struct), 2);</span>
<span class="line-modified">724                         assertEquals((long) VH_HugePoint_z.get(struct), 3);</span>
<span class="line-modified">725                     }</span>
<span class="line-modified">726                 })},</span>
<span class="line-modified">727                 { linkVaListCB(&quot;upcallFloatStruct&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">728                     try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {</span>
<span class="line-modified">729                         assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);</span>
<span class="line-modified">730                         assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);</span>
<span class="line-modified">731                     }</span>
<span class="line-modified">732                 })},</span>
<span class="line-modified">733                 { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">734                     MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);</span>
<span class="line-modified">735                     MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),</span>
<span class="line-modified">736                             Thread.currentThread(), null, null);</span>
<span class="line-modified">737                     int x = MemoryAccess.getInt(ms);</span>
<span class="line-modified">738                     assertEquals(x, 10);</span>
<span class="line-modified">739                 })},</span>
<span class="line-modified">740                 { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">741                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);</span>
<span class="line-modified">742                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);</span>
<span class="line-modified">743                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);</span>
<span class="line-modified">744                 })},</span>
<span class="line-modified">745                 { linkVaListCB(&quot;upcallInts&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">746                     assertEquals(vaList.vargAsInt(C_INT), 10);</span>
<span class="line-modified">747                     assertEquals(vaList.vargAsInt(C_INT), 15);</span>
<span class="line-modified">748                     assertEquals(vaList.vargAsInt(C_INT), 20);</span>
<span class="line-modified">749                 })},</span>
<span class="line-modified">750                 { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">751                     // skip all registers</span>
<span class="line-modified">752                     for (long l = 1; l &lt;= 16; l++) {</span>
<span class="line-modified">753                         assertEquals(vaList.vargAsLong(C_LONGLONG), l);</span>
<span class="line-modified">754                     }</span>
<span class="line-modified">755                     for (double d = 1; d &lt;= 16; d++) {</span>
<span class="line-modified">756                         assertEquals(vaList.vargAsDouble(C_DOUBLE), d);</span>
<span class="line-modified">757                     }</span>
<span class="line-modified">758 </span>
<span class="line-modified">759                     // test some arbitrary values on the stack</span>
<span class="line-modified">760                     assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);</span>
<span class="line-modified">761                     assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);</span>
<span class="line-modified">762                     assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);</span>
<span class="line-modified">763                     assertEquals(vaList.vargAsInt(C_INT), 4);</span>
<span class="line-modified">764                     assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);</span>
<span class="line-modified">765                     assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);</span>
<span class="line-modified">766                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);</span>
<span class="line-modified">767                     assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);</span>
<span class="line-modified">768                     assertEquals((char) vaList.vargAsInt(C_INT), &#39;b&#39;);</span>
<span class="line-modified">769                     assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);</span>
<span class="line-modified">770                     assertEquals(vaList.vargAsInt(C_INT), 11);</span>
<span class="line-modified">771                     assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);</span>
<span class="line-modified">772                     assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);</span>
<span class="line-modified">773                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);</span>
<span class="line-modified">774 </span>
<span class="line-modified">775                     try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {</span>
<span class="line-modified">776                         assertEquals((int) VH_Point_x.get(point), 5);</span>
<span class="line-modified">777                         assertEquals((int) VH_Point_y.get(point), 10);</span>
<span class="line-modified">778                     }</span>
<span class="line-modified">779 </span>
<span class="line-modified">780                     VaList copy = vaList.copy();</span>
<span class="line-modified">781                     try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">782                         assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);</span>
<span class="line-modified">783                         assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);</span>
<span class="line-modified">784 </span>
<span class="line-modified">785                         VH_BigPoint_x.set(bigPoint, 0);</span>
<span class="line-modified">786                         VH_BigPoint_y.set(bigPoint, 0);</span>
<span class="line-modified">787                     }</span>
<span class="line-modified">788 </span>
<span class="line-modified">789                     // should be independent</span>
<span class="line-modified">790                     try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {</span>
<span class="line-modified">791                         assertEquals((long) VH_BigPoint_x.get(struct), 15);</span>
<span class="line-modified">792                         assertEquals((long) VH_BigPoint_y.get(struct), 20);</span>
<span class="line-modified">793                     }</span>
<span class="line-modified">794                 })},</span>
<span class="line-modified">795                 // test skip</span>
<span class="line-modified">796                 { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {</span>
<span class="line-modified">797                     vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">798                     assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);</span>
<span class="line-modified">799                     vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">800                     assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);</span>
<span class="line-modified">801                     vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);</span>
<span class="line-modified">802                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);</span>
<span class="line-modified">803                     vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);</span>
<span class="line-modified">804                     assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);</span>
<span class="line-modified">805                 })},</span>
806         };
807     }
808 
809     interface VaListConsumer {
810         void accept(CSupport.VaList list);
811 
812         static MethodHandle mh(VaListConsumer instance) {
813             try {
814                 return MethodHandles.lookup().findVirtual(VaListConsumer.class, &quot;accept&quot;,
<span class="line-modified">815                         MethodType.methodType(void.class, VaList.class)).bindTo(instance);</span>
816             } catch (ReflectiveOperationException e) {
817                 throw new InternalError(e);
818             }
819         }
820     }
821 
822 }
</pre>
</td>
</tr>
</table>
<center><a href="../TestVarHandleCombinators.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
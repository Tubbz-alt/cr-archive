diff a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
--- a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
+++ b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
@@ -34,30 +34,23 @@
     final boolean be;
 
     /** access size (in bytes, computed from var handle carrier type) **/
     final long length;
 
-    /** access offset (in bytes); must be compatible with {@code alignmentMask} **/
-    final long offset;
-
     /** alignment constraint (in bytes, expressed as a bit mask) **/
     final long alignmentMask;
 
-    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long offset, long alignmentMask) {
+    /** if true, only the base part of the address will be checked for alignment **/
+    final boolean skipAlignmentMaskCheck;
+
+    MemoryAccessVarHandleBase(VarForm form, boolean skipOffetCheck, boolean be, long length, long alignmentMask) {
         super(form);
+        this.skipAlignmentMaskCheck = skipOffetCheck;
         this.be = be;
         this.length = length;
-        this.offset = offset;
         this.alignmentMask = alignmentMask;
     }
 
     static IllegalStateException newIllegalStateExceptionForMisalignedAccess(long address) {
         return new IllegalStateException("Misaligned access at address: " + address);
     }
-
-    /**
-     * Strides used for multi-dimensional access; each stride must be compatible with {@code alignmentMask}.
-     */
-    abstract long[] strides();
-
-    abstract Class<?> carrier();
 }
diff a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
--- a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
+++ /dev/null
@@ -1,510 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.lang.invoke;
-
-import jdk.internal.access.foreign.MemoryAddressProxy;
-import jdk.internal.org.objectweb.asm.ClassReader;
-import jdk.internal.org.objectweb.asm.ClassWriter;
-import jdk.internal.org.objectweb.asm.ConstantDynamic;
-import jdk.internal.org.objectweb.asm.Handle;
-import jdk.internal.org.objectweb.asm.MethodVisitor;
-import jdk.internal.org.objectweb.asm.Opcodes;
-import jdk.internal.org.objectweb.asm.Type;
-import jdk.internal.org.objectweb.asm.util.TraceClassVisitor;
-import jdk.internal.vm.annotation.ForceInline;
-import sun.security.action.GetBooleanAction;
-import sun.security.action.GetPropertyAction;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.Arrays;
-import java.util.HashMap;
-
-import static jdk.internal.org.objectweb.asm.Opcodes.AALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;
-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.ASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.BIPUSH;
-import static jdk.internal.org.objectweb.asm.Opcodes.CHECKCAST;
-import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;
-import static jdk.internal.org.objectweb.asm.Opcodes.GETSTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_1;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_2;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_3;
-import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.LALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.LASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.LLOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.NEWARRAY;
-import static jdk.internal.org.objectweb.asm.Opcodes.PUTFIELD;
-import static jdk.internal.org.objectweb.asm.Opcodes.PUTSTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP;
-import static jdk.internal.org.objectweb.asm.Opcodes.SIPUSH;
-import static jdk.internal.org.objectweb.asm.Opcodes.T_LONG;
-import static jdk.internal.org.objectweb.asm.Opcodes.V14;
-
-class MemoryAccessVarHandleGenerator {
-    private static final String DEBUG_DUMP_CLASSES_DIR_PROPERTY = "jdk.internal.foreign.ClassGenerator.DEBUG_DUMP_CLASSES_DIR";
-
-    private static final boolean DEBUG =
-        GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.ClassGenerator.DEBUG");
-
-    private static final Class<?> BASE_CLASS = MemoryAccessVarHandleBase.class;
-
-    private static final HashMap<Class<?>, Class<?>> helperClassCache;
-
-    private final static MethodType OFFSET_OP_TYPE;
-
-    private final static MethodHandle ADD_OFFSETS_HANDLE;
-    private final static MethodHandle MUL_OFFSETS_HANDLE;
-
-    static {
-        helperClassCache = new HashMap<>();
-        helperClassCache.put(byte.class, MemoryAccessVarHandleByteHelper.class);
-        helperClassCache.put(short.class, MemoryAccessVarHandleShortHelper.class);
-        helperClassCache.put(char.class, MemoryAccessVarHandleCharHelper.class);
-        helperClassCache.put(int.class, MemoryAccessVarHandleIntHelper.class);
-        helperClassCache.put(long.class, MemoryAccessVarHandleLongHelper.class);
-        helperClassCache.put(float.class, MemoryAccessVarHandleFloatHelper.class);
-        helperClassCache.put(double.class, MemoryAccessVarHandleDoubleHelper.class);
-
-        OFFSET_OP_TYPE = MethodType.methodType(long.class, long.class, long.class, MemoryAddressProxy.class);
-
-        try {
-            ADD_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "addOffsets", OFFSET_OP_TYPE);
-            MUL_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "multiplyOffsets", OFFSET_OP_TYPE);
-        } catch (Throwable ex) {
-            throw new ExceptionInInitializerError(ex);
-        }
-    }
-
-    private static final File DEBUG_DUMP_CLASSES_DIR;
-
-    static {
-        String path = GetPropertyAction.privilegedGetProperty(DEBUG_DUMP_CLASSES_DIR_PROPERTY);
-        if (path == null) {
-            DEBUG_DUMP_CLASSES_DIR = null;
-        } else {
-            DEBUG_DUMP_CLASSES_DIR = new File(path);
-        }
-    }
-
-    private final String implClassName;
-    private final int dimensions;
-    private final Class<?> carrier;
-    private final Class<?> helperClass;
-    private final VarForm form;
-    private final Object[] classData;
-
-    MemoryAccessVarHandleGenerator(Class<?> carrier, int dims) {
-        this.dimensions = dims;
-        this.carrier = carrier;
-        Class<?>[] components = new Class<?>[dimensions];
-        Arrays.fill(components, long.class);
-        this.form = new VarForm(BASE_CLASS, MemoryAddressProxy.class, carrier, components);
-        this.helperClass = helperClassCache.get(carrier);
-        this.implClassName = helperClass.getName().replace('.', '/') + dimensions;
-        // live constants
-        Class<?>[] intermediate = new Class<?>[dimensions];
-        Arrays.fill(intermediate, long.class);
-        this.classData = new Object[] { carrier, intermediate, ADD_OFFSETS_HANDLE, MUL_OFFSETS_HANDLE };
-    }
-
-    /*
-     * Generate a VarHandle memory access factory.
-     * The factory has type (ZJJ[J)VarHandle.
-     */
-    MethodHandle generateHandleFactory() {
-        byte[] classBytes = generateClassBytes();
-        if (DEBUG_DUMP_CLASSES_DIR != null) {
-            debugWriteClassToFile(classBytes);
-        }
-        try {
-            MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClassWithClassData(classBytes, classData);
-            Class<?> implCls = lookup.lookupClass();
-            Class<?>[] components = new Class<?>[dimensions];
-            Arrays.fill(components, long.class);
-
-            VarForm form = new VarForm(implCls, MemoryAddressProxy.class, carrier, components);
-
-            MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
-            MethodHandle constr = lookup.findConstructor(implCls, constrType);
-            constr = MethodHandles.insertArguments(constr, 0, form);
-            return constr;
-        } catch (Throwable ex) {
-            debugPrintClass(classBytes);
-            throw new AssertionError(ex);
-        }
-    }
-
-    /*
-     * Generate a specialized VarHandle class for given carrier
-     * and access coordinates.
-     */
-    byte[] generateClassBytes() {
-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
-
-        if (DEBUG) {
-            System.out.println("Generating header implementation class");
-        }
-
-        cw.visit(V14, ACC_PUBLIC | ACC_SUPER, implClassName, null, Type.getInternalName(BASE_CLASS), null);
-
-        //add dimension fields
-        for (int i = 0; i < dimensions; i++) {
-            cw.visitField(ACC_PRIVATE | ACC_FINAL, "dim" + i, "J", null, null);
-        }
-
-        addStaticInitializer(cw);
-
-        addConstructor(cw);
-
-        addAccessModeTypeMethod(cw);
-
-        addStridesAccessor(cw);
-
-        addCarrierAccessor(cw);
-
-        for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {
-            addAccessModeMethodIfNeeded(mode, cw);
-        }
-
-        cw.visitEnd();
-        return cw.toByteArray();
-    }
-
-    void addStaticInitializer(ClassWriter cw) {
-        // carrier and intermediate
-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, "carrier", Class.class.descriptorString(), null, null);
-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, "intermediate", Class[].class.descriptorString(), null, null);
-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, "addHandle", MethodHandle.class.descriptorString(), null, null);
-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, "mulHandle", MethodHandle.class.descriptorString(), null, null);
-
-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
-        mv.visitCode();
-        // extract class data in static final fields
-        MethodType mtype = MethodType.methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);
-        Handle bsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), "classData",
-                    mtype.descriptorString(), false);
-        ConstantDynamic dynamic = new ConstantDynamic("classData", Object[].class.descriptorString(), bsm);
-        mv.visitLdcInsn(dynamic);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Object[].class));
-        mv.visitVarInsn(ASTORE, 0);
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitInsn(ICONST_0);
-        mv.visitInsn(AALOAD);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
-        mv.visitFieldInsn(PUTSTATIC, implClassName, "carrier", Class.class.descriptorString());
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitInsn(ICONST_1);
-        mv.visitInsn(AALOAD);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class[].class));
-        mv.visitFieldInsn(PUTSTATIC, implClassName, "intermediate", Class[].class.descriptorString());
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitInsn(ICONST_2);
-        mv.visitInsn(AALOAD);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
-        mv.visitFieldInsn(PUTSTATIC, implClassName, "addHandle", MethodHandle.class.descriptorString());
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitInsn(ICONST_3);
-        mv.visitInsn(AALOAD);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
-        mv.visitFieldInsn(PUTSTATIC, implClassName, "mulHandle", MethodHandle.class.descriptorString());
-        mv.visitInsn(Opcodes.RETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addConstructor(ClassWriter cw) {
-        MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
-        MethodVisitor mv = cw.visitMethod(0, "<init>", constrType.toMethodDescriptorString(), null, null);
-        mv.visitCode();
-        //super call
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitVarInsn(ALOAD, 1);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(VarForm.class));
-        mv.visitVarInsn(ILOAD, 2);
-        mv.visitVarInsn(LLOAD, 3);
-        mv.visitVarInsn(LLOAD, 5);
-        mv.visitVarInsn(LLOAD, 7);
-        mv.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(BASE_CLASS), "<init>",
-                MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class).toMethodDescriptorString(), false);
-        //init dimensions
-        for (int i = 0 ; i < dimensions ; i++) {
-            mv.visitVarInsn(ALOAD, 0);
-            mv.visitVarInsn(ALOAD, 9);
-            mv.visitLdcInsn(i);
-            mv.visitInsn(LALOAD);
-            mv.visitFieldInsn(PUTFIELD, implClassName, "dim" + i, "J");
-        }
-        mv.visitInsn(RETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addAccessModeTypeMethod(ClassWriter cw) {
-        MethodType modeMethType = MethodType.methodType(MethodType.class, VarHandle.AccessMode.class);
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "accessModeTypeUncached", modeMethType.toMethodDescriptorString(), null, null);
-        mv.visitCode();
-        mv.visitVarInsn(ALOAD, 1);
-        mv.visitFieldInsn(GETFIELD, Type.getInternalName(VarHandle.AccessMode.class), "at", VarHandle.AccessType.class.descriptorString());
-        mv.visitLdcInsn(Type.getType(MemoryAddressProxy.class));
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
-        mv.visitFieldInsn(GETSTATIC, implClassName, "carrier", Class.class.descriptorString());
-        mv.visitFieldInsn(GETSTATIC, implClassName, "intermediate", Class[].class.descriptorString());
-
-        mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(VarHandle.AccessType.class),
-                "accessModeType", MethodType.methodType(MethodType.class, Class.class, Class.class, Class[].class).toMethodDescriptorString(), false);
-
-        mv.visitInsn(ARETURN);
-
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addAccessModeMethodIfNeeded(VarHandle.AccessMode mode, ClassWriter cw) {
-        String methName = mode.methodName();
-        MethodType methType = form.getMethodType(mode.at.ordinal())
-                .insertParameterTypes(0, VarHandle.class);
-
-        try {
-            MethodType helperType = methType.insertParameterTypes(2, long.class);
-            if (dimensions > 0) {
-                helperType = helperType.dropParameterTypes(3, 3 + dimensions);
-            }
-            //try to resolve...
-            String helperMethodName = methName + "0";
-            MethodHandles.Lookup.IMPL_LOOKUP
-                    .findStatic(helperClass,
-                            helperMethodName,
-                            helperType);
-
-
-            MethodVisitor mv = cw.visitMethod(ACC_STATIC, methName, methType.toMethodDescriptorString(), null, null);
-            mv.visitAnnotation(Type.getDescriptor(ForceInline.class), true);
-            mv.visitCode();
-
-            mv.visitVarInsn(ALOAD, 0); // handle impl
-            mv.visitVarInsn(ALOAD, 1); // receiver
-
-            // offset calculation
-            int slot = 2;
-            mv.visitVarInsn(ALOAD, 0); // load recv
-            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(BASE_CLASS));
-            mv.visitFieldInsn(GETFIELD, Type.getInternalName(BASE_CLASS), "offset", "J");
-            for (int i = 0 ; i < dimensions ; i++) {
-                // load ADD MH
-                mv.visitFieldInsn(GETSTATIC, implClassName, "addHandle", MethodHandle.class.descriptorString());
-
-                //fixup stack so that ADD MH ends up bottom
-                mv.visitInsn(Opcodes.DUP_X2);
-                mv.visitInsn(Opcodes.POP);
-
-                // load MUL MH
-                mv.visitFieldInsn(GETSTATIC, implClassName, "mulHandle", MethodHandle.class.descriptorString());
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
-
-                mv.visitVarInsn(ALOAD, 0); // load recv
-                mv.visitTypeInsn(CHECKCAST, implClassName);
-                mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
-                mv.visitVarInsn(LLOAD, slot);
-
-                mv.visitVarInsn(ALOAD, 1); // receiver
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
-
-                //MUL
-                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
-                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
-
-                mv.visitVarInsn(ALOAD, 1); // receiver
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
-
-                //ADD
-                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
-                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
-                slot += 2;
-            }
-
-            for (int i = 2 + dimensions; i < methType.parameterCount() ; i++) {
-                Class<?> param = methType.parameterType(i);
-                mv.visitVarInsn(loadInsn(param), slot); // load index
-                slot += getSlotsForType(param);
-            }
-
-            //call helper
-            mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(helperClass), helperMethodName,
-                    helperType.toMethodDescriptorString(), false);
-
-            mv.visitInsn(returnInsn(helperType.returnType()));
-
-            mv.visitMaxs(0, 0);
-            mv.visitEnd();
-        } catch (ReflectiveOperationException ex) {
-            //not found, skip
-        }
-    }
-
-    void addStridesAccessor(ClassWriter cw) {
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "strides", "()[J", null, null);
-        mv.visitCode();
-        iConstInsn(mv, dimensions);
-        mv.visitIntInsn(NEWARRAY, T_LONG);
-
-        for (int i = 0 ; i < dimensions ; i++) {
-            mv.visitInsn(DUP);
-            iConstInsn(mv, i);
-            mv.visitVarInsn(ALOAD, 0);
-            mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
-            mv.visitInsn(LASTORE);
-        }
-
-        mv.visitInsn(ARETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addCarrierAccessor(ClassWriter cw) {
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "carrier", "()Ljava/lang/Class;", null, null);
-        mv.visitCode();
-        mv.visitFieldInsn(GETSTATIC, implClassName, "carrier", Class.class.descriptorString());
-        mv.visitInsn(ARETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    // shared code generation helpers
-
-    private static int getSlotsForType(Class<?> c) {
-        if (c == long.class || c == double.class) {
-            return 2;
-        }
-        return 1;
-    }
-
-    /**
-     * Emits an actual return instruction conforming to the given return type.
-     */
-    private int returnInsn(Class<?> type) {
-        return switch (LambdaForm.BasicType.basicType(type)) {
-            case I_TYPE -> Opcodes.IRETURN;
-            case J_TYPE -> Opcodes.LRETURN;
-            case F_TYPE -> Opcodes.FRETURN;
-            case D_TYPE -> Opcodes.DRETURN;
-            case L_TYPE -> Opcodes.ARETURN;
-            case V_TYPE -> RETURN;
-        };
-    }
-
-    private int loadInsn(Class<?> type) {
-        return switch (LambdaForm.BasicType.basicType(type)) {
-            case I_TYPE -> Opcodes.ILOAD;
-            case J_TYPE -> LLOAD;
-            case F_TYPE -> Opcodes.FLOAD;
-            case D_TYPE -> Opcodes.DLOAD;
-            case L_TYPE -> Opcodes.ALOAD;
-            case V_TYPE -> throw new IllegalStateException("Cannot load void");
-        };
-    }
-
-    private static void iConstInsn(MethodVisitor mv, int i) {
-        switch (i) {
-            case -1, 0, 1, 2, 3, 4, 5:
-                mv.visitInsn(ICONST_0 + i);
-                break;
-            default:
-                if(i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE) {
-                    mv.visitIntInsn(BIPUSH, i);
-                } else if (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {
-                    mv.visitIntInsn(SIPUSH, i);
-                } else {
-                    mv.visitLdcInsn(i);
-                }
-        }
-    }
-
-    // debug helpers
-
-    private static String debugPrintClass(byte[] classFile) {
-        ClassReader cr = new ClassReader(classFile);
-        StringWriter sw = new StringWriter();
-        cr.accept(new TraceClassVisitor(new PrintWriter(sw)), 0);
-        return sw.toString();
-    }
-
-    private void debugWriteClassToFile(byte[] classFile) {
-        File file = new File(DEBUG_DUMP_CLASSES_DIR, implClassName + ".class");
-
-        if (DEBUG) {
-            System.err.println("Dumping class " + implClassName + " to " + file);
-        }
-
-        try {
-            debugWriteDataToFile(classFile, file);
-        } catch (Exception e) {
-            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
-        }
-    }
-
-    private void debugWriteDataToFile(byte[] data, File file) {
-        if (file.exists()) {
-            file.delete();
-        }
-        if (file.exists()) {
-            throw new RuntimeException("Failed to remove pre-existing file " + file);
-        }
-
-        File parent = file.getParentFile();
-        if (!parent.exists()) {
-            parent.mkdirs();
-        }
-        if (!parent.exists()) {
-            throw new RuntimeException("Failed to create " + parent);
-        }
-        if (!parent.isDirectory()) {
-            throw new RuntimeException(parent + " is not a directory");
-        }
-
-        try (FileOutputStream fos = new FileOutputStream(file)) {
-            fos.write(data);
-        } catch (IOException e) {
-            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
-        }
-    }
-}
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
@@ -1800,50 +1800,19 @@
                 return GenerateJLIClassesHelper
                         .generateInvokersHolderClassBytes(className,
                                 invokerMethodTypes, callSiteMethodTypes);
             }
 
-            @Override
-            public VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask,
-                                                   ByteOrder order, long offset, long[] strides) {
-                return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);
-            }
-
-            @Override
-            public Class<?> memoryAddressCarrier(VarHandle handle) {
-                return checkMemoryAccessHandle(handle).carrier();
-            }
-
-            @Override
-            public long memoryAddressAlignmentMask(VarHandle handle) {
-                return checkMemoryAccessHandle(handle).alignmentMask;
-            }
-
-            @Override
-            public ByteOrder memoryAddressByteOrder(VarHandle handle) {
-                return checkMemoryAccessHandle(handle).be ?
-                        ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
-            }
-
-            @Override
-            public long memoryAddressOffset(VarHandle handle) {
-                return checkMemoryAccessHandle(handle).offset;
-            }
-
-            @Override
-            public long[] memoryAddressStrides(VarHandle handle) {
-                return checkMemoryAccessHandle(handle).strides();
-            }
-
             @Override
             public MethodHandle nativeMethodHandle(NativeEntryPoint nep, MethodHandle fallback) {
                 return NativeMethodHandle.make(nep, fallback);
             }
 
             @Override
-            public boolean isMemoryAccessVarHandle(VarHandle handle) {
-                return asMemoryAccessVarHandle(handle) != null;
+            public VarHandle memoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,
+                                                   ByteOrder order) {
+                return VarHandles.makeMemoryAddressViewHandle(carrier, skipAlignmentMaskCheck, alignmentMask, order);
             }
 
             @Override
             public VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {
                 return VarHandles.filterValue(target, filterToTarget, filterFromTarget);
@@ -1871,30 +1840,10 @@
 
             @Override
             public VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
                 return VarHandles.insertCoordinates(target, pos, values);
             }
-
-            private MemoryAccessVarHandleBase asMemoryAccessVarHandle(VarHandle handle) {
-                if (handle instanceof MemoryAccessVarHandleBase) {
-                    return (MemoryAccessVarHandleBase)handle;
-                } else if (handle.target() instanceof MemoryAccessVarHandleBase) {
-                    // skip first adaptation, since we have to step over MemoryAddressProxy
-                    // see JDK-8237349
-                    return (MemoryAccessVarHandleBase)handle.target();
-                } else {
-                    return null;
-                }
-            }
-
-            private MemoryAccessVarHandleBase checkMemoryAccessHandle(VarHandle handle) {
-                MemoryAccessVarHandleBase base = asMemoryAccessVarHandle(handle);
-                if (base == null) {
-                    throw new IllegalArgumentException("Not a memory access varhandle: " + handle);
-                }
-                return base;
-            }
         });
     }
 
     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
     private static MethodHandle unboxResultHandle(Class<?> returnType) {
diff a/src/java.base/share/classes/java/lang/invoke/VarHandles.java b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
@@ -309,33 +309,39 @@
      *
      * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added
      * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.
      *
      * @param carrier the Java carrier type.
+     * @param skipAlignmentMaskCheck if true, only the base part of the address will be checked for alignment.
      * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.
      * @param byteOrder the byte order.
-     * @param offset a constant offset for the access.
-     * @param strides the scale factors with which to multiply given access coordinates.
      * @return the created VarHandle.
      */
-    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, long alignmentMask,
-                                                 ByteOrder byteOrder, long offset, long[] strides) {
+    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,
+                                                 ByteOrder byteOrder) {
         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
             throw new IllegalArgumentException("Invalid carrier: " + carrier.getName());
         }
         long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
 
-        Map<Integer, MethodHandle> carrierFactory = ADDRESS_FACTORIES.get(carrier);
-        MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
-                dims -> new MemoryAccessVarHandleGenerator(carrier, dims)
-                            .generateHandleFactory());
-
-        try {
-            return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));
-        } catch (Throwable ex) {
-            throw new IllegalStateException(ex);
+        if (carrier == byte.class) {
+            return maybeAdapt(new MemoryAccessVarHandleByteHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == char.class) {
+            return maybeAdapt(new MemoryAccessVarHandleCharHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == short.class) {
+            return maybeAdapt(new MemoryAccessVarHandleShortHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == int.class) {
+            return maybeAdapt(new MemoryAccessVarHandleIntHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == float.class) {
+            return maybeAdapt(new MemoryAccessVarHandleFloatHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == long.class) {
+            return maybeAdapt(new MemoryAccessVarHandleLongHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == double.class) {
+            return maybeAdapt(new MemoryAccessVarHandleDoubleHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else {
+            throw new IllegalStateException("Cannot get here");
         }
     }
 
     private static VarHandle maybeAdapt(VarHandle target) {
         if (!VAR_HANDLE_IDENTITY_ADAPT) return target;
diff a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
--- a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
+++ b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
@@ -22,25 +22,36 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package java.lang.invoke;
 
-import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.vm.annotation.ForceInline;
 
 import java.util.Objects;
 
 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 
 #warn
 
-final class MemoryAccessVarHandle$Type$Helper {
+final class MemoryAccessVarHandle$Type$Helper extends MemoryAccessVarHandleBase {
 
     static final boolean BE = UNSAFE.isBigEndian();
 
     static final int VM_ALIGN = $BoxType$.BYTES - 1;
 
+    static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegmentProxy.class, $type$.class, long.class);
+
+    MemoryAccessVarHandle$Type$Helper(boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask) {
+        super(FORM, skipAlignmentMaskCheck, be, length, alignmentMask);
+    }
+
+    @Override
+    final MethodType accessModeTypeUncached(AccessMode accessMode) {
+        return accessMode.at.accessModeType(MemorySegmentProxy.class, $type$.class, long.class);
+    }
+
 #if[floatingPoint]
     @ForceInline
     static $rawType$ convEndian(boolean big, $type$ v) {
         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
@@ -64,309 +75,315 @@
     }
 #end[byte]
 #end[floatingPoint]
 
     @ForceInline
-    static MemoryAddressProxy checkAddress(Object obb, long offset, long length, boolean ro) {
-        MemoryAddressProxy oo = (MemoryAddressProxy)Objects.requireNonNull(obb);
+    static MemorySegmentProxy checkAddress(Object obb, long offset, long length, boolean ro) {
+        MemorySegmentProxy oo = (MemorySegmentProxy)Objects.requireNonNull(obb);
         oo.checkAccess(offset, length, ro);
         return oo;
     }
 
     @ForceInline
-    static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {
-        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);
+    static long offset(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {
+        long address = offsetNoVMAlignCheck(skipAlignmentMaskCheck, bb, offset, alignmentMask);
         if ((address & VM_ALIGN) != 0) {
             throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
         }
         return address;
     }
 
     @ForceInline
-    static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {
+    static long offsetNoVMAlignCheck(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {
         long base = bb.unsafeGetOffset();
         long address = base + offset;
-        //note: the offset portion has already been aligned-checked, by construction
-        if ((base & alignmentMask) != 0) {
-            throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
+        if (skipAlignmentMaskCheck) {
+            //note: the offset portion has already been aligned-checked, by construction
+            if ((base & alignmentMask) != 0) {
+                throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
+            }
+        } else {
+            if ((address & alignmentMask) != 0) {
+                throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
+            }
         }
         return address;
     }
 
     @ForceInline
-    static $type$ get0(VarHandle ob, Object obb, long base) {
+    static $type$ get(VarHandle ob, Object obb, long base) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
 #if[floatingPoint]
         $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 handle.be);
         return $Type$.$rawType$BitsTo$Type$(rawValue);
 #else[floatingPoint]
 #if[byte]
         return UNSAFE.get$Type$(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask));
 #else[byte]
         return UNSAFE.get$Type$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 handle.be);
 #end[byte]
 #end[floatingPoint]
     }
 
     @ForceInline
-    static void set0(VarHandle ob, Object obb, long base, $type$ value) {
+    static void set(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
 #if[floatingPoint]
         UNSAFE.put$RawType$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 $Type$.$type$ToRaw$RawType$Bits(value),
                 handle.be);
 #else[floatingPoint]
 #if[byte]
         UNSAFE.put$Type$(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 value);
 #else[byte]
         UNSAFE.put$Type$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 value,
                 handle.be);
 #end[byte]
 #end[floatingPoint]
     }
 
     @ForceInline
-    static $type$ getVolatile0(VarHandle ob, Object obb, long base) {
+    static $type$ getVolatile(VarHandle ob, Object obb, long base) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
         return convEndian(handle.be,
                           UNSAFE.get$RawType$Volatile(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));
     }
 
     @ForceInline
-    static void setVolatile0(VarHandle ob, Object obb, long base, $type$ value) {
+    static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         UNSAFE.put$RawType$Volatile(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, value));
     }
 
     @ForceInline
-    static $type$ getAcquire0(VarHandle ob, Object obb, long base) {
+    static $type$ getAcquire(VarHandle ob, Object obb, long base) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
         return convEndian(handle.be,
                           UNSAFE.get$RawType$Acquire(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));
     }
 
     @ForceInline
-    static void setRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+    static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         UNSAFE.put$RawType$Release(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, value));
     }
 
     @ForceInline
-    static $type$ getOpaque0(VarHandle ob, Object obb, long base) {
+    static $type$ getOpaque(VarHandle ob, Object obb, long base) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
         return convEndian(handle.be,
                           UNSAFE.get$RawType$Opaque(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));
     }
 
     @ForceInline
-    static void setOpaque0(VarHandle ob, Object obb, long base, $type$ value) {
+    static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         UNSAFE.put$RawType$Opaque(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, value));
     }
 #if[CAS]
 
     @ForceInline
-    static boolean compareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.compareAndSet$RawType$(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
-    static $type$ compareAndExchange0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.compareAndExchange$RawType$(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
     }
 
     @ForceInline
-    static $type$ compareAndExchangeAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.compareAndExchange$RawType$Acquire(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
     }
 
     @ForceInline
-    static $type$ compareAndExchangeRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.compareAndExchange$RawType$Release(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
     }
 
     @ForceInline
-    static boolean weakCompareAndSetPlain0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$Plain(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
-    static boolean weakCompareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
-    static boolean weakCompareAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$Acquire(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
-    static boolean weakCompareAndSetRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$Release(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
-    static $type$ getAndSet0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.getAndSet$RawType$(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, value)));
     }
 
     @ForceInline
-    static $type$ getAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.getAndSet$RawType$Acquire(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, value)));
     }
 
     @ForceInline
-    static $type$ getAndSetRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.getAndSet$RawType$Release(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, value)));
     }
 #end[CAS]
 #if[AtomicAdd]
 
     @ForceInline
-    static $type$ getAndAdd0(VarHandle ob, Object obb, long base, $type$ delta) {
+    static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndAdd$RawType$(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     delta);
         } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);
         }
     }
 
     @ForceInline
-    static $type$ getAndAddAcquire0(VarHandle ob, Object obb, long base, $type$ delta) {
+    static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndAdd$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     delta);
         } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);
         }
     }
 
     @ForceInline
-    static $type$ getAndAddRelease0(VarHandle ob, Object obb, long base, $type$ delta) {
+    static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndAdd$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     delta);
         } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);
         }
     }
 
     @ForceInline
-    static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {
+    static $type$ getAndAddConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ delta) {
         $type$ nativeExpectedValue, expectedValue;
         Object base = bb.unsafeGetBase();
         do {
             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
@@ -376,53 +393,53 @@
     }
 #end[AtomicAdd]
 #if[Bitwise]
 
     @ForceInline
-    static $type$ getAndBitwiseOr0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseOr$RawType$(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseOrRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseOr$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseOrAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseOr$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+    static $type$ getAndBitwiseOrConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
         $type$ nativeExpectedValue, expectedValue;
         Object base = bb.unsafeGetBase();
         do {
             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
@@ -430,53 +447,53 @@
                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
         return expectedValue;
     }
 
     @ForceInline
-    static $type$ getAndBitwiseAnd0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseAnd$RawType$(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseAndRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseAnd$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseAndAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+    static $type$ getAndBitwiseAndConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
         $type$ nativeExpectedValue, expectedValue;
         Object base = bb.unsafeGetBase();
         do {
             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
@@ -485,53 +502,53 @@
         return expectedValue;
     }
 
 
     @ForceInline
-    static $type$ getAndBitwiseXor0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseXor$RawType$(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseXorRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseXor$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseXorAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseXor$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+    static $type$ getAndBitwiseXorConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
         $type$ nativeExpectedValue, expectedValue;
         Object base = bb.unsafeGetBase();
         do {
             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
diff a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
@@ -115,48 +115,12 @@
     /**
      * Returns a var handle view of a given memory address.
      * Used by {@code jdk.internal.foreign.LayoutPath} and
      * {@code jdk.incubator.foreign.MemoryHandles}.
      */
-    VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask,
-                                    ByteOrder order, long offset, long[] strides);
-
-    /**
-     * Is {@code handle} a memory access varhandle?
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    boolean isMemoryAccessVarHandle(VarHandle handle);
-
-    /**
-     * Returns the carrier associated with a memory access var handle.
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    Class<?> memoryAddressCarrier(VarHandle handle);
-
-    /**
-     * Returns the alignment mask associated with a memory access var handle.
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    long memoryAddressAlignmentMask(VarHandle handle);
-
-    /**
-     * Returns the byte order associated with a memory access var handle.
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    ByteOrder memoryAddressByteOrder(VarHandle handle);
-
-    /**
-     * Returns the offset associated with a memory access var handle.
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    long memoryAddressOffset(VarHandle handle);
-
-    /**
-     * Returns the strides associated with a memory access var handle.
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    long[] memoryAddressStrides(VarHandle handle);
+    VarHandle memoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,
+                                    ByteOrder order);
 
     /**
      * Var handle carrier combinator.
      * Used by {@code jdk.incubator.foreign.MemoryHandles}.
      */
diff a/src/java.base/share/classes/jdk/internal/access/foreign/MemorySegmentProxy.java b/src/java.base/share/classes/jdk/internal/access/foreign/MemorySegmentProxy.java
--- a/src/java.base/share/classes/jdk/internal/access/foreign/MemorySegmentProxy.java
+++ b/src/java.base/share/classes/jdk/internal/access/foreign/MemorySegmentProxy.java
@@ -30,6 +30,72 @@
  * This proxy interface is required to allow instances of the {@code MemorySegment} interface (which is defined inside
  * an incubating module) to be accessed from the memory access var handles.
  */
 public interface MemorySegmentProxy {
     void checkValidState();
+
+    /**
+     * Check that memory access is within spatial and temporal bounds.
+     * @throws IllegalStateException if underlying segment has been closed already.
+     * @throws IndexOutOfBoundsException if access is out-of-bounds.
+     */
+    void checkAccess(long offset, long length, boolean readOnly);
+    long unsafeGetOffset();
+    Object unsafeGetBase();
+    boolean isSmall();
+
+    /* Helper functions for offset computations. These are required so that we can avoid issuing long opcodes
+     * (e.g. LMUL, LADD) when we're operating on 'small' segments (segments whose length can be expressed with an int).
+     * C2 BCE code is very sensitive to the kind of opcode being emitted, and this workaround allows us to rescue
+     * BCE when working with small segments. This workaround should be dropped when JDK-8223051 is resolved.
+     */
+
+    static long addOffsets(long op1, long op2, MemorySegmentProxy segmentProxy) {
+        if (segmentProxy.isSmall()) {
+            // force ints for BCE
+            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE
+                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {
+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);
+            }
+            int i1 = (int)op1;
+            int i2 = (int)op2;
+            try {
+                return Math.addExact(i1, i2);
+            } catch (ArithmeticException ex) {
+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);
+            }
+        } else {
+            try {
+                return Math.addExact(op1, op2);
+            } catch (ArithmeticException ex) {
+                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);
+            }
+        }
+    }
+
+    static long multiplyOffsets(long op1, long op2, MemorySegmentProxy segmentProxy) {
+        if (segmentProxy.isSmall()) {
+            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE
+                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {
+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);
+            }
+            // force ints for BCE
+            int i1 = (int)op1;
+            int i2 = (int)op2;
+            try {
+                return Math.multiplyExact(i1, i2);
+            } catch (ArithmeticException ex) {
+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);
+            }
+        } else {
+            try {
+                return Math.multiplyExact(op1, op2);
+            } catch (ArithmeticException ex) {
+                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);
+            }
+        }
+    }
+
+    private static IndexOutOfBoundsException overflowException(long min, long max) {
+        return new IndexOutOfBoundsException(String.format("Overflow occurred during offset computation ; offset exceeded range { %d .. %d }", min, max));
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
@@ -23,11 +23,11 @@
  *  questions.
  *
  */
 package jdk.incubator.foreign;
 
-import jdk.internal.foreign.AbstractMemorySegmentImpl;
+import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.SharedUtils;
 
 import java.nio.ByteOrder;
 import java.nio.charset.Charset;
@@ -755,11 +755,11 @@
      * @param str the Java string to be converted into a C string.
      * @param scope the scope to be used for the native segment allocation.
      * @return a new native memory segment containing the converted C string.
      * @throws NullPointerException if either {@code str == null} or {@code scope == null}.
      */
-    public static MemoryAddress toCString(String str, NativeScope scope) {
+    public static MemorySegment toCString(String str, NativeScope scope) {
         Objects.requireNonNull(str);
         Objects.requireNonNull(scope);
         return toCString(str.getBytes(), scope);
     }
 
@@ -776,11 +776,11 @@
      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
      * @param scope the scope to be used for the native segment allocation.
      * @return a new native memory segment containing the converted C string.
      * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.
      */
-    public static MemoryAddress toCString(String str, Charset charset, NativeScope scope) {
+    public static MemorySegment toCString(String str, Charset charset, NativeScope scope) {
         Objects.requireNonNull(str);
         Objects.requireNonNull(charset);
         Objects.requireNonNull(scope);
         return toCString(str.getBytes(charset), scope);
     }
@@ -801,11 +801,11 @@
      * @throws NullPointerException if {@code addr == null}
      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
      */
     public static String toJavaStringRestricted(MemoryAddress addr) {
         Utils.checkRestrictedAccess("CSupport.toJavaStringRestricted");
-        return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), Charset.defaultCharset());
+        return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue(), Charset.defaultCharset());
     }
 
     /**
      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
      * <p>
@@ -823,11 +823,11 @@
      * @throws NullPointerException if {@code addr == null}
      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
      */
     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
         Utils.checkRestrictedAccess("CSupport.toJavaStringRestricted");
-        return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), charset);
+        return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue(), charset);
     }
 
     /**
      * Convert a null-terminated C string stored at given address into a Java string, using the platform's default charset.
      * <p>
@@ -840,12 +840,12 @@
      * @throws NullPointerException if {@code addr == null}
      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
      * associated with {@code addr}, or if {@code addr} is associated with a segment that is <em>not alive</em>.
      */
-    public static String toJavaString(MemoryAddress addr) {
-        return SharedUtils.toJavaStringInternal(addr, Charset.defaultCharset());
+    public static String toJavaString(MemorySegment addr) {
+        return SharedUtils.toJavaStringInternal(addr, 0L, Charset.defaultCharset());
     }
 
     /**
      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
      * <p>
@@ -859,28 +859,27 @@
      * @throws NullPointerException if {@code addr == null}
      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
      * associated with {@code addr}, or if {@code addr} is associated with a segment that is <em>not alive</em>.
      */
-    public static String toJavaString(MemoryAddress addr, Charset charset) {
-        return SharedUtils.toJavaStringInternal(addr, charset);
+    public static String toJavaString(MemorySegment addr, Charset charset) {
+        return SharedUtils.toJavaStringInternal(addr, 0L, charset);
     }
 
-    private static void copy(MemoryAddress addr, byte[] bytes) {
+    private static void copy(MemorySegment addr, byte[] bytes) {
         var heapSegment = MemorySegment.ofArray(bytes);
-        addr.segment().copyFrom(heapSegment);
+        addr.copyFrom(heapSegment);
         MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);
     }
 
     private static MemorySegment toCString(byte[] bytes) {
         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
-        MemoryAddress addr = segment.address();
-        copy(addr, bytes);
+        copy(segment, bytes);
         return segment;
     }
 
-    private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
-        MemoryAddress addr = scope.allocate(bytes.length + 1, 1L);
+    private static MemorySegment toCString(byte[] bytes, NativeScope scope) {
+        MemorySegment addr = scope.allocate(bytes.length + 1, 1L);
         copy(addr, bytes);
         return addr;
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAccess.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAccess.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAccess.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAccess.java
@@ -1,26 +1,26 @@
 package jdk.incubator.foreign;
 
-import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.vm.annotation.ForceInline;
 
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 
 /**
  * This class defines ready-made static accessors which can be used to dereference memory segments in many ways.
  * <p>
- * The most primitive accessors (see {@link #getIntAtOffset(MemoryAddress, long)} (MemoryAddress, long)}) take a <em>base</em> address and an offset (expressed in bytes).
+ * The most primitive accessors (see {@link #getIntAtOffset(MemorySegment, long)}) take a segment and an offset (expressed in bytes).
  * The final address at which the dereference will occur will be computed by offsetting the base address by
  * the specified offset, as if by calling {@link MemoryAddress#addOffset(long)} on the specified base address.
  * <p>
- * In cases where no offset is required, overloads are provided (see {@link #getInt(MemoryAddress)}) so that
+ * In cases where no offset is required, overloads are provided (see {@link #getInt(MemorySegment)}) so that
  * clients can omit the offset coordinate.
  * <p>
  * To help dereferencing in array-like use cases (e.g. where the layout of a given memory segment is a sequence
- * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemoryAddress, long)}),
- * which take an <em>base</em> address and a <em>logical</em> element index. The formula to obtain the byte offset {@code O} from an
+ * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemorySegment, long)}),
+ * which take a segment and a <em>logical</em> element index. The formula to obtain the byte offset {@code O} from an
  * index {@code I} is given by {@code O = I * S} where {@code S} is the size (expressed in bytes) of the element to
  * be dereferenced.
  */
 public final class MemoryAccess {
 
@@ -43,2002 +43,2002 @@
     private static final VarHandle long_BE_handle = indexedHandle(MemoryLayouts.BITS_64_BE, long.class);
     private static final VarHandle double_BE_handle = indexedHandle(MemoryLayouts.BITS_64_BE, double.class);
     private static final VarHandle address_handle = MemoryHandles.asAddressVarHandle((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle);
 
     /**
-     * Read a byte from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a byte from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);
-    byte value = (byte)handle.get(addr, offset);
+    byte value = (byte)handle.get(segment, offset);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByteAtOffset_LE(MemoryAddress addr, long offset) {
-        return (byte)byte_LE_handle.get(addr, offset);
+    public static byte getByteAtOffset_LE(MemorySegment segment, long offset) {
+        return (byte)byte_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a byte at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtOffset_LE(MemoryAddress addr, long offset, byte value) {
-        byte_LE_handle.set(addr, offset, value);
+    public static void setByteAtOffset_LE(MemorySegment segment, long offset, byte value) {
+        byte_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a char from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a char from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);
-    char value = (char)handle.get(addr, offset);
+    char value = (char)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a char value read from {@code segment}.
      */
-    public static char getCharAtOffset_LE(MemoryAddress addr, long offset) {
-        return (char)char_LE_handle.get(addr, offset);
+    public static char getCharAtOffset_LE(MemorySegment segment, long offset) {
+        return (char)char_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a char at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtOffset_LE(MemoryAddress addr, long offset, char value) {
-        char_LE_handle.set(addr, offset, value);
+    public static void setCharAtOffset_LE(MemorySegment segment, long offset, char value) {
+        char_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a short from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a short from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);
-    short value = (short)handle.get(addr, offset);
+    short value = (short)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShortAtOffset_LE(MemoryAddress addr, long offset) {
-        return (short)short_LE_handle.get(addr, offset);
+    public static short getShortAtOffset_LE(MemorySegment segment, long offset) {
+        return (short)short_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a short at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtOffset_LE(MemoryAddress addr, long offset, short value) {
-        short_LE_handle.set(addr, offset, value);
+    public static void setShortAtOffset_LE(MemorySegment segment, long offset, short value) {
+        short_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read an int from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read an int from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);
-    int value = (int)handle.get(addr, offset);
+    int value = (int)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return an int value read from {@code segment}.
      */
-    public static int getIntAtOffset_LE(MemoryAddress addr, long offset) {
-        return (int)int_LE_handle.get(addr, offset);
+    public static int getIntAtOffset_LE(MemorySegment segment, long offset) {
+        return (int)int_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes an int at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtOffset_LE(MemoryAddress addr, long offset, int value) {
-        int_LE_handle.set(addr, offset, value);
+    public static void setIntAtOffset_LE(MemorySegment segment, long offset, int value) {
+        int_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a float from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a float from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);
-    float value = (float)handle.get(addr, offset);
+    float value = (float)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloatAtOffset_LE(MemoryAddress addr, long offset) {
-        return (float)float_LE_handle.get(addr, offset);
+    public static float getFloatAtOffset_LE(MemorySegment segment, long offset) {
+        return (float)float_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a float at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtOffset_LE(MemoryAddress addr, long offset, float value) {
-        float_LE_handle.set(addr, offset, value);
+    public static void setFloatAtOffset_LE(MemorySegment segment, long offset, float value) {
+        float_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a long from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a long from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);
-    long value = (long)handle.get(addr, offset);
+    long value = (long)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLongAtOffset_LE(MemoryAddress addr, long offset) {
-        return (long)long_LE_handle.get(addr, offset);
+    public static long getLongAtOffset_LE(MemorySegment segment, long offset) {
+        return (long)long_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a long at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtOffset_LE(MemoryAddress addr, long offset, long value) {
-        long_LE_handle.set(addr, offset, value);
+    public static void setLongAtOffset_LE(MemorySegment segment, long offset, long value) {
+        long_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a double from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a double from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);
-    double value = (double)handle.get(addr, offset);
+    double value = (double)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDoubleAtOffset_LE(MemoryAddress addr, long offset) {
-        return (double)double_LE_handle.get(addr, offset);
+    public static double getDoubleAtOffset_LE(MemorySegment segment, long offset) {
+        return (double)double_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a double at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtOffset_LE(MemoryAddress addr, long offset, double value) {
-        double_LE_handle.set(addr, offset, value);
+    public static void setDoubleAtOffset_LE(MemorySegment segment, long offset, double value) {
+        double_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a byte from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a byte from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);
-    byte value = (byte)handle.get(addr, offset);
+    byte value = (byte)handle.get(segment, offset);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByteAtOffset_BE(MemoryAddress addr, long offset) {
-        return (byte)byte_BE_handle.get(addr, offset);
+    public static byte getByteAtOffset_BE(MemorySegment segment, long offset) {
+        return (byte)byte_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a byte at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtOffset_BE(MemoryAddress addr, long offset, byte value) {
-        byte_BE_handle.set(addr, offset, value);
+    public static void setByteAtOffset_BE(MemorySegment segment, long offset, byte value) {
+        byte_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a char from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a char from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);
-    char value = (char)handle.get(addr, offset);
+    char value = (char)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a char value read from {@code segment}.
      */
-    public static char getCharAtOffset_BE(MemoryAddress addr, long offset) {
-        return (char)char_BE_handle.get(addr, offset);
+    public static char getCharAtOffset_BE(MemorySegment segment, long offset) {
+        return (char)char_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a char at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtOffset_BE(MemoryAddress addr, long offset, char value) {
-        char_BE_handle.set(addr, offset, value);
+    public static void setCharAtOffset_BE(MemorySegment segment, long offset, char value) {
+        char_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a short from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a short from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);
-    short value = (short)handle.get(addr, offset);
+    short value = (short)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShortAtOffset_BE(MemoryAddress addr, long offset) {
-        return (short)short_BE_handle.get(addr, offset);
+    public static short getShortAtOffset_BE(MemorySegment segment, long offset) {
+        return (short)short_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a short at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtOffset_BE(MemoryAddress addr, long offset, short value) {
-        short_BE_handle.set(addr, offset, value);
+    public static void setShortAtOffset_BE(MemorySegment segment, long offset, short value) {
+        short_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read an int from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read an int from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);
-    int value = (int)handle.get(addr, offset);
+    int value = (int)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return an int value read from {@code segment}.
      */
-    public static int getIntAtOffset_BE(MemoryAddress addr, long offset) {
-        return (int)int_BE_handle.get(addr, offset);
+    public static int getIntAtOffset_BE(MemorySegment segment, long offset) {
+        return (int)int_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes an int at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtOffset_BE(MemoryAddress addr, long offset, int value) {
-        int_BE_handle.set(addr, offset, value);
+    public static void setIntAtOffset_BE(MemorySegment segment, long offset, int value) {
+        int_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a float from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a float from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);
-    float value = (float)handle.get(addr, offset);
+    float value = (float)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloatAtOffset_BE(MemoryAddress addr, long offset) {
-        return (float)float_BE_handle.get(addr, offset);
+    public static float getFloatAtOffset_BE(MemorySegment segment, long offset) {
+        return (float)float_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a float at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtOffset_BE(MemoryAddress addr, long offset, float value) {
-        float_BE_handle.set(addr, offset, value);
+    public static void setFloatAtOffset_BE(MemorySegment segment, long offset, float value) {
+        float_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a long from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a long from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);
-    long value = (long)handle.get(addr, offset);
+    long value = (long)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLongAtOffset_BE(MemoryAddress addr, long offset) {
-        return (long)long_BE_handle.get(addr, offset);
+    public static long getLongAtOffset_BE(MemorySegment segment, long offset) {
+        return (long)long_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a long at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtOffset_BE(MemoryAddress addr, long offset, long value) {
-        long_BE_handle.set(addr, offset, value);
+    public static void setLongAtOffset_BE(MemorySegment segment, long offset, long value) {
+        long_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a double from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a double from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);
-    double value = (double)handle.get(addr, offset);
+    double value = (double)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDoubleAtOffset_BE(MemoryAddress addr, long offset) {
-        return (double)double_BE_handle.get(addr, offset);
+    public static double getDoubleAtOffset_BE(MemorySegment segment, long offset) {
+        return (double)double_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a double at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtOffset_BE(MemoryAddress addr, long offset, double value) {
-        double_BE_handle.set(addr, offset, value);
+    public static void setDoubleAtOffset_BE(MemorySegment segment, long offset, double value) {
+        double_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a byte from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a byte from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);
-    byte value = (byte)handle.get(addr, offset);
+    byte value = (byte)handle.get(segment, offset);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByteAtOffset(MemoryAddress addr, long offset) {
-        return (byte)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).get(addr, offset);
+    public static byte getByteAtOffset(MemorySegment segment, long offset) {
+        return (byte)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a byte at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtOffset(MemoryAddress addr, long offset, byte value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).set(addr, offset, value);
+    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a char from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a char from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);
-    char value = (char)handle.get(addr, offset);
+    char value = (char)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a char value read from {@code segment}.
      */
-    public static char getCharAtOffset(MemoryAddress addr, long offset) {
-        return (char)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(addr, offset);
+    public static char getCharAtOffset(MemorySegment segment, long offset) {
+        return (char)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a char at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtOffset(MemoryAddress addr, long offset, char value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(addr, offset, value);
+    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a short from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a short from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);
-    short value = (short)handle.get(addr, offset);
+    short value = (short)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShortAtOffset(MemoryAddress addr, long offset) {
-        return (short)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(addr, offset);
+    public static short getShortAtOffset(MemorySegment segment, long offset) {
+        return (short)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a short at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtOffset(MemoryAddress addr, long offset, short value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(addr, offset, value);
+    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read an int from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read an int from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);
-    int value = (int)handle.get(addr, offset);
+    int value = (int)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return an int value read from {@code segment}.
      */
-    public static int getIntAtOffset(MemoryAddress addr, long offset) {
-        return (int)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(addr, offset);
+    public static int getIntAtOffset(MemorySegment segment, long offset) {
+        return (int)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes an int at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtOffset(MemoryAddress addr, long offset, int value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(addr, offset, value);
+    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a float from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a float from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);
-    float value = (float)handle.get(addr, offset);
+    float value = (float)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloatAtOffset(MemoryAddress addr, long offset) {
-        return (float)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(addr, offset);
+    public static float getFloatAtOffset(MemorySegment segment, long offset) {
+        return (float)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a float at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtOffset(MemoryAddress addr, long offset, float value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(addr, offset, value);
+    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a long from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a long from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);
-    long value = (long)handle.get(addr, offset);
+    long value = (long)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLongAtOffset(MemoryAddress addr, long offset) {
-        return (long)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(addr, offset);
+    public static long getLongAtOffset(MemorySegment segment, long offset) {
+        return (long)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a long at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtOffset(MemoryAddress addr, long offset, long value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(addr, offset, value);
+    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a double from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a double from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);
-    double value = (double)handle.get(addr, offset);
+    double value = (double)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDoubleAtOffset(MemoryAddress addr, long offset) {
-        return (double)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(addr, offset);
+    public static double getDoubleAtOffset(MemorySegment segment, long offset) {
+        return (double)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a double at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtOffset(MemoryAddress addr, long offset, double value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(addr, offset, value);
+    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a memory address from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a memory address from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L));
-    MemoryAddress value = (MemoryAddress)handle.get(addr, offset);
+    MemoryAddress value = (MemoryAddress)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a memory address read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a memory address read from {@code segment}.
      */
-    public static MemoryAddress getAddressAtOffset(MemoryAddress addr, long offset) {
-        return (MemoryAddress)address_handle.get(addr, offset);
+    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {
+        return (MemoryAddress)address_handle.get(segment, offset);
     }
 
     /**
-     * Writes a memory address at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a memory address at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L));
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the memory address to be written.
      */
-    public static void setAddressAtOffset(MemoryAddress addr, long offset, MemoryAddress value) {
-        address_handle.set(addr, offset, value);
+    public static void setAddressAtOffset(MemorySegment segment, long offset, MemoryAddress value) {
+        address_handle.set(segment, offset, value);
     }
 
-    private static VarHandle indexedHandle(MemoryLayout elementLayout, Class<?> carrier) {
-        return MemoryHandles.withStride(elementLayout.withBitAlignment(8).varHandle(carrier), 1L);
+    private static VarHandle indexedHandle(ValueLayout elementLayout, Class<?> carrier) {
+        return MemoryHandles.varHandle(carrier, 1, elementLayout.order());
     }
 
     /**
-     * Read a byte from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a byte from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset_LE(addr, 0L);
+    byte value = getByteAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByte_LE(MemoryAddress addr) {
-        return getByteAtOffset_LE(addr, 0L);
+    public static byte getByte_LE(MemorySegment segment) {
+        return getByteAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a byte at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a byte at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset_LE(addr, 0L, value);
+    setByteAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the byte value to be written.
      */
-    public static void setByte_LE(MemoryAddress addr, byte value) {
-        setByteAtOffset_LE(addr, 0L, value);
+    public static void setByte_LE(MemorySegment segment, byte value) {
+        setByteAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a char from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a char from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset_LE(addr, 0L);
+    char value = getCharAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a char value read from {@code segment}.
      */
-    public static char getChar_LE(MemoryAddress addr) {
-        return getCharAtOffset_LE(addr, 0L);
+    public static char getChar_LE(MemorySegment segment) {
+        return getCharAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a char at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a char at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset_LE(addr, 0L, value);
+    setCharAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the char value to be written.
      */
-    public static void setChar_LE(MemoryAddress addr, char value) {
-        setCharAtOffset_LE(addr, 0L, value);
+    public static void setChar_LE(MemorySegment segment, char value) {
+        setCharAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a short from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a short from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset_LE(addr, 0L);
+    short value = getShortAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShort_LE(MemoryAddress addr) {
-        return getShortAtOffset_LE(addr, 0L);
+    public static short getShort_LE(MemorySegment segment) {
+        return getShortAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a short at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a short at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset_LE(addr, 0L, value);
+    setShortAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the short value to be written.
      */
-    public static void setShort_LE(MemoryAddress addr, short value) {
-        setShortAtOffset_LE(addr, 0L, value);
+    public static void setShort_LE(MemorySegment segment, short value) {
+        setShortAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read an int from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read an int from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset_LE(addr, 0L);
+    int value = getIntAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return an int value read from {@code segment}.
      */
-    public static int getInt_LE(MemoryAddress addr) {
-        return getIntAtOffset_LE(addr, 0L);
+    public static int getInt_LE(MemorySegment segment) {
+        return getIntAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes an int at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes an int at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset_LE(addr, 0L, value);
+    setIntAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the int value to be written.
      */
-    public static void setInt_LE(MemoryAddress addr, int value) {
-        setIntAtOffset_LE(addr, 0L, value);
+    public static void setInt_LE(MemorySegment segment, int value) {
+        setIntAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a float from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a float from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset_LE(addr, 0L);
+    float value = getFloatAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloat_LE(MemoryAddress addr) {
-        return getFloatAtOffset_LE(addr, 0L);
+    public static float getFloat_LE(MemorySegment segment) {
+        return getFloatAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a float at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a float at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset_LE(addr, 0L, value);
+    setFloatAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the float value to be written.
      */
-    public static void setFloat_LE(MemoryAddress addr, float value) {
-        setFloatAtOffset_LE(addr, 0L, value);
+    public static void setFloat_LE(MemorySegment segment, float value) {
+        setFloatAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a long from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a long from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    long value = getLongAtOffset_LE(addr, 0L);
+    long value = getLongAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLong_LE(MemoryAddress addr) {
-        return getLongAtOffset_LE(addr, 0L);
+    public static long getLong_LE(MemorySegment segment) {
+        return getLongAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a long at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a long at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset_LE(addr, 0L, value);
+    setLongAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the long value to be written.
      */
-    public static void setLong_LE(MemoryAddress addr, long value) {
-        setLongAtOffset_LE(addr, 0L, value);
+    public static void setLong_LE(MemorySegment segment, long value) {
+        setLongAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a double from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a double from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    double value = getDoubleAtOffset_LE(addr, 0L);
+    double value = getDoubleAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDouble_LE(MemoryAddress addr) {
-        return getDoubleAtOffset_LE(addr, 0L);
+    public static double getDouble_LE(MemorySegment segment) {
+        return getDoubleAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a double at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a double at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset_LE(addr, 0L, value);
+    setDoubleAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the double value to be written.
      */
-    public static void setDouble_LE(MemoryAddress addr, double value) {
-        setDoubleAtOffset_LE(addr, 0L, value);
+    public static void setDouble_LE(MemorySegment segment, double value) {
+        setDoubleAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a byte from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a byte from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset_BE(addr, 0L);
+    byte value = getByteAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByte_BE(MemoryAddress addr) {
-        return getByteAtOffset_BE(addr, 0L);
+    public static byte getByte_BE(MemorySegment segment) {
+        return getByteAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a byte at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a byte at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset_BE(addr, 0L, value);
+    setByteAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the byte value to be written.
      */
-    public static void setByte_BE(MemoryAddress addr, byte value) {
-        setByteAtOffset_BE(addr, 0L, value);
+    public static void setByte_BE(MemorySegment segment, byte value) {
+        setByteAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a char from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a char from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset_BE(addr, 0L);
+    char value = getCharAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a char value read from {@code segment}.
      */
-    public static char getChar_BE(MemoryAddress addr) {
-        return getCharAtOffset_BE(addr, 0L);
+    public static char getChar_BE(MemorySegment segment) {
+        return getCharAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a char at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a char at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset_BE(addr, 0L, value);
+    setCharAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the char value to be written.
      */
-    public static void setChar_BE(MemoryAddress addr, char value) {
-        setCharAtOffset_BE(addr, 0L, value);
+    public static void setChar_BE(MemorySegment segment, char value) {
+        setCharAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a short from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a short from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset_BE(addr, 0L);
+    short value = getShortAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShort_BE(MemoryAddress addr) {
-        return getShortAtOffset_BE(addr, 0L);
+    public static short getShort_BE(MemorySegment segment) {
+        return getShortAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a short at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a short at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset_BE(addr, 0L, value);
+    setShortAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the short value to be written.
      */
-    public static void setShort_BE(MemoryAddress addr, short value) {
-        setShortAtOffset_BE(addr, 0L, value);
+    public static void setShort_BE(MemorySegment segment, short value) {
+        setShortAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read an int from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read an int from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset_BE(addr, 0L);
+    int value = getIntAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return an int value read from {@code segment}.
      */
-    public static int getInt_BE(MemoryAddress addr) {
-        return getIntAtOffset_BE(addr, 0L);
+    public static int getInt_BE(MemorySegment segment) {
+        return getIntAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes an int at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes an int at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset_BE(addr, 0L, value);
+    setIntAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the int value to be written.
      */
-    public static void setInt_BE(MemoryAddress addr, int value) {
-        setIntAtOffset_BE(addr, 0L, value);
+    public static void setInt_BE(MemorySegment segment, int value) {
+        setIntAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a float from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a float from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset_BE(addr, 0L);
+    float value = getFloatAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloat_BE(MemoryAddress addr) {
-        return getFloatAtOffset_BE(addr, 0L);
+    public static float getFloat_BE(MemorySegment segment) {
+        return getFloatAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a float at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a float at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset_BE(addr, 0L, value);
+    setFloatAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the float value to be written.
      */
-    public static void setFloat_BE(MemoryAddress addr, float value) {
-        setFloatAtOffset_BE(addr, 0L, value);
+    public static void setFloat_BE(MemorySegment segment, float value) {
+        setFloatAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a long from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a long from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    long value = getLongAtOffset_BE(addr, 0L);
+    long value = getLongAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLong_BE(MemoryAddress addr) {
-        return getLongAtOffset_BE(addr, 0L);
+    public static long getLong_BE(MemorySegment segment) {
+        return getLongAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a long at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a long at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset_BE(addr, 0L, value);
+    setLongAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the long value to be written.
      */
-    public static void setLong_BE(MemoryAddress addr, long value) {
-        setLongAtOffset_BE(addr, 0L, value);
+    public static void setLong_BE(MemorySegment segment, long value) {
+        setLongAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a double from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a double from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    double value = getDoubleAtOffset_BE(addr, 0L);
+    double value = getDoubleAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDouble_BE(MemoryAddress addr) {
-        return getDoubleAtOffset_BE(addr, 0L);
+    public static double getDouble_BE(MemorySegment segment) {
+        return getDoubleAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a double at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a double at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset_BE(addr, 0L, value);
+    setDoubleAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the double value to be written.
      */
-    public static void setDouble_BE(MemoryAddress addr, double value) {
-        setDoubleAtOffset_BE(addr, 0L, value);
+    public static void setDouble_BE(MemorySegment segment, double value) {
+        setDoubleAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a byte from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a byte from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset(addr, 0L);
+    byte value = getByteAtOffset(segment, 0L);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByte(MemoryAddress addr) {
-        return getByteAtOffset(addr, 0L);
+    public static byte getByte(MemorySegment segment) {
+        return getByteAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a byte at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a byte at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset(addr, 0L, value);
+    setByteAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the byte value to be written.
      */
-    public static void setByte(MemoryAddress addr, byte value) {
-        setByteAtOffset(addr, 0L, value);
+    public static void setByte(MemorySegment segment, byte value) {
+        setByteAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a char from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset(addr, 0L);
+    char value = getCharAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a char value read from {@code segment}.
      */
-    public static char getChar(MemoryAddress addr) {
-        return getCharAtOffset(addr, 0L);
+    public static char getChar(MemorySegment segment) {
+        return getCharAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a char at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset(addr, 0L, value);
+    setCharAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the char value to be written.
      */
-    public static void setChar(MemoryAddress addr, char value) {
-        setCharAtOffset(addr, 0L, value);
+    public static void setChar(MemorySegment segment, char value) {
+        setCharAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a short from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset(addr, 0L);
+    short value = getShortAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShort(MemoryAddress addr) {
-        return getShortAtOffset(addr, 0L);
+    public static short getShort(MemorySegment segment) {
+        return getShortAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a short at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset(addr, 0L, value);
+    setShortAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the short value to be written.
      */
-    public static void setShort(MemoryAddress addr, short value) {
-        setShortAtOffset(addr, 0L, value);
+    public static void setShort(MemorySegment segment, short value) {
+        setShortAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read an int from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset(addr, 0L);
+    int value = getIntAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return an int value read from {@code segment}.
      */
-    public static int getInt(MemoryAddress addr) {
-        return getIntAtOffset(addr, 0L);
+    public static int getInt(MemorySegment segment) {
+        return getIntAtOffset(segment, 0L);
     }
 
     /**
-     * Writes an int at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset(addr, 0L, value);
+    setIntAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the int value to be written.
      */
-    public static void setInt(MemoryAddress addr, int value) {
-        setIntAtOffset(addr, 0L, value);
+    public static void setInt(MemorySegment segment, int value) {
+        setIntAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a float from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset(addr, 0L);
+    float value = getFloatAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloat(MemoryAddress addr) {
-        return getFloatAtOffset(addr, 0L);
+    public static float getFloat(MemorySegment segment) {
+        return getFloatAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a float at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset(addr, 0L, value);
+    setFloatAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the float value to be written.
      */
-    public static void setFloat(MemoryAddress addr, float value) {
-        setFloatAtOffset(addr, 0L, value);
+    public static void setFloat(MemorySegment segment, float value) {
+        setFloatAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a long from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    long value = getLongAtOffset(addr, 0L);
+    long value = getLongAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLong(MemoryAddress addr) {
-        return getLongAtOffset(addr, 0L);
+    public static long getLong(MemorySegment segment) {
+        return getLongAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a long at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a long at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset(addr, 0L, value);
+    setLongAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the long value to be written.
      */
-    public static void setLong(MemoryAddress addr, long value) {
-        setLongAtOffset(addr, 0L, value);
+    public static void setLong(MemorySegment segment, long value) {
+        setLongAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a double from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a double from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    double value = getDoubleAtOffset(addr, 0L);
+    double value = getDoubleAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDouble(MemoryAddress addr) {
-        return getDoubleAtOffset(addr, 0L);
+    public static double getDouble(MemorySegment segment) {
+        return getDoubleAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a double at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a double at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset(addr, 0L, value);
+    setDoubleAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the double value to be written.
      */
-    public static void setDouble(MemoryAddress addr, double value) {
-        setDoubleAtOffset(addr, 0L, value);
+    public static void setDouble(MemorySegment segment, double value) {
+        setDoubleAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a memory address from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a memory address from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    MemoryAddress value = getAddressAtOffset(addr, 0L);
+    MemoryAddress value = getAddressAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a memory address read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a memory address read from {@code segment}.
      */
-    public static MemoryAddress getAddress(MemoryAddress addr) {
-        return getAddressAtOffset(addr, 0L);
+    public static MemoryAddress getAddress(MemorySegment segment) {
+        return getAddressAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a memory address at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a memory address at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setAddressAtOffset(addr, 0L, value);
+    setAddressAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the memory address to be written.
      */
-    public static void setAddress(MemoryAddress addr, MemoryAddress value) {
-        setAddressAtOffset(addr, 0L, value);
+    public static void setAddress(MemorySegment segment, MemoryAddress value) {
+        setAddressAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a byte from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a byte from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset_LE(addr, index);
+    byte value = getByteAtOffset_LE(segment, index);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
-     * @return a byte value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
+     * @return a byte value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static byte getByteAtIndex_LE(MemoryAddress addr, long index) {
-        return getByteAtOffset_LE(addr, index);
+    public static byte getByteAtIndex_LE(MemorySegment segment, long index) {
+        return getByteAtOffset_LE(segment, index);
     }
 
     /**
-     * Writes a byte at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a byte at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset_LE(addr, index, value);
+    setByteAtOffset_LE(segment, index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtIndex_LE(MemoryAddress addr, long index, byte value) {
-        setByteAtOffset_LE(addr, index, value);
+    public static void setByteAtIndex_LE(MemorySegment segment, long index, byte value) {
+        setByteAtOffset_LE(segment, index, value);
     }
 
     /**
-     * Read a char from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a char from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset_LE(addr, 2 * index);
+    char value = getCharAtOffset_LE(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a char value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a char value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static char getCharAtIndex_LE(MemoryAddress addr, long index) {
-        return getCharAtOffset_LE(addr, scale(addr, index, 2));
+    public static char getCharAtIndex_LE(MemorySegment segment, long index) {
+        return getCharAtOffset_LE(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a char at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset_LE(addr, 2 * index, value);
+    setCharAtOffset_LE(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtIndex_LE(MemoryAddress addr, long index, char value) {
-        setCharAtOffset_LE(addr, scale(addr, index, 2), value);
+    public static void setCharAtIndex_LE(MemorySegment segment, long index, char value) {
+        setCharAtOffset_LE(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read a short from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a short from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset_LE(addr, 2 * index);
+    short value = getShortAtOffset_LE(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a short value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a short value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static short getShortAtIndex_LE(MemoryAddress addr, long index) {
-        return getShortAtOffset_LE(addr, scale(addr, index, 2));
+    public static short getShortAtIndex_LE(MemorySegment segment, long index) {
+        return getShortAtOffset_LE(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a short at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset_LE(addr, 2 * index, value);
+    setShortAtOffset_LE(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtIndex_LE(MemoryAddress addr, long index, short value) {
-        setShortAtOffset_LE(addr, scale(addr, index, 2), value);
+    public static void setShortAtIndex_LE(MemorySegment segment, long index, short value) {
+        setShortAtOffset_LE(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read an int from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read an int from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset_LE(addr, 4 * index);
+    int value = getIntAtOffset_LE(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return an int value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return an int value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static int getIntAtIndex_LE(MemoryAddress addr, long index) {
-        return getIntAtOffset_LE(addr, scale(addr, index, 4));
+    public static int getIntAtIndex_LE(MemorySegment segment, long index) {
+        return getIntAtOffset_LE(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes an int at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset_LE(addr, 4 * index, value);
+    setIntAtOffset_LE(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtIndex_LE(MemoryAddress addr, long index, int value) {
-        setIntAtOffset_LE(addr, scale(addr, index, 4), value);
+    public static void setIntAtIndex_LE(MemorySegment segment, long index, int value) {
+        setIntAtOffset_LE(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a float from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a float from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset_LE(addr, 4 * index);
+    float value = getFloatAtOffset_LE(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return a float value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return a float value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static float getFloatAtIndex_LE(MemoryAddress addr, long index) {
-        return getFloatAtOffset_LE(addr, scale(addr, index, 4));
+    public static float getFloatAtIndex_LE(MemorySegment segment, long index) {
+        return getFloatAtOffset_LE(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes a float at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset_LE(addr, 4 * index, value);
+    setFloatAtOffset_LE(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtIndex_LE(MemoryAddress addr, long index, float value) {
-        setFloatAtOffset_LE(addr, scale(addr, index, 4), value);
+    public static void setFloatAtIndex_LE(MemorySegment segment, long index, float value) {
+        setFloatAtOffset_LE(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a long from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a long from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getLongAtOffset_LE(addr, 8 * index);
+    return getLongAtOffset_LE(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a long value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a long value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static long getLongAtIndex_LE(MemoryAddress addr, long index) {
-        return getLongAtOffset_LE(addr, scale(addr, index, 8));
+    public static long getLongAtIndex_LE(MemorySegment segment, long index) {
+        return getLongAtOffset_LE(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a long at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset_LE(addr, 8 * index, value);
+    setLongAtOffset_LE(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtIndex_LE(MemoryAddress addr, long index, long value) {
-        setLongAtOffset_LE(addr, scale(addr, index, 8), value);
+    public static void setLongAtIndex_LE(MemorySegment segment, long index, long value) {
+        setLongAtOffset_LE(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a double from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a double from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getDoubleAtOffset_LE(addr, 8 * index);
+    return getDoubleAtOffset_LE(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a double value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a double value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static double getDoubleAtIndex_LE(MemoryAddress addr, long index) {
-        return getDoubleAtOffset_LE(addr, scale(addr, index, 8));
+    public static double getDoubleAtIndex_LE(MemorySegment segment, long index) {
+        return getDoubleAtOffset_LE(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a double at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset_LE(addr, 8 * index, value);
+    setDoubleAtOffset_LE(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtIndex_LE(MemoryAddress addr, long index, double value) {
-        setDoubleAtOffset_LE(addr, scale(addr, index, 8), value);
+    public static void setDoubleAtIndex_LE(MemorySegment segment, long index, double value) {
+        setDoubleAtOffset_LE(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a byte from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a byte from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset_BE(addr, index);
+    byte value = getByteAtOffset_BE(segment, index);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
-     * @return a byte value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
+     * @return a byte value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static byte getByteAtIndex_BE(MemoryAddress addr, long index) {
-        return getByteAtOffset_BE(addr, index);
+    public static byte getByteAtIndex_BE(MemorySegment segment, long index) {
+        return getByteAtOffset_BE(segment, index);
     }
 
     /**
-     * Writes a byte at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a byte at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset_BE(addr, index, value);
+    setByteAtOffset_BE(segment, index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtIndex_BE(MemoryAddress addr, long index, byte value) {
-        setByteAtOffset_BE(addr, index, value);
+    public static void setByteAtIndex_BE(MemorySegment segment, long index, byte value) {
+        setByteAtOffset_BE(segment, index, value);
     }
 
     /**
-     * Read a char from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a char from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset_BE(addr, 2 * index);
+    char value = getCharAtOffset_BE(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a char value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a char value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static char getCharAtIndex_BE(MemoryAddress addr, long index) {
-        return getCharAtOffset_BE(addr, scale(addr, index, 2));
+    public static char getCharAtIndex_BE(MemorySegment segment, long index) {
+        return getCharAtOffset_BE(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a char at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset_BE(addr, 2 * index, value);
+    setCharAtOffset_BE(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtIndex_BE(MemoryAddress addr, long index, char value) {
-        setCharAtOffset_BE(addr, scale(addr, index, 2), value);
+    public static void setCharAtIndex_BE(MemorySegment segment, long index, char value) {
+        setCharAtOffset_BE(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read a short from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a short from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset_BE(addr, 2 * index);
+    short value = getShortAtOffset_BE(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a short value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a short value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static short getShortAtIndex_BE(MemoryAddress addr, long index) {
-        return getShortAtOffset_BE(addr, scale(addr, index, 2));
+    public static short getShortAtIndex_BE(MemorySegment segment, long index) {
+        return getShortAtOffset_BE(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a short at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset_BE(addr, 2 * index, value);
+    setShortAtOffset_BE(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtIndex_BE(MemoryAddress addr, long index, short value) {
-        setShortAtOffset_BE(addr, scale(addr, index, 2), value);
+    public static void setShortAtIndex_BE(MemorySegment segment, long index, short value) {
+        setShortAtOffset_BE(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read an int from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read an int from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset_BE(addr, 4 * index);
+    int value = getIntAtOffset_BE(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return an int value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return an int value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static int getIntAtIndex_BE(MemoryAddress addr, long index) {
-        return getIntAtOffset_BE(addr, scale(addr, index, 4));
+    public static int getIntAtIndex_BE(MemorySegment segment, long index) {
+        return getIntAtOffset_BE(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes an int at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset_BE(addr, 4 * index, value);
+    setIntAtOffset_BE(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtIndex_BE(MemoryAddress addr, long index, int value) {
-        setIntAtOffset_BE(addr, scale(addr, index, 4), value);
+    public static void setIntAtIndex_BE(MemorySegment segment, long index, int value) {
+        setIntAtOffset_BE(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a float from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a float from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset_BE(addr, 4 * index);
+    float value = getFloatAtOffset_BE(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return a float value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return a float value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static float getFloatAtIndex_BE(MemoryAddress addr, long index) {
-        return getFloatAtOffset_BE(addr, scale(addr, index, 4));
+    public static float getFloatAtIndex_BE(MemorySegment segment, long index) {
+        return getFloatAtOffset_BE(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes a float at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset_BE(addr, 4 * index, value);
+    setFloatAtOffset_BE(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtIndex_BE(MemoryAddress addr, long index, float value) {
-        setFloatAtOffset_BE(addr, scale(addr, index, 4), value);
+    public static void setFloatAtIndex_BE(MemorySegment segment, long index, float value) {
+        setFloatAtOffset_BE(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a long from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a long from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getLongAtOffset_BE(addr, 8 * index);
+    return getLongAtOffset_BE(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a long value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a long value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static long getLongAtIndex_BE(MemoryAddress addr, long index) {
-        return getLongAtOffset_BE(addr, scale(addr, index, 8));
+    public static long getLongAtIndex_BE(MemorySegment segment, long index) {
+        return getLongAtOffset_BE(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a long at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset_BE(addr, 8 * index, value);
+    setLongAtOffset_BE(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtIndex_BE(MemoryAddress addr, long index, long value) {
-        setLongAtOffset_BE(addr, scale(addr, index, 8), value);
+    public static void setLongAtIndex_BE(MemorySegment segment, long index, long value) {
+        setLongAtOffset_BE(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a double from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a double from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getDoubleAtOffset_BE(addr, 8 * index);
+    return getDoubleAtOffset_BE(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a double value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a double value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static double getDoubleAtIndex_BE(MemoryAddress addr, long index) {
-        return getDoubleAtOffset_BE(addr, scale(addr, index, 8));
+    public static double getDoubleAtIndex_BE(MemorySegment segment, long index) {
+        return getDoubleAtOffset_BE(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a double at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset_BE(addr, 8 * index, value);
+    setDoubleAtOffset_BE(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtIndex_BE(MemoryAddress addr, long index, double value) {
-        setDoubleAtOffset_BE(addr, scale(addr, index, 8), value);
+    public static void setDoubleAtIndex_BE(MemorySegment segment, long index, double value) {
+        setDoubleAtOffset_BE(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a byte from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a byte from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset(addr, index);
+    byte value = getByteAtOffset(segment, index);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
-     * @return a byte value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
+     * @return a byte value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static byte getByteAtIndex(MemoryAddress addr, long index) {
-        return getByteAtOffset(addr, index);
+    public static byte getByteAtIndex(MemorySegment segment, long index) {
+        return getByteAtOffset(segment, index);
     }
 
     /**
-     * Writes a byte at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a byte at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset(addr, index, value);
+    setByteAtOffset(segment, index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtIndex(MemoryAddress addr, long index, byte value) {
-        setByteAtOffset(addr, index, value);
+    public static void setByteAtIndex(MemorySegment segment, long index, byte value) {
+        setByteAtOffset(segment, index, value);
     }
 
     /**
-     * Read a char from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a char from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset(addr, 2 * index);
+    char value = getCharAtOffset(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a char value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a char value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static char getCharAtIndex(MemoryAddress addr, long index) {
-        return getCharAtOffset(addr, scale(addr, index, 2));
+    public static char getCharAtIndex(MemorySegment segment, long index) {
+        return getCharAtOffset(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a char at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset(addr, 2 * index, value);
+    setCharAtOffset(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtIndex(MemoryAddress addr, long index, char value) {
-        setCharAtOffset(addr, scale(addr, index, 2), value);
+    public static void setCharAtIndex(MemorySegment segment, long index, char value) {
+        setCharAtOffset(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read a short from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a short from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset(addr, 2 * index);
+    short value = getShortAtOffset(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a short value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a short value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static short getShortAtIndex(MemoryAddress addr, long index) {
-        return getShortAtOffset(addr, scale(addr, index, 2));
+    public static short getShortAtIndex(MemorySegment segment, long index) {
+        return getShortAtOffset(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a short at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset(addr, 2 * index, value);
+    setShortAtOffset(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtIndex(MemoryAddress addr, long index, short value) {
-        setShortAtOffset(addr, scale(addr, index, 2), value);
+    public static void setShortAtIndex(MemorySegment segment, long index, short value) {
+        setShortAtOffset(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read an int from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read an int from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset(addr, 4 * index);
+    int value = getIntAtOffset(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return an int value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return an int value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static int getIntAtIndex(MemoryAddress addr, long index) {
-        return getIntAtOffset(addr, scale(addr, index, 4));
+    public static int getIntAtIndex(MemorySegment segment, long index) {
+        return getIntAtOffset(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes an int at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset(addr, 4 * index, value);
+    setIntAtOffset(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtIndex(MemoryAddress addr, long index, int value) {
-        setIntAtOffset(addr, scale(addr, index, 4), value);
+    public static void setIntAtIndex(MemorySegment segment, long index, int value) {
+        setIntAtOffset(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a float from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset(addr, 4 * index);
+    float value = getFloatAtOffset(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return a float value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return a float value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static float getFloatAtIndex(MemoryAddress addr, long index) {
-        return getFloatAtOffset(addr, scale(addr, index, 4));
+    public static float getFloatAtIndex(MemorySegment segment, long index) {
+        return getFloatAtOffset(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes a float at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset(addr, 4 * index, value);
+    setFloatAtOffset(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtIndex(MemoryAddress addr, long index, float value) {
-        setFloatAtOffset(addr, scale(addr, index, 4), value);
+    public static void setFloatAtIndex(MemorySegment segment, long index, float value) {
+        setFloatAtOffset(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a long from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a long from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getLongAtOffset(addr, 8 * index);
+    return getLongAtOffset(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a long value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a long value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static long getLongAtIndex(MemoryAddress addr, long index) {
-        return getLongAtOffset(addr, scale(addr, index, 8));
+    public static long getLongAtIndex(MemorySegment segment, long index) {
+        return getLongAtOffset(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a long at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset(addr, 8 * index, value);
+    setLongAtOffset(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtIndex(MemoryAddress addr, long index, long value) {
-        setLongAtOffset(addr, scale(addr, index, 8), value);
+    public static void setLongAtIndex(MemorySegment segment, long index, long value) {
+        setLongAtOffset(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a double from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a double from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getDoubleAtOffset(addr, 8 * index);
+    return getDoubleAtOffset(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a double value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a double value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static double getDoubleAtIndex(MemoryAddress addr, long index) {
-        return getDoubleAtOffset(addr, scale(addr, index, 8));
+    public static double getDoubleAtIndex(MemorySegment segment, long index) {
+        return getDoubleAtOffset(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a double at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset(addr, 8 * index, value);
+    setDoubleAtOffset(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtIndex(MemoryAddress addr, long index, double value) {
-        setDoubleAtOffset(addr, scale(addr, index, 8), value);
+    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {
+        setDoubleAtOffset(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a memory address from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getAddressAtOffset(addr, index * 8);
+    return getAddressAtOffset(segment, index * 8);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a memory address read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a memory address read from {@code segment} at the element index specified by {@code index}.
      */
-    public static MemoryAddress getAddressAtIndex(MemoryAddress addr, long index) {
-        return getAddressAtOffset(addr, scale(addr, index, 8));
+    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {
+        return getAddressAtOffset(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a memory address at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setAddressAtOffset(addr, index * 8, value);
+    setAddressAtOffset(segment, index * 8, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the memory address to be written.
      */
-    public static void setAddressAtIndex(MemoryAddress addr, long index, MemoryAddress value) {
-        setAddressAtOffset(addr, scale(addr, index, 8), value);
+    public static void setAddressAtIndex(MemorySegment segment, long index, MemoryAddress value) {
+        setAddressAtOffset(segment, scale(segment, index, 8), value);
     }
 
     @ForceInline
-    private static long scale(MemoryAddress address, long index, int size) {
-        return MemoryAddressProxy.multiplyOffsets(index, size, (MemoryAddressProxy)address);
+    private static long scale(MemorySegment address, long index, int size) {
+        return MemorySegmentProxy.multiplyOffsets(index, size, (MemorySegmentProxy)address);
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -28,19 +28,13 @@
 
 import jdk.internal.foreign.MemoryAddressImpl;
 
 /**
  * A memory address models a reference into a memory location. Memory addresses are typically obtained using the
- * {@link MemorySegment#address()} method; such addresses are said to be <em>checked</em>, and can be expressed
- * as <em>offsets</em> into some underlying memory segment (see {@link #segment()} and {@link #segmentOffset()}).
- * Since checked memory addresses feature both spatial and temporal bounds, these addresses can <em>safely</em> be
- * dereferenced using a memory access var handle (see {@link MemoryHandles}).
- * <p>
- * If an address does not have any associated segment, it is said to be <em>unchecked</em>. Unchecked memory
- * addresses do not feature known spatial or temporal bounds; as such, attempting a memory dereference operation
- * using an unchecked memory address will result in a runtime exception. Unchecked addresses can be obtained
- * e.g. by calling the {@link #ofLong(long)} method.
+ * {@link MemorySegment#address()} method, and can refer to either off-heap or on-heap memory.
+ * Given an address, it is possible to compute its offset relative to a given segment, which can be useful
+ * when performing memory dereference operations using a memory access var handle (see {@link MemoryHandles}).
  * <p>
  * All implementations of this interface must be <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>;
  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
  * instances of {@code MemoryAddress} may have unpredictable results and should be avoided. The {@code equals} method should
  * be used for comparisons.
@@ -67,39 +61,36 @@
      * @return a new memory address with given offset from current one.
      */
     MemoryAddress addOffset(long offset);
 
     /**
-     * Returns the offset of this memory address into the underlying segment (if any).
-     * @return the offset of this memory address into the underlying segment (if any).
-     * @throws UnsupportedOperationException if no segment is associated with this memory address,
-     * e.g. if {@code segment() == null}.
+     * Returns the offset of this memory address into the given segment. More specifically, if both the segment's
+     * base address and this address are off-heap addresses, the result is computed as
+     * {@code this.toRawLongValue() - segment.address().toRawLongValue()}. Otherwise, if both addresses in the form
+     * {@code (B, O1)}, {@code (B, O2)}, where {@code B} is the same base heap object and {@code O1}, {@code O2}
+     * are byte offsets (relative to the base object) associated with this address and the segment's base address,
+     * the result is computed as {@code O1 - O2}.
+     * <p>
+     * If the segment's base address and this address are both heap addresses, but with different base objects, the result is undefined
+     * and an exception is thrown. Similarly, if the segment's base address is an heap address (resp. off-heap) and
+     * this address is an off-heap (resp. heap) address, the result is undefined and an exception is thrown.
+     * Otherwise, the result is a byte offset {@code SO}. If this address falls within the
+     * spatial bounds of the given segment, then {@code 0 <= SO < segment.byteSize()}; otherwise, {@code SO < 0 || SO > segment.byteSize()}.
+     * @return the offset of this memory address into the given segment.
+     * @param segment the segment relative to which this address offset should be computed
+     * @throws IllegalArgumentException if {@code segment} is not compatible with this address; this can happen, for instance,
+     * when {@code segment} models an heap memory region, while this address models an off-heap memory address.
      */
-    long segmentOffset();
+    long segmentOffset(MemorySegment segment);
 
     /**
      * Returns the raw long value associated to this memory address.
      * @return The raw long value associated to this memory address.
      * @throws UnsupportedOperationException if this memory address is associated with an heap segment.
      */
     long toRawLongValue();
 
-    /**
-     * Returns the memory segment (if any) this address belongs to.
-     * @return The memory segment this address belongs to, or {@code null} if no such segment exists.
-     */
-    MemorySegment segment();
-
-    /**
-     * Reinterpret this address as an offset into the provided segment.
-     * @param segment the segment to be rebased
-     * @return a new address pointing to the same memory location through the provided segment
-     * @throws IllegalArgumentException if the provided segment is not a valid rebase target for this address. This
-     * can happen, for instance, if an heap-based addressed is rebased to an off-heap memory segment.
-     */
-    MemoryAddress rebase(MemorySegment segment);
-
     /**
      * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified
      * object is also an address, and it refers to the same memory location as this address.
      *
      * @apiNote two addresses might be considered equal despite their associated segments differ. This
@@ -120,22 +111,20 @@
      */
     @Override
     int hashCode();
 
     /**
-     * The <em>unchecked</em> memory address instance modelling the {@code NULL} address. This address is <em>not</em> backed by
-     * a memory segment and hence it cannot be dereferenced.
+     * The off-heap memory address instance modelling the {@code NULL} address.
      */
-    MemoryAddress NULL = new MemoryAddressImpl( 0L);
+    MemoryAddress NULL = new MemoryAddressImpl(null,  0L);
 
     /**
-     * Obtain a new <em>unchecked</em> memory address instance from given long address. The returned address is <em>not</em> backed by
-     * a memory segment and hence it cannot be dereferenced.
+     * Obtain an off-heap memory address instance from given long address.
      * @param value the long address.
      * @return the new memory address instance.
      */
     static MemoryAddress ofLong(long value) {
         return value == 0 ?
                 NULL :
-                new MemoryAddressImpl(value);
+                new MemoryAddressImpl(null, value);
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
@@ -44,48 +44,26 @@
  * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},
  * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type
  * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the
  * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways
  * to emulate different addressing modes. The var handles created by this class feature a <em>mandatory</em> coordinate type
- * (of type {@link MemoryAddress}), and zero or more {@code long} coordinate types, which can be used to emulate
- * multi-dimensional array indexing.
+ * (of type {@link MemorySegment}), and one {@code long} coordinate type, which represents the offset, in bytes, relative
+ * to the segment, at which dereference should occur.
  * <p>
- * As an example, consider the memory layout expressed by a {@link SequenceLayout} instance constructed as follows:
+ * As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:
  * <blockquote><pre>{@code
-SequenceLayout seq = MemoryLayout.ofSequence(5,
-    MemoryLayout.ofStruct(
+GroupLayout seq = MemoryLayout.ofStruct(
         MemoryLayout.ofPaddingBits(32),
         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName("value")
-    ));
+);
  * }</pre></blockquote>
  * To access the member layout named {@code value}, we can construct a memory access var handle as follows:
  * <blockquote><pre>{@code
-VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); //(MemoryAddress) -> int
-handle = MemoryHandles.withOffset(handle, 4); //(MemoryAddress) -> int
-handle = MemoryHandles.withStride(handle, 8); //(MemoryAddress, long) -> int
+VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); //(MemorySegment, long) -> int
+handle = MemoryHandles.insertCoordinates(handle, 1, 4); //(MemorySegment) -> int
  * }</pre></blockquote>
  *
- * <h2>Addressing mode</h2>
- *
- * The final memory location accessed by a memory access var handle can be computed as follows:
- *
- * <blockquote><pre>{@code
-address = base + offset
- * }</pre></blockquote>
- *
- * where {@code base} denotes the address expressed by the {@link MemoryAddress} access coordinate, and {@code offset}
- * can be expressed in the following form:
- *
- * <blockquote><pre>{@code
-offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
- * }</pre></blockquote>
- *
- * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic</em> values provided as optional {@code long}
- * access coordinates, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are
- * <em>static</em> constants which are can be acquired through the {@link MemoryHandles#withOffset(VarHandle, long)}
- * and the {@link MemoryHandles#withStride(VarHandle, long)} combinators, respectively.
- *
  * <h2><a id="memaccess-mode"></a>Alignment and access modes</h2>
  *
  * A memory access var handle is associated with an access size {@code S} and an alignment constraint {@code B}
  * (both expressed in bytes). We say that a memory access operation is <em>fully aligned</em> if it occurs
  * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.
@@ -128,13 +106,10 @@
         //sorry, just the one!
     }
 
     private static final MethodHandle LONG_TO_ADDRESS;
     private static final MethodHandle ADDRESS_TO_LONG;
-    private static final MethodHandle ADD_OFFSET;
-    private static final MethodHandle ADD_STRIDE;
-
     private static final MethodHandle INT_TO_BYTE;
     private static final MethodHandle BYTE_TO_UNSIGNED_INT;
     private static final MethodHandle INT_TO_SHORT;
     private static final MethodHandle SHORT_TO_UNSIGNED_INT;
     private static final MethodHandle LONG_TO_BYTE;
@@ -148,16 +123,10 @@
         try {
             LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryHandles.class, "longToAddress",
                     MethodType.methodType(MemoryAddress.class, long.class));
             ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(MemoryHandles.class, "addressToLong",
                     MethodType.methodType(long.class, MemoryAddress.class));
-            ADD_OFFSET = MethodHandles.lookup().findStatic(MemoryHandles.class, "addOffset",
-                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class));
-
-            ADD_STRIDE = MethodHandles.lookup().findStatic(MemoryHandles.class, "addStride",
-                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class, long.class));
-
             INT_TO_BYTE = MethodHandles.explicitCastArguments(MethodHandles.identity(byte.class),
                     MethodType.methodType(byte.class, int.class));
             BYTE_TO_UNSIGNED_INT = MethodHandles.lookup().findStatic(Byte.class, "toUnsignedInt",
                     MethodType.methodType(int.class, byte.class));
             INT_TO_SHORT = MethodHandles.explicitCastArguments(MethodHandles.identity(short.class),
@@ -182,11 +151,11 @@
     }
 
     /**
      * Creates a memory access var handle with the given carrier type and byte order.
      *
-     * The resulting memory access var handle features a single {@link MemoryAddress} access coordinate,
+     * The resulting memory access var handle features a single {@link MemorySegment} access coordinate,
      * and its variable type is set by the given carrier type.
      *
      * The alignment constraint for the resulting memory access var handle is the same as the in memory size of the
      * carrier type, and the accessed offset is set at zero.
      *
@@ -207,11 +176,11 @@
     }
 
     /**
      * Creates a memory access var handle with the given carrier type, alignment constraint, and byte order.
      *
-     * The resulting memory access var handle features a single {@link MemoryAddress} access coordinate,
+     * The resulting memory access var handle features a single {@link MemorySegment} access coordinate,
      * and its variable type is set by the given carrier type.
      *
      * The accessed offset is zero.
      *
      * @apiNote the resulting var handle features certain <a href="#memaccess-mode">access mode restrictions</a>,
@@ -230,98 +199,15 @@
         if (alignmentBytes <= 0
                 || (alignmentBytes & (alignmentBytes - 1)) != 0) { // is power of 2?
             throw new IllegalArgumentException("Bad alignment: " + alignmentBytes);
         }
 
-        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, alignmentBytes - 1, byteOrder, 0, new long[]{}));
-    }
-
-    /**
-     * Returns a var handle that adds a <em>fixed</em> offset to the incoming {@link MemoryAddress} coordinate
-     * and then propagates such value to the target var handle. That is,
-     * when the returned var handle receives a memory address coordinate pointing at a memory location at
-     * offset <em>O</em>, a memory address coordinate pointing at a memory location at offset <em>O' + O</em>
-     * is created, and then passed to the target var handle.
-     *
-     * The returned var handle will feature the same type and access coordinates as the target var handle.
-     *
-     * @param target the target memory access handle to access after the offset adjustment.
-     * @param bytesOffset the offset, in bytes. Must be positive or zero.
-     * @return the adapted var handle.
-     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
-     */
-    public static VarHandle withOffset(VarHandle target, long bytesOffset) {
-        if (bytesOffset == 0) {
-            return target; //nothing to do
-        }
-
-        checkAddressFirstCoordinate(target);
-
-        if (JLI.isMemoryAccessVarHandle(target) &&
-                (bytesOffset & JLI.memoryAddressAlignmentMask(target)) == 0) {
-            //flatten
-            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
-                    JLI.memoryAddressCarrier(target),
-                    JLI.memoryAddressAlignmentMask(target),
-                    JLI.memoryAddressByteOrder(target),
-                    JLI.memoryAddressOffset(target) + bytesOffset,
-                    JLI.memoryAddressStrides(target)));
-        } else {
-            //slow path
-            VarHandle res = collectCoordinates(target, 0, ADD_OFFSET);
-            return insertCoordinates(res, 1, bytesOffset);
-        }
+        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, false, alignmentBytes - 1, byteOrder));
     }
 
     /**
-     * Returns a var handle which adds a <em>variable</em> offset to the incoming {@link MemoryAddress}
-     * access coordinate value and then propagates such value to the target var handle.
-     * That is, when the returned var handle receives a memory address coordinate pointing at a memory location at
-     * offset <em>O</em>, a new memory address coordinate pointing at a memory location at offset <em>(S * X) + O</em>
-     * is created, and then passed to the target var handle,
-     * where <em>S</em> is a constant <em>stride</em>, whereas <em>X</em> is a dynamic value that will be
-     * provided as an additional access coordinate (of type {@code long}).
-     *
-     * The returned var handle will feature the same type as the target var handle; an additional access coordinate
-     * of type {@code long} will be added to the access coordinate types of the target var handle at the position
-     * immediately following the leading access coordinate of type {@link MemoryAddress}.
-     *
-     * @param target the target memory access handle to access after the scale adjustment.
-     * @param bytesStride the stride, in bytes, by which to multiply the coordinate value.
-     * @return the adapted var handle.
-     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
-     */
-    public static VarHandle withStride(VarHandle target, long bytesStride) {
-        if (bytesStride == 0) {
-            return dropCoordinates(target, 1, long.class); // dummy coordinate
-        }
-
-        checkAddressFirstCoordinate(target);
-
-        if (JLI.isMemoryAccessVarHandle(target) &&
-                (bytesStride & JLI.memoryAddressAlignmentMask(target)) == 0) {
-            //flatten
-            long[] strides = JLI.memoryAddressStrides(target);
-            long[] newStrides = new long[strides.length + 1];
-            System.arraycopy(strides, 0, newStrides, 1, strides.length);
-            newStrides[0] = bytesStride;
-
-            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
-                    JLI.memoryAddressCarrier(target),
-                    JLI.memoryAddressAlignmentMask(target),
-                    JLI.memoryAddressByteOrder(target),
-                    JLI.memoryAddressOffset(target),
-                    newStrides));
-        } else {
-            //slow path
-            VarHandle res = collectCoordinates(target, 0, ADD_STRIDE);
-            return insertCoordinates(res, 2, bytesStride);
-        }
-    }
-
-    /**
-     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemoryAddress}.
+     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemorySegment}.
      * That is, when calling {@link VarHandle#get(Object...)} on the returned var handle,
      * the read numeric value will be turned into a memory address (as if by calling {@link MemoryAddress#ofLong(long)});
      * similarly, when calling {@link VarHandle#set(Object...)}, the memory address to be set will be converted
      * into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to)
      * memory depends on the carrier of the original memory access var handle.
@@ -360,12 +246,12 @@
      * the case if modeled as a Java {@code short}. This is illustrated in the following example:
      * <blockquote><pre>{@code
     MemorySegment segment = MemorySegment.allocateNative(2);
     VarHandle SHORT_VH = MemoryLayouts.JAVA_SHORT.varHandle(short.class);
     VarHandle INT_VH = MemoryHandles.asUnsigned(SHORT_VH, int.class);
-    SHORT_VH.set(segment.address(), (short)-1);
-    INT_VH.get(segment.address()); // returns 65535
+    SHORT_VH.set(segment, (short)-1);
+    INT_VH.get(segment); // returns 65535
      * }</pre></blockquote>
      * <p>
      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var
      * handle, the incoming value (of type {@code adaptedType}) is converted by a
      * <i>narrowing primitive conversion</i> and then passed to the {@code
@@ -618,12 +504,12 @@
         return JLI.dropCoordinates(target, pos, valueTypes);
     }
 
     private static void checkAddressFirstCoordinate(VarHandle handle) {
         if (handle.coordinateTypes().size() < 1 ||
-                handle.coordinateTypes().get(0) != MemoryAddress.class) {
-            throw new IllegalArgumentException("Expected var handle with leading coordinate of type MemoryAddress");
+                handle.coordinateTypes().get(0) != MemorySegment.class) {
+            throw new IllegalArgumentException("Expected var handle with leading coordinate of type MemorySegment");
         }
     }
 
     private static void checkCarrier(Class<?> carrier) {
         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
@@ -660,14 +546,6 @@
     }
 
     private static long addressToLong(MemoryAddress value) {
         return value.toRawLongValue();
     }
-
-    private static MemoryAddress addOffset(MemoryAddress address, long offset) {
-        return address.addOffset(offset);
-    }
-
-    private static MemoryAddress addStride(MemoryAddress address, long index, long stride) {
-        return address.addOffset(index * stride);
-    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
@@ -368,10 +368,28 @@
     }
 
     /**
      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
      * where the path is considered rooted in this layout.
+     * <p>
+     * The final memory location accessed by the returned memory access var handle can be computed as follows:
+     *
+     * <blockquote><pre>{@code
+    address = base + offset
+     * }</pre></blockquote>
+     *
+     * where {@code base} denotes the base address expressed by the {@link MemorySegment} access coordinate
+     * (see {@link MemorySegment#address()} and {@link MemoryAddress#toRawLongValue()}) and {@code offset}
+     * can be expressed in the following form:
+     *
+     * <blockquote><pre>{@code
+    offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
+     * }</pre></blockquote>
+     *
+     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic</em> values provided as optional {@code long}
+     * access coordinates, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are
+     * <em>static</em> stride constants which are derived from the layout path.
      *
      * @apiNote the resulting var handle will feature an additional {@code long} access coordinate for every
      * unspecified sequence access component contained in this layout path. Moreover, the resulting var handle
      * features certain <a href="MemoryHandles.html#memaccess-mode">access mode restrictions</a>, which are common to all memory access var handles.
      *
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -174,10 +174,12 @@
     /**
      * The base memory address associated with this memory segment. The returned address is
      * a <em>checked</em> memory address and can therefore be used in dereference operations
      * (see {@link MemoryAddress}).
      * @return The base memory address.
+     * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
+     * thread owning this segment
      */
     @Override
     MemoryAddress address();
 
     /**
@@ -276,10 +278,31 @@
      * @return a new memory segment view with updated base/limit addresses.
      * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}
      */
     MemorySegment asSlice(long offset, long newSize);
 
+    /**
+     * Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
+     * and whose new size is computed by subtracting the specified offset from this segment size.
+     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.
+     * @return a new memory segment view with updated base/limit addresses.
+     * @throws IndexOutOfBoundsException if {@code offset < 0}, or {@code offset > byteSize()}.
+     */
+    MemorySegment asSlice(long offset);
+
+    /**
+     * Obtains a new memory segment view whose base address is the address passed as argument,
+     * and whose new size is computed by subtracting the address offset relative to this segment
+     * (see {@link MemoryAddress#segmentOffset(MemorySegment)}) from this segment size.
+     * @param address The new segment base offset (relative to the current segment base address), specified in bytes.
+     * @return a new memory segment view with updated base/limit addresses.
+     * @throws IndexOutOfBoundsException if {@code address.segmentOffset(this) < 0}, or {@code address.segmentOffset(this) > byteSize()}.
+     */
+    default MemorySegment asSlice(MemoryAddress address) {
+        return asSlice(address.segmentOffset(this));
+    }
+
     /**
      * Is this segment alive?
      * @return true, if the segment is alive.
      * @see MemorySegment#close()
      */
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java
@@ -43,11 +43,11 @@
  * of the native scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,
  * using a <em>bounded</em> native scope will typically provide better performances than independently allocating the memory
  * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an <em>unbounded</em> native scope.
  * For this reason, using a bounded native scope is recommended in cases where programs might need to emulate native stack allocation.
  * <p>
- * Allocation scopes are thread-confined (see {@link #ownerThread()}; as such, the resulting {@code MemoryAddress} instances
+ * Allocation scopes are thread-confined (see {@link #ownerThread()}; as such, the resulting {@link MemorySegment} instances
  * returned by the native scope will be backed by memory segments confined by the same owner thread as the native scope.
  * <p>
  * To allow for more usability, it is possible for an native scope to reclaim ownership of an existing memory segments
  * (see {@link #register(MemorySegment)}). This might be useful to allow one or more segments which were independently
  * created to share the same life-cycle as a given native scope - which in turns enables client to group all memory
@@ -73,286 +73,286 @@
      */
     public abstract long allocatedBytes();
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given byte value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
      * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.
      */
-    public MemoryAddress allocate(MemoryLayout layout, byte value) {
+    public MemorySegment allocate(MemoryLayout layout, byte value) {
         VarHandle handle = layout.varHandle(byte.class);
-        MemoryAddress addr = allocate(layout);
+        MemorySegment addr = allocate(layout);
         handle.set(addr, value);
         return addr;
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given short value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
      * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.
      */
-    public MemoryAddress allocate(MemoryLayout layout, short value) {
+    public MemorySegment allocate(MemoryLayout layout, short value) {
         VarHandle handle = layout.varHandle(short.class);
-        MemoryAddress addr = allocate(layout);
+        MemorySegment addr = allocate(layout);
         handle.set(addr, value);
         return addr;
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given int value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
      * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.
      */
-    public MemoryAddress allocate(MemoryLayout layout, int value) {
+    public MemorySegment allocate(MemoryLayout layout, int value) {
         VarHandle handle = layout.varHandle(int.class);
-        MemoryAddress addr = allocate(layout);
+        MemorySegment addr = allocate(layout);
         handle.set(addr, value);
         return addr;
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given float value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
      * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.
      */
-    public MemoryAddress allocate(MemoryLayout layout, float value) {
+    public MemorySegment allocate(MemoryLayout layout, float value) {
         VarHandle handle = layout.varHandle(float.class);
-        MemoryAddress addr = allocate(layout);
+        MemorySegment addr = allocate(layout);
         handle.set(addr, value);
         return addr;
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given long value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
      * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.
      */
-    public MemoryAddress allocate(MemoryLayout layout, long value) {
+    public MemorySegment allocate(MemoryLayout layout, long value) {
         VarHandle handle = layout.varHandle(long.class);
-        MemoryAddress addr = allocate(layout);
+        MemorySegment addr = allocate(layout);
         handle.set(addr, value);
         return addr;
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given double value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
      * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.
      */
-    public MemoryAddress allocate(MemoryLayout layout, double value) {
+    public MemorySegment allocate(MemoryLayout layout, double value) {
         VarHandle handle = layout.varHandle(double.class);
-        MemoryAddress addr = allocate(layout);
+        MemorySegment addr = allocate(layout);
         handle.set(addr, value);
         return addr;
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given byte array.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param elementLayout the element layout of the array to be allocated.
      * @param array the array to be copied on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.
      */
-    public MemoryAddress allocateArray(ValueLayout elementLayout, byte[] array) {
+    public MemorySegment allocateArray(ValueLayout elementLayout, byte[] array) {
         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given short array.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param elementLayout the element layout of the array to be allocated.
      * @param array the array to be copied on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.
      */
-    public MemoryAddress allocateArray(ValueLayout elementLayout, short[] array) {
+    public MemorySegment allocateArray(ValueLayout elementLayout, short[] array) {
         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given char array.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param elementLayout the element layout of the array to be allocated.
      * @param array the array to be copied on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.
      */
-    public MemoryAddress allocateArray(ValueLayout elementLayout, char[] array) {
+    public MemorySegment allocateArray(ValueLayout elementLayout, char[] array) {
         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given int array.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param elementLayout the element layout of the array to be allocated.
      * @param array the array to be copied on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.
      */
-    public MemoryAddress allocateArray(ValueLayout elementLayout, int[] array) {
+    public MemorySegment allocateArray(ValueLayout elementLayout, int[] array) {
         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given float array.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param elementLayout the element layout of the array to be allocated.
      * @param array the array to be copied on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.
      */
-    public MemoryAddress allocateArray(ValueLayout elementLayout, float[] array) {
+    public MemorySegment allocateArray(ValueLayout elementLayout, float[] array) {
         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given long array.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param elementLayout the element layout of the array to be allocated.
      * @param array the array to be copied on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.
      */
-    public MemoryAddress allocateArray(ValueLayout elementLayout, long[] array) {
+    public MemorySegment allocateArray(ValueLayout elementLayout, long[] array) {
         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout and initialize it with given double array.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * segment must conform to the layout alignment constraints.
      * @param elementLayout the element layout of the array to be allocated.
      * @param array the array to be copied on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.
      */
-    public MemoryAddress allocateArray(ValueLayout elementLayout, double[] array) {
+    public MemorySegment allocateArray(ValueLayout elementLayout, double[] array) {
         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);
     }
 
-    private <Z> MemoryAddress copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,
+    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,
                                                         Function<Z, MemorySegment> heapSegmentFactory) {
         Utils.checkPrimitiveCarrierCompat(array.getClass().componentType(), elementLayout);
-        MemoryAddress addr = allocate(MemoryLayout.ofSequence(Array.getLength(array), elementLayout));
+        MemorySegment addr = allocate(MemoryLayout.ofSequence(Array.getLength(array), elementLayout));
         if (elementLayout.byteSize() == 1 || (elementLayout.order() == ByteOrder.nativeOrder())) {
-            addr.segment().copyFrom(heapSegmentFactory.apply(array));
+            addr.copyFrom(heapSegmentFactory.apply(array));
         } else {
-            ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());
+            ((AbstractMemorySegmentImpl)addr).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());
         }
         return addr;
     }
 
     /**
-     * Allocate a block of memory in this native scope with given layout. The address returned by this method is
-     * associated with a segment which cannot be closed. Moreover, the returned address must conform to the layout alignment constraints.
+     * Allocate a block of memory in this native scope with given layout. The segment returned by this method is
+     * associated with a segment which cannot be closed. Moreover, the returned segment must conform to the layout alignment constraints.
      * @param layout the layout of the block of memory to be allocated.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
      */
-    public MemoryAddress allocate(MemoryLayout layout) {
+    public MemorySegment allocate(MemoryLayout layout) {
         return allocate(layout.byteSize(), layout.byteAlignment());
     }
 
     /**
      * Allocate a block of memory corresponding to an array with given element layout and size.
-     * The address returned by this method is associated with a segment which cannot be closed.
-     * Moreover, the returned address must conform to the layout alignment constraints. This is equivalent to the
+     * The segment returned by this method is associated with a segment which cannot be closed.
+     * Moreover, the returned segment must conform to the layout alignment constraints. This is equivalent to the
      * following code:
      * <pre>{@code
     allocate(MemoryLayout.ofSequence(size, elementLayout));
      * }</pre>
      * @param elementLayout the array element layout.
      * @param size the array element count.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < (elementLayout.byteSize() * size)}.
      */
-    public MemoryAddress allocateArray(MemoryLayout elementLayout, long size) {
+    public MemorySegment allocateArray(MemoryLayout elementLayout, long size) {
         return allocate(MemoryLayout.ofSequence(size, elementLayout));
     }
 
     /**
-     * Allocate a block of memory in this native scope with given size. The address returned by this method is
-     * associated with a segment which cannot be closed. Moreover, the returned address must be aligned to {@code size}.
+     * Allocate a block of memory in this native scope with given size. The segment returned by this method is
+     * associated with a segment which cannot be closed. Moreover, the returned segment must be aligned to {@code size}.
      * @param bytesSize the size (in bytes) of the block of memory to be allocated.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < bytesSize}.
      */
-    public MemoryAddress allocate(long bytesSize) {
+    public MemorySegment allocate(long bytesSize) {
         return allocate(bytesSize, bytesSize);
     }
 
     /**
      * Allocate a block of memory in this native scope with given size and alignment constraint.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover,
-     * the returned address must be aligned to {@code alignment}.
+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover,
+     * the returned segment must be aligned to {@code alignment}.
      * @param bytesSize the size (in bytes) of the block of memory to be allocated.
      * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.
-     * @return an address which points to the newly allocated memory block.
+     * @return a segment for the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
      * {@code limit() - size() < bytesSize}.
      */
-    public abstract MemoryAddress allocate(long bytesSize, long bytesAlignment);
+    public abstract MemorySegment allocate(long bytesSize, long bytesAlignment);
 
     /**
      * Register a segment on this scope, which will then reclaim ownership of said segment.
      * The input segment must be closeable - that is, it must feature the {@link MemorySegment#CLOSE} access mode.
      * As a side-effect, the input segment will be marked as <em>not alive</em>, and a new segment will be returned.
@@ -370,11 +370,11 @@
      * or if {@code segment} does not feature the {@link MemorySegment#CLOSE} access mode.
      */
     public abstract MemorySegment register(MemorySegment segment);
 
     /**
-     * Close this native scope; calling this method will render any address obtained through this native scope
+     * Close this native scope; calling this method will render any segment obtained through this native scope
      * unusable and might release any backing memory resources associated with this native scope.
      */
     @Override
     public abstract void close();
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
@@ -26,12 +26,13 @@
 
 /**
  * <p> Classes to support low-level, safe and efficient memory access.
  * <p>
  * The key abstractions introduced by this package are {@link jdk.incubator.foreign.MemorySegment} and {@link jdk.incubator.foreign.MemoryAddress}.
- * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which can
- * sometimes be expressed as an offset into a given segment. A memory address represents the main access coordinate of a memory access var handle, which can be obtained
+ * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which also can
+ * reside either inside or outside the Java heap (and can sometimes be expressed as an offset into a given segment).
+ * A memory segment represents the main access coordinate of a memory access var handle, which can be obtained
  * using the combinator methods defined in the {@link jdk.incubator.foreign.MemoryHandles} class. Finally, the {@link jdk.incubator.foreign.MemoryLayout} class
  * hierarchy enables description of <em>memory layouts</em> and basic operations such as computing the size in bytes of a given
  * layout, obtain its alignment requirements, and so on. Memory layouts also provide an alternate, more abstract way, to produce
  * memory access var handles, e.g. using <a href="MemoryLayout.html#layout-paths"><em>layout paths</em></a>.
  *
@@ -40,13 +41,12 @@
  *
  * <pre>{@code
 static final VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
 
 try (MemorySegment segment = MemorySegment.allocateNative(10 * 4)) {
-    MemoryAddress base = segment.address();
     for (long i = 0 ; i < 10 ; i++) {
-       intHandle.set(base.addOffset(i * 4), (int)i);
+       intHandle.set(base.asSlice(i * 4), (int)i);
     }
 }
  * }</pre>
  *
  * Here we create a var handle, namely {@code intHandle}, to manipulate values of the primitive type {@code int}, at
@@ -75,18 +75,18 @@
  * models such as this can be very convenient - clients do not have to remember to <em>close</em> a direct buffer - such models can also make it
  * hard for clients to ensure that the memory associated with a direct buffer has indeed been released.
  *
  * <h2><a id="safety"></a>Safety</h2>
  *
- * This API provides strong safety guarantees when it comes to memory access. First, when dereferencing a memory segment using
- * a memory address, such an address is validated (upon access), to make sure that it does not point to a memory location
- * which resides <em>outside</em> the boundaries of the memory segment it refers to. We call this guarantee <em>spatial safety</em>;
+ * This API provides strong safety guarantees when it comes to memory access. First, when dereferencing a memory segment,
+ * the access coordinates are validated (upon access), to make sure that access does not occur at an address which resides
+ * <em>outside</em> the boundaries of the memory segment used by the dereference operation. We call this guarantee <em>spatial safety</em>;
  * in other words, access to memory segments is bounds-checked, in the same way as array access is, as described in
  * Section {@jls 15.10.4} of <cite>The Java Language Specification</cite>.
  * <p>
- * Since memory segments can be closed (see above), a memory address is also validated (upon access) to make sure that
- * the segment it belongs to has not been closed prematurely. We call this guarantee <em>temporal safety</em>. Note that,
+ * Since memory segments can be closed (see above), segments are also validated (upon access) to make sure that
+ * the segment being accessed has not been closed prematurely. We call this guarantee <em>temporal safety</em>. Note that,
  * in the general case, guaranteeing temporal safety can be hard, as multiple threads could attempt to access and/or close
  * the same memory segment concurrently. The memory access API addresses this problem by imposing strong
  * <a href="MemorySegment.html#thread-confinement"><em>thread-confinement</em></a> guarantees on memory segments: each
  * memory segment is associated with an owner thread, which is the only thread that can either access or close the segment.
  * <p>
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -101,10 +101,16 @@
     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
         checkBounds(offset, newSize);
         return asSliceNoCheck(offset, newSize);
     }
 
+    @Override
+    public AbstractMemorySegmentImpl asSlice(long offset) {
+        checkBounds(offset, 0);
+        return asSliceNoCheck(offset, length - offset);
+    }
+
     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
         return dup(offset, newSize, mask, scope);
     }
 
     @SuppressWarnings("unchecked")
@@ -117,30 +123,30 @@
                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));
     }
 
     @Override
     public final MemorySegment fill(byte value){
-        checkRange(0, length, true);
+        checkAccess(0, length, false);
         UNSAFE.setMemory(base(), min(), length, value);
         return this;
     }
 
     public void copyFrom(MemorySegment src) {
         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
         long size = that.byteSize();
-        checkRange(0, size, true);
-        that.checkRange(0, size, false);
+        checkAccess(0, size, false);
+        that.checkAccess(0, size, true);
         UNSAFE.copyMemory(
                 that.base(), that.min(),
                 base(), min(), size);
     }
 
     public void copyFromSwap(MemorySegment src, long elemSize) {
         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
         long size = that.byteSize();
-        checkRange(0, size, true);
-        that.checkRange(0, size, false);
+        checkAccess(0, size, true);
+        that.checkAccess(0, size, false);
         UNSAFE.copySwapMemory(
                 that.base(), that.min(),
                 base(), min(), size, elemSize);
     }
 
@@ -151,19 +157,19 @@
     public long mismatch(MemorySegment other) {
         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
         final long thisSize = this.byteSize();
         final long thatSize = that.byteSize();
         final long length = Math.min(thisSize, thatSize);
-        this.checkRange(0, length, false);
-        that.checkRange(0, length, false);
+        this.checkAccess(0, length, true);
+        that.checkAccess(0, length, true);
         if (this == other) {
             return -1;
         }
 
         long i = 0;
         if (length > 7) {
-            if ((byte) BYTE_HANDLE.get(this.address(), 0) != (byte) BYTE_HANDLE.get(that.address(), 0)) {
+            if ((byte) BYTE_HANDLE.get(this, 0) != (byte) BYTE_HANDLE.get(that, 0)) {
                 return 0;
             }
             i = ArraysSupport.vectorizedMismatchLargeForBytes(
                     this.base(), this.min(),
                     that.base(), that.min(),
@@ -173,24 +179,23 @@
             }
             long remaining = ~i;
             assert remaining < 8 : "remaining greater than 7: " + remaining;
             i = length - remaining;
         }
-        MemoryAddress thisAddress = this.address();
-        MemoryAddress thatAddress = that.address();
         for (; i < length; i++) {
-            if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {
+            if ((byte) BYTE_HANDLE.get(this, i) != (byte) BYTE_HANDLE.get(that, i)) {
                 return i;
             }
         }
         return thisSize != thatSize ? length : -1;
     }
 
     @Override
     @ForceInline
     public final MemoryAddress address() {
-        return new MemoryAddressImpl(this, 0);
+        checkValidState();
+        return new MemoryAddressImpl(base(), min());
     }
 
     @Override
     public final ByteBuffer asByteBuffer() {
         if (!isSet(READ)) {
@@ -328,24 +333,36 @@
         MemorySegment arrSegment = segmentFactory.apply(arr);
         arrSegment.copyFrom(this);
         return arr;
     }
 
-    boolean isSmall() {
+    @Override
+    public boolean isSmall() {
         return isSet(SMALL);
     }
 
-    void checkRange(long offset, long length, boolean writeAccess) {
+    @Override
+    public void checkAccess(long offset, long length, boolean readOnly) {
         scope.checkValidState();
-        if (writeAccess && !isSet(WRITE)) {
+        if (!readOnly && !isSet(WRITE)) {
             throw unsupportedAccessMode(WRITE);
-        } else if (!writeAccess && !isSet(READ)) {
+        } else if (readOnly && !isSet(READ)) {
             throw unsupportedAccessMode(READ);
         }
         checkBounds(offset, length);
     }
 
+    @Override
+    public long unsafeGetOffset() {
+        return min();
+    }
+
+    @Override
+    public Object unsafeGetBase() {
+        return base();
+    }
+
     @Override
     public final void checkValidState() {
         scope.checkValidState();
     }
 
@@ -566,29 +583,6 @@
         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
             throw new UnsupportedOperationException();
         }
     };
 
-    public static final AbstractMemorySegmentImpl EVERYTHING = new AbstractMemorySegmentImpl(
-            Long.MAX_VALUE, READ | WRITE, MemoryScope.createUnchecked(null, null, null)
-    ) {
-        @Override
-        ByteBuffer makeByteBuffer() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        long min() {
-            return 0;
-        }
-
-        @Override
-        Object base() {
-            return null;
-        }
-
-        @Override
-        AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
-            throw new UnsupportedOperationException();
-        }
-    };
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractNativeScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractNativeScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractNativeScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractNativeScope.java
@@ -1,8 +1,7 @@
 package jdk.internal.foreign;
 
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.NativeScope;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -90,26 +89,25 @@
             super(Thread.currentThread());
             this.segment = newSegment(BLOCK_SIZE);
         }
 
         @Override
-        public MemoryAddress allocate(long bytesSize, long bytesAlignment) {
+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {
             checkOwnerThread();
             if (bytesSize > MAX_ALLOC_SIZE) {
                 MemorySegment segment = newSegment(bytesSize, bytesAlignment);
-                return segment.withAccessModes(SCOPE_MASK)
-                        .address();
+                return segment.withAccessModes(SCOPE_MASK);
             }
             for (int i = 0; i < 2; i++) {
-                long min = ((MemoryAddressImpl) segment.address()).unsafeGetOffset();
+                long min = segment.address().toRawLongValue();
                 long start = Utils.alignUp(min + sp, bytesAlignment) - min;
                 try {
                     MemorySegment slice = segment.asSlice(start, bytesSize)
                             .withAccessModes(SCOPE_MASK);
                     sp = start + bytesSize;
                     size += Utils.alignUp(bytesSize, bytesAlignment);
-                    return slice.address();
+                    return slice;
                 } catch (IndexOutOfBoundsException ex) {
                     sp = 0L;
                     segment = newSegment(BLOCK_SIZE, 1L);
                 }
             }
@@ -135,19 +133,19 @@
             super(Thread.currentThread());
             this.segment = newSegment(size, 1);
         }
 
         @Override
-        public MemoryAddress allocate(long bytesSize, long bytesAlignment) {
+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {
             checkOwnerThread();
-            long min = ((MemoryAddressImpl)segment.address()).unsafeGetOffset();
+            long min = segment.address().toRawLongValue();
             long start = Utils.alignUp(min + sp, bytesAlignment) - min;
             try {
                 MemorySegment slice = segment.asSlice(start, bytesSize)
                         .withAccessModes(SCOPE_MASK);
                 sp = start + bytesSize;
-                return slice.address();
+                return slice;
             } catch (IndexOutOfBoundsException ex) {
                 throw new OutOfMemoryError("Not enough space left to allocate");
             }
         }
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
@@ -23,25 +23,32 @@
  *  questions.
  *
  */
 package jdk.internal.foreign;
 
+import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
 import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.internal.access.SharedSecrets;
-import sun.invoke.util.Wrapper;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
+import sun.invoke.util.Wrapper;
 
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.List;
 import java.util.function.ToLongFunction;
 import java.util.function.UnaryOperator;
-import java.util.stream.LongStream;
 
 /**
  * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout, ToLongFunction)},
  * a path can be constructed by selecting layout elements using the selector methods provided by this class
  * (see {@link #sequenceElement()}, {@link #sequenceElement(long)}, {@link #sequenceElement(long, long)}, {@link #groupElement(String)}).
@@ -51,10 +58,21 @@
  */
 public class LayoutPath {
 
     private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();
 
+    private static final MethodHandle ADD_STRIDE;
+
+    static {
+        try {
+            ADD_STRIDE = MethodHandles.lookup().findStatic(LayoutPath.class, "addStride",
+                    MethodType.methodType(long.class, MemorySegment.class, long.class, long.class, long.class));
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
     private final MemoryLayout layout;
     private final long offset;
     private final LayoutPath enclosing;
     private final long[] strides;
     private final long elementIndex;
@@ -131,16 +149,34 @@
 
     public VarHandle dereferenceHandle(Class<?> carrier) {
         Utils.checkPrimitiveCarrierCompat(carrier, layout);
         checkAlignment(this);
 
-        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
-                carrier,
-                layout.byteAlignment() - 1, //mask
-                ((ValueLayout) layout).order(),
-                Utils.bitsToBytesOrThrow(offset, IllegalStateException::new),
-                LongStream.of(strides).map(s -> Utils.bitsToBytesOrThrow(s, IllegalStateException::new)).toArray()));
+        List<Class<?>> expectedCoordinates = new ArrayList<>();
+        Deque<Integer> perms = new ArrayDeque<>();
+        perms.addFirst(0);
+        expectedCoordinates.add(MemorySegment.class);
+
+        VarHandle handle = Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, true, layout.byteAlignment() - 1,
+                ((ValueLayout)layout).order()));
+
+        for (int i = 0 ; i < strides.length ; i++) {
+            expectedCoordinates.add(long.class);
+            perms.addFirst(0);
+            perms.addLast(i + 1);
+            //add stride
+            handle = MemoryHandles.collectCoordinates(handle, 1 + i,
+                    MethodHandles.insertArguments(ADD_STRIDE, 1, Utils.bitsToBytesOrThrow(strides[strides.length - 1 - i], IllegalStateException::new))); // MS, long, MS_n, long_n, long
+        }
+        //add offset
+        handle = MemoryHandles.insertCoordinates(handle, 1 + strides.length, Utils.bitsToBytesOrThrow(offset, IllegalStateException::new));
+
+        if (strides.length > 0) {
+            // remove duplicate MS args
+            handle = MemoryHandles.permuteCoordinates(handle, expectedCoordinates, perms.stream().mapToInt(i -> i).toArray());
+        }
+        return handle;
     }
 
     public MemoryLayout layout() {
         return layout;
     }
@@ -274,6 +310,11 @@
 
         public PathKind kind() {
             return kind;
         }
     }
+
+    private static long addStride(MemorySegment segment, long stride, long base, long index) {
+        return MemorySegmentProxy.addOffsets(base,
+                    MemorySegmentProxy.multiplyOffsets(stride, index, ((MemorySegmentProxy)segment)), (MemorySegmentProxy)segment);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -23,123 +23,81 @@
  *  questions.
  *
  */
 package jdk.internal.foreign;
 
-import jdk.internal.access.foreign.MemoryAddressProxy;
-import jdk.internal.misc.Unsafe;
-
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
 import java.util.Objects;
 
 /**
  * This class provides an immutable implementation for the {@code MemoryAddress} interface. This class contains information
  * about the segment this address is associated with, as well as an offset into such segment.
  */
-public final class MemoryAddressImpl implements MemoryAddress, MemoryAddressProxy {
-
-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+public final class MemoryAddressImpl implements MemoryAddress {
 
-    private final AbstractMemorySegmentImpl segment;
+    private final Object base;
     private final long offset;
 
-    public MemoryAddressImpl(long offset) {
-        this.segment = AbstractMemorySegmentImpl.NOTHING;
-        this.offset = offset;
-    }
-
-    public MemoryAddressImpl(AbstractMemorySegmentImpl segment, long offset) {
-        this.segment = Objects.requireNonNull(segment);
+    public MemoryAddressImpl(Object base, long offset) {
+        this.base = base;
         this.offset = offset;
     }
 
     // MemoryAddress methods
 
     @Override
-    public long segmentOffset() {
-        if (segment() == null) {
-            throw new UnsupportedOperationException("Address does not have a segment");
+    public long segmentOffset(MemorySegment segment) {
+        Objects.requireNonNull(segment);
+        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
+        if (segmentImpl.base() != base) {
+            throw new IllegalArgumentException("Invalid segment: " + segment);
         }
-        return offset;
+        return offset - segmentImpl.min();
     }
 
     @Override
     public long toRawLongValue() {
-        if (unsafeGetBase() != null) {
+        if (base != null) {
             throw new UnsupportedOperationException("Not a native address");
         }
-        return unsafeGetOffset();
-    }
-
-    @Override
-    public MemorySegment segment() {
-        return segment != AbstractMemorySegmentImpl.NOTHING ?
-                segment : null;
+        return offset;
     }
 
     @Override
     public MemoryAddress addOffset(long bytes) {
-        return new MemoryAddressImpl(segment, offset + bytes);
+        return new MemoryAddressImpl(base, offset + bytes);
     }
 
-    @Override
-    public MemoryAddress rebase(MemorySegment segment) {
-        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
-        if (segmentImpl.base() != this.segment.base()) {
-            throw new IllegalArgumentException("Invalid rebase target: " + segment);
-        }
-        return new MemoryAddressImpl((AbstractMemorySegmentImpl)segment,
-                unsafeGetOffset() - ((MemoryAddressImpl)segment.address()).unsafeGetOffset());
-    }
-
-    // MemoryAddressProxy methods
-
-    public void checkAccess(long offset, long length, boolean readOnly) {
-        segment.checkRange(MemoryAddressProxy.addOffsets(this.offset, offset, this), length, !readOnly);
-    }
-
-    public long unsafeGetOffset() {
-        return segment.min() + offset;
-    }
-
-    public Object unsafeGetBase() {
-        return segment.base();
-    }
-
-    @Override
-    public boolean isSmall() {
-        return segment.isSmall();
-    }
     // Object methods
 
     @Override
     public int hashCode() {
-        return Objects.hash(unsafeGetBase(), unsafeGetOffset());
+        return Objects.hash(base, offset);
     }
 
     @Override
     public boolean equals(Object that) {
         if (that instanceof MemoryAddressImpl) {
             MemoryAddressImpl addr = (MemoryAddressImpl)that;
-            return Objects.equals(unsafeGetBase(), ((MemoryAddressImpl) that).unsafeGetBase()) &&
-                    unsafeGetOffset() == addr.unsafeGetOffset();
+            return Objects.equals(base, addr.base) &&
+                    offset == addr.offset;
         } else {
             return false;
         }
     }
 
     @Override
     public String toString() {
-        return "MemoryAddress{ region: " + segment + " offset=0x" + Long.toHexString(offset) + " }";
+        return "MemoryAddress{ base: " + base + " offset=0x" + Long.toHexString(offset) + " }";
     }
 
-    public static MemoryAddress ofLongUnchecked(long value) {
+    public static MemorySegment ofLongUnchecked(long value) {
         return ofLongUnchecked(value, Long.MAX_VALUE);
     }
 
-    public static MemoryAddress ofLongUnchecked(long value, long byteSize) {
+    public static MemorySegment ofLongUnchecked(long value, long byteSize) {
         return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
-                MemoryAddress.ofLong(value), byteSize, null, null, null).address();
+                MemoryAddress.ofLong(value), byteSize, null, null, null);
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -25,17 +25,17 @@
  */
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.CSupport;
-import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.ValueLayout;
-import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.misc.VM;
 import sun.invoke.util.Wrapper;
 
 import java.lang.invoke.MethodHandle;
@@ -55,12 +55,12 @@
 
     private static final MethodHandle ADDRESS_FILTER;
 
     static {
         try {
-            ADDRESS_FILTER = MethodHandles.lookup().findStatic(Utils.class, "filterAddress",
-                    MethodType.methodType(MemoryAddressProxy.class, MemoryAddress.class));
+            ADDRESS_FILTER = MethodHandles.lookup().findStatic(Utils.class, "filterSegment",
+                    MethodType.methodType(MemorySegmentProxy.class, MemorySegment.class));
         } catch (Throwable ex) {
             throw new ExceptionInInitializerError(ex);
         }
     }
 
@@ -71,10 +71,15 @@
     public static MemoryAddress alignUp(MemoryAddress ma, long alignment) {
         long offset = ma.toRawLongValue();
         return ma.addOffset(alignUp(offset, alignment) - offset);
     }
 
+    public static MemorySegment alignUp(MemorySegment ms, long alignment) {
+        long offset = ms.address().toRawLongValue();
+        return ms.asSlice(alignUp(offset, alignment) - offset);
+    }
+
     public static long bitsToBytesOrThrow(long bits, Supplier<RuntimeException> exFactory) {
         if (bits % 8 == 0) {
             return bits / 8;
         } else {
             throw exFactory.get();
@@ -85,12 +90,12 @@
         // This adaptation is required, otherwise the memory access var handle will have type MemoryAddressProxy,
         // and not MemoryAddress (which the user expects), which causes performance issues with asType() adaptations.
         return MemoryHandles.filterCoordinates(handle, 0, ADDRESS_FILTER);
     }
 
-    private static MemoryAddressProxy filterAddress(MemoryAddress addr) {
-        return (MemoryAddressImpl)addr;
+    private static MemorySegmentProxy filterSegment(MemorySegment segment) {
+        return (AbstractMemorySegmentImpl)segment;
     }
 
     public static void checkRestrictedAccess(String method) {
         switch (foreignRestrictedAccess) {
             case "deny" -> throwIllegalAccessError(foreignRestrictedAccess, method);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java
@@ -280,11 +280,11 @@
         if (!type.isPrimitive() || type == void.class || type == boolean.class)
             throw new IllegalArgumentException("Illegal type: " + type);
     }
 
     private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, NativeScope allocator) {
-        MemorySegment copy = allocator.allocate(size, alignment).segment();
+        MemorySegment copy = allocator.allocate(size, alignment);
         copy.copyFrom(operand.asSlice(0, size));
         return copy;
     }
 
     public static Move move(VMStorage storage, Class<?> type) {
@@ -516,43 +516,38 @@
         }
 
         @Override
         public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
             MemorySegment operand = (MemorySegment) stack.pop();
-            MemoryAddress baseAddress = operand.address();
-            MemoryAddress readAddress = baseAddress.addOffset(offset);
+            MemorySegment readAddress = operand.asSlice(offset);
             stack.push(SharedUtils.read(readAddress, type));
         }
 
         @Override
         public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {
             Object value = stack.pop();
             MemorySegment operand = (MemorySegment) stack.pop();
-            MemoryAddress baseAddress = operand.address();
-            MemoryAddress writeAddress = baseAddress.addOffset(offset);
+            MemorySegment writeAddress = operand.asSlice(offset);
             SharedUtils.write(writeAddress, type, value);
         }
 
         private VarHandle varHandle() {
-            return MemoryHandles.withOffset(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), offset);
+            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), 1, offset);
         }
 
         @Override
         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
-            MethodHandle filter = filterArguments(
-                varHandle()
+            MethodHandle filter = varHandle()
                     .toMethodHandle(VarHandle.AccessMode.GET)
-                    .asType(methodType(type, MemoryAddress.class)), 0, MH_BASE_ADDRESS);
+                    .asType(methodType(type, MemorySegment.class));
             return filterArguments(specializedHandle, insertPos, filter);
         }
 
         @Override
         public MethodHandle specializeBox(MethodHandle returnFilter) {
             MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);
-            setter = filterArguments(
-                setter.asType(methodType(void.class, MemoryAddress.class, type)),
-                0, MH_BASE_ADDRESS);
+            setter = setter.asType(methodType(void.class, MemorySegment.class, type));
             return collectArguments(returnFilter, returnFilter.type().parameterCount(), setter);
         }
     }
 
     /**
@@ -617,21 +612,21 @@
         }
 
         @Override
         public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
             MemorySegment operand = (MemorySegment) stack.pop();
-            MemorySegment copy = scope.allocate(size, alignment).segment();
+            MemorySegment copy = scope.allocate(size, alignment);
             copy.copyFrom(operand.asSlice(0, size));
             stack.push(copy);
         }
 
         @Override
         public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {
             MemoryAddress operand = (MemoryAddress) stack.pop();
-            operand = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);
+            MemorySegment segment = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);
             MemorySegment copy = MemorySegment.allocateNative(size, alignment);
-            copy.copyFrom(operand.segment().asSlice(0, size));
+            copy.copyFrom(segment);
             stack.push(copy); // leaked
         }
 
         @Override
         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
@@ -767,11 +762,11 @@
             stack.push(MemoryAddress.class);
         }
 
         @Override
         public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
-            stack.push(((MemoryAddress) stack.pop()).toRawLongValue());
+            stack.push(((MemoryAddress)stack.pop()).toRawLongValue());
         }
 
         @Override
         public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {
             stack.push(MemoryAddress.ofLong((long) stack.pop()));
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BufferLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BufferLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BufferLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BufferLayout.java
@@ -20,21 +20,20 @@
  *  or visit www.oracle.com if you need additional information or have any
  *  questions.
  */
 package jdk.internal.foreign.abi;
 
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemorySegment;
 
 import java.io.PrintStream;
 import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
 import java.util.HashMap;
 import java.util.Map;
 
 class BufferLayout {
-    static final VarHandle VH_LONG = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
+    static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);
 
     final long size;
     final long arguments_next_pc;
     final long stack_args_bytes;
     final long stack_args;
@@ -108,30 +107,30 @@
 
     long retOffset(jdk.internal.foreign.abi.VMStorage storage) {
         return retOffsets.get(storage);
     }
 
-    private static String getLongString(MemoryAddress buffer, long offset) {
-        return Long.toHexString((long) VH_LONG.get(buffer.addOffset(offset)));
+    private static String getLongString(MemorySegment buffer, long offset) {
+        return Long.toHexString((long) VH_LONG.get(buffer.asSlice(offset)));
     }
 
-    private static void dumpValues(jdk.internal.foreign.abi.Architecture arch, MemoryAddress buff, PrintStream stream,
+    private static void dumpValues(jdk.internal.foreign.abi.Architecture arch, MemorySegment buff, PrintStream stream,
                                    Map<jdk.internal.foreign.abi.VMStorage, Long> offsets) {
         for (var entry : offsets.entrySet()) {
             VMStorage storage = entry.getKey();
             stream.print(storage.name());
             stream.print("={ ");
-            MemoryAddress start = buff.addOffset(entry.getValue());
+            MemorySegment start = buff.asSlice(entry.getValue());
             for (int i = 0; i < arch.typeSize(storage.type()) / 8; i += 8) {
                 stream.print(getLongString(start, i));
                 stream.print(" ");
             }
             stream.println("}");
         }
     }
 
-    void dump(Architecture arch, MemoryAddress buff, PrintStream stream) {
+    void dump(Architecture arch, MemorySegment buff, PrintStream stream) {
         stream.println("Next PC: " + getLongString(buff, arguments_next_pc));
         stream.println("Stack args bytes: " + getLongString(buff, stack_args_bytes));
         stream.println("Stack args ptr: " + getLongString(buff, stack_args));
 
         stream.println("Arguments:");
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
@@ -23,10 +23,11 @@
 package jdk.internal.foreign.abi;
 
 import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.NativeScope;
 import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.foreign.MemoryAddressImpl;
@@ -69,11 +70,11 @@
     private static final boolean USE_INTRINSICS = Boolean.parseBoolean(
         GetPropertyAction.privilegedGetProperty("jdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS", "false"));
 
     private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();
 
-    private static final VarHandle VH_LONG = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
+    private static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);
 
     private static final MethodHandle MH_INVOKE_MOVES;
     private static final MethodHandle MH_INVOKE_INTERP_BINDINGS;
 
     private static final MethodHandle MH_MAKE_ALLOCATOR;
@@ -265,56 +266,51 @@
      * @return null, a single primitive value, or an Object[] of primitive values
      */
     Object invokeMoves(Object[] args, Binding.Move[] argBindings, Binding.Move[] returnBindings) {
         MemorySegment stackArgsSeg = null;
         try (MemorySegment argBuffer = MemorySegment.allocateNative(layout.size, 64)) {
-            MemoryAddress argsPtr = argBuffer.address();
-            MemoryAddress stackArgs;
             if (stackArgsBytes > 0) {
                 stackArgsSeg = MemorySegment.allocateNative(stackArgsBytes, 8);
-                stackArgs = stackArgsSeg.address();
-            } else {
-                stackArgs = MemoryAddressImpl.NULL;
             }
 
-            VH_LONG.set(argsPtr.addOffset(layout.arguments_next_pc), addr.address().toRawLongValue());
-            VH_LONG.set(argsPtr.addOffset(layout.stack_args_bytes), stackArgsBytes);
-            VH_LONG.set(argsPtr.addOffset(layout.stack_args), stackArgs.toRawLongValue());
+            VH_LONG.set(argBuffer.asSlice(layout.arguments_next_pc), addr.address().toRawLongValue());
+            VH_LONG.set(argBuffer.asSlice(layout.stack_args_bytes), stackArgsBytes);
+            VH_LONG.set(argBuffer.asSlice(layout.stack_args), stackArgsSeg == null ? 0L : stackArgsSeg.address().toRawLongValue());
 
             for (int i = 0; i < argBindings.length; i++) {
                 Binding.Move binding = argBindings[i];
                 VMStorage storage = binding.storage();
-                MemoryAddress ptr = abi.arch.isStackType(storage.type())
-                    ? stackArgs.addOffset(storage.index() * abi.arch.typeSize(abi.arch.stackType()))
-                    : argsPtr.addOffset(layout.argOffset(storage));
+                MemorySegment ptr = abi.arch.isStackType(storage.type())
+                    ? stackArgsSeg.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))
+                    : argBuffer.asSlice(layout.argOffset(storage));
                 SharedUtils.writeOverSized(ptr, binding.type(), args[i]);
             }
 
             if (DEBUG) {
                 System.err.println("Buffer state before:");
-                layout.dump(abi.arch, argsPtr, System.err);
+                layout.dump(abi.arch, argBuffer, System.err);
             }
 
-            invokeNative(stubAddress, argsPtr.toRawLongValue());
+            invokeNative(stubAddress, argBuffer.address().toRawLongValue());
 
             if (DEBUG) {
                 System.err.println("Buffer state after:");
-                layout.dump(abi.arch, argsPtr, System.err);
+                layout.dump(abi.arch, argBuffer, System.err);
             }
 
             if (returnBindings.length == 0) {
                 return null;
             } else if (returnBindings.length == 1) {
                 Binding.Move move = returnBindings[0];
                 VMStorage storage = move.storage();
-                return SharedUtils.read(argsPtr.addOffset(layout.retOffset(storage)), move.type());
+                return SharedUtils.read(argBuffer.asSlice(layout.retOffset(storage)), move.type());
             } else { // length > 1
                 Object[] returns = new Object[returnBindings.length];
                 for (int i = 0; i < returnBindings.length; i++) {
                     Binding.Move move = returnBindings[i];
                     VMStorage storage = move.storage();
-                    returns[i] = SharedUtils.read(argsPtr.addOffset(layout.retOffset(storage)), move.type());
+                    returns[i] = SharedUtils.read(argBuffer.asSlice(layout.retOffset(storage)), move.type());
                 }
                 return returns;
             }
         } finally {
             if (stackArgsSeg != null) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableUpcallHandler.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableUpcallHandler.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableUpcallHandler.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableUpcallHandler.java
@@ -23,10 +23,12 @@
 
 package jdk.internal.foreign.abi;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemorySegment;
 import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.vm.annotation.Stable;
 
 import java.lang.invoke.MethodHandle;
@@ -47,11 +49,11 @@
 public class ProgrammableUpcallHandler implements UpcallHandler {
 
     private static final boolean DEBUG =
         privilegedGetProperty("jdk.internal.foreign.ProgrammableUpcallHandler.DEBUG");
 
-    private static final VarHandle VH_LONG = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
+    private static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);
 
     @Stable
     private final MethodHandle mh;
     private final MethodType type;
     private final CallingSequence callingSequence;
@@ -78,24 +80,25 @@
         handler.invoke(MemoryAddress.ofLong(address));
     }
 
     private void invoke(MemoryAddress buffer) {
         try {
+            MemorySegment bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);
+
             if (DEBUG) {
                 System.err.println("Buffer state before:");
-                layout.dump(abi.arch, buffer, System.err);
+                layout.dump(abi.arch, bufferBase, System.err);
             }
 
-            MemoryAddress bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);
-            MemoryAddress stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(buffer.rebase(bufferBase.segment()).addOffset(layout.stack_args)));
+            MemorySegment stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(bufferBase.asSlice(layout.stack_args)));
             Object[] args = new Object[type.parameterCount()];
             for (int i = 0 ; i < type.parameterCount() ; i++) {
                 args[i] = BindingInterpreter.box(callingSequence.argumentBindings(i),
                         (storage, type) -> {
-                            MemoryAddress ptr = abi.arch.isStackType(storage.type())
-                                ? stackArgsBase.addOffset(storage.index() * abi.arch.typeSize(abi.arch.stackType()))
-                                : bufferBase.addOffset(layout.argOffset(storage));
+                            MemorySegment ptr = abi.arch.isStackType(storage.type())
+                                ? stackArgsBase.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))
+                                : bufferBase.asSlice(layout.argOffset(storage));
                             return SharedUtils.read(ptr, type);
                         });
             }
 
             if (DEBUG) {
@@ -111,18 +114,18 @@
             }
 
             if (mh.type().returnType() != void.class) {
                 BindingInterpreter.unbox(o, callingSequence.returnBindings(),
                         (storage, type, value) -> {
-                            MemoryAddress ptr = bufferBase.addOffset(layout.retOffset(storage));
+                            MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));
                             SharedUtils.writeOverSized(ptr, type, value);
                         }, null);
             }
 
             if (DEBUG) {
                 System.err.println("Buffer state after:");
-                layout.dump(abi.arch, buffer, System.err);
+                layout.dump(abi.arch, bufferBase, System.err);
             }
         } catch (Throwable t) {
             throw new IllegalStateException(t);
         }
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -35,21 +35,19 @@
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.NativeScope;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.MemoryAddressImpl;
-import jdk.internal.foreign.NativeMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.aarch64.AArch64Linker;
 import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;
 import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
 import java.nio.charset.Charset;
 import java.util.List;
 import java.util.function.Consumer;
 import java.util.stream.IntStream;
 
@@ -64,18 +62,10 @@
 
     private static final MethodHandle MH_ALLOC_BUFFER;
     private static final MethodHandle MH_BASEADDRESS;
     private static final MethodHandle MH_BUFFER_COPY;
 
-    private static final VarHandle VH_BYTE = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_CHAR = MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_SHORT = MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_INT = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_LONG = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_FLOAT = MemoryHandles.varHandle(float.class, ByteOrder.nativeOrder());
-    private static final VarHandle VH_DOUBLE = MemoryHandles.varHandle(double.class, ByteOrder.nativeOrder());
-
     static {
         try {
             var lookup = MethodHandles.lookup();
             MH_ALLOC_BUFFER = lookup.findStatic(SharedUtils.class, "allocateNative",
                     methodType(MemorySegment.class, MemoryLayout.class));
@@ -196,12 +186,11 @@
 
         return target;
     }
 
     private static MemoryAddress bufferCopy(MemoryAddress dest, MemorySegment buffer) {
-        MemoryAddressImpl.ofLongUnchecked(dest.toRawLongValue(), buffer.byteSize())
-                .segment().copyFrom(buffer);
+        MemoryAddressImpl.ofLongUnchecked(dest.toRawLongValue(), buffer.byteSize()).copyFrom(buffer);
         return dest;
     }
 
     public static void checkCompatibleType(Class<?> carrier, MemoryLayout layout, long addressSize) {
         if (carrier.isPrimitive()) {
@@ -258,22 +247,22 @@
             return AArch64Linker.getInstance();
         }
         throw new UnsupportedOperationException("Unsupported os or arch: " + os + ", " + arch);
     }
 
-    public static String toJavaStringInternal(MemoryAddress addr, Charset charset) {
-        int len = strlen(addr);
+    public static String toJavaStringInternal(MemorySegment segment, long start, Charset charset) {
+        int len = strlen(segment, start);
         byte[] bytes = new byte[len];
         MemorySegment.ofArray(bytes)
-                .copyFrom(NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, len, null, null, null));
+                .copyFrom(segment.asSlice(start, len));
         return new String(bytes, charset);
     }
 
-    private static int strlen(MemoryAddress address) {
+    private static int strlen(MemorySegment segment, long start) {
         // iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)
         for (int offset = 0; offset >= 0; offset++) {
-            byte curr = MemoryAccess.getByteAtOffset(address, offset);
+            byte curr = MemoryAccess.getByteAtOffset(segment, start + offset);
             if (curr == 0) {
                 return offset;
             }
         }
         throw new IllegalArgumentException("String too large");
@@ -367,11 +356,11 @@
         }
 
         MemorySegment allocate(long size, long align);
 
         static Allocator ofScope(NativeScope scope) {
-            return (size, align) -> scope.allocate(size, align).segment();
+            return scope::allocate;
         }
     }
 
     public static class SimpleVaArg {
         public final Class<?> carrier;
@@ -462,66 +451,66 @@
         public MemoryAddress address() {
             return address;
         }
     }
 
-    static void writeOverSized(MemoryAddress ptr, Class<?> type, Object o) {
+    static void writeOverSized(MemorySegment ptr, Class<?> type, Object o) {
         // use VH_LONG for integers to zero out the whole register in the process
         if (type == long.class) {
-            VH_LONG.set(ptr, (long) o);
+            MemoryAccess.setLong(ptr, (long) o);
         } else if (type == int.class) {
-            VH_LONG.set(ptr, (long) (int) o);
+            MemoryAccess.setLong(ptr, (int) o);
         } else if (type == short.class) {
-            VH_LONG.set(ptr, (long) (short) o);
+            MemoryAccess.setLong(ptr, (short) o);
         } else if (type == char.class) {
-            VH_LONG.set(ptr, (long) (char) o);
+            MemoryAccess.setLong(ptr, (char) o);
         } else if (type == byte.class) {
-            VH_LONG.set(ptr, (long) (byte) o);
+            MemoryAccess.setLong(ptr, (byte) o);
         } else if (type == float.class) {
-            VH_FLOAT.set(ptr, (float) o);
+            MemoryAccess.setFloat(ptr, (float) o);
         } else if (type == double.class) {
-            VH_DOUBLE.set(ptr, (double) o);
+            MemoryAccess.setDouble(ptr, (double) o);
         } else {
             throw new IllegalArgumentException("Unsupported carrier: " + type);
         }
     }
 
-    static void write(MemoryAddress ptr, Class<?> type, Object o) {
+    static void write(MemorySegment ptr, Class<?> type, Object o) {
         if (type == long.class) {
-            VH_LONG.set(ptr, (long) o);
+            MemoryAccess.setLong(ptr, (long) o);
         } else if (type == int.class) {
-            VH_INT.set(ptr, (int) o);
+            MemoryAccess.setInt(ptr, (int) o);
         } else if (type == short.class) {
-            VH_SHORT.set(ptr, (short) o);
+            MemoryAccess.setShort(ptr, (short) o);
         } else if (type == char.class) {
-            VH_CHAR.set(ptr, (char) o);
+            MemoryAccess.setChar(ptr, (char) o);
         } else if (type == byte.class) {
-            VH_BYTE.set(ptr, (byte) o);
+            MemoryAccess.setByte(ptr, (byte) o);
         } else if (type == float.class) {
-            VH_FLOAT.set(ptr, (float) o);
+            MemoryAccess.setFloat(ptr, (float) o);
         } else if (type == double.class) {
-            VH_DOUBLE.set(ptr, (double) o);
+            MemoryAccess.setDouble(ptr, (double) o);
         } else {
             throw new IllegalArgumentException("Unsupported carrier: " + type);
         }
     }
 
-    static Object read(MemoryAddress ptr, Class<?> type) {
+    static Object read(MemorySegment ptr, Class<?> type) {
         if (type == long.class) {
-            return (long) VH_LONG.get(ptr);
+            return MemoryAccess.getLong(ptr);
         } else if (type == int.class) {
-            return (int) VH_INT.get(ptr);
+            return MemoryAccess.getInt(ptr);
         } else if (type == short.class) {
-            return (short) VH_SHORT.get(ptr);
+            return MemoryAccess.getShort(ptr);
         } else if (type == char.class) {
-            return (char) VH_CHAR.get(ptr);
+            return MemoryAccess.getChar(ptr);
         } else if (type == byte.class) {
-            return (byte) VH_BYTE.get(ptr);
+            return MemoryAccess.getByte(ptr);
         } else if (type == float.class) {
-            return (float) VH_FLOAT.get(ptr);
+            return MemoryAccess.getFloat(ptr);
         } else if (type == double.class) {
-            return (double) VH_DOUBLE.get(ptr);
+            return MemoryAccess.getDouble(ptr);
         } else {
             throw new IllegalArgumentException("Unsupported carrier: " + type);
         }
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
@@ -134,17 +134,16 @@
         long ptr = U.allocateMemory(LAYOUT.byteSize());
         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
                 MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null,
                 () -> U.freeMemory(ptr), null);
         cleaner.register(AArch64VaList.class, ms::close);
-        MemoryAddress base = ms.address();
-        VH_stack.set(base, MemoryAddress.NULL);
-        VH_gr_top.set(base, MemoryAddress.NULL);
-        VH_vr_top.set(base, MemoryAddress.NULL);
-        VH_gr_offs.set(base, 0);
-        VH_vr_offs.set(base, 0);
-        return ms.withAccessModes(0).address();
+        VH_stack.set(ms, MemoryAddress.NULL);
+        VH_gr_top.set(ms, MemoryAddress.NULL);
+        VH_vr_top.set(ms, MemoryAddress.NULL);
+        VH_gr_offs.set(ms, 0);
+        VH_vr_offs.set(ms, 0);
+        return ms.address();
     }
 
     public static CSupport.VaList empty() {
         return EMPTY;
     }
@@ -152,49 +151,49 @@
     private MemoryAddress grTop() {
         return grTop(segment);
     }
 
     private static MemoryAddress grTop(MemorySegment segment) {
-        return (MemoryAddress) VH_gr_top.get(segment.address());
+        return (MemoryAddress) VH_gr_top.get(segment);
     }
 
     private MemoryAddress vrTop() {
         return vrTop(segment);
     }
 
     private static MemoryAddress vrTop(MemorySegment segment) {
-        return (MemoryAddress) VH_vr_top.get(segment.address());
+        return (MemoryAddress) VH_vr_top.get(segment);
     }
 
     private int grOffs() {
-        final int offs = (int) VH_gr_offs.get(segment.address());
+        final int offs = (int) VH_gr_offs.get(segment);
         assert offs <= 0;
         return offs;
     }
 
     private int vrOffs() {
-        final int offs = (int) VH_vr_offs.get(segment.address());
+        final int offs = (int) VH_vr_offs.get(segment);
         assert offs <= 0;
         return offs;
     }
 
     private MemoryAddress stackPtr() {
-        return (MemoryAddress) VH_stack.get(segment.address());
+        return (MemoryAddress) VH_stack.get(segment);
     }
 
     private void stackPtr(MemoryAddress ptr) {
-        VH_stack.set(segment.address(), ptr);
+        VH_stack.set(segment, ptr);
     }
 
     private void consumeGPSlots(int num) {
-        final int old = (int) VH_gr_offs.get(segment.address());
-        VH_gr_offs.set(segment.address(), old + num * GP_SLOT_SIZE);
+        final int old = (int) VH_gr_offs.get(segment);
+        VH_gr_offs.set(segment, old + num * GP_SLOT_SIZE);
     }
 
     private void consumeFPSlots(int num) {
-        final int old = (int) VH_vr_offs.get(segment.address());
-        VH_vr_offs.set(segment.address(), old + num * FP_SLOT_SIZE);
+        final int old = (int) VH_vr_offs.get(segment);
+        VH_vr_offs.set(segment, old + num * FP_SLOT_SIZE);
     }
 
     private long currentGPOffset() {
         // Offset from start of GP register segment. __gr_top points to the top
         // (highest address) of the GP registers area. __gr_offs is the negative
@@ -275,11 +274,11 @@
                 case POINTER, INTEGER, FLOAT -> {
                     VarHandle reader = vhPrimitiveOrAddress(carrier, layout);
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
                              stackPtr(), layout.byteSize(),
                              segment.ownerThread(), null, null)) {
-                        Object res = reader.get(slice.address());
+                        Object res = reader.get(slice);
                         postAlignStack(layout);
                         yield res;
                     }
                 }
             };
@@ -317,11 +316,11 @@
                 case STRUCT_REFERENCE -> {
                     // Struct is passed indirectly via a pointer in an integer register.
                     VarHandle ptrReader
                         = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class, AArch64.C_POINTER);
                     MemoryAddress ptr = (MemoryAddress) ptrReader.get(
-                        gpRegsArea.address().addOffset(currentGPOffset()));
+                        gpRegsArea.asSlice(currentGPOffset()));
                     consumeGPSlots(1);
 
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
                              ptr, layout.byteSize(), segment.ownerThread(), null, null)) {
                         MemorySegment seg = allocator.allocate(layout);
@@ -329,17 +328,17 @@
                         yield seg;
                     }
                 }
                 case POINTER, INTEGER -> {
                     VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
-                    Object res = reader.get(gpRegsArea.address().addOffset(currentGPOffset()));
+                    Object res = reader.get(gpRegsArea.asSlice(currentGPOffset()));
                     consumeGPSlots(1);
                     yield res;
                 }
                 case FLOAT -> {
                     VarHandle reader = layout.varHandle(carrier);
-                    Object res = reader.get(fpRegsArea.address().addOffset(currentFPOffset()));
+                    Object res = reader.get(fpRegsArea.asSlice(currentFPOffset()));
                     consumeFPSlots(1);
                     yield res;
                 }
             };
         }
@@ -508,22 +507,22 @@
                         // Struct is passed indirectly via a pointer in an integer register.
                         MemorySegment valueSegment = (MemorySegment) value;
                         VarHandle writer
                             = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class,
                                                                AArch64.C_POINTER);
-                        writer.set(gpRegs.address().addOffset(currentGPOffset),
+                        writer.set(gpRegs.asSlice(currentGPOffset),
                                    valueSegment.address());
                         currentGPOffset += GP_SLOT_SIZE;
                     }
                     case POINTER, INTEGER -> {
                         VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
-                        writer.set(gpRegs.address().addOffset(currentGPOffset), value);
+                        writer.set(gpRegs.asSlice(currentGPOffset), value);
                         currentGPOffset += GP_SLOT_SIZE;
                     }
                     case FLOAT -> {
                         VarHandle writer = layout.varHandle(carrier);
-                        writer.set(fpRegs.address().addOffset(currentFPOffset), value);
+                        writer.set(fpRegs.asSlice(currentFPOffset), value);
                         currentFPOffset += FP_SLOT_SIZE;
                     }
                 }
             }
             return this;
@@ -543,28 +542,26 @@
             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
             if (!stackArgs.isEmpty()) {
                 long stackArgsSize = stackArgs.stream()
                     .reduce(0L, (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), 8), Long::sum);
                 MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
-                MemoryAddress maStackArea = stackArgsSegment.address();
+                stackArgsPtr = stackArgsSegment.address();
                 for (SimpleVaArg arg : stackArgs) {
                     final long alignedSize = Utils.alignUp(arg.layout.byteSize(), 8);
-                    maStackArea = Utils.alignUp(maStackArea, alignedSize);
+                    stackArgsSegment = Utils.alignUp(stackArgsSegment, alignedSize);
                     VarHandle writer = arg.varHandle();
-                    writer.set(maStackArea, arg.value);
-                    maStackArea = maStackArea.addOffset(alignedSize);
+                    writer.set(stackArgsSegment, arg.value);
+                    stackArgsSegment = stackArgsSegment.asSlice(alignedSize);
                 }
-                stackArgsPtr = stackArgsSegment.address();
                 attachedSegments.add(stackArgsSegment);
             }
 
-            MemoryAddress vaListAddr = vaListSegment.address();
-            VH_gr_top.set(vaListAddr, gpRegs.address().addOffset(gpRegs.byteSize()));
-            VH_vr_top.set(vaListAddr, fpRegs.address().addOffset(fpRegs.byteSize()));
-            VH_stack.set(vaListAddr, stackArgsPtr);
-            VH_gr_offs.set(vaListAddr, -MAX_GP_OFFSET);
-            VH_vr_offs.set(vaListAddr, -MAX_FP_OFFSET);
+            VH_gr_top.set(vaListSegment, gpRegs.asSlice(gpRegs.byteSize()).address());
+            VH_vr_top.set(vaListSegment, fpRegs.asSlice(fpRegs.byteSize()).address());
+            VH_stack.set(vaListSegment, stackArgsPtr);
+            VH_gr_offs.set(vaListSegment, -MAX_GP_OFFSET);
+            VH_vr_offs.set(vaListSegment, -MAX_FP_OFFSET);
 
             attachedSegments.add(gpRegs);
             attachedSegments.add(fpRegs);
             assert gpRegs.ownerThread() == vaListSegment.ownerThread();
             assert fpRegs.ownerThread() == vaListSegment.ownerThread();
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
@@ -135,55 +135,54 @@
         return new SysVVaList(segment, regSaveArea, List.of(regSaveArea));
     }
 
     private static MemoryAddress emptyListAddress() {
         long ptr = U.allocateMemory(LAYOUT.byteSize());
-        MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
+        MemorySegment base = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
                 MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null, () -> U.freeMemory(ptr), null);
-        cleaner.register(SysVVaList.class, ms::close);
-        MemoryAddress base = ms.address();
+        cleaner.register(SysVVaList.class, base::close);
         VH_gp_offset.set(base, MAX_GP_OFFSET);
         VH_fp_offset.set(base, MAX_FP_OFFSET);
         VH_overflow_arg_area.set(base, MemoryAddress.NULL);
         VH_reg_save_area.set(base, MemoryAddress.NULL);
-        return ms.withAccessModes(0).address();
+        return base.withAccessModes(0).address();
     }
 
     public static CSupport.VaList empty() {
         return EMPTY;
     }
 
     private int currentGPOffset() {
-        return (int) VH_gp_offset.get(segment.address());
+        return (int) VH_gp_offset.get(segment);
     }
 
     private void currentGPOffset(int i) {
-        VH_gp_offset.set(segment.address(), i);
+        VH_gp_offset.set(segment, i);
     }
 
     private int currentFPOffset() {
-        return (int) VH_fp_offset.get(segment.address());
+        return (int) VH_fp_offset.get(segment);
     }
 
     private void currentFPOffset(int i) {
-        VH_fp_offset.set(segment.address(), i);
+        VH_fp_offset.set(segment, i);
     }
 
     private MemoryAddress stackPtr() {
-        return (MemoryAddress) VH_overflow_arg_area.get(segment.address());
+        return (MemoryAddress) VH_overflow_arg_area.get(segment);
     }
 
     private void stackPtr(MemoryAddress ptr) {
-        VH_overflow_arg_area.set(segment.address(), ptr);
+        VH_overflow_arg_area.set(segment, ptr);
     }
 
     private MemorySegment regSaveArea() {
         return getRegSaveArea(segment);
     }
 
     private static MemorySegment getRegSaveArea(MemorySegment segment) {
-        return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment.address()),
+        return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment),
             LAYOUT_REG_SAVE_AREA.byteSize(), segment.ownerThread(), null, null);
     }
 
     private void preAlignStack(MemoryLayout layout) {
         if (layout.byteAlignment() > 8) {
@@ -247,11 +246,11 @@
                 }
                 case POINTER, INTEGER, FLOAT -> {
                     VarHandle reader = vhPrimitiveOrAddress(carrier, layout);
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),
                                                                                 segment.ownerThread(), null, null)) {
-                        Object res = reader.get(slice.address());
+                        Object res = reader.get(slice);
                         postAlignStack(layout);
                         yield res;
                     }
                 }
             };
@@ -276,17 +275,17 @@
                     }
                     yield value;
                 }
                 case POINTER, INTEGER -> {
                     VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
-                    Object res = reader.get(regSaveArea.address().addOffset(currentGPOffset()));
+                    Object res = reader.get(regSaveArea.asSlice(currentGPOffset()));
                     currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);
                     yield res;
                 }
                 case FLOAT -> {
                     VarHandle reader = layout.varHandle(carrier);
-                    Object res = reader.get(regSaveArea.address().addOffset(currentFPOffset()));
+                    Object res = reader.get(regSaveArea.asSlice(currentFPOffset()));
                     currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);
                     yield res;
                 }
             };
         }
@@ -427,16 +426,16 @@
                             offset += copy;
                         }
                     }
                     case POINTER, INTEGER -> {
                         VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
-                        writer.set(reg_save_area.address().addOffset(currentGPOffset), value);
+                        writer.set(reg_save_area.asSlice(currentGPOffset), value);
                         currentGPOffset += GP_SLOT_SIZE;
                     }
                     case FLOAT -> {
                         VarHandle writer = layout.varHandle(carrier);
-                        writer.set(reg_save_area.address().addOffset(currentFPOffset), value);
+                        writer.set(reg_save_area.asSlice(currentFPOffset), value);
                         currentFPOffset += FP_SLOT_SIZE;
                     }
                 }
             }
             return this;
@@ -455,33 +454,30 @@
             List<MemorySegment> attachedSegments = new ArrayList<>();
             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
             if (!stackArgs.isEmpty()) {
                 long stackArgsSize = stackArgs.stream().reduce(0L, (acc, e) -> acc + e.layout.byteSize(), Long::sum);
                 MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
-                MemoryAddress maOverflowArgArea = stackArgsSegment.address();
+                MemorySegment maOverflowArgArea = stackArgsSegment;
                 for (SimpleVaArg arg : stackArgs) {
                     if (arg.layout.byteSize() > 8) {
                         maOverflowArgArea = Utils.alignUp(maOverflowArgArea, Math.min(16, arg.layout.byteSize()));
                     }
                     if (arg.value instanceof MemorySegment) {
-                        MemorySegment slice
-                            = stackArgsSegment.asSlice(maOverflowArgArea.segmentOffset(), arg.layout.byteSize());
-                        slice.copyFrom((MemorySegment) arg.value);
+                        maOverflowArgArea.copyFrom((MemorySegment) arg.value);
                     } else {
                         VarHandle writer = arg.varHandle();
                         writer.set(maOverflowArgArea, arg.value);
                     }
-                    maOverflowArgArea = maOverflowArgArea.addOffset(arg.layout.byteSize());
+                    maOverflowArgArea = maOverflowArgArea.asSlice(arg.layout.byteSize());
                 }
                 stackArgsPtr = stackArgsSegment.address();
                 attachedSegments.add(stackArgsSegment);
             }
 
-            MemoryAddress vaListAddr = vaListSegment.address();
-            VH_fp_offset.set(vaListAddr, (int) FP_OFFSET);
-            VH_overflow_arg_area.set(vaListAddr, stackArgsPtr);
-            VH_reg_save_area.set(vaListAddr, reg_save_area.address());
+            VH_fp_offset.set(vaListSegment, (int) FP_OFFSET);
+            VH_overflow_arg_area.set(vaListSegment, stackArgsPtr);
+            VH_reg_save_area.set(vaListSegment, reg_save_area.address());
             attachedSegments.add(reg_save_area);
             assert reg_save_area.ownerThread() == vaListSegment.ownerThread();
             return new SysVVaList(vaListSegment, reg_save_area, attachedSegments);
         }
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
@@ -23,10 +23,11 @@
  *  questions.
  *
  */
 package jdk.internal.foreign.abi.x64.windows;
 
+import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.CSupport.VaList;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
@@ -61,16 +62,16 @@
     private static final long VA_SLOT_SIZE_BYTES = 8;
     private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));
 
     private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemoryAddress.NULL);
 
-    private MemoryAddress ptr;
+    private MemorySegment segment;
     private final List<MemorySegment> attachedSegments;
     private final MemorySegment livenessCheck;
 
-    private WinVaList(MemoryAddress ptr, List<MemorySegment> attachedSegments, MemorySegment livenessCheck) {
-        this.ptr = ptr;
+    private WinVaList(MemorySegment segment, List<MemorySegment> attachedSegments, MemorySegment livenessCheck) {
+        this.segment = segment;
         this.attachedSegments = attachedSegments;
         this.livenessCheck = livenessCheck;
     }
 
     public static final VaList empty() {
@@ -116,41 +117,41 @@
         Object res;
         if (carrier == MemorySegment.class) {
             TypeClass typeClass = TypeClass.typeClassFor(layout);
             res = switch (typeClass) {
                 case STRUCT_REFERENCE -> {
-                    MemoryAddress structAddr = (MemoryAddress) VH_address.get(ptr);
+                    MemoryAddress structAddr = (MemoryAddress) VH_address.get(segment);
                     try (MemorySegment struct = MemorySegment.ofNativeRestricted(structAddr, layout.byteSize(),
-                                                                            ptr.segment().ownerThread(), null, null)) {
-                        MemorySegment seg = allocator.allocate(layout);
+                                                                            segment.ownerThread(), null, null)) {
+                        MemorySegment seg = allocator.allocate(layout.byteSize());
                         seg.copyFrom(struct);
                         yield seg;
                     }
                 }
                 case STRUCT_REGISTER -> {
                     MemorySegment struct = allocator.allocate(layout);
-                    struct.copyFrom(ptr.segment().asSlice(ptr.segmentOffset(), layout.byteSize()));
+                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));
                     yield struct;
                 }
                 default -> throw new IllegalStateException("Unexpected TypeClass: " + typeClass);
             };
         } else {
             VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
-            res = reader.get(ptr);
+            res = reader.get(segment);
         }
-        ptr = ptr.addOffset(VA_SLOT_SIZE_BYTES);
+        segment = segment.asSlice(VA_SLOT_SIZE_BYTES);
         return res;
     }
 
     @Override
     public void skip(MemoryLayout... layouts) {
-        ptr = ptr.addOffset(layouts.length * VA_SLOT_SIZE_BYTES);
+        segment = segment.asSlice(layouts.length * VA_SLOT_SIZE_BYTES);
     }
 
     static WinVaList ofAddress(MemoryAddress addr) {
         MemorySegment segment = MemorySegment.ofNativeRestricted(addr, Long.MAX_VALUE, Thread.currentThread(), null, null);
-        return new WinVaList(segment.address(), List.of(segment), null);
+        return new WinVaList(segment, List.of(segment), null);
     }
 
     static Builder builder(SharedUtils.Allocator allocator) {
         return new Builder(allocator);
     }
@@ -163,32 +164,32 @@
     }
 
     @Override
     public VaList copy() {
         MemorySegment liveness = MemorySegment.ofNativeRestricted(
-                MemoryAddress.NULL, 1, ptr.segment().ownerThread(), null, null);
-        return new WinVaList(ptr, List.of(), liveness);
+                MemoryAddress.NULL, 1, segment.ownerThread(), null, null);
+        return new WinVaList(segment, List.of(), liveness);
     }
 
     @Override
     public VaList copy(NativeScope scope) {
         MemorySegment liveness = MemorySegment.ofNativeRestricted(
-                MemoryAddress.NULL, 1, ptr.segment().ownerThread(), null, null);
+                MemoryAddress.NULL, 1, segment.ownerThread(), null, null);
         liveness = scope.register(liveness);
-        return new WinVaList(ptr, List.of(), liveness);
+        return new WinVaList(segment, List.of(), liveness);
     }
 
     @Override
     public MemoryAddress address() {
-        return ptr;
+        return segment.address();
     }
 
     @Override
     public boolean isAlive() {
         if (livenessCheck != null)
             return livenessCheck.isAlive();
-        return ptr.segment().isAlive();
+        return segment.isAlive();
     }
 
     static class Builder implements VaList.Builder {
 
         private final SharedUtils.Allocator allocator;
@@ -231,37 +232,38 @@
 
         public VaList build() {
             if (args.isEmpty()) {
                 return EMPTY;
             }
-            MemorySegment ms = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size());
+            MemorySegment segment = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size());
             List<MemorySegment> attachedSegments = new ArrayList<>();
-            attachedSegments.add(ms);
-            MemoryAddress addr = ms.address();
+            attachedSegments.add(segment);
+            MemorySegment cursor = segment;
+
             for (SimpleVaArg arg : args) {
                 if (arg.carrier == MemorySegment.class) {
                     MemorySegment msArg = ((MemorySegment) arg.value);
                     TypeClass typeClass = TypeClass.typeClassFor(arg.layout);
                     switch (typeClass) {
                         case STRUCT_REFERENCE -> {
                             MemorySegment copy = allocator.allocate(arg.layout);
                             copy.copyFrom(msArg); // by-value
                             attachedSegments.add(copy);
-                            VH_address.set(addr, copy.address());
+                            VH_address.set(cursor, copy.address());
                         }
                         case STRUCT_REGISTER -> {
-                            MemorySegment slice = ms.asSlice(addr.segmentOffset(), VA_SLOT_SIZE_BYTES);
+                            MemorySegment slice = cursor.asSlice(0, VA_SLOT_SIZE_BYTES);
                             slice.copyFrom(msArg);
                         }
                         default -> throw new IllegalStateException("Unexpected TypeClass: " + typeClass);
                     }
                 } else {
                     VarHandle writer = arg.varHandle();
-                    writer.set(addr, arg.value);
+                    writer.set(cursor, arg.value);
                 }
-                addr = addr.addOffset(VA_SLOT_SIZE_BYTES);
+                cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);
             }
 
-            return new WinVaList(ms.address(), attachedSegments, null);
+            return new WinVaList(segment, attachedSegments, null);
         }
     }
 }
diff a/test/jdk/java/foreign/CallGeneratorHelper.java b/test/jdk/java/foreign/CallGeneratorHelper.java
--- a/test/jdk/java/foreign/CallGeneratorHelper.java
+++ b/test/jdk/java/foreign/CallGeneratorHelper.java
@@ -327,26 +327,20 @@
         System.out.println(res);
     }
 
     //helper methods
 
-    static void cleanup(Object arg) {
-        if (arg instanceof MemoryAddress) {
-            cleanup(((MemoryAddress)arg).segment());
-        } else if (arg instanceof MemorySegment) {
-            ((MemorySegment) arg).close();
-        }
-    }
-
     @SuppressWarnings("unchecked")
-    static Object makeArg(MemoryLayout layout, List<Consumer<Object>> checks, boolean check) throws ReflectiveOperationException {
+    static Object makeArg(MemoryLayout layout, List<Consumer<Object>> checks, boolean check, List<MemorySegment> segments) throws ReflectiveOperationException {
         if (layout instanceof GroupLayout) {
             MemorySegment segment = MemorySegment.allocateNative(layout);
-            initStruct(segment, (GroupLayout)layout, checks, check);
+            initStruct(segment, (GroupLayout)layout, checks, check, segments);
+            segments.add(segment);
             return segment;
         } else if (isPointer(layout)) {
             MemorySegment segment = MemorySegment.allocateNative(1);
+            segments.add(segment);
             if (check) {
                 checks.add(o -> {
                     try {
                         assertEquals((MemoryAddress)o, segment.address());
                     } catch (Throwable ex) {
@@ -375,31 +369,31 @@
         } else {
             throw new IllegalStateException("Unexpected layout: " + layout);
         }
     }
 
-    static void initStruct(MemorySegment str, GroupLayout g, List<Consumer<Object>> checks, boolean check) throws ReflectiveOperationException {
+    static void initStruct(MemorySegment str, GroupLayout g, List<Consumer<Object>> checks, boolean check, List<MemorySegment> segments) throws ReflectiveOperationException {
         for (MemoryLayout l : g.memberLayouts()) {
             if (l.isPadding()) continue;
             VarHandle accessor = g.varHandle(structFieldCarrier(l), MemoryLayout.PathElement.groupElement(l.name().get()));
             List<Consumer<Object>> fieldsCheck = new ArrayList<>();
-            Object value = makeArg(l, fieldsCheck, check);
+            Object value = makeArg(l, fieldsCheck, check, segments);
             if (isPointer(l)) {
                 value = ((MemoryAddress)value).toRawLongValue();
             }
             //set value
-            accessor.set(str.address(), value);
+            accessor.set(str, value);
             //add check
             if (check) {
                 assertTrue(fieldsCheck.size() == 1);
                 checks.add(o -> {
                     MemorySegment actual = (MemorySegment)o;
                     try {
                         if (isPointer(l)) {
-                            fieldsCheck.get(0).accept(MemoryAddress.ofLong((long)accessor.get(actual.address())));
+                            fieldsCheck.get(0).accept(MemoryAddress.ofLong((long)accessor.get(actual)));
                         } else {
-                            fieldsCheck.get(0).accept(accessor.get(actual.address()));
+                            fieldsCheck.get(0).accept(accessor.get(actual));
                         }
                     } catch (Throwable ex) {
                         throw new IllegalStateException(ex);
                     }
                 });
diff a/test/jdk/java/foreign/StdLibTest.java b/test/jdk/java/foreign/StdLibTest.java
--- a/test/jdk/java/foreign/StdLibTest.java
+++ b/test/jdk/java/foreign/StdLibTest.java
@@ -231,13 +231,13 @@
         String strcat(String s1, String s2) throws Throwable {
             try (MemorySegment buf = MemorySegment.allocateNative(s1.length() + s2.length() + 1) ;
                  MemorySegment other = toCString(s2)) {
                 char[] chars = s1.toCharArray();
                 for (long i = 0 ; i < chars.length ; i++) {
-                    setByteAtOffset(buf.address(), i, (byte)chars[(int)i]);
+                    setByteAtOffset(buf, i, (byte)chars[(int)i]);
                 }
-                setByteAtOffset(buf.address(), chars.length, (byte)'\0');
+                setByteAtOffset(buf, chars.length, (byte)'\0');
                 return toJavaStringRestricted(((MemoryAddress)strcat.invokeExact(buf.address(), other.address())));
             }
         }
 
         int strcmp(String s1, String s2) throws Throwable {
@@ -259,25 +259,25 @@
             }
         }
 
         Tm gmtime(long arg) throws Throwable {
             try (MemorySegment time = MemorySegment.allocateNative(8)) {
-                setLong(time.address(), arg);
+                setLong(time, arg);
                 return new Tm((MemoryAddress)gmtime.invokeExact(time.address()));
             }
         }
 
         static class Tm {
 
             //Tm pointer should never be freed directly, as it points to shared memory
-            private final MemoryAddress base;
+            private final MemorySegment base;
 
             static final long SIZE = 56;
 
-            Tm(MemoryAddress base) {
-                this.base = MemorySegment.ofNativeRestricted(base, SIZE, Thread.currentThread(),
-                        null, null).address();
+            Tm(MemoryAddress addr) {
+                this.base = MemorySegment.ofNativeRestricted(addr, SIZE, Thread.currentThread(),
+                        null, null);
             }
 
             int sec() {
                 return getIntAtOffset(base, 0);
             }
@@ -310,26 +310,26 @@
 
         int[] qsort(int[] arr) throws Throwable {
             //init native array
             try (NativeScope scope = NativeScope.unboundedScope()) {
 
-                MemorySegment nativeArr = scope.allocateArray(C_INT, arr).segment();
+                MemorySegment nativeArr = scope.allocateArray(C_INT, arr);
 
                 //call qsort
                 MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction);
-                scope.register(qsortUpcallStub);
+                qsortUpcallStub = scope.register(qsortUpcallStub);
 
                 qsort.invokeExact(nativeArr.address(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub.address());
 
                 //convert back to Java array
                 return nativeArr.toIntArray();
             }
         }
 
         static int qsortCompare(MemorySegment base, MemoryAddress addr1, MemoryAddress addr2) {
-            return getIntAtOffset(base.address(), addr1.rebase(base).segmentOffset()) -
-                   getIntAtOffset(base.address(), addr2.rebase(base).segmentOffset());
+            return getIntAtOffset(base, addr1.segmentOffset(base)) -
+                   getIntAtOffset(base, addr2.segmentOffset(base));
         }
 
         int rand() throws Throwable {
             return (int)rand.invokeExact();
         }
diff a/test/jdk/java/foreign/TestAdaptVarHandles.java b/test/jdk/java/foreign/TestAdaptVarHandles.java
--- a/test/jdk/java/foreign/TestAdaptVarHandles.java
+++ b/test/jdk/java/foreign/TestAdaptVarHandles.java
@@ -31,10 +31,11 @@
  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAdaptVarHandles
  */
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.ValueLayout;
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
@@ -68,11 +69,11 @@
                     MethodType.methodType(String.class, String.class, String.class, int.class));
             O2I = MethodHandles.explicitCastArguments(S2I, MethodType.methodType(int.class, Object.class));
             I2O = MethodHandles.explicitCastArguments(I2S, MethodType.methodType(Object.class, int.class));
             S2L = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "stringToLong", MethodType.methodType(long.class, String.class));
             S2L_EX = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "stringToLongException", MethodType.methodType(long.class, String.class));
-            BASE_ADDR = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "baseAddress", MethodType.methodType(MemoryAddress.class, MemorySegment.class));
+            BASE_ADDR = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "baseAddress", MethodType.methodType(MemorySegment.class, MemorySegment.class));
             SUM_OFFSETS = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "sumOffsets", MethodType.methodType(long.class, long.class, long.class));
             VOID_FILTER = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "void_filter", MethodType.methodType(void.class, String.class));
 
             MethodHandle s2i_ex = MethodHandles.throwException(int.class, Throwable.class);
             s2i_ex = MethodHandles.insertArguments(s2i_ex, 0, new Throwable());
@@ -84,26 +85,33 @@
         } catch (Throwable ex) {
             throw new ExceptionInInitializerError();
         }
     }
 
+    static final VarHandle intHandleIndexed = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)
+            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
+
+    static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+
+    static final VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);
+
     @Test
     public void testFilterValue() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, S2I, I2S);
-        i2SHandle.set(segment.address(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
+        i2SHandle.set(segment, "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment, "42");
         assertEquals(oldValue, "1");
-        String value = (String)i2SHandle.get(segment.address());
+        String value = (String)i2SHandle.get(segment);
         assertEquals(value, "43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment, "12", "42");
         assertEquals(oldValue, "12");
-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);
         assertEquals(value, "42");
     }
 
     @Test
     public void testFilterValueComposite() throws Throwable {
@@ -111,62 +119,59 @@
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         MethodHandle CTX_S2I = MethodHandles.dropArguments(S2I, 0, String.class, String.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, CTX_S2I, CTX_I2S);
         i2SHandle = MemoryHandles.insertCoordinates(i2SHandle, 1, "a", "b");
-        i2SHandle.set(segment.address(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
+        i2SHandle.set(segment, "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment, "42");
         assertEquals(oldValue, "ab1");
-        String value = (String)i2SHandle.get(segment.address());
+        String value = (String)i2SHandle.get(segment);
         assertEquals(value, "ab43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment, "12", "42");
         assertEquals(oldValue, "ab12");
-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);
         assertEquals(value, "ab42");
     }
 
     @Test
     public void testFilterValueLoose() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, O2I, I2O);
-        i2SHandle.set(segment.address(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
+        i2SHandle.set(segment, "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment, "42");
         assertEquals(oldValue, "1");
-        String value = (String)i2SHandle.get(segment.address());
+        String value = (String)i2SHandle.get(segment);
         assertEquals(value, "43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment, "12", "42");
         assertEquals(oldValue, "12");
-        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);
         assertEquals(value, "42");
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterNullTarget() {
         MemoryHandles.filterValue(null, S2I, I2S);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterNullUnbox() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterValue(intHandle, null, I2S);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterNullBox() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterValue(intHandle, S2I, null);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCarrier() {
-        VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);
         MemoryHandles.filterValue(floatHandle, S2I, I2S);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterUnboxArity() {
@@ -214,12 +219,11 @@
 
     @Test
     public void testFilterCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_longIndex = MemoryHandles.filterCoordinates(intHandle, 0, BASE_ADDR, S2L);
+        VarHandle intHandle_longIndex = MemoryHandles.filterCoordinates(intHandleIndexed, 0, BASE_ADDR, S2L);
         intHandle_longIndex.set(segment, "0", 1);
         int oldValue = (int)intHandle_longIndex.getAndAdd(segment, "0", 42);
         assertEquals(oldValue, 1);
         int value = (int)intHandle_longIndex.get(segment, "0");
         assertEquals(value, 43);
@@ -236,50 +240,43 @@
         MemoryHandles.filterCoordinates(null, 0, S2I);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterCoordinatesNullFilters() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterCoordinates(intHandle, 0, null);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCoordinatesNegativePos() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterCoordinates(intHandle, -1, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCoordinatesPosTooBig() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterCoordinates(intHandle, 1, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCoordinatesWrongFilterType() {
-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);
-        MemoryHandles.filterCoordinates(intHandle, 1, S2I);
+        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2I);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCoordinatesWrongFilterException() {
-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);
-        MemoryHandles.filterCoordinates(intHandle, 1, S2L_EX);
+        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2L_EX);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCoordinatesTooManyFilters() {
-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);
-        MemoryHandles.filterCoordinates(intHandle, 1, S2L, S2L);
+        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2L, S2L);
     }
 
     @Test
     public void testInsertCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandle, 0, segment.address(), 0L);
+        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandleIndexed, 0, segment, 0L);
         intHandle_longIndex.set(1);
         int oldValue = (int)intHandle_longIndex.getAndAdd(42);
         assertEquals(oldValue, 1);
         int value = (int)intHandle_longIndex.get();
         assertEquals(value, 43);
@@ -296,193 +293,170 @@
         MemoryHandles.insertCoordinates(null, 0, 42);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadInsertCoordinatesNullValues() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.insertCoordinates(intHandle, 0, null);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadInsertCoordinatesNegativePos() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.insertCoordinates(intHandle, -1, 42);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadInsertCoordinatesPosTooBig() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.insertCoordinates(intHandle, 1, 42);
     }
 
     @Test(expectedExceptions = ClassCastException.class)
     public void testBadInsertCoordinatesWrongCoordinateType() {
-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);
-        MemoryHandles.insertCoordinates(intHandle, 1, "Hello");
+        MemoryHandles.insertCoordinates(intHandleIndexed, 1, "Hello");
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadInsertCoordinatesTooManyValues() {
-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);
-        MemoryHandles.insertCoordinates(intHandle, 1, 0L, 0L);
+        MemoryHandles.insertCoordinates(intHandleIndexed, 1, 0L, 0L);
     }
 
     @Test
     public void testPermuteCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_swap = MemoryHandles.permuteCoordinates(intHandle,
-                List.of(long.class, MemoryAddress.class), 1, 0);
-        intHandle_swap.set(0L, segment.address(), 1);
-        int oldValue = (int)intHandle_swap.getAndAdd(0L, segment.address(), 42);
+        VarHandle intHandle_swap = MemoryHandles.permuteCoordinates(intHandleIndexed,
+                List.of(long.class, MemorySegment.class), 1, 0);
+        intHandle_swap.set(0L, segment, 1);
+        int oldValue = (int)intHandle_swap.getAndAdd(0L, segment, 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_swap.get(0L, segment.address());
+        int value = (int)intHandle_swap.get(0L, segment);
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_swap.compareAndSet(0L, segment.address(), 43, 12);
+        boolean swapped = (boolean)intHandle_swap.compareAndSet(0L, segment, 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_swap.compareAndExchange(0L, segment.address(), 12, 42);
+        oldValue = (int)intHandle_swap.compareAndExchange(0L, segment, 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_swap.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(0L, segment.address());
+        value = (int)intHandle_swap.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(0L, segment);
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadPermuteCoordinatesNullTarget() {
         MemoryHandles.permuteCoordinates(null, List.of());
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadPermuteCoordinatesNullCoordinates() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, null);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadPermuteCoordinatesNullReorder() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, List.of(int.class), null);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadPermuteCoordinatesTooManyCoordinates() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), new int[2]);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadPermuteCoordinatesTooFewCoordinates() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, List.of());
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadPermuteCoordinatesIndexTooBig() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), 3);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadPermuteCoordinatesIndexTooSmall() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), -1);
     }
 
     @Test
     public void testCollectCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_sum = MemoryHandles.collectCoordinates(intHandle, 1, SUM_OFFSETS);
-        intHandle_sum.set(segment.address(), -2L, 2L, 1);
-        int oldValue = (int)intHandle_sum.getAndAdd(segment.address(), -2L, 2L, 42);
+        VarHandle intHandle_sum = MemoryHandles.collectCoordinates(intHandleIndexed, 1, SUM_OFFSETS);
+        intHandle_sum.set(segment, -2L, 2L, 1);
+        int oldValue = (int)intHandle_sum.getAndAdd(segment, -2L, 2L, 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_sum.get(segment.address(), -2L, 2L);
+        int value = (int)intHandle_sum.get(segment, -2L, 2L);
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_sum.compareAndSet(segment.address(), -2L, 2L, 43, 12);
+        boolean swapped = (boolean)intHandle_sum.compareAndSet(segment, -2L, 2L, 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_sum.compareAndExchange(segment.address(), -2L, 2L, 12, 42);
+        oldValue = (int)intHandle_sum.compareAndExchange(segment, -2L, 2L, 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_sum.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address(), -2L, 2L);
+        value = (int)intHandle_sum.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, -2L, 2L);
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadCollectCoordinatesNullTarget() {
         MemoryHandles.collectCoordinates(null, 0, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadCollectCoordinatesNullFilters() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, 0, null);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadCollectCoordinatesNegativePos() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, -1, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadCollectCoordinatesPosTooBig() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, 1, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadCollectCoordinatesWrongFilterType() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, 0, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadCollectCoordinatesWrongVoidFilterType() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, 0, VOID_FILTER);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadCollectCoordinatesWrongFilterException() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, 0, S2L_EX);
     }
 
     @Test
     public void testDropCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_dummy = MemoryHandles.dropCoordinates(intHandle, 1, float.class, String.class);
-        intHandle_dummy.set(segment.address(), 1f, "hello", 0L, 1);
-        int oldValue = (int)intHandle_dummy.getAndAdd(segment.address(), 1f, "hello", 0L, 42);
+        VarHandle intHandle_dummy = MemoryHandles.dropCoordinates(intHandleIndexed, 1, float.class, String.class);
+        intHandle_dummy.set(segment, 1f, "hello", 0L, 1);
+        int oldValue = (int)intHandle_dummy.getAndAdd(segment, 1f, "hello", 0L, 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_dummy.get(segment.address(), 1f, "hello", 0L);
+        int value = (int)intHandle_dummy.get(segment, 1f, "hello", 0L);
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment.address(), 1f, "hello", 0L, 43, 12);
+        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment, 1f, "hello", 0L, 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_dummy.compareAndExchange(segment.address(), 1f, "hello", 0L, 12, 42);
+        oldValue = (int)intHandle_dummy.compareAndExchange(segment, 1f, "hello", 0L, 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address(), 1f, "hello", 0L);
+        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 1f, "hello", 0L);
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadDropCoordinatesNegativePos() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.dropCoordinates(intHandle, -1);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadDropCoordinatesPosTooBig() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.dropCoordinates(intHandle, 2);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadDropCoordinatesNullValueTypes() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.dropCoordinates(intHandle, 1, null);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadDropCoordinatesNullTarget() {
@@ -505,12 +479,12 @@
 
     static long stringToLongException(String s) throws Throwable {
         return Long.valueOf(s);
     }
 
-    static MemoryAddress baseAddress(MemorySegment segment) {
-        return segment.address();
+    static MemorySegment baseAddress(MemorySegment segment) {
+        return segment;
     }
 
     static long sumOffsets(long l1, long l2) {
         return l1 + l2;
     }
diff a/test/jdk/java/foreign/TestAddressHandle.java b/test/jdk/java/foreign/TestAddressHandle.java
--- a/test/jdk/java/foreign/TestAddressHandle.java
+++ b/test/jdk/java/foreign/TestAddressHandle.java
@@ -59,96 +59,89 @@
         }
     }
 
     @Test(dataProvider = "addressHandles")
     public void testAddressHandle(VarHandle addrHandle, int byteSize) {
-        VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
+        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
-            MemoryAddress target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?
-                    segment.address().addOffset(8 - byteSize) :
-                    segment.address();
-            longHandle.set(segment.address(), 42L);
+            MemorySegment target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?
+                    segment.asSlice(8 - byteSize) :
+                    segment;
+            longHandle.set(segment, 42L);
             MemoryAddress address = (MemoryAddress)addrHandle.get(target);
             assertEquals(address.toRawLongValue(), 42L);
-            try {
-                longHandle.get(address); // check that address cannot be de-referenced
-                fail();
-            } catch (UnsupportedOperationException ex) {
-                assertTrue(true);
-            }
             addrHandle.set(target, address.addOffset(1));
-            long result = (long)longHandle.get(segment.address());
+            long result = (long)longHandle.get(segment);
             assertEquals(43L, result);
         }
     }
 
     @Test(dataProvider = "addressHandles")
     public void testNull(VarHandle addrHandle, int byteSize) {
-        VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
+        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
-            longHandle.set(segment.address(), 0L);
-            MemoryAddress address = (MemoryAddress)addrHandle.get(segment.address());
+            longHandle.set(segment, 0L);
+            MemoryAddress address = (MemoryAddress)addrHandle.get(segment);
             assertTrue(address == MemoryAddress.NULL);
         }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadAdaptFloat() {
-        VarHandle floatHandle = MemoryHandles.varHandle(float.class, ByteOrder.nativeOrder());
+        VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);
         MemoryHandles.asAddressVarHandle(floatHandle);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadAdaptDouble() {
-        VarHandle doubleHandle = MemoryHandles.varHandle(double.class, ByteOrder.nativeOrder());
+        VarHandle doubleHandle = MemoryLayouts.JAVA_DOUBLE.varHandle(double.class);
         MemoryHandles.asAddressVarHandle(doubleHandle);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadAdaptBoolean() {
-        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         VarHandle boolHandle = MemoryHandles.filterValue(intHandle, BOOL_TO_INT, INT_TO_BOOL);
         MemoryHandles.asAddressVarHandle(boolHandle);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadAdaptString() {
-        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         VarHandle stringHandle = MemoryHandles.filterValue(intHandle, STRING_TO_INT, INT_TO_STRING);
         MemoryHandles.asAddressVarHandle(stringHandle);
     }
 
     @DataProvider(name = "addressHandles")
     static Object[][] addressHandles() {
         return new Object[][] {
                 // long
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder())), 8 },
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)), 8 },
+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)), 8 },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_LONG.varHandle(long.class)), 8 },
 
                 // int
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder())), 4 },
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)), 4 },
+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)), 4 },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_INT.varHandle(int.class)), 4 },
 
                 // short
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder())), 2 },
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)), 2 },
+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)), 2 },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_SHORT.varHandle(short.class)), 2 },
 
                 // char
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder())), 2 },
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)), 2 },
+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)), 2 },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_CHAR.varHandle(char.class)), 2 },
 
                 // byte
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder())), 1 },
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)), 1 },
+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)), 1 },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_BYTE.varHandle(byte.class)), 1 }
         };
     }
 
+    static VarHandle at(VarHandle handle, long offset) {
+        return MemoryHandles.insertCoordinates(handle, 1, offset);
+    }
+
     static int boolToInt(boolean value) {
         return value ? 1 : 0;
     }
 
     static boolean intToBool(int value) {
diff a/test/jdk/java/foreign/TestArrays.java b/test/jdk/java/foreign/TestArrays.java
--- a/test/jdk/java/foreign/TestArrays.java
+++ b/test/jdk/java/foreign/TestArrays.java
@@ -37,10 +37,11 @@
 import java.lang.invoke.VarHandle;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Function;
+import java.util.function.ToIntFunction;
 
 import org.testng.annotations.*;
 
 import static jdk.incubator.foreign.MemorySegment.READ;
 import static org.testng.Assert.*;
@@ -81,31 +82,31 @@
     static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());
     static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());
     static VarHandle longHandle = longs.varHandle(long.class, PathElement.sequenceElement());
     static VarHandle doubleHandle = doubles.varHandle(double.class, PathElement.sequenceElement());
 
-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {
+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {
         for (long i = 0; i < seq.elementCount().getAsLong() ; i++) {
             handleSetter.accept(base, i);
         }
     }
 
-    static void checkBytes(MemoryAddress base, SequenceLayout layout, Function<MemorySegment, Object> arrayFactory, BiFunction<MemoryAddress, Long, Object> handleGetter) {
+    static void checkBytes(MemorySegment base, SequenceLayout layout, Function<MemorySegment, Object> arrayFactory, BiFunction<MemorySegment, Long, Object> handleGetter) {
         int nelems = (int)layout.elementCount().getAsLong();
-        Object arr = arrayFactory.apply(base.segment());
+        Object arr = arrayFactory.apply(base);
         for (int i = 0; i < nelems; i++) {
             Object found = handleGetter.apply(base, (long) i);
             Object expected = java.lang.reflect.Array.get(arr, i);
             assertEquals(expected, found);
         }
     }
 
     @Test(dataProvider = "arrays")
-    public void testArrays(Consumer<MemoryAddress> init, Consumer<MemoryAddress> checker, MemoryLayout layout) {
+    public void testArrays(Consumer<MemorySegment> init, Consumer<MemorySegment> checker, MemoryLayout layout) {
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            init.accept(segment.address());
-            checker.accept(segment.address());
+            init.accept(segment);
+            checker.accept(segment);
         }
     }
 
     @Test(dataProvider = "elemLayouts",
           expectedExceptions = UnsupportedOperationException.class)
@@ -150,38 +151,38 @@
         }
     }
 
     @DataProvider(name = "arrays")
     public Object[][] nativeAccessOps() {
-        Consumer<MemoryAddress> byteInitializer =
+        Consumer<MemorySegment> byteInitializer =
                 (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));
-        Consumer<MemoryAddress> charInitializer =
+        Consumer<MemorySegment> charInitializer =
                 (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));
-        Consumer<MemoryAddress> shortInitializer =
+        Consumer<MemorySegment> shortInitializer =
                 (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));
-        Consumer<MemoryAddress> intInitializer =
+        Consumer<MemorySegment> intInitializer =
                 (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));
-        Consumer<MemoryAddress> floatInitializer =
+        Consumer<MemorySegment> floatInitializer =
                 (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));
-        Consumer<MemoryAddress> longInitializer =
+        Consumer<MemorySegment> longInitializer =
                 (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));
-        Consumer<MemoryAddress> doubleInitializer =
+        Consumer<MemorySegment> doubleInitializer =
                 (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));
 
-        Consumer<MemoryAddress> byteChecker =
+        Consumer<MemorySegment> byteChecker =
                 (base) -> checkBytes(base, bytes, MemorySegment::toByteArray, (addr, pos) -> (byte)byteHandle.get(addr, pos));
-        Consumer<MemoryAddress> shortChecker =
+        Consumer<MemorySegment> shortChecker =
                 (base) -> checkBytes(base, shorts, MemorySegment::toShortArray, (addr, pos) -> (short)shortHandle.get(addr, pos));
-        Consumer<MemoryAddress> charChecker =
+        Consumer<MemorySegment> charChecker =
                 (base) -> checkBytes(base, chars, MemorySegment::toCharArray, (addr, pos) -> (char)charHandle.get(addr, pos));
-        Consumer<MemoryAddress> intChecker =
+        Consumer<MemorySegment> intChecker =
                 (base) -> checkBytes(base, ints, MemorySegment::toIntArray, (addr, pos) -> (int)intHandle.get(addr, pos));
-        Consumer<MemoryAddress> floatChecker =
+        Consumer<MemorySegment> floatChecker =
                 (base) -> checkBytes(base, floats, MemorySegment::toFloatArray, (addr, pos) -> (float)floatHandle.get(addr, pos));
-        Consumer<MemoryAddress> longChecker =
+        Consumer<MemorySegment> longChecker =
                 (base) -> checkBytes(base, longs, MemorySegment::toLongArray, (addr, pos) -> (long)longHandle.get(addr, pos));
-        Consumer<MemoryAddress> doubleChecker =
+        Consumer<MemorySegment> doubleChecker =
                 (base) -> checkBytes(base, doubles, MemorySegment::toDoubleArray, (addr, pos) -> (double)doubleHandle.get(addr, pos));
 
         return new Object[][]{
                 {byteInitializer, byteChecker, bytes},
                 {charInitializer, charChecker, chars},
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -131,46 +131,46 @@
     );
 
     static VarHandle indexHandle = tuples.varHandle(int.class, PathElement.sequenceElement(), PathElement.groupElement("index"));
     static VarHandle valueHandle = tuples.varHandle(float.class, PathElement.sequenceElement(), PathElement.groupElement("value"));
 
-    static void initTuples(MemoryAddress base, long count) {
+    static void initTuples(MemorySegment base, long count) {
         for (long i = 0; i < count ; i++) {
             indexHandle.set(base, i, (int)i);
             valueHandle.set(base, i, (float)(i / 500f));
         }
     }
 
-    static void checkTuples(MemoryAddress base, ByteBuffer bb, long count) {
+    static void checkTuples(MemorySegment base, ByteBuffer bb, long count) {
         for (long i = 0; i < count ; i++) {
             int index;
             float value;
             assertEquals(index = bb.getInt(), (int)indexHandle.get(base, i));
             assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, i));
             assertEquals(value, index / 500f);
         }
     }
 
-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {
+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {
         for (long i = 0; i < seq.elementCount().getAsLong() ; i++) {
             handleSetter.accept(base, i);
         }
     }
 
-    static <Z extends Buffer> void checkBytes(MemoryAddress base, SequenceLayout layout,
+    static <Z extends Buffer> void checkBytes(MemorySegment base, SequenceLayout layout,
                                               Function<ByteBuffer, Z> bufFactory,
-                                              BiFunction<MemoryAddress, Long, Object> handleExtractor,
+                                              BiFunction<MemorySegment, Long, Object> handleExtractor,
                                               Function<Z, Object> bufferExtractor) {
         long nelems = layout.elementCount().getAsLong();
         long elemSize = layout.elementLayout().byteSize();
         for (long i = 0 ; i < nelems ; i++) {
             long limit = nelems - i;
-            MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);
+            MemorySegment resizedSegment = base.asSlice(i * elemSize, limit * elemSize);
             ByteBuffer bb = resizedSegment.asByteBuffer();
             Z z = bufFactory.apply(bb);
             for (long j = i ; j < limit ; j++) {
-                Object handleValue = handleExtractor.apply(resizedSegment.address(), j - i);
+                Object handleValue = handleExtractor.apply(resizedSegment, j - i);
                 Object bufferValue = bufferExtractor.apply(z);
                 if (handleValue instanceof Number) {
                     assertEquals(((Number)handleValue).longValue(), j);
                     assertEquals(((Number)bufferValue).longValue(), j);
                 } else {
@@ -182,27 +182,25 @@
     }
 
     @Test
     public void testOffheap() {
         try (MemorySegment segment = MemorySegment.allocateNative(tuples)) {
-            MemoryAddress base = segment.address();
-            initTuples(base, tuples.elementCount().getAsLong());
+            initTuples(segment, tuples.elementCount().getAsLong());
 
             ByteBuffer bb = segment.asByteBuffer();
-            checkTuples(base, bb, tuples.elementCount().getAsLong());
+            checkTuples(segment, bb, tuples.elementCount().getAsLong());
         }
     }
 
     @Test
     public void testHeap() {
         byte[] arr = new byte[(int) tuples.byteSize()];
         MemorySegment region = MemorySegment.ofArray(arr);
-        MemoryAddress base = region.address();
-        initTuples(base, tuples.elementCount().getAsLong());
+        initTuples(region, tuples.elementCount().getAsLong());
 
         ByteBuffer bb = region.asByteBuffer();
-        checkTuples(base, bb, tuples.elementCount().getAsLong());
+        checkTuples(region, bb, tuples.elementCount().getAsLong());
     }
 
     @Test
     public void testChannel() throws Throwable {
         File f = new File("test.out");
@@ -211,22 +209,20 @@
 
         //write to channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -> {
                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
-                MemoryAddress base = segment.address();
-                initTuples(base, tuples.elementCount().getAsLong());
+                initTuples(segment, tuples.elementCount().getAsLong());
                 mbb.force();
             });
         }
 
         //read from channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -> {
                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
-                MemoryAddress base = segment.address();
-                checkTuples(base, mbb, tuples.elementCount().getAsLong());
+                checkTuples(segment, mbb, tuples.elementCount().getAsLong());
             });
         }
     }
 
     @Test
@@ -248,19 +244,17 @@
         f.createNewFile();
         f.deleteOnExit();
 
         //write to channel
         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
-            MemoryAddress base = segment.address();
-            initTuples(base, tuples.elementCount().getAsLong());
+            initTuples(segment, tuples.elementCount().getAsLong());
             segment.force();
         }
 
         //read from channel
         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
-            MemoryAddress base = segment.address();
-            checkTuples(base, segment.asByteBuffer(), tuples.elementCount().getAsLong());
+            checkTuples(segment, segment.asByteBuffer(), tuples.elementCount().getAsLong());
         }
     }
 
     @Test
     public void testMappedSegmentOffset() throws Throwable {
@@ -272,22 +266,20 @@
 
         // write one at a time
         for (int i = 0 ; i < tuples.byteSize() ; i += tupleLayout.byteSize()) {
             //write to channel
             try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
-                MemoryAddress base = segment.address();
-                initTuples(base, 1);
+                initTuples(segment, 1);
                 segment.force();
             }
         }
 
         // check one at a time
         for (int i = 0 ; i < tuples.byteSize() ; i += tupleLayout.byteSize()) {
             //read from channel
             try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
-                MemoryAddress base = segment.address();
-                checkTuples(base, segment.asByteBuffer(), 1);
+                checkTuples(segment, segment.asByteBuffer(), 1);
             }
         }
     }
 
     static void withMappedBuffer(FileChannel channel, FileChannel.MapMode mode, long pos, long size, Consumer<MappedByteBuffer> action) throws Throwable {
@@ -311,11 +303,10 @@
 
     @Test(dataProvider = "bufferOps")
     public void testScopedBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {
         Buffer bb;
         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
-            MemoryAddress base = segment.address();
             bb = bufferFactory.apply(segment.asByteBuffer());
         }
         //outside of scope!!
         for (Map.Entry<Method, Object[]> e : members.entrySet()) {
             if (!e.getKey().getName().contains("get") &&
@@ -377,65 +368,61 @@
     }
 
     @Test(dataProvider = "bufferOps")
     public void testDirectBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {
         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
-            MemoryAddress base = segment.address();
             Buffer bb = bufferFactory.apply(segment.asByteBuffer());
             assertTrue(bb.isDirect());
             DirectBuffer directBuffer = ((DirectBuffer)bb);
-            assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
+            assertEquals(directBuffer.address(), segment.address().toRawLongValue());
             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
             assertTrue(directBuffer.cleaner() == null);
         }
     }
 
     @Test(dataProvider="resizeOps")
-    public void testResizeOffheap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testResizeOffheap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress base = segment.address();
-            initializer.accept(base);
-            checker.accept(base);
+            initializer.accept(segment);
+            checker.accept(segment);
         }
     }
 
     @Test(dataProvider="resizeOps")
-    public void testResizeHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testResizeHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
-        MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).address();
+        MemorySegment base = MemorySegment.ofArray(new byte[capacity]);
         initializer.accept(base);
         checker.accept(base);
     }
 
     @Test(dataProvider="resizeOps")
-    public void testResizeBuffer(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testResizeBuffer(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
-        MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).address();
+        MemorySegment base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity]));
         initializer.accept(base);
         checker.accept(base);
     }
 
     @Test(dataProvider="resizeOps")
-    public void testResizeRoundtripHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testResizeRoundtripHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
         byte[] arr = new byte[capacity];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress first = segment.address();
-        initializer.accept(first);
-        MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).address();
+        initializer.accept(segment);
+        MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());
         checker.accept(second);
     }
 
     @Test(dataProvider="resizeOps")
-    public void testResizeRoundtripNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testResizeRoundtripNative(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress first = segment.address();
-            initializer.accept(first);
-            MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).address();
+            initializer.accept(segment);
+            MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());
             checker.accept(second);
         }
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
@@ -480,30 +467,30 @@
             assertEquals(segment.byteSize(), 0);
         }
     }
 
     @Test(dataProvider="resizeOps")
-    public void testCopyHeapToNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testCopyHeapToNative(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
-            initializer.accept(heapArray.address());
+            initializer.accept(heapArray);
             nativeArray.copyFrom(heapArray);
-            checker.accept(nativeArray.address());
+            checker.accept(nativeArray);
         }
     }
 
     @Test(dataProvider="resizeOps")
-    public void testCopyNativeToHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testCopyNativeToHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
-            initializer.accept(nativeArray.address());
+            initializer.accept(nativeArray);
             heapArray.copyFrom(nativeArray);
-            checker.accept(heapArray.address());
+            checker.accept(heapArray);
         }
     }
 
     @Test
     public void testDefaultAccessModesOfBuffer() {
@@ -551,11 +538,11 @@
         MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);
         MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());
 
         s1.close(); // memory freed
 
-        MemoryAccess.setInt(s2.address(), 10); // Dead access!
+        MemoryAccess.setInt(s2, 10); // Dead access!
     }
 
     @DataProvider(name = "bufferOps")
     public static Object[][] bufferOps() throws Throwable {
         return new Object[][]{
@@ -611,38 +598,38 @@
         return members;
     }
 
     @DataProvider(name = "resizeOps")
     public Object[][] resizeOps() {
-        Consumer<MemoryAddress> byteInitializer =
+        Consumer<MemorySegment> byteInitializer =
                 (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtIndex_BE(addr, pos, (byte)(long)pos));
-        Consumer<MemoryAddress> charInitializer =
+        Consumer<MemorySegment> charInitializer =
                 (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex_BE(addr, pos, (char)(long)pos));
-        Consumer<MemoryAddress> shortInitializer =
+        Consumer<MemorySegment> shortInitializer =
                 (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex_BE(addr, pos, (short)(long)pos));
-        Consumer<MemoryAddress> intInitializer =
+        Consumer<MemorySegment> intInitializer =
                 (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex_BE(addr, pos, (int)(long)pos));
-        Consumer<MemoryAddress> floatInitializer =
+        Consumer<MemorySegment> floatInitializer =
                 (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex_BE(addr, pos, (float)(long)pos));
-        Consumer<MemoryAddress> longInitializer =
-                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex_BE(addr, pos, pos));
-        Consumer<MemoryAddress> doubleInitializer =
+        Consumer<MemorySegment> longInitializer =
+                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex_BE(addr, pos, (long)pos));
+        Consumer<MemorySegment> doubleInitializer =
                 (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex_BE(addr, pos, (double)(long)pos));
 
-        Consumer<MemoryAddress> byteChecker =
+        Consumer<MemorySegment> byteChecker =
                 (base) -> checkBytes(base, bytes, Function.identity(), MemoryAccess::getByteAtIndex_BE, ByteBuffer::get);
-        Consumer<MemoryAddress> charChecker =
+        Consumer<MemorySegment> charChecker =
                 (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, MemoryAccess::getCharAtIndex_BE, CharBuffer::get);
-        Consumer<MemoryAddress> shortChecker =
+        Consumer<MemorySegment> shortChecker =
                 (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, MemoryAccess::getShortAtIndex_BE, ShortBuffer::get);
-        Consumer<MemoryAddress> intChecker =
+        Consumer<MemorySegment> intChecker =
                 (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, MemoryAccess::getIntAtIndex_BE, IntBuffer::get);
-        Consumer<MemoryAddress> floatChecker =
+        Consumer<MemorySegment> floatChecker =
                 (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, MemoryAccess::getFloatAtIndex_BE, FloatBuffer::get);
-        Consumer<MemoryAddress> longChecker =
+        Consumer<MemorySegment> longChecker =
                 (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, MemoryAccess::getLongAtIndex_BE, LongBuffer::get);
-        Consumer<MemoryAddress> doubleChecker =
+        Consumer<MemorySegment> doubleChecker =
                 (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, MemoryAccess::getDoubleAtIndex_BE, DoubleBuffer::get);
 
         return new Object[][]{
                 {byteChecker, byteInitializer, bytes},
                 {charChecker, charInitializer, chars},
diff a/test/jdk/java/foreign/TestDowncall.java b/test/jdk/java/foreign/TestDowncall.java
--- a/test/jdk/java/foreign/TestDowncall.java
+++ b/test/jdk/java/foreign/TestDowncall.java
@@ -63,10 +63,11 @@
 import java.lang.invoke.MethodType;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Consumer;
 
+import jdk.incubator.foreign.MemorySegment;
 import org.testng.annotations.*;
 
 public class TestDowncall extends CallGeneratorHelper {
 
     static LibraryLookup lib = LibraryLookup.ofLibrary("TestDowncall");
@@ -74,21 +75,20 @@
 
 
     @Test(dataProvider="functions", dataProviderClass=CallGeneratorHelper.class)
     public void testDowncall(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {
         List<Consumer<Object>> checks = new ArrayList<>();
+        List<MemorySegment> segments = new ArrayList<>();
         LibraryLookup.Symbol addr = lib.lookup(fName);
         MethodHandle mh = abi.downcallHandle(addr, methodType(ret, paramTypes, fields), function(ret, paramTypes, fields));
-        Object[] args = makeArgs(paramTypes, fields, checks);
+        Object[] args = makeArgs(paramTypes, fields, checks, segments);
         mh = mh.asSpreader(Object[].class, paramTypes.size());
         Object res = mh.invoke(args);
         if (ret == Ret.NON_VOID) {
             checks.forEach(c -> c.accept(res));
         }
-        for (Object arg : args) {
-            cleanup(arg);
-        }
+        segments.forEach(MemorySegment::close);
     }
 
     static MethodType methodType(Ret ret, List<ParamType> params, List<StructFieldType> fields) {
         MethodType mt = ret == Ret.VOID ?
                 MethodType.methodType(void.class) : MethodType.methodType(paramCarrier(params.get(0).layout(fields)));
@@ -103,13 +103,13 @@
         return ret == Ret.VOID ?
                 FunctionDescriptor.ofVoid(paramLayouts) :
                 FunctionDescriptor.of(paramLayouts[0], paramLayouts);
     }
 
-    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {
+    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<MemorySegment> segments) throws ReflectiveOperationException {
         Object[] args = new Object[params.size()];
         for (int i = 0 ; i < params.size() ; i++) {
-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);
+            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0, segments);
         }
         return args;
     }
 }
diff a/test/jdk/java/foreign/TestLayouts.java b/test/jdk/java/foreign/TestLayouts.java
--- a/test/jdk/java/foreign/TestLayouts.java
+++ b/test/jdk/java/foreign/TestLayouts.java
@@ -62,18 +62,18 @@
         VarHandle array_elem_handle = layout.varHandle(double.class,
                 MemoryLayout.PathElement.groupElement("arr"),
                 MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(
                 layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement("arr")))) {
-            size_handle.set(segment.address(), 4);
+            size_handle.set(segment, 4);
             for (int i = 0 ; i < 4 ; i++) {
-                array_elem_handle.set(segment.address(), i, (double)i);
+                array_elem_handle.set(segment, i, (double)i);
             }
             //check
-            assertEquals(4, (int)size_handle.get(segment.address()));
+            assertEquals(4, (int)size_handle.get(segment));
             for (int i = 0 ; i < 4 ; i++) {
-                assertEquals((double)i, (double)array_elem_handle.get(segment.address(), i));
+                assertEquals((double)i, (double)array_elem_handle.get(segment, i));
             }
         }
     }
 
     @Test
@@ -88,18 +88,18 @@
                 MemoryLayout.PathElement.groupElement("arr"),
                 MemoryLayout.PathElement.sequenceElement(0),
                 MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(
                 layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement("arr"), MemoryLayout.PathElement.sequenceElement()))) {
-            size_handle.set(segment.address(), 4);
+            size_handle.set(segment, 4);
             for (int i = 0 ; i < 4 ; i++) {
-                array_elem_handle.set(segment.address(), i, (double)i);
+                array_elem_handle.set(segment, i, (double)i);
             }
             //check
-            assertEquals(4, (int)size_handle.get(segment.address()));
+            assertEquals(4, (int)size_handle.get(segment));
             for (int i = 0 ; i < 4 ; i++) {
-                assertEquals((double)i, (double)array_elem_handle.get(segment.address(), i));
+                assertEquals((double)i, (double)array_elem_handle.get(segment, i));
             }
         }
     }
 
     @Test
@@ -107,17 +107,17 @@
         MemoryLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
             VarHandle indexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
             // init segment
             for (int i = 0 ; i < 10 ; i++) {
-                indexHandle.set(segment.address(), (long)i, i);
+                indexHandle.set(segment, (long)i, i);
             }
             //check statically indexed handles
             for (int i = 0 ; i < 10 ; i++) {
                 VarHandle preindexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(i));
-                int expected = (int)indexHandle.get(segment.address(), (long)i);
-                int found = (int)preindexHandle.get(segment.address());
+                int expected = (int)indexHandle.get(segment, (long)i);
+                int found = (int)preindexHandle.get(segment);
                 assertEquals(expected, found);
             }
         }
     }
 
diff a/test/jdk/java/foreign/TestMemoryAccess.java b/test/jdk/java/foreign/TestMemoryAccess.java
--- a/test/jdk/java/foreign/TestMemoryAccess.java
+++ b/test/jdk/java/foreign/TestMemoryAccess.java
@@ -34,11 +34,11 @@
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
-import jdk.incubator.foreign.MemoryAddress;
+
 import java.lang.invoke.VarHandle;
 import java.util.function.Function;
 
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
@@ -80,49 +80,47 @@
         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout));
         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);
     }
 
     private void testAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
-        MemoryAddress outer_address;
+        MemorySegment outer_segment;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.address();
             try {
-                checker.check(handle, addr);
+                checker.check(handle, segment);
                 if (isRO) {
                     throw new AssertionError(); //not ok, memory should be immutable
                 }
             } catch (UnsupportedOperationException ex) {
                 if (!isRO) {
                     throw new AssertionError(); //we should not have failed!
                 }
                 return;
             }
             try {
-                checker.check(handle, addr.addOffset(layout.byteSize()));
+                checker.check(handle, segment.asSlice(layout.byteSize()));
                 throw new AssertionError(); //not ok, out of bounds
             } catch (IndexOutOfBoundsException ex) {
                 //ok, should fail (out of bounds)
             }
-            outer_address = addr; //leak!
+            outer_segment = segment; //leak!
         }
         try {
-            checker.check(handle, outer_address);
+            checker.check(handle, outer_segment);
             throw new AssertionError(); //not ok, scope is closed
         } catch (IllegalStateException ex) {
             //ok, should fail (scope is closed)
         }
     }
 
     private void testArrayAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
-        MemoryAddress outer_address;
+        MemorySegment outer_segment;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.address();
             try {
                 for (int i = 0; i < seq.elementCount().getAsLong(); i++) {
-                    checker.check(handle, addr, i);
+                    checker.check(handle, segment, i);
                 }
                 if (isRO) {
                     throw new AssertionError(); //not ok, memory should be immutable
                 }
             } catch (UnsupportedOperationException ex) {
@@ -130,19 +128,19 @@
                     throw new AssertionError(); //we should not have failed!
                 }
                 return;
             }
             try {
-                checker.check(handle, addr, seq.elementCount().getAsLong());
+                checker.check(handle, segment, seq.elementCount().getAsLong());
                 throw new AssertionError(); //not ok, out of bounds
             } catch (IndexOutOfBoundsException ex) {
                 //ok, should fail (out of bounds)
             }
-            outer_address = addr; //leak!
+            outer_segment = segment; //leak!
         }
         try {
-            checker.check(handle, outer_address, 0);
+            checker.check(handle, outer_segment, 0);
             throw new AssertionError(); //not ok, scope is closed
         } catch (IllegalStateException ex) {
             //ok, should fail (scope is closed)
         }
     }
@@ -181,18 +179,17 @@
         ValueLayout l = MemoryLayouts.BITS_32_LE.withName("elem");
         l.varHandle(carrier);
     }
 
     private void testMatrixAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
-        MemoryAddress outer_address;
+        MemorySegment outer_segment;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.address();
             try {
                 for (int i = 0; i < seq.elementCount().getAsLong(); i++) {
                     for (int j = 0; j < ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
-                        checker.check(handle, addr, i, j);
+                        checker.check(handle, segment, i, j);
                     }
                 }
                 if (isRO) {
                     throw new AssertionError(); //not ok, memory should be immutable
                 }
@@ -201,20 +198,20 @@
                     throw new AssertionError(); //we should not have failed!
                 }
                 return;
             }
             try {
-                checker.check(handle, addr, seq.elementCount().getAsLong(),
+                checker.check(handle, segment, seq.elementCount().getAsLong(),
                         ((SequenceLayout)seq.elementLayout()).elementCount().getAsLong());
                 throw new AssertionError(); //not ok, out of bounds
             } catch (IndexOutOfBoundsException ex) {
                 //ok, should fail (out of bounds)
             }
-            outer_address = addr; //leak!
+            outer_segment = segment; //leak!
         }
         try {
-            checker.check(handle, outer_address, 0, 0);
+            checker.check(handle, outer_segment, 0, 0);
             throw new AssertionError(); //not ok, scope is closed
         } catch (IllegalStateException ex) {
             //ok, should fail (scope is closed)
         }
     }
@@ -259,45 +256,45 @@
                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },
         };
     }
 
     interface Checker {
-        void check(VarHandle handle, MemoryAddress addr);
+        void check(VarHandle handle, MemorySegment segment);
 
-        Checker BYTE = (handle, addr) -> {
-            handle.set(addr, (byte)42);
-            assertEquals(42, (byte)handle.get(addr));
+        Checker BYTE = (handle, segment) -> {
+            handle.set(segment, (byte)42);
+            assertEquals(42, (byte)handle.get(segment));
         };
 
-        Checker SHORT = (handle, addr) -> {
-            handle.set(addr, (short)42);
-            assertEquals(42, (short)handle.get(addr));
+        Checker SHORT = (handle, segment) -> {
+            handle.set(segment, (short)42);
+            assertEquals(42, (short)handle.get(segment));
         };
 
-        Checker CHAR = (handle, addr) -> {
-            handle.set(addr, (char)42);
-            assertEquals(42, (char)handle.get(addr));
+        Checker CHAR = (handle, segment) -> {
+            handle.set(segment, (char)42);
+            assertEquals(42, (char)handle.get(segment));
         };
 
-        Checker INT = (handle, addr) -> {
-            handle.set(addr, 42);
-            assertEquals(42, (int)handle.get(addr));
+        Checker INT = (handle, segment) -> {
+            handle.set(segment, 42);
+            assertEquals(42, (int)handle.get(segment));
         };
 
-        Checker LONG = (handle, addr) -> {
-            handle.set(addr, (long)42);
-            assertEquals(42, (long)handle.get(addr));
+        Checker LONG = (handle, segment) -> {
+            handle.set(segment, (long)42);
+            assertEquals(42, (long)handle.get(segment));
         };
 
-        Checker FLOAT = (handle, addr) -> {
-            handle.set(addr, (float)42);
-            assertEquals((float)42, (float)handle.get(addr));
+        Checker FLOAT = (handle, segment) -> {
+            handle.set(segment, (float)42);
+            assertEquals((float)42, (float)handle.get(segment));
         };
 
-        Checker DOUBLE = (handle, addr) -> {
-            handle.set(addr, (double)42);
-            assertEquals((double)42, (double)handle.get(addr));
+        Checker DOUBLE = (handle, segment) -> {
+            handle.set(segment, (double)42);
+            assertEquals((double)42, (double)handle.get(segment));
         };
     }
 
     @DataProvider(name = "arrayElements")
     public Object[][] createArrayData() {
@@ -336,45 +333,45 @@
                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },
         };
     }
 
     interface ArrayChecker {
-        void check(VarHandle handle, MemoryAddress addr, long index);
+        void check(VarHandle handle, MemorySegment segment, long index);
 
-        ArrayChecker BYTE = (handle, addr, i) -> {
-            handle.set(addr, i, (byte)i);
-            assertEquals(i, (byte)handle.get(addr, i));
+        ArrayChecker BYTE = (handle, segment, i) -> {
+            handle.set(segment, i, (byte)i);
+            assertEquals(i, (byte)handle.get(segment, i));
         };
 
-        ArrayChecker SHORT = (handle, addr, i) -> {
-            handle.set(addr, i, (short)i);
-            assertEquals(i, (short)handle.get(addr, i));
+        ArrayChecker SHORT = (handle, segment, i) -> {
+            handle.set(segment, i, (short)i);
+            assertEquals(i, (short)handle.get(segment, i));
         };
 
-        ArrayChecker CHAR = (handle, addr, i) -> {
-            handle.set(addr, i, (char)i);
-            assertEquals(i, (char)handle.get(addr, i));
+        ArrayChecker CHAR = (handle, segment, i) -> {
+            handle.set(segment, i, (char)i);
+            assertEquals(i, (char)handle.get(segment, i));
         };
 
-        ArrayChecker INT = (handle, addr, i) -> {
-            handle.set(addr, i, (int)i);
-            assertEquals(i, (int)handle.get(addr, i));
+        ArrayChecker INT = (handle, segment, i) -> {
+            handle.set(segment, i, (int)i);
+            assertEquals(i, (int)handle.get(segment, i));
         };
 
-        ArrayChecker LONG = (handle, addr, i) -> {
-            handle.set(addr, i, (long)i);
-            assertEquals(i, (long)handle.get(addr, i));
+        ArrayChecker LONG = (handle, segment, i) -> {
+            handle.set(segment, i, (long)i);
+            assertEquals(i, (long)handle.get(segment, i));
         };
 
-        ArrayChecker FLOAT = (handle, addr, i) -> {
-            handle.set(addr, i, (float)i);
-            assertEquals((float)i, (float)handle.get(addr, i));
+        ArrayChecker FLOAT = (handle, segment, i) -> {
+            handle.set(segment, i, (float)i);
+            assertEquals((float)i, (float)handle.get(segment, i));
         };
 
-        ArrayChecker DOUBLE = (handle, addr, i) -> {
-            handle.set(addr, i, (double)i);
-            assertEquals((double)i, (double)handle.get(addr, i));
+        ArrayChecker DOUBLE = (handle, segment, i) -> {
+            handle.set(segment, i, (double)i);
+            assertEquals((double)i, (double)handle.get(segment, i));
         };
     }
 
     @DataProvider(name = "matrixElements")
     public Object[][] createMatrixData() {
@@ -413,45 +410,45 @@
                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },
         };
     }
 
     interface MatrixChecker {
-        void check(VarHandle handle, MemoryAddress addr, long row, long col);
+        void check(VarHandle handle, MemorySegment segment, long row, long col);
 
-        MatrixChecker BYTE = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (byte)(r + c));
-            assertEquals(r + c, (byte)handle.get(addr, r, c));
+        MatrixChecker BYTE = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (byte)(r + c));
+            assertEquals(r + c, (byte)handle.get(segment, r, c));
         };
 
-        MatrixChecker SHORT = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (short)(r + c));
-            assertEquals(r + c, (short)handle.get(addr, r, c));
+        MatrixChecker SHORT = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (short)(r + c));
+            assertEquals(r + c, (short)handle.get(segment, r, c));
         };
 
-        MatrixChecker CHAR = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (char)(r + c));
-            assertEquals(r + c, (char)handle.get(addr, r, c));
+        MatrixChecker CHAR = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (char)(r + c));
+            assertEquals(r + c, (char)handle.get(segment, r, c));
         };
 
-        MatrixChecker INT = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (int)(r + c));
-            assertEquals(r + c, (int)handle.get(addr, r, c));
+        MatrixChecker INT = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (int)(r + c));
+            assertEquals(r + c, (int)handle.get(segment, r, c));
         };
 
-        MatrixChecker LONG = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, r + c);
-            assertEquals(r + c, (long)handle.get(addr, r, c));
+        MatrixChecker LONG = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, r + c);
+            assertEquals(r + c, (long)handle.get(segment, r, c));
         };
 
-        MatrixChecker FLOAT = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (float)(r + c));
-            assertEquals((float)(r + c), (float)handle.get(addr, r, c));
+        MatrixChecker FLOAT = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (float)(r + c));
+            assertEquals((float)(r + c), (float)handle.get(segment, r, c));
         };
 
-        MatrixChecker DOUBLE = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (double)(r + c));
-            assertEquals((double)(r + c), (double)handle.get(addr, r, c));
+        MatrixChecker DOUBLE = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (double)(r + c));
+            assertEquals((double)(r + c), (double)handle.get(segment, r, c));
         };
     }
 
     @DataProvider(name = "badCarriers")
     public Object[][] createBadCarriers() {
diff a/test/jdk/java/foreign/TestMemoryAlignment.java b/test/jdk/java/foreign/TestMemoryAlignment.java
--- a/test/jdk/java/foreign/TestMemoryAlignment.java
+++ b/test/jdk/java/foreign/TestMemoryAlignment.java
@@ -29,11 +29,10 @@
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
 import java.lang.invoke.VarHandle;
 import java.util.stream.LongStream;
@@ -49,13 +48,12 @@
         assertEquals(layout.bitAlignment(), 32);
         ValueLayout aligned = layout.withBitAlignment(align);
         assertEquals(aligned.bitAlignment(), align); //unreasonable alignment here, to make sure access throws
         VarHandle vh = aligned.varHandle(int.class);
         try (MemorySegment segment = MemorySegment.allocateNative(aligned)) {
-            MemoryAddress addr = segment.address();
-            vh.set(addr, -42);
-            int val = (int)vh.get(addr);
+            vh.set(segment, -42);
+            int val = (int)vh.get(segment);
             assertEquals(val, -42);
         }
     }
 
     @Test(dataProvider = "alignments")
@@ -65,12 +63,11 @@
         ValueLayout aligned = layout.withBitAlignment(align);
         MemoryLayout alignedGroup = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, aligned);
         assertEquals(alignedGroup.bitAlignment(), align);
         VarHandle vh = aligned.varHandle(int.class);
         try (MemorySegment segment = MemorySegment.allocateNative(alignedGroup)) {
-            MemoryAddress addr = segment.address();
-            vh.set(addr.addOffset(1L), -42);
+            vh.set(segment.asSlice(1L), -42);
             assertEquals(align, 8); //this is the only case where access is aligned
         } catch (IllegalStateException ex) {
             assertNotEquals(align, 8); //if align != 8, access is always unaligned
         }
     }
@@ -92,13 +89,12 @@
     public void testUnalignedSequence(long align) {
         SequenceLayout layout = MemoryLayout.ofSequence(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));
         try {
             VarHandle vh = layout.varHandle(int.class, PathElement.sequenceElement());
             try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-                MemoryAddress addr = segment.address();
                 for (long i = 0 ; i < 5 ; i++) {
-                    vh.set(addr, i, -42);
+                    vh.set(segment, i, -42);
                 }
             }
         } catch (UnsupportedOperationException ex) {
             assertTrue(align > 32); //if align > 32, access is always unaligned (for some elements)
         }
@@ -116,17 +112,16 @@
         assertEquals(g.bitAlignment(), 8);
         VarHandle vh_c = g.varHandle(byte.class, PathElement.groupElement("a"));
         VarHandle vh_s = g.varHandle(short.class, PathElement.groupElement("b"));
         VarHandle vh_i = g.varHandle(int.class, PathElement.groupElement("c"));
         try (MemorySegment segment = MemorySegment.allocateNative(g)) {
-            MemoryAddress addr = segment.address();
-            vh_c.set(addr, Byte.MIN_VALUE);
-            assertEquals(vh_c.get(addr), Byte.MIN_VALUE);
-            vh_s.set(addr, Short.MIN_VALUE);
-            assertEquals(vh_s.get(addr), Short.MIN_VALUE);
-            vh_i.set(addr, Integer.MIN_VALUE);
-            assertEquals(vh_i.get(addr), Integer.MIN_VALUE);
+            vh_c.set(segment, Byte.MIN_VALUE);
+            assertEquals(vh_c.get(segment), Byte.MIN_VALUE);
+            vh_s.set(segment, Short.MIN_VALUE);
+            assertEquals(vh_s.get(segment), Short.MIN_VALUE);
+            vh_i.set(segment, Integer.MIN_VALUE);
+            assertEquals(vh_i.get(segment), Integer.MIN_VALUE);
         }
     }
 
     @DataProvider(name = "alignments")
     public Object[][] createAlignments() {
diff a/test/jdk/java/foreign/TestMemoryCopy.java b/test/jdk/java/foreign/TestMemoryCopy.java
--- a/test/jdk/java/foreign/TestMemoryCopy.java
+++ b/test/jdk/java/foreign/TestMemoryCopy.java
@@ -25,11 +25,10 @@
 /*
  * @test
  * @run testng TestMemoryCopy
  */
 
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
@@ -44,25 +43,23 @@
 
     final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
 
     @Test(dataProvider = "slices")
     public void testCopy(SegmentSlice s1, SegmentSlice s2) {
-        MemoryAddress addr1 = s1.segment.address();
-        MemoryAddress addr2 = s2.segment.address();
         int size = Math.min(s1.size(), s2.size());
         //prepare source and target segments
         for (int i = 0 ; i < size ; i++) {
-            BYTE_HANDLE.set(addr2.addOffset(i), (byte)0);
+            BYTE_HANDLE.set(s2.segment.asSlice(i), (byte)0);
         }
         for (int i = 0 ; i < size ; i++) {
-            BYTE_HANDLE.set(addr1.addOffset(i), (byte) i);
+            BYTE_HANDLE.set(s1.segment.asSlice(i), (byte) i);
         }
         //perform copy
         s2.segment.copyFrom(s1.segment.asSlice(0, size));
         //check that copy actually worked
         for (int i = 0 ; i < size ; i++) {
-            assertEquals((byte)i, BYTE_HANDLE.get(addr2.addOffset(i)));
+            assertEquals((byte)i, BYTE_HANDLE.get(s2.segment.asSlice(i)));
         }
     }
 
     static class SegmentSlice {
 
diff a/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java b/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
--- a/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
+++ b/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
@@ -57,14 +57,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_8_BE;
         VarHandle byteHandle = layout.varHandle(byte.class);
         VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.address(), intValue);
+            intHandle.set(segment, intValue);
             int expectedIntValue = Byte.toUnsignedInt(byteValue);
-            assertEquals((int) intHandle.get(segment.address()), expectedIntValue);
-            assertEquals((byte) byteHandle.get(segment.address()), byteValue);
+            assertEquals((int) intHandle.get(segment), expectedIntValue);
+            assertEquals((byte) byteHandle.get(segment), byteValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToByteData")
     public Object[][] unsignedLongToByteData() {
@@ -79,14 +79,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_8_BE;
         VarHandle byteHandle = layout.varHandle(byte.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(byteHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.address(), longValue);
+            longHandle.set(segment, longValue);
             long expectedLongValue = Byte.toUnsignedLong(byteValue);
-            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
-            assertEquals((byte) byteHandle.get(segment.address()), byteValue);
+            assertEquals((long) longHandle.get(segment), expectedLongValue);
+            assertEquals((byte) byteHandle.get(segment), byteValue);
         }
     }
 
     @DataProvider(name = "unsignedIntToShortData")
     public Object[][] unsignedIntToShortData() {
@@ -101,14 +101,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_16_BE;
         VarHandle shortHandle = layout.varHandle(short.class);
         VarHandle intHandle = MemoryHandles.asUnsigned(shortHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.address(), intValue);
+            intHandle.set(segment, intValue);
             int expectedIntValue = Short.toUnsignedInt(shortValue);
-            assertEquals((int) intHandle.get(segment.address()), expectedIntValue);
-            assertEquals((short) shortHandle.get(segment.address()), shortValue);
+            assertEquals((int) intHandle.get(segment), expectedIntValue);
+            assertEquals((short) shortHandle.get(segment), shortValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToShortData")
     public Object[][] unsignedLongToShortData() {
@@ -123,14 +123,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_16_BE;
         VarHandle shortHandle = layout.varHandle(short.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(shortHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.address(), longValue);
+            longHandle.set(segment, longValue);
             long expectedLongValue = Short.toUnsignedLong(shortValue);
-            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
-            assertEquals((short) shortHandle.get(segment.address()), shortValue);
+            assertEquals((long) longHandle.get(segment), expectedLongValue);
+            assertEquals((short) shortHandle.get(segment), shortValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToIntData")
     public Object[][] unsignedLongToIntData() {
@@ -149,48 +149,47 @@
         MemoryLayout layout = MemoryLayouts.BITS_32_BE;
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(intHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.address(), longValue);
+            longHandle.set(segment, longValue);
             long expectedLongValue = Integer.toUnsignedLong(intValue);
-            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
-            assertEquals((int) intHandle.get(segment.address()), intValue);
+            assertEquals((long) longHandle.get(segment), expectedLongValue);
+            assertEquals((int) intHandle.get(segment), intValue);
         }
     }
 
     @Test
     public void testCoordinatesSequenceLayout() {
         MemoryLayout layout = MemoryLayout.ofSequence(2, MemoryLayouts.BITS_8_BE);
         VarHandle byteHandle = layout.varHandle(byte.class, PathElement.sequenceElement());
         VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.address(), 0L, (int) -1);
-            assertEquals((int) intHandle.get(segment.address(), 0L), 255);
-            intHandle.set(segment.address(), 1L, (int) 200);
-            assertEquals((int) intHandle.get(segment.address(), 1L), 200);
+            intHandle.set(segment, 0L, (int) -1);
+            assertEquals((int) intHandle.get(segment, 0L), 255);
+            intHandle.set(segment, 1L, (int) 200);
+            assertEquals((int) intHandle.get(segment, 1L), 200);
         }
     }
 
     @Test
     public void testCoordinatesStride() {
         byte[] arr = { 0, 0, (byte) 129, 0 };
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress addr = segment.address();
 
         {
-            VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
+            VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+                    .varHandle(byte.class, PathElement.sequenceElement());
             VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
-            VarHandle strideHandle = MemoryHandles.withStride(intHandle, 1);
-            assertEquals((int) strideHandle.get(addr, 2L), 129);
+            assertEquals((int) intHandle.get(segment, 2L), 129);
         }
         {
-            VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-            VarHandle strideHandle = MemoryHandles.withStride(byteHandle, 1);
-            VarHandle intHandle = MemoryHandles.asUnsigned(strideHandle, int.class);
-            assertEquals((int) intHandle.get(addr, 2L), 129);
+            VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+                    .varHandle(byte.class, PathElement.sequenceElement());
+            VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
+            assertEquals((int) intHandle.get(segment, 2L), 129);
         }
     }
 
     static final Class<NullPointerException> NPE = NullPointerException.class;
 
diff a/test/jdk/java/foreign/TestMismatch.java b/test/jdk/java/foreign/TestMismatch.java
--- a/test/jdk/java/foreign/TestMismatch.java
+++ b/test/jdk/java/foreign/TestMismatch.java
@@ -45,13 +45,12 @@
 
     final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
 
     // stores a increasing sequence of values into the memory of the given segment
     static MemorySegment initializeSegment(MemorySegment segment) {
-        MemoryAddress addr = segment.address();
         for (int i = 0 ; i < segment.byteSize() ; i++) {
-            BYTE_HANDLE.set(addr.addOffset(i), (byte)i);
+            BYTE_HANDLE.set(segment.asSlice(i), (byte)i);
         }
         return segment;
     }
 
     @Test(dataProvider = "slices")
@@ -79,11 +78,11 @@
         s1 = initializeSegment(s1);
         s2 = initializeSegment(s2);
 
         for (long i = s2.byteSize() -1 ; i >= 0; i--) {
             long expectedMismatchOffset = i;
-            BYTE_HANDLE.set(s2.address().addOffset(i), (byte) 0xFF);
+            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);
 
             if (s1.byteSize() == s2.byteSize()) {
                 assertEquals(s1.mismatch(s2), expectedMismatchOffset);
                 assertEquals(s2.mismatch(s1), expectedMismatchOffset);
             } else if (s1.byteSize() > s2.byteSize()) {
@@ -133,11 +132,11 @@
         }
     }
 
     private void testLargeMismatchAcrossMaxBoundary(MemorySegment s1, MemorySegment s2) {
         for (long i = s2.byteSize() -1 ; i >= Integer.MAX_VALUE - 10L; i--) {
-            BYTE_HANDLE.set(s2.address().addOffset(i), (byte) 0xFF);
+            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);
             long expectedMismatchOffset = i;
             assertEquals(s1.mismatch(s2), expectedMismatchOffset);
             assertEquals(s2.mismatch(s1), expectedMismatchOffset);
         }
     }
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -91,28 +91,28 @@
     static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());
     static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());
     static VarHandle longHandle = doubles.varHandle(long.class, PathElement.sequenceElement());
     static VarHandle doubleHandle = longs.varHandle(double.class, PathElement.sequenceElement());
 
-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {
+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {
         for (long i = 0; i < seq.elementCount().getAsLong() ; i++) {
             handleSetter.accept(base, i);
         }
     }
 
-    static <Z extends Buffer> void checkBytes(MemoryAddress base, SequenceLayout layout,
-                                              BiFunction<MemoryAddress, Long, Object> handleExtractor,
+    static <Z extends Buffer> void checkBytes(MemorySegment base, SequenceLayout layout,
+                                              BiFunction<MemorySegment, Long, Object> handleExtractor,
                                               Function<ByteBuffer, Z> bufferFactory,
                                               BiFunction<Z, Integer, Object> nativeBufferExtractor,
                                               BiFunction<Long, Integer, Object> nativeRawExtractor) {
         long nelems = layout.elementCount().getAsLong();
-        ByteBuffer bb = base.segment().asSlice(base.segmentOffset(), (int)layout.byteSize()).asByteBuffer();
+        ByteBuffer bb = base.asByteBuffer();
         Z z = bufferFactory.apply(bb);
         for (long i = 0 ; i < nelems ; i++) {
             Object handleValue = handleExtractor.apply(base, i);
             Object bufferValue = nativeBufferExtractor.apply(z, (int)i);
-            Object rawValue = nativeRawExtractor.apply(base.toRawLongValue(), (int)i);
+            Object rawValue = nativeRawExtractor.apply(base.address().toRawLongValue(), (int)i);
             if (handleValue instanceof Number) {
                 assertEquals(((Number)handleValue).longValue(), i);
                 assertEquals(((Number)bufferValue).longValue(), i);
                 assertEquals(((Number)rawValue).longValue(), i);
             } else {
@@ -143,15 +143,14 @@
 
     public static native long allocate(int size);
     public static native void free(long address);
 
     @Test(dataProvider="nativeAccessOps")
-    public void testNativeAccess(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testNativeAccess(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress address = segment.address();
-            initializer.accept(address);
-            checker.accept(address);
+            initializer.accept(segment);
+            checker.accept(segment);
         }
     }
 
     @Test(dataProvider="buffers")
     public void testNativeCapacity(Function<ByteBuffer, Buffer> bufferFunction, int elemSize) {
@@ -184,26 +183,23 @@
     }
 
     @Test
     public void testMallocSegment() {
         MemoryAddress addr = MemoryAddress.ofLong(allocate(12));
-        assertNull(addr.segment());
         MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,
                 () -> free(addr.toRawLongValue()), null);
         assertEquals(mallocSegment.byteSize(), 12);
         mallocSegment.close(); //free here
         assertTrue(!mallocSegment.isAlive());
     }
 
     @Test
     public void testEverythingSegment() {
         MemoryAddress addr = MemoryAddress.ofLong(allocate(4));
-        assertNull(addr.segment());
         MemorySegment everything = MemorySegment.ofNativeRestricted();
-        MemoryAddress ptr = addr.rebase(everything);
-        MemoryAccess.setInt(ptr, 42);
-        assertEquals(MemoryAccess.getInt(ptr), 42);
+        MemoryAccess.setIntAtOffset(everything, addr.toRawLongValue(), 42);
+        assertEquals(MemoryAccess.getIntAtOffset(everything, addr.toRawLongValue()), 42);
         free(addr.toRawLongValue());
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadResize() {
@@ -221,38 +217,38 @@
         System.loadLibrary("NativeAccess");
     }
 
     @DataProvider(name = "nativeAccessOps")
     public Object[][] nativeAccessOps() {
-        Consumer<MemoryAddress> byteInitializer =
+        Consumer<MemorySegment> byteInitializer =
                 (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));
-        Consumer<MemoryAddress> charInitializer =
+        Consumer<MemorySegment> charInitializer =
                 (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));
-        Consumer<MemoryAddress> shortInitializer =
+        Consumer<MemorySegment> shortInitializer =
                 (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));
-        Consumer<MemoryAddress> intInitializer =
+        Consumer<MemorySegment> intInitializer =
                 (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));
-        Consumer<MemoryAddress> floatInitializer =
+        Consumer<MemorySegment> floatInitializer =
                 (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));
-        Consumer<MemoryAddress> longInitializer =
+        Consumer<MemorySegment> longInitializer =
                 (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));
-        Consumer<MemoryAddress> doubleInitializer =
+        Consumer<MemorySegment> doubleInitializer =
                 (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));
 
-        Consumer<MemoryAddress> byteChecker =
+        Consumer<MemorySegment> byteChecker =
                 (base) -> checkBytes(base, bytes, byteHandle::get, bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);
-        Consumer<MemoryAddress> charChecker =
+        Consumer<MemorySegment> charChecker =
                 (base) -> checkBytes(base, chars, charHandle::get, ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);
-        Consumer<MemoryAddress> shortChecker =
+        Consumer<MemorySegment> shortChecker =
                 (base) -> checkBytes(base, shorts, shortHandle::get, ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);
-        Consumer<MemoryAddress> intChecker =
+        Consumer<MemorySegment> intChecker =
                 (base) -> checkBytes(base, ints, intHandle::get, ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);
-        Consumer<MemoryAddress> floatChecker =
+        Consumer<MemorySegment> floatChecker =
                 (base) -> checkBytes(base, floats, floatHandle::get, ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);
-        Consumer<MemoryAddress> longChecker =
+        Consumer<MemorySegment> longChecker =
                 (base) -> checkBytes(base, longs, longHandle::get, ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);
-        Consumer<MemoryAddress> doubleChecker =
+        Consumer<MemorySegment> doubleChecker =
                 (base) -> checkBytes(base, doubles, doubleHandle::get, ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);
 
         return new Object[][]{
                 {byteChecker, byteInitializer, bytes},
                 {charChecker, charInitializer, chars},
diff a/test/jdk/java/foreign/TestNativeScope.java b/test/jdk/java/foreign/TestNativeScope.java
--- a/test/jdk/java/foreign/TestNativeScope.java
+++ b/test/jdk/java/foreign/TestNativeScope.java
@@ -66,21 +66,21 @@
                 layout.withBitAlignment(layout.bitAlignment() * 2),
                 layout.withBitAlignment(layout.bitAlignment() * 4),
                 layout.withBitAlignment(layout.bitAlignment() * 8)
         };
         for (ValueLayout alignedLayout : layouts) {
-            List<MemoryAddress> addressList = new ArrayList<>();
+            List<MemorySegment> addressList = new ArrayList<>();
             int elems = ELEMS / ((int)alignedLayout.byteAlignment() / (int)layout.byteAlignment());
             try (NativeScope scope = scopeFactory.make((int)alignedLayout.byteSize() * ELEMS)) {
                 for (int i = 0 ; i < elems ; i++) {
-                    MemoryAddress address = allocationFunction.allocate(scope, alignedLayout, value);
-                    assertEquals(address.segment().byteSize(), alignedLayout.byteSize());
+                    MemorySegment address = allocationFunction.allocate(scope, alignedLayout, value);
+                    assertEquals(address.byteSize(), alignedLayout.byteSize());
                     addressList.add(address);
                     VarHandle handle = handleFactory.apply(alignedLayout);
                     assertEquals(value, handle.get(address));
                     try {
-                        address.segment().close();
+                        address.close();
                         fail();
                     } catch (UnsupportedOperationException uoe) {
                         //failure is expected
                         assertTrue(true);
                     }
@@ -93,27 +93,27 @@
                     //failure is expected if bound
                     assertTrue(isBound);
                 }
             }
             // addresses should be invalid now
-            for (MemoryAddress address : addressList) {
-                assertFalse(address.segment().isAlive());
+            for (MemorySegment address : addressList) {
+                assertFalse(address.isAlive());
             }
         }
     }
 
     static final int SIZE_256M = 1024 * 1024 * 256;
 
     @Test
     public void testBigAllocationInUnboundedScope() {
         try (NativeScope scope = NativeScope.unboundedScope()) {
             for (int i = 8 ; i < SIZE_256M ; i *= 8) {
-                MemoryAddress address = scope.allocate(i);
+                MemorySegment address = scope.allocate(i);
                 //check size
-                assertEquals(address.segment().byteSize(), i);
+                assertEquals(address.byteSize(), i);
                 //check alignment
-                assertTrue(address.segment().address().toRawLongValue() % i == 0);
+                assertTrue(address.address().toRawLongValue() % i == 0);
             }
         }
     }
 
     @Test
@@ -206,12 +206,12 @@
 
     @Test(dataProvider = "arrayScopes")
     public <Z> void testArray(ScopeFactory scopeFactory, ValueLayout layout, AllocationFunction<Object> allocationFunction, ToArrayHelper<Z> arrayHelper) {
         Z arr = arrayHelper.array();
         try (NativeScope scope = scopeFactory.make(100)) {
-            MemoryAddress address = allocationFunction.allocate(scope, layout, arr);
-            Z found = arrayHelper.toArray(address.segment(), layout);
+            MemorySegment address = allocationFunction.allocate(scope, layout, arr);
+            Z found = arrayHelper.toArray(address, layout);
             assertEquals(found, arr);
         }
     }
 
     @DataProvider(name = "nativeScopes")
@@ -385,11 +385,11 @@
                         ToArrayHelper.toDoubleArray },
         };
     }
 
     interface AllocationFunction<X> {
-        MemoryAddress allocate(NativeScope scope, ValueLayout layout, X value);
+        MemorySegment allocate(NativeScope scope, ValueLayout layout, X value);
     }
 
     interface ScopeFactory {
         NativeScope make(int size);
     }
diff a/test/jdk/java/foreign/TestRebase.java b/test/jdk/java/foreign/TestRebase.java
--- a/test/jdk/java/foreign/TestRebase.java
+++ b/test/jdk/java/foreign/TestRebase.java
@@ -25,10 +25,11 @@
 /*
  * @test
  * @run testng TestRebase
  */
 
+import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
@@ -40,39 +41,37 @@
 
 import static org.testng.Assert.*;
 
 public class TestRebase {
 
-    static VarHandle BYTE_VH = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
-
     @Test(dataProvider = "slices")
     public void testRebase(SegmentSlice s1, SegmentSlice s2) {
         if (s1.contains(s2)) {
             //check that an address and its rebased counterpart point to same element
             MemoryAddress base = s2.segment.address();
-            MemoryAddress rebased = base.rebase(s1.segment);
+            long offset = base.segmentOffset(s1.segment);
             for (int i = 0; i < s2.size(); i++) {
-                int expected = (int) BYTE_VH.get(base.addOffset(i));
-                int found = (int) BYTE_VH.get(rebased.addOffset(i));
+                int expected = MemoryAccess.getByteAtOffset(s2.segment, i);
+                int found = (int)MemoryAccess.getByteAtOffset(s1.segment, i + offset);
                 assertEquals(found, expected);
             }
         } else if (s1.kind != s2.kind) {
             // check that rebase s1 to s2 fails
             try {
-                s1.segment.address().rebase(s2.segment);
+                s1.segment.address().segmentOffset(s2.segment);
                 fail("Rebase unexpectedly passed!");
             } catch (IllegalArgumentException ex) {
                 assertTrue(true);
             }
         } else if (!s2.contains(s1)) {
             //disjoint segments - check that rebased address is out of bounds
             MemoryAddress base = s2.segment.address();
-            MemoryAddress rebased = base.rebase(s1.segment);
+            long offset = base.segmentOffset(s1.segment);
             for (int i = 0; i < s2.size(); i++) {
-                BYTE_VH.get(base.addOffset(i));
+                MemoryAccess.getByteAtOffset(s2.segment, i);
                 try {
-                    BYTE_VH.get(rebased.addOffset(i));
+                    MemoryAccess.getByteAtOffset(s1.segment, i + offset);
                     fail("Rebased address on a disjoint segment is not out of bounds!");
                 } catch (IndexOutOfBoundsException ex) {
                     assertTrue(true);
                 }
             }
@@ -125,11 +124,11 @@
         List<SegmentSlice> slices = new ArrayList<>();
         for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {
             //init root segment
             MemorySegment segment = kind.makeSegment(16);
             for (int i = 0 ; i < 16 ; i++) {
-                BYTE_VH.set(segment.address().addOffset(i), (byte)i);
+                MemoryAccess.setByteAtOffset(segment, i, (byte)i);
             }
             //compute all slices
             for (int size : sizes) {
                 for (int index = 0 ; index < 16 ; index += size) {
                     MemorySegment slice = segment.asSlice(index, size);
diff a/test/jdk/java/foreign/TestSegments.java b/test/jdk/java/foreign/TestSegments.java
--- a/test/jdk/java/foreign/TestSegments.java
+++ b/test/jdk/java/foreign/TestSegments.java
@@ -92,58 +92,32 @@
     public void testNativeSegmentIsZeroed() {
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(1000)) {
             for (long i = 0 ; i < segment.byteSize() ; i++) {
-                assertEquals(0, (byte)byteHandle.get(segment.address(), i));
+                assertEquals(0, (byte)byteHandle.get(segment, i));
             }
         }
     }
 
-    @Test
-    public void testNothingSegmentAccess() {
-        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);
-        long[] values = { 0L, Integer.MAX_VALUE - 1, (long) Integer.MAX_VALUE + 1 };
-        for (long value : values) {
-            MemoryAddress addr = MemoryAddress.ofLong(value);
-            try {
-                longHandle.get(addr);
-            } catch (UnsupportedOperationException ex) {
-                assertTrue(ex.getMessage().contains("Required access mode"));
-            }
-        }
-    }
-
-    @Test(expectedExceptions = UnsupportedOperationException.class)
-    public void testNothingSegmentOffset() {
-        MemoryAddress addr = MemoryAddress.ofLong(42);
-        assertNull(addr.segment());
-        addr.segmentOffset();
-    }
-
     @Test
     public void testSlices() {
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(10)) {
             //init
             for (byte i = 0 ; i < segment.byteSize() ; i++) {
-                byteHandle.set(segment.address(), (long)i, i);
+                byteHandle.set(segment, (long)i, i);
             }
-            long start = 0;
-            MemoryAddress base = segment.address();
-            MemoryAddress last = base.addOffset(10);
-            while (!base.equals(last)) {
-                MemorySegment slice = segment.asSlice(base.segmentOffset(), 10 - start);
-                for (long i = start ; i < 10 ; i++) {
+            for (int offset = 0 ; offset < 10 ; offset++) {
+                MemorySegment slice = segment.asSlice(offset);
+                for (long i = offset ; i < 10 ; i++) {
                     assertEquals(
-                            byteHandle.get(segment.address(), i),
-                            byteHandle.get(slice.address(), i - start)
+                            byteHandle.get(segment, i),
+                            byteHandle.get(slice, i - offset)
                     );
                 }
-                base = base.addOffset(1);
-                start++;
             }
         }
     }
 
     @Test(dataProvider = "segmentFactories")
@@ -195,24 +169,24 @@
 
         for (byte value : new byte[] {(byte) 0xFF, (byte) 0x00, (byte) 0x45}) {
             try (MemorySegment segment = memorySegmentSupplier.get()) {
                 segment.fill(value);
                 for (long l = 0; l < segment.byteSize(); l++) {
-                    assertEquals((byte) byteHandle.get(segment.address(), l), value);
+                    assertEquals((byte) byteHandle.get(segment, l), value);
                 }
 
                 // fill a slice
                 var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);
                 for (long l = 0; l < sliceSegment.byteSize(); l++) {
-                    assertEquals((byte) byteHandle.get(sliceSegment.address(), l), ~value);
+                    assertEquals((byte) byteHandle.get(sliceSegment, l), ~value);
                 }
                 // assert enclosing slice
-                assertEquals((byte) byteHandle.get(segment.address(), 0L), value);
+                assertEquals((byte) byteHandle.get(segment, 0L), value);
                 for (long l = 1; l < segment.byteSize() - 2; l++) {
-                    assertEquals((byte) byteHandle.get(segment.address(), l), (byte) ~value);
+                    assertEquals((byte) byteHandle.get(segment, l), (byte) ~value);
                 }
-                assertEquals((byte) byteHandle.get(segment.address(), segment.byteSize() - 1L), value);
+                assertEquals((byte) byteHandle.get(segment, segment.byteSize() - 1L), value);
             }
         }
     }
 
     @Test(dataProvider = "segmentFactories", expectedExceptions = IllegalStateException.class)
@@ -317,12 +291,13 @@
 
     @DataProvider(name = "segmentOperations")
     static Object[][] segmentMembers() {
         List<SegmentMember> members = new ArrayList<>();
         for (Method m : MemorySegment.class.getDeclaredMethods()) {
-            //skip statics and method declared in j.l.Object
-            if (m.getDeclaringClass().equals(Object.class) ||
+            //skip defaults, statics and method declared in j.l.Object
+            if (m.isDefault() ||
+                    m.getDeclaringClass().equals(Object.class) ||
                     (m.getModifiers() & Modifier.STATIC) != 0) continue;
             Object[] args = Stream.of(m.getParameterTypes())
                     .map(TestSegments::defaultValue)
                     .toArray();
             members.add(new SegmentMember(m, args));
@@ -333,10 +308,11 @@
     static class SegmentMember {
         final Method method;
         final Object[] params;
 
         final static List<String> CONFINED_NAMES = List.of(
+                "address",
                 "close",
                 "fill",
                 "copyFrom",
                 "mismatch",
                 "toByteArray",
@@ -434,17 +410,17 @@
             }
         },
         READ(MemorySegment.READ) {
             @Override
             void run(MemorySegment segment) {
-                INT_HANDLE.get(segment.address());
+                INT_HANDLE.get(segment);
             }
         },
         WRITE(MemorySegment.WRITE) {
             @Override
             void run(MemorySegment segment) {
-                INT_HANDLE.set(segment.address(), 42);
+                INT_HANDLE.set(segment, 42);
             }
         },
         HANDOFF(MemorySegment.HANDOFF) {
             @Override
             void run(MemorySegment segment) {
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -25,11 +25,10 @@
 /*
  * @test
  * @run testng/othervm -Dforeign.restricted=permit TestSharedAccess
  */
 
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.SequenceLayout;
 import org.testng.annotations.*;
@@ -54,16 +53,16 @@
     @Test
     public void testConfined() throws Throwable {
         Thread owner = Thread.currentThread();
         MemorySegment s = MemorySegment.allocateNative(4);
         AtomicReference<MemorySegment> confined = new AtomicReference<>(s);
-        setInt(s.address(), 42);
-        assertEquals(getInt(s.address()), 42);
+        setInt(s, 42);
+        assertEquals(getInt(s), 42);
         List<Thread> threads = new ArrayList<>();
         for (int i = 0 ; i < 1000 ; i++) {
             threads.add(new Thread(() -> {
-                assertEquals(getInt(confined.get().address()), 42);
+                assertEquals(getInt(confined.get()), 42);
                 confined.set(confined.get().withOwnerThread(owner));
             }));
         }
         threads.forEach(t -> {
             confined.set(confined.get().withOwnerThread(t));
@@ -80,11 +79,11 @@
     @Test
     public void testShared() throws Throwable {
         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
         try (MemorySegment s = MemorySegment.allocateNative(layout)) {
             for (int i = 0 ; i < layout.elementCount().getAsLong() ; i++) {
-                setInt(s.address().addOffset(i * 4), 42);
+                setInt(s.asSlice(i * 4), 42);
             }
             List<Thread> threads = new ArrayList<>();
             List<Spliterator<MemorySegment>> spliterators = new ArrayList<>();
             spliterators.add(MemorySegment.spliterator(s, layout));
             while (true) {
@@ -103,11 +102,11 @@
 
             AtomicInteger accessCount = new AtomicInteger();
             for (Spliterator<MemorySegment> spliterator : spliterators) {
                 threads.add(new Thread(() -> {
                     spliterator.tryAdvance(local -> {
-                        assertEquals(getInt(local.address()), 42);
+                        assertEquals(getInt(local), 42);
                         accessCount.incrementAndGet();
                     });
                 }));
             }
             threads.forEach(Thread::start);
@@ -123,18 +122,18 @@
     }
 
     @Test
     public void testSharedUnsafe() throws Throwable {
         try (MemorySegment s = MemorySegment.allocateNative(4)) {
-            setInt(s.address(), 42);
-            assertEquals(getInt(s.address()), 42);
+            setInt(s, 42);
+            assertEquals(getInt(s), 42);
             List<Thread> threads = new ArrayList<>();
             MemorySegment sharedSegment = MemorySegment.ofNativeRestricted(
                     s.address(), s.byteSize(), null, null, null);
             for (int i = 0 ; i < 1000 ; i++) {
                 threads.add(new Thread(() -> {
-                    assertEquals(getInt(sharedSegment.address()), 42);
+                    assertEquals(getInt(sharedSegment), 42);
                 }));
             }
             threads.forEach(Thread::start);
             threads.forEach(t -> {
                 try {
@@ -223,30 +222,28 @@
                     try {
                         b.await();
                     } catch (InterruptedException e) {
                     }
 
-                    MemoryAddress base = s2.address();
-                    setInt(base.addOffset(4), -42);
+                    setInt(s2.asSlice(4), -42);
                     fail();
                 } catch (IllegalStateException ex) {
                     assertTrue(ex.getMessage().contains("owning thread"));
                 }
             });
 
             a.await();
-            MemoryAddress base = s1.address();
-            setInt(base.addOffset(4), 42);
+            setInt(s1.asSlice(4), 42);
         }
 
         b.countDown();
         r.get();
     }
 
-    static int getInt(MemoryAddress address) {
-        return (int)intHandle.getVolatile(address);
+    static int getInt(MemorySegment base) {
+        return (int)intHandle.getVolatile(base);
     }
 
-    static void setInt(MemoryAddress address, int value) {
-        intHandle.setVolatile(address, value);
+    static void setInt(MemorySegment base, int value) {
+        intHandle.setVolatile(base, value);
     }
 }
diff a/test/jdk/java/foreign/TestSlices.java b/test/jdk/java/foreign/TestSlices.java
--- a/test/jdk/java/foreign/TestSlices.java
+++ b/test/jdk/java/foreign/TestSlices.java
@@ -42,19 +42,17 @@
             MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT));
 
     static VarHandle VH_ALL = LAYOUT.varHandle(int.class,
             MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement());
 
-    static VarHandle VH_INT = MemoryLayouts.JAVA_INT.varHandle(int.class);
-
     @Test(dataProvider = "slices")
     public void testSlices(VarHandle handle, int lo, int hi, int[] values) {
         try (MemorySegment segment = MemorySegment.allocateNative(LAYOUT)) {
             //init
             for (long i = 0 ; i < 2 ; i++) {
                 for (long j = 0 ; j < 5 ; j++) {
-                    VH_ALL.set(segment.address(), i, j, (int)j + 1 + ((int)i * 5));
+                    VH_ALL.set(segment, i, j, (int)j + 1 + ((int)i * 5));
                 }
             }
 
             checkSlice(segment, handle, lo, hi, values);
         }
@@ -62,11 +60,11 @@
 
     static void checkSlice(MemorySegment segment, VarHandle handle, long i_max, long j_max, int... values) {
         int index = 0;
         for (long i = 0 ; i < i_max ; i++) {
             for (long j = 0 ; j < j_max ; j++) {
-                int x = (int) handle.get(segment.address(), i, j);
+                int x = (int) handle.get(segment, i, j);
                 assertEquals(x, values[index++]);
             }
         }
         assertEquals(index, values.length);
     }
@@ -77,21 +75,17 @@
                 // x
                 { VH_ALL, 2, 5, new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } },
                 // x[0::2]
                 { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),
                         MemoryLayout.PathElement.sequenceElement(0, 2)), 2, 3, new int[] { 1, 3, 5, 6, 8, 10 } },
-                { MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, 8), 20), 2, 3, new int[] { 1, 3, 5, 6, 8, 10 } },
                 // x[1::2]
                 { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),
                         MemoryLayout.PathElement.sequenceElement(1, 2)), 2, 2, new int[] { 2, 4, 7, 9 } },
-                { MemoryHandles.withOffset(MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, 8), 20), 4), 2, 2, new int[] { 2, 4, 7, 9 } },
                 // x[4::-2]
                 { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),
                         MemoryLayout.PathElement.sequenceElement(4, -2)), 2, 3, new int[] { 5, 3, 1, 10, 8, 6 } },
-                { MemoryHandles.withOffset(MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, -8), 20), 16), 2, 3, new int[] { 5, 3, 1, 10, 8, 6 } },
                 // x[3::-2]
                 { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),
                         MemoryLayout.PathElement.sequenceElement(3, -2)), 2, 2, new int[] { 4, 2, 9, 7 } },
-                { MemoryHandles.withOffset(MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, -8), 20), 12), 2, 2, new int[] { 4, 2, 9, 7 } },
         };
     }
 }
diff a/test/jdk/java/foreign/TestSpliterator.java b/test/jdk/java/foreign/TestSpliterator.java
--- a/test/jdk/java/foreign/TestSpliterator.java
+++ b/test/jdk/java/foreign/TestSpliterator.java
@@ -61,11 +61,11 @@
         SequenceLayout layout = MemoryLayout.ofSequence(size, MemoryLayouts.JAVA_INT);
 
         //setup
         MemorySegment segment = MemorySegment.allocateNative(layout);
         for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
-            INT_HANDLE.set(segment.address(), (long) i, i);
+            INT_HANDLE.set(segment, (long) i, i);
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
         //serial
         long serial = sum(0, segment);
         assertEquals(serial, expected);
@@ -86,11 +86,11 @@
         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
 
         //setup
         MemorySegment segment = MemorySegment.allocateNative(layout);
         for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
-            INT_HANDLE.set(segment.address(), (long) i, i);
+            INT_HANDLE.set(segment, (long) i, i);
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 
         //check that a segment w/o ACQUIRE access mode can still be used from same thread
         AtomicLong spliteratorSum = new AtomicLong();
@@ -98,19 +98,18 @@
                 .forEachRemaining(s -> spliteratorSum.addAndGet(sumSingle(0L, s)));
         assertEquals(spliteratorSum.get(), expected);
     }
 
     static long sumSingle(long acc, MemorySegment segment) {
-        return acc + (int)INT_HANDLE.get(segment.address(), 0L);
+        return acc + (int)INT_HANDLE.get(segment, 0L);
     }
 
     static long sum(long start, MemorySegment segment) {
         long sum = start;
-        MemoryAddress base = segment.address();
         int length = (int)segment.byteSize();
         for (int i = 0 ; i < length / CARRIER_SIZE ; i++) {
-            sum += (int)INT_HANDLE.get(base, (long)i);
+            sum += (int)INT_HANDLE.get(segment, (long)i);
         }
         return sum;
     }
 
     static class SumSegmentCounted extends CountedCompleter<Long> {
diff a/test/jdk/java/foreign/TestUpcall.java b/test/jdk/java/foreign/TestUpcall.java
--- a/test/jdk/java/foreign/TestUpcall.java
+++ b/test/jdk/java/foreign/TestUpcall.java
@@ -95,40 +95,37 @@
         } catch (Throwable ex) {
             throw new IllegalStateException(ex);
         }
     }
 
-    static MemoryAddress dummyAddress;
+    static MemorySegment dummyStub;
 
     @BeforeClass
     void setup() {
-        dummyAddress = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid()).address();
+        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid());
     }
 
     @AfterClass
     void teardown() {
-        dummyAddress.segment().close();
+        dummyStub.close();
     }
 
     @Test(dataProvider="functions", dataProviderClass=CallGeneratorHelper.class)
     public void testUpcalls(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {
+        List<MemorySegment> segments = new ArrayList<>();
         List<Consumer<Object>> returnChecks = new ArrayList<>();
         List<Consumer<Object[]>> argChecks = new ArrayList<>();
         LibraryLookup.Symbol addr = lib.lookup(fName);
         MethodHandle mh = abi.downcallHandle(addr, methodType(ret, paramTypes, fields), function(ret, paramTypes, fields));
-        Object[] args = makeArgs(ret, paramTypes, fields, returnChecks, argChecks);
+        Object[] args = makeArgs(ret, paramTypes, fields, returnChecks, argChecks, segments);
         mh = mh.asSpreader(Object[].class, paramTypes.size() + 1);
         Object res = mh.invoke(args);
         argChecks.forEach(c -> c.accept(args));
         if (ret == Ret.NON_VOID) {
             returnChecks.forEach(c -> c.accept(res));
         }
-        for (Object arg : args) {
-            if (arg != dummyAddress) {
-                cleanup(arg);
-            }
-        }
+        segments.forEach(MemorySegment::close);
     }
 
     static MethodType methodType(Ret ret, List<ParamType> params, List<StructFieldType> fields) {
         MethodType mt = ret == Ret.VOID ?
                 MethodType.methodType(void.class) : MethodType.methodType(paramCarrier(params.get(0).layout(fields)));
@@ -146,22 +143,23 @@
         return ret == Ret.VOID ?
                 FunctionDescriptor.ofVoid(layouts) :
                 FunctionDescriptor.of(layouts[0], layouts);
     }
 
-    static Object[] makeArgs(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {
+    static Object[] makeArgs(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemorySegment> segments) throws ReflectiveOperationException {
         Object[] args = new Object[params.size() + 1];
         for (int i = 0 ; i < params.size() ; i++) {
-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);
+            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0, segments);
         }
-        args[params.size()] = makeCallback(ret, params, fields, checks, argChecks);
+        args[params.size()] = makeCallback(ret, params, fields, checks, argChecks, segments);
         return args;
     }
 
-    static MemoryAddress makeCallback(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {
+    @SuppressWarnings("unchecked")
+    static MemoryAddress makeCallback(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemorySegment> segments) {
         if (params.isEmpty()) {
-            return dummyAddress;
+            return dummyStub.address();
         }
 
         AtomicReference<Object[]> box = new AtomicReference<>();
         MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box);
         mh = mh.asCollector(Object[].class, params.size());
@@ -194,21 +192,22 @@
 
         MemoryLayout[] paramLayouts = params.stream().map(p -> p.layout(fields)).toArray(MemoryLayout[]::new);
         FunctionDescriptor func = ret != Ret.VOID
                 ? FunctionDescriptor.of(firstlayout, paramLayouts)
                 : FunctionDescriptor.ofVoid(paramLayouts);
-        MemoryAddress stub = abi.upcallStub(mh, func).address();
-        return stub;
+        MemorySegment stub = abi.upcallStub(mh, func);
+        segments.add(stub);
+        return stub.address();
     }
 
     private static void assertStructEquals(MemorySegment actual, MemorySegment expected, MemoryLayout layout) {
         assertEquals(actual.byteSize(), expected.byteSize());
         GroupLayout g = (GroupLayout) layout;
         for (MemoryLayout field : g.memberLayouts()) {
             if (field instanceof ValueLayout) {
                 VarHandle vh = g.varHandle(vhCarrier(field), MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));
-                assertEquals(vh.get(actual.address()), vh.get(expected.address()));
+                assertEquals(vh.get(actual), vh.get(expected));
             }
         }
     }
 
     private static Class<?> vhCarrier(MemoryLayout layout) {
diff a/test/jdk/java/foreign/TestUpcallStubs.java b/test/jdk/java/foreign/TestUpcallStubs.java
--- a/test/jdk/java/foreign/TestUpcallStubs.java
+++ b/test/jdk/java/foreign/TestUpcallStubs.java
@@ -62,11 +62,11 @@
 
     @Test(expectedExceptions = UnsupportedOperationException.class)
     public void testNoAccess() {
         try (MemorySegment stub = getStub()) {
             VarHandle vh = JAVA_INT.varHandle(int.class);
-            vh.set(stub.address(), 10);
+            vh.set(stub, 10);
         }
     }
 
     @Test
     public void testFree() {
diff a/test/jdk/java/foreign/TestVarArgs.java b/test/jdk/java/foreign/TestVarArgs.java
--- a/test/jdk/java/foreign/TestVarArgs.java
+++ b/test/jdk/java/foreign/TestVarArgs.java
@@ -82,15 +82,15 @@
             MemorySegment callInfo = MemorySegment.allocateNative(ML_CallInfo);
             MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.ofSequence(args.size(), C_INT))) {
 
             MemoryAddress callInfoPtr = callInfo.address();
 
-            VH_CallInfo_writeback.set(callInfoPtr, writeBack.address().toRawLongValue());
-            VH_CallInfo_argIDs.set(callInfoPtr, argIDs.address().toRawLongValue());
+            VH_CallInfo_writeback.set(callInfo, writeBack.address().toRawLongValue());
+            VH_CallInfo_argIDs.set(callInfo, argIDs.address().toRawLongValue());
 
             for (int i = 0; i < args.size(); i++) {
-                VH_IntArray.set(argIDs.address(), (long) i, args.get(i).id.ordinal());
+                VH_IntArray.set(argIDs, (long) i, args.get(i).id.ordinal());
             }
 
             List<MemoryLayout> argLayouts = new ArrayList<>();
             argLayouts.add(C_POINTER); // call info
             argLayouts.add(C_INT); // size
@@ -114,11 +114,11 @@
 
             downcallHandle.invokeWithArguments(argValues);
 
             for (int i = 0; i < args.size(); i++) {
                 VarArg a = args.get(i);
-                MemoryAddress writtenPtr = writeBack.address().addOffset(i * WRITEBACK_BYTES_PER_ARG);
+                MemorySegment writtenPtr = writeBack.asSlice(i * WRITEBACK_BYTES_PER_ARG);
                 Object written = a.vh.get(writtenPtr);
                 assertEquals(written, a.value);
             }
         }
     }
diff a/test/jdk/java/foreign/TestVarHandleCombinators.java b/test/jdk/java/foreign/TestVarHandleCombinators.java
--- a/test/jdk/java/foreign/TestVarHandleCombinators.java
+++ b/test/jdk/java/foreign/TestVarHandleCombinators.java
@@ -29,11 +29,10 @@
 
 import jdk.incubator.foreign.MemoryHandles;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
@@ -43,40 +42,24 @@
 public class TestVarHandleCombinators {
 
     @Test
     public void testElementAccess() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withStride(vh, 1);
 
         byte[] arr = { 0, 0, -1, 0 };
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress addr = segment.address();
-
-        assertEquals((byte) vh.get(addr, 2), (byte) -1);
+        assertEquals((byte) vh.get(segment, 2), (byte) -1);
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedElement() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withStride(vh, 2);
         MemorySegment segment = MemorySegment.ofArray(new byte[4]);
-        vh.get(segment.address(), 1L); //should throw
-    }
-
-    public void testZeroStrideElement() {
-        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-        VarHandle strided_vh = MemoryHandles.withStride(vh, 0);
-        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
-        for (int i = 0 ; i < 100 ; i++) {
-            assertEquals((int)vh.get(segment.address()), strided_vh.get(segment.address(), (long)i));
-        }
-    }
-
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void testStrideWrongHandle() {
-        VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());
-        MemoryHandles.withStride(vh, 10);
+        vh.get(segment, 2L); //should throw
+        //FIXME: the VH only checks the alignment of the segment, which is fine if the VH is derived from layouts,
+        //FIXME: but not if the VH is just created from scratch - we need a VH variable to govern this property,
+        //FIXME: at least until the VM is fixed
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testAlignNotPowerOf2() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 3, ByteOrder.nativeOrder());
@@ -90,82 +73,30 @@
     @Test
     public void testAlign() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
 
         MemorySegment segment = MemorySegment.allocateNative(1, 2);
-        MemoryAddress address = segment.address();
-
-        vh.set(address, (byte) 10); // fine, memory region is aligned
-        assertEquals((byte) vh.get(address), (byte) 10);
-    }
-
-    @Test(expectedExceptions = IllegalStateException.class)
-    public void testAlignBadAccess() {
-        VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withOffset(vh, 1); // offset by 1 byte
-
-        MemorySegment segment = MemorySegment.allocateNative(2, 2);
-        MemoryAddress address = segment.address();
-
-        vh.set(address, (byte) 10); // should be bad align
-    }
-
-    public void testZeroOffsetElement() {
-        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-        VarHandle offset_vh = MemoryHandles.withOffset(vh, 0);
-        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
-        for (int i = 0 ; i < 100 ; i++) {
-            assertEquals((int)vh.get(segment.address()), offset_vh.get(segment.address(), (long)i));
-        }
-    }
-
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void testOffsetWrongHandle() {
-        VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());
-        MemoryHandles.withOffset(vh, 1);
-    }
-
-    @Test(expectedExceptions = IllegalStateException.class)
-    public void testUnalignedOffset() {
-        VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withOffset(vh, 2);
-        MemorySegment segment = MemorySegment.ofArray(new byte[4]);
-        vh.get(segment.address()); //should throw
-    }
-
-    @Test
-    public void testOffset() {
-        VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withOffset(vh, 1);
-
-        MemorySegment segment = MemorySegment.ofArray(new byte[2]);
-        MemoryAddress address = segment.address();
-
-        vh.set(address, (byte) 10);
-        assertEquals((byte) vh.get(address), (byte) 10);
+        vh.set(segment, 0L, (byte) 10); // fine, memory region is aligned
+        assertEquals((byte) vh.get(segment, 0L), (byte) 10);
     }
 
     @Test
     public void testByteOrderLE() {
         VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.LITTLE_ENDIAN);
         byte[] arr = new byte[2];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress address = segment.address();
-
-        vh.set(address, (short) 0xFF);
+        vh.set(segment, 0L, (short) 0xFF);
         assertEquals(arr[0], (byte) 0xFF);
         assertEquals(arr[1], (byte) 0);
     }
 
     @Test
     public void testByteOrderBE() {
         VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.BIG_ENDIAN);
         byte[] arr = new byte[2];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress address = segment.address();
-
-        vh.set(address, (short) 0xFF);
+        vh.set(segment, 0L, (short) 0xFF);
         assertEquals(arr[0], (byte) 0);
         assertEquals(arr[1], (byte) 0xFF);
     }
 
     @Test
@@ -174,20 +105,17 @@
         int inner_size = 5;
 
         //[10 : [5 : [x32 i32]]]
 
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withOffset(vh, 4);
-        VarHandle inner_vh = MemoryHandles.withStride(vh, 8);
-        VarHandle outer_vh = MemoryHandles.withStride(inner_vh, 5 * 8);
         int count = 0;
         try (MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8)) {
             for (long i = 0; i < outer_size; i++) {
                 for (long j = 0; j < inner_size; j++) {
-                    outer_vh.set(segment.address(), i, j, count);
+                    vh.set(segment, i * 40 + j * 8, count);
                     assertEquals(
-                            (int)inner_vh.get(segment.address().addOffset(i * inner_size * 8), j),
+                            (int)vh.get(segment.asSlice(i * inner_size * 8), j * 8),
                             count);
                     count++;
                 }
             }
         }
diff a/test/jdk/java/foreign/valist/VaListTest.java b/test/jdk/java/foreign/valist/VaListTest.java
--- a/test/jdk/java/foreign/valist/VaListTest.java
+++ b/test/jdk/java/foreign/valist/VaListTest.java
@@ -113,114 +113,112 @@
         }
     }
 
     private static MethodHandle linkVaListCB(String symbol) {
         return link(symbol,
-            MethodType.methodType(void.class, MemoryAddress.class),
-            FunctionDescriptor.ofVoid(C_POINTER));
+                MethodType.methodType(void.class, MemoryAddress.class),
+                FunctionDescriptor.ofVoid(C_POINTER));
 
     }
 
     private static final Function<Consumer<VaList.Builder>, VaList> winVaListFactory
-        = actions -> Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);
+            = actions -> Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);
     private static final Function<Consumer<VaList.Builder>, VaList> sysvVaListFactory
-        = actions -> SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);
+            = actions -> SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);
     private static final Function<Consumer<VaList.Builder>, VaList> aarch64VaListFactory
-        = actions -> AArch64Linker.newVaList(actions, MemorySegment::allocateNative);
+            = actions -> AArch64Linker.newVaList(actions, MemorySegment::allocateNative);
     private static final Function<Consumer<VaList.Builder>, VaList> platformVaListFactory
-        = CSupport.VaList::make;
+            = CSupport.VaList::make;
 
     private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> winVaListScopedFactory
-        = (actions, scope) -> Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
+            = (actions, scope) -> Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
     private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> sysvVaListScopedFactory
-        = (actions, scope) -> SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
+            = (actions, scope) -> SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
     private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> aarch64VaListScopedFactory
-        = (actions, scope) -> AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
+            = (actions, scope) -> AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
     private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> platformVaListScopedFactory
-        = CSupport.VaList::make;
+            = CSupport.VaList::make;
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] sumInts() {
         Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->
-            (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();
+                (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();
         BiFunction<Integer, VaList, Integer> sumIntsNative
-            = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
+                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
         return new Object[][]{
-            { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
-            { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
-            { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
-            { platformVaListFactory, sumIntsNative,                        C_INT         },
+                { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
+                { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
+                { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
+                { platformVaListFactory, sumIntsNative,                        C_INT         },
         };
     }
 
     @Test(dataProvider = "sumInts")
     public void testIntSum(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                            BiFunction<Integer, VaList, Integer> sumInts,
                            MemoryLayout intLayout) {
         try (VaList vaList = vaListFactory.apply(b ->
                 b.vargFromInt(intLayout, 10)
-                 .vargFromInt(intLayout, 15)
-                 .vargFromInt(intLayout, 20))) {
+                        .vargFromInt(intLayout, 15)
+                        .vargFromInt(intLayout, 20))) {
             int x = sumInts.apply(3, vaList);
             assertEquals(x, 45);
         }
     }
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] sumDoubles() {
         Function<MemoryLayout, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->
-            (num, list) -> DoubleStream.generate(() -> list.vargAsDouble(layout)).limit(num).sum();
+                (num, list) -> DoubleStream.generate(() -> list.vargAsDouble(layout)).limit(num).sum();
         BiFunction<Integer, VaList, Double> sumDoublesNative
-            = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);
+                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);
         return new Object[][]{
-            { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },
-            { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },
-            { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },
-            { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },
+                { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },
+                { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },
+                { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },
+                { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },
         };
     }
 
     @Test(dataProvider = "sumDoubles")
     public void testDoubleSum(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                               BiFunction<Integer, VaList, Double> sumDoubles,
                               MemoryLayout doubleLayout) {
         try (VaList vaList = vaListFactory.apply(b ->
                 b.vargFromDouble(doubleLayout, 3.0D)
-                 .vargFromDouble(doubleLayout, 4.0D)
-                 .vargFromDouble(doubleLayout, 5.0D))) {
+                        .vargFromDouble(doubleLayout, 4.0D)
+                        .vargFromDouble(doubleLayout, 5.0D))) {
             double x = sumDoubles.apply(3, vaList);
             assertEquals(x, 12.0D);
         }
     }
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] pointers() {
         Function<MemoryLayout, Function<VaList, Integer>> getIntJavaFact = layout ->
-            list -> {
-                MemoryAddress ma = list.vargAsAddress(layout);
-                MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,
-                        4, Thread.currentThread(), null, null);
-                return MemoryAccess.getInt(accessibleSegment.address());
-            };
+                list -> {
+                    MemoryAddress ma = list.vargAsAddress(layout);
+                    return MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), ma.toRawLongValue());
+                };
         Function<VaList, Integer> getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
         return new Object[][]{
-            { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
-            { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },
-            { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },
-            { platformVaListFactory, getIntNative,                            C_POINTER         },
+                { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
+                { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },
+                { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },
+                { platformVaListFactory, getIntNative,                            C_POINTER         },
         };
     }
 
     @Test(dataProvider = "pointers")
     public void testVaListMemoryAddress(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                                         Function<VaList, Integer> getFromPointer,
                                         MemoryLayout pointerLayout) {
         try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
-            MemoryAccess.setInt(msInt.address(), 10);
+            MemoryAccess.setInt(msInt, 10);
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.address()))) {
                 int x = getFromPointer.apply(vaList);
                 assertEquals(x, 10);
             }
         }
@@ -232,49 +230,49 @@
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] structs() {
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact
-            = (pointLayout, VH_Point_x, VH_Point_y) ->
+                = (pointLayout, VH_Point_x, VH_Point_y) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(pointLayout);
-                    int x = (int) VH_Point_x.get(struct.address());
-                    int y = (int) VH_Point_y.get(struct.address());
+                    int x = (int) VH_Point_x.get(struct);
+                    int y = (int) VH_Point_y.get(struct);
                     return x + y;
                 };
 
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact
-            = (pointLayout, VH_Point_x, VH_Point_y) ->
+                = (pointLayout, VH_Point_x, VH_Point_y) ->
                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);
 
         TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
                 TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact
-            = (vaListFact, intLayout, sumStructFact) -> {
-                GroupLayout pointLayout =  MemoryLayout.ofStruct(
+                = (vaListFact, intLayout, sumStructFact) -> {
+            GroupLayout pointLayout =  MemoryLayout.ofStruct(
                     intLayout.withName("x"),
                     intLayout.withName("y")
-                );
-                VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement("x"));
-                VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement("y"));
-                return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),
-                                      pointLayout, VH_Point_x, VH_Point_y  };
-            };
+            );
+            VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement("x"));
+            VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement("y"));
+            return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),
+                    pointLayout, VH_Point_x, VH_Point_y  };
+        };
         return new Object[][]{
-            argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),
-            argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),
-            argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),
-            argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),
+                argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),
+                argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),
+                argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),
+                argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),
         };
     }
 
     @Test(dataProvider = "structs")
     public void testStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                            Function<VaList, Integer> sumStruct,
                            MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
-            VH_Point_x.set(struct.address(), 5);
-            VH_Point_y.set(struct.address(), 10);
+            VH_Point_x.set(struct, 5);
+            VH_Point_y.set(struct, 10);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct))) {
                 int sum = sumStruct.apply(vaList);
                 assertEquals(sum, 15);
             }
@@ -283,49 +281,49 @@
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] bigStructs() {
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact
-            = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) ->
+                = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
-                    long x = (long) VH_BigPoint_x.get(struct.address());
-                    long y = (long) VH_BigPoint_y.get(struct.address());
+                    long x = (long) VH_BigPoint_x.get(struct);
+                    long y = (long) VH_BigPoint_y.get(struct);
                     return x + y;
                 };
 
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact
-            = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) ->
+                = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) ->
                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);
 
         TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
                 TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact
-            = (vaListFact, longLongLayout, sumBigStructFact) -> {
-                GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(
+                = (vaListFact, longLongLayout, sumBigStructFact) -> {
+            GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(
                     longLongLayout.withName("x"),
                     longLongLayout.withName("y")
-                );
-                VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement("x"));
-                VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement("y"));
-                return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),
-                                      BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };
-            };
+            );
+            VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement("x"));
+            VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement("y"));
+            return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),
+                    BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };
+        };
         return new Object[][]{
-            argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
-            argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
-            argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
-            argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
+                argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
+                argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
+                argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
+                argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
         };
     }
 
     @Test(dataProvider = "bigStructs")
     public void testBigStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                               Function<VaList, Long> sumBigStruct,
                               MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
-            VH_BigPoint_x.set(struct.address(), 5);
-            VH_BigPoint_y.set(struct.address(), 10);
+            VH_BigPoint_x.set(struct, 5);
+            VH_BigPoint_y.set(struct, 10);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct))) {
                 long sum = sumBigStruct.apply(vaList);
                 assertEquals(sum, 15);
             }
@@ -334,50 +332,50 @@
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] floatStructs() {
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact
-            = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) ->
+                = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
-                    float x = (float) VH_FloatPoint_x.get(struct.address());
-                    float y = (float) VH_FloatPoint_y.get(struct.address());
+                    float x = (float) VH_FloatPoint_x.get(struct);
+                    float y = (float) VH_FloatPoint_y.get(struct);
                     return x + y;
                 };
 
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact
-            = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) ->
+                = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) ->
                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);
 
         TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
                 TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact
-            = (vaListFact, floatLayout, sumFloatStructFact) -> {
-                GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
+                = (vaListFact, floatLayout, sumFloatStructFact) -> {
+            GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
                     floatLayout.withName("x"),
                     floatLayout.withName("y")
-                );
-                VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement("x"));
-                VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement("y"));
-                return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),
-                                      FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };
-            };
+            );
+            VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement("x"));
+            VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement("y"));
+            return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),
+                    FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };
+        };
         return new Object[][]{
-            argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),
-            argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),
-            argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),
-            argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),
+                argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),
+                argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),
+                argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),
+                argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),
         };
     }
 
     @Test(dataProvider = "floatStructs")
     public void testFloatStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                                 Function<VaList, Float> sumFloatStruct,
                                 MemoryLayout FloatPoint_LAYOUT,
                                 VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
-            VH_FloatPoint_x.set(struct.address(), 1.234f);
-            VH_FloatPoint_y.set(struct.address(), 3.142f);
+            VH_FloatPoint_x.set(struct, 1.234f);
+            VH_FloatPoint_y.set(struct, 3.142f);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
                 float sum = sumFloatStruct.apply(vaList);
                 assertEquals(sum, 4.376f, 0.00001f);
             }
@@ -390,43 +388,43 @@
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] hugeStructs() {
         QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact
-            = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
+                = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
-                    long x = (long) VH_HugePoint_x.get(struct.address());
-                    long y = (long) VH_HugePoint_y.get(struct.address());
-                    long z = (long) VH_HugePoint_z.get(struct.address());
+                    long x = (long) VH_HugePoint_x.get(struct);
+                    long y = (long) VH_HugePoint_y.get(struct);
+                    long z = (long) VH_HugePoint_z.get(struct);
                     return x + y + z;
                 };
 
         QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact
-            = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
+                = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);
 
         TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,
                 QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact
-            = (vaListFact, longLongLayout, sumBigStructFact) -> {
-                GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
+                = (vaListFact, longLongLayout, sumBigStructFact) -> {
+            GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
                     longLongLayout.withName("x"),
                     longLongLayout.withName("y"),
                     longLongLayout.withName("z")
-                );
-                VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement("x"));
-                VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement("y"));
-                VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement("z"));
-                return new Object[] { vaListFact,
-                                      sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),
-                                      HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };
-            };
+            );
+            VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement("x"));
+            VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement("y"));
+            VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement("z"));
+            return new Object[] { vaListFact,
+                    sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),
+                    HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };
+        };
         return new Object[][]{
-            argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
-            argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
-            argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
-            argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
+                argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
+                argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
+                argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
+                argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
         };
     }
 
     @Test(dataProvider = "hugeStructs")
     public void testHugeStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
@@ -434,58 +432,64 @@
                                MemoryLayout HugePoint_LAYOUT,
                                VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
         // On AArch64 a struct needs to be larger than 16 bytes to be
         // passed by reference.
         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
-            VH_HugePoint_x.set(struct.address(), 1);
-            VH_HugePoint_y.set(struct.address(), 2);
-            VH_HugePoint_z.set(struct.address(), 3);
+            VH_HugePoint_x.set(struct, 1);
+            VH_HugePoint_y.set(struct, 2);
+            VH_HugePoint_z.set(struct, 3);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct))) {
                 long sum = sumHugeStruct.apply(vaList);
                 assertEquals(sum, 6);
             }
         }
     }
 
     public interface SumStackFunc {
-        void invoke(MemoryAddress longSum, MemoryAddress doubleSum, VaList list);
+        void invoke(MemorySegment longSum, MemorySegment doubleSum, VaList list);
     }
 
     @DataProvider
     public static Object[][] sumStack() {
         BiFunction<MemoryLayout, MemoryLayout, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->
-            (longSum, doubleSum, list) -> {
-                long lSum = 0L;
-                for (int i = 0; i < 16; i++) {
-                    lSum += list.vargAsLong(longLayout);
-                }
-                MemoryAccess.setLong(longSum, lSum);
-                double dSum = 0D;
-                for (int i = 0; i < 16; i++) {
-                    dSum += list.vargAsDouble(doubleLayout);
-                }
-                MemoryAccess.setDouble(doubleSum, dSum);
-            };
-        SumStackFunc sumStackNative = MethodHandleProxies.asInterfaceInstance(SumStackFunc.class, MH_sumStack);
+                (longSum, doubleSum, list) -> {
+                    long lSum = 0L;
+                    for (int i = 0; i < 16; i++) {
+                        lSum += list.vargAsLong(longLayout);
+                    }
+                    MemoryAccess.setLong(longSum, lSum);
+                    double dSum = 0D;
+                    for (int i = 0; i < 16; i++) {
+                        dSum += list.vargAsDouble(doubleLayout);
+                    }
+                    MemoryAccess.setDouble(doubleSum, dSum);
+                };
+        SumStackFunc sumStackNative = (longSum, doubleSum, list) -> {
+            try {
+                MH_sumStack.invokeExact(longSum.address(), doubleSum.address(), list);
+            } catch (Throwable ex) {
+                throw new AssertionError(ex);
+            }
+        };
         return new Object[][]{
-            { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },
-            { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },
-            { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },
-            { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },
+                { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },
+                { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },
+                { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },
+                { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },
         };
     }
 
     @Test(dataProvider = "sumStack")
     public void testStack(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                           SumStackFunc sumStack,
                           MemoryLayout longLayout,
                           MemoryLayout doubleLayout) {
-       try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);
-            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {
-            MemoryAccess.setLong(longSum.address(), 0L);
-            MemoryAccess.setDouble(doubleSum.address(), 0D);
+        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);
+             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {
+            MemoryAccess.setLong(longSum, 0L);
+            MemoryAccess.setDouble(doubleSum, 0D);
 
             VaList list = vaListFactory.apply(b -> {
                 for (long l = 1; l <= 16L; l++) {
                     b.vargFromLong(longLayout, l);
                 }
@@ -493,15 +497,15 @@
                     b.vargFromDouble(doubleLayout, d);
                 }
             });
 
             try (list) {
-                sumStack.invoke(longSum.address(), doubleSum.address(), list);
+                sumStack.invoke(longSum, doubleSum, list);
             }
 
-            long lSum = MemoryAccess.getLong(longSum.address());
-            double dSum = MemoryAccess.getDouble(doubleSum.address());
+            long lSum = MemoryAccess.getLong(longSum);
+            double dSum = MemoryAccess.getDouble(doubleSum);
 
             assertEquals(lSum, 136L);
             assertEquals(dSum, 136D);
         }
     }
@@ -515,50 +519,50 @@
     }
 
     @DataProvider
     public Object[][] emptyVaLists() {
         return new Object[][] {
-            { Windowsx64Linker.emptyVaList()      },
-            { winVaListFactory.apply(b -> {})     },
-            { SysVx64Linker.emptyVaList()         },
-            { sysvVaListFactory.apply(b -> {})    },
-            { AArch64Linker.emptyVaList()         },
-            { aarch64VaListFactory.apply(b -> {}) },
+                { Windowsx64Linker.emptyVaList()      },
+                { winVaListFactory.apply(b -> {})     },
+                { SysVx64Linker.emptyVaList()         },
+                { sysvVaListFactory.apply(b -> {})    },
+                { AArch64Linker.emptyVaList()         },
+                { aarch64VaListFactory.apply(b -> {}) },
         };
     }
 
     @Test(expectedExceptions = UnsupportedOperationException.class,
-          expectedExceptionsMessageRegExp = ".*Empty VaList.*",
-          dataProvider = "emptyVaLists")
+            expectedExceptionsMessageRegExp = ".*Empty VaList.*",
+            dataProvider = "emptyVaLists")
     public void testEmptyNotCloseable(VaList emptyList) {
         emptyList.close();
     }
 
     @DataProvider
     @SuppressWarnings("unchecked")
     public static Object[][] sumIntsScoped() {
         Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->
-            (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();
+                (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();
         BiFunction<Integer, VaList, Integer> sumIntsNative
-            = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
+                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);
         return new Object[][]{
-            { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
-            { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
-            { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
-            { platformVaListScopedFactory, sumIntsNative,                        C_INT         },
+                { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },
+                { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },
+                { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },
+                { platformVaListScopedFactory, sumIntsNative,                        C_INT         },
         };
     }
 
     @Test(dataProvider = "sumIntsScoped")
     public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> vaListFactory,
                                  BiFunction<Integer, VaList, Integer> sumInts,
                                  MemoryLayout intLayout) {
         VaList listLeaked;
         try (NativeScope scope = NativeScope.unboundedScope()) {
             VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
-                                                    .vargFromInt(intLayout, 8),
-                                               scope);
+                            .vargFromInt(intLayout, 8),
+                    scope);
             int x = sumInts.apply(2, list);
             assertEquals(x, 12);
             listLeaked = list;
         }
         assertFalse(listLeaked.isAlive());
@@ -569,16 +573,16 @@
                                 Function<VaList, Integer> sumStruct, // ignored
                                 MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
         MemorySegment pointOut;
         try (NativeScope scope = NativeScope.unboundedScope()) {
             try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
-                VH_Point_x.set(pointIn.address(), 3);
-                VH_Point_y.set(pointIn.address(), 6);
+                VH_Point_x.set(pointIn, 3);
+                VH_Point_y.set(pointIn, 6);
                 try (VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn))) {
                     pointOut = list.vargAsSegment(Point_LAYOUT, scope);
-                    assertEquals((int) VH_Point_x.get(pointOut.address()), 3);
-                    assertEquals((int) VH_Point_y.get(pointOut.address()), 6);
+                    assertEquals((int) VH_Point_x.get(pointOut), 3);
+                    assertEquals((int) VH_Point_y.get(pointOut), 6);
                 }
                 assertTrue(pointOut.isAlive()); // after VaList freed
             }
             assertTrue(pointOut.isAlive()); // after input MS freed
         }
@@ -586,20 +590,20 @@
     }
 
     @DataProvider
     public Object[][] copy() {
         return new Object[][] {
-            { winVaListFactory,      Win64.C_INT   },
-            { sysvVaListFactory,     SysV.C_INT    },
-            { aarch64VaListFactory,  AArch64.C_INT },
+                { winVaListFactory,      Win64.C_INT   },
+                { sysvVaListFactory,     SysV.C_INT    },
+                { aarch64VaListFactory,  AArch64.C_INT },
         };
     }
 
     @Test(dataProvider = "copy")
     public void testCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, MemoryLayout intLayout) {
         try (VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
-                                                     .vargFromInt(intLayout, 8))) {
+                .vargFromInt(intLayout, 8))) {
             VaList  copy = list.copy();
             assertEquals(copy.vargAsInt(intLayout), 4);
             assertEquals(copy.vargAsInt(intLayout), 8);
             copy.close();
 
@@ -611,11 +615,11 @@
     }
 
     @Test(dataProvider = "copy")
     public void testScopedCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, MemoryLayout intLayout) {
         try (VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
-                                                     .vargFromInt(intLayout, 8))) {
+                .vargFromInt(intLayout, 8))) {
             VaList copy;
             try (NativeScope scope = NativeScope.unboundedScope()) {
                 copy = list.copy(scope);
 
                 assertEquals(copy.vargAsInt(intLayout), 4);
@@ -627,28 +631,28 @@
             assertEquals(list.vargAsInt(intLayout), 8);
         }
     }
 
     @Test(dataProvider = "copy",
-          expectedExceptions = IllegalStateException.class)
+            expectedExceptions = IllegalStateException.class)
     public void testCopyUnusableAfterOriginalClosed(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                                                     MemoryLayout intLayout) {
         VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
-                                                .vargFromInt(intLayout, 8));
+                .vargFromInt(intLayout, 8));
         try (VaList copy = list.copy()) {
             list.close();
 
             copy.vargAsInt(intLayout); // should throw
         }
     }
 
     @Test(dataProvider = "copy",
-          expectedExceptions = IllegalStateException.class)
+            expectedExceptions = IllegalStateException.class)
     public void testCopyUnusableAfterOriginalClosedScope(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                                                          MemoryLayout intLayout) {
         VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)
-                                                .vargFromInt(intLayout, 8));
+                .vargFromInt(intLayout, 8));
         try (NativeScope scope = NativeScope.unboundedScope()) {
             VaList copy = list.copy(scope);
             list.close();
 
             copy.vargAsInt(intLayout); // should throw
@@ -656,161 +660,161 @@
     }
 
     @DataProvider
     public static Object[][] upcalls() {
         GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(
-            C_LONGLONG.withName("x"),
-            C_LONGLONG.withName("y")
+                C_LONGLONG.withName("x"),
+                C_LONGLONG.withName("y")
         );
         VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement("x"));
         VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement("y"));
         GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(
-            C_INT.withName("x"),
-            C_INT.withName("y")
+                C_INT.withName("x"),
+                C_INT.withName("y")
         );
         VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement("x"));
         VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement("y"));
         GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
-            C_FLOAT.withName("x"),
-            C_FLOAT.withName("y")
+                C_FLOAT.withName("x"),
+                C_FLOAT.withName("y")
         );
         VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement("x"));
         VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement("y"));
         GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
-            C_LONGLONG.withName("x"),
-            C_LONGLONG.withName("y"),
-            C_LONGLONG.withName("z")
+                C_LONGLONG.withName("x"),
+                C_LONGLONG.withName("y"),
+                C_LONGLONG.withName("z")
         );
         VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement("x"));
         VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement("y"));
         VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement("z"));
 
         return new Object[][]{
-            { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
-                try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);
-                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);
-                }
-            })},
-            { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
-                VaList copy = vaList.copy();
-                try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);
-                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);
-
-                    VH_BigPoint_x.set(struct.address(), 0);
-                    VH_BigPoint_y.set(struct.address(), 0);
-                }
-
-                // should be independent
-                try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);
-                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);
-                }
-            })},
-            { linkVaListCB("upcallStruct"), VaListConsumer.mh(vaList -> {
-                try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {
-                    assertEquals((int) VH_Point_x.get(struct.address()), 5);
-                    assertEquals((int) VH_Point_y.get(struct.address()), 10);
-                }
-            })},
-            { linkVaListCB("upcallHugeStruct"), VaListConsumer.mh(vaList -> {
-                try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {
-                    assertEquals((long) VH_HugePoint_x.get(struct.address()), 1);
-                    assertEquals((long) VH_HugePoint_y.get(struct.address()), 2);
-                    assertEquals((long) VH_HugePoint_z.get(struct.address()), 3);
-                }
-            })},
-            { linkVaListCB("upcallFloatStruct"), VaListConsumer.mh(vaList -> {
-                try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {
-                    assertEquals((float) VH_FloatPoint_x.get(struct.address()), 1.0f);
-                    assertEquals((float) VH_FloatPoint_y.get(struct.address()), 2.0f);
-                }
-            })},
-            { linkVaListCB("upcallMemoryAddress"), VaListConsumer.mh(vaList -> {
-                MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
-                MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
-                                                                    Thread.currentThread(), null, null);
-                int x = MemoryAccess.getInt(ms.address());
-                assertEquals(x, 10);
-            })},
-            { linkVaListCB("upcallDoubles"), VaListConsumer.mh(vaList -> {
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);
-            })},
-            { linkVaListCB("upcallInts"), VaListConsumer.mh(vaList -> {
-                assertEquals(vaList.vargAsInt(C_INT), 10);
-                assertEquals(vaList.vargAsInt(C_INT), 15);
-                assertEquals(vaList.vargAsInt(C_INT), 20);
-            })},
-            { linkVaListCB("upcallStack"), VaListConsumer.mh(vaList -> {
-                // skip all registers
-                for (long l = 1; l <= 16; l++) {
-                    assertEquals(vaList.vargAsLong(C_LONGLONG), l);
-                }
-                for (double d = 1; d <= 16; d++) {
-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), d);
-                }
-
-                // test some arbitrary values on the stack
-                assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
-                assertEquals((char) vaList.vargAsInt(C_INT), 'a');
-                assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
-                assertEquals(vaList.vargAsInt(C_INT), 4);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
-                assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);
-                assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);
-                assertEquals((char) vaList.vargAsInt(C_INT), 'b');
-                assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);
-                assertEquals(vaList.vargAsInt(C_INT), 11);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
-                assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
-
-                try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {
-                    assertEquals((int) VH_Point_x.get(point.address()), 5);
-                    assertEquals((int) VH_Point_y.get(point.address()), 10);
-                }
-
-                VaList copy = vaList.copy();
-                try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(bigPoint.address()), 15);
-                    assertEquals((long) VH_BigPoint_y.get(bigPoint.address()), 20);
-
-                    VH_BigPoint_x.set(bigPoint.address(), 0);
-                    VH_BigPoint_y.set(bigPoint.address(), 0);
-                }
-
-                // should be independent
-                try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 15);
-                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 20);
-                }
-            })},
-            // test skip
-            { linkVaListCB("upcallStack"), VaListConsumer.mh(vaList -> {
-                vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
-                vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
-                assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);
-                vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);
-                vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);
-                assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);
-            })},
+                { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
+                    try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
+                        assertEquals((long) VH_BigPoint_x.get(struct), 8);
+                        assertEquals((long) VH_BigPoint_y.get(struct), 16);
+                    }
+                })},
+                { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
+                    VaList copy = vaList.copy();
+                    try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
+                        assertEquals((long) VH_BigPoint_x.get(struct), 8);
+                        assertEquals((long) VH_BigPoint_y.get(struct), 16);
+
+                        VH_BigPoint_x.set(struct, 0);
+                        VH_BigPoint_y.set(struct, 0);
+                    }
+
+                    // should be independent
+                    try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
+                        assertEquals((long) VH_BigPoint_x.get(struct), 8);
+                        assertEquals((long) VH_BigPoint_y.get(struct), 16);
+                    }
+                })},
+                { linkVaListCB("upcallStruct"), VaListConsumer.mh(vaList -> {
+                    try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {
+                        assertEquals((int) VH_Point_x.get(struct), 5);
+                        assertEquals((int) VH_Point_y.get(struct), 10);
+                    }
+                })},
+                { linkVaListCB("upcallHugeStruct"), VaListConsumer.mh(vaList -> {
+                    try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {
+                        assertEquals((long) VH_HugePoint_x.get(struct), 1);
+                        assertEquals((long) VH_HugePoint_y.get(struct), 2);
+                        assertEquals((long) VH_HugePoint_z.get(struct), 3);
+                    }
+                })},
+                { linkVaListCB("upcallFloatStruct"), VaListConsumer.mh(vaList -> {
+                    try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {
+                        assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);
+                        assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);
+                    }
+                })},
+                { linkVaListCB("upcallMemoryAddress"), VaListConsumer.mh(vaList -> {
+                    MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
+                    MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
+                            Thread.currentThread(), null, null);
+                    int x = MemoryAccess.getInt(ms);
+                    assertEquals(x, 10);
+                })},
+                { linkVaListCB("upcallDoubles"), VaListConsumer.mh(vaList -> {
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);
+                })},
+                { linkVaListCB("upcallInts"), VaListConsumer.mh(vaList -> {
+                    assertEquals(vaList.vargAsInt(C_INT), 10);
+                    assertEquals(vaList.vargAsInt(C_INT), 15);
+                    assertEquals(vaList.vargAsInt(C_INT), 20);
+                })},
+                { linkVaListCB("upcallStack"), VaListConsumer.mh(vaList -> {
+                    // skip all registers
+                    for (long l = 1; l <= 16; l++) {
+                        assertEquals(vaList.vargAsLong(C_LONGLONG), l);
+                    }
+                    for (double d = 1; d <= 16; d++) {
+                        assertEquals(vaList.vargAsDouble(C_DOUBLE), d);
+                    }
+
+                    // test some arbitrary values on the stack
+                    assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
+                    assertEquals((char) vaList.vargAsInt(C_INT), 'a');
+                    assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
+                    assertEquals(vaList.vargAsInt(C_INT), 4);
+                    assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
+                    assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);
+                    assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);
+                    assertEquals((char) vaList.vargAsInt(C_INT), 'b');
+                    assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);
+                    assertEquals(vaList.vargAsInt(C_INT), 11);
+                    assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
+                    assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
+
+                    try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {
+                        assertEquals((int) VH_Point_x.get(point), 5);
+                        assertEquals((int) VH_Point_y.get(point), 10);
+                    }
+
+                    VaList copy = vaList.copy();
+                    try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {
+                        assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);
+                        assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);
+
+                        VH_BigPoint_x.set(bigPoint, 0);
+                        VH_BigPoint_y.set(bigPoint, 0);
+                    }
+
+                    // should be independent
+                    try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
+                        assertEquals((long) VH_BigPoint_x.get(struct), 15);
+                        assertEquals((long) VH_BigPoint_y.get(struct), 20);
+                    }
+                })},
+                // test skip
+                { linkVaListCB("upcallStack"), VaListConsumer.mh(vaList -> {
+                    vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
+                    assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
+                    vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
+                    assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);
+                    vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);
+                    vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);
+                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);
+                })},
         };
     }
 
     interface VaListConsumer {
         void accept(CSupport.VaList list);
 
         static MethodHandle mh(VaListConsumer instance) {
             try {
                 return MethodHandles.lookup().findVirtual(VaListConsumer.class, "accept",
-                    MethodType.methodType(void.class, VaList.class)).bindTo(instance);
+                        MethodType.methodType(void.class, VaList.class)).bindTo(instance);
             } catch (ReflectiveOperationException e) {
                 throw new InternalError(e);
             }
         }
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
@@ -70,16 +70,16 @@
         }
     }
 
     //setup native memory segment
 
-    static final MemoryAddress segment_addr = MemorySegment.allocateNative(ALLOC_SIZE).address();
+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);
     static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());
 
     static {
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment_addr, (long) i, i);
+            VH_int.set(segment, (long) i, i);
         }
     }
 
     //setup direct buffer
 
@@ -98,11 +98,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int)VH_int.get(segment_addr, 0L);
+        return (int)VH_int.get(segment, 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -120,11 +120,11 @@
 
     @Benchmark
     public int segment_loop() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i++) {
-            res += (int) VH_int.get(segment_addr, (long)i);
+            res += (int) VH_int.get(segment, (long)i);
         }
         return res;
     }
 
     @Benchmark
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
@@ -71,11 +71,11 @@
 
     @Benchmark
     public void segment_loop() {
         MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.address(), (long) i, i);
+            VH_int.set(segment, (long) i, i);
         }
         segment.close();
     }
 
     @Benchmark
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
@@ -72,11 +72,11 @@
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(unsafe_addr + (i * CARRIER_SIZE) , i);
         }
         segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.address(), (long) i, i);
+            VH_int.set(segment, (long) i, i);
         }
         byteBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());
         for (int i = 0; i < ELEM_SIZE; i++) {
             byteBuffer.putInt(i * CARRIER_SIZE , i);
         }
@@ -96,11 +96,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.address(), 0L);
+        return (int) VH_int.get(segment, 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -118,39 +118,38 @@
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.address(), i);
+            res += MemoryAccess.getIntAtIndex(segment, i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            sum += (int) VH_int.get(base, (long) i);
+            sum += (int) VH_int.get(segment, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
+        MemorySegment base = segment.asSlice(0, segment.byteSize());
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
@@ -89,11 +89,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.address(), 0L);
+        return (int) VH_int.get(segment, 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -110,40 +110,39 @@
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            sum += (int) VH_int.get(base, (long) i);
+            sum += (int) VH_int.get(segment, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.address(), i);
+            res += MemoryAccess.getIntAtIndex(segment, i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
+        MemorySegment base = segment.asSlice(0, segment.byteSize());
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
@@ -113,11 +113,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.address(), 0L);
+        return (int) VH_int.get(segment, 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -134,40 +134,39 @@
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            sum += (int) VH_int.get(base, (long) i);
+            sum += (int) VH_int.get(segment, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.address(), i);
+            res += MemoryAccess.getIntAtIndex(segment, i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
+        MemorySegment base = segment.asSlice(0, segment.byteSize());
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
@@ -42,14 +42,16 @@
 import jdk.incubator.foreign.MemorySegment;
 import java.lang.invoke.VarHandle;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Optional;
+import java.util.OptionalInt;
 import java.util.Spliterator;
 import java.util.concurrent.CountedCompleter;
 import java.util.concurrent.RecursiveTask;
 import java.util.concurrent.TimeUnit;
+import java.util.function.IntFunction;
 import java.util.function.Predicate;
 import java.util.function.ToIntFunction;
 import java.util.stream.StreamSupport;
 
 import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;
@@ -83,11 +85,11 @@
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(address + (i * CARRIER_SIZE), i);
         }
         segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.address(), (long) i, i);
+            VH_int.set(segment, (long) i, i);
         }
     }
 
     @TearDown
     public void tearDown() throws Throwable {
@@ -96,13 +98,12 @@
     }
 
     @Benchmark
     public int segment_serial() {
         int res = 0;
-        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            res += (int)VH_int.get(base, (long) i);
+            res += (int)VH_int.get(segment, (long) i);
         }
         return res;
     }
 
     @Benchmark
@@ -135,17 +136,16 @@
         return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)
                 .mapToInt(SEGMENT_TO_INT_BULK).sum();
     }
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT = slice ->
-            (int) VH_int.get(slice.address(), 0L);
+            (int) VH_int.get(slice, 0L);
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT_BULK = slice -> {
         int res = 0;
-        MemoryAddress base = slice.address();
         for (int i = 0; i < BULK_FACTOR ; i++) {
-            res += (int)VH_int.get(base, (long) i);
+            res += (int)VH_int.get(slice, (long) i);
         }
         return res;
     };
 
     @Benchmark
@@ -175,16 +175,15 @@
                 .filter(FIND_BULK)
                 .findAny();
     }
 
     final static Predicate<MemorySegment> FIND_SINGLE = slice ->
-            (int)VH_int.get(slice.address(), 0L) == (ELEM_SIZE - 1);
+            (int)VH_int.get(slice, 0L) == (ELEM_SIZE - 1);
 
     final static Predicate<MemorySegment> FIND_BULK = slice -> {
-        MemoryAddress base = slice.address();
         for (int i = 0; i < BULK_FACTOR ; i++) {
-            if ((int)VH_int.get(base, (long)i) == (ELEM_SIZE - 1)) {
+            if ((int)VH_int.get(slice, (long)i) == (ELEM_SIZE - 1)) {
                 return true;
             }
         }
         return false;
     };
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
@@ -142,22 +142,20 @@
     }
 
     @Benchmark
     public int segment_loop() throws Throwable {
         int sum = 0;
-        MemoryAddress baseAddress = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            sum += (int)VH_addr_int.get(baseAddress, (long)i);
+            sum += (int)VH_addr_int.get(segment, (long)i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_box_loop() throws Throwable {
         int sum = 0;
-        MemoryAddress baseAddress = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            sum += ((IntBox)VH_addr_box_int.get(baseAddress, (long)i)).intValue();
+            sum += ((IntBox)VH_addr_box_int.get(segment, (long)i)).intValue();
         }
         return sum;
     }
 }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
@@ -66,11 +66,11 @@
         } catch (NoSuchMethodException e) {
             throw new BootstrapMethodError(e);
         }
     }
 
-    private final MemoryAddress address;
+    private final MemorySegment segment;
 
     public PanamaPoint(int x, int y) {
         this(MemorySegment.allocateNative(LAYOUT), x, y);
     }
 
@@ -79,45 +79,45 @@
         setX(x);
         setY(y);
     }
 
     public PanamaPoint(MemorySegment segment) {
-        this.address = segment.address();
+        this.segment = segment;
     }
 
     public void setX(int x) {
-        VH_x.set(address, x);
+        VH_x.set(segment, x);
     }
 
     public int getX() {
-        return (int) VH_x.get(address);
+        return (int) VH_x.get(segment);
     }
 
     public void setY(int y) {
-        VH_y.set(address, y);
+        VH_y.set(segment, y);
     }
 
     public int getY() {
-        return (int) VH_y.get(address);
+        return (int) VH_y.get(segment);
     }
 
     public double distanceTo(PanamaPoint other) {
         try {
-            return (double) MH_distance.invokeExact(address.segment(), other.address.segment());
+            return (double) MH_distance.invokeExact(segment, other.segment);
         } catch (Throwable throwable) {
             throw new InternalError(throwable);
         }
     }
 
     public double distanceToPtrs(PanamaPoint other) {
         try {
-            return (double) MH_distance_ptrs.invokeExact(address, other.address);
+            return (double) MH_distance_ptrs.invokeExact(segment.address(), other.segment.address());
         } catch (Throwable throwable) {
             throw new InternalError(throwable);
         }
     }
 
     @Override
     public void close() {
-        address.segment().close();
+        segment.close();
     }
 }

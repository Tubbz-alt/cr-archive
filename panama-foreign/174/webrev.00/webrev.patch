diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/C.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/C.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/C.java
@@ -0,0 +1,354 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.incubator.foreign;
+
+import jdk.internal.foreign.Utils;
+import jdk.internal.foreign.abi.SharedUtils;
+
+import java.nio.ByteOrder;
+
+/**
+ * A set of utilities for working with libraries using the C language/ABI
+ */
+public class C {
+    /**
+     * Obtain a linker that uses the de facto C ABI of the current system to do it's linking.
+     * <p>
+     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
+     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
+     * restricted methods, and use safe and supported functionalities, where possible.
+     * @return a linker for this system.
+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
+     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
+     */
+    public static ForeignLinker getSystemLinker() {
+        Utils.checkRestrictedAccess("C.getSystemLinker");
+        return SharedUtils.getSystemLinker();
+    }
+
+    /**
+     * The {@code _Bool} native type.
+     */
+    public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
+    /**
+     * The {@code char} native type.
+     */
+    public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
+    /**
+     * The {@code short} native type.
+     */
+    public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
+    /**
+     * The {@code int} native type.
+     */
+    public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
+    /**
+     * The {@code long} native type.
+     */
+    public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
+    /**
+     * The {@code long long} native type.
+     */
+    public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
+    /**
+     * The {@code float} native type.
+     */
+    public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
+    /**
+     * The {@code double} native type.
+     */
+    public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
+    /**
+     * The {@code long double} native type.
+     */
+    public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
+    /**
+     * The {@code T*} native type.
+     */
+    public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
+
+    /**
+     * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
+     */
+    public static final class SysV {
+        private SysV() {
+            //just the one
+        }
+
+        /**
+         * The name of the SysV linker ({@see ForeignLinker#name})
+         */
+        public static final String NAME = "SysV";
+
+        public final static String CLASS_ATTRIBUTE_NAME = "abi/sysv/class";
+
+        public enum ArgumentClass {
+            INTEGER,
+            SSE,
+            X87,
+            COMPLEX_87,
+            POINTER;
+        }
+
+        /**
+         * The {@code _Bool} native type.
+         */
+        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code char} native type.
+         */
+        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code short} native type.
+         */
+        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code int} native type.
+         */
+        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code long} native type.
+         */
+        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code long long} native type.
+         */
+        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code float} native type.
+         */
+        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
+
+        /**
+         * The {@code double} native type.
+         */
+        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
+
+        /**
+         * The {@code long double} native type.
+         */
+        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
+
+        /**
+         * The {@code complex long double} native type.
+         */
+        public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
+
+        /**
+         * The {@code T*} native type.
+         */
+        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
+    }
+
+    /**
+     * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
+     */
+    public static final class Win64 {
+
+        private Win64() {
+            //just the one
+        }
+
+        /**
+         * The name of the Windows linker ({@see ForeignLinker#name})
+         */
+        public final static String NAME = "Windows";
+
+        public final static String VARARGS_ATTRIBUTE_NAME = "abi/windows/varargs";
+
+        public final static String CLASS_ATTRIBUTE_NAME = "abi/windows/class";
+
+        public enum ArgumentClass {
+            INTEGER,
+            FLOAT,
+            POINTER;
+        }
+
+        /**
+         * The {@code _Bool} native type.
+         */
+        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code char} native type.
+         */
+        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code short} native type.
+         */
+        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code int} native type.
+         */
+        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code long} native type.
+         */
+        public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code long long} native type.
+         */
+        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code float} native type.
+         */
+        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
+
+        /**
+         * The {@code double} native type.
+         */
+        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
+
+        /**
+         * The {@code long double} native type.
+         */
+        public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
+
+        /**
+         * The {@code T*} native type.
+         */
+        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
+
+        public static ValueLayout asVarArg(ValueLayout l) {
+            return l.withAttribute(VARARGS_ATTRIBUTE_NAME, "true");
+        }
+    }
+
+    /**
+     * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
+     */
+    public static final class AArch64 {
+
+        private AArch64() {
+            //just the one
+        }
+
+        /**
+         * The name of the AArch64 linker ({@see ForeignLinker#name})
+         */
+        public final static String NAME = "AArch64";
+
+        public static final String CLASS_ATTRIBUTE_NAME = "abi/aarch64/class";
+
+        public enum ArgumentClass {
+            INTEGER,
+            VECTOR,
+            POINTER;
+        }
+
+        /**
+         * The {@code _Bool} native type.
+         */
+        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code char} native type.
+         */
+        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code short} native type.
+         */
+        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code int} native type.
+         */
+        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code long} native type.
+         */
+        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code long long} native type.
+         */
+        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code float} native type.
+         */
+        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
+
+        /**
+         * The {@code double} native type.
+         */
+        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
+
+        /**
+         * The {@code long double} native type.
+         */
+        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
+
+        /**
+         * The {@code T*} native type.
+         */
+        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ForeignLinker.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ForeignLinker.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ForeignLinker.java
@@ -0,0 +1,67 @@
+/*
+ *  Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.incubator.foreign;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+
+/**
+ * This class can be used to link native functions as a {@link MethodHandle}, or to link Java
+ * methods as a native function pointer (modelled as a {@link MemorySegment}).
+ *
+ * Instances of this interface can be obtained for instance by calling {@link C#getSystemLinker()}
+ */
+public interface ForeignLinker {
+    /**
+     * Obtain a method handle which can be used to call a given native function.
+     *
+     * @param symbol downcall symbol.
+     * @param type the method type.
+     * @param function the function descriptor.
+     * @return the downcall method handle.
+     */
+    MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function);
+
+    /**
+     * Allocates a native stub segment which contains executable code to upcall into a given method handle.
+     * As such, the base address of the returned stub segment can be passed to other foreign functions
+     * (as a function pointer). The returned segment is <em>not</em> thread-confined, and it only features
+     * the {@link MemorySegment#CLOSE} access mode. When the returned segment is closed,
+     * the corresponding native stub will be deallocated.
+     *
+     * @param target the target method handle.
+     * @param function the function descriptor.
+     * @return the native stub segment.
+     */
+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function);
+
+    /**
+     * Returns the name of this linker.
+     *
+     * @return the name
+     */
+    String name();
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java
@@ -36,11 +36,11 @@
  * A given native library remains loaded as long as there is at least one <em>live</em> library lookup instance referring
  * to it.
  * <p>
  * Memory address instances generated by a library lookup will contain a strong reference to the originating lookup object,
  * therefore preventing library unloading; in turn method handle instances obtained from
- * {@link SystemABI#downcallHandle(MemoryAddress, MethodType, FunctionDescriptor)}) also maintain a strong reference
+ * {@link ForeignLinker#downcallHandle(MemoryAddress, MethodType, FunctionDescriptor)}) also maintain a strong reference
  * to the memory address parameter used for their construction. This means that there is always a strong reachability chain
  * from a native method handle to a lookup object (the one that was used to lookup the native library symbol the method handle
  * refers to); this is useful to prevent situations where a native library is unloaded in the middle of a native call.
  * <p>
  * To allow for a library to be unloaded, a client will have to discard any strong references it
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
@@ -24,19 +24,12 @@
  *
  */
 
 package jdk.incubator.foreign;
 
-import jdk.internal.foreign.abi.SharedUtils;
-import jdk.internal.foreign.abi.x64.windows.Windowsx64ABI;
-
 import java.nio.ByteOrder;
 
-import static jdk.incubator.foreign.SystemABI.ABI_AARCH64;
-import static jdk.incubator.foreign.SystemABI.ABI_SYSV;
-import static jdk.incubator.foreign.SystemABI.ABI_WINDOWS;
-
 /**
  * This class defines useful layout constants. Some of the constants defined in this class are explicit in both
  * size and byte order (see {@link #BITS_64_BE}), and can therefore be used to explicitly and unambiguously specify the
  * contents of a memory segment. Other constants make implicit byte order assumptions (see
  * {@link #JAVA_INT}); as such, these constants make it easy to work with other serialization-centric APIs,
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
+++ /dev/null
@@ -1,422 +0,0 @@
-/*
- *  Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-package jdk.incubator.foreign;
-
-import jdk.internal.foreign.Utils;
-import jdk.internal.foreign.abi.SharedUtils;
-import jdk.internal.foreign.abi.UpcallStubs;
-import jdk.internal.foreign.abi.aarch64.AArch64ABI;
-import jdk.internal.foreign.abi.x64.sysv.SysVx64ABI;
-import jdk.internal.foreign.abi.x64.windows.Windowsx64ABI;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodType;
-import java.nio.ByteOrder;
-import java.util.Optional;
-
-/**
- * This class models a system application binary interface (ABI).
- *
- * Instances of this class can be obtained by calling {@link SystemABI#getSystemABI()}
- */
-public interface SystemABI {
-    /**
-     * The name of the SysV ABI
-     */
-    String ABI_SYSV = "SysV";
-
-    /**
-     * The name of the Windows ABI
-     */
-    String ABI_WINDOWS = "Windows";
-
-    /**
-     * The name of the AArch64 ABI
-     */
-    String ABI_AARCH64 = "AArch64";
-
-    /**
-     * memory layout attribute key for abi native type
-     */
-    String NATIVE_TYPE = "abi/native-type";
-
-    /**
-     * Obtain a method handle which can be used to call a given native function.
-     *
-     * @param symbol downcall symbol.
-     * @param type the method type.
-     * @param function the function descriptor.
-     * @return the downcall method handle.
-     */
-    MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function);
-
-    /**
-     * Allocates a native stub segment which contains executable code to upcall into a given method handle.
-     * As such, the base address of the returned stub segment can be passed to other foreign functions
-     * (as a function pointer). The returned segment is <em>not</em> thread-confined, and it only features
-     * the {@link MemorySegment#CLOSE} access mode. When the returned segment is closed,
-     * the corresponding native stub will be deallocated.
-     *
-     * @param target the target method handle.
-     * @param function the function descriptor.
-     * @return the native stub segment.
-     */
-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function);
-
-    /**
-     * Returns the name of this ABI.
-     *
-     * @return the name
-     */
-    String name();
-
-    /**
-     * The {@code _Bool} native type.
-     */
-    ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
-
-    /**
-     * The {@code char} native type.
-     */
-    ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
-
-    /**
-     * The {@code short} native type.
-     */
-    ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
-
-    /**
-     * The {@code int} native type.
-     */
-    ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
-
-    /**
-     * The {@code long} native type.
-     */
-    ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
-
-    /**
-     * The {@code long long} native type.
-     */
-    ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
-
-    /**
-     * The {@code float} native type.
-     */
-    ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
-
-    /**
-     * The {@code double} native type.
-     */
-    ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
-
-    /**
-     * The {@code long double} native type.
-     */
-    ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
-
-    /**
-     * The {@code T*} native type.
-     */
-    ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
-
-    /**
-     * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
-     */
-    final class SysV {
-        private SysV() {
-            //just the one
-        }
-
-        /**
-         * The name of the SysV ABI
-         */
-        public static final String NAME = "SysV";
-
-        public final static String CLASS_ATTRIBUTE_NAME = "abi/sysv/class";
-
-        public enum ArgumentClass {
-            INTEGER,
-            SSE,
-            X87,
-            COMPLEX_87,
-            POINTER;
-        }
-
-        /**
-         * The {@code _Bool} native type.
-         */
-        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code char} native type.
-         */
-        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code short} native type.
-         */
-        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code int} native type.
-         */
-        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code long} native type.
-         */
-        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code long long} native type.
-         */
-        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code float} native type.
-         */
-        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
-
-        /**
-         * The {@code double} native type.
-         */
-        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
-
-        /**
-         * The {@code long double} native type.
-         */
-        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
-
-        /**
-         * The {@code complex long double} native type.
-         */
-        public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
-
-        /**
-         * The {@code T*} native type.
-         */
-        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
-    }
-
-    /**
-     * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
-     */
-    final class Win64 {
-
-        private Win64() {
-            //just the one
-        }
-
-        /**
-         * The name of the Windows ABI
-         */
-        public final static String NAME = "Windows";
-
-        public final static String VARARGS_ATTRIBUTE_NAME = "abi/windows/varargs";
-
-        public final static String CLASS_ATTRIBUTE_NAME = "abi/windows/class";
-
-        public enum ArgumentClass {
-            INTEGER,
-            FLOAT,
-            POINTER;
-        }
-
-        /**
-         * The {@code _Bool} native type.
-         */
-        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code char} native type.
-         */
-        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code short} native type.
-         */
-        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code int} native type.
-         */
-        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code long} native type.
-         */
-        public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code long long} native type.
-         */
-        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code float} native type.
-         */
-        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
-
-        /**
-         * The {@code double} native type.
-         */
-        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
-
-        /**
-         * The {@code long double} native type.
-         */
-        public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
-
-        /**
-         * The {@code T*} native type.
-         */
-        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
-
-        public static ValueLayout asVarArg(ValueLayout l) {
-            return l.withAttribute(VARARGS_ATTRIBUTE_NAME, "true");
-        }
-    }
-
-    /**
-     * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
-     */
-    final class AArch64 {
-
-        private AArch64() {
-            //just the one
-        }
-
-        /**
-         * The name of the AArch64 ABI
-         */
-        public final static String NAME = "AArch64";
-
-        public static final String CLASS_ATTRIBUTE_NAME = "abi/aarch64/class";
-
-        public enum ArgumentClass {
-            INTEGER,
-            VECTOR,
-            POINTER;
-        }
-
-        /**
-         * The {@code _Bool} native type.
-         */
-        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code char} native type.
-         */
-        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code short} native type.
-         */
-        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code int} native type.
-         */
-        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code long} native type.
-         */
-        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code long long} native type.
-         */
-        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
-
-        /**
-         * The {@code float} native type.
-         */
-        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
-
-        /**
-         * The {@code double} native type.
-         */
-        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
-
-        /**
-         * The {@code long double} native type.
-         */
-        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
-
-        /**
-         * The {@code T*} native type.
-         */
-        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
-    }
-
-    /**
-     * Obtain an instance of the system ABI.
-     * <p>
-     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
-     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
-     * restricted methods, and use safe and supported functionalities, where possible.
-     * @return system ABI.
-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
-     */
-    static SystemABI getSystemABI() {
-        Utils.checkRestrictedAccess("SystemABI.getSystemABI");
-        return SharedUtils.getSystemABI();
-    }
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -24,15 +24,15 @@
  *
  */
 
 package jdk.internal.foreign;
 
-import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.C;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.access.foreign.MemoryAddressProxy;
 import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.misc.VM;
 import sun.invoke.util.Wrapper;
@@ -105,15 +105,15 @@
         throw new IllegalAccessError("Illegal access to restricted foreign method: " + method +
                 " ; system property 'foreign.restricted' is set to '" + value + "'");
     }
 
     public static <Z extends MemoryLayout> Z pick(Z sysv, Z win64, Z aarch64) {
-        SystemABI abi = SharedUtils.getSystemABI();
+        ForeignLinker abi = SharedUtils.getSystemLinker();
         return switch (abi.name()) {
-            case SystemABI.SysV.NAME -> sysv;
-            case SystemABI.Win64.NAME -> win64;
-            case SystemABI.AArch64.NAME -> aarch64;
+            case C.SysV.NAME -> sysv;
+            case C.Win64.NAME -> win64;
+            case C.AArch64.NAME -> aarch64;
             default -> throw new ExceptionInInitializerError("Unexpected ABI: " + abi.name());
         };
     }
 
     public static void checkPrimitiveCarrierCompat(Class<?> carrier, MemoryLayout layout) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -22,23 +22,23 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi;
 
+import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
-import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.Utils;
-import jdk.internal.foreign.abi.aarch64.AArch64ABI;
-import jdk.internal.foreign.abi.x64.sysv.SysVx64ABI;
-import jdk.internal.foreign.abi.x64.windows.Windowsx64ABI;
+import jdk.internal.foreign.abi.aarch64.AArch64Linker;
+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;
+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.util.List;
@@ -226,20 +226,20 @@
         }
 
         throw new IllegalArgumentException("Size too large: " + size);
     }
 
-    public static SystemABI getSystemABI() {
+    public static ForeignLinker getSystemLinker() {
         String arch = System.getProperty("os.arch");
         String os = System.getProperty("os.name");
         if (arch.equals("amd64") || arch.equals("x86_64")) {
             if (os.startsWith("Windows")) {
-                return Windowsx64ABI.getInstance();
+                return Windowsx64Linker.getInstance();
             } else {
-                return SysVx64ABI.getInstance();
+                return SysVx64Linker.getInstance();
             }
         } else if (arch.equals("aarch64")) {
-            return AArch64ABI.getInstance();
+            return AArch64Linker.getInstance();
         }
         throw new UnsupportedOperationException("Unsupported os or arch: " + os + ", " + arch);
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Arm Limited. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.internal.foreign.abi.aarch64;
-
-import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SystemABI;
-import jdk.internal.foreign.abi.*;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodType;
-
-/**
- * ABI implementation based on ARM document "Procedure Call Standard for
- * the ARM 64-bit Architecture".
- */
-public class AArch64ABI implements SystemABI {
-    private static AArch64ABI instance;
-
-    static final long ADDRESS_SIZE = 64; // bits
-
-    public static AArch64ABI getInstance() {
-        if (instance == null) {
-            instance = new AArch64ABI();
-        }
-        return instance;
-    }
-
-    @Override
-    public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        return CallArranger.arrangeDowncall(symbol, type, function);
-    }
-
-    @Override
-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {
-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
-    }
-
-    @Override
-    public String name() {
-        return AArch64.NAME;
-    }
-
-    static AArch64.ArgumentClass argumentClassFor(MemoryLayout layout) {
-        return (AArch64.ArgumentClass)layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get();
-    }
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Arm Limited. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.foreign.abi.aarch64;
+
+import jdk.incubator.foreign.ForeignLinker;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.foreign.abi.UpcallStubs;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+
+import static jdk.incubator.foreign.C.*;
+
+/**
+ * ABI implementation based on ARM document "Procedure Call Standard for
+ * the ARM 64-bit Architecture".
+ */
+public class AArch64Linker implements ForeignLinker {
+    private static AArch64Linker instance;
+
+    static final long ADDRESS_SIZE = 64; // bits
+
+    public static AArch64Linker getInstance() {
+        if (instance == null) {
+            instance = new AArch64Linker();
+        }
+        return instance;
+    }
+
+    @Override
+    public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+        return CallArranger.arrangeDowncall(symbol, type, function);
+    }
+
+    @Override
+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {
+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
+    }
+
+    @Override
+    public String name() {
+        return AArch64.NAME;
+    }
+
+    static AArch64.ArgumentClass argumentClassFor(MemoryLayout layout) {
+        return (AArch64.ArgumentClass)layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get();
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
@@ -25,14 +25,12 @@
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
-import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.CallingSequenceBuilder;
 import jdk.internal.foreign.abi.UpcallHandler;
 import jdk.internal.foreign.abi.ABIDescriptor;
@@ -46,10 +44,11 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
 import java.util.List;
 import java.util.Optional;
 
+import static jdk.incubator.foreign.C.*;
 import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;
 
 /**
  * For the AArch64 C ABI specifically, this class uses the ProgrammableInvoker API, namely CallingSequenceBuilder2
  * to translate a C FunctionDescriptor into a CallingSequence2, which can then be turned into a MethodHandle.
@@ -96,20 +95,20 @@
             this.isInMemoryReturn = isInMemoryReturn;
         }
     }
 
     public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {
-        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64ABI.ADDRESS_SIZE);
+        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64Linker.ADDRESS_SIZE);
 
         CallingSequenceBuilder csb = new CallingSequenceBuilder(forUpcall);
 
         BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);
         BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);
 
         boolean returnInMemory = isInMemoryReturn(cDesc.returnLayout());
         if (returnInMemory) {
-            csb.addArgumentBindings(MemoryAddress.class, SystemABI.AArch64.C_POINTER,
+            csb.addArgumentBindings(MemoryAddress.class, AArch64.C_POINTER,
                     argCalc.getIndirectBindings());
         } else if (cDesc.returnLayout().isPresent()) {
             Class<?> carrier = mt.returnType();
             MemoryLayout layout = cDesc.returnLayout().get();
             csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout));
@@ -161,21 +160,21 @@
         INTEGER,
         FLOAT,
     }
 
     private static TypeClass classifyValueType(ValueLayout type) {
-        SystemABI.AArch64.ArgumentClass clazz = AArch64ABI.argumentClassFor(type);
+        AArch64.ArgumentClass clazz = AArch64Linker.argumentClassFor(type);
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
 
-        if (clazz == SystemABI.AArch64.ArgumentClass.INTEGER) {
+        if (clazz == AArch64.ArgumentClass.INTEGER) {
             return TypeClass.INTEGER;
-        } else if(clazz == SystemABI.AArch64.ArgumentClass.POINTER) {
+        } else if(clazz == AArch64.ArgumentClass.POINTER) {
             return TypeClass.POINTER;
-        } else if (clazz == SystemABI.AArch64.ArgumentClass.VECTOR) {
+        } else if (clazz == AArch64.ArgumentClass.VECTOR) {
             return TypeClass.FLOAT;
         }
         throw new IllegalArgumentException("Unknown ABI class: " + clazz);
     }
 
@@ -196,19 +195,19 @@
         MemoryLayout baseType = groupLayout.memberLayouts().get(0);
 
         if (!(baseType instanceof ValueLayout))
             return false;
 
-        SystemABI.AArch64.ArgumentClass baseArgClass = AArch64ABI.argumentClassFor(baseType);
-        if (baseArgClass != SystemABI.AArch64.ArgumentClass.VECTOR)
+        AArch64.ArgumentClass baseArgClass = AArch64Linker.argumentClassFor(baseType);
+        if (baseArgClass != AArch64.ArgumentClass.VECTOR)
            return false;
 
         for (MemoryLayout elem : groupLayout.memberLayouts()) {
             if (!(elem instanceof ValueLayout))
                 return false;
 
-            SystemABI.AArch64.ArgumentClass argClass = AArch64ABI.argumentClassFor(elem);
+            AArch64.ArgumentClass argClass = AArch64Linker.argumentClassFor(elem);
             if (elem.bitSize() != baseType.bitSize() ||
                     elem.bitAlignment() != baseType.bitAlignment() ||
                     baseArgClass != argClass) {
                 return false;
             }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -29,11 +29,10 @@
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
-import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.CallingSequenceBuilder;
 import jdk.internal.foreign.abi.UpcallHandler;
 import jdk.internal.foreign.abi.ABIDescriptor;
@@ -52,15 +51,16 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
+import static jdk.incubator.foreign.C.*;
 import static jdk.internal.foreign.abi.Binding.*;
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
-import static jdk.internal.foreign.abi.x64.sysv.SysVx64ABI.MAX_INTEGER_ARGUMENT_REGISTERS;
-import static jdk.internal.foreign.abi.x64.sysv.SysVx64ABI.MAX_VECTOR_ARGUMENT_REGISTERS;
-import static jdk.internal.foreign.abi.x64.sysv.SysVx64ABI.argumentClassFor;
+import static jdk.internal.foreign.abi.x64.sysv.SysVx64Linker.MAX_INTEGER_ARGUMENT_REGISTERS;
+import static jdk.internal.foreign.abi.x64.sysv.SysVx64Linker.MAX_VECTOR_ARGUMENT_REGISTERS;
+import static jdk.internal.foreign.abi.x64.sysv.SysVx64Linker.argumentClassFor;
 
 /**
  * For the SysV x64 C ABI specifically, this class uses the ProgrammableInvoker API, namely CallingSequenceBuilder2
  * to translate a C FunctionDescriptor into a CallingSequence, which can then be turned into a MethodHandle.
  *
@@ -91,21 +91,21 @@
             this.nVectorArgs = nVectorArgs;
         }
     }
 
     public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {
-        SharedUtils.checkFunctionTypes(mt, cDesc, SysVx64ABI.ADDRESS_SIZE);
+        SharedUtils.checkFunctionTypes(mt, cDesc, SysVx64Linker.ADDRESS_SIZE);
 
         CallingSequenceBuilder csb = new CallingSequenceBuilder(forUpcall);
 
         BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);
         BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);
 
         boolean returnInMemory = isInMemoryReturn(cDesc.returnLayout());
         if (returnInMemory) {
             Class<?> carrier = MemoryAddress.class;
-            MemoryLayout layout = SystemABI.SysV.C_POINTER;
+            MemoryLayout layout = SysV.C_POINTER;
             csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout));
         } else if (cDesc.returnLayout().isPresent()) {
             Class<?> carrier = mt.returnType();
             MemoryLayout layout = cDesc.returnLayout().get();
             csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout));
@@ -117,11 +117,11 @@
             csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout));
         }
 
         if (!forUpcall) {
             //add extra binding for number of used vector registers (used for variadic calls)
-            csb.addArgumentBindings(long.class, SystemABI.SysV.C_LONG,
+            csb.addArgumentBindings(long.class, SysV.C_LONG,
                     List.of(move(rax, long.class)));
         }
 
         return new Bindings(csb.build(), returnInMemory, argCalc.storageCalculator.nVectorReg);
     }
@@ -210,11 +210,11 @@
         }
 
         private int maxRegisterArguments(int type) {
             return type == StorageClasses.INTEGER ?
                     MAX_INTEGER_ARGUMENT_REGISTERS :
-                    SysVx64ABI.MAX_VECTOR_ARGUMENT_REGISTERS;
+                    SysVx64Linker.MAX_VECTOR_ARGUMENT_REGISTERS;
         }
 
         VMStorage stackAlloc() {
             assert forArguments : "no stack returns";
             VMStorage storage = X86_64Architecture.stackStorage((int)stackOffset);
@@ -425,11 +425,11 @@
     // TODO: handle '__int128' and 'long double'
     private static ArgumentClassImpl classifyValueType(ValueLayout type) {
         if (type.byteSize() > 8) {
             throw new IllegalStateException("");
         }
-        ArgumentClassImpl clazz = SysVx64ABI.argumentClassFor(type)
+        ArgumentClassImpl clazz = SysVx64Linker.argumentClassFor(type)
                 .orElseThrow(() -> new IllegalStateException("Unexpected value layout: could not determine ABI class"));
         return clazz;
     }
 
     // TODO: handle zero length arrays
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.internal.foreign.abi.x64.sysv;
-
-import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SystemABI;
-import jdk.internal.foreign.abi.*;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodType;
-import java.util.Optional;
-
-/**
- * ABI implementation based on System V ABI AMD64 supplement v.0.99.6
- */
-public class SysVx64ABI implements SystemABI {
-    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 6;
-    public static final int MAX_INTEGER_RETURN_REGISTERS = 2;
-    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 8;
-    public static final int MAX_VECTOR_RETURN_REGISTERS = 2;
-    public static final int MAX_X87_RETURN_REGISTERS = 2;
-
-    private static SysVx64ABI instance;
-
-    static final long ADDRESS_SIZE = 64; // bits
-
-    public static SysVx64ABI getInstance() {
-        if (instance == null) {
-            instance = new SysVx64ABI();
-        }
-        return instance;
-    }
-
-    @Override
-    public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        return CallArranger.arrangeDowncall(symbol, type, function);
-    }
-
-    @Override
-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {
-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
-    }
-
-    @Override
-    public String name() {
-        return SysV.NAME;
-    }
-
-    static Optional<ArgumentClassImpl> argumentClassFor(MemoryLayout layout) {
-        @SuppressWarnings({"unchecked", "rawtypes"})
-        Optional<SysV.ArgumentClass> argClassOpt =
-                (Optional<SysV.ArgumentClass>)(Optional)layout.attribute(SysV.CLASS_ATTRIBUTE_NAME);
-        return argClassOpt.map(argClass -> switch (argClass) {
-            case INTEGER -> ArgumentClassImpl.INTEGER;
-            case SSE -> ArgumentClassImpl.SSE;
-            case X87 -> ArgumentClassImpl.X87;
-            case COMPLEX_87 -> ArgumentClassImpl.COMPLEX_X87;
-            case POINTER -> ArgumentClassImpl.POINTER;
-            default -> null;
-        });
-    }
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.foreign.abi.x64.sysv;
+
+import jdk.incubator.foreign.ForeignLinker;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.foreign.abi.UpcallStubs;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.util.Optional;
+
+import static jdk.incubator.foreign.C.*;
+
+/**
+ * ABI implementation based on System V ABI AMD64 supplement v.0.99.6
+ */
+public class SysVx64Linker implements ForeignLinker {
+    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 6;
+    public static final int MAX_INTEGER_RETURN_REGISTERS = 2;
+    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 8;
+    public static final int MAX_VECTOR_RETURN_REGISTERS = 2;
+    public static final int MAX_X87_RETURN_REGISTERS = 2;
+
+    private static SysVx64Linker instance;
+
+    static final long ADDRESS_SIZE = 64; // bits
+
+    public static SysVx64Linker getInstance() {
+        if (instance == null) {
+            instance = new SysVx64Linker();
+        }
+        return instance;
+    }
+
+    @Override
+    public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+        return CallArranger.arrangeDowncall(symbol, type, function);
+    }
+
+    @Override
+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {
+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
+    }
+
+    @Override
+    public String name() {
+        return SysV.NAME;
+    }
+
+    static Optional<ArgumentClassImpl> argumentClassFor(MemoryLayout layout) {
+        @SuppressWarnings({"unchecked", "rawtypes"})
+        Optional<SysV.ArgumentClass> argClassOpt =
+                (Optional<SysV.ArgumentClass>)(Optional)layout.attribute(SysV.CLASS_ATTRIBUTE_NAME);
+        return argClassOpt.map(argClass -> switch (argClass) {
+            case INTEGER -> ArgumentClassImpl.INTEGER;
+            case SSE -> ArgumentClassImpl.SSE;
+            case X87 -> ArgumentClassImpl.X87;
+            case COMPLEX_87 -> ArgumentClassImpl.COMPLEX_X87;
+            case POINTER -> ArgumentClassImpl.POINTER;
+            default -> null;
+        });
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
@@ -26,11 +26,10 @@
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
-import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.CallingSequenceBuilder;
 import jdk.internal.foreign.abi.UpcallHandler;
 import jdk.internal.foreign.abi.ABIDescriptor;
@@ -45,11 +44,12 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
 import java.util.List;
 import java.util.Optional;
 
-import static jdk.incubator.foreign.SystemABI.Win64.VARARGS_ATTRIBUTE_NAME;
+import static jdk.incubator.foreign.C.*;
+import static jdk.incubator.foreign.C.Win64.VARARGS_ATTRIBUTE_NAME;
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
 
 /**
  * For the Windowx x64 C ABI specifically, this class uses the ProgrammableInvoker API, namely CallingSequenceBuilder2
  * to translate a C FunctionDescriptor into a CallingSequence2, which can then be turned into a MethodHandle.
@@ -81,11 +81,11 @@
             this.isInMemoryReturn = isInMemoryReturn;
         }
     }
 
     public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {
-        SharedUtils.checkFunctionTypes(mt, cDesc, Windowsx64ABI.ADDRESS_SIZE);
+        SharedUtils.checkFunctionTypes(mt, cDesc, Windowsx64Linker.ADDRESS_SIZE);
 
         class CallingSequenceBuilderHelper {
             final CallingSequenceBuilder csb = new CallingSequenceBuilder(forUpcall);
             final BindingCalculator argCalc =
                 forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);
@@ -103,11 +103,11 @@
         var csb = new CallingSequenceBuilderHelper();
 
         boolean returnInMemory = isInMemoryReturn(cDesc.returnLayout());
         if (returnInMemory) {
             Class<?> carrier = MemoryAddress.class;
-            MemoryLayout layout = SystemABI.Win64.C_POINTER;
+            MemoryLayout layout = Win64.C_POINTER;
             csb.addArgumentBindings(carrier, layout);
             if (forUpcall) {
                 csb.setReturnBindings(carrier, layout);
             }
         } else if (cDesc.returnLayout().isPresent()) {
@@ -158,11 +158,11 @@
         FLOAT,
         VARARG_FLOAT
     }
 
     private static TypeClass classifyValueType(ValueLayout type) {
-        SystemABI.Win64.ArgumentClass clazz = Windowsx64ABI.argumentClassFor(type);
+        Win64.ArgumentClass clazz = Windowsx64Linker.argumentClassFor(type);
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
 
@@ -173,15 +173,15 @@
         // x87 is ignored on Windows:
         // "The x87 register stack is unused, and may be used by the callee,
         // but must be considered volatile across function calls."
         // https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019
 
-        if (clazz == SystemABI.Win64.ArgumentClass.INTEGER) {
+        if (clazz == Win64.ArgumentClass.INTEGER) {
             return TypeClass.INTEGER;
-        } else if(clazz == SystemABI.Win64.ArgumentClass.POINTER) {
+        } else if(clazz == Win64.ArgumentClass.POINTER) {
             return TypeClass.POINTER;
-        } else if (clazz == SystemABI.Win64.ArgumentClass.FLOAT) {
+        } else if (clazz == Win64.ArgumentClass.FLOAT) {
             if (type.attribute(VARARGS_ATTRIBUTE_NAME)
                     .map(String.class::cast)
                     .map(Boolean::parseBoolean).orElse(false)) {
                 return TypeClass.VARARG_FLOAT;
             }
@@ -226,11 +226,11 @@
         public StorageCalculator(boolean forArguments) {
             this.forArguments = forArguments;
         }
 
         VMStorage nextStorage(int type, MemoryLayout layout) {
-            if (nRegs >= Windowsx64ABI.MAX_REGISTER_ARGUMENTS) {
+            if (nRegs >= Windowsx64Linker.MAX_REGISTER_ARGUMENTS) {
                 assert forArguments : "no stack returns";
                 // stack
                 long alignment = Math.max(SharedUtils.alignment(layout, true), STACK_SLOT_SIZE);
                 stackOffset = Utils.alignUp(stackOffset, alignment);
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.internal.foreign.abi.x64.windows;
-
-import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SystemABI;
-import jdk.internal.foreign.abi.x64.sysv.ArgumentClassImpl;
-import jdk.internal.foreign.abi.*;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodType;
-
-/**
- * ABI implementation based on Windows ABI AMD64 supplement v.0.99.6
- */
-public class Windowsx64ABI implements SystemABI {
-
-    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 4;
-    public static final int MAX_INTEGER_RETURN_REGISTERS = 1;
-    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 4;
-    public static final int MAX_VECTOR_RETURN_REGISTERS = 1;
-    public static final int MAX_REGISTER_ARGUMENTS = 4;
-    public static final int MAX_REGISTER_RETURNS = 1;
-
-    private static Windowsx64ABI instance;
-
-    static final long ADDRESS_SIZE = 64; // bits
-
-    public static Windowsx64ABI getInstance() {
-        if (instance == null) {
-            instance = new Windowsx64ABI();
-        }
-        return instance;
-    }
-
-    @Override
-    public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        return CallArranger.arrangeDowncall(symbol, type, function);
-    }
-
-    @Override
-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {
-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
-    }
-
-    @Override
-    public String name() {
-        return Win64.NAME;
-    }
-
-    static Win64.ArgumentClass argumentClassFor(MemoryLayout layout) {
-        return (Win64.ArgumentClass)layout.attribute(Win64.CLASS_ATTRIBUTE_NAME).get();
-    }
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.foreign.abi.x64.windows;
+
+import jdk.incubator.foreign.ForeignLinker;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.foreign.abi.UpcallStubs;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+
+import static jdk.incubator.foreign.C.*;
+
+/**
+ * ABI implementation based on Windows ABI AMD64 supplement v.0.99.6
+ */
+public class Windowsx64Linker implements ForeignLinker {
+
+    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 4;
+    public static final int MAX_INTEGER_RETURN_REGISTERS = 1;
+    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 4;
+    public static final int MAX_VECTOR_RETURN_REGISTERS = 1;
+    public static final int MAX_REGISTER_ARGUMENTS = 4;
+    public static final int MAX_REGISTER_RETURNS = 1;
+
+    private static Windowsx64Linker instance;
+
+    static final long ADDRESS_SIZE = 64; // bits
+
+    public static Windowsx64Linker getInstance() {
+        if (instance == null) {
+            instance = new Windowsx64Linker();
+        }
+        return instance;
+    }
+
+    @Override
+    public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+        return CallArranger.arrangeDowncall(symbol, type, function);
+    }
+
+    @Override
+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {
+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
+    }
+
+    @Override
+    public String name() {
+        return Win64.NAME;
+    }
+
+    static Win64.ArgumentClass argumentClassFor(MemoryLayout layout) {
+        return (Win64.ArgumentClass)layout.attribute(Win64.CLASS_ATTRIBUTE_NAME).get();
+    }
+}
diff a/test/jdk/java/foreign/CallGeneratorHelper.java b/test/jdk/java/foreign/CallGeneratorHelper.java
--- a/test/jdk/java/foreign/CallGeneratorHelper.java
+++ b/test/jdk/java/foreign/CallGeneratorHelper.java
@@ -36,11 +36,11 @@
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
 import org.testng.annotations.*;
 
-import static jdk.incubator.foreign.SystemABI.*;
+import static jdk.incubator.foreign.C.*;
 import static org.testng.Assert.*;
 
 public class CallGeneratorHelper extends NativeTestHelper {
 
     static final int MAX_FIELDS = 3;
diff a/test/jdk/java/foreign/Cstring.java b/test/jdk/java/foreign/Cstring.java
--- a/test/jdk/java/foreign/Cstring.java
+++ b/test/jdk/java/foreign/Cstring.java
@@ -25,11 +25,11 @@
 import java.nio.charset.Charset;
 import jdk.incubator.foreign.NativeAllocationScope;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
-import static jdk.incubator.foreign.SystemABI.C_CHAR;
+import static jdk.incubator.foreign.C.C_CHAR;
 
 public final class Cstring {
     // don't create!
     private Cstring() {
     }
diff a/test/jdk/java/foreign/NativeTestHelper.java b/test/jdk/java/foreign/NativeTestHelper.java
--- a/test/jdk/java/foreign/NativeTestHelper.java
+++ b/test/jdk/java/foreign/NativeTestHelper.java
@@ -20,35 +20,36 @@
  *  or visit www.oracle.com if you need additional information or have any
  *  questions.
  *
  */
 
+import jdk.incubator.foreign.C;
+import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
 
 public class NativeTestHelper {
 
-    public static final SystemABI ABI = SystemABI.getSystemABI();
+    public static final ForeignLinker ABI = C.getSystemLinker();
 
     public static boolean isIntegral(MemoryLayout layout) {
         return switch (ABI.name()) {
-            case SystemABI.SysV.NAME -> layout.attribute(SystemABI.SysV.CLASS_ATTRIBUTE_NAME).get() == SystemABI.SysV.ArgumentClass.INTEGER;
-            case SystemABI.Win64.NAME -> layout.attribute(SystemABI.Win64.CLASS_ATTRIBUTE_NAME).get() == SystemABI.Win64.ArgumentClass.INTEGER;
-            case SystemABI.AArch64.NAME -> layout.attribute(SystemABI.AArch64.CLASS_ATTRIBUTE_NAME).get() == SystemABI.AArch64.ArgumentClass.INTEGER;
+            case C.SysV.NAME -> layout.attribute(C.SysV.CLASS_ATTRIBUTE_NAME).get() == C.SysV.ArgumentClass.INTEGER;
+            case C.Win64.NAME -> layout.attribute(C.Win64.CLASS_ATTRIBUTE_NAME).get() == C.Win64.ArgumentClass.INTEGER;
+            case C.AArch64.NAME -> layout.attribute(C.AArch64.CLASS_ATTRIBUTE_NAME).get() == C.AArch64.ArgumentClass.INTEGER;
             default -> throw new AssertionError("unexpected ABI: " + ABI.name());
         };
     }
 
     public static boolean isPointer(MemoryLayout layout) {
         return switch (ABI.name()) {
-            case SystemABI.SysV.NAME -> layout.attribute(SystemABI.SysV.CLASS_ATTRIBUTE_NAME).get() == SystemABI.SysV.ArgumentClass.POINTER;
-            case SystemABI.Win64.NAME -> layout.attribute(SystemABI.Win64.CLASS_ATTRIBUTE_NAME).get() == SystemABI.Win64.ArgumentClass.POINTER;
-            case SystemABI.AArch64.NAME -> layout.attribute(SystemABI.AArch64.CLASS_ATTRIBUTE_NAME).get() == SystemABI.AArch64.ArgumentClass.POINTER;
+            case C.SysV.NAME -> layout.attribute(C.SysV.CLASS_ATTRIBUTE_NAME).get() == C.SysV.ArgumentClass.POINTER;
+            case C.Win64.NAME -> layout.attribute(C.Win64.CLASS_ATTRIBUTE_NAME).get() == C.Win64.ArgumentClass.POINTER;
+            case C.AArch64.NAME -> layout.attribute(C.AArch64.CLASS_ATTRIBUTE_NAME).get() == C.AArch64.ArgumentClass.POINTER;
             default -> throw new AssertionError("unexpected ABI: " + ABI.name());
         };
     }
 
     public static ValueLayout asVarArg(ValueLayout layout) {
-        return ABI.name().equals(SystemABI.Win64.NAME) ? SystemABI.Win64.asVarArg(layout) : layout;
+        return ABI.name().equals(C.Win64.NAME) ? C.Win64.asVarArg(layout) : layout;
     }
 }
diff a/test/jdk/java/foreign/StdLibTest.java b/test/jdk/java/foreign/StdLibTest.java
--- a/test/jdk/java/foreign/StdLibTest.java
+++ b/test/jdk/java/foreign/StdLibTest.java
@@ -49,27 +49,28 @@
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.LongStream;
 import java.util.stream.Stream;
 
+import jdk.incubator.foreign.C;
+import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
-import jdk.incubator.foreign.SystemABI;
 import org.testng.annotations.*;
 
-import static jdk.incubator.foreign.SystemABI.*;
+import static jdk.incubator.foreign.C.*;
 import static org.testng.Assert.*;
 
 @Test
 public class StdLibTest extends NativeTestHelper {
 
-    final static SystemABI abi = SystemABI.getSystemABI();
+    final static ForeignLinker abi = C.getSystemLinker();
 
     final static VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
     final static VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
     final static VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
     final static VarHandle byteArrHandle = arrayHandle(C_CHAR, byte.class);
diff a/test/jdk/java/foreign/TestCircularInit1.java b/test/jdk/java/foreign/TestCircularInit1.java
--- a/test/jdk/java/foreign/TestCircularInit1.java
+++ b/test/jdk/java/foreign/TestCircularInit1.java
@@ -25,19 +25,19 @@
  * @test
  * @modules jdk.incubator.foreign
  * @run testng/othervm TestCircularInit1
  */
 
-import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.C;
 import org.testng.annotations.Test;
 
 import static org.testng.Assert.assertNotNull;
 
 public class TestCircularInit1 {
 
     @Test
     public void testCircularInit() {
-        System.out.println(SystemABI.C_BOOL); // trigger clinit
-        assertNotNull(SystemABI.C_BOOL); // should not be null
+        System.out.println(C.C_BOOL); // trigger clinit
+        assertNotNull(C.C_BOOL); // should not be null
     }
 
 }
diff a/test/jdk/java/foreign/TestCircularInit2.java b/test/jdk/java/foreign/TestCircularInit2.java
--- a/test/jdk/java/foreign/TestCircularInit2.java
+++ b/test/jdk/java/foreign/TestCircularInit2.java
@@ -25,21 +25,21 @@
  * @test
  * @modules jdk.incubator.foreign
  * @run testng/othervm TestCircularInit2
  */
 
-import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.C;
 import org.testng.annotations.Test;
 
 import static org.testng.Assert.assertNotNull;
 
 public class TestCircularInit2 {
 
     @Test
     public void testCircularInit() {
-        System.out.println(SystemABI.C_BOOL); // trigger clinit
-        assertNotNull(SystemABI.C_BOOL);
-        assertNotNull(SystemABI.C_BOOL);
-        assertNotNull(SystemABI.C_BOOL);
+        System.out.println(C.C_BOOL); // trigger clinit
+        assertNotNull(C.C_BOOL);
+        assertNotNull(C.C_BOOL);
+        assertNotNull(C.C_BOOL);
     }
 
 }
diff a/test/jdk/java/foreign/TestDowncall.java b/test/jdk/java/foreign/TestDowncall.java
--- a/test/jdk/java/foreign/TestDowncall.java
+++ b/test/jdk/java/foreign/TestDowncall.java
@@ -31,30 +31,29 @@
  * @build NativeTestHelper CallGeneratorHelper TestDowncall
  *
  * @run testng/othervm -Dforeign.restricted=permit TestDowncall
  */
 
+import jdk.incubator.foreign.C;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.ForeignLinker;
 
 import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Consumer;
 
 import org.testng.annotations.*;
-import static org.testng.Assert.*;
 
 public class TestDowncall extends CallGeneratorHelper {
 
     static LibraryLookup lib = LibraryLookup.ofLibrary("TestDowncall");
-    static SystemABI abi = SystemABI.getSystemABI();
+    static ForeignLinker abi = C.getSystemLinker();
 
 
     @Test(dataProvider="functions", dataProviderClass=CallGeneratorHelper.class)
     public void testDowncall(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {
         List<Consumer<Object>> checks = new ArrayList<>();
diff a/test/jdk/java/foreign/TestIllegalLink.java b/test/jdk/java/foreign/TestIllegalLink.java
--- a/test/jdk/java/foreign/TestIllegalLink.java
+++ b/test/jdk/java/foreign/TestIllegalLink.java
@@ -26,29 +26,30 @@
  * @test
  *
  * @run testng/othervm -Dforeign.restricted=permit TestIllegalLink
  */
 
+import jdk.incubator.foreign.C;
+import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SystemABI;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodType;
 
-import static jdk.incubator.foreign.SystemABI.C_INT;
+import static jdk.incubator.foreign.C.C_INT;
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
 public class TestIllegalLink {
 
     private static final MemoryAddress dummyTarget = MemoryAddress.NULL;
-    private static final SystemABI ABI = SystemABI.getSystemABI();
+    private static final ForeignLinker ABI = C.getSystemLinker();
 
     @Test(dataProvider = "types")
     public void testTypeMismatch(MethodType mt, FunctionDescriptor desc, String expectedExceptionMessage) {
         try {
             ABI.downcallHandle(dummyTarget, mt, desc);
diff a/test/jdk/java/foreign/TestUpcall.java b/test/jdk/java/foreign/TestUpcall.java
--- a/test/jdk/java/foreign/TestUpcall.java
+++ b/test/jdk/java/foreign/TestUpcall.java
@@ -31,42 +31,42 @@
  * @build NativeTestHelper CallGeneratorHelper TestUpcall
  *
  * @run testng/othervm -Dforeign.restricted=permit TestUpcall
  */
 
+import jdk.incubator.foreign.C;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.ValueLayout;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
-import java.lang.ref.Cleaner;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 import java.util.stream.Collectors;
 
 import static java.lang.invoke.MethodHandles.insertArguments;
-import static jdk.incubator.foreign.SystemABI.C_POINTER;
+import static jdk.incubator.foreign.C.C_POINTER;
 import static org.testng.Assert.assertEquals;
 
 
 public class TestUpcall extends CallGeneratorHelper {
 
     static LibraryLookup lib = LibraryLookup.ofLibrary("TestUpcall");
-    static SystemABI abi = SystemABI.getSystemABI();
+    static ForeignLinker abi = C.getSystemLinker();
 
     static MethodHandle DUMMY;
     static MethodHandle PASS_AND_SAVE;
 
     static {
diff a/test/jdk/java/foreign/TestUpcallStubs.java b/test/jdk/java/foreign/TestUpcallStubs.java
--- a/test/jdk/java/foreign/TestUpcallStubs.java
+++ b/test/jdk/java/foreign/TestUpcallStubs.java
@@ -25,14 +25,15 @@
 /*
  * @test
  * @run testng/othervm -Dforeign.restricted=permit TestUpcallStubs
  */
 
+import jdk.incubator.foreign.C;
+import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SystemABI;
 import org.testng.annotations.*;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
@@ -41,11 +42,11 @@
 import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;
 import static org.testng.Assert.assertFalse;
 
 public class TestUpcallStubs {
 
-    static final SystemABI abi = SystemABI.getSystemABI();
+    static final ForeignLinker abi = C.getSystemLinker();
     static final MethodHandle MH_dummy;
 
     static {
         try {
             MH_dummy = MethodHandles.lookup()
diff a/test/jdk/java/foreign/TestVarArgs.java b/test/jdk/java/foreign/TestVarArgs.java
--- a/test/jdk/java/foreign/TestVarArgs.java
+++ b/test/jdk/java/foreign/TestVarArgs.java
@@ -29,31 +29,29 @@
  *          jdk.incubator.foreign/jdk.internal.foreign.abi
  *          java.base/sun.security.action
  * @run testng/othervm -Dforeign.restricted=permit TestVarArgs
  */
 
+import jdk.incubator.foreign.C;
+import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
-import jdk.internal.foreign.MemoryAddressImpl;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
 
+import static jdk.incubator.foreign.C.*;
 import static jdk.incubator.foreign.MemoryLayout.PathElement.*;
-import static jdk.incubator.foreign.SystemABI.*;
 import static org.testng.Assert.assertEquals;
 
 public class TestVarArgs extends NativeTestHelper {
 
     static final MemoryLayout ML_CallInfo = MemoryLayout.ofStruct(
@@ -63,11 +61,11 @@
     static final VarHandle VH_CallInfo_writeback = ML_CallInfo.varHandle(long.class, groupElement("writeback"));
     static final VarHandle VH_CallInfo_argIDs = ML_CallInfo.varHandle(long.class, groupElement("argIDs"));
 
     static final VarHandle VH_IntArray = MemoryLayout.ofSequence(C_INT).varHandle(int.class, sequenceElement());
 
-    static final SystemABI abi = SystemABI.getSystemABI();
+    static final ForeignLinker abi = C.getSystemLinker();
     static final MemoryAddress varargsAddr;
 
     static {
         try {
             varargsAddr = LibraryLookup.ofLibrary("VarArgs").lookup("varargs");
diff a/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java b/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
@@ -42,11 +42,11 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodType;
 
-import static jdk.incubator.foreign.SystemABI.AArch64.*;
+import static jdk.incubator.foreign.C.AArch64.*;
 import static jdk.internal.foreign.abi.Binding.*;
 import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertFalse;
 import static org.testng.Assert.assertTrue;
diff a/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java b/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
@@ -43,11 +43,11 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodType;
 
-import static jdk.incubator.foreign.SystemABI.SysV.*;
+import static jdk.incubator.foreign.C.SysV.*;
 import static jdk.internal.foreign.abi.Binding.*;
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertFalse;
 import static org.testng.Assert.assertTrue;
diff a/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java b/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
@@ -42,11 +42,11 @@
 import jdk.internal.foreign.abi.x64.windows.CallArranger;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodType;
 
-import static jdk.incubator.foreign.SystemABI.Win64.*;
+import static jdk.incubator.foreign.C.Win64.*;
 import static jdk.internal.foreign.abi.Binding.*;
 import static jdk.internal.foreign.abi.Binding.copy;
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
 import static org.testng.Assert.*;
 
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
@@ -20,38 +20,38 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.bench.jdk.incubator.foreign;
 
+import jdk.incubator.foreign.C;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
-import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.ForeignLinker;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Mode;
 import org.openjdk.jmh.annotations.OutputTimeUnit;
 import org.openjdk.jmh.annotations.State;
 import org.openjdk.jmh.annotations.Warmup;
 
 import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.util.concurrent.TimeUnit;
 
-import static jdk.incubator.foreign.SystemABI.C_INT;
+import static jdk.incubator.foreign.C.C_INT;
 
 @BenchmarkMode(Mode.AverageTime)
 @Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)
 @Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)
 @State(org.openjdk.jmh.annotations.Scope.Thread)
 @OutputTimeUnit(TimeUnit.NANOSECONDS)
 @Fork(3)
 public class CallOverhead {
 
-    static final SystemABI abi = SystemABI.getSystemABI();
+    static final ForeignLinker abi = C.getSystemLinker();
     static final MethodHandle func;
     static final MethodHandle identity;
 
     static {
         System.loadLibrary("CallOverheadJNI");
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
@@ -20,25 +20,24 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.bench.jdk.incubator.foreign.points.support;
 
+import jdk.incubator.foreign.C;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.ForeignLinker;
 
 import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 
 import static java.lang.invoke.MethodType.methodType;
+import static jdk.incubator.foreign.C.*;
 import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
-import static jdk.incubator.foreign.SystemABI.*;
 
 public class PanamaPoint implements AutoCloseable {
 
     public static final MemoryLayout LAYOUT = MemoryLayout.ofStruct(
         C_INT.withName("x"),
@@ -50,11 +49,11 @@
     private static final MethodHandle MH_distance;
     private static final MethodHandle MH_distance_ptrs;
 
     static {
         try {
-            SystemABI abi = SystemABI.getSystemABI();
+            ForeignLinker abi = C.getSystemLinker();
             LibraryLookup lookup = LibraryLookup.ofLibrary("Point");
             MH_distance = abi.downcallHandle(
                 lookup.lookup("distance"),
                 methodType(double.class, MemorySegment.class, MemorySegment.class),
                 FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)

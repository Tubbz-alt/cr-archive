diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java
@@ -26,11 +26,10 @@
 
 package jdk.incubator.jextract;
 
 import java.lang.constant.Constable;
 import java.util.List;
-import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import jdk.incubator.foreign.MemoryLayout;
@@ -55,15 +54,19 @@
      * @return The name associated with this declaration.
      */
     String name();
 
     /**
-     * Get a declaration with specified attributes
-     * @param attributes The map of attribute names and their values
+     * Get a declaration with specified attribute.
+     * Set the values to the specified attribute while other attributes remains unchanged. If the specified attribute
+     * already exist, the new values are replacing the old ones. By not specifying any value, the attribute will become
+     * empty as {@link #getAttribute(String) getAttribute(name).isEmpty()} will return true.
+     * @param name The attribute name
+     * @param values More attribute values
      * @return the Declaration with attributes
      */
-    Declaration withAttributes(Map<String, List<Constable>> attributes);
+    Declaration withAttribute(String name, Constable... values);
 
     /**
      * Get a declaration without current attributes
      * @return the Declatation without any attributes
      */
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
@@ -26,10 +26,11 @@
 
 package jdk.internal.jextract.impl;
 
 import java.lang.constant.Constable;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import jdk.incubator.foreign.MemoryLayout;
@@ -70,10 +71,22 @@
     @Override
     public Set<String> attributeNames() { return Collections.unmodifiableSet(
             attributes.map(Map::keySet).orElse(Collections.emptySet()));
     }
 
+    @Override
+    public Declaration withAttribute(String name, Constable... values) {
+        if (values == null || values.length == 0) {
+            return withAttributes(null);
+        }
+        var attrs = attributes.map(HashMap::new).orElseGet(HashMap::new);
+        attrs.put(name, List.of(values));
+        return withAttributes(attrs);
+    }
+
+    abstract protected Declaration withAttributes(Map<String, List<Constable>> attrs);
+
     public static class VariableImpl extends DeclarationImpl implements Declaration.Variable {
 
         final Variable.Kind kind;
         final Type type;
         final Optional<MemoryLayout> layout;
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
@@ -94,11 +94,11 @@
     }
 
     public Declaration createTree(Cursor c) {
         Objects.requireNonNull(c);
         return checkCache(c, () -> {
-            Declaration rv = createTreeInternal(c);
+            var rv = (DeclarationImpl) createTreeInternal(c);
             return (rv == null) ? null : rv.withAttributes(collectAttributes(c));
         });
     }
 
     private Declaration createTreeInternal(Cursor c) {
diff a/test/jdk/java/jextract/TestAttributes.java b/test/jdk/java/jextract/TestAttributes.java
--- a/test/jdk/java/jextract/TestAttributes.java
+++ b/test/jdk/java/jextract/TestAttributes.java
@@ -29,17 +29,23 @@
  * @bug 8239808
  * @build JextractApiTestBase
  * @run testng TestAttributes
  */
 
+import java.lang.constant.Constable;
+import java.time.LocalDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.List;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.jextract.Declaration;
 import jdk.incubator.jextract.Type;
 import org.testng.annotations.Test;
 
 import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 public class TestAttributes extends JextractApiTestBase {
     private final static Type C_INT = Type.primitive(Type.Primitive.Kind.Int, MemoryLayouts.C_INT);
     private final static String ASMLABEL = "AsmLabelAttr";
 
@@ -98,6 +104,61 @@
     @Test
     public void testB() {
         Declaration.Scoped d = parse("libAsmSymbol.h");
         validateHeader(d, false);
     }
+
+    private static  Constable getSingleValue(Declaration d, String name) {
+        List<Constable> values = d.getAttribute(name).get();
+        assertEquals(1, values.size());
+        return values.get(0);
+    }
+
+    @Test
+    public void testAddAttribute() {
+        final String ts = "timestamp";
+        Declaration.Scoped d = parse("libAsmSymbol.h");
+        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);
+        Declaration withAttrs = d.withAttribute("header", d.name())
+                .withAttribute(ts, timestamp);
+
+        assertEquals(getSingleValue(withAttrs, "header"), d.name());
+        assertEquals(getSingleValue(withAttrs, ts), timestamp);
+
+        String timestamp2 = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
+        Declaration withNewAttrs = withAttrs.withAttribute(ts, timestamp2);
+        assertEquals(getSingleValue(withNewAttrs, ts), timestamp2);
+
+        // Make sure original Declaration is not altered
+        assertEquals(getSingleValue(withAttrs, ts), timestamp);
+
+        // Add more value to same attribute
+        withNewAttrs = withAttrs.withAttribute(ts, Stream.concat(
+                withAttrs.getAttribute(ts).map(List::stream).orElse(Stream.empty()),
+                Stream.of(timestamp2)
+            ).toArray(Constable[]::new));
+        assertEquals(withNewAttrs.getAttribute(ts).get(), List.of(timestamp, timestamp2));
+        assertEquals(getSingleValue(withNewAttrs,"header"), d.name());
+
+        // Remove attribute
+        withAttrs = withNewAttrs.withAttribute(ts);
+        assertTrue(withAttrs.getAttribute(ts).isEmpty());
+
+        // Strip attribute
+        withNewAttrs = withNewAttrs.stripAttributes();
+        assertTrue(withNewAttrs.attributeNames().isEmpty());
+    }
+
+    @Test
+    public void replaceFunctionSymbol() {
+        Declaration.Scoped d = parse("libAsmSymbol.h", "-DADD");
+        validateHeader(d, true);
+
+        var members = d.members().stream()
+            .map(m -> m.getAttribute(ASMLABEL)
+                    .map(attr -> m.withAttribute(ASMLABEL, attr.get(0).toString().replace('A', 'B')))
+                    .orElse(m))
+            .toArray(Declaration[]::new);
+        Declaration.Scoped patched = Declaration.toplevel(d.pos(), members);
+        validateHeader(patched, false);
+    }
 }

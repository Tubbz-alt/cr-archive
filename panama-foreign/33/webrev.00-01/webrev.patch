diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java
@@ -26,11 +26,10 @@
 
 package jdk.incubator.jextract;
 
 import java.lang.constant.ConstantDesc;
 import java.util.List;
-import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import jdk.incubator.foreign.MemoryLayout;
@@ -65,11 +64,11 @@
 
     /**
      * The attributes associated with this declaration
      * @return The attributes associated with this declaration
      */
-    Set<String> availableAttributes();
+    Set<String> attributeNames();
 
     /**
      * Entry point for visiting declaration instances.
      * @param visitor the declaration visitor.
      * @param data optional data to be passed to the visitor.
@@ -290,46 +289,46 @@
      * @param pos the global variable declaration position.
      * @param name the global variable declaration name.
      * @param type the global variable declaration type.
      * @return a new global variable declaration with given name and type.
      */
-    static Declaration.Variable globalVariable(Position pos, String name, Type type, Map<String, List<ConstantDesc>> attrs) {
-        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.GLOBAL, name, pos, attrs);
+    static Declaration.Variable globalVariable(Position pos, String name, Type type) {
+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.GLOBAL, name, pos);
     }
 
     /**
      * Creates a new field declaration with given name and type.
      * @param pos the field declaration position.
      * @param name the field declaration name.
      * @param type the field declaration type.
      * @return a new field declaration with given name and type.
      */
-    static Declaration.Variable field(Position pos, String name, Type type, Map<String, List<ConstantDesc>> attrs) {
-        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.FIELD, name, pos, attrs);
+    static Declaration.Variable field(Position pos, String name, Type type) {
+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.FIELD, name, pos);
     }
 
     /**
      * Creates a new bitfield declaration with given name, type and layout.
      * @param pos the bitfield declaration position.
      * @param name the bitfield declaration name.
      * @param type the bitfield declaration type.
      * @param layout the bitfield declaration layout.
      * @return a new bitfield declaration with given name, type and layout.
      */
-    static Declaration.Variable bitfield(Position pos, String name, Type type, MemoryLayout layout, Map<String, List<ConstantDesc>> attrs) {
-        return new DeclarationImpl.VariableImpl(type, layout, Declaration.Variable.Kind.BITFIELD, name, pos, attrs);
+    static Declaration.Variable bitfield(Position pos, String name, Type type, MemoryLayout layout) {
+        return new DeclarationImpl.VariableImpl(type, layout, Declaration.Variable.Kind.BITFIELD, name, pos);
     }
 
     /**
      * Creates a new parameter declaration with given name and type.
      * @param pos the parameter declaration position.
      * @param name the parameter declaration name.
      * @param type the parameter declaration type.
      * @return a new parameter declaration with given name and type.
      */
-    static Declaration.Variable parameter(Position pos, String name, Type type, Map<String, List<ConstantDesc>> attrs) {
-        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.PARAMETER, name, pos, attrs);
+    static Declaration.Variable parameter(Position pos, String name, Type type) {
+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.PARAMETER, name, pos);
     }
 
     /**
      * Creates a new toplevel declaration with given member declarations.
      * @param pos the toplevel declaration position.
@@ -472,13 +471,13 @@
      * @param name the function declaration name.
      * @param type the function declaration type.
      * @param params the function declaration parameter declarations.
      * @return a new function declaration with given name, type and parameter declarations.
      */
-    static Declaration.Function function(Position pos, String name, Map<String, List<ConstantDesc>> attrs, Type.Function type, Declaration.Variable... params) {
+    static Declaration.Function function(Position pos, String name, Type.Function type, Declaration.Variable... params) {
         List<Variable> paramList = Stream.of(params).collect(Collectors.toList());
-        return new DeclarationImpl.FunctionImpl(type, paramList, name, pos, attrs);
+        return new DeclarationImpl.FunctionImpl(type, paramList, name, pos);
     }
 
     /**
      * Creates a new typedef declaration with given name and declared type.
      * @param pos the typedef declaration position.
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
@@ -66,33 +66,41 @@
     public Optional<List<ConstantDesc>> getAttribute(String name) {
         return Optional.ofNullable(attributes.get(name));
     }
 
     @Override
-    public Set<String> availableAttributes() { return Collections.unmodifiableSet(attributes.keySet()); }
+    public Set<String> attributeNames() { return Collections.unmodifiableSet(attributes.keySet()); }
 
     public static class VariableImpl extends DeclarationImpl implements Declaration.Variable {
 
         final Variable.Kind kind;
         final Type type;
         final Optional<MemoryLayout> layout;
 
-        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos, Map<String, List<ConstantDesc>> attrs) {
-            this(type, LayoutUtils.getLayout(type), kind, name, pos, attrs);
-        }
-
-        public VariableImpl(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos, Map<String, List<ConstantDesc>> attrs) {
-            this(type, Optional.of(layout), kind, name, pos, attrs);
-        }
-
         private VariableImpl(Type type, Optional<MemoryLayout> layout, Variable.Kind kind, String name, Position pos, Map<String, List<ConstantDesc>> attrs) {
             super(name, pos, attrs);
             this.kind = kind;
             this.type = type;
             this.layout = layout;
         }
 
+        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {
+            this(type, LayoutUtils.getLayout(type), kind, name, pos, Collections.emptyMap());
+        }
+
+        public VariableImpl(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos) {
+            this(type, Optional.of(layout), kind, name, pos, Collections.emptyMap());
+        }
+
+        public static VariableImpl of(Type type, Variable.Kind kind, String name, Position pos, Map<String, List<ConstantDesc>> attrs) {
+            return new VariableImpl(type, LayoutUtils.getLayout(type), kind, name, pos, attrs);
+        }
+
+        public static VariableImpl of(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos, Map<String, List<ConstantDesc>> attrs) {
+            return new VariableImpl(type, Optional.of(layout), kind, name, pos, attrs);
+        }
+
         @Override
         public Kind kind() {
             return kind;
         }
 
@@ -115,10 +123,14 @@
     public static class FunctionImpl extends DeclarationImpl implements Declaration.Function {
 
         final List<Variable> params;
         final Type.Function type;
 
+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos) {
+            this(type, params, name, pos, Collections.emptyMap());
+        }
+
         public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos, Map<String, List<ConstantDesc>> attrs) {
             super(name, pos, attrs);
             this.params = params;
             this.type = type;
         }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java
@@ -51,11 +51,11 @@
     }
     
     StringBuilder builder = new StringBuilder();
 
     private void getAttributes(Declaration decl) {
-        Set<String> attrs = decl.availableAttributes();
+        Set<String> attrs = decl.attributeNames();
         if (attrs.isEmpty()) {
             return;
         }
         incr();
         indent();
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
@@ -79,14 +79,10 @@
 
     interface ScopedFactoryNoLayout {
         Declaration.Scoped make(Position pos, String name, Declaration... decls);
     }
 
-    interface VarFactoryNoLayout {
-        Declaration.Variable make(Position pos, String name, Type type, Map<String, List<ConstantDesc>> attrs);
-    }
-
     Map<String, List<ConstantDesc>> collectAttributes(Cursor c) {
         return c.children().filter(Cursor::isAttribute)
                 .collect(Collectors.groupingBy(
                         attr -> attr.kind().name(),
                         Collectors.mapping(Cursor::spelling, Collectors.toList())
@@ -101,24 +97,24 @@
                 return createScoped(c, Declaration.Scoped.Kind.ENUM, Declaration::enum_, Declaration::enum_);
             case EnumConstantDecl:
                 return createEnumConstant(c);
             case FieldDecl:
                 return createVar(c.isBitField() ?
-                        Declaration.Variable.Kind.BITFIELD : Declaration.Variable.Kind.FIELD, c, Declaration::field, attrs);
+                        Declaration.Variable.Kind.BITFIELD : Declaration.Variable.Kind.FIELD, c, attrs);
             case ParmDecl:
-                return createVar(Declaration.Variable.Kind.PARAMETER, c, Declaration::parameter, attrs);
+                return createVar(Declaration.Variable.Kind.PARAMETER, c, attrs);
             case FunctionDecl:
                 return createFunction(c, attrs);
             case StructDecl:
                 return createScoped(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);
             case UnionDecl:
                 return createScoped(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);
             case TypedefDecl: {
                 return createTypedef(c);
             }
             case VarDecl:
-                return createVar(Declaration.Variable.Kind.GLOBAL, c, Declaration::globalVariable, attrs);
+                return createVar(Declaration.Variable.Kind.GLOBAL, c, attrs);
             default:
                 return null;
         }
     }
 
@@ -176,11 +172,11 @@
         List<Declaration.Variable> params = new ArrayList<>();
         for (int i = 0 ; i < c.numberOfArgs() ; i++) {
             params.add((Declaration.Variable)createTree(c.getArgument(i)));
         }
         return checkCache(c, Declaration.Function.class,
-                ()->Declaration.function(toPos(c), c.spelling(), attrs, (Type.Function)toType(c), params.toArray(new Declaration.Variable[0])));
+                () -> new DeclarationImpl.FunctionImpl((Type.Function)toType(c), params, c.spelling(), toPos(c), attrs));
     }
 
     public Declaration.Constant createMacro(Cursor c, Optional<MacroParserImpl.Macro> macro) {
         checkCursorAny(c, CursorKind.MacroDefinition);
         if (macro.isEmpty()) {
@@ -249,19 +245,21 @@
             }
         }
         return null;
     }
 
-    private Declaration.Variable createVar(Declaration.Variable.Kind kind, Cursor c, VarFactoryNoLayout varFactory, Map<String, List<ConstantDesc>> attrs) {
+    private Declaration.Variable createVar(Declaration.Variable.Kind kind, Cursor c, Map<String, List<ConstantDesc>> attrs) {
         checkCursorAny(c, CursorKind.VarDecl, CursorKind.FieldDecl, CursorKind.ParmDecl);
         if (c.isBitField()) {
             return checkCache(c, Declaration.Variable.class,
-                    () -> Declaration.bitfield(toPos(c), c.spelling(), toType(c),
-                    MemoryLayout.ofValueBits(c.getBitFieldWidth(), ByteOrder.nativeOrder()), attrs));
+                    () -> DeclarationImpl.VariableImpl.of(toType(c),
+                            MemoryLayout.ofValueBits(c.getBitFieldWidth(), ByteOrder.nativeOrder()),
+                            Declaration.Variable.Kind.BITFIELD,
+                            c.spelling(), toPos(c), attrs));
         } else {
             return checkCache(c, Declaration.Variable.class,
-                    ()->varFactory.make(toPos(c), c.spelling(), toType(c), attrs));
+                    () -> DeclarationImpl.VariableImpl.of(toType(c), kind, c.spelling(), toPos(c), attrs));
         }
     }
 
     private List<Declaration> collectBitfields(MemoryLayout layout, List<Declaration> declarations) {
         List<Declaration> newDecls = new ArrayList<>();

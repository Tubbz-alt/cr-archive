diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java
@@ -50,22 +50,29 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 class MacroParserImpl implements JextractTask.ConstantParser {
 
-    private Reparser reparser;
-    TreeMaker treeMaker;
-    MacroTable macroTable;
+    private final ClangReparser reparser;
+    private final TreeMaker treeMaker;
+    final MacroTable macroTable;
 
-    public MacroParserImpl(TreeMaker treeMaker, TranslationUnit tu, Collection<String> args) {
+    private MacroParserImpl(ClangReparser reparser, TreeMaker treeMaker) {
+        this.reparser = reparser;
+        this.treeMaker = treeMaker;
+        this.macroTable = new MacroTable();
+    }
+
+    public static MacroParserImpl make(TreeMaker treeMaker, TranslationUnit tu, Collection<String> args) {
+        ClangReparser reparser;
         try {
-            this.reparser = new ClangReparser(tu, args);
-            this.treeMaker = treeMaker;
-            this.macroTable = new MacroTable();
+            reparser = new ClangReparser(tu, args);
         } catch (IOException | Index.ParsingFailedException ex) {
-            this.reparser = Reparser.DUMMY;
+            throw new RuntimeException(ex);
         }
+
+        return new MacroParserImpl(reparser, treeMaker);
     }
 
     /**
      * This method attempts to evaluate the macro. Evaluation occurs in two steps: first, an attempt is made
      * to see if the macro corresponds to a simple numeric constant. If so, the constant is parsed in Java directly.
@@ -99,22 +106,16 @@
         } catch (NumberFormatException nfe) {
             return null;
         }
     }
 
-    interface Reparser {
-        Stream<Cursor> reparse(String snippet);
-
-        Reparser DUMMY = s -> Stream.empty();
-    }
-
     /**
      * This class allows client to reparse a snippet of code against a given set of include files.
      * For performance reasons, the set of includes (which comes from the jextract parser) is compiled
      * into a precompiled header, so as to speed to incremental recompilation of the generated snippets.
      */
-    static class ClangReparser implements Reparser {
+    static class ClangReparser {
         final Path macro;
         final Index macroIndex = LibClang.createIndex(true);
         final TranslationUnit macroUnit;
 
         public ClangReparser(TranslationUnit tu, Collection<String> args) throws IOException, Index.ParsingFailedException {
@@ -141,11 +142,10 @@
             if (Main.DEBUG) {
                 System.err.println("Error while processing macro: " + diag.spelling());
             }
         }
 
-        @Override
         public Stream<Cursor> reparse(String snippet) {
             macroUnit.reparse(this::processDiagnostics,
                     Index.UnsavedFile.of(macro, snippet));
             return macroUnit.getCursor().children();
         }

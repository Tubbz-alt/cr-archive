diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
@@ -24,19 +24,12 @@
  *
  */
 
 package jdk.incubator.foreign;
 
-import jdk.internal.foreign.InternalForeign;
-import jdk.internal.foreign.abi.x64.windows.Windowsx64ABI;
-
 import java.nio.ByteOrder;
 
-import static jdk.incubator.foreign.SystemABI.ABI_AARCH64;
-import static jdk.incubator.foreign.SystemABI.ABI_SYSV;
-import static jdk.incubator.foreign.SystemABI.ABI_WINDOWS;
-
 /**
  * This class defines useful layout constants. Some of the constants defined in this class are explicit in both
  * size and byte order (see {@link #BITS_64_BE}), and can therefore be used to explicitly and unambiguously specify the
  * contents of a memory segment. Other constants make implicit byte order assumptions (see
  * {@link #JAVA_INT}); as such, these constants make it easy to work with other serialization-centric APIs,
@@ -49,26 +42,26 @@
     }
 
     /**
      * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      */
-    public static final ValueLayout BITS_8_LE = SharedLayouts.BITS_8_LE;
+    public static final ValueLayout BITS_8_LE = MemoryLayout.ofValueBits(8, ByteOrder.LITTLE_ENDIAN);
 
     /**
      * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      */
-    public static final ValueLayout BITS_16_LE = SharedLayouts.BITS_16_LE;
+    public static final ValueLayout BITS_16_LE = MemoryLayout.ofValueBits(16, ByteOrder.LITTLE_ENDIAN);
 
     /**
      * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      */
-    public static final ValueLayout BITS_32_LE = SharedLayouts.BITS_32_LE;
+    public static final ValueLayout BITS_32_LE = MemoryLayout.ofValueBits(32, ByteOrder.LITTLE_ENDIAN);
 
     /**
      * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      */
-    public static final ValueLayout BITS_64_LE = SharedLayouts.BITS_64_LE;
+    public static final ValueLayout BITS_64_LE = MemoryLayout.ofValueBits(64, ByteOrder.LITTLE_ENDIAN);
 
     /**
      * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#BIG_ENDIAN}.
      */
     public static final ValueLayout BITS_8_BE = MemoryLayout.ofValueBits(8, ByteOrder.BIG_ENDIAN);
@@ -140,467 +133,6 @@
 
     /**
      * A value layout constant whose size is the same as that of a Java {@code double}, and byte order set to {@link ByteOrder#nativeOrder()}.
      */
     public static final ValueLayout JAVA_DOUBLE = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());
-
-    /**
-     * The {@code _Bool} native type.
-     */
-    public static final ValueLayout C_BOOL;
-
-    /**
-     * The {@code unsigned char} native type.
-     */
-    public static final ValueLayout C_UCHAR;
-
-    /**
-     * The {@code signed char} native type.
-     */
-    public static final ValueLayout C_SCHAR ;
-
-    /**
-     * The {@code char} native type.
-     */
-    public static final ValueLayout C_CHAR;
-
-    /**
-     * The {@code short} native type.
-     */
-    public static final ValueLayout C_SHORT;
-
-    /**
-     * The {@code unsigned short} native type.
-     */
-    public static final ValueLayout C_USHORT;
-
-    /**
-     * The {@code int} native type.
-     */
-    public static final ValueLayout C_INT;
-
-    /**
-     * The {@code unsigned int} native type.
-     */
-    public static final ValueLayout C_UINT;
-
-    /**
-     * The {@code long} native type.
-     */
-    public static final ValueLayout C_LONG;
-
-    /**
-     * The {@code unsigned long} native type.
-     */
-    public static final ValueLayout C_ULONG;
-
-    /**
-     * The {@code long long} native type.
-     */
-    public static final ValueLayout C_LONGLONG;
-
-    /**
-     * The {@code unsigned long long} native type.
-     */
-    public static final ValueLayout C_ULONGLONG;
-
-    /**
-     * The {@code float} native type.
-     */
-    public static final ValueLayout C_FLOAT;
-
-    /**
-     * The {@code double} native type.
-     */
-    public static final ValueLayout C_DOUBLE;
-
-    /**
-     * The {@code T*} native type.
-     */
-    public static final ValueLayout C_POINTER;
-
-    static {
-        SystemABI abi = InternalForeign.getInstancePrivileged().getSystemABI();
-        switch (abi.name()) {
-            case ABI_SYSV -> {
-                C_BOOL = SysV.C_BOOL;
-                C_UCHAR = SysV.C_UCHAR;
-                C_SCHAR = SysV.C_SCHAR;
-                C_CHAR = SysV.C_CHAR;
-                C_SHORT = SysV.C_SHORT;
-                C_USHORT = SysV.C_USHORT;
-                C_INT = SysV.C_INT;
-                C_UINT = SysV.C_UINT;
-                C_LONG = SysV.C_LONG;
-                C_ULONG = SysV.C_ULONG;
-                C_LONGLONG = SysV.C_LONGLONG;
-                C_ULONGLONG = SysV.C_ULONGLONG;
-                C_FLOAT = SysV.C_FLOAT;
-                C_DOUBLE = SysV.C_DOUBLE;
-                C_POINTER = SysV.C_POINTER;
-            }
-            case ABI_WINDOWS -> {
-                C_BOOL = WinABI.C_BOOL;
-                C_UCHAR = WinABI.C_UCHAR;
-                C_SCHAR = WinABI.C_SCHAR;
-                C_CHAR = WinABI.C_CHAR;
-                C_SHORT = WinABI.C_SHORT;
-                C_USHORT = WinABI.C_USHORT;
-                C_INT = WinABI.C_INT;
-                C_UINT = WinABI.C_UINT;
-                C_LONG = WinABI.C_LONG;
-                C_ULONG = WinABI.C_ULONG;
-                C_LONGLONG = WinABI.C_LONGLONG;
-                C_ULONGLONG = WinABI.C_ULONGLONG;
-                C_FLOAT = WinABI.C_FLOAT;
-                C_DOUBLE = WinABI.C_DOUBLE;
-                C_POINTER = WinABI.C_POINTER;
-            }
-            case ABI_AARCH64 -> {
-                C_BOOL = AArch64ABI.C_BOOL;
-                C_UCHAR = AArch64ABI.C_UCHAR;
-                C_SCHAR = AArch64ABI.C_SCHAR;
-                C_CHAR = AArch64ABI.C_CHAR;
-                C_SHORT = AArch64ABI.C_SHORT;
-                C_USHORT = AArch64ABI.C_USHORT;
-                C_INT = AArch64ABI.C_INT;
-                C_UINT = AArch64ABI.C_UINT;
-                C_LONG = AArch64ABI.C_LONG;
-                C_ULONG = AArch64ABI.C_ULONG;
-                C_LONGLONG = AArch64ABI.C_LONGLONG;
-                C_ULONGLONG = AArch64ABI.C_ULONGLONG;
-                C_FLOAT = AArch64ABI.C_FLOAT;
-                C_DOUBLE = AArch64ABI.C_DOUBLE;
-                C_POINTER = AArch64ABI.C_POINTER;
-            }
-            default -> throw new IllegalStateException("Unsupported ABI: " + abi.name());
-        }
-    }
-
-    /**
-     * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
-     */
-    public static final class SysV {
-        private SysV() {
-            //just the one
-        }
-
-        /**
-         * The {@code _Bool} native type.
-         */
-        public static final ValueLayout C_BOOL = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.BOOL);
-
-
-        /**
-         * The {@code unsigned char} native type.
-         */
-        public static final ValueLayout C_UCHAR = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
-
-
-        /**
-         * The {@code signed char} native type.
-         */
-        public static final ValueLayout C_SCHAR = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
-
-
-        /**
-         * The {@code char} native type.
-         */
-        public static final ValueLayout C_CHAR = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.CHAR);
-
-        /**
-         * The {@code short} native type.
-         */
-        public static final ValueLayout C_SHORT = SharedLayouts.BITS_16_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SHORT);
-
-        /**
-         * The {@code unsigned short} native type.
-         */
-        public static final ValueLayout C_USHORT = SharedLayouts.BITS_16_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
-
-        /**
-         * The {@code int} native type.
-         */
-        public static final ValueLayout C_INT = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.INT);
-
-        /**
-         * The {@code unsigned int} native type.
-         */
-        public static final ValueLayout C_UINT = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
-
-        /**
-         * The {@code long} native type.
-         */
-        public static final ValueLayout C_LONG = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG);
-
-        /**
-         * The {@code unsigned long} native type.
-         */
-        public static final ValueLayout C_ULONG = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
-
-
-        /**
-         * The {@code long long} native type.
-         */
-        public static final ValueLayout C_LONGLONG = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
-
-        /**
-         * The {@code unsigned long long} native type.
-         */
-        public static final ValueLayout C_ULONGLONG = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
-
-        /**
-         * The {@code float} native type.
-         */
-        public static final ValueLayout C_FLOAT = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.FLOAT);
-
-        /**
-         * The {@code double} native type.
-         */
-        public static final ValueLayout C_DOUBLE = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.DOUBLE);
-
-        /**
-         * The {@code long double} native type.
-         */
-        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_DOUBLE);
-
-        /**
-         * The {@code complex long double} native type.
-         */
-        public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.COMPLEX_LONG_DOUBLE);
-
-        /**
-         * The {@code T*} native type.
-         */
-        public static final ValueLayout C_POINTER = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.POINTER);
-    }
-
-    /**
-     * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
-     */
-    public static final class WinABI {
-        /**
-         * The {@code _Bool} native type.
-         */
-        public static final ValueLayout C_BOOL = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.BOOL);
-
-        /**
-         * The {@code unsigned char} native type.
-         */
-        public static final ValueLayout C_UCHAR = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
-
-        /**
-         * The {@code signed char} native type.
-         */
-        public static final ValueLayout C_SCHAR = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
-
-        /**
-         * The {@code char} native type.
-         */
-        public static final ValueLayout C_CHAR = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.CHAR);
-
-        /**
-         * The {@code short} native type.
-         */
-        public static final ValueLayout C_SHORT = SharedLayouts.BITS_16_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SHORT);
-
-        /**
-         * The {@code unsigned short} native type.
-         */
-        public static final ValueLayout C_USHORT = SharedLayouts.BITS_16_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
-
-        /**
-         * The {@code int} native type.
-         */
-        public static final ValueLayout C_INT = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.INT);
-
-        /**
-         * The {@code unsigned int} native type.
-         */
-        public static final ValueLayout C_UINT = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
-
-        /**
-         * The {@code long} native type.
-         */
-        public static final ValueLayout C_LONG = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG);
-
-        /**
-         * The {@code unsigned long} native type.
-         */
-        public static final ValueLayout C_ULONG = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
-
-        /**
-         * The {@code long long} native type.
-         */
-        public static final ValueLayout C_LONGLONG = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
-
-        /**
-         * The {@code unsigned long long} native type.
-         */
-        public static final ValueLayout C_ULONGLONG = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
-
-        /**
-         * The {@code float} native type.
-         */
-        public static final ValueLayout C_FLOAT = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.FLOAT);
-
-        /**
-         * The {@code double} native type.
-         */
-        public static final ValueLayout C_DOUBLE = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.DOUBLE);
-
-        /**
-         * The {@code long double} native type.
-         */
-        public static final ValueLayout C_LONGDOUBLE = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_DOUBLE);
-
-        /**
-         * The {@code T*} native type.
-         */
-        public static final ValueLayout C_POINTER = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.POINTER);
-
-        public static ValueLayout asVarArg(ValueLayout l) {
-           return l.withAttribute(Windowsx64ABI.VARARGS_ATTRIBUTE_NAME, "true");
-        }
-    }
-
-    /**
-     * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
-     */
-    public static final class AArch64ABI {
-        /**
-         * The {@code _Bool} native type.
-         */
-        public static final ValueLayout C_BOOL = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.BOOL);
-
-        /**
-         * The {@code unsigned char} native type.
-         */
-        public static final ValueLayout C_UCHAR = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
-
-        /**
-         * The {@code signed char} native type.
-         */
-        public static final ValueLayout C_SCHAR = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
-
-        /**
-         * The {@code char} native type.
-         */
-        public static final ValueLayout C_CHAR = SharedLayouts.BITS_8_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.CHAR);
-
-        /**
-         * The {@code short} native type.
-         */
-        public static final ValueLayout C_SHORT = SharedLayouts.BITS_16_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.SHORT);
-
-        /**
-         * The {@code unsigned short} native type.
-         */
-        public static final ValueLayout C_USHORT = SharedLayouts.BITS_16_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
-
-        /**
-         * The {@code int} native type.
-         */
-        public static final ValueLayout C_INT = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.INT);
-
-        /**
-         * The {@code unsigned int} native type.
-         */
-        public static final ValueLayout C_UINT = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
-
-        /**
-         * The {@code long} native type.
-         */
-        public static final ValueLayout C_LONG = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG);
-
-        /**
-         * The {@code unsigned long} native type.
-         */
-        public static final ValueLayout C_ULONG = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
-
-        /**
-         * The {@code long long} native type.
-         */
-        public static final ValueLayout C_LONGLONG = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
-
-        /**
-         * The {@code unsigned long long} native type.
-         */
-        public static final ValueLayout C_ULONGLONG = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
-
-        /**
-         * The {@code float} native type.
-         */
-        public static final ValueLayout C_FLOAT = SharedLayouts.BITS_32_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.FLOAT);
-
-        /**
-         * The {@code double} native type.
-         */
-        public static final ValueLayout C_DOUBLE = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.DOUBLE);
-
-        /**
-         * The {@code long double} native type.
-         */
-        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.LONG_DOUBLE);
-
-        /**
-         * The {@code T*} native type.
-         */
-        public static final ValueLayout C_POINTER = SharedLayouts.BITS_64_LE
-                .withAttribute(SystemABI.NATIVE_TYPE, SystemABI.Type.POINTER);
-    }
-
-    private static class SharedLayouts { // Separate class to prevent circular clinit references
-        public static final ValueLayout BITS_8_LE = MemoryLayout.ofValueBits(8, ByteOrder.LITTLE_ENDIAN);
-        public static final ValueLayout BITS_16_LE = MemoryLayout.ofValueBits(16, ByteOrder.LITTLE_ENDIAN);
-        public static final ValueLayout BITS_32_LE = MemoryLayout.ofValueBits(32, ByteOrder.LITTLE_ENDIAN);
-        public static final ValueLayout BITS_64_LE = MemoryLayout.ofValueBits(64, ByteOrder.LITTLE_ENDIAN);
-    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
@@ -23,41 +23,23 @@
  *  questions.
  *
  */
 package jdk.incubator.foreign;
 
+import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.UpcallStubs;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
-import java.util.Optional;
+import java.nio.ByteOrder;
 
 /**
  * This class models a system application binary interface (ABI).
  *
  * Instances of this class can be obtained by calling {@link Foreign#getSystemABI()}
  */
 public interface SystemABI {
-    /**
-     * The name of the SysV ABI
-     */
-    String ABI_SYSV = "SysV";
-
-    /**
-     * The name of the Windows ABI
-     */
-    String ABI_WINDOWS = "Windows";
-
-    /**
-     * The name of the AArch64 ABI
-     */
-    String ABI_AARCH64 = "AArch64";
-
-    /**
-     * memory layout attribute key for abi native type
-     */
-    String NATIVE_TYPE = "abi/native-type";
 
     /**
      * Obtain a method handle which can be used to call a given native function.
      *
      * @param symbol downcall symbol.
@@ -93,113 +75,454 @@
      *
      * @return the name
      */
     String name();
 
-    enum Type {
+    /**
+     * The {@code _Bool} native type.
+     */
+     ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
+
+    /**
+     * The {@code unsigned char} native type.
+     */
+     ValueLayout C_UCHAR = Utils.pick(SysV.C_UCHAR, Win64.C_UCHAR, AArch64.C_UCHAR);
+
+    /**
+     * The {@code signed char} native type.
+     */
+     ValueLayout C_SCHAR = Utils.pick(SysV.C_SCHAR, Win64.C_SCHAR, AArch64.C_SCHAR) ;
+
+    /**
+     * The {@code char} native type.
+     */
+     ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
+
+    /**
+     * The {@code short} native type.
+     */
+     ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
+
+    /**
+     * The {@code unsigned short} native type.
+     */
+     ValueLayout C_USHORT = Utils.pick(SysV.C_USHORT, Win64.C_USHORT, AArch64.C_USHORT);
+
+    /**
+     * The {@code int} native type.
+     */
+     ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
+
+    /**
+     * The {@code unsigned int} native type.
+     */
+     ValueLayout C_UINT = Utils.pick(SysV.C_UINT, Win64.C_UINT, AArch64.C_UINT);
+
+    /**
+     * The {@code long} native type.
+     */
+     ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
+
+    /**
+     * The {@code unsigned long} native type.
+     */
+     ValueLayout C_ULONG = Utils.pick(SysV.C_ULONG, Win64.C_ULONG, AArch64.C_ULONG);
+
+    /**
+     * The {@code long long} native type.
+     */
+     ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
+
+    /**
+     * The {@code unsigned long long} native type.
+     */
+     ValueLayout C_ULONGLONG = Utils.pick(SysV.C_ULONGLONG, Win64.C_ULONGLONG, AArch64.C_ULONGLONG);
+
+    /**
+     * The {@code float} native type.
+     */
+     ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
+
+    /**
+     * The {@code double} native type.
+     */
+     ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
+
+    /**
+     * The {@code T*} native type.
+     */
+     ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
+
+    /**
+     * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
+     */
+    final class SysV {
+        private SysV() {
+            //just the one
+        }
+
+        /**
+         * The name of the SysV ABI
+         */
+        public static final String NAME = "SysV";
+
+        public final static String CLASS_ATTRIBUTE_NAME = "abi/sysv/class";
+
+        public enum ArgumentClass {
+            INTEGER,
+            SSE,
+            X87,
+            COMPLEX_87,
+            POINTER;
+        }
+
         /**
          * The {@code _Bool} native type.
          */
-        BOOL,
+        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
 
         /**
          * The {@code unsigned char} native type.
          */
-        UNSIGNED_CHAR,
+        public static final ValueLayout C_UCHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
 
         /**
          * The {@code signed char} native type.
          */
-        SIGNED_CHAR,
+        public static final ValueLayout C_SCHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
 
         /**
          * The {@code char} native type.
          */
-        CHAR,
+        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
 
         /**
          * The {@code short} native type.
          */
-        SHORT,
+        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
 
         /**
          * The {@code unsigned short} native type.
          */
-        UNSIGNED_SHORT,
+        public static final ValueLayout C_USHORT = MemoryLayouts.BITS_16_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
 
         /**
          * The {@code int} native type.
          */
-        INT,
+        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
 
         /**
          * The {@code unsigned int} native type.
          */
-        UNSIGNED_INT,
+        public static final ValueLayout C_UINT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
 
         /**
          * The {@code long} native type.
          */
-        LONG,
+        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
 
         /**
          * The {@code unsigned long} native type.
          */
-        UNSIGNED_LONG,
+        public static final ValueLayout C_ULONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
 
         /**
          * The {@code long long} native type.
          */
-        LONG_LONG,
+        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
 
         /**
          * The {@code unsigned long long} native type.
          */
-        UNSIGNED_LONG_LONG,
+        public static final ValueLayout C_ULONGLONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
 
         /**
          * The {@code float} native type.
          */
-        FLOAT,
+        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
 
         /**
          * The {@code double} native type.
          */
-        DOUBLE,
+        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
 
         /**
          * The {@code long double} native type.
          */
-        LONG_DOUBLE,
+        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
 
         /**
          * The {@code complex long double} native type.
          */
-        COMPLEX_LONG_DOUBLE,
+        public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
 
         /**
          * The {@code T*} native type.
          */
-        POINTER;
+        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
+    }
+
+    /**
+     * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
+     */
+    final class Win64 {
+
+        private Win64() {
+            //just the one
+        }
+
+        /**
+         * The name of the Windows ABI
+         */
+        public final static String NAME = "Windows";
+
+        public final static String VARARGS_ATTRIBUTE_NAME = "abi/windows/varargs";
+
+        public final static String CLASS_ATTRIBUTE_NAME = "abi/windows/class";
+
+        public enum ArgumentClass {
+            INTEGER,
+            SSE,
+            POINTER;
+        }
+
+        /**
+         * The {@code _Bool} native type.
+         */
+        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code unsigned char} native type.
+         */
+        public static final ValueLayout C_UCHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code signed char} native type.
+         */
+        public static final ValueLayout C_SCHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code char} native type.
+         */
+        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code short} native type.
+         */
+        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code unsigned short} native type.
+         */
+        public static final ValueLayout C_USHORT = MemoryLayouts.BITS_16_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code int} native type.
+         */
+        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code unsigned int} native type.
+         */
+        public static final ValueLayout C_UINT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code long} native type.
+         */
+        public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code unsigned long} native type.
+         */
+        public static final ValueLayout C_ULONG = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
 
         /**
-         * Retrieve the ABI type attached to the given layout,
-         * or throw an {@code IllegalArgumentException} if there is none
-         *
-         * @param ml the layout to retrieve the ABI type of
-         * @return the retrieved ABI type
-         * @throws IllegalArgumentException if the given layout does not have an ABI type attribute
+         * The {@code long long} native type.
+         */
+        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code unsigned long long} native type.
+         */
+        public static final ValueLayout C_ULONGLONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code float} native type.
          */
-        public static Type fromLayout(MemoryLayout ml) throws IllegalArgumentException {
-            return ml.attribute(NATIVE_TYPE)
-                     .map(SystemABI.Type.class::cast)
-                     .orElseThrow(() -> new IllegalArgumentException("No ABI attribute present"));
+        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
+
+        /**
+         * The {@code double} native type.
+         */
+        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
+
+        /**
+         * The {@code long double} native type.
+         */
+        public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
+
+        /**
+         * The {@code T*} native type.
+         */
+        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
+
+        public static ValueLayout asVarArg(ValueLayout l) {
+            return l.withAttribute(VARARGS_ATTRIBUTE_NAME, "true");
         }
     }
 
     /**
-     * Returns memory layout for the given native type if supported by the platform ABI.
-     * @param type the native type for which the layout is to be retrieved.
-     * @return the layout (if any) associated with {@code type}
+     * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
      */
-    Optional<MemoryLayout> layoutFor(Type type);
+    final class AArch64 {
+
+        private AArch64() {
+            //just the one
+        }
+
+        /**
+         * The name of the AArch64 ABI
+         */
+        public final static String NAME = "AArch64";
+
+        public static final String CLASS_ATTRIBUTE_NAME = "abi/aarch64/class";
+
+        public enum ArgumentClass {
+            INTEGER,
+            VECTOR,
+            POINTER;
+        }
+
+        /**
+         * The {@code _Bool} native type.
+         */
+        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code unsigned char} native type.
+         */
+        public static final ValueLayout C_UCHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code signed char} native type.
+         */
+        public static final ValueLayout C_SCHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code char} native type.
+         */
+        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code short} native type.
+         */
+        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code unsigned short} native type.
+         */
+        public static final ValueLayout C_USHORT = MemoryLayouts.BITS_16_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code int} native type.
+         */
+        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code unsigned int} native type.
+         */
+        public static final ValueLayout C_UINT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code long} native type.
+         */
+        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code unsigned long} native type.
+         */
+        public static final ValueLayout C_ULONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code long long} native type.
+         */
+        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code unsigned long long} native type.
+         */
+        public static final ValueLayout C_ULONGLONG = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
+
+        /**
+         * The {@code float} native type.
+         */
+        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
+
+        /**
+         * The {@code double} native type.
+         */
+        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
+
+        /**
+         * The {@code long double} native type.
+         */
+        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
+
+        /**
+         * The {@code T*} native type.
+         */
+        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -25,11 +25,13 @@
  */
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SystemABI;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.MemoryAddressProxy;
 import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
@@ -189,6 +191,16 @@
     }
 
     private static MemoryAddressProxy filterAddress(MemoryAddress addr) {
         return (MemoryAddressImpl)addr;
     }
+
+    public static <Z extends MemoryLayout> Z pick(Z sysv, Z win64, Z aarch64) {
+        SystemABI abi = InternalForeign.getInstancePrivileged().getSystemABI();
+        return switch (abi.name()) {
+            case SystemABI.SysV.NAME -> sysv;
+            case SystemABI.Win64.NAME -> win64;
+            case SystemABI.AArch64.NAME -> aarch64;
+            default -> throw new ExceptionInInitializerError("Unexpected ABI: " + abi.name());
+        };
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
@@ -27,19 +27,14 @@
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.SystemABI;
-import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.abi.*;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
-import java.util.Objects;
-import java.util.Optional;
-
-import static jdk.incubator.foreign.MemoryLayouts.AArch64ABI.*;
 
 /**
  * ABI implementation based on ARM document "Procedure Call Standard for
  * the ARM 64-bit Architecture".
  */
@@ -63,42 +58,12 @@
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
     }
 
     @Override
     public String name() {
-        return SystemABI.ABI_AARCH64;
-    }
-
-    @Override
-    public Optional<MemoryLayout> layoutFor(Type type) {
-        return switch (Objects.requireNonNull(type)) {
-            case BOOL -> Optional.of(C_BOOL);
-            case UNSIGNED_CHAR -> Optional.of(C_UCHAR);
-            case SIGNED_CHAR -> Optional.of(C_SCHAR);
-            case CHAR -> Optional.of(C_CHAR);
-            case SHORT -> Optional.of(C_SHORT);
-            case UNSIGNED_SHORT -> Optional.of(C_USHORT);
-            case INT -> Optional.of(C_INT);
-            case UNSIGNED_INT -> Optional.of(C_UINT);
-            case LONG -> Optional.of(C_LONG);
-            case UNSIGNED_LONG -> Optional.of(C_ULONG);
-            case LONG_LONG -> Optional.of(C_LONGLONG);
-            case UNSIGNED_LONG_LONG -> Optional.of(C_ULONGLONG);
-            case FLOAT -> Optional.of(C_FLOAT);
-            case DOUBLE -> Optional.of(C_DOUBLE);
-            case LONG_DOUBLE -> Optional.of(C_LONGDOUBLE);
-            case POINTER -> Optional.of(C_POINTER);
-            default -> Optional.empty();
-        };
+        return AArch64.NAME;
     }
 
-    static ArgumentClassImpl argumentClassFor(Type type) {
-        return switch (Objects.requireNonNull(type)) {
-            case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
-                INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG ->
-                    ArgumentClassImpl.INTEGER;
-            case FLOAT, DOUBLE -> ArgumentClassImpl.VECTOR;
-            case POINTER -> ArgumentClassImpl.POINTER;
-            default -> null;
-        };
+    static AArch64.ArgumentClass argumentClassFor(MemoryLayout layout) {
+        return (AArch64.ArgumentClass)layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get();
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
@@ -105,11 +105,11 @@
         BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);
         BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);
 
         boolean returnInMemory = isInMemoryReturn(cDesc.returnLayout());
         if (returnInMemory) {
-            csb.addArgumentBindings(MemoryAddress.class, MemoryLayouts.AArch64ABI.C_POINTER,
+            csb.addArgumentBindings(MemoryAddress.class, SystemABI.AArch64.C_POINTER,
                     argCalc.getIndirectBindings());
         } else if (cDesc.returnLayout().isPresent()) {
             Class<?> carrier = mt.returnType();
             MemoryLayout layout = cDesc.returnLayout().get();
             csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout));
@@ -161,21 +161,21 @@
         INTEGER,
         FLOAT,
     }
 
     private static TypeClass classifyValueType(ValueLayout type) {
-        ArgumentClassImpl clazz = AArch64ABI.argumentClassFor(SystemABI.Type.fromLayout(type));
+        SystemABI.AArch64.ArgumentClass clazz = AArch64ABI.argumentClassFor(type);
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
 
-        if (clazz == ArgumentClassImpl.INTEGER) {
+        if (clazz == SystemABI.AArch64.ArgumentClass.INTEGER) {
             return TypeClass.INTEGER;
-        } else if(clazz == ArgumentClassImpl.POINTER) {
+        } else if(clazz == SystemABI.AArch64.ArgumentClass.POINTER) {
             return TypeClass.POINTER;
-        } else if (clazz == ArgumentClassImpl.VECTOR) {
+        } else if (clazz == SystemABI.AArch64.ArgumentClass.VECTOR) {
             return TypeClass.FLOAT;
         }
         throw new IllegalArgumentException("Unknown ABI class: " + clazz);
     }
 
@@ -196,19 +196,19 @@
         MemoryLayout baseType = groupLayout.memberLayouts().get(0);
 
         if (!(baseType instanceof ValueLayout))
             return false;
 
-        ArgumentClassImpl baseArgClass = AArch64ABI.argumentClassFor(SystemABI.Type.fromLayout(baseType));
-        if (baseArgClass != ArgumentClassImpl.VECTOR)
+        SystemABI.AArch64.ArgumentClass baseArgClass = AArch64ABI.argumentClassFor(baseType);
+        if (baseArgClass != SystemABI.AArch64.ArgumentClass.VECTOR)
            return false;
 
         for (MemoryLayout elem : groupLayout.memberLayouts()) {
             if (!(elem instanceof ValueLayout))
                 return false;
 
-            ArgumentClassImpl argClass = AArch64ABI.argumentClassFor(SystemABI.Type.fromLayout(elem));
+            SystemABI.AArch64.ArgumentClass argClass = AArch64ABI.argumentClassFor(elem);
             if (elem.bitSize() != baseType.bitSize() ||
                     elem.bitAlignment() != baseType.bitAlignment() ||
                     baseArgClass != argClass) {
                 return false;
             }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/ArgumentClassImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/ArgumentClassImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/ArgumentClassImpl.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.internal.foreign.abi.x64;
-
-public enum ArgumentClassImpl {
-    POINTER, INTEGER, SSE, SSEUP, X87, X87UP, COMPLEX_X87, NO_CLASS, MEMORY;
-
-    public ArgumentClassImpl merge(ArgumentClassImpl other) {
-        if (this == other) {
-            return this;
-        }
-
-        if (other == NO_CLASS) {
-            return this;
-        }
-        if (this == NO_CLASS) {
-            return other;
-        }
-
-        if (this == MEMORY || other == MEMORY) {
-            return MEMORY;
-        }
-
-        if (this == POINTER || other == POINTER) {
-            return POINTER;
-        }
-
-        if (this == INTEGER || other == INTEGER) {
-            return INTEGER;
-        }
-
-        if (this == X87 || this == X87UP || this == COMPLEX_X87) {
-            return MEMORY;
-        }
-        if (other == X87 || other == X87UP || other == COMPLEX_X87) {
-            return MEMORY;
-        }
-
-        return SSE;
-    }
-
-    public boolean isIntegral() {
-        return this == INTEGER || this == POINTER;
-    }
-
-    public boolean isPointer() {
-        return this == POINTER;
-    }
-
-    public boolean isIndirect() {
-        return this == MEMORY;
-    }
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/ArgumentClassImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/ArgumentClassImpl.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/ArgumentClassImpl.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.foreign.abi.x64.sysv;
+
+public enum ArgumentClassImpl {
+    POINTER, INTEGER, SSE, SSEUP, X87, X87UP, COMPLEX_X87, NO_CLASS, MEMORY;
+
+    public ArgumentClassImpl merge(ArgumentClassImpl other) {
+        if (this == other) {
+            return this;
+        }
+
+        if (other == NO_CLASS) {
+            return this;
+        }
+        if (this == NO_CLASS) {
+            return other;
+        }
+
+        if (this == MEMORY || other == MEMORY) {
+            return MEMORY;
+        }
+
+        if (this == POINTER || other == POINTER) {
+            return POINTER;
+        }
+
+        if (this == INTEGER || other == INTEGER) {
+            return INTEGER;
+        }
+
+        if (this == X87 || this == X87UP || this == COMPLEX_X87) {
+            return MEMORY;
+        }
+        if (other == X87 || other == X87UP || other == COMPLEX_X87) {
+            return MEMORY;
+        }
+
+        return SSE;
+    }
+
+    public boolean isIntegral() {
+        return this == INTEGER || this == POINTER;
+    }
+
+    public boolean isPointer() {
+        return this == POINTER;
+    }
+
+    public boolean isIndirect() {
+        return this == MEMORY;
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -27,11 +27,10 @@
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.Utils;
@@ -42,11 +41,10 @@
 import jdk.internal.foreign.abi.CallingSequence;
 import jdk.internal.foreign.abi.ProgrammableInvoker;
 import jdk.internal.foreign.abi.ProgrammableUpcallHandler;
 import jdk.internal.foreign.abi.VMStorage;
 import jdk.internal.foreign.abi.x64.X86_64Architecture;
-import jdk.internal.foreign.abi.x64.ArgumentClassImpl;
 import jdk.internal.foreign.abi.SharedUtils;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
@@ -102,11 +100,11 @@
         BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);
 
         boolean returnInMemory = isInMemoryReturn(cDesc.returnLayout());
         if (returnInMemory) {
             Class<?> carrier = MemoryAddress.class;
-            MemoryLayout layout = MemoryLayouts.SysV.C_POINTER;
+            MemoryLayout layout = SystemABI.SysV.C_POINTER;
             csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout));
         } else if (cDesc.returnLayout().isPresent()) {
             Class<?> carrier = mt.returnType();
             MemoryLayout layout = cDesc.returnLayout().get();
             csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout));
@@ -118,11 +116,11 @@
             csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout));
         }
 
         if (!forUpcall) {
             //add extra binding for number of used vector registers (used for variadic calls)
-            csb.addArgumentBindings(long.class, MemoryLayouts.SysV.C_LONG,
+            csb.addArgumentBindings(long.class, SystemABI.SysV.C_LONG,
                     List.of(move(rax, long.class)));
         }
 
         return new Bindings(csb.build(), returnInMemory, argCalc.storageCalculator.nVectorReg);
     }
@@ -427,11 +425,11 @@
     }
 
 
     private static List<ArgumentClassImpl> classifyValueType(ValueLayout type) {
         ArrayList<ArgumentClassImpl> classes = new ArrayList<>();
-        ArgumentClassImpl clazz = SysVx64ABI.argumentClassFor(SystemABI.Type.fromLayout(type));
+        ArgumentClassImpl clazz = SysVx64ABI.argumentClassFor(type);
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
         classes.add(clazz);
@@ -515,13 +513,11 @@
     }
 
     // TODO: handle zero length arrays
     // TODO: Handle nested structs (and primitives)
     private static List<ArgumentClassImpl> classifyStructType(GroupLayout type) {
-        if (type.attribute(SystemABI.NATIVE_TYPE)
-                .map(SystemABI.Type.class::cast)
-                .map(SysVx64ABI::argumentClassFor)
+        if (type.attribute(SystemABI.SysV.CLASS_ATTRIBUTE_NAME)
                 .filter(ArgumentClassImpl.COMPLEX_X87::equals)
                 .isPresent()) {
             return COMPLEX_X87_CLASSES;
         }
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
@@ -26,19 +26,14 @@
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.SystemABI;
-import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.abi.*;
-import jdk.internal.foreign.abi.x64.ArgumentClassImpl;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
-import java.util.*;
-
-import static jdk.incubator.foreign.MemoryLayouts.SysV.*;
 
 /**
  * ABI implementation based on System V ABI AMD64 supplement v.0.99.6
  */
 public class SysVx64ABI implements SystemABI {
@@ -67,45 +62,20 @@
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
     }
 
     @Override
     public String name() {
-        return SystemABI.ABI_SYSV;
-    }
-
-    @Override
-    public Optional<MemoryLayout> layoutFor(Type type) {
-        return switch (Objects.requireNonNull(type)) {
-            case BOOL -> Optional.of(C_BOOL);
-            case UNSIGNED_CHAR -> Optional.of(C_UCHAR);
-            case SIGNED_CHAR -> Optional.of(C_SCHAR);
-            case CHAR -> Optional.of(C_CHAR);
-            case SHORT -> Optional.of(C_SHORT);
-            case UNSIGNED_SHORT -> Optional.of(C_USHORT);
-            case INT -> Optional.of(C_INT);
-            case UNSIGNED_INT -> Optional.of(C_UINT);
-            case LONG -> Optional.of(C_LONG);
-            case UNSIGNED_LONG -> Optional.of(C_ULONG);
-            case LONG_LONG -> Optional.of(C_LONGLONG);
-            case UNSIGNED_LONG_LONG -> Optional.of(C_ULONGLONG);
-            case FLOAT -> Optional.of(C_FLOAT);
-            case DOUBLE -> Optional.of(C_DOUBLE);
-            case LONG_DOUBLE -> Optional.of(C_LONGDOUBLE);
-            case COMPLEX_LONG_DOUBLE -> Optional.of(C_COMPLEX_LONGDOUBLE);
-            case POINTER -> Optional.of(C_POINTER);
-            default -> Optional.empty();
-        };
+        return SysV.NAME;
     }
 
-    static ArgumentClassImpl argumentClassFor(Type type) {
-        return switch (Objects.requireNonNull(type)) {
-            case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
-                INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG ->
-                    ArgumentClassImpl.INTEGER;
-            case FLOAT, DOUBLE -> ArgumentClassImpl.SSE;
-            case LONG_DOUBLE -> ArgumentClassImpl.X87;
-            case COMPLEX_LONG_DOUBLE -> ArgumentClassImpl.COMPLEX_X87;
+    static ArgumentClassImpl argumentClassFor(MemoryLayout layout) {
+        SysV.ArgumentClass argClass = (SysV.ArgumentClass)layout.attribute(SysV.CLASS_ATTRIBUTE_NAME).get();
+        return switch (argClass) {
+            case INTEGER -> ArgumentClassImpl.INTEGER;
+            case SSE -> ArgumentClassImpl.SSE;
+            case X87 -> ArgumentClassImpl.X87;
+            case COMPLEX_87 -> ArgumentClassImpl.COMPLEX_X87;
             case POINTER -> ArgumentClassImpl.POINTER;
             default -> null;
         };
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
@@ -24,11 +24,10 @@
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.Utils;
@@ -39,21 +38,20 @@
 import jdk.internal.foreign.abi.CallingSequence;
 import jdk.internal.foreign.abi.ProgrammableInvoker;
 import jdk.internal.foreign.abi.ProgrammableUpcallHandler;
 import jdk.internal.foreign.abi.VMStorage;
 import jdk.internal.foreign.abi.x64.X86_64Architecture;
-import jdk.internal.foreign.abi.x64.ArgumentClassImpl;
+import jdk.internal.foreign.abi.x64.sysv.ArgumentClassImpl;
 import jdk.internal.foreign.abi.SharedUtils;
-import jdk.internal.foreign.abi.x64.sysv.SysVx64ABI;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
 import java.util.List;
 import java.util.Optional;
 
+import static jdk.incubator.foreign.SystemABI.Win64.VARARGS_ATTRIBUTE_NAME;
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
-import static jdk.internal.foreign.abi.x64.windows.Windowsx64ABI.VARARGS_ATTRIBUTE_NAME;
 
 /**
  * For the Windowx x64 C ABI specifically, this class uses the ProgrammableInvoker API, namely CallingSequenceBuilder2
  * to translate a C FunctionDescriptor into a CallingSequence2, which can then be turned into a MethodHandle.
  *
@@ -106,11 +104,11 @@
         var csb = new CallingSequenceBuilderHelper();
 
         boolean returnInMemory = isInMemoryReturn(cDesc.returnLayout());
         if (returnInMemory) {
             Class<?> carrier = MemoryAddress.class;
-            MemoryLayout layout = MemoryLayouts.WinABI.C_POINTER;
+            MemoryLayout layout = SystemABI.Win64.C_POINTER;
             csb.addArgumentBindings(carrier, layout);
             if (forUpcall) {
                 csb.setReturnBindings(carrier, layout);
             }
         } else if (cDesc.returnLayout().isPresent()) {
@@ -161,11 +159,11 @@
         FLOAT,
         VARARG_FLOAT
     }
 
     private static TypeClass classifyValueType(ValueLayout type) {
-        ArgumentClassImpl clazz = Windowsx64ABI.argumentClassFor(SystemABI.Type.fromLayout(type));
+        SystemABI.Win64.ArgumentClass clazz = Windowsx64ABI.argumentClassFor(type);
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
 
@@ -176,15 +174,15 @@
         // x87 is ignored on Windows:
         // "The x87 register stack is unused, and may be used by the callee,
         // but must be considered volatile across function calls."
         // https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019
 
-        if (clazz == ArgumentClassImpl.INTEGER) {
+        if (clazz == SystemABI.Win64.ArgumentClass.INTEGER) {
             return TypeClass.INTEGER;
-        } else if(clazz == ArgumentClassImpl.POINTER) {
+        } else if(clazz == SystemABI.Win64.ArgumentClass.POINTER) {
             return TypeClass.POINTER;
-        } else if (clazz == ArgumentClassImpl.SSE) {
+        } else if (clazz == SystemABI.Win64.ArgumentClass.SSE) {
             if (type.attribute(VARARGS_ATTRIBUTE_NAME)
                     .map(String.class::cast)
                     .map(Boolean::parseBoolean).orElse(false)) {
                 return TypeClass.VARARG_FLOAT;
             }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
@@ -26,20 +26,15 @@
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.SystemABI;
-import jdk.internal.foreign.MemoryAddressImpl;
-import jdk.internal.foreign.abi.x64.ArgumentClassImpl;
+import jdk.internal.foreign.abi.x64.sysv.ArgumentClassImpl;
 import jdk.internal.foreign.abi.*;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
-import java.util.Objects;
-import java.util.Optional;
-
-import static jdk.incubator.foreign.MemoryLayouts.WinABI.*;
 
 /**
  * ABI implementation based on Windows ABI AMD64 supplement v.0.99.6
  */
 public class Windowsx64ABI implements SystemABI {
@@ -49,12 +44,10 @@
     public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 4;
     public static final int MAX_VECTOR_RETURN_REGISTERS = 1;
     public static final int MAX_REGISTER_ARGUMENTS = 4;
     public static final int MAX_REGISTER_RETURNS = 1;
 
-    public static final String VARARGS_ATTRIBUTE_NAME = "abi/windows/varargs";
-
     private static Windowsx64ABI instance;
 
     public static Windowsx64ABI getInstance() {
         if (instance == null) {
             instance = new Windowsx64ABI();
@@ -72,42 +65,12 @@
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
     }
 
     @Override
     public String name() {
-        return SystemABI.ABI_WINDOWS;
-    }
-
-    @Override
-    public Optional<MemoryLayout> layoutFor(Type type) {
-        return switch (Objects.requireNonNull(type)) {
-            case BOOL -> Optional.of(C_BOOL);
-            case UNSIGNED_CHAR -> Optional.of(C_UCHAR);
-            case SIGNED_CHAR -> Optional.of(C_SCHAR);
-            case CHAR -> Optional.of(C_CHAR);
-            case SHORT -> Optional.of(C_SHORT);
-            case UNSIGNED_SHORT -> Optional.of(C_USHORT);
-            case INT -> Optional.of(C_INT);
-            case UNSIGNED_INT -> Optional.of(C_UINT);
-            case LONG -> Optional.of(C_LONG);
-            case UNSIGNED_LONG -> Optional.of(C_ULONG);
-            case LONG_LONG -> Optional.of(C_LONGLONG);
-            case UNSIGNED_LONG_LONG -> Optional.of(C_ULONGLONG);
-            case FLOAT -> Optional.of(C_FLOAT);
-            case DOUBLE -> Optional.of(C_DOUBLE);
-            case LONG_DOUBLE -> Optional.of(C_LONGDOUBLE);
-            case POINTER -> Optional.of(C_POINTER);
-            default -> Optional.empty();
-        };
+        return Win64.NAME;
     }
 
-    static ArgumentClassImpl argumentClassFor(Type type) {
-        return switch (Objects.requireNonNull(type)) {
-            case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
-                INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG ->
-                    ArgumentClassImpl.INTEGER;
-            case FLOAT, DOUBLE -> ArgumentClassImpl.SSE;
-            case POINTER -> ArgumentClassImpl.POINTER;
-            default -> null;
-        };
+    static Win64.ArgumentClass argumentClassFor(MemoryLayout layout) {
+        return (Win64.ArgumentClass)layout.attribute(Win64.CLASS_ATTRIBUTE_NAME).get();
     }
 }
diff a/test/jdk/java/foreign/CallGeneratorHelper.java b/test/jdk/java/foreign/CallGeneratorHelper.java
--- a/test/jdk/java/foreign/CallGeneratorHelper.java
+++ b/test/jdk/java/foreign/CallGeneratorHelper.java
@@ -36,11 +36,11 @@
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
 import org.testng.annotations.*;
 
-import static jdk.incubator.foreign.MemoryLayouts.*;
+import static jdk.incubator.foreign.SystemABI.*;
 import static org.testng.Assert.*;
 
 public class CallGeneratorHelper extends NativeTestHelper {
 
     static final int MAX_FIELDS = 3;
diff a/test/jdk/java/foreign/Cstring.java b/test/jdk/java/foreign/Cstring.java
--- a/test/jdk/java/foreign/Cstring.java
+++ b/test/jdk/java/foreign/Cstring.java
@@ -26,11 +26,11 @@
 import jdk.incubator.foreign.NativeAllocationScope;
 import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
-import static jdk.incubator.foreign.MemoryLayouts.C_CHAR;
+import static jdk.incubator.foreign.SystemABI.C_CHAR;
 
 public final class Cstring {
     // don't create!
     private Cstring() {
     }
diff a/test/jdk/java/foreign/NativeTestHelper.java b/test/jdk/java/foreign/NativeTestHelper.java
--- a/test/jdk/java/foreign/NativeTestHelper.java
+++ b/test/jdk/java/foreign/NativeTestHelper.java
@@ -22,34 +22,36 @@
  *
  */
 
 import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemoryLayouts.WinABI;
 import jdk.incubator.foreign.SystemABI;
-import jdk.incubator.foreign.SystemABI.Type;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.Utils;
 import java.util.function.Predicate;
 
-import static jdk.incubator.foreign.SystemABI.ABI_WINDOWS;
-
 public class NativeTestHelper {
 
     public static final SystemABI ABI = Foreign.getInstance().getSystemABI();
 
     public static boolean isIntegral(MemoryLayout layout) {
-        return switch(SystemABI.Type.fromLayout(layout)) {
-            case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
-                INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG -> true;
-            default -> false;
+        return switch (ABI.name()) {
+            case SystemABI.SysV.NAME -> layout.attribute(SystemABI.SysV.CLASS_ATTRIBUTE_NAME).get() == SystemABI.SysV.ArgumentClass.INTEGER;
+            case SystemABI.Win64.NAME -> layout.attribute(SystemABI.Win64.CLASS_ATTRIBUTE_NAME).get() == SystemABI.Win64.ArgumentClass.INTEGER;
+            case SystemABI.AArch64.NAME -> layout.attribute(SystemABI.AArch64.CLASS_ATTRIBUTE_NAME).get() == SystemABI.AArch64.ArgumentClass.INTEGER;
+            default -> throw new AssertionError("unexpected ABI: " + ABI.name());
         };
     }
 
     public static boolean isPointer(MemoryLayout layout) {
-        return SystemABI.Type.fromLayout(layout) == Type.POINTER;
+        return switch (ABI.name()) {
+            case SystemABI.SysV.NAME -> layout.attribute(SystemABI.SysV.CLASS_ATTRIBUTE_NAME).get() == SystemABI.SysV.ArgumentClass.POINTER;
+            case SystemABI.Win64.NAME -> layout.attribute(SystemABI.Win64.CLASS_ATTRIBUTE_NAME).get() == SystemABI.Win64.ArgumentClass.POINTER;
+            case SystemABI.AArch64.NAME -> layout.attribute(SystemABI.AArch64.CLASS_ATTRIBUTE_NAME).get() == SystemABI.AArch64.ArgumentClass.POINTER;
+            default -> throw new AssertionError("unexpected ABI: " + ABI.name());
+        };
     }
 
     public static ValueLayout asVarArg(ValueLayout layout) {
-        return ABI.name().equals(ABI_WINDOWS) ? WinABI.asVarArg(layout) : layout;
+        return ABI.name().equals(SystemABI.Win64.NAME) ? SystemABI.Win64.asVarArg(layout) : layout;
     }
 }
diff a/test/jdk/java/foreign/StdLibTest.java b/test/jdk/java/foreign/StdLibTest.java
--- a/test/jdk/java/foreign/StdLibTest.java
+++ b/test/jdk/java/foreign/StdLibTest.java
@@ -60,11 +60,11 @@
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.SystemABI;
 import org.testng.annotations.*;
 
-import static jdk.incubator.foreign.MemoryLayouts.*;
+import static jdk.incubator.foreign.SystemABI.*;
 import static org.testng.Assert.*;
 
 @Test
 public class StdLibTest extends NativeTestHelper {
 
diff a/test/jdk/java/foreign/TestCircularInit1.java b/test/jdk/java/foreign/TestCircularInit1.java
--- a/test/jdk/java/foreign/TestCircularInit1.java
+++ b/test/jdk/java/foreign/TestCircularInit1.java
@@ -25,19 +25,19 @@
  * @test
  * @modules jdk.incubator.foreign
  * @run testng/othervm TestCircularInit1
  */
 
-import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.SystemABI;
 import org.testng.annotations.Test;
 
 import static org.testng.Assert.assertNotNull;
 
 public class TestCircularInit1 {
 
     @Test
     public void testCircularInit() {
-        System.out.println(MemoryLayouts.WinABI.C_BOOL); // trigger clinit
-        assertNotNull(MemoryLayouts.C_BOOL); // should not be null
+        System.out.println(SystemABI.C_BOOL); // trigger clinit
+        assertNotNull(SystemABI.C_BOOL); // should not be null
     }
 
 }
diff a/test/jdk/java/foreign/TestCircularInit2.java b/test/jdk/java/foreign/TestCircularInit2.java
--- a/test/jdk/java/foreign/TestCircularInit2.java
+++ b/test/jdk/java/foreign/TestCircularInit2.java
@@ -25,21 +25,21 @@
  * @test
  * @modules jdk.incubator.foreign
  * @run testng/othervm TestCircularInit2
  */
 
-import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.SystemABI;
 import org.testng.annotations.Test;
 
 import static org.testng.Assert.assertNotNull;
 
 public class TestCircularInit2 {
 
     @Test
     public void testCircularInit() {
-        System.out.println(MemoryLayouts.C_BOOL); // trigger clinit
-        assertNotNull(MemoryLayouts.WinABI.C_BOOL);
-        assertNotNull(MemoryLayouts.SysV.C_BOOL);
-        assertNotNull(MemoryLayouts.AArch64ABI.C_BOOL);
+        System.out.println(SystemABI.C_BOOL); // trigger clinit
+        assertNotNull(SystemABI.C_BOOL);
+        assertNotNull(SystemABI.C_BOOL);
+        assertNotNull(SystemABI.C_BOOL);
     }
 
 }
diff a/test/jdk/java/foreign/TestUpcall.java b/test/jdk/java/foreign/TestUpcall.java
--- a/test/jdk/java/foreign/TestUpcall.java
+++ b/test/jdk/java/foreign/TestUpcall.java
@@ -54,11 +54,11 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 import java.util.stream.Collectors;
 
 import static java.lang.invoke.MethodHandles.insertArguments;
-import static jdk.incubator.foreign.MemoryLayouts.C_POINTER;
+import static jdk.incubator.foreign.SystemABI.C_POINTER;
 import static org.testng.Assert.assertEquals;
 
 
 public class TestUpcall extends CallGeneratorHelper {
 
diff a/test/jdk/java/foreign/TestVarArgs.java b/test/jdk/java/foreign/TestVarArgs.java
--- a/test/jdk/java/foreign/TestVarArgs.java
+++ b/test/jdk/java/foreign/TestVarArgs.java
@@ -50,11 +50,11 @@
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
 
 import static jdk.incubator.foreign.MemoryLayout.PathElement.*;
-import static jdk.incubator.foreign.MemoryLayouts.*;
+import static jdk.incubator.foreign.SystemABI.*;
 import static org.testng.Assert.assertEquals;
 
 public class TestVarArgs extends NativeTestHelper {
 
     static final MemoryLayout ML_CallInfo = MemoryLayout.ofStruct(
diff a/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java b/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
@@ -42,11 +42,11 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodType;
 
-import static jdk.incubator.foreign.MemoryLayouts.AArch64ABI.*;
+import static jdk.incubator.foreign.SystemABI.AArch64.*;
 import static jdk.internal.foreign.abi.Binding.*;
 import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertFalse;
 import static org.testng.Assert.assertTrue;
diff a/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java b/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
@@ -43,12 +43,11 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodType;
 
-import static jdk.incubator.foreign.MemoryLayouts.SysV.*;
-import static jdk.incubator.foreign.MemoryLayouts.WinABI.C_POINTER;
+import static jdk.incubator.foreign.SystemABI.SysV.*;
 import static jdk.internal.foreign.abi.Binding.*;
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertFalse;
 import static org.testng.Assert.assertTrue;
diff a/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java b/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
@@ -42,12 +42,11 @@
 import jdk.internal.foreign.abi.x64.windows.CallArranger;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodType;
 
-import static jdk.incubator.foreign.MemoryLayouts.WinABI.*;
-import static jdk.incubator.foreign.MemoryLayouts.WinABI.asVarArg;
+import static jdk.incubator.foreign.SystemABI.Win64.*;
 import static jdk.internal.foreign.abi.Binding.*;
 import static jdk.internal.foreign.abi.Binding.copy;
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
 import static org.testng.Assert.*;
 
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
@@ -38,11 +38,11 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.util.concurrent.TimeUnit;
 
-import static jdk.incubator.foreign.MemoryLayouts.C_INT;
+import static jdk.incubator.foreign.SystemABI.C_INT;
 
 @BenchmarkMode(Mode.AverageTime)
 @Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)
 @Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)
 @State(org.openjdk.jmh.annotations.Scope.Thread)
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
@@ -35,17 +35,17 @@
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 
 import static java.lang.invoke.MethodType.methodType;
 import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
-import static jdk.incubator.foreign.MemoryLayouts.*;
+import static jdk.incubator.foreign.SystemABI.*;
 
 public class PanamaPoint implements AutoCloseable {
 
     public static final MemoryLayout LAYOUT = MemoryLayout.ofStruct(
-        MemoryLayouts.C_INT.withName("x"),
-        MemoryLayouts.C_INT.withName("y")
+        C_INT.withName("x"),
+        C_INT.withName("y")
     );
 
     private static final VarHandle VH_x = LAYOUT.varHandle(int.class, groupElement("x"));
     private static final VarHandle VH_y = LAYOUT.varHandle(int.class, groupElement("y"));
     private static final MethodHandle MH_distance;

diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java
@@ -0,0 +1,133 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.incubator.foreign;
+
+import jdk.internal.foreign.InternalForeign;
+import jdk.internal.foreign.MemoryAddressImpl;
+import jdk.internal.foreign.Utils;
+import jdk.internal.foreign.abi.aarch64.AArch64ABI;
+import jdk.internal.foreign.abi.x64.sysv.SysVx64ABI;
+import jdk.internal.foreign.abi.x64.windows.Windowsx64ABI;
+
+import java.nio.charset.Charset;
+
+/**
+ * A class containing various methods relating to native interop.
+ */
+public interface Foreign {
+
+    /**
+     * Get an instance of the {@linkplain Foreign} interface.
+     * <p>
+     * Access to this method must be explicitly enabled by setting the {@code jdk.incubator.foreign.Foreign} system
+     * property. The available values are {@code deny}, {@code warn}, {@code debug}, {@code permit}.
+     * <ul>
+     * <li>
+     * If set to {@code deny} an {@linkplain IllegalAccessError} will be thrown.
+     * <li>
+     * If set to {@code warn} a warning message will be written to the standard error stream.
+     * <li>
+     * If set to {@code debug} a debug message and a stack trace will be printed to the standard output stream.
+     * <li>
+     * If set to {@code permit} no special action will be taken.
+     * <li>
+     * If set to any other value an {@linkplain IllegalAccessError} will be thrown.
+     * </ul>
+     * <p>
+     * {@code deny} is the default value.
+     *
+     * @return an instance of {@linkplain Foreign}
+     * @throws IllegalAccessError if {@code jdk.incubator.foreign.Foreign} is set to {@code deny}
+     */
+    static Foreign getInstance() throws IllegalAccessError {
+        return InternalForeign.getInstance();
+    }
+
+    /**
+     * Returns the absolute address represented by the given off-heap memory address as a {@code long}.
+     * <p>
+     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
+     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
+     * restricted methods, and use safe and supported functionalities, where possible.
+     *
+     * @param address the address to turn into a {@code long}
+     * @return the address as a {@code long}
+     * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
+     * @throws IllegalStateException if the given address is not an off-heap address
+     */
+    long asLong(MemoryAddress address) throws IllegalAccessError;
+
+    /**
+     * Returns a new native memory segment with given base address and size. The returned segment has its own temporal
+     * bounds, and can therefore be closed; closing such a segment does <em>not</em> result in any resource being
+     * deallocated.
+     * <p>
+     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
+     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
+     * restricted methods, and use safe and supported functionalities, where possible.
+     * <p>
+     * This method allows for making an otherwise in-accessible memory region accessible. However, there
+     * is no guarantee that this memory is safe to access, or that the given size for the new segment is not too large,
+     * potentially resulting in out-of-bounds accesses. The developer is trusted to make the judgement that the use of the
+     * returned memory segment is safe.
+     *
+     * @param base the desired base address
+     * @param byteSize the desired size.
+     * @return a new native memory segment with given base address and size.
+     * @throws IllegalArgumentException if {@code base} does not encapsulate a native memory address.
+     * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
+     */
+    MemorySegment ofNativeUnchecked(MemoryAddress base, long byteSize) throws IllegalAccessError;
+
+    /**
+     * Obtain an instance of the system ABI.
+     * @return system ABI.
+     */
+    SystemABI getSystemABI();
+
+    /**
+     * Returns a new native memory segment holding contents of the given Java String
+     * @param str the Java String
+     * @return a new native memory segment
+     */
+    MemorySegment toCString(String str);
+
+    /**
+     * Returns a new native memory segment holding contents of the given Java String
+     * @param str The Java String
+     * @param charset The Charset to be used to encode the String
+     * @return a new native memory segment
+     */
+    MemorySegment toCString(String str, Charset charset);
+
+    /**
+     * Returns a Java String from the contents of the given C '\0' terminated string
+     * @param addr The address of the C string
+     * @return a Java String
+     */
+    String toJavaString(MemoryAddress addr);
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
@@ -24,10 +24,11 @@
  *
  */
 
 package jdk.incubator.foreign;
 
+import jdk.internal.foreign.InternalForeign;
 import jdk.internal.foreign.abi.x64.windows.Windowsx64ABI;
 
 import java.nio.ByteOrder;
 
 import static jdk.incubator.foreign.SystemABI.ABI_AARCH64;
@@ -216,11 +217,11 @@
      * The {@code T*} native type.
      */
     public static final ValueLayout C_POINTER;
 
     static {
-        SystemABI abi = SystemABI.getInstance();
+        SystemABI abi = InternalForeign.getInstancePriviledged().getSystemABI();
         switch (abi.name()) {
             case ABI_SYSV -> {
                 C_BOOL = SysV.C_BOOL;
                 C_UCHAR = SysV.C_UCHAR;
                 C_SCHAR = SysV.C_SCHAR;
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
@@ -34,10 +34,12 @@
 import java.lang.invoke.MethodType;
 import java.util.Optional;
 
 /**
  * This class models a system application binary interface (ABI).
+ *
+ * Instances of this class can be obtained by calling {@link Foreign#getSystemABI()}
  */
 public interface SystemABI {
     /**
      * The name of the SysV ABI
      */
@@ -90,30 +92,11 @@
      *
      * @return the name
      */
     String name();
 
-    /**
-     * Obtain an instance of the system ABI.
-     * @return system ABI.
-     */
-    static SystemABI getInstance() {
-        String arch = System.getProperty("os.arch");
-        String os = System.getProperty("os.name");
-        if (arch.equals("amd64") || arch.equals("x86_64")) {
-            if (os.startsWith("Windows")) {
-                return Windowsx64ABI.getInstance();
-            } else {
-                return SysVx64ABI.getInstance();
-            }
-        } else if (arch.equals("aarch64")) {
-            return AArch64ABI.getInstance();
-        }
-        throw new UnsupportedOperationException("Unsupported os or arch: " + os + ", " + arch);
-    }
-
-    public enum Type {
+    enum Type {
         /**
          * The {@code _Bool} native type.
          */
         BOOL,
 
@@ -199,7 +182,7 @@
     }
 
     /**
      * Returns memory layout for the given native type if supported by the platform ABI.
      */
-    public Optional<MemoryLayout> layoutFor(Type type);
+    Optional<MemoryLayout> layoutFor(Type type);
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/unsafe/ForeignUnsafe.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/unsafe/ForeignUnsafe.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/unsafe/ForeignUnsafe.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.incubator.foreign.unsafe;
-
-import java.lang.invoke.VarHandle;
-import java.nio.charset.Charset;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.internal.foreign.MemoryAddressImpl;
-import jdk.internal.foreign.Utils;
-import static jdk.incubator.foreign.MemoryLayouts.C_CHAR;
-
-/**
- * Unsafe methods to allow interop between sun.misc.unsafe and memory access API.
- */
-public final class ForeignUnsafe {
-
-    private ForeignUnsafe() {
-        //just the one, please
-    }
-
-    // The following methods can be used in conjunction with the java.foreign API.
-
-    /**
-     * Obtain the base object (if any) associated with this address. This can be used in conjunction with
-     * {@link #getUnsafeOffset(MemoryAddress)} in order to obtain a base/offset addressing coordinate pair
-     * to be used with methods like {@link sun.misc.Unsafe#getInt(Object, long)} and the likes.
-     *
-     * @param address the address whose base object is to be obtained.
-     * @return the base object associated with the address, or {@code null}.
-     */
-    public static Object getUnsafeBase(MemoryAddress address) {
-        return ((MemoryAddressImpl)address).unsafeGetBase();
-    }
-
-    /**
-     * Obtain the offset associated with this address. If {@link #getUnsafeBase(MemoryAddress)} returns {@code null} on the passed
-     * address, then the offset is to be interpreted as the (absolute) numerical value associated said address.
-     * Alternatively, the offset represents the displacement of a field or an array element within the containing
-     * base object. This can be used in conjunction with {@link #getUnsafeBase(MemoryAddress)} in order to obtain a base/offset
-     * addressing coordinate pair to be used with methods like {@link sun.misc.Unsafe#getInt(Object, long)} and the likes.
-     *
-     * @param address the address whose offset is to be obtained.
-     * @return the offset associated with the address.
-     */
-    public static long getUnsafeOffset(MemoryAddress address) {
-        return ((MemoryAddressImpl)address).unsafeGetOffset();
-    }
-
-    /**
-     * Returns a new native memory segment with given base address and size. The returned segment has its own temporal
-     * bounds, and can therefore be closed; closing such a segment does <em>not</em> result in any resource being
-     * deallocated.
-     * @param base the desired base address
-     * @param byteSize the desired size.
-     * @return a new native memory segment with given base address and size.
-     * @throws IllegalArgumentException if {@code base} does not encapsulate a native memory address.
-     */
-    public static MemorySegment ofNativeUnchecked(MemoryAddress base, long byteSize) {
-        return Utils.makeNativeSegmentUnchecked(base, byteSize);
-    }
-
-    private static VarHandle arrayHandle(MemoryLayout elemLayout, Class<?> elemCarrier) {
-        return MemoryLayout.ofSequence(1, elemLayout)
-                .varHandle(elemCarrier, MemoryLayout.PathElement.sequenceElement());
-    }
-    private final static VarHandle byteArrHandle = arrayHandle(C_CHAR, byte.class);
-
-    /**
-     * Returns a new native memory segment holding contents of the given Java String
-     * @param str the Java String
-     * @return a new native memory segment
-     */
-    public static MemorySegment toCString(String str) {
-        return toCString(str.getBytes());
-    }
-
-    /**
-     * Returns a new native memory segment holding contents of the given Java String
-     * @param str The Java String
-     * @param charset The Charset to be used to encode the String
-     * @return a new native memory segment
-     */
-    public static MemorySegment toCString(String str, Charset charset) {
-        return toCString(str.getBytes(charset));
-    }
-
-    private static MemorySegment toCString(byte[] bytes) {
-        MemoryLayout strLayout = MemoryLayout.ofSequence(bytes.length + 1, C_CHAR);
-        MemorySegment segment = MemorySegment.allocateNative(strLayout);
-        MemoryAddress addr = segment.baseAddress();
-        for (int i = 0 ; i < bytes.length; i++) {
-            byteArrHandle.set(addr, i, bytes[i]);
-        }
-        byteArrHandle.set(addr, (long)bytes.length, (byte)0);
-        return segment;
-    }
-
-    /**
-     * Returns a Java String from the contents of the given C '\0' terminated string
-     * @param addr The address of the C string
-     * @return a Java String
-     */
-    public static String toJavaString(MemoryAddress addr) {
-        StringBuilder buf = new StringBuilder();
-        try (MemorySegment seg = ofNativeUnchecked(addr, Long.MAX_VALUE)) {
-            MemoryAddress baseAddr = seg.baseAddress();
-            byte curr = (byte) byteArrHandle.get(baseAddr, 0);
-            long offset = 0;
-            while (curr != 0) {
-                buf.append((char) curr);
-                curr = (byte) byteArrHandle.get(baseAddr, ++offset);
-            }
-        }
-        return buf.toString();
-    }
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
@@ -0,0 +1,157 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.foreign;
+
+import jdk.incubator.foreign.Foreign;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SystemABI;
+import jdk.internal.foreign.abi.aarch64.AArch64ABI;
+import jdk.internal.foreign.abi.x64.sysv.SysVx64ABI;
+import jdk.internal.foreign.abi.x64.windows.Windowsx64ABI;
+import sun.security.action.GetPropertyAction;
+
+import java.lang.invoke.VarHandle;
+import java.nio.charset.Charset;
+
+import static jdk.incubator.foreign.MemoryLayouts.C_CHAR;
+
+public class InternalForeign implements Foreign {
+
+    private static final String foreignAccess
+            = GetPropertyAction.privilegedGetProperty("jdk.incubator.foreign.Foreign", "deny");
+    private static final InternalForeign INSTANCE = new InternalForeign();
+
+    private InternalForeign() {}
+
+    public static InternalForeign getInstance() {
+        checkRestrictedAcccess();
+        return getInstancePriviledged();
+    }
+
+    public static InternalForeign getInstancePriviledged() {
+        return INSTANCE;
+    }
+
+    @Override
+    public long asLong(MemoryAddress address) throws IllegalAccessError {
+        return MemoryAddressImpl.addressof(address);
+    }
+
+    @Override
+    public MemorySegment ofNativeUnchecked(MemoryAddress base, long byteSize) throws IllegalAccessError {
+        return Utils.makeNativeSegmentUnchecked(base, byteSize);
+    }
+
+    @Override
+    public SystemABI getSystemABI() {
+        String arch = System.getProperty("os.arch");
+        String os = System.getProperty("os.name");
+        if (arch.equals("amd64") || arch.equals("x86_64")) {
+            if (os.startsWith("Windows")) {
+                return Windowsx64ABI.getInstance();
+            } else {
+                return SysVx64ABI.getInstance();
+            }
+        } else if (arch.equals("aarch64")) {
+            return AArch64ABI.getInstance();
+        }
+        throw new UnsupportedOperationException("Unsupported os or arch: " + os + ", " + arch);
+    }
+
+    private static void checkRestrictedAcccess() {
+        switch (foreignAccess) {
+            case "deny" -> throwIllegalAccessError(foreignAccess);
+            case "warn" -> System.err.println("WARNING: Accessing jdk.incubator.foreign.Foreign.");
+            case "debug" -> {
+                StringBuilder sb = new StringBuilder("DEBUG: Accessing jdk.incubator.foreign.Foreign.");
+                StackWalker.getInstance().walk(s -> {
+                     s
+                     .skip(1) // skip checkRestrictedAccess
+                     .forEach(f -> sb.append(System.lineSeparator()).append("\tat " + f));
+                    return null;
+                });
+                System.out.println(sb.toString());
+            }
+            case "permit" -> {}
+            default -> throwIllegalAccessError(foreignAccess);
+        }
+    }
+
+    private static void throwIllegalAccessError(String value) {
+        throw new IllegalAccessError("Can not access jdk.incubator.foreign.Foreign." +
+                " System property 'jdk.incubator.foreign.Foreign' is set to '" + value + "'");
+    }
+
+    private static VarHandle arrayHandle(MemoryLayout elemLayout, Class<?> elemCarrier) {
+        return MemoryLayout.ofSequence(1, elemLayout)
+                .varHandle(elemCarrier, MemoryLayout.PathElement.sequenceElement());
+    }
+
+
+    @Override
+    public MemorySegment toCString(String str) {
+        return toCString(str.getBytes());
+    }
+
+    @Override
+    public MemorySegment toCString(String str, Charset charset) {
+        return toCString(str.getBytes(charset));
+    }
+
+    private MemorySegment toCString(byte[] bytes) {
+        MemoryLayout strLayout = MemoryLayout.ofSequence(bytes.length + 1, C_CHAR);
+        MemorySegment segment = MemorySegment.allocateNative(strLayout);
+        MemoryAddress addr = segment.baseAddress();
+        for (int i = 0 ; i < bytes.length; i++) {
+            Lazy.byteArrHandle.set(addr, i, bytes[i]);
+        }
+        Lazy.byteArrHandle.set(addr, (long)bytes.length, (byte)0);
+        return segment;
+    }
+
+    @Override
+    public String toJavaString(MemoryAddress addr) {
+        StringBuilder buf = new StringBuilder();
+        try (MemorySegment seg = ofNativeUnchecked(addr, Long.MAX_VALUE)) {
+            MemoryAddress baseAddr = seg.baseAddress();
+            byte curr = (byte) Lazy.byteArrHandle.get(baseAddr, 0);
+            long offset = 0;
+            while (curr != 0) {
+                buf.append((char) curr);
+                curr = (byte) Lazy.byteArrHandle.get(baseAddr, ++offset);
+            }
+        }
+        return buf.toString();
+    }
+
+    // need to lazily initialize this to prevent circular init
+    // MemoryLayouts -> Foreign -> MemoryLayouts
+    private static class Lazy {
+        final static VarHandle byteArrHandle = arrayHandle(C_CHAR, byte.class);
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
@@ -53,11 +53,10 @@
     public static final int MAX_INTEGER_RETURN_REGISTERS = 2;
     public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 8;
     public static final int MAX_VECTOR_RETURN_REGISTERS = 2;
     public static final int MAX_X87_RETURN_REGISTERS = 2;
 
-    private static final String fastPath = privilegedGetProperty("jdk.internal.foreign.NativeInvoker.FASTPATH");
     private static SysVx64ABI instance;
 
     public static SysVx64ABI getInstance() {
         if (instance == null) {
             instance = new SysVx64ABI();
diff a/test/jdk/java/foreign/CallGeneratorHelper.java b/test/jdk/java/foreign/CallGeneratorHelper.java
--- a/test/jdk/java/foreign/CallGeneratorHelper.java
+++ b/test/jdk/java/foreign/CallGeneratorHelper.java
@@ -20,16 +20,16 @@
  *  or visit www.oracle.com if you need additional information or have any
  *  questions.
  *
  */
 
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.ValueLayout;
-import jdk.incubator.foreign.unsafe.ForeignUnsafe;
 import jdk.internal.foreign.Utils;
 
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
@@ -389,11 +389,11 @@
             if (Utils.isPadding(l)) continue;
             VarHandle accessor = g.varHandle(structFieldCarrier(l), MemoryLayout.PathElement.groupElement(l.name().get()));
             List<Consumer<Object>> fieldsCheck = new ArrayList<>();
             Object value = makeArg(l, fieldsCheck, check);
             if (isPointer(l)) {
-                value = ForeignUnsafe.getUnsafeOffset((MemoryAddress)value);
+                value = Foreign.getInstance().asLong((MemoryAddress)value);
             }
             //set value
             accessor.set(str.baseAddress(), value);
             //add check
             if (check) {
diff a/test/jdk/java/foreign/NativeTestHelper.java b/test/jdk/java/foreign/NativeTestHelper.java
--- a/test/jdk/java/foreign/NativeTestHelper.java
+++ b/test/jdk/java/foreign/NativeTestHelper.java
@@ -20,10 +20,11 @@
  *  or visit www.oracle.com if you need additional information or have any
  *  questions.
  *
  */
 
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts.WinABI;
 import jdk.incubator.foreign.SystemABI;
 import jdk.incubator.foreign.SystemABI.Type;
 import jdk.incubator.foreign.ValueLayout;
@@ -32,11 +33,11 @@
 
 import static jdk.incubator.foreign.SystemABI.ABI_WINDOWS;
 
 public class NativeTestHelper {
 
-    public static final SystemABI ABI = SystemABI.getInstance();
+    public static final SystemABI ABI = Foreign.getInstance().getSystemABI();
 
     public static boolean isIntegral(MemoryLayout layout) {
         var optAbiType = layout.abiType();
         if (!optAbiType.isPresent()) {
             return false;
diff a/test/jdk/java/foreign/StdLibTest.java b/test/jdk/java/foreign/StdLibTest.java
--- a/test/jdk/java/foreign/StdLibTest.java
+++ b/test/jdk/java/foreign/StdLibTest.java
@@ -28,12 +28,11 @@
   * @modules jdk.incubator.foreign/jdk.incubator.foreign.unsafe
  *          jdk.incubator.foreign/jdk.internal.foreign
  *          jdk.incubator.foreign/jdk.internal.foreign.abi
  *          java.base/sun.security.action
  * @build NativeTestHelper StdLibTest
- * @run testng StdLibTest
- * @run testng/othervm -Djdk.internal.foreign.NativeInvoker.FASTPATH=none -Djdk.internal.foreign.UpcallHandler.FASTPATH=none StdLibTest
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit StdLibTest
  */
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
@@ -52,28 +51,29 @@
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.LongStream;
 import java.util.stream.Stream;
 
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.SystemABI;
-import jdk.incubator.foreign.unsafe.ForeignUnsafe;
 import org.testng.annotations.*;
 
 import static jdk.incubator.foreign.MemoryLayouts.*;
 import static org.testng.Assert.*;
 
 @Test
 public class StdLibTest extends NativeTestHelper {
 
-    final static SystemABI abi = SystemABI.getInstance();
+    final static Foreign FOREIGN = Foreign.getInstance();
+    final static SystemABI abi = FOREIGN.getSystemABI();
 
     final static VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
     final static VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
     final static VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
     final static VarHandle byteArrHandle = arrayHandle(C_CHAR, byte.class);
@@ -267,11 +267,11 @@
             private MemoryAddress base;
 
             static final long SIZE = 56;
 
             Tm(MemoryAddress base) {
-                this.base = base.rebase(ForeignUnsafe.ofNativeUnchecked(base, SIZE));
+                this.base = base.rebase(FOREIGN.ofNativeUnchecked(base, SIZE));
             }
 
             int sec() {
                 return (int)intHandle.get(base);
             }
@@ -450,12 +450,12 @@
                     }).collect(Collectors.toCollection(LinkedHashSet::new));
         }
     }
 
     static MemorySegment toCString(String value) {
-        return ForeignUnsafe.toCString(value);
+        return FOREIGN.toCString(value);
     }
 
     static String toJavaString(MemoryAddress address) {
-        return ForeignUnsafe.toJavaString(address);
+        return FOREIGN.toJavaString(address);
     }
 }
diff a/test/jdk/java/foreign/Test8241148.java b/test/jdk/java/foreign/Test8241148.java
--- a/test/jdk/java/foreign/Test8241148.java
+++ b/test/jdk/java/foreign/Test8241148.java
@@ -23,15 +23,16 @@
  * questions.
  */
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
+
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.SystemABI;
-import jdk.incubator.foreign.unsafe.ForeignUnsafe;
 
 import org.testng.annotations.*;
 import static jdk.incubator.foreign.MemoryLayouts.*;
 import static org.testng.Assert.*;
 
@@ -40,20 +41,21 @@
  * @bug 8241148
  * @summary need a way to create MemorySegment with contents from java String and a way to read a C char* as java String
  * @modules jdk.incubator.foreign/jdk.incubator.foreign.unsafe
  *          jdk.incubator.foreign/jdk.internal.foreign
  *          jdk.incubator.foreign/jdk.internal.foreign.abi
- * @run testng Test8241148
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit Test8241148
  */
 @Test
 public class Test8241148 {
+    private final static Foreign FOREIGN = Foreign.getInstance();
     private final static MethodHandle getenv;
     private final static MethodHandle strlen;
 
     static {
         try {
-            SystemABI abi = SystemABI.getInstance();
+            SystemABI abi = FOREIGN.getSystemABI();
             LibraryLookup lookup = LibraryLookup.ofDefault();
 
             getenv = abi.downcallHandle(lookup.lookup("getenv"),
                     MethodType.methodType(MemoryAddress.class, MemoryAddress.class),
                     FunctionDescriptor.of(C_POINTER, C_POINTER));
@@ -66,18 +68,18 @@
         }
     }
 
     @Test
     public void test() throws Throwable {
-        try (var seg = ForeignUnsafe.toCString("java")) {
+        try (var seg = FOREIGN.toCString("java")) {
             assertEquals((int) strlen.invoke(seg.baseAddress()), 4);
         }
         var envMap = System.getenv();
         for (var entry : envMap.entrySet()) {
-            try (var envVar = ForeignUnsafe.toCString(entry.getKey())) {
+            try (var envVar = FOREIGN.toCString(entry.getKey())) {
                 var envValue = (MemoryAddress) getenv.invoke(envVar.baseAddress());
-                var envValueStr = ForeignUnsafe.toJavaString(envValue);
+                var envValueStr = FOREIGN.toJavaString(envValue);
                 assertEquals(entry.getValue(), envValueStr);
                 System.out.println(entry.getKey() + " = " + envValueStr);
             }
         }
     }
diff a/test/jdk/java/foreign/TestDowncall.java b/test/jdk/java/foreign/TestDowncall.java
--- a/test/jdk/java/foreign/TestDowncall.java
+++ b/test/jdk/java/foreign/TestDowncall.java
@@ -30,14 +30,14 @@
  *          jdk.incubator.foreign/jdk.internal.foreign
  *          jdk.incubator.foreign/jdk.internal.foreign.abi
  *          java.base/sun.security.action
  * @build NativeTestHelper CallGeneratorHelper TestDowncall
  *
- * @run testng/othervm -Djdk.internal.foreign.NativeInvoker.FASTPATH=none TestDowncall
- * @run testng/othervm TestDowncall
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit TestDowncall
  */
 
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.SystemABI;
@@ -53,11 +53,11 @@
 import static org.testng.Assert.*;
 
 public class TestDowncall extends CallGeneratorHelper {
 
     static LibraryLookup lib = LibraryLookup.ofLibrary(MethodHandles.lookup(), "TestDowncall");
-    static SystemABI abi = SystemABI.getInstance();
+    static SystemABI abi = Foreign.getInstance().getSystemABI();
 
 
     @Test(dataProvider="functions", dataProviderClass=CallGeneratorHelper.class)
     public void testDowncall(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {
         List<Consumer<Object>> checks = new ArrayList<>();
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -24,17 +24,17 @@
 
 /*
  * @test
  * @modules java.base/jdk.internal.misc
  *          jdk.incubator.foreign/jdk.incubator.foreign.unsafe
- * @run testng TestNative
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit TestNative
  */
 
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
-import jdk.incubator.foreign.unsafe.ForeignUnsafe;
 import jdk.internal.misc.Unsafe;
 import org.testng.annotations.*;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
@@ -116,11 +116,11 @@
         ByteBuffer bb = base.segment().asSlice(base.offset(), (int)layout.byteSize()).asByteBuffer();
         Z z = bufferFactory.apply(bb);
         for (long i = 0 ; i < nelems ; i++) {
             Object handleValue = handleExtractor.apply(base, i);
             Object bufferValue = nativeBufferExtractor.apply(z, (int)i);
-            Object rawValue = nativeRawExtractor.apply(ForeignUnsafe.getUnsafeOffset(base), (int)i);
+            Object rawValue = nativeRawExtractor.apply(Foreign.getInstance().asLong(base), (int)i);
             if (handleValue instanceof Number) {
                 assertEquals(((Number)handleValue).longValue(), i);
                 assertEquals(((Number)bufferValue).longValue(), i);
                 assertEquals(((Number)rawValue).longValue(), i);
             } else {
diff a/test/jdk/java/foreign/TestUpcall.java b/test/jdk/java/foreign/TestUpcall.java
--- a/test/jdk/java/foreign/TestUpcall.java
+++ b/test/jdk/java/foreign/TestUpcall.java
@@ -28,14 +28,14 @@
  *          jdk.incubator.foreign/jdk.internal.foreign
  *          jdk.incubator.foreign/jdk.internal.foreign.abi
  *          java.base/sun.security.action
  * @build NativeTestHelper CallGeneratorHelper TestUpcall
  *
- * @run testng/othervm -Djdk.internal.foreign.UpcallHandler.FASTPATH=none TestUpcall
- * @run testng/othervm TestUpcall
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit TestUpcall
  */
 
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
@@ -61,11 +61,11 @@
 
 
 public class TestUpcall extends CallGeneratorHelper {
 
     static LibraryLookup lib = LibraryLookup.ofLibrary(MethodHandles.lookup(), "TestUpcall");
-    static SystemABI abi = SystemABI.getInstance();
+    static SystemABI abi = Foreign.getInstance().getSystemABI();
     static final MemoryAddress dummyAddress;
     static final Cleaner cleaner = Cleaner.create();
 
     static MethodHandle DUMMY;
     static MethodHandle PASS_AND_SAVE;
diff a/test/jdk/java/foreign/TestUpcallStubs.java b/test/jdk/java/foreign/TestUpcallStubs.java
--- a/test/jdk/java/foreign/TestUpcallStubs.java
+++ b/test/jdk/java/foreign/TestUpcallStubs.java
@@ -22,13 +22,14 @@
  *
  */
 
 /*
  * @test
- * @run testng TestUpcallStubs
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit TestUpcallStubs
  */
 
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SystemABI;
 import org.testng.annotations.*;
@@ -40,11 +41,11 @@
 
 import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;
 
 public class TestUpcallStubs {
 
-    static final SystemABI abi = SystemABI.getInstance();
+    static final SystemABI abi = Foreign.getInstance().getSystemABI();
     static final MethodHandle MH_dummy;
 
     static {
         try {
             MH_dummy = MethodHandles.lookup()
diff a/test/jdk/java/foreign/TestVarArgs.java b/test/jdk/java/foreign/TestVarArgs.java
--- a/test/jdk/java/foreign/TestVarArgs.java
+++ b/test/jdk/java/foreign/TestVarArgs.java
@@ -26,13 +26,14 @@
  * @test
  * @modules jdk.incubator.foreign/jdk.incubator.foreign.unsafe
  *          jdk.incubator.foreign/jdk.internal.foreign
  *          jdk.incubator.foreign/jdk.internal.foreign.abi
  *          java.base/sun.security.action
- * @run testng TestVarArgs
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit TestVarArgs
  */
 
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
@@ -63,11 +64,11 @@
     static final VarHandle VH_CallInfo_writeback = ML_CallInfo.varHandle(long.class, groupElement("writeback"));
     static final VarHandle VH_CallInfo_argIDs = ML_CallInfo.varHandle(long.class, groupElement("argIDs"));
 
     static final VarHandle VH_IntArray = MemoryLayout.ofSequence(C_INT).varHandle(int.class, sequenceElement());
 
-    static final SystemABI abi = SystemABI.getInstance();
+    static final SystemABI abi = Foreign.getInstance().getSystemABI();
     static final MemoryAddress varargsAddr;
 
     static {
         try {
             varargsAddr = LibraryLookup.ofLibrary(MethodHandles.lookup(), "VarArgs").lookup("varargs");

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemorySegment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
25  */
26 
27 /**
28  * &lt;p&gt; Classes to support low-level, safe and efficient memory access.
29  * &lt;p&gt;
30  * The key abstractions introduced by this package are {@link jdk.incubator.foreign.MemorySegment} and {@link jdk.incubator.foreign.MemoryAddress}.
31  * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which can
32  * sometimes be expressed as an offset into a given segment. A memory address represents the main access coordinate of a memory access var handle, which can be obtained
33  * using the combinator methods defined in the {@link jdk.incubator.foreign.MemoryHandles} class. Finally, the {@link jdk.incubator.foreign.MemoryLayout} class
34  * hierarchy enables description of &lt;em&gt;memory layouts&lt;/em&gt; and basic operations such as computing the size in bytes of a given
35  * layout, obtain its alignment requirements, and so on. Memory layouts also provide an alternate, more abstract way, to produce
36  * memory access var handles, e.g. using &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;.
37  *
38  * For example, to allocate an off-heap memory region big enough to hold 10 values of the primitive type {@code int}, and fill it with values
39  * ranging from {@code 0} to {@code 9}, we can use the following code:
40  *
41  * &lt;pre&gt;{@code
42 static final VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
43 
44 try (MemorySegment segment = MemorySegment.allocateNative(10 * 4)) {
<span class="line-modified">45     MemoryAddress base = segment.baseAddress();</span>
46     for (long i = 0 ; i &lt; 10 ; i++) {
47        intHandle.set(base.addOffset(i * 4), (int)i);
48     }
49 }
50  * }&lt;/pre&gt;
51  *
52  * Here we create a var handle, namely {@code intHandle}, to manipulate values of the primitive type {@code int}, at
53  * a given memory location. Also, {@code intHandle} is stored in a {@code static} and {@code final} field, to achieve
54  * better performance and allow for inlining of the memory access operation through the {@link java.lang.invoke.VarHandle}
55  * instance. We then create a &lt;em&gt;native&lt;/em&gt; memory segment, that is, a memory segment backed by
56  * off-heap memory; the size of the segment is 40 bytes, enough to store 10 values of the primitive type {@code int}.
57  * The segment is created inside a &lt;em&gt;try-with-resources&lt;/em&gt; construct: this idiom ensures that all the memory resources
58  * associated with the segment will be released at the end of the block, according to the semantics described in
59  * Section {@jls 14.20.3} of &lt;cite&gt;The Java Language Specification&lt;/cite&gt;. Inside the try-with-resources block, we initialize
60  * the contents of the memory segment; more specifically, if we view the memory segment as a set of 10 adjacent slots,
61  * {@code s[i]}, where {@code 0 &lt;= i &lt; 10}, where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot
62  * so that {@code s[i] = i}, again where {@code 0 &lt;= i &lt; 10}.
63  *
64  * &lt;h2&gt;&lt;a id=&quot;deallocation&quot;&gt;&lt;/a&gt;Deterministic deallocation&lt;/h2&gt;
65  *
</pre>
</td>
<td>
<hr />
<pre>
25  */
26 
27 /**
28  * &lt;p&gt; Classes to support low-level, safe and efficient memory access.
29  * &lt;p&gt;
30  * The key abstractions introduced by this package are {@link jdk.incubator.foreign.MemorySegment} and {@link jdk.incubator.foreign.MemoryAddress}.
31  * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which can
32  * sometimes be expressed as an offset into a given segment. A memory address represents the main access coordinate of a memory access var handle, which can be obtained
33  * using the combinator methods defined in the {@link jdk.incubator.foreign.MemoryHandles} class. Finally, the {@link jdk.incubator.foreign.MemoryLayout} class
34  * hierarchy enables description of &lt;em&gt;memory layouts&lt;/em&gt; and basic operations such as computing the size in bytes of a given
35  * layout, obtain its alignment requirements, and so on. Memory layouts also provide an alternate, more abstract way, to produce
36  * memory access var handles, e.g. using &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;.
37  *
38  * For example, to allocate an off-heap memory region big enough to hold 10 values of the primitive type {@code int}, and fill it with values
39  * ranging from {@code 0} to {@code 9}, we can use the following code:
40  *
41  * &lt;pre&gt;{@code
42 static final VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
43 
44 try (MemorySegment segment = MemorySegment.allocateNative(10 * 4)) {
<span class="line-modified">45     MemoryAddress base = segment.address();</span>
46     for (long i = 0 ; i &lt; 10 ; i++) {
47        intHandle.set(base.addOffset(i * 4), (int)i);
48     }
49 }
50  * }&lt;/pre&gt;
51  *
52  * Here we create a var handle, namely {@code intHandle}, to manipulate values of the primitive type {@code int}, at
53  * a given memory location. Also, {@code intHandle} is stored in a {@code static} and {@code final} field, to achieve
54  * better performance and allow for inlining of the memory access operation through the {@link java.lang.invoke.VarHandle}
55  * instance. We then create a &lt;em&gt;native&lt;/em&gt; memory segment, that is, a memory segment backed by
56  * off-heap memory; the size of the segment is 40 bytes, enough to store 10 values of the primitive type {@code int}.
57  * The segment is created inside a &lt;em&gt;try-with-resources&lt;/em&gt; construct: this idiom ensures that all the memory resources
58  * associated with the segment will be released at the end of the block, according to the semantics described in
59  * Section {@jls 14.20.3} of &lt;cite&gt;The Java Language Specification&lt;/cite&gt;. Inside the try-with-resources block, we initialize
60  * the contents of the memory segment; more specifically, if we view the memory segment as a set of 10 adjacent slots,
61  * {@code s[i]}, where {@code 0 &lt;= i &lt; 10}, where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot
62  * so that {@code s[i] = i}, again where {@code 0 &lt;= i &lt; 10}.
63  *
64  * &lt;h2&gt;&lt;a id=&quot;deallocation&quot;&gt;&lt;/a&gt;Deterministic deallocation&lt;/h2&gt;
65  *
</pre>
</td>
</tr>
</table>
<center><a href="MemorySegment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
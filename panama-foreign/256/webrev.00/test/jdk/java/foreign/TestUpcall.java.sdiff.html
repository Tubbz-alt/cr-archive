<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestUpcall.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="TestLibraryLookup.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestVarArgs.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestUpcall.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 96             throw new IllegalStateException(ex);
 97         }
 98     }
 99 
100     static MemoryAddress dummyAddress;
101 
102     @BeforeClass
103     void setup() {
104         dummyAddress = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid()).address();
105     }
106 
107     @AfterClass
108     void teardown() {
109         dummyAddress.segment().close();
110     }
111 
112     @Test(dataProvider=&quot;functions&quot;, dataProviderClass=CallGeneratorHelper.class)
113     public void testUpcalls(String fName, Ret ret, List&lt;ParamType&gt; paramTypes, List&lt;StructFieldType&gt; fields) throws Throwable {
114         List&lt;Consumer&lt;Object&gt;&gt; returnChecks = new ArrayList&lt;&gt;();
115         List&lt;Consumer&lt;Object[]&gt;&gt; argChecks = new ArrayList&lt;&gt;();
<span class="line-modified">116         MemoryAddress addr = lib.lookup(fName);</span>
117         MethodHandle mh = abi.downcallHandle(addr, methodType(ret, paramTypes, fields), function(ret, paramTypes, fields));
118         Object[] args = makeArgs(ret, paramTypes, fields, returnChecks, argChecks);
119         mh = mh.asSpreader(Object[].class, paramTypes.size() + 1);
120         Object res = mh.invoke(args);
121         argChecks.forEach(c -&gt; c.accept(args));
122         if (ret == Ret.NON_VOID) {
123             returnChecks.forEach(c -&gt; c.accept(res));
124         }
125         for (Object arg : args) {
126             if (arg != dummyAddress) {
127                 cleanup(arg);
128             }
129         }
130     }
131 
132     static MethodType methodType(Ret ret, List&lt;ParamType&gt; params, List&lt;StructFieldType&gt; fields) {
133         MethodType mt = ret == Ret.VOID ?
134                 MethodType.methodType(void.class) : MethodType.methodType(paramCarrier(params.get(0).layout(fields)));
135         for (ParamType p : params) {
136             mt = mt.appendParameterTypes(paramCarrier(p.layout(fields)));
</pre>
</td>
<td>
<hr />
<pre>
 96             throw new IllegalStateException(ex);
 97         }
 98     }
 99 
100     static MemoryAddress dummyAddress;
101 
102     @BeforeClass
103     void setup() {
104         dummyAddress = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid()).address();
105     }
106 
107     @AfterClass
108     void teardown() {
109         dummyAddress.segment().close();
110     }
111 
112     @Test(dataProvider=&quot;functions&quot;, dataProviderClass=CallGeneratorHelper.class)
113     public void testUpcalls(String fName, Ret ret, List&lt;ParamType&gt; paramTypes, List&lt;StructFieldType&gt; fields) throws Throwable {
114         List&lt;Consumer&lt;Object&gt;&gt; returnChecks = new ArrayList&lt;&gt;();
115         List&lt;Consumer&lt;Object[]&gt;&gt; argChecks = new ArrayList&lt;&gt;();
<span class="line-modified">116         LibraryLookup.Symbol addr = lib.lookup(fName);</span>
117         MethodHandle mh = abi.downcallHandle(addr, methodType(ret, paramTypes, fields), function(ret, paramTypes, fields));
118         Object[] args = makeArgs(ret, paramTypes, fields, returnChecks, argChecks);
119         mh = mh.asSpreader(Object[].class, paramTypes.size() + 1);
120         Object res = mh.invoke(args);
121         argChecks.forEach(c -&gt; c.accept(args));
122         if (ret == Ret.NON_VOID) {
123             returnChecks.forEach(c -&gt; c.accept(res));
124         }
125         for (Object arg : args) {
126             if (arg != dummyAddress) {
127                 cleanup(arg);
128             }
129         }
130     }
131 
132     static MethodType methodType(Ret ret, List&lt;ParamType&gt; params, List&lt;StructFieldType&gt; fields) {
133         MethodType mt = ret == Ret.VOID ?
134                 MethodType.methodType(void.class) : MethodType.methodType(paramCarrier(params.get(0).layout(fields)));
135         for (ParamType p : params) {
136             mt = mt.appendParameterTypes(paramCarrier(p.layout(fields)));
</pre>
</td>
</tr>
</table>
<center><a href="TestLibraryLookup.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestVarArgs.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Addressable.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Addressable.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Addressable.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Addressable.java
@@ -26,15 +26,16 @@
 package jdk.incubator.foreign;
 
 /**
  * Represents a type which is <em>addressable</em>. An addressable type is one which can be projected down to
  * a memory address instance (see {@link #address()}). Examples of addressable types are {@link MemorySegment},
- * and {@link MemoryAddress}.
+ * {@link MemoryAddress}, {@link LibraryLookup.Symbol} and {@link CSupport.VaList}.
  *
  * @apiNote In the future, if the Java language permits, {@link Addressable}
  * may become a {@code sealed} interface, which would prohibit subclassing except by
- * explicitly permitted types, such as {@link MemorySegment} and {@link MemoryAddress}.
+ * explicitly permitted types, such as {@link MemorySegment}, {@link MemoryAddress}, {@link LibraryLookup.Symbol}
+ * and {@link CSupport.VaList}.
  *
  * @implSpec
  * Implementations of this interface <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>.
  */
 public interface Addressable {
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
@@ -64,11 +64,11 @@
      * and which erases all {@code float} arguments to {@code double}.
      * <p>
      * As such, this interface only supports reading {@code int}, {@code double},
      * and any other type that fits into a {@code long}.
      */
-    public interface VaList extends AutoCloseable {
+    public interface VaList extends Addressable, AutoCloseable {
 
         /**
          * Reads the next value as an {@code int} and advances this va list's position.
          *
          * @param layout the layout of the value
@@ -212,10 +212,11 @@
         /**
          * Returns the memory address of the C {@code va_list} associated with this instance.
          *
          * @return the memory address of the C {@code va_list} associated with this instance.
          */
+        @Override
         MemoryAddress address();
 
         /**
          * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.
          *
@@ -259,10 +260,11 @@
          * Note that when there are no elements added to the created va list,
          * this method will return the same as {@linkplain #empty()}.
          *
          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
          *                of the underlying C {@code va_list}.
+         * @param scope the scope to be used for the valist allocation.
          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
          */
         static VaList make(Consumer<VaList.Builder> actions, NativeScope scope) {
             return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
         }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ForeignLinker.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ForeignLinker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ForeignLinker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ForeignLinker.java
@@ -41,11 +41,11 @@
      * @param symbol downcall symbol.
      * @param type the method type.
      * @param function the function descriptor.
      * @return the downcall method handle.
      */
-    MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function);
+    MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function);
 
     /**
      * Allocates a native stub segment which contains executable code to upcall into a given method handle.
      * As such, the base address of the returned stub segment can be passed to other foreign functions
      * (as a function pointer). The returned segment is <em>not</em> thread-confined, and it only features
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/LibraryLookup.java
@@ -36,28 +36,47 @@
  * A given native library remains loaded as long as there is at least one <em>live</em> library lookup instance referring
  * to it.
  * <p>
  * Memory address instances generated by a library lookup will contain a strong reference to the originating lookup object,
  * therefore preventing library unloading; in turn method handle instances obtained from
- * {@link ForeignLinker#downcallHandle(MemoryAddress, MethodType, FunctionDescriptor)}) also maintain a strong reference
+ * {@link ForeignLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor)}) also maintain a strong reference
  * to the memory address parameter used for their construction. This means that there is always a strong reachability chain
  * from a native method handle to a lookup object (the one that was used to lookup the native library symbol the method handle
  * refers to); this is useful to prevent situations where a native library is unloaded in the middle of a native call.
  * <p>
  * To allow for a library to be unloaded, a client will have to discard any strong references it
  * maintains, directly, or indirectly to a lookup object associated with given library.
  */
 public interface LibraryLookup {
 
+    /**
+     * A symbol retrieved during a library lookup. A lookup symbol has a <em>name</em> and can be projected
+     * into a memory address (see {@link #name()} and {@link #address()}, respectively).
+     */
+    interface Symbol extends Addressable {
+        /**
+         * The name of this lookup symbol.
+         * @return the name of this lookup symbol.
+         */
+        String name();
+
+        /**
+         * The memory address of this lookup symbol.
+         * @return the memory address of this lookup symbol.
+         */
+        @Override
+        MemoryAddress address();
+    }
+
     /**
      * Lookups a symbol with given name in this library. The returned address has the same temporal bounds
      * as this lookup object.
      * @param name the symbol name.
      * @return the library symbol (if any)
      * @throws NoSuchMethodException if no symbol with given name could be found.
      */
-    MemoryAddress lookup(String name) throws NoSuchMethodException;
+    Symbol lookup(String name) throws NoSuchMethodException;
 
     /**
      * Obtain a default library lookup object.
      * @return the default library lookup object.
      */
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
@@ -113,15 +113,23 @@
         LibraryLookupImpl(NativeLibrary library) {
             this.library = library;
         }
 
         @Override
-        public MemoryAddress lookup(String name) throws NoSuchMethodException {
-            long addr = library.lookup(name);
-            return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(addr),
-                    0, null, null, this)
-                    .address();
+        public Symbol lookup(String name) throws NoSuchMethodException {
+            MemoryAddress addr = MemoryAddress.ofLong(library.lookup(name));
+            return new Symbol() { // inner class - retains a link to enclosing lookup
+                @Override
+                public String name() {
+                    return name;
+                }
+
+                @Override
+                public MemoryAddress address() {
+                    return addr;
+                }
+            };
         }
 
         static LibraryLookup DEFAULT_LOOKUP = new LibraryLookupImpl(NativeLibraries.defaultLibrary);
     }
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
@@ -20,10 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi;
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.NativeScope;
 import jdk.internal.access.JavaLangInvokeAccess;
@@ -105,16 +106,16 @@
     private final MemoryAddress addr;
     private final long stubAddress;
 
     private final long bufferCopySize;
 
-    public ProgrammableInvoker(ABIDescriptor abi, MemoryAddress addr, CallingSequence callingSequence) {
+    public ProgrammableInvoker(ABIDescriptor abi, Addressable addr, CallingSequence callingSequence) {
         this.abi = abi;
         this.layout = BufferLayout.of(abi);
         this.stubAddress = adapterStubs.computeIfAbsent(abi, key -> generateAdapter(key, layout));
 
-        this.addr = addr;
+        this.addr = addr.address();
         this.callingSequence = callingSequence;
 
         this.stackArgsBytes = callingSequence.argMoveBindings()
                 .map(Binding.Move::storage)
                 .filter(s -> abi.arch.isStackType(s.type()))
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
@@ -23,10 +23,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi.aarch64;
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
@@ -71,11 +72,11 @@
         }
         return instance;
     }
 
     @Override
-    public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {
         MethodType llMt = SharedUtils.convertVaListCarriers(type, AArch64VaList.CARRIER);
         MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);
         handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);
         return handle;
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
@@ -21,10 +21,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi.aarch64;
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
@@ -122,11 +123,11 @@
         csb.setTrivial(SharedUtils.isTrivial(cDesc));
 
         return new Bindings(csb.build(), returnInMemory);
     }
 
-    public static MethodHandle arrangeDowncall(MemoryAddress addr, MethodType mt, FunctionDescriptor cDesc) {
+    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {
         Bindings bindings = getBindings(mt, cDesc, false);
 
         MethodHandle handle = new ProgrammableInvoker(C, addr, bindings.callingSequence).getBoundMethodHandle();
 
         if (bindings.isInMemoryReturn) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -23,10 +23,11 @@
  *  questions.
  *
  */
 package jdk.internal.foreign.abi.x64.sysv;
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
@@ -119,11 +120,11 @@
         csb.setTrivial(SharedUtils.isTrivial(cDesc));
 
         return new Bindings(csb.build(), returnInMemory, argCalc.storageCalculator.nVectorReg);
     }
 
-    public static MethodHandle arrangeDowncall(MemoryAddress addr, MethodType mt, FunctionDescriptor cDesc) {
+    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {
         Bindings bindings = getBindings(mt, cDesc, false);
 
         MethodHandle handle = new ProgrammableInvoker(CSysV, addr, bindings.callingSequence).getBoundMethodHandle();
         handle = MethodHandles.insertArguments(handle, handle.type().parameterCount() - 1, bindings.nVectorArgs);
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64Linker.java
@@ -22,10 +22,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi.x64.sysv;
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
@@ -82,11 +83,11 @@
         actions.accept(builder);
         return builder.build();
     }
 
     @Override
-    public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {
         MethodType llMt = SharedUtils.convertVaListCarriers(type, SysVVaList.CARRIER);
         MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);
         handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);
         return handle;
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
@@ -20,10 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi.x64.windows;
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
@@ -118,11 +119,11 @@
         csb.csb.setTrivial(SharedUtils.isTrivial(cDesc));
 
         return new Bindings(csb.csb.build(), returnInMemory);
     }
 
-    public static MethodHandle arrangeDowncall(MemoryAddress addr, MethodType mt, FunctionDescriptor cDesc) {
+    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {
         Bindings bindings = getBindings(mt, cDesc, false);
 
         MethodHandle handle = new ProgrammableInvoker(CWindows, addr, bindings.callingSequence).getBoundMethodHandle();
 
         if (bindings.isInMemoryReturn) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64Linker.java
@@ -22,10 +22,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi.x64.windows;
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
@@ -83,11 +84,11 @@
         actions.accept(builder);
         return builder.build();
     }
 
     @Override
-    public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {
         MethodType llMt = SharedUtils.convertVaListCarriers(type, WinVaList.CARRIER);
         MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);
         handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);
         return handle;
     }
diff a/test/jdk/java/foreign/StdLibTest.java b/test/jdk/java/foreign/StdLibTest.java
--- a/test/jdk/java/foreign/StdLibTest.java
+++ b/test/jdk/java/foreign/StdLibTest.java
@@ -173,11 +173,11 @@
         final static MethodHandle qsort;
         final static MethodHandle qsortCompar;
         final static FunctionDescriptor qsortComparFunction;
         final static MethodHandle rand;
         final static MethodHandle vprintf;
-        final static MemoryAddress printfAddr;
+        final static LibraryLookup.Symbol printfAddr;
         final static FunctionDescriptor printfBase;
 
         static {
             try {
                 LibraryLookup lookup = LibraryLookup.ofDefault();
diff a/test/jdk/java/foreign/TestDowncall.java b/test/jdk/java/foreign/TestDowncall.java
--- a/test/jdk/java/foreign/TestDowncall.java
+++ b/test/jdk/java/foreign/TestDowncall.java
@@ -74,11 +74,11 @@
 
 
     @Test(dataProvider="functions", dataProviderClass=CallGeneratorHelper.class)
     public void testDowncall(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {
         List<Consumer<Object>> checks = new ArrayList<>();
-        MemoryAddress addr = lib.lookup(fName);
+        LibraryLookup.Symbol addr = lib.lookup(fName);
         MethodHandle mh = abi.downcallHandle(addr, methodType(ret, paramTypes, fields), function(ret, paramTypes, fields));
         Object[] args = makeArgs(paramTypes, fields, checks);
         mh = mh.asSpreader(Object[].class, paramTypes.size());
         Object res = mh.invoke(args);
         if (ret == Ret.NON_VOID) {
diff a/test/jdk/java/foreign/TestIntrinsics.java b/test/jdk/java/foreign/TestIntrinsics.java
--- a/test/jdk/java/foreign/TestIntrinsics.java
+++ b/test/jdk/java/foreign/TestIntrinsics.java
@@ -68,20 +68,20 @@
     private static final MethodHandle MH_identity_va;
     private static final MethodHandle MH_invoke_consumer;
 
     private static MethodHandle linkIndentity(String name, Class<?> carrier, MemoryLayout layout)
             throws NoSuchMethodException {
-        MemoryAddress ma = lookup.lookup(name);
+        LibraryLookup.Symbol ma = lookup.lookup(name);
         MethodType mt = methodType(carrier, carrier);
         FunctionDescriptor fd = FunctionDescriptor.of(layout, layout);
         return abi.downcallHandle(ma, mt, fd);
     }
 
     static {
         try {
             {
-                MemoryAddress ma = lookup.lookup("empty");
+                LibraryLookup.Symbol ma = lookup.lookup("empty");
                 MethodType mt = methodType(void.class);
                 FunctionDescriptor fd = FunctionDescriptor.ofVoid();
                 MH_empty = abi.downcallHandle(ma, mt, fd);
             }
             MH_identity_char = linkIndentity("identity_char", byte.class, C_CHAR);
@@ -89,18 +89,18 @@
             MH_identity_int = linkIndentity("identity_int", int.class, C_INT);
             MH_identity_long = linkIndentity("identity_long", long.class, C_LONGLONG);
             MH_identity_float = linkIndentity("identity_float", float.class, C_FLOAT);
             MH_identity_double = linkIndentity("identity_double", double.class, C_DOUBLE);
             {
-                MemoryAddress ma = lookup.lookup("identity_va");
+                LibraryLookup.Symbol ma = lookup.lookup("identity_va");
                 MethodType mt = methodType(int.class, int.class, double.class, int.class, float.class, long.class);
                 FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT, asVarArg(C_DOUBLE),
                         asVarArg(C_INT), asVarArg(C_FLOAT), asVarArg(C_LONGLONG));
                 MH_identity_va = abi.downcallHandle(ma, mt, fd);
             }
             {
-                MemoryAddress ma = lookup.lookup("invoke_consumer");
+                LibraryLookup.Symbol ma = lookup.lookup("invoke_consumer");
                 MethodType mt = methodType(void.class, int.class, double.class, long.class, float.class, byte.class,
                         short.class, char.class);
                 FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_DOUBLE, C_LONGLONG, C_FLOAT, C_CHAR,
                         C_SHORT, C_SHORT);
                 MH_invoke_consumer = abi.downcallHandle(ma, mt, fd);
diff a/test/jdk/java/foreign/TestLibraryLookup.java b/test/jdk/java/foreign/TestLibraryLookup.java
--- a/test/jdk/java/foreign/TestLibraryLookup.java
+++ b/test/jdk/java/foreign/TestLibraryLookup.java
@@ -53,28 +53,27 @@
         LibraryLookup.ofPath(Path.of("NonExistent").toAbsolutePath().toString());
     }
 
     @Test
     public void testSimpleLookup() throws Throwable {
-        MemoryAddress symbol = null;
+        LibraryLookup.Symbol symbol = null;
         LibraryLookup lookup = LibraryLookup.ofLibrary("LookupTest");
         symbol = lookup.lookup("f");
-        assertTrue(symbol.segment().isAlive());
+        assertEquals(symbol.name(), "f");
         assertEquals(LibrariesHelper.numLoadedLibraries(), 1);
         lookup = null;
         symbol = null;
         waitUnload();
     }
 
     @Test
     public void testMultiLookupSameLoader() throws Throwable {
-        List<MemoryAddress> symbols = new ArrayList<>();
+        List<LibraryLookup.Symbol> symbols = new ArrayList<>();
         List<LibraryLookup> lookups = new ArrayList<>();
         for (int i = 0 ; i < 5 ; i++) {
             LibraryLookup lookup = LibraryLookup.ofLibrary("LookupTest");
-            MemoryAddress symbol = lookup.lookup("f");
-            assertTrue(symbol.segment().isAlive());
+            LibraryLookup.Symbol symbol = lookup.lookup("f");
             lookups.add(lookup);
             symbols.add(symbol);
             assertEquals(LibrariesHelper.numLoadedLibraries(), 1);
         }
         lookups = null;
@@ -128,11 +127,11 @@
         }
     }
 
     static class Holder {
         public static LibraryLookup lookup;
-        public static MemoryAddress symbol;
+        public static LibraryLookup.Symbol symbol;
 
         static {
             try {
                 lookup = LibraryLookup.ofLibrary("LookupTest");
                 symbol = lookup.lookup("f");
diff a/test/jdk/java/foreign/TestUpcall.java b/test/jdk/java/foreign/TestUpcall.java
--- a/test/jdk/java/foreign/TestUpcall.java
+++ b/test/jdk/java/foreign/TestUpcall.java
@@ -111,11 +111,11 @@
 
     @Test(dataProvider="functions", dataProviderClass=CallGeneratorHelper.class)
     public void testUpcalls(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {
         List<Consumer<Object>> returnChecks = new ArrayList<>();
         List<Consumer<Object[]>> argChecks = new ArrayList<>();
-        MemoryAddress addr = lib.lookup(fName);
+        LibraryLookup.Symbol addr = lib.lookup(fName);
         MethodHandle mh = abi.downcallHandle(addr, methodType(ret, paramTypes, fields), function(ret, paramTypes, fields));
         Object[] args = makeArgs(ret, paramTypes, fields, returnChecks, argChecks);
         mh = mh.asSpreader(Object[].class, paramTypes.size() + 1);
         Object res = mh.invoke(args);
         argChecks.forEach(c -> c.accept(args));
diff a/test/jdk/java/foreign/TestVarArgs.java b/test/jdk/java/foreign/TestVarArgs.java
--- a/test/jdk/java/foreign/TestVarArgs.java
+++ b/test/jdk/java/foreign/TestVarArgs.java
@@ -62,11 +62,11 @@
     static final VarHandle VH_CallInfo_argIDs = ML_CallInfo.varHandle(long.class, groupElement("argIDs"));
 
     static final VarHandle VH_IntArray = MemoryLayout.ofSequence(C_INT).varHandle(int.class, sequenceElement());
 
     static final ForeignLinker abi = CSupport.getSystemLinker();
-    static final MemoryAddress varargsAddr;
+    static final LibraryLookup.Symbol varargsAddr;
 
     static {
         try {
             varargsAddr = LibraryLookup.ofLibrary("VarArgs").lookup("varargs");
         } catch (NoSuchMethodException e) {
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
@@ -75,18 +75,18 @@
         System.loadLibrary("CallOverheadJNI");
 
         try {
             LibraryLookup ll = LibraryLookup.ofLibrary("CallOverhead");
             {
-                MemoryAddress addr = ll.lookup("func");
+                LibraryLookup.Symbol addr = ll.lookup("func");
                 MethodType mt = MethodType.methodType(void.class);
                 FunctionDescriptor fd = FunctionDescriptor.ofVoid();
                 func = abi.downcallHandle(addr, mt, fd);
                 func_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));
             }
             {
-                MemoryAddress addr = ll.lookup("identity");
+                LibraryLookup.Symbol addr = ll.lookup("identity");
                 MethodType mt = MethodType.methodType(int.class, int.class);
                 FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);
                 identity = abi.downcallHandle(addr, mt, fd);
                 identity_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));
             }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../LibrariesHelper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="aarch64/AArch64Linker.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 

 25 import jdk.incubator.foreign.MemoryAddress;
 26 import jdk.incubator.foreign.MemoryHandles;
 27 import jdk.incubator.foreign.MemorySegment;
 28 import jdk.incubator.foreign.NativeScope;
 29 import jdk.internal.access.JavaLangInvokeAccess;
 30 import jdk.internal.access.SharedSecrets;
 31 import jdk.internal.foreign.MemoryAddressImpl;
 32 import jdk.internal.foreign.Utils;
 33 import jdk.internal.invoke.NativeEntryPoint;
 34 import jdk.internal.invoke.VMStorageProxy;
 35 import sun.security.action.GetPropertyAction;
 36 
 37 import java.lang.invoke.MethodHandle;
 38 import java.lang.invoke.MethodHandles;
 39 import java.lang.invoke.MethodType;
 40 import java.lang.invoke.VarHandle;
 41 import java.nio.ByteOrder;
 42 import java.util.Arrays;
 43 import java.util.List;
 44 import java.util.Map;
</pre>
<hr />
<pre>
 90             MH_MAKE_ALLOCATOR = lookup.findStatic(NativeScope.class, &quot;boundedScope&quot;,
 91                     methodType(NativeScope.class, long.class));
 92             MH_CLOSE_ALLOCATOR = lookup.findVirtual(NativeScope.class, &quot;close&quot;,
 93                     methodType(void.class));
 94         } catch (ReflectiveOperationException e) {
 95             throw new RuntimeException(e);
 96         }
 97     }
 98 
 99     private final ABIDescriptor abi;
100     private final BufferLayout layout;
101     private final long stackArgsBytes;
102 
103     private final CallingSequence callingSequence;
104 
105     private final MemoryAddress addr;
106     private final long stubAddress;
107 
108     private final long bufferCopySize;
109 
<span class="line-modified">110     public ProgrammableInvoker(ABIDescriptor abi, MemoryAddress addr, CallingSequence callingSequence) {</span>
111         this.abi = abi;
112         this.layout = BufferLayout.of(abi);
113         this.stubAddress = adapterStubs.computeIfAbsent(abi, key -&gt; generateAdapter(key, layout));
114 
<span class="line-modified">115         this.addr = addr;</span>
116         this.callingSequence = callingSequence;
117 
118         this.stackArgsBytes = callingSequence.argMoveBindings()
119                 .map(Binding.Move::storage)
120                 .filter(s -&gt; abi.arch.isStackType(s.type()))
121                 .count()
122                 * abi.arch.typeSize(abi.arch.stackType());
123 
124         this.bufferCopySize = bufferCopySize(callingSequence);
125     }
126 
127     private static long bufferCopySize(CallingSequence callingSequence) {
128         // FIXME: &gt; 16 bytes alignment might need extra space since the
129         // starting address of the allocator might be un-aligned.
130         long size = 0;
131         for (int i = 0; i &lt; callingSequence.argumentCount(); i++) {
132             List&lt;Binding&gt; bindings = callingSequence.argumentBindings(i);
133             for (Binding b : bindings) {
134                 if (b instanceof Binding.Copy) {
135                     Binding.Copy c = (Binding.Copy) b;
</pre>
</td>
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 
<span class="line-added"> 25 import jdk.incubator.foreign.Addressable;</span>
 26 import jdk.incubator.foreign.MemoryAddress;
 27 import jdk.incubator.foreign.MemoryHandles;
 28 import jdk.incubator.foreign.MemorySegment;
 29 import jdk.incubator.foreign.NativeScope;
 30 import jdk.internal.access.JavaLangInvokeAccess;
 31 import jdk.internal.access.SharedSecrets;
 32 import jdk.internal.foreign.MemoryAddressImpl;
 33 import jdk.internal.foreign.Utils;
 34 import jdk.internal.invoke.NativeEntryPoint;
 35 import jdk.internal.invoke.VMStorageProxy;
 36 import sun.security.action.GetPropertyAction;
 37 
 38 import java.lang.invoke.MethodHandle;
 39 import java.lang.invoke.MethodHandles;
 40 import java.lang.invoke.MethodType;
 41 import java.lang.invoke.VarHandle;
 42 import java.nio.ByteOrder;
 43 import java.util.Arrays;
 44 import java.util.List;
 45 import java.util.Map;
</pre>
<hr />
<pre>
 91             MH_MAKE_ALLOCATOR = lookup.findStatic(NativeScope.class, &quot;boundedScope&quot;,
 92                     methodType(NativeScope.class, long.class));
 93             MH_CLOSE_ALLOCATOR = lookup.findVirtual(NativeScope.class, &quot;close&quot;,
 94                     methodType(void.class));
 95         } catch (ReflectiveOperationException e) {
 96             throw new RuntimeException(e);
 97         }
 98     }
 99 
100     private final ABIDescriptor abi;
101     private final BufferLayout layout;
102     private final long stackArgsBytes;
103 
104     private final CallingSequence callingSequence;
105 
106     private final MemoryAddress addr;
107     private final long stubAddress;
108 
109     private final long bufferCopySize;
110 
<span class="line-modified">111     public ProgrammableInvoker(ABIDescriptor abi, Addressable addr, CallingSequence callingSequence) {</span>
112         this.abi = abi;
113         this.layout = BufferLayout.of(abi);
114         this.stubAddress = adapterStubs.computeIfAbsent(abi, key -&gt; generateAdapter(key, layout));
115 
<span class="line-modified">116         this.addr = addr.address();</span>
117         this.callingSequence = callingSequence;
118 
119         this.stackArgsBytes = callingSequence.argMoveBindings()
120                 .map(Binding.Move::storage)
121                 .filter(s -&gt; abi.arch.isStackType(s.type()))
122                 .count()
123                 * abi.arch.typeSize(abi.arch.stackType());
124 
125         this.bufferCopySize = bufferCopySize(callingSequence);
126     }
127 
128     private static long bufferCopySize(CallingSequence callingSequence) {
129         // FIXME: &gt; 16 bytes alignment might need extra space since the
130         // starting address of the allocator might be un-aligned.
131         long size = 0;
132         for (int i = 0; i &lt; callingSequence.argumentCount(); i++) {
133             List&lt;Binding&gt; bindings = callingSequence.argumentBindings(i);
134             for (Binding b : bindings) {
135                 if (b instanceof Binding.Copy) {
136                     Binding.Copy c = (Binding.Copy) b;
</pre>
</td>
</tr>
</table>
<center><a href="../LibrariesHelper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="aarch64/AArch64Linker.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
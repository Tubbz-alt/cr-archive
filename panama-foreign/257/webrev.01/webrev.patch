diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
@@ -22,11 +22,14 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.incubator.jextract;
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryAddress;
+
 import java.lang.invoke.MethodType;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -63,39 +66,47 @@
     public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
         incrAlign();
         indent();
         sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaName + " (");
         String delim = "";
-        List<String> pNames = new ArrayList<>();
+        List<String> pExprs = new ArrayList<>();
         final int numParams = paramNames.size();
         for (int i = 0 ; i < numParams; i++) {
             String pName = paramNames.get(i);
             if (pName.isEmpty()) {
                 pName = "x" + i;
             }
-            pNames.add(pName);
-            sb.append(delim + mtype.parameterType(i).getName() + " " + pName);
+            if (mtype.parameterType(i).equals(MemoryAddress.class)) {
+                pExprs.add(pName + ".address()");
+            } else {
+                pExprs.add(pName);
+            }
+            Class<?> pType = mtype.parameterType(i);
+            if (pType.equals(MemoryAddress.class)) {
+                pType = Addressable.class;
+            }
+            sb.append(delim + pType.getName() + " " + pName);
             delim = ", ";
         }
         if (varargs) {
             String lastArg = "x" + numParams;
             if (numParams > 0) {
                 sb.append(", ");
             }
             sb.append("Object... " + lastArg);
-            pNames.add(lastArg);
+            pExprs.add(lastArg);
         }
         sb.append(") {\n");
         incrAlign();
         indent();
         sb.append("try {\n");
         incrAlign();
         indent();
         if (!mtype.returnType().equals(void.class)) {
             sb.append("return (" + mtype.returnType().getName() + ")");
         }
-        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pNames) + ");\n");
+        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pExprs) + ");\n");
         decrAlign();
         indent();
         sb.append("} catch (Throwable ex) {\n");
         incrAlign();
         indent();
diff a/test/jdk/tools/jextract/JextractToolProviderTest.java b/test/jdk/tools/jextract/JextractToolProviderTest.java
--- a/test/jdk/tools/jextract/JextractToolProviderTest.java
+++ b/test/jdk/tools/jextract/JextractToolProviderTest.java
@@ -22,10 +22,12 @@
  */
 
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
+
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.MemoryAddress;
 
 import org.testng.annotations.Test;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertFalse;
@@ -66,11 +68,11 @@
         try(Loader loader = classLoader(helloOutput)) {
             Class<?> cls = loader.loadClass("hello_h");
             // check a method for "void func(int)"
             assertNotNull(findMethod(cls, "func", int.class));
             // check a method for "int printf(MemoryAddress, Object[])"
-            assertNotNull(findMethod(cls, "printf", MemoryAddress.class, Object[].class));
+            assertNotNull(findMethod(cls, "printf", Addressable.class, Object[].class));
         } finally {
             deleteDir(helloOutput);
         }
     }
 
@@ -82,11 +84,11 @@
         try(Loader loader = classLoader(helloOutput)) {
             Class<?> cls = loader.loadClass("com.acme.hello_h");
             // check a method for "void func(int)"
             assertNotNull(findMethod(cls, "func", int.class));
             // check a method for "int printf(MemoryAddress, Object[])"
-            assertNotNull(findMethod(cls, "printf", MemoryAddress.class, Object[].class));
+            assertNotNull(findMethod(cls, "printf", Addressable.class, Object[].class));
         } finally {
             deleteDir(helloOutput);
         }
     }
 
diff a/test/jdk/tools/jextract/RepeatedDeclsTest.java b/test/jdk/tools/jextract/RepeatedDeclsTest.java
--- a/test/jdk/tools/jextract/RepeatedDeclsTest.java
+++ b/test/jdk/tools/jextract/RepeatedDeclsTest.java
@@ -19,16 +19,16 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.CSupport;
 import org.testng.annotations.Test;
 
 import java.nio.file.Path;
 import jdk.incubator.foreign.GroupLayout;
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
 
@@ -54,14 +54,14 @@
 
             // check a method for "void func2(int)"
             assertNotNull(findMethod(cls, "func2", int.class));
 
             // check a method for "void func3(int*)"
-            assertNotNull(findMethod(cls, "func3", MemoryAddress.class));
+            assertNotNull(findMethod(cls, "func3", Addressable.class));
 
             // check a method for "void func4(int*)"
-            assertNotNull(findMethod(cls, "func4", MemoryAddress.class));
+            assertNotNull(findMethod(cls, "func4", Addressable.class));
 
             // check a method for "void func5(int)"
             assertNotNull(findMethod(cls, "func5", int.class));
 
             // check a method for "double distance(struct Point)"
diff a/test/jdk/tools/jextract/Test8249290.java b/test/jdk/tools/jextract/Test8249290.java
--- a/test/jdk/tools/jextract/Test8249290.java
+++ b/test/jdk/tools/jextract/Test8249290.java
@@ -20,11 +20,12 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 import java.nio.file.Path;
-import jdk.incubator.foreign.MemoryAddress;
+
+import jdk.incubator.foreign.Addressable;
 import org.testng.annotations.Test;
 
 /*
  * @test
  * @library /test/lib
@@ -40,11 +41,11 @@
         Path outputPath = getOutputFilePath("output8249290");
         Path headerFile = getInputFilePath("test8249290.h");
         run("-d", outputPath.toString(), headerFile.toString()).checkSuccess();
         try(Loader loader = classLoader(outputPath)) {
             Class<?> headerClass = loader.loadClass("test8249290_h");
-            checkMethod(headerClass, "func", void.class, MemoryAddress.class);
+            checkMethod(headerClass, "func", void.class, Addressable.class);
             Class<?> fiClass = loader.loadClass("test8249290_h$func$f");
             checkMethod(fiClass, "apply", void.class);
         } finally {
             deleteDir(outputPath);
         }
diff a/test/jdk/tools/jextract/Test8249300.java b/test/jdk/tools/jextract/Test8249300.java
--- a/test/jdk/tools/jextract/Test8249300.java
+++ b/test/jdk/tools/jextract/Test8249300.java
@@ -20,11 +20,12 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 import java.nio.file.Path;
-import jdk.incubator.foreign.MemoryAddress;
+
+import jdk.incubator.foreign.Addressable;
 import org.testng.annotations.Test;
 
 /*
  * @test
  * @library /test/lib
@@ -40,11 +41,11 @@
         Path outputPath = getOutputFilePath("output8249300");
         Path headerFile = getInputFilePath("test8249300.h");
         run("-d", outputPath.toString(), headerFile.toString()).checkSuccess();
         try(Loader loader = classLoader(outputPath)) {
             Class<?> headerClass = loader.loadClass("test8249300_h");
-            checkMethod(headerClass, "func", void.class, MemoryAddress.class);
+            checkMethod(headerClass, "func", void.class, Addressable.class);
             Class<?> fiClass = loader.loadClass("test8249300_h$func$f");
             checkMethod(fiClass, "apply", void.class);
         } finally {
             deleteDir(outputPath);
         }
diff a/test/jdk/tools/jextract/UniondeclTest.java b/test/jdk/tools/jextract/UniondeclTest.java
--- a/test/jdk/tools/jextract/UniondeclTest.java
+++ b/test/jdk/tools/jextract/UniondeclTest.java
@@ -19,15 +19,15 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.CSupport;
 import org.testng.annotations.Test;
 import java.nio.file.Path;
 import jdk.incubator.foreign.GroupLayout;
-import jdk.incubator.foreign.MemoryAddress;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
 
 /*
  * @test
@@ -43,11 +43,11 @@
         Path uniondeclH = getInputFilePath("uniondecl.h");
         run("-d", uniondeclOutput.toString(), uniondeclH.toString()).checkSuccess();
         try(Loader loader = classLoader(uniondeclOutput)) {
             Class<?> cls = loader.loadClass("uniondecl_h");
             // check a method for "void func(IntOrFloat*)"
-            assertNotNull(findMethod(cls, "func", MemoryAddress.class));
+            assertNotNull(findMethod(cls, "func", Addressable.class));
             // check IntOrFloat layout
             Class<?> intOrFloatCls = loader.loadClass("uniondecl_h$IntOrFloat");
             GroupLayout intOrFloatLayout = (GroupLayout)findLayout(intOrFloatCls);
             assertNotNull(intOrFloatLayout);
             assertTrue(intOrFloatLayout.isUnion());

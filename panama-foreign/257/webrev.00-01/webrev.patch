diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
@@ -24,10 +24,12 @@
  */
 package jdk.incubator.jextract;
 
 import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryAddress;
+
 import java.lang.invoke.MethodType;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -59,28 +61,32 @@
         sb.append("}\n");
         decrAlign();
         indent();
     }
 
-    public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType sigtype, MethodType mhtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
+    public void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {
         incrAlign();
         indent();
-        sb.append(PUB_MODS + sigtype.returnType().getName() + " " + javaName + " (");
+        sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaName + " (");
         String delim = "";
         List<String> pExprs = new ArrayList<>();
         final int numParams = paramNames.size();
         for (int i = 0 ; i < numParams; i++) {
             String pName = paramNames.get(i);
             if (pName.isEmpty()) {
                 pName = "x" + i;
             }
-            if (sigtype.parameterType(i).equals(Addressable.class)) {
+            if (mtype.parameterType(i).equals(MemoryAddress.class)) {
                 pExprs.add(pName + ".address()");
             } else {
                 pExprs.add(pName);
             }
-            sb.append(delim + sigtype.parameterType(i).getName() + " " + pName);
+            Class<?> pType = mtype.parameterType(i);
+            if (pType.equals(MemoryAddress.class)) {
+                pType = Addressable.class;
+            }
+            sb.append(delim + pType.getName() + " " + pName);
             delim = ", ";
         }
         if (varargs) {
             String lastArg = "x" + numParams;
             if (numParams > 0) {
@@ -93,14 +99,14 @@
         incrAlign();
         indent();
         sb.append("try {\n");
         incrAlign();
         indent();
-        if (!sigtype.returnType().equals(void.class)) {
-            sb.append("return (" + sigtype.returnType().getName() + ")");
+        if (!mtype.returnType().equals(void.class)) {
+            sb.append("return (" + mtype.returnType().getName() + ")");
         }
-        sb.append(methodHandleGetCallString(javaName, nativeName, mhtype, desc, varargs) + ".invokeExact(" + String.join(", ", pExprs) + ");\n");
+        sb.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + ".invokeExact(" + String.join(", ", pExprs) + ");\n");
         decrAlign();
         indent();
         sb.append("} catch (Throwable ex) {\n");
         incrAlign();
         indent();
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java
@@ -241,26 +241,25 @@
     public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
         if (functionSeen(funcTree)) {
             return null;
         }
 
-        MethodType sigtype = typeTranslator.getMethodType(funcTree.type(), true, false);
-        MethodType mhtype = typeTranslator.getMethodType(funcTree.type(), false, false);
+        MethodType mtype = typeTranslator.getMethodType(funcTree.type());
         FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
         if (descriptor == null) {
             //abort
             return null;
         }
         String mhName = Utils.javaSafeIdentifier(funcTree.name());
-        builder.addMethodHandleGetter(mhName, funcTree.name(), mhtype, descriptor, funcTree.type().varargs());
+        builder.addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());
         //generate static wrapper for function
         List<String> paramNames = funcTree.parameters()
                                           .stream()
                                           .map(Declaration.Variable::name)
                                           .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)
                                           .collect(Collectors.toList());
-        builder.addStaticFunctionWrapper(Utils.javaSafeIdentifier(funcTree.name()), funcTree.name(), sigtype, mhtype,
+        builder.addStaticFunctionWrapper(Utils.javaSafeIdentifier(funcTree.name()), funcTree.name(), mtype,
                 Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames);
         int i = 0;
         for (Declaration.Variable param : funcTree.parameters()) {
             Type.Function f = getAsFunctionPointer(param.type());
             if (f != null) {
@@ -268,11 +267,11 @@
                 name = Utils.javaSafeIdentifier(name);
                 //generate functional interface
                 if (f.varargs()) {
                     System.err.println("WARNING: varargs in callbacks is not supported");
                 }
-                MethodType fitype = typeTranslator.getMethodType(f, false, true);
+                MethodType fitype = typeTranslator.getMethodType(f, false);
                 builder.addFunctionalInterface(name, fitype, Type.descriptorFor(f).orElseThrow());
                 i++;
             }
         }
         return null;
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/TypeTranslator.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/TypeTranslator.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/TypeTranslator.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/TypeTranslator.java
@@ -23,22 +23,21 @@
  * questions.
  */
 
 package jdk.incubator.jextract;
 
-import jdk.incubator.foreign.Addressable;
 import jdk.incubator.jextract.Type.Primitive;
 import jdk.incubator.jextract.Type;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 
 import java.lang.invoke.MethodType;
 
-public class TypeTranslator implements Type.Visitor<Class<?>, Boolean> {
+public class TypeTranslator implements Type.Visitor<Class<?>, Void> {
     @Override
-    public Class<?> visitPrimitive(Type.Primitive t, Boolean allowAddressable) {
+    public Class<?> visitPrimitive(Type.Primitive t, Void aVoid) {
         if (t.kind().layout().isEmpty()) {
             return void.class;
         } else {
             return layoutToClass(isFloatingPoint(t), t.kind().layout().orElseThrow(UnsupportedOperationException::new));
         }
@@ -83,23 +82,23 @@
                 throw new UnsupportedOperationException();
         }
     }
 
     @Override
-    public Class<?> visitDelegated(Type.Delegated t, Boolean allowAddressable) {
+    public Class<?> visitDelegated(Type.Delegated t, Void aVoid) {
         return t.kind() == Type.Delegated.Kind.POINTER ?
-                (allowAddressable ? Addressable.class : MemoryAddress.class) :
-                t.type().accept(this, allowAddressable);
+                MemoryAddress.class :
+                t.type().accept(this, null);
     }
 
     @Override
-    public Class<?> visitFunction(Type.Function t, Boolean allowAddressable) {
+    public Class<?> visitFunction(Type.Function t, Void aVoid) {
         return MemoryAddress.class; // function pointer
     }
 
     @Override
-    public Class<?> visitDeclared(Type.Declared t, Boolean allowAddressable) {
+    public Class<?> visitDeclared(Type.Declared t, Void aVoid) {
         switch (t.tree().kind()) {
             case UNION:
             case STRUCT:
                 return MemorySegment.class;
             case ENUM:
@@ -108,37 +107,37 @@
                 throw new UnsupportedOperationException();
         }
     }
 
     @Override
-    public Class<?> visitArray(Type.Array t, Boolean allowAddressable) {
+    public Class<?> visitArray(Type.Array t, Void aVoid) {
         if (t.kind() == Type.Array.Kind.VECTOR) {
             throw new UnsupportedOperationException();
         } else {
             return MemorySegment.class;
         }
     }
 
     @Override
-    public Class<?> visitType(Type t, Boolean allowAddressable) {
+    public Class<?> visitType(Type t, Void aVoid) {
         throw new UnsupportedOperationException();
     }
 
     Class<?> getJavaType(Type t) {
-        return t.accept(this, false);
+        return t.accept(this, null);
     }
 
-    Class<?> getJavaType(Type t, boolean allowAddressable) {
-        return t.accept(this, allowAddressable);
+    MethodType getMethodType(Type.Function type) {
+        return getMethodType(type, true);
     }
 
-    MethodType getMethodType(Type.Function type, boolean allowAddressable, boolean upcall) {
-        MethodType mtype = MethodType.methodType(getJavaType(type.returnType(), false));
+    MethodType getMethodType(Type.Function type, boolean varargsCheck) {
+        MethodType mtype = MethodType.methodType(getJavaType(type.returnType()));
         for (Type arg : type.argumentTypes()) {
-            mtype = mtype.appendParameterTypes(getJavaType(arg, allowAddressable));
+            mtype = mtype.appendParameterTypes(getJavaType(arg));
         }
-        if (!upcall && type.varargs()) {
+        if (varargsCheck && type.varargs()) {
             mtype = mtype.appendParameterTypes(Object[].class);
         }
         return mtype;
     }
 }

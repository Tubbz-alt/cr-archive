diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
@@ -140,11 +140,11 @@
         };
     }
 
     private void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {
         indent();
-        sb.append(PUB_MODS + "MemoryAddress allocate(" + className + " fi) {\n");
+        sb.append(PUB_MODS + "MemorySegment allocate(" + className + " fi) {\n");
         incrAlign();
         indent();
         sb.append("return RuntimeHelper.upcallStub(" + className + ".class, fi, " + functionGetCallString(className, fDesc) + ", " +
                 "\"" + mtype.toMethodDescriptorString() + "\");\n");
         decrAlign();
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.java.template
@@ -60,29 +60,25 @@
                         VarargsInvoker.make(addr, mt, fdesc) :
                         ABI.downcallHandle(addr, mt, fdesc);
                 }).orElse(null);
     }
 
-    public static final MemoryAddress upcallStub(MethodHandle handle, FunctionDescriptor fdesc) {
+    public static final MemorySegment upcallStub(MethodHandle handle, FunctionDescriptor fdesc) {
         return ABI.upcallStub(handle, fdesc);
     }
 
-    public static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {
+    public static final <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {
         try {
             MethodHandle handle = MH_LOOKUP.findVirtual(fi, "apply",
                     MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));
             handle = handle.bindTo(z);
             return upcallStub(handle, fdesc);
         } catch (Throwable ex) {
             throw new AssertionError(ex);
         }
     }
 
-    public static void freeUpcallStub(MemoryAddress addr) {
-        ABI.freeUpcallStub(addr);
-    }
-
     private static class VarargsInvoker {
         private static final MethodHandle INVOKE_MH;
         private final MemoryAddress symbol;
         private final MethodType varargs;
         private final FunctionDescriptor function;
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/RuntimeHelper.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/RuntimeHelper.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/RuntimeHelper.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/RuntimeHelper.java
@@ -94,11 +94,11 @@
                                            MethodType.fromMethodDescriptorString(desc, LOADER),
                                            fdesc)).orElse(null);
     }
 
     public static final MemoryAddress upcallStub(MethodHandle handle, FunctionDescriptor fdesc) {
-        return ABI.upcallStub(handle, fdesc);
+        return ABI.upcallStub(handle, fdesc).baseAddress();
     }
 
     public static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {
         try {
             MethodHandle handle = MH_LOOKUP.findVirtual(fi, "apply",
diff a/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java b/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
--- a/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
+++ b/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
@@ -216,11 +216,11 @@
     @Test(dataProvider = "functionalInterfaces")
     public void testFunctionalInterface(String name, MethodType type) {
         Class<?> fiClass = findNestedClass(cls, name);
         assertNotNull(fiClass);
         checkMethod(fiClass, "apply", type);
-        checkMethod(fiClass, "allocate", MemoryAddress.class, fiClass);
+        checkMethod(fiClass, "allocate", MemorySegment.class, fiClass);
     }
 
     @BeforeClass
     public void setup() {
         outputDir = getOutputFilePath("exmples_out");
diff a/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java b/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java
--- a/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java
+++ b/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java
@@ -35,10 +35,10 @@
  * @run testng/othervm -Dforeign.restricted=permit LibFuncPtrTest
  */
 public class LibFuncPtrTest {
     @Test
     public void test() {
-        var addr = func$f.allocate(x -> x*x);
-        assertEquals(func(addr, 35), 35*35 + 35);
-        RuntimeHelper.freeUpcallStub(addr);
+        try (var handle = func$f.allocate(x -> x*x)) {
+            assertEquals(func(handle.baseAddress(), 35), 35 * 35 + 35);
+        } //deallocate
     }
 }

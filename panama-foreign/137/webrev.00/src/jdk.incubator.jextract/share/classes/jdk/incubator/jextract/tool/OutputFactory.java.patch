diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
@@ -215,13 +215,10 @@
         return null;
     }
 
     @Override
     public Void visitScoped(Declaration.Scoped d, Declaration parent) {
-        if (d.kind() == Declaration.Scoped.Kind.TYPEDEF) {
-            return d.members().get(0).accept(this, d);
-        }
         if (d.layout().isEmpty()) {
             //skip decl-only
             return null;
         }
         String name = d.name();
@@ -313,20 +310,34 @@
             return null;
         }
 
         String fieldName = tree.name();
         String symbol = tree.name();
+        Type type = tree.type();
+
+        if (tree.kind() == Declaration.Variable.Kind.TYPE) {
+            if (type instanceof Type.Declared) {
+                Declaration.Scoped s = ((Type.Declared) type).tree();
+                // only generate unnamed for now
+                // skip typedef with different name
+                if (!s.name().isEmpty()) return null;
+                return visitScoped(s, tree);
+            } else {
+                // skip for now
+                return null;
+            }
+        }
+
         assert !symbol.isEmpty();
         assert !fieldName.isEmpty();
 
         // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
         if (parent == null) {
             fieldName = tree.name();
         }
         fieldName = Utils.javaSafeIdentifier(fieldName);
 
-        Type type = tree.type();
         MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
         if (layout == null) {
             //no layout - abort
             return null;
         }
@@ -337,12 +348,11 @@
             return null;
         }
 
         MemoryLayout treeLayout = tree.layout().orElseThrow();
         if (parent != null) { //struct field
-            Declaration.Scoped parentC = (Declaration.Scoped) parent;
-            MemoryLayout parentLayout = parentLayout(parentC);
+            MemoryLayout parentLayout = parentLayout(parent);
             structBuilder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
             structBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
             structBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, parentLayout);
         } else {
             builder.addLayoutGetter(fieldName, layout);
@@ -366,12 +376,20 @@
                     scope.kind() == Declaration.Scoped.Kind.STRUCT ||
                     scope.kind() == Declaration.Scoped.Kind.UNION;
         }
     }
 
-    protected static MemoryLayout parentLayout(Declaration.Scoped parent) {
+    protected static MemoryLayout parentLayout(Declaration parent) {
+        Declaration.Scoped scope;
+        if (parent instanceof Declaration.Variable) {
+            Declaration.Variable v = (Declaration.Variable) parent;
+            assert v.kind() == Declaration.Variable.Kind.TYPE;
+            scope = ((Type.Declared)(v.type())).tree();
+        } else if (parent instanceof Declaration.Scoped) {
+            scope = (Declaration.Scoped) parent;
+        } else {
+            throw new IllegalArgumentException("Unexpected parent declaration");
+        }
         // case like `typedef struct { ... } Foo`
-        return (parent.kind() == Declaration.Scoped.Kind.TYPEDEF
-            ? (Declaration.Scoped) parent.members().get(0)
-            : parent).layout().orElseThrow();
+        return scope.layout().orElseThrow();
     }
 }

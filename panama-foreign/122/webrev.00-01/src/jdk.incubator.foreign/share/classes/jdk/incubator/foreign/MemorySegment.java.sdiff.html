<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/MemoryScope.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
464      */
465     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
466         if (bytesSize &lt;= 0) {
467             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
468         }
469 
470         if (alignmentBytes &lt; 0 ||
471                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
472             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
473         }
474 
475         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
476     }
477 
478     /**
479      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
480      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
481      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
482      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
483      * (often as a plain {@code long} value).
<span class="line-removed">484      * &lt;p&gt;Since the cleanup action is an {@link AutoCloseable} object, another memory segment can be used to specify a</span>
<span class="line-removed">485      * cleanup operation; this can be useful in cases where the user would like to take an existing native segment</span>
<span class="line-removed">486      * and tweak some of the properties of the original segment - as demonstrated below:</span>
<span class="line-removed">487      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-removed">488     MemorySegment segment = MemorySegment.allocateNative(100);</span>
<span class="line-removed">489     MemorySegment unconfinedSegment = MemorySegment.ofNativeUnsafe(</span>
<span class="line-removed">490                                               segment.baseAddress(),</span>
<span class="line-removed">491                                               segment.byteSize(),</span>
<span class="line-removed">492                                               null,</span>
<span class="line-removed">493                                               segment,</span>
<span class="line-removed">494                                               null);</span>
<span class="line-removed">495      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-removed">496      * The above code takes an existing native segment and creates an unsafe segment that refers to the same</span>
<span class="line-removed">497      * underlying memory region as that of the original segment, but where thread-confinement constraints</span>
<span class="line-removed">498      * have been dropped.</span>
499      * &lt;p&gt;
500      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
501      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
502      * restricted methods, and use safe and supported functionalities, where possible.
503      *
504      * @param addr the desired base address
505      * @param bytesSize the desired size.
506      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
507      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
508      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
509      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
510      *                   the returned segment depends on memory which could be released if a certain object
511      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
512      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
513      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
514      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
<span class="line-modified">515      * @throws IllegalAccessError if the runtime property {@code foreign.unsafe} is not set to either</span>
<span class="line-removed">516      * @throws NullPointerException if {@code addr == null}.</span>
517      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).

518      */
<span class="line-modified">519     static MemorySegment ofNativeUnsafe(MemoryAddress addr, long bytesSize, Thread owner, AutoCloseable cleanup, Object attachment) {</span>
520         Objects.requireNonNull(addr);
521         if (bytesSize &lt;= 0) {
522             throw new IllegalArgumentException(&quot;Invalid size : &quot; + bytesSize);
523         }
<span class="line-modified">524         Utils.checkRestrictedAccess();</span>
525         return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, bytesSize, owner, cleanup, attachment);
526     }
527 
528     // access mode masks
529 
530     /**
531      * Read access mode; read operations are supported by a segment which supports this access mode.
532      * @see MemorySegment#accessModes()
533      * @see MemorySegment#withAccessModes(int)
534      */
535     int READ = 1;
536 
537     /**
538      * Write access mode; write operations are supported by a segment which supports this access mode.
539      * @see MemorySegment#accessModes()
540      * @see MemorySegment#withAccessModes(int)
541      */
542     int WRITE = READ &lt;&lt; 1;
543 
544     /**
</pre>
</td>
<td>
<hr />
<pre>
464      */
465     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
466         if (bytesSize &lt;= 0) {
467             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
468         }
469 
470         if (alignmentBytes &lt; 0 ||
471                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
472             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
473         }
474 
475         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
476     }
477 
478     /**
479      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
480      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
481      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
482      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
483      * (often as a plain {@code long} value).















484      * &lt;p&gt;
485      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
486      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
487      * restricted methods, and use safe and supported functionalities, where possible.
488      *
489      * @param addr the desired base address
490      * @param bytesSize the desired size.
491      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
492      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
493      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
494      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
495      *                   the returned segment depends on memory which could be released if a certain object
496      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
497      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
498      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
499      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
<span class="line-modified">500      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either</span>

501      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
<span class="line-added">502      * @throws NullPointerException if {@code addr == null}.</span>
503      */
<span class="line-modified">504     static MemorySegment ofNativeRestricted(MemoryAddress addr, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {</span>
505         Objects.requireNonNull(addr);
506         if (bytesSize &lt;= 0) {
507             throw new IllegalArgumentException(&quot;Invalid size : &quot; + bytesSize);
508         }
<span class="line-modified">509         Utils.checkRestrictedAccess(&quot;MemorySegment.ofNativeUnsafe&quot;);</span>
510         return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, bytesSize, owner, cleanup, attachment);
511     }
512 
513     // access mode masks
514 
515     /**
516      * Read access mode; read operations are supported by a segment which supports this access mode.
517      * @see MemorySegment#accessModes()
518      * @see MemorySegment#withAccessModes(int)
519      */
520     int READ = 1;
521 
522     /**
523      * Write access mode; write operations are supported by a segment which supports this access mode.
524      * @see MemorySegment#accessModes()
525      * @see MemorySegment#withAccessModes(int)
526      */
527     int WRITE = READ &lt;&lt; 1;
528 
529     /**
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/MemoryScope.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -479,25 +479,10 @@
      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
      * (often as a plain {@code long} value).
-     * <p>Since the cleanup action is an {@link AutoCloseable} object, another memory segment can be used to specify a
-     * cleanup operation; this can be useful in cases where the user would like to take an existing native segment
-     * and tweak some of the properties of the original segment - as demonstrated below:
-     * <blockquote><pre>{@code
-    MemorySegment segment = MemorySegment.allocateNative(100);
-    MemorySegment unconfinedSegment = MemorySegment.ofNativeUnsafe(
-                                              segment.baseAddress(),
-                                              segment.byteSize(),
-                                              null,
-                                              segment,
-                                              null);
-     * }</pre></blockquote>
-     * The above code takes an existing native segment and creates an unsafe segment that refers to the same
-     * underlying memory region as that of the original segment, but where thread-confinement constraints
-     * have been dropped.
      * <p>
      * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
      * restricted methods, and use safe and supported functionalities, where possible.
      *
@@ -510,20 +495,20 @@
      *                   the returned segment depends on memory which could be released if a certain object
      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
      * @throws IllegalArgumentException if {@code bytesSize <= 0}.
      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
-     * @throws IllegalAccessError if the runtime property {@code foreign.unsafe} is not set to either
-     * @throws NullPointerException if {@code addr == null}.
+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
+     * @throws NullPointerException if {@code addr == null}.
      */
-    static MemorySegment ofNativeUnsafe(MemoryAddress addr, long bytesSize, Thread owner, AutoCloseable cleanup, Object attachment) {
+    static MemorySegment ofNativeRestricted(MemoryAddress addr, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {
         Objects.requireNonNull(addr);
         if (bytesSize <= 0) {
             throw new IllegalArgumentException("Invalid size : " + bytesSize);
         }
-        Utils.checkRestrictedAccess();
+        Utils.checkRestrictedAccess("MemorySegment.ofNativeUnsafe");
         return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, bytesSize, owner, cleanup, attachment);
     }
 
     // access mode masks
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
@@ -54,15 +54,15 @@
 
     final static int UNACQUIRED = 0;
     final static int CLOSED = -1;
     final static int MAX_ACQUIRE = Integer.MAX_VALUE;
 
-    final AutoCloseable cleanupAction;
+    final Runnable cleanupAction;
 
     final static MemoryScope GLOBAL = new MemoryScope(null, null);
 
-    public MemoryScope(Object ref, AutoCloseable cleanupAction) {
+    public MemoryScope(Object ref, Runnable cleanupAction) {
         this.ref = ref;
         this.cleanupAction = cleanupAction;
     }
 
     /**
@@ -113,13 +113,9 @@
             checkAliveConfined();
             //...if not, then we have acquired views that are still active
             throw new IllegalStateException("Cannot close a segment that has active acquired views");
         }
         if (cleanupAction != null) {
-            try {
-                cleanupAction.close();
-            } catch (Exception ex) {
-                throw new IllegalStateException("Unexpected exception while closing the segment", ex);
-            }
+            cleanupAction.run();
         }
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
@@ -101,16 +101,10 @@
             segment = segment.asSlice(delta, bytesSize);
         }
         return segment;
     }
 
-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Thread owner, AutoCloseable cleanup, Object attachment) {
-        MemoryScope scope = new MemoryScope(attachment, extractCleanup(cleanup));
+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {
+        MemoryScope scope = new MemoryScope(attachment, cleanup);
         return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize), owner, scope);
     }
-
-    private static AutoCloseable extractCleanup(AutoCloseable cleanup) {
-        return (cleanup instanceof AbstractMemorySegmentImpl) ?
-            ((AbstractMemorySegmentImpl) cleanup).scope.cleanupAction :
-            cleanup;
-    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -40,11 +40,11 @@
 /**
  * This class contains misc helper functions to support creation of memory segments.
  */
 public final class Utils {
 
-    private static final String foreignAccess = Optional.ofNullable(VM.getSavedProperty("foreign.unsafe"))
+    private static final String foreignRestrictedAccess = Optional.ofNullable(VM.getSavedProperty("foreign.restricted"))
             .orElse("deny");
 
     private static final MethodHandle ADDRESS_FILTER;
 
     static {
@@ -76,28 +76,26 @@
 
     private static MemoryAddressProxy filterAddress(MemoryAddress addr) {
         return (MemoryAddressImpl)addr;
     }
 
-    public static void checkRestrictedAccess() {
-        switch (foreignAccess) {
-            case "deny" -> throwIllegalAccessError(foreignAccess);
-            case "warn" -> System.err.println("WARNING: Accessing jdk.incubator.foreign.Foreign.");
+    public static void checkRestrictedAccess(String method) {
+        switch (foreignRestrictedAccess) {
+            case "deny" -> throwIllegalAccessError(foreignRestrictedAccess, method);
+            case "warn" -> System.err.println("WARNING: Accessing restricted foreign method: " + method);
             case "debug" -> {
-                StringBuilder sb = new StringBuilder("DEBUG: Accessing jdk.incubator.foreign.Foreign.");
-                StackWalker.getInstance().walk(s -> {
-                    s
-                            .forEach(f -> sb.append(System.lineSeparator()).append("\tat ").append(f));
-                    return null;
-                });
-                System.out.println(sb.toString());
+                StringBuilder sb = new StringBuilder("DEBUG: restricted foreign method: \" + method");
+                StackWalker.getInstance().forEach(f -> sb.append(System.lineSeparator())
+                        .append("\tat ")
+                        .append(f));
+                System.err.println(sb.toString());
             }
             case "permit" -> {}
-            default -> throwIllegalAccessError(foreignAccess);
+            default -> throwIllegalAccessError(foreignRestrictedAccess, method);
         }
     }
 
-    private static void throwIllegalAccessError(String value) {
-        throw new IllegalAccessError("Can not access jdk.incubator.foreign.Foreign." +
-                " System property 'jdk.incubator.foreign.Foreign' is set to '" + value + "'");
+    private static void throwIllegalAccessError(String value, String method) {
+        throw new IllegalAccessError("Illegal access to restricted foreign method: " + method +
+                " ; system property 'foreign.restricted' is set to '" + value + "'");
     }
 }
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -24,11 +24,11 @@
 
 /*
  * @test
  * @modules java.base/jdk.internal.misc
  *          jdk.incubator.foreign/jdk.internal.foreign
- * @run testng/othervm -Dforeign.unsafe=permit TestNative
+ * @run testng/othervm -Dforeign.restricted=permit TestNative
  */
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
@@ -173,27 +173,27 @@
 
     @Test
     public void testMallocSegment() {
         MemoryAddress addr = MemoryAddress.ofLong(allocate(12));
         assertNull(addr.segment());
-        MemorySegment mallocSegment = MemorySegment.ofNativeUnsafe(addr, 12, null,
+        MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,
                 () -> UNSAFE.freeMemory(addr.toRawLongValue()), null);
         assertEquals(mallocSegment.byteSize(), 12);
         mallocSegment.close(); //free here
         assertTrue(!mallocSegment.isAlive());
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadResize() {
         try (MemorySegment segment = MemorySegment.allocateNative(4)) {
-            MemorySegment.ofNativeUnsafe(segment.baseAddress(), 0, null, null, null);
+            MemorySegment.ofNativeRestricted(segment.baseAddress(), 0, null, null, null);
         }
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testNullUnsafeSegment() {
-        MemorySegment.ofNativeUnsafe(null, 10, null, null, null);
+        MemorySegment.ofNativeRestricted(null, 10, null, null, null);
     }
 
     static {
         System.loadLibrary("NativeAccess");
     }
diff a/test/jdk/java/foreign/TestNoForeignUnsafeOverride.java b/test/jdk/java/foreign/TestNoForeignUnsafeOverride.java
--- a/test/jdk/java/foreign/TestNoForeignUnsafeOverride.java
+++ b/test/jdk/java/foreign/TestNoForeignUnsafeOverride.java
@@ -33,13 +33,13 @@
 
 import org.testng.annotations.Test;
 
 public class TestNoForeignUnsafeOverride {
     static {
-        System.setProperty("foreign.unsafe", "permit");
+        System.setProperty("foreign.restricted", "permit");
     }
 
     @Test(expectedExceptions = IllegalAccessError.class)
     public void testUnsafeAccess() {
-        MemorySegment.ofNativeUnsafe(MemoryAddress.ofLong(42), 10, null, null, null);
+        MemorySegment.ofNativeRestricted(MemoryAddress.ofLong(42), 10, null, null, null);
     }
 }
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -22,11 +22,11 @@
  *
  */
 
 /*
  * @test
- * @run testng/othervm -Dforeign.unsafe=permit TestSharedAccess
+ * @run testng/othervm -Dforeign.restricted=permit TestSharedAccess
  */
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
@@ -100,11 +100,11 @@
     public void testSharedUnsafe() throws Throwable {
         try (MemorySegment s = MemorySegment.allocateNative(4)) {
             setInt(s.baseAddress(), 42);
             assertEquals(getInt(s.baseAddress()), 42);
             List<Thread> threads = new ArrayList<>();
-            MemorySegment sharedSegment = MemorySegment.ofNativeUnsafe(
+            MemorySegment sharedSegment = MemorySegment.ofNativeRestricted(
                     s.baseAddress(), s.byteSize(), null, null, null);
             for (int i = 0 ; i < 1000 ; i++) {
                 threads.add(new Thread(() -> {
                     assertEquals(getInt(sharedSegment.baseAddress()), 42);
                 }));

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/Recording.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr;
 27 
 28 import java.io.Closeable;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.nio.file.Path;
 32 import java.time.Duration;
 33 import java.time.Instant;
 34 import java.util.HashMap;
 35 import java.util.Map;
 36 import java.util.Objects;
 37 
 38 import jdk.jfr.internal.PlatformRecorder;
 39 import jdk.jfr.internal.PlatformRecording;
 40 import jdk.jfr.internal.Type;
 41 import jdk.jfr.internal.Utils;
 42 import jdk.jfr.internal.WriteableUserPath;
 43 
 44 /**
 45  * Provides means to configure, start, stop and dump recording data to disk.
 46  * &lt;p&gt;
 47  * The following example shows how configure, start, stop and dump recording data to disk.
 48  *
<a name="1" id="anc1"></a><span class="line-modified"> 49  * &lt;pre&gt;{@literal</span>

 50  *   Configuration c = Configuration.getConfiguration(&quot;default&quot;);
 51  *   Recording r = new Recording(c);
 52  *   r.start();
 53  *   System.gc();
 54  *   Thread.sleep(5000);
 55  *   r.stop();
 56  *   r.dump(Files.createTempFile(&quot;my-recording&quot;, &quot;.jfr&quot;));
<a name="2" id="anc2"></a><span class="line-modified"> 57  * }&lt;/pre&gt;</span>

 58  *
 59  * @since 9
 60  */
 61 public final class Recording implements Closeable {
 62 
 63     private static class RecordingSettings extends EventSettings {
 64 
 65         private final Recording recording;
 66         private final String identifier;
 67 
 68         RecordingSettings(Recording r, String identifier) {
 69             this.recording = r;
 70             this.identifier = identifier;
 71         }
 72 
 73         RecordingSettings(Recording r, Class&lt;? extends Event&gt; eventClass) {
 74             Utils.ensureValidEventSubclass(eventClass);
 75             this.recording = r;
 76             this.identifier = String.valueOf(Type.getTypeId(eventClass));
 77         }
 78 
 79         @Override
 80         public EventSettings with(String name, String value) {
 81             Objects.requireNonNull(value);
 82             recording.setSetting(identifier + &quot;#&quot; + name, value);
 83             return this;
 84         }
 85 
 86         @Override
 87         public Map&lt;String, String&gt; toMap() {
 88             return recording.getSettings();
 89         }
 90     }
 91 
 92     private final PlatformRecording internal;
 93 
 94     /**
 95      * Creates a recording with settings from a map of name-value pairs.
 96      * &lt;p&gt;
 97      * A newly created recording is in the {@link RecordingState#NEW} state. To start
 98      * the recording, invoke the {@link Recording#start()} method.
 99      *
100      * @param settings settings as a map of name-value pairs, not {@code null}
101      *
102      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
103      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
104      *         support, or if the file repository can&#39;t be created or accessed)
105      *
106      * @throws SecurityException If a security manager is used and
107      *         FlightRecorderPermission &quot;accessFlightRecorder&quot; is not set.
108      *
109      * @see jdk.jfr
110      */
111     public Recording(Map&lt;String, String&gt; settings) {
112         Objects.requireNonNull(settings);
113         Map&lt;String, String&gt; sanitized = Utils.sanitizeNullFreeStringMap(settings);
114         PlatformRecorder r = FlightRecorder.getFlightRecorder().getInternal();
115         synchronized (r) {
116             this.internal = r.newRecording(sanitized);
117             this.internal.setRecording(this);
118             if (internal.getRecording() != this) {
119                 throw new InternalError(&quot;Internal recording not properly setup&quot;);
120             }
121         }
122     }
123 
124     /**
125      * Creates a recording without any settings.
126      * &lt;p&gt;
127      * A newly created recording is in the {@link RecordingState#NEW} state. To start
128      * the recording, invoke the {@link Recording#start()} method.
129      *
130      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
131      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
132      *         support, or if the file repository can&#39;t be created or accessed)
133      *
134      * @throws SecurityException If a security manager is used and
135      *         FlightRecorderPermission &quot;accessFlightRecorder&quot; is not set.
136      */
137     public Recording() {
138         this(new HashMap&lt;String, String&gt;());
139      }
140 
141     /**
142      * Creates a recording with settings from a configuration.
143      * &lt;p&gt;
144      * The following example shows how create a recording that uses a predefined configuration.
145      *
<a name="3" id="anc3"></a><span class="line-modified">146      * &lt;pre&gt;{@literal</span>

147      * Recording r = new Recording(Configuration.getConfiguration(&quot;default&quot;));
<a name="4" id="anc4"></a><span class="line-modified">148      * }&lt;/pre&gt;</span>

149      *
150      * The newly created recording is in the {@link RecordingState#NEW} state. To
151      * start the recording, invoke the {@link Recording#start()} method.
152      *
153      * @param configuration configuration that contains the settings to be use, not
154      *        {@code null}
155      *
156      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
157      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
158      *         support, or if the file repository can&#39;t be created or accessed)
159      *
160      * @throws SecurityException if a security manager is used and
161      *         FlightRecorderPermission &quot;accessFlightRecorder&quot; is not set.
162      *
163      * @see Configuration
164      */
165     public Recording(Configuration configuration) {
166         this(configuration.getSettings());
167     }
168 
169     /**
170      * Starts this recording.
171      * &lt;p&gt;
172      * It&#39;s recommended that the recording options and event settings are configured
173      * before calling this method. The benefits of doing so are a more consistent
174      * state when analyzing the recorded data, and improved performance because the
175      * configuration can be applied atomically.
176      * &lt;p&gt;
177      * After a successful invocation of this method, this recording is in the
178      * {@code RUNNING} state.
179      *
180      * @throws IllegalStateException if recording is already started or is in the
181      *         {@code CLOSED} state
182      */
183     public void start() {
184         internal.start();
185     }
186 
187     /**
188      * Starts this recording after a delay.
189      * &lt;p&gt;
190      * After a successful invocation of this method, this recording is in the
191      * {@code DELAYED} state.
192      *
193      * @param delay the time to wait before starting this recording, not
194      *        {@code null}
195      * @throws IllegalStateException if the recording is not it the {@code NEW} state
196      */
197     public void scheduleStart(Duration delay) {
198         Objects.requireNonNull(delay);
199         internal.scheduleStart(delay);
200     }
201 
202     /**
203      * Stops this recording.
204      * &lt;p&gt;
205      * When a recording is stopped it can&#39;t be restarted. If this
206      * recording has a destination, data is written to that destination and
207      * the recording is closed. After a recording is closed, the data is no longer
208      * available.
209      * &lt;p&gt;
210      * After a successful invocation of this method, this recording will be
211      * in the {@code STOPPED} state.
212      *
213      * @return {@code true} if recording is stopped, {@code false} otherwise
214      *
215      * @throws IllegalStateException if the recording is not started or is already stopped
216      *
217      * @throws SecurityException if a security manager exists and the caller
218      *         doesn&#39;t have {@code FilePermission} to write to the destination
219      *         path
220      *
221      * @see #setDestination(Path)
222      *
223      */
224     public boolean stop() {
225         return internal.stop(&quot;Stopped by user&quot;);
226     }
227 
228     /**
229      * Returns settings used by this recording.
230      * &lt;p&gt;
231      * Modifying the returned {@code Map} will not change the settings for this recording.
232      * &lt;p&gt;
233      * If no settings are set for this recording, an empty {@code Map} is
234      * returned.
235      *
236      * @return recording settings, not {@code null}
237      */
238     public Map&lt;String, String&gt; getSettings() {
239         return new HashMap&lt;&gt;(internal.getSettings());
240     }
241 
242     /**
243      * Returns the current size of this recording in the disk repository,
244      * measured in bytes.
245      * &lt;p&gt;
246      * The size is updated when recording buffers are flushed. If the recording is
247      * not written to the disk repository the returned size is always {@code 0}.
248      *
249      * @return amount of recorded data, measured in bytes, or {@code 0} if the
250      *         recording is not written to the disk repository
251      */
252     public long getSize() {
253         return internal.getSize();
254     }
255 
256     /**
257      * Returns the time when this recording was stopped.
258      *
259      * @return the time, or {@code null} if this recording is not stopped
260      */
261     public Instant getStopTime() {
262         return internal.getStopTime();
263     }
264 
265     /**
266      * Returns the time when this recording was started.
267      *
<a name="5" id="anc5"></a><span class="line-modified">268      * @return the time, or {@code null} if this recording is not started</span>
269      */
270     public Instant getStartTime() {
271         return internal.getStartTime();
272     }
273 
274     /**
275      * Returns the maximum size, measured in bytes, at which data is no longer kept in the disk repository.
276      *
277      * @return maximum size in bytes, or {@code 0} if no maximum size is set
278      */
279     public long getMaxSize() {
280         return internal.getMaxSize();
281     }
282 
283     /**
284      * Returns the length of time that the data is kept in the disk repository
285      * before it is removed.
286      *
287      * @return maximum length of time, or {@code null} if no maximum length of time
288      *         has been set
289      */
290     public Duration getMaxAge() {
291         return internal.getMaxAge();
292     }
293 
294     /**
295      * Returns the name of this recording.
296      * &lt;p&gt;
297      * By default, the name is the same as the recording ID.
298      *
299      * @return the recording name, not {@code null}
300      */
301     public String getName() {
302         return internal.getName();
303     }
304 
305     /**
306      * Replaces all settings for this recording.
307      * &lt;p&gt;
308      * The following example shows how to set event settings for a recording.
309      *
<a name="6" id="anc6"></a><span class="line-modified">310      * &lt;pre&gt;{@literal</span>
<span class="line-modified">311      *     Map&lt;String, String&gt; settings = new HashMap&lt;&gt;();</span>

312      *     settings.putAll(EventSettings.enabled(&quot;jdk.CPUSample&quot;).withPeriod(Duration.ofSeconds(2)).toMap());
313      *     settings.putAll(EventSettings.enabled(MyEvent.class).withThreshold(Duration.ofSeconds(2)).withoutStackTrace().toMap());
314      *     settings.put(&quot;jdk.ExecutionSample#period&quot;, &quot;10 ms&quot;);
315      *     recording.setSettings(settings);
<a name="7" id="anc7"></a><span class="line-modified">316      * }&lt;/pre&gt;</span>

317      *
318      * The following example shows how to merge settings.
319      *
<a name="8" id="anc8"></a><span class="line-modified">320      * &lt;pre&gt;{@literal</span>

321      *     Map&lt;String, String&gt; settings = recording.getSettings();
322      *     settings.putAll(additionalSettings);
323      *     recording.setSettings(settings);
<a name="9" id="anc9"></a><span class="line-modified">324      * }&lt;/pre&gt;</span>

325      *
326      * @param settings the settings to set, not {@code null}
327      */
328     public void setSettings(Map&lt;String, String&gt; settings) {
329         Objects.requireNonNull(settings);
330         Map&lt;String, String&gt; sanitized = Utils.sanitizeNullFreeStringMap(settings);
331         internal.setSettings(sanitized);
332     }
333 
334     /**
335      * Returns the recording state that this recording is currently in.
336      *
337      * @return the recording state, not {@code null}
338      *
339      * @see RecordingState
340      */
341     public RecordingState getState() {
342         return internal.getState();
343     }
344 
345     /**
346      * Releases all data that is associated with this recording.
347      * &lt;p&gt;
348      * After a successful invocation of this method, this recording is in the
349      * {@code CLOSED} state.
350      */
351     @Override
352     public void close() {
353         internal.close();
354     }
355 
356     /**
357      * Returns a clone of this recording, with a new recording ID and name.
358      *
359      * Clones are useful for dumping data without stopping the recording. After
360      * a clone is created, the amount of data to copy is constrained
361      * with the {@link #setMaxAge(Duration)} method and the {@link #setMaxSize(long)}method.
362      *
363      * @param stop {@code true} if the newly created copy should be stopped
364      *        immediately, {@code false} otherwise
365      * @return the recording copy, not {@code null}
366      */
367     public Recording copy(boolean stop) {
368         return internal.newCopy(stop);
369     }
370 
371     /**
372      * Writes recording data to a file.
373      * &lt;p&gt;
374      * Recording must be started, but not necessarily stopped.
375      *
376      * @param destination the location where recording data is written, not
377      *        {@code null}
378      *
379      * @throws IOException if the recording can&#39;t be copied to the specified
380      *         location
381      *
382      * @throws SecurityException if a security manager exists and the caller doesn&#39;t
383      *         have {@code FilePermission} to write to the destination path
384      */
385     public void dump(Path destination) throws IOException {
386         Objects.requireNonNull(destination);
387         internal.dump(new WriteableUserPath(destination));
388 
389     }
390 
391     /**
392      * Returns {@code true} if this recording uses the disk repository, {@code false} otherwise.
393      * &lt;p&gt;
394      * If no value is set, {@code true} is returned.
395      *
396      * @return {@code true} if the recording uses the disk repository, {@code false}
397      *         otherwise
398      */
399     public boolean isToDisk() {
400         return internal.isToDisk();
401     }
402 
403     /**
404      * Determines how much data is kept in the disk repository.
405      * &lt;p&gt;
406      * To control the amount of recording data that is stored on disk, the maximum
407      * amount of data to retain can be specified. When the maximum limit is
408      * exceeded, the Java Virtual Machine (JVM) removes the oldest chunk to make
409      * room for a more recent chunk.
410      * &lt;p&gt;
411      * If neither maximum limit or the maximum age is set, the size of the
412      * recording may grow indefinitely.
413      *
414      * @param maxSize the amount of data to retain, {@code 0} if infinite
415      *
<a name="10" id="anc10"></a><span class="line-modified">416      * @throws IllegalArgumentException if {@code maxSize} is negative</span>
417      *
418      * @throws IllegalStateException if the recording is in {@code CLOSED} state
419      */
420     public void setMaxSize(long maxSize) {
421         if (maxSize &lt; 0) {
422             throw new IllegalArgumentException(&quot;Max size of recording can&#39;t be negative&quot;);
423         }
424         internal.setMaxSize(maxSize);
425     }
426 
427         /**
428          * Determines how often events are made available for streaming.
429          *
430          * @param interval the interval at which events are made available for streaming.
431          *
432          * @throws IllegalArgumentException if {@code interval} is negative
433          *
434          * @throws IllegalStateException if the recording is in the {@code CLOSED} state
435          *
436          * @since 14
437          */
438         /*package private*/ void setFlushInterval(Duration interval) {
439             Objects.nonNull(interval);
440             if (interval.isNegative()) {
441                 throw new IllegalArgumentException(&quot;Stream interval can&#39;t be negative&quot;);
442             }
443             internal.setFlushInterval(interval);
444         }
445 
446     /**
447      * Returns how often events are made available for streaming purposes.
448      *
449      * @return the flush interval, or {@code null} if no interval has been set
450      *
451      * @since 14
452      */
453     /*package private*/ Duration getFlushInterval() {
454         return internal.getFlushInterval();
455     }
456 
457     /**
458      * Determines how far back data is kept in the disk repository.
459      * &lt;p&gt;
460      * To control the amount of recording data stored on disk, the maximum length of
461      * time to retain the data can be specified. Data stored on disk that is older
462      * than the specified length of time is removed by the Java Virtual Machine (JVM).
463      * &lt;p&gt;
464      * If neither maximum limit or the maximum age is set, the size of the
465      * recording may grow indefinitely.
466      *
467      * @param maxAge the length of time that data is kept, or {@code null} if infinite
468      *
<a name="11" id="anc11"></a><span class="line-modified">469      * @throws IllegalArgumentException if {@code maxAge} is negative</span>
470      *
471      * @throws IllegalStateException if the recording is in the {@code CLOSED} state
472      */
473     public void setMaxAge(Duration maxAge) {
474         if (maxAge != null &amp;&amp; maxAge.isNegative()) {
475             throw new IllegalArgumentException(&quot;Max age of recording can&#39;t be negative&quot;);
476         }
477         internal.setMaxAge(maxAge);
478     }
479 
480     /**
481      * Sets a location where data is written on recording stop, or
482      * {@code null} if data is not to be dumped.
483      * &lt;p&gt;
484      * If a destination is set, this recording is automatically closed
485      * after data is successfully copied to the destination path.
486      * &lt;p&gt;
487      * If a destination is &lt;em&gt;not&lt;/em&gt; set, Flight Recorder retains the
488      * recording data until this recording is closed. Use the {@link #dump(Path)} method to
489      * manually write data to a file.
490      *
491      * @param destination the destination path, or {@code null} if recording should
492      *        not be dumped at stop
493      *
494      * @throws IllegalStateException if recording is in the {@code STOPPED} or
495      *         {@code CLOSED} state.
496      *
497      * @throws SecurityException if a security manager exists and the caller
498      *         doesn&#39;t have {@code FilePermission} to read, write, and delete the
499      *         {@code destination} file
500      *
501      * @throws IOException if the path is not writable
502      */
503     public void setDestination(Path destination) throws IOException {
504         internal.setDestination(destination != null ? new WriteableUserPath(destination) : null);
505     }
506 
507     /**
508      * Returns the destination file, where recording data is written when the
509      * recording stops, or {@code null} if no destination is set.
510      *
511      * @return the destination file, or {@code null} if not set.
512      */
513     public Path getDestination() {
514         WriteableUserPath usp = internal.getDestination();
515         if (usp == null) {
516             return null;
517         } else {
518             return usp.getPotentiallyMaliciousOriginal();
519         }
520     }
521 
522     /**
523      * Returns a unique ID for this recording.
524      *
525      * @return the recording ID
526      */
527     public long getId() {
528         return internal.getId();
529     }
530 
531     /**
532      * Sets a human-readable name (for example, {@code &quot;My Recording&quot;}).
533      *
534      * @param name the recording name, not {@code null}
535      *
536      * @throws IllegalStateException if the recording is in {@code CLOSED} state
537      */
538     public void setName(String name) {
539         Objects.requireNonNull(name);
540         internal.setName(name);
541     }
542 
543     /**
544      * Sets whether this recording is dumped to disk when the JVM exits.
545      *
546      * @param dumpOnExit if this recording should be dumped when the JVM exits
547      */
548     public void setDumpOnExit(boolean dumpOnExit) {
549         internal.setDumpOnExit(dumpOnExit);
550     }
551 
552     /**
553      * Returns whether this recording is dumped to disk when the JVM exits.
554      * &lt;p&gt;
555      * If dump on exit is not set, {@code false} is returned.
556      *
557      * @return {@code true} if the recording is dumped on exit, {@code false}
558      *         otherwise.
559      */
560     public boolean getDumpOnExit() {
561         return internal.getDumpOnExit();
562     }
563 
564     /**
565      * Determines whether this recording is continuously flushed to the disk
566      * repository or data is constrained to what is available in memory buffers.
567      *
568      * @param disk {@code true} if this recording is written to disk,
569      *        {@code false} if in-memory
570      *
571      */
572     public void setToDisk(boolean disk) {
573         internal.setToDisk(disk);
574     }
575 
576     /**
577      * Creates a data stream for a specified interval.
578      * &lt;p&gt;
579      * The stream may contain some data outside the specified range.
580      *
<a name="12" id="anc12"></a><span class="line-modified">581      * @param start the start time for the stream, or {@code null} to get data from</span>
582      *        start time of the recording
583      *
<a name="13" id="anc13"></a><span class="line-modified">584      * @param end the end time for the stream, or {@code null} to get data until the</span>
585      *        present time.
586      *
587      * @return an input stream, or {@code null} if no data is available in the
588      *         interval.
589      *
590      * @throws IllegalArgumentException if {@code end} happens before
591      *         {@code start}
592      *
593      * @throws IOException if a stream can&#39;t be opened
594      */
595     public InputStream getStream(Instant start, Instant end) throws IOException {
596         if (start != null &amp;&amp; end != null &amp;&amp; end.isBefore(start)) {
597             throw new IllegalArgumentException(&quot;End time of requested stream must not be before start time&quot;);
598         }
599         return internal.open(start, end);
600     }
601 
602     /**
603      * Returns the specified duration for this recording, or {@code null} if no
604      * duration is set.
605      * &lt;p&gt;
606      * The duration can be set only when the recording is in the
607      * {@link RecordingState#NEW} state.
608      *
609      * @return the desired duration of the recording, or {@code null} if no duration
610      *         has been set.
611      */
612     public Duration getDuration() {
613         return internal.getDuration();
614     }
615 
616     /**
617      * Sets a duration for how long a recording runs before it stops.
618      * &lt;p&gt;
619      * By default, a recording has no duration ({@code null}).
620      *
621      * @param duration the duration, or {@code null} if no duration is set
622      *
623      * @throws IllegalStateException if recording is in the {@code STOPPED} or {@code CLOSED} state
624      */
625     public void setDuration(Duration duration) {
626         internal.setDuration(duration);
627     }
628 
629     /**
630      * Enables the event with the specified name.
631      * &lt;p&gt;
632      * If multiple events have the same name (for example, the same class is loaded
633      * in different class loaders), then all events that match the name are enabled. To
634      * enable a specific class, use the {@link #enable(Class)} method or a {@code String}
635      * representation of the event type ID.
636      *
637      * @param name the settings for the event, not {@code null}
638      *
639      * @return an event setting for further configuration, not {@code null}
640      *
641      * @see EventType
642      */
643     public EventSettings enable(String name) {
644         Objects.requireNonNull(name);
645         RecordingSettings rs = new RecordingSettings(this, name);
646         rs.with(&quot;enabled&quot;, &quot;true&quot;);
647         return rs;
648     }
649 
650     /**
651      * Disables event with the specified name.
652      * &lt;p&gt;
653      * If multiple events with same name (for example, the same class is loaded
654      * in different class loaders), then all events that match the
655      * name is disabled. To disable a specific class, use the
656      * {@link #disable(Class)} method or a {@code String} representation of the event
657      * type ID.
658      *
659      * @param name the settings for the event, not {@code null}
660      *
661      * @return an event setting for further configuration, not {@code null}
662      *
663      */
664     public EventSettings disable(String name) {
665         Objects.requireNonNull(name);
666         RecordingSettings rs = new RecordingSettings(this, name);
667         rs.with(&quot;enabled&quot;, &quot;false&quot;);
668         return rs;
669     }
670 
671     /**
672      * Enables event.
673      *
674      * @param eventClass the event to enable, not {@code null}
675      *
676      * @throws IllegalArgumentException if {@code eventClass} is an abstract
677      *         class or not a subclass of {@link Event}
678      *
679      * @return an event setting for further configuration, not {@code null}
680      */
681     public EventSettings enable(Class&lt;? extends Event&gt; eventClass) {
682         Objects.requireNonNull(eventClass);
683         RecordingSettings rs = new RecordingSettings(this, eventClass);
684         rs.with(&quot;enabled&quot;, &quot;true&quot;);
685         return rs;
686     }
687 
688     /**
689      * Disables event.
690      *
691      * @param eventClass the event to enable, not {@code null}
692      *
693      * @throws IllegalArgumentException if {@code eventClass} is an abstract
694      *         class or not a subclass of {@link Event}
695      *
696      * @return an event setting for further configuration, not {@code null}
697      *
698      */
699     public EventSettings disable(Class&lt;? extends Event&gt; eventClass) {
700         Objects.requireNonNull(eventClass);
701         RecordingSettings rs = new RecordingSettings(this, eventClass);
702         rs.with(&quot;enabled&quot;, &quot;false&quot;);
703         return rs;
704     }
705 
706     // package private
707     PlatformRecording getInternal() {
708         return internal;
709     }
710 
711     private void setSetting(String id, String value) {
712         Objects.requireNonNull(id);
713         Objects.requireNonNull(value);
714         internal.setSetting(id, value);
715     }
716 
717 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
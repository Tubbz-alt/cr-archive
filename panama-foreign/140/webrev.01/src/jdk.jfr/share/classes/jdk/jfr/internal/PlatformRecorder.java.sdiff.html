<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecorder.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformEventType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PlatformRecording.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecorder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
226         if (duration != null) {
227             recording.setStopTime(now.plus(duration));
228         }
229         boolean toDisk = recording.isToDisk();
230         boolean beginPhysical = true;
231         long streamInterval = recording.getStreamIntervalMillis();
232         for (PlatformRecording s : getRecordings()) {
233             if (s.getState() == RecordingState.RUNNING) {
234                 beginPhysical = false;
235                 if (s.isToDisk()) {
236                     toDisk = true;
237                 }
238                 streamInterval = Math.min(streamInterval, s.getStreamIntervalMillis());
239             }
240         }
241         long startNanos = -1;
242         if (beginPhysical) {
243             RepositoryChunk newChunk = null;
244             if (toDisk) {
245                 newChunk = repository.newChunk(now);
<span class="line-modified">246                 MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());</span>
247             } else {
248                 MetadataRepository.getInstance().setOutput(null);
249             }
250             currentChunk = newChunk;
251             jvm.beginRecording();
252             startNanos = jvm.getChunkStartNanos();
253             recording.setState(RecordingState.RUNNING);
254             updateSettings();
255             writeMetaEvents();
256         } else {
257             RepositoryChunk newChunk = null;
258             if (toDisk) {
259                 newChunk = repository.newChunk(now);
260                 RequestEngine.doChunkEnd();
<span class="line-modified">261                 MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());</span>
262                 startNanos = jvm.getChunkStartNanos();
263             }
264             recording.setState(RecordingState.RUNNING);
265             updateSettings();
266             writeMetaEvents();
267             if (currentChunk != null) {
268                 finishChunk(currentChunk, now, recording);
269             }
270             currentChunk = newChunk;
271         }
272         if (toDisk) {
273             RequestEngine.setFlushInterval(streamInterval);
274         }
275         RequestEngine.doChunkBegin();
276 
277         return startNanos;
278     }
279 
280     synchronized void stop(PlatformRecording recording) {
281         RecordingState state = recording.getState();
</pre>
<hr />
<pre>
309                 if (currentChunk != null) {
310                     if (inShutdown) {
311                         jvm.markChunkFinal();
312                     }
313                     MetadataRepository.getInstance().setOutput(null);
314                     finishChunk(currentChunk, now, null);
315                     currentChunk = null;
316                 }
317             } else {
318                 // last memory
319                 dumpMemoryToDestination(recording);
320             }
321             jvm.endRecording();
322             disableEvents();
323         } else {
324             RepositoryChunk newChunk = null;
325             RequestEngine.doChunkEnd();
326             updateSettingsButIgnoreRecording(recording);
327             if (toDisk) {
328                 newChunk = repository.newChunk(now);
<span class="line-modified">329                 MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());</span>
330             } else {
331                 MetadataRepository.getInstance().setOutput(null);
332             }
333             writeMetaEvents();
334             if (currentChunk != null) {
335                 finishChunk(currentChunk, now, null);
336             }
337             currentChunk = newChunk;
338             RequestEngine.doChunkBegin();
339         }
340 
341         if (toDisk) {
342             RequestEngine.setFlushInterval(streamInterval);
343         } else {
344             RequestEngine.setFlushInterval(Long.MAX_VALUE);
345         }
346         recording.setState(RecordingState.STOPPED);
347     }
348 
349     private void dumpMemoryToDestination(PlatformRecording recording)  {
</pre>
<hr />
<pre>
361         updateSettingsButIgnoreRecording(null);
362     }
363 
364     void updateSettingsButIgnoreRecording(PlatformRecording ignoreMe) {
365         List&lt;PlatformRecording&gt; recordings = getRunningRecordings();
366         List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;(recordings.size());
367         for (PlatformRecording r : recordings) {
368             if (r != ignoreMe) {
369                 list.add(r.getSettings());
370             }
371         }
372         MetadataRepository.getInstance().setSettings(list);
373     }
374 
375 
376 
377     synchronized void rotateDisk() {
378         Instant now = Instant.now();
379         RepositoryChunk newChunk = repository.newChunk(now);
380         RequestEngine.doChunkEnd();
<span class="line-modified">381         MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());</span>
382         writeMetaEvents();
383         if (currentChunk != null) {
384             finishChunk(currentChunk, now, null);
385         }
386         currentChunk = newChunk;
387         RequestEngine.doChunkBegin();
388     }
389 
390     private List&lt;PlatformRecording&gt; getRunningRecordings() {
391         List&lt;PlatformRecording&gt; runningRecordings = new ArrayList&lt;&gt;();
392         for (PlatformRecording recording : getRecordings()) {
393             if (recording.getState() == RecordingState.RUNNING) {
394                 runningRecordings.add(recording);
395             }
396         }
397         return runningRecordings;
398     }
399 
400     private List&lt;RepositoryChunk&gt; makeChunkList(Instant startTime, Instant endTime) {
401         Set&lt;RepositoryChunk&gt; chunkSet = new HashSet&lt;&gt;();
</pre>
</td>
<td>
<hr />
<pre>
226         if (duration != null) {
227             recording.setStopTime(now.plus(duration));
228         }
229         boolean toDisk = recording.isToDisk();
230         boolean beginPhysical = true;
231         long streamInterval = recording.getStreamIntervalMillis();
232         for (PlatformRecording s : getRecordings()) {
233             if (s.getState() == RecordingState.RUNNING) {
234                 beginPhysical = false;
235                 if (s.isToDisk()) {
236                     toDisk = true;
237                 }
238                 streamInterval = Math.min(streamInterval, s.getStreamIntervalMillis());
239             }
240         }
241         long startNanos = -1;
242         if (beginPhysical) {
243             RepositoryChunk newChunk = null;
244             if (toDisk) {
245                 newChunk = repository.newChunk(now);
<span class="line-modified">246                 MetadataRepository.getInstance().setOutput(newChunk.getUnfinishedFile().toString());</span>
247             } else {
248                 MetadataRepository.getInstance().setOutput(null);
249             }
250             currentChunk = newChunk;
251             jvm.beginRecording();
252             startNanos = jvm.getChunkStartNanos();
253             recording.setState(RecordingState.RUNNING);
254             updateSettings();
255             writeMetaEvents();
256         } else {
257             RepositoryChunk newChunk = null;
258             if (toDisk) {
259                 newChunk = repository.newChunk(now);
260                 RequestEngine.doChunkEnd();
<span class="line-modified">261                 MetadataRepository.getInstance().setOutput(newChunk.getUnfinishedFile().toString());</span>
262                 startNanos = jvm.getChunkStartNanos();
263             }
264             recording.setState(RecordingState.RUNNING);
265             updateSettings();
266             writeMetaEvents();
267             if (currentChunk != null) {
268                 finishChunk(currentChunk, now, recording);
269             }
270             currentChunk = newChunk;
271         }
272         if (toDisk) {
273             RequestEngine.setFlushInterval(streamInterval);
274         }
275         RequestEngine.doChunkBegin();
276 
277         return startNanos;
278     }
279 
280     synchronized void stop(PlatformRecording recording) {
281         RecordingState state = recording.getState();
</pre>
<hr />
<pre>
309                 if (currentChunk != null) {
310                     if (inShutdown) {
311                         jvm.markChunkFinal();
312                     }
313                     MetadataRepository.getInstance().setOutput(null);
314                     finishChunk(currentChunk, now, null);
315                     currentChunk = null;
316                 }
317             } else {
318                 // last memory
319                 dumpMemoryToDestination(recording);
320             }
321             jvm.endRecording();
322             disableEvents();
323         } else {
324             RepositoryChunk newChunk = null;
325             RequestEngine.doChunkEnd();
326             updateSettingsButIgnoreRecording(recording);
327             if (toDisk) {
328                 newChunk = repository.newChunk(now);
<span class="line-modified">329                 MetadataRepository.getInstance().setOutput(newChunk.getUnfinishedFile().toString());</span>
330             } else {
331                 MetadataRepository.getInstance().setOutput(null);
332             }
333             writeMetaEvents();
334             if (currentChunk != null) {
335                 finishChunk(currentChunk, now, null);
336             }
337             currentChunk = newChunk;
338             RequestEngine.doChunkBegin();
339         }
340 
341         if (toDisk) {
342             RequestEngine.setFlushInterval(streamInterval);
343         } else {
344             RequestEngine.setFlushInterval(Long.MAX_VALUE);
345         }
346         recording.setState(RecordingState.STOPPED);
347     }
348 
349     private void dumpMemoryToDestination(PlatformRecording recording)  {
</pre>
<hr />
<pre>
361         updateSettingsButIgnoreRecording(null);
362     }
363 
364     void updateSettingsButIgnoreRecording(PlatformRecording ignoreMe) {
365         List&lt;PlatformRecording&gt; recordings = getRunningRecordings();
366         List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;(recordings.size());
367         for (PlatformRecording r : recordings) {
368             if (r != ignoreMe) {
369                 list.add(r.getSettings());
370             }
371         }
372         MetadataRepository.getInstance().setSettings(list);
373     }
374 
375 
376 
377     synchronized void rotateDisk() {
378         Instant now = Instant.now();
379         RepositoryChunk newChunk = repository.newChunk(now);
380         RequestEngine.doChunkEnd();
<span class="line-modified">381         MetadataRepository.getInstance().setOutput(newChunk.getUnfinishedFile().toString());</span>
382         writeMetaEvents();
383         if (currentChunk != null) {
384             finishChunk(currentChunk, now, null);
385         }
386         currentChunk = newChunk;
387         RequestEngine.doChunkBegin();
388     }
389 
390     private List&lt;PlatformRecording&gt; getRunningRecordings() {
391         List&lt;PlatformRecording&gt; runningRecordings = new ArrayList&lt;&gt;();
392         for (PlatformRecording recording : getRecordings()) {
393             if (recording.getState() == RecordingState.RUNNING) {
394                 runningRecordings.add(recording);
395             }
396         }
397         return runningRecordings;
398     }
399 
400     private List&lt;RepositoryChunk&gt; makeChunkList(Instant startTime, Instant endTime) {
401         Set&lt;RepositoryChunk&gt; chunkSet = new HashSet&lt;&gt;();
</pre>
</td>
</tr>
</table>
<center><a href="PlatformEventType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PlatformRecording.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/Recording.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Period.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="RecordingState.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/Recording.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.nio.file.Path;
 32 import java.time.Duration;
 33 import java.time.Instant;
 34 import java.util.HashMap;
 35 import java.util.Map;
 36 import java.util.Objects;
 37 
 38 import jdk.jfr.internal.PlatformRecorder;
 39 import jdk.jfr.internal.PlatformRecording;
 40 import jdk.jfr.internal.Type;
 41 import jdk.jfr.internal.Utils;
 42 import jdk.jfr.internal.WriteableUserPath;
 43 
 44 /**
 45  * Provides means to configure, start, stop and dump recording data to disk.
 46  * &lt;p&gt;
 47  * The following example shows how configure, start, stop and dump recording data to disk.
 48  *
<span class="line-modified"> 49  * &lt;pre&gt;</span>
<span class="line-removed"> 50  * &lt;code&gt;</span>
 51  *   Configuration c = Configuration.getConfiguration(&quot;default&quot;);
 52  *   Recording r = new Recording(c);
 53  *   r.start();
 54  *   System.gc();
 55  *   Thread.sleep(5000);
 56  *   r.stop();
 57  *   r.dump(Files.createTempFile(&quot;my-recording&quot;, &quot;.jfr&quot;));
<span class="line-modified"> 58  * &lt;/code&gt;</span>
<span class="line-removed"> 59  * &lt;/pre&gt;</span>
 60  *
 61  * @since 9
 62  */
 63 public final class Recording implements Closeable {
 64 
 65     private static class RecordingSettings extends EventSettings {
 66 
 67         private final Recording recording;
 68         private final String identifier;
 69 
 70         RecordingSettings(Recording r, String identifier) {
 71             this.recording = r;
 72             this.identifier = identifier;
 73         }
 74 
 75         RecordingSettings(Recording r, Class&lt;? extends Event&gt; eventClass) {
 76             Utils.ensureValidEventSubclass(eventClass);
 77             this.recording = r;
 78             this.identifier = String.valueOf(Type.getTypeId(eventClass));
 79         }
</pre>
<hr />
<pre>
128      * &lt;p&gt;
129      * A newly created recording is in the {@link RecordingState#NEW} state. To start
130      * the recording, invoke the {@link Recording#start()} method.
131      *
132      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
133      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
134      *         support, or if the file repository can&#39;t be created or accessed)
135      *
136      * @throws SecurityException If a security manager is used and
137      *         FlightRecorderPermission &quot;accessFlightRecorder&quot; is not set.
138      */
139     public Recording() {
140         this(new HashMap&lt;String, String&gt;());
141      }
142 
143     /**
144      * Creates a recording with settings from a configuration.
145      * &lt;p&gt;
146      * The following example shows how create a recording that uses a predefined configuration.
147      *
<span class="line-modified">148      * &lt;pre&gt;</span>
<span class="line-removed">149      * &lt;code&gt;</span>
150      * Recording r = new Recording(Configuration.getConfiguration(&quot;default&quot;));
<span class="line-modified">151      * &lt;/code&gt;</span>
<span class="line-removed">152      * &lt;/pre&gt;</span>
153      *
154      * The newly created recording is in the {@link RecordingState#NEW} state. To
155      * start the recording, invoke the {@link Recording#start()} method.
156      *
157      * @param configuration configuration that contains the settings to be use, not
158      *        {@code null}
159      *
160      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
161      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
162      *         support, or if the file repository can&#39;t be created or accessed)
163      *
164      * @throws SecurityException if a security manager is used and
165      *         FlightRecorderPermission &quot;accessFlightRecorder&quot; is not set.
166      *
167      * @see Configuration
168      */
169     public Recording(Configuration configuration) {
170         this(configuration.getSettings());
171     }
172 
</pre>
<hr />
<pre>
252      *
253      * @return amount of recorded data, measured in bytes, or {@code 0} if the
254      *         recording is not written to the disk repository
255      */
256     public long getSize() {
257         return internal.getSize();
258     }
259 
260     /**
261      * Returns the time when this recording was stopped.
262      *
263      * @return the time, or {@code null} if this recording is not stopped
264      */
265     public Instant getStopTime() {
266         return internal.getStopTime();
267     }
268 
269     /**
270      * Returns the time when this recording was started.
271      *
<span class="line-modified">272      * @return the the time, or {@code null} if this recording is not started</span>
273      */
274     public Instant getStartTime() {
275         return internal.getStartTime();
276     }
277 
278     /**
279      * Returns the maximum size, measured in bytes, at which data is no longer kept in the disk repository.
280      *
281      * @return maximum size in bytes, or {@code 0} if no maximum size is set
282      */
283     public long getMaxSize() {
284         return internal.getMaxSize();
285     }
286 
287     /**
288      * Returns the length of time that the data is kept in the disk repository
289      * before it is removed.
290      *
291      * @return maximum length of time, or {@code null} if no maximum length of time
292      *         has been set
</pre>
<hr />
<pre>
294     public Duration getMaxAge() {
295         return internal.getMaxAge();
296     }
297 
298     /**
299      * Returns the name of this recording.
300      * &lt;p&gt;
301      * By default, the name is the same as the recording ID.
302      *
303      * @return the recording name, not {@code null}
304      */
305     public String getName() {
306         return internal.getName();
307     }
308 
309     /**
310      * Replaces all settings for this recording.
311      * &lt;p&gt;
312      * The following example shows how to set event settings for a recording.
313      *
<span class="line-modified">314      * &lt;pre&gt;</span>
<span class="line-modified">315      * &lt;code&gt;</span>
<span class="line-removed">316      *     Map{@literal &lt;}String, String{@literal &gt;} settings = new HashMap{@literal &lt;}{@literal &gt;}();</span>
317      *     settings.putAll(EventSettings.enabled(&quot;jdk.CPUSample&quot;).withPeriod(Duration.ofSeconds(2)).toMap());
318      *     settings.putAll(EventSettings.enabled(MyEvent.class).withThreshold(Duration.ofSeconds(2)).withoutStackTrace().toMap());
319      *     settings.put(&quot;jdk.ExecutionSample#period&quot;, &quot;10 ms&quot;);
320      *     recording.setSettings(settings);
<span class="line-modified">321      * &lt;/code&gt;</span>
<span class="line-removed">322      * &lt;/pre&gt;</span>
323      *
324      * The following example shows how to merge settings.
325      *
<span class="line-modified">326      * &lt;pre&gt;</span>
<span class="line-removed">327      *     {@code</span>
328      *     Map&lt;String, String&gt; settings = recording.getSettings();
329      *     settings.putAll(additionalSettings);
330      *     recording.setSettings(settings);
<span class="line-modified">331      * }</span>
<span class="line-removed">332      * &lt;/pre&gt;</span>
333      *
334      * @param settings the settings to set, not {@code null}
335      */
336     public void setSettings(Map&lt;String, String&gt; settings) {
337         Objects.requireNonNull(settings);
338         Map&lt;String, String&gt; sanitized = Utils.sanitizeNullFreeStringMap(settings);
339         internal.setSettings(sanitized);
340     }
341 
342     /**
343      * Returns the recording state that this recording is currently in.
344      *
345      * @return the recording state, not {@code null}
346      *
347      * @see RecordingState
348      */
349     public RecordingState getState() {
350         return internal.getState();
351     }
352 
</pre>
<hr />
<pre>
404      * @return {@code true} if the recording uses the disk repository, {@code false}
405      *         otherwise
406      */
407     public boolean isToDisk() {
408         return internal.isToDisk();
409     }
410 
411     /**
412      * Determines how much data is kept in the disk repository.
413      * &lt;p&gt;
414      * To control the amount of recording data that is stored on disk, the maximum
415      * amount of data to retain can be specified. When the maximum limit is
416      * exceeded, the Java Virtual Machine (JVM) removes the oldest chunk to make
417      * room for a more recent chunk.
418      * &lt;p&gt;
419      * If neither maximum limit or the maximum age is set, the size of the
420      * recording may grow indefinitely.
421      *
422      * @param maxSize the amount of data to retain, {@code 0} if infinite
423      *
<span class="line-modified">424      * @throws IllegalArgumentException if &lt;code&gt;maxSize&lt;/code&gt; is negative</span>
425      *
426      * @throws IllegalStateException if the recording is in {@code CLOSED} state
427      */
428     public void setMaxSize(long maxSize) {
429         if (maxSize &lt; 0) {
430             throw new IllegalArgumentException(&quot;Max size of recording can&#39;t be negative&quot;);
431         }
432         internal.setMaxSize(maxSize);
433     }
434 
435         /**
436          * Determines how often events are made available for streaming.
437          *
438          * @param interval the interval at which events are made available for streaming.
439          *
440          * @throws IllegalArgumentException if {@code interval} is negative
441          *
442          * @throws IllegalStateException if the recording is in the {@code CLOSED} state
443          *
444          * @since 14
</pre>
<hr />
<pre>
457      * @return the flush interval, or {@code null} if no interval has been set
458      *
459      * @since 14
460      */
461     /*package private*/ Duration getFlushInterval() {
462         return internal.getFlushInterval();
463     }
464 
465     /**
466      * Determines how far back data is kept in the disk repository.
467      * &lt;p&gt;
468      * To control the amount of recording data stored on disk, the maximum length of
469      * time to retain the data can be specified. Data stored on disk that is older
470      * than the specified length of time is removed by the Java Virtual Machine (JVM).
471      * &lt;p&gt;
472      * If neither maximum limit or the maximum age is set, the size of the
473      * recording may grow indefinitely.
474      *
475      * @param maxAge the length of time that data is kept, or {@code null} if infinite
476      *
<span class="line-modified">477      * @throws IllegalArgumentException if &lt;code&gt;maxAge&lt;/code&gt; is negative</span>
478      *
479      * @throws IllegalStateException if the recording is in the {@code CLOSED} state
480      */
481     public void setMaxAge(Duration maxAge) {
482         if (maxAge != null &amp;&amp; maxAge.isNegative()) {
483             throw new IllegalArgumentException(&quot;Max age of recording can&#39;t be negative&quot;);
484         }
485         internal.setMaxAge(maxAge);
486     }
487 
488     /**
489      * Sets a location where data is written on recording stop, or
490      * {@code null} if data is not to be dumped.
491      * &lt;p&gt;
492      * If a destination is set, this recording is automatically closed
493      * after data is successfully copied to the destination path.
494      * &lt;p&gt;
495      * If a destination is &lt;em&gt;not&lt;/em&gt; set, Flight Recorder retains the
496      * recording data until this recording is closed. Use the {@link #dump(Path)} method to
497      * manually write data to a file.
</pre>
<hr />
<pre>
569         return internal.getDumpOnExit();
570     }
571 
572     /**
573      * Determines whether this recording is continuously flushed to the disk
574      * repository or data is constrained to what is available in memory buffers.
575      *
576      * @param disk {@code true} if this recording is written to disk,
577      *        {@code false} if in-memory
578      *
579      */
580     public void setToDisk(boolean disk) {
581         internal.setToDisk(disk);
582     }
583 
584     /**
585      * Creates a data stream for a specified interval.
586      * &lt;p&gt;
587      * The stream may contain some data outside the specified range.
588      *
<span class="line-modified">589      * @param the start start time for the stream, or {@code null} to get data from</span>
590      *        start time of the recording
591      *
<span class="line-modified">592      * @param the end end time for the stream, or {@code null} to get data until the</span>
593      *        present time.
594      *
595      * @return an input stream, or {@code null} if no data is available in the
596      *         interval.
597      *
598      * @throws IllegalArgumentException if {@code end} happens before
599      *         {@code start}
600      *
601      * @throws IOException if a stream can&#39;t be opened
602      */
603     public InputStream getStream(Instant start, Instant end) throws IOException {
604         if (start != null &amp;&amp; end != null &amp;&amp; end.isBefore(start)) {
605             throw new IllegalArgumentException(&quot;End time of requested stream must not be before start time&quot;);
606         }
607         return internal.open(start, end);
608     }
609 
610     /**
611      * Returns the specified duration for this recording, or {@code null} if no
612      * duration is set.
</pre>
</td>
<td>
<hr />
<pre>
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.nio.file.Path;
 32 import java.time.Duration;
 33 import java.time.Instant;
 34 import java.util.HashMap;
 35 import java.util.Map;
 36 import java.util.Objects;
 37 
 38 import jdk.jfr.internal.PlatformRecorder;
 39 import jdk.jfr.internal.PlatformRecording;
 40 import jdk.jfr.internal.Type;
 41 import jdk.jfr.internal.Utils;
 42 import jdk.jfr.internal.WriteableUserPath;
 43 
 44 /**
 45  * Provides means to configure, start, stop and dump recording data to disk.
 46  * &lt;p&gt;
 47  * The following example shows how configure, start, stop and dump recording data to disk.
 48  *
<span class="line-modified"> 49  * &lt;pre&gt;{@literal</span>

 50  *   Configuration c = Configuration.getConfiguration(&quot;default&quot;);
 51  *   Recording r = new Recording(c);
 52  *   r.start();
 53  *   System.gc();
 54  *   Thread.sleep(5000);
 55  *   r.stop();
 56  *   r.dump(Files.createTempFile(&quot;my-recording&quot;, &quot;.jfr&quot;));
<span class="line-modified"> 57  * }&lt;/pre&gt;</span>

 58  *
 59  * @since 9
 60  */
 61 public final class Recording implements Closeable {
 62 
 63     private static class RecordingSettings extends EventSettings {
 64 
 65         private final Recording recording;
 66         private final String identifier;
 67 
 68         RecordingSettings(Recording r, String identifier) {
 69             this.recording = r;
 70             this.identifier = identifier;
 71         }
 72 
 73         RecordingSettings(Recording r, Class&lt;? extends Event&gt; eventClass) {
 74             Utils.ensureValidEventSubclass(eventClass);
 75             this.recording = r;
 76             this.identifier = String.valueOf(Type.getTypeId(eventClass));
 77         }
</pre>
<hr />
<pre>
126      * &lt;p&gt;
127      * A newly created recording is in the {@link RecordingState#NEW} state. To start
128      * the recording, invoke the {@link Recording#start()} method.
129      *
130      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
131      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
132      *         support, or if the file repository can&#39;t be created or accessed)
133      *
134      * @throws SecurityException If a security manager is used and
135      *         FlightRecorderPermission &quot;accessFlightRecorder&quot; is not set.
136      */
137     public Recording() {
138         this(new HashMap&lt;String, String&gt;());
139      }
140 
141     /**
142      * Creates a recording with settings from a configuration.
143      * &lt;p&gt;
144      * The following example shows how create a recording that uses a predefined configuration.
145      *
<span class="line-modified">146      * &lt;pre&gt;{@literal</span>

147      * Recording r = new Recording(Configuration.getConfiguration(&quot;default&quot;));
<span class="line-modified">148      * }&lt;/pre&gt;</span>

149      *
150      * The newly created recording is in the {@link RecordingState#NEW} state. To
151      * start the recording, invoke the {@link Recording#start()} method.
152      *
153      * @param configuration configuration that contains the settings to be use, not
154      *        {@code null}
155      *
156      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
157      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
158      *         support, or if the file repository can&#39;t be created or accessed)
159      *
160      * @throws SecurityException if a security manager is used and
161      *         FlightRecorderPermission &quot;accessFlightRecorder&quot; is not set.
162      *
163      * @see Configuration
164      */
165     public Recording(Configuration configuration) {
166         this(configuration.getSettings());
167     }
168 
</pre>
<hr />
<pre>
248      *
249      * @return amount of recorded data, measured in bytes, or {@code 0} if the
250      *         recording is not written to the disk repository
251      */
252     public long getSize() {
253         return internal.getSize();
254     }
255 
256     /**
257      * Returns the time when this recording was stopped.
258      *
259      * @return the time, or {@code null} if this recording is not stopped
260      */
261     public Instant getStopTime() {
262         return internal.getStopTime();
263     }
264 
265     /**
266      * Returns the time when this recording was started.
267      *
<span class="line-modified">268      * @return the time, or {@code null} if this recording is not started</span>
269      */
270     public Instant getStartTime() {
271         return internal.getStartTime();
272     }
273 
274     /**
275      * Returns the maximum size, measured in bytes, at which data is no longer kept in the disk repository.
276      *
277      * @return maximum size in bytes, or {@code 0} if no maximum size is set
278      */
279     public long getMaxSize() {
280         return internal.getMaxSize();
281     }
282 
283     /**
284      * Returns the length of time that the data is kept in the disk repository
285      * before it is removed.
286      *
287      * @return maximum length of time, or {@code null} if no maximum length of time
288      *         has been set
</pre>
<hr />
<pre>
290     public Duration getMaxAge() {
291         return internal.getMaxAge();
292     }
293 
294     /**
295      * Returns the name of this recording.
296      * &lt;p&gt;
297      * By default, the name is the same as the recording ID.
298      *
299      * @return the recording name, not {@code null}
300      */
301     public String getName() {
302         return internal.getName();
303     }
304 
305     /**
306      * Replaces all settings for this recording.
307      * &lt;p&gt;
308      * The following example shows how to set event settings for a recording.
309      *
<span class="line-modified">310      * &lt;pre&gt;{@literal</span>
<span class="line-modified">311      *     Map&lt;String, String&gt; settings = new HashMap&lt;&gt;();</span>

312      *     settings.putAll(EventSettings.enabled(&quot;jdk.CPUSample&quot;).withPeriod(Duration.ofSeconds(2)).toMap());
313      *     settings.putAll(EventSettings.enabled(MyEvent.class).withThreshold(Duration.ofSeconds(2)).withoutStackTrace().toMap());
314      *     settings.put(&quot;jdk.ExecutionSample#period&quot;, &quot;10 ms&quot;);
315      *     recording.setSettings(settings);
<span class="line-modified">316      * }&lt;/pre&gt;</span>

317      *
318      * The following example shows how to merge settings.
319      *
<span class="line-modified">320      * &lt;pre&gt;{@literal</span>

321      *     Map&lt;String, String&gt; settings = recording.getSettings();
322      *     settings.putAll(additionalSettings);
323      *     recording.setSettings(settings);
<span class="line-modified">324      * }&lt;/pre&gt;</span>

325      *
326      * @param settings the settings to set, not {@code null}
327      */
328     public void setSettings(Map&lt;String, String&gt; settings) {
329         Objects.requireNonNull(settings);
330         Map&lt;String, String&gt; sanitized = Utils.sanitizeNullFreeStringMap(settings);
331         internal.setSettings(sanitized);
332     }
333 
334     /**
335      * Returns the recording state that this recording is currently in.
336      *
337      * @return the recording state, not {@code null}
338      *
339      * @see RecordingState
340      */
341     public RecordingState getState() {
342         return internal.getState();
343     }
344 
</pre>
<hr />
<pre>
396      * @return {@code true} if the recording uses the disk repository, {@code false}
397      *         otherwise
398      */
399     public boolean isToDisk() {
400         return internal.isToDisk();
401     }
402 
403     /**
404      * Determines how much data is kept in the disk repository.
405      * &lt;p&gt;
406      * To control the amount of recording data that is stored on disk, the maximum
407      * amount of data to retain can be specified. When the maximum limit is
408      * exceeded, the Java Virtual Machine (JVM) removes the oldest chunk to make
409      * room for a more recent chunk.
410      * &lt;p&gt;
411      * If neither maximum limit or the maximum age is set, the size of the
412      * recording may grow indefinitely.
413      *
414      * @param maxSize the amount of data to retain, {@code 0} if infinite
415      *
<span class="line-modified">416      * @throws IllegalArgumentException if {@code maxSize} is negative</span>
417      *
418      * @throws IllegalStateException if the recording is in {@code CLOSED} state
419      */
420     public void setMaxSize(long maxSize) {
421         if (maxSize &lt; 0) {
422             throw new IllegalArgumentException(&quot;Max size of recording can&#39;t be negative&quot;);
423         }
424         internal.setMaxSize(maxSize);
425     }
426 
427         /**
428          * Determines how often events are made available for streaming.
429          *
430          * @param interval the interval at which events are made available for streaming.
431          *
432          * @throws IllegalArgumentException if {@code interval} is negative
433          *
434          * @throws IllegalStateException if the recording is in the {@code CLOSED} state
435          *
436          * @since 14
</pre>
<hr />
<pre>
449      * @return the flush interval, or {@code null} if no interval has been set
450      *
451      * @since 14
452      */
453     /*package private*/ Duration getFlushInterval() {
454         return internal.getFlushInterval();
455     }
456 
457     /**
458      * Determines how far back data is kept in the disk repository.
459      * &lt;p&gt;
460      * To control the amount of recording data stored on disk, the maximum length of
461      * time to retain the data can be specified. Data stored on disk that is older
462      * than the specified length of time is removed by the Java Virtual Machine (JVM).
463      * &lt;p&gt;
464      * If neither maximum limit or the maximum age is set, the size of the
465      * recording may grow indefinitely.
466      *
467      * @param maxAge the length of time that data is kept, or {@code null} if infinite
468      *
<span class="line-modified">469      * @throws IllegalArgumentException if {@code maxAge} is negative</span>
470      *
471      * @throws IllegalStateException if the recording is in the {@code CLOSED} state
472      */
473     public void setMaxAge(Duration maxAge) {
474         if (maxAge != null &amp;&amp; maxAge.isNegative()) {
475             throw new IllegalArgumentException(&quot;Max age of recording can&#39;t be negative&quot;);
476         }
477         internal.setMaxAge(maxAge);
478     }
479 
480     /**
481      * Sets a location where data is written on recording stop, or
482      * {@code null} if data is not to be dumped.
483      * &lt;p&gt;
484      * If a destination is set, this recording is automatically closed
485      * after data is successfully copied to the destination path.
486      * &lt;p&gt;
487      * If a destination is &lt;em&gt;not&lt;/em&gt; set, Flight Recorder retains the
488      * recording data until this recording is closed. Use the {@link #dump(Path)} method to
489      * manually write data to a file.
</pre>
<hr />
<pre>
561         return internal.getDumpOnExit();
562     }
563 
564     /**
565      * Determines whether this recording is continuously flushed to the disk
566      * repository or data is constrained to what is available in memory buffers.
567      *
568      * @param disk {@code true} if this recording is written to disk,
569      *        {@code false} if in-memory
570      *
571      */
572     public void setToDisk(boolean disk) {
573         internal.setToDisk(disk);
574     }
575 
576     /**
577      * Creates a data stream for a specified interval.
578      * &lt;p&gt;
579      * The stream may contain some data outside the specified range.
580      *
<span class="line-modified">581      * @param start the start time for the stream, or {@code null} to get data from</span>
582      *        start time of the recording
583      *
<span class="line-modified">584      * @param end the end time for the stream, or {@code null} to get data until the</span>
585      *        present time.
586      *
587      * @return an input stream, or {@code null} if no data is available in the
588      *         interval.
589      *
590      * @throws IllegalArgumentException if {@code end} happens before
591      *         {@code start}
592      *
593      * @throws IOException if a stream can&#39;t be opened
594      */
595     public InputStream getStream(Instant start, Instant end) throws IOException {
596         if (start != null &amp;&amp; end != null &amp;&amp; end.isBefore(start)) {
597             throw new IllegalArgumentException(&quot;End time of requested stream must not be before start time&quot;);
598         }
599         return internal.open(start, end);
600     }
601 
602     /**
603      * Returns the specified duration for this recording, or {@code null} if no
604      * duration is set.
</pre>
</td>
</tr>
</table>
<center><a href="Period.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="RecordingState.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
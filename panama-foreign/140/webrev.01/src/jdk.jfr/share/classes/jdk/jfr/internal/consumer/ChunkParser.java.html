<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/ChunkParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.IOException;
 29 import java.util.Collection;
 30 import java.util.List;
 31 import java.util.StringJoiner;
 32 
 33 import jdk.jfr.EventType;
 34 import jdk.jfr.consumer.RecordedEvent;
 35 import jdk.jfr.consumer.RecordedObject;
 36 import jdk.jfr.internal.LogLevel;
 37 import jdk.jfr.internal.LogTag;
 38 import jdk.jfr.internal.Logger;
 39 import jdk.jfr.internal.LongMap;
 40 import jdk.jfr.internal.MetadataDescriptor;
 41 import jdk.jfr.internal.Type;
 42 import jdk.jfr.internal.Utils;
 43 
 44 /**
 45  * Parses a chunk.
 46  *
 47  */
 48 public final class ChunkParser {
 49 
 50     static final class ParserConfiguration {
 51         private final boolean reuse;
 52         private final boolean ordered;
 53         private final ParserFilter eventFilter;
 54 
 55         long filterStart;
 56         long filterEnd;
 57 
 58         ParserConfiguration(long filterStart, long filterEnd, boolean reuse, boolean ordered, ParserFilter filter) {
 59             this.filterStart = filterStart;
 60             this.filterEnd = filterEnd;
 61             this.reuse = reuse;
 62             this.ordered = ordered;
 63             this.eventFilter = filter;
 64         }
 65 
 66         public ParserConfiguration() {
 67             this(0, Long.MAX_VALUE, false, false, ParserFilter.ACCEPT_ALL);
 68         }
 69 
 70         public boolean isOrdered() {
 71             return ordered;
 72         }
 73     }
 74 
 75     private enum CheckPointType {
 76         // Checkpoint that finishes a flush segment
 77         FLUSH(1),
 78         // Checkpoint contains chunk header information in the first pool
 79         CHUNK_HEADER(2),
 80         // Checkpoint contains only statics that will not change from chunk to chunk
 81         STATICS(4),
 82         // Checkpoint contains thread related information
 83         THREAD(8);
 84         private final int mask;
 85         private CheckPointType(int mask) {
 86             this.mask = mask;
 87         }
 88 
 89         private boolean is(int flags) {
 90             return (mask &amp; flags) != 0;
 91         }
 92     }
 93 
 94     private static final long CONSTANT_POOL_TYPE_ID = 1;
 95     private static final String CHUNKHEADER = &quot;jdk.types.ChunkHeader&quot;;
 96     private final RecordingInput input;
 97     private final ChunkHeader chunkHeader;
 98     private final MetadataDescriptor metadata;
 99     private final TimeConverter timeConverter;
100     private final MetadataDescriptor previousMetadata;
101     private final LongMap&lt;ConstantLookup&gt; constantLookups;
102 
103     private LongMap&lt;Type&gt; typeMap;
104     private LongMap&lt;Parser&gt; parsers;
105     private boolean chunkFinished;
106 
107     private Runnable flushOperation;
108     private ParserConfiguration configuration;
109     private volatile boolean closed;
110 
111     public ChunkParser(RecordingInput input) throws IOException {
112         this(input, new ParserConfiguration());
113     }
114 
115     ChunkParser(RecordingInput input, ParserConfiguration pc) throws IOException {
116        this(new ChunkHeader(input), null, pc);
117     }
118 
119     private ChunkParser(ChunkParser previous) throws IOException {
120         this(new ChunkHeader(previous.input), previous, new ParserConfiguration());
121      }
122 
123     private ChunkParser(ChunkHeader header, ChunkParser previous, ParserConfiguration pc) throws IOException {
124         this.configuration = pc;
125         this.input = header.getInput();
126         this.chunkHeader = header;
127         if (previous == null) {
128             this.constantLookups = new LongMap&lt;&gt;();
129             this.previousMetadata = null;
130         } else {
131             this.constantLookups = previous.constantLookups;
132             this.previousMetadata = previous.metadata;
133             this.configuration = previous.configuration;
134         }
135         this.metadata = header.readMetadata(previousMetadata);
136         this.timeConverter = new TimeConverter(chunkHeader, metadata.getGMTOffset());
137         if (metadata != previousMetadata) {
138             ParserFactory factory = new ParserFactory(metadata, constantLookups, timeConverter);
139             parsers = factory.getParsers();
140             typeMap = factory.getTypeMap();
141             updateConfiguration();
142         } else {
143             parsers = previous.parsers;
144             typeMap = previous.typeMap;
145         }
146         constantLookups.forEach(c -&gt; c.newPool());
147         fillConstantPools(0);
148         constantLookups.forEach(c -&gt; c.getLatestPool().setResolving());
149         constantLookups.forEach(c -&gt; c.getLatestPool().resolve());
150         constantLookups.forEach(c -&gt; c.getLatestPool().setResolved());
151 
152         input.position(chunkHeader.getEventStart());
153     }
154 
155     public ChunkParser nextChunkParser() throws IOException {
156         return new ChunkParser(chunkHeader.nextHeader(), this, configuration);
157     }
158 
159     private void updateConfiguration() {
160         updateConfiguration(configuration, false);
161     }
162 
163     void updateConfiguration(ParserConfiguration configuration, boolean resetEventCache) {
164         this.configuration = configuration;
165         parsers.forEach(p -&gt; {
166             if (p instanceof EventParser) {
167                 EventParser ep = (EventParser) p;
168                 if (resetEventCache) {
169                     ep.resetCache();
170                 }
171                 String name = ep.getEventType().getName();
172                 ep.setOrdered(configuration.ordered);
173                 ep.setReuse(configuration.reuse);
174                 ep.setFilterStart(configuration.filterStart);
175                 ep.setFilterEnd(configuration.filterEnd);
176                 long threshold = configuration.eventFilter.getThreshold(name);
177                 if (threshold &gt;= 0) {
178                     ep.setEnabled(true);
179                     ep.setThresholdNanos(threshold);
180                 } else {
181                     ep.setEnabled(false);
182                     ep.setThresholdNanos(Long.MAX_VALUE);
183                 }
184             }
185         });
186     }
187 
188     /**
189      * Reads an event and returns null when segment or chunk ends.
190      */
191     RecordedEvent readStreamingEvent() throws IOException {
192         long absoluteChunkEnd = chunkHeader.getEnd();
193         RecordedEvent event = readEvent();
194         if (event != null) {
195             return event;
196         }
197         long lastValid = absoluteChunkEnd;
198         long metadataPosition = chunkHeader.getMetataPosition();
199         long constantPosition = chunkHeader.getConstantPoolPosition();
200         chunkFinished = awaitUpdatedHeader(absoluteChunkEnd, configuration.filterEnd);
201         if (chunkFinished) {
202             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;At chunk end&quot;);
203             return null;
204         }
205         absoluteChunkEnd = chunkHeader.getEnd();
206         // Read metadata and constant pools for the next segment
207         if (chunkHeader.getMetataPosition() != metadataPosition) {
208             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Found new metadata in chunk. Rebuilding types and parsers&quot;);
209             MetadataDescriptor metadata = chunkHeader.readMetadata(previousMetadata);
210             ParserFactory factory = new ParserFactory(metadata, constantLookups, timeConverter);
211             parsers = factory.getParsers();
212             typeMap = factory.getTypeMap();
213             updateConfiguration();
214         }
215         if (constantPosition != chunkHeader.getConstantPoolPosition()) {
216             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Found new constant pool data. Filling up pools with new values&quot;);
217             constantLookups.forEach(c -&gt; c.getLatestPool().setAllResolved(false));
218             fillConstantPools(constantPosition + chunkHeader.getAbsoluteChunkStart());
219             constantLookups.forEach(c -&gt; c.getLatestPool().setResolving());
220             constantLookups.forEach(c -&gt; c.getLatestPool().resolve());
221             constantLookups.forEach(c -&gt; c.getLatestPool().setResolved());
222         }
223         input.position(lastValid);
224         return null;
225     }
226 
227     /**
228      * Reads an event and returns null when the chunk ends
229      */
230     public RecordedEvent readEvent() throws IOException {
231         long absoluteChunkEnd = chunkHeader.getEnd();
232         while (input.position() &lt; absoluteChunkEnd) {
233             long pos = input.position();
234             int size = input.readInt();
235             if (size == 0) {
236                 throw new IOException(&quot;Event can&#39;t have zero size&quot;);
237             }
238             long typeId = input.readLong();
239             Parser p = parsers.get(typeId);
240             if (p instanceof EventParser) {
241                 // Fast path
242                 EventParser ep = (EventParser) p;
243                 RecordedEvent event = ep.parse(input);
244                 if (event != null) {
245                     input.position(pos + size);
246                     return event;
247                 }
248                 // Not accepted by filter
249             } else {
250                 if (typeId == 1) { // checkpoint event
251                     if (flushOperation != null) {
252                         parseCheckpoint();
253                     }
254                 } else {
255                     if (typeId != 0) { // Not metadata event
256                         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Unknown event type &quot; + typeId);
257                     }
258                 }
259             }
260             input.position(pos + size);
261         }
262         return null;
263     }
264 
265     private void parseCheckpoint() throws IOException {
266         // Content has been parsed previously. This
267         // is to trigger flush
268         input.readLong(); // timestamp
269         input.readLong(); // duration
270         input.readLong(); // delta
271         byte typeFlags = input.readByte();
272         if (CheckPointType.FLUSH.is(typeFlags)) {
273             flushOperation.run();
274         }
275     }
276 
277     private boolean awaitUpdatedHeader(long absoluteChunkEnd, long filterEnd) throws IOException {
278         if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO)) {
279             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Waiting for more data (streaming). Read so far: &quot; + chunkHeader.getChunkSize() + &quot; bytes&quot;);
280         }
281         while (true) {
282             if (closed) {
283                 return true;
284             }
285             if (chunkHeader.getLastNanos() &gt; filterEnd)  {
286               return true;
287             }
288             chunkHeader.refresh();
289             if (absoluteChunkEnd != chunkHeader.getEnd()) {
290                 return false;
291             }
292             if (chunkHeader.isFinished()) {
293                 return true;
294             }
295             Utils.waitFlush(1000);
296         }
297     }
298 
299     private void fillConstantPools(long abortCP) throws IOException {
300         long thisCP = chunkHeader.getConstantPoolPosition() + chunkHeader.getAbsoluteChunkStart();
301         long lastCP = -1;
302         long delta = -1;
303         boolean logTrace = Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE);
304         while (thisCP != abortCP &amp;&amp; delta != 0) {
305             input.position(thisCP);
306             lastCP = thisCP;
307             int size = input.readInt(); // size
308             long typeId = input.readLong();
309             if (typeId != CONSTANT_POOL_TYPE_ID) {
310                 throw new IOException(&quot;Expected check point event (id = 1) at position &quot; + lastCP + &quot;, but found type id = &quot; + typeId);
311             }
312             input.readLong(); // timestamp
313             input.readLong(); // duration
314             delta = input.readLong();
315             thisCP += delta;
316             boolean flush = input.readBoolean();
317             int poolCount = input.readInt();
318             final long logLastCP = lastCP;
319             final long logDelta = delta;
320             if (logTrace) {
321                 Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, () -&gt; {
322                     return &quot;New constant pool: startPosition=&quot; + logLastCP + &quot;, size=&quot; + size + &quot;, deltaToNext=&quot; + logDelta + &quot;, flush=&quot; + flush + &quot;, poolCount=&quot; + poolCount;
323                 });
324             }
325             for (int i = 0; i &lt; poolCount; i++) {
326                 long id = input.readLong(); // type id
327                 ConstantLookup lookup = constantLookups.get(id);
328                 Type type = typeMap.get(id);
329                 if (lookup == null) {
330                     if (type == null) {
331                         throw new IOException(
332                                 &quot;Error parsing constant pool type &quot; + getName(id) + &quot; at position &quot; + input.position() + &quot; at check point between [&quot; + lastCP + &quot;, &quot; + lastCP + size + &quot;]&quot;);
333                     }
334                     if (type.getName() != CHUNKHEADER) {
335                         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Found constant pool(&quot; + id + &quot;) that is never used&quot;);
336                     }
337                     ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type.getName());
338                     lookup = new ConstantLookup(pool, type);
339                     constantLookups.put(type.getId(), lookup);
340                 }
341                 Parser parser = parsers.get(id);
342                 if (parser == null) {
343                     throw new IOException(&quot;Could not find constant pool type with id = &quot; + id);
344                 }
345                 try {
346                     int count = input.readInt();
347                     if (count == 0) {
348                         throw new InternalError(&quot;Pool &quot; + type.getName() + &quot; must contain at least one element &quot;);
349                     }
350                     if (logTrace) {
351                         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, &quot;Constant Pool &quot; + i + &quot;: &quot; + type.getName());
352                     }
353                     for (int j = 0; j &lt; count; j++) {
354                         long key = input.readLong();
355                         Object resolved = lookup.getPreviousResolved(key);
356                         if (resolved == null) {
357                             Object v = parser.parse(input);
358                             logConstant(key, v, false);
359                             lookup.getLatestPool().put(key, v);
360                         } else {
361                             parser.skip(input);
362                             logConstant(key, resolved, true);
363                             lookup.getLatestPool().putResolved(key, resolved);
364                         }
365                     }
366                 } catch (Exception e) {
367                     throw new IOException(&quot;Error parsing constant pool type &quot; + getName(id) + &quot; at position &quot; + input.position() + &quot; at check point between [&quot; + lastCP + &quot;, &quot; + lastCP + size + &quot;]&quot;,
368                             e);
369                 }
370             }
371             if (input.position() != lastCP + size) {
372                 throw new IOException(&quot;Size of check point event doesn&#39;t match content&quot;);
373             }
374         }
375     }
376 
377     private void logConstant(long key, Object v, boolean preresolved) {
378         if (!Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE)) {
379             return;
380         }
381         String valueText;
382         if (v.getClass().isArray()) {
383             Object[] array = (Object[]) v;
384             StringJoiner sj = new StringJoiner(&quot;, &quot;, &quot;{&quot;, &quot;}&quot;);
385             for (int i = 0; i &lt; array.length; i++) {
386                 sj.add(textify(array[i]));
387             }
388             valueText = sj.toString();
389         } else {
390             valueText = textify(v);
391         }
392         String suffix  = preresolved ? &quot; (presolved)&quot; :&quot;&quot;;
393         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, &quot;Constant: &quot; + key + &quot; = &quot; + valueText + suffix);
394     }
395 
396     private String textify(Object o) {
397         if (o == null) { // should not happen
398             return &quot;null&quot;;
399         }
400         if (o instanceof String) {
401             return &quot;\&quot;&quot; + String.valueOf(o) + &quot;\&quot;&quot;;
402         }
403         if (o instanceof RecordedObject) {
404             return o.getClass().getName();
405         }
406         if (o.getClass().isArray()) {
407             Object[] array = (Object[]) o;
408             if (array.length &gt; 0) {
409                 return textify(array[0]) + &quot;[]&quot;; // can it be recursive?
410             }
411         }
412         return String.valueOf(o);
413     }
414 
415     private String getName(long id) {
416         Type type = typeMap.get(id);
417         return type == null ? (&quot;unknown(&quot; + id + &quot;)&quot;) : type.getName();
418     }
419 
420     public Collection&lt;Type&gt; getTypes() {
421         return metadata.getTypes();
422     }
423 
424     public List&lt;EventType&gt; getEventTypes() {
425         return metadata.getEventTypes();
426     }
427 
428     public boolean isLastChunk() throws IOException {
429         return chunkHeader.isLastChunk();
430     }
431 
432     ChunkParser newChunkParser() throws IOException {
433         return new ChunkParser(this);
434     }
435 
436     public boolean isChunkFinished() {
437         return chunkFinished;
438     }
439 
440     public void setFlushOperation(Runnable flushOperation) {
441         this.flushOperation = flushOperation;
442     }
443 
444     public long getChunkDuration() {
445         return chunkHeader.getDurationNanos();
446     }
447 
448     public long getStartNanos() {
449         return chunkHeader.getStartNanos();
450     }
451 
452     public boolean isFinalChunk() {
453         return chunkHeader.isFinalChunk();
454     }
455 
456     public void close() {
457         this.closed = true;
458         Utils.notifyFlush();
459     }
460 
461 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformRecorder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PrivateAccess.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 66     private long maxSize;
 67 
 68     private WriteableUserPath destination;
 69 
 70     private boolean toDisk = true;
 71     private String name;
 72     private boolean dumpOnExit;
 73     private SafePath dumpOnExitDirectory = new SafePath(&quot;.&quot;);
 74     // Timestamp information
 75     private Instant stopTime;
 76     private Instant startTime;
 77 
 78     // Misc, information
 79     private RecordingState state = RecordingState.NEW;
 80     private long size;
 81     private final LinkedList&lt;RepositoryChunk&gt; chunks = new LinkedList&lt;&gt;();
 82     private volatile Recording recording;
 83     private TimerTask stopTask;
 84     private TimerTask startTask;
 85     private AccessControlContext noDestinationDumpOnExitAccessControlContext;
<span class="line-modified"> 86     private boolean shuoldWriteActiveRecordingEvent = true;</span>
 87     private Duration flushInterval = Duration.ofSeconds(1);
 88     private long finalStartChunkNanos = Long.MIN_VALUE;
 89 
 90     PlatformRecording(PlatformRecorder recorder, long id) {
 91         // Typically the access control context is taken
<span class="line-modified"> 92         // when you call dump(Path) or setDdestination(Path),</span>
<span class="line-modified"> 93         // but if no destination is set and dumponexit=true</span>
 94         // the control context of the recording is taken when the
 95         // Recording object is constructed. This works well for
 96         // -XX:StartFlightRecording and JFR.dump
 97         this.noDestinationDumpOnExitAccessControlContext = AccessController.getContext();
 98         this.id = id;
 99         this.recorder = recorder;
100         this.name = String.valueOf(id);
101     }
102 
103     public long start() {
104         RecordingState oldState;
105         RecordingState newState;
106         long startNanos = -1;
107         synchronized (recorder) {
108             oldState = getState();
109             if (!Utils.isBefore(state, RecordingState.RUNNING)) {
110                 throw new IllegalStateException(&quot;Recording can only be started once.&quot;);
111             }
112             if (startTask != null) {
113                 startTask.cancel();
</pre>
<hr />
<pre>
186         synchronized (recorder) {
187             ensureOkForSchedule();
188 
189             startTime = Instant.now().plus(delay);
190             LocalDateTime now = LocalDateTime.now().plus(delay);
191             setState(RecordingState.DELAYED);
192             startTask = createStartTask();
193             try {
194                 recorder.getTimer().schedule(startTask, delay.toMillis());
195                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Scheduled recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to start at &quot; + now);
196             } catch (IllegalStateException ise) {
197                 // This can happen in the unlikely case that a recording
198                 // is scheduled after the Timer has been cancelled in
199                 // the shutdown hook. Just ignore.
200             }
201         }
202     }
203 
204     private void ensureOkForSchedule() {
205         if (getState() != RecordingState.NEW) {
<span class="line-modified">206             throw new IllegalStateException(&quot;Only a new recoridng can be scheduled for start&quot;);</span>
207         }
208     }
209 
210     private TimerTask createStartTask() {
211         // Taking ref. to recording here.
212         // Opens up for memory leaks.
213         return new TimerTask() {
214             @Override
215             public void run() {
216                 synchronized (recorder) {
217                     if (getState() != RecordingState.DELAYED) {
218                         return;
219                     }
220                     start();
221                 }
222             }
223         };
224     }
225 
226     void scheduleStart(Instant startTime) {
</pre>
<hr />
<pre>
665 
666     public Recording newCopy(boolean stop) {
667         return recorder.newCopy(this, stop);
668     }
669 
670     void setStopTask(TimerTask stopTask) {
671         synchronized (recorder) {
672             this.stopTask = stopTask;
673         }
674     }
675 
676     void clearDestination() {
677         destination = null;
678     }
679 
680     public AccessControlContext getNoDestinationDumpOnExitAccessControlContext() {
681         return noDestinationDumpOnExitAccessControlContext;
682     }
683 
684     void setShouldWriteActiveRecordingEvent(boolean shouldWrite) {
<span class="line-modified">685         this.shuoldWriteActiveRecordingEvent = shouldWrite;</span>
686     }
687 
688     boolean shouldWriteMetadataEvent() {
<span class="line-modified">689         return shuoldWriteActiveRecordingEvent;</span>
690     }
691 
692     // Dump running and stopped recordings
693     public void dump(WriteableUserPath writeableUserPath) throws IOException {
694         synchronized (recorder) {
695             try(PlatformRecording p = newSnapshotClone(&quot;Dumped by user&quot;, null))  {
696                 p.dumpStopped(writeableUserPath);
697             }
698         }
699     }
700 
701     public void dumpStopped(WriteableUserPath userPath) throws IOException {
702         synchronized (recorder) {
<span class="line-modified">703                 userPath.doPriviligedIO(() -&gt; {</span>
704                     try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
705                         cc.transferTo(fc);
706                         fc.force(true);
707                     }
708                     return null;
709                 });
710         }
711     }
712 
713     public void filter(Instant begin, Instant end, Long maxSize) {
714         synchronized (recorder) {
715             List&lt;RepositoryChunk&gt; result = removeAfter(end, removeBefore(begin, new ArrayList&lt;&gt;(chunks)));
716             if (maxSize != null) {
717                 if (begin != null &amp;&amp; end == null) {
718                     result = reduceFromBeginning(maxSize, result);
719                 } else {
720                     result = reduceFromEnd(maxSize, result);
721                 }
722             }
723             int size = 0;
</pre>
</td>
<td>
<hr />
<pre>
 66     private long maxSize;
 67 
 68     private WriteableUserPath destination;
 69 
 70     private boolean toDisk = true;
 71     private String name;
 72     private boolean dumpOnExit;
 73     private SafePath dumpOnExitDirectory = new SafePath(&quot;.&quot;);
 74     // Timestamp information
 75     private Instant stopTime;
 76     private Instant startTime;
 77 
 78     // Misc, information
 79     private RecordingState state = RecordingState.NEW;
 80     private long size;
 81     private final LinkedList&lt;RepositoryChunk&gt; chunks = new LinkedList&lt;&gt;();
 82     private volatile Recording recording;
 83     private TimerTask stopTask;
 84     private TimerTask startTask;
 85     private AccessControlContext noDestinationDumpOnExitAccessControlContext;
<span class="line-modified"> 86     private boolean shouldWriteActiveRecordingEvent = true;</span>
 87     private Duration flushInterval = Duration.ofSeconds(1);
 88     private long finalStartChunkNanos = Long.MIN_VALUE;
 89 
 90     PlatformRecording(PlatformRecorder recorder, long id) {
 91         // Typically the access control context is taken
<span class="line-modified"> 92         // when you call dump(Path) or setDestination(Path),</span>
<span class="line-modified"> 93         // but if no destination is set and dumpOnExit=true</span>
 94         // the control context of the recording is taken when the
 95         // Recording object is constructed. This works well for
 96         // -XX:StartFlightRecording and JFR.dump
 97         this.noDestinationDumpOnExitAccessControlContext = AccessController.getContext();
 98         this.id = id;
 99         this.recorder = recorder;
100         this.name = String.valueOf(id);
101     }
102 
103     public long start() {
104         RecordingState oldState;
105         RecordingState newState;
106         long startNanos = -1;
107         synchronized (recorder) {
108             oldState = getState();
109             if (!Utils.isBefore(state, RecordingState.RUNNING)) {
110                 throw new IllegalStateException(&quot;Recording can only be started once.&quot;);
111             }
112             if (startTask != null) {
113                 startTask.cancel();
</pre>
<hr />
<pre>
186         synchronized (recorder) {
187             ensureOkForSchedule();
188 
189             startTime = Instant.now().plus(delay);
190             LocalDateTime now = LocalDateTime.now().plus(delay);
191             setState(RecordingState.DELAYED);
192             startTask = createStartTask();
193             try {
194                 recorder.getTimer().schedule(startTask, delay.toMillis());
195                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Scheduled recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to start at &quot; + now);
196             } catch (IllegalStateException ise) {
197                 // This can happen in the unlikely case that a recording
198                 // is scheduled after the Timer has been cancelled in
199                 // the shutdown hook. Just ignore.
200             }
201         }
202     }
203 
204     private void ensureOkForSchedule() {
205         if (getState() != RecordingState.NEW) {
<span class="line-modified">206             throw new IllegalStateException(&quot;Only a new recording can be scheduled for start&quot;);</span>
207         }
208     }
209 
210     private TimerTask createStartTask() {
211         // Taking ref. to recording here.
212         // Opens up for memory leaks.
213         return new TimerTask() {
214             @Override
215             public void run() {
216                 synchronized (recorder) {
217                     if (getState() != RecordingState.DELAYED) {
218                         return;
219                     }
220                     start();
221                 }
222             }
223         };
224     }
225 
226     void scheduleStart(Instant startTime) {
</pre>
<hr />
<pre>
665 
666     public Recording newCopy(boolean stop) {
667         return recorder.newCopy(this, stop);
668     }
669 
670     void setStopTask(TimerTask stopTask) {
671         synchronized (recorder) {
672             this.stopTask = stopTask;
673         }
674     }
675 
676     void clearDestination() {
677         destination = null;
678     }
679 
680     public AccessControlContext getNoDestinationDumpOnExitAccessControlContext() {
681         return noDestinationDumpOnExitAccessControlContext;
682     }
683 
684     void setShouldWriteActiveRecordingEvent(boolean shouldWrite) {
<span class="line-modified">685         this.shouldWriteActiveRecordingEvent = shouldWrite;</span>
686     }
687 
688     boolean shouldWriteMetadataEvent() {
<span class="line-modified">689         return shouldWriteActiveRecordingEvent;</span>
690     }
691 
692     // Dump running and stopped recordings
693     public void dump(WriteableUserPath writeableUserPath) throws IOException {
694         synchronized (recorder) {
695             try(PlatformRecording p = newSnapshotClone(&quot;Dumped by user&quot;, null))  {
696                 p.dumpStopped(writeableUserPath);
697             }
698         }
699     }
700 
701     public void dumpStopped(WriteableUserPath userPath) throws IOException {
702         synchronized (recorder) {
<span class="line-modified">703                 userPath.doPrivilegedIO(() -&gt; {</span>
704                     try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
705                         cc.transferTo(fc);
706                         fc.force(true);
707                     }
708                     return null;
709                 });
710         }
711     }
712 
713     public void filter(Instant begin, Instant end, Long maxSize) {
714         synchronized (recorder) {
715             List&lt;RepositoryChunk&gt; result = removeAfter(end, removeBefore(begin, new ArrayList&lt;&gt;(chunks)));
716             if (maxSize != null) {
717                 if (begin != null &amp;&amp; end == null) {
718                     result = reduceFromBeginning(maxSize, result);
719                 } else {
720                     result = reduceFromEnd(maxSize, result);
721                 }
722             }
723             int size = 0;
</pre>
</td>
</tr>
</table>
<center><a href="PlatformRecorder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PrivateAccess.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
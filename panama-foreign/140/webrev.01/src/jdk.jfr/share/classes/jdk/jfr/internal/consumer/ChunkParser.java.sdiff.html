<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/ChunkParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../WriteableUserPath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ConstantMap.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/ChunkParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
170                 }
171                 String name = ep.getEventType().getName();
172                 ep.setOrdered(configuration.ordered);
173                 ep.setReuse(configuration.reuse);
174                 ep.setFilterStart(configuration.filterStart);
175                 ep.setFilterEnd(configuration.filterEnd);
176                 long threshold = configuration.eventFilter.getThreshold(name);
177                 if (threshold &gt;= 0) {
178                     ep.setEnabled(true);
179                     ep.setThresholdNanos(threshold);
180                 } else {
181                     ep.setEnabled(false);
182                     ep.setThresholdNanos(Long.MAX_VALUE);
183                 }
184             }
185         });
186     }
187 
188     /**
189      * Reads an event and returns null when segment or chunk ends.
<span class="line-removed">190      *</span>
<span class="line-removed">191      * @param awaitNewEvents wait for new data.</span>
192      */
193     RecordedEvent readStreamingEvent() throws IOException {
194         long absoluteChunkEnd = chunkHeader.getEnd();
195         RecordedEvent event = readEvent();
196         if (event != null) {
197             return event;
198         }
199         long lastValid = absoluteChunkEnd;
200         long metadataPosition = chunkHeader.getMetataPosition();
<span class="line-modified">201         long contantPosition = chunkHeader.getConstantPoolPosition();</span>
202         chunkFinished = awaitUpdatedHeader(absoluteChunkEnd, configuration.filterEnd);
203         if (chunkFinished) {
204             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;At chunk end&quot;);
205             return null;
206         }
207         absoluteChunkEnd = chunkHeader.getEnd();
208         // Read metadata and constant pools for the next segment
209         if (chunkHeader.getMetataPosition() != metadataPosition) {
210             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Found new metadata in chunk. Rebuilding types and parsers&quot;);
211             MetadataDescriptor metadata = chunkHeader.readMetadata(previousMetadata);
212             ParserFactory factory = new ParserFactory(metadata, constantLookups, timeConverter);
213             parsers = factory.getParsers();
214             typeMap = factory.getTypeMap();
215             updateConfiguration();
216         }
<span class="line-modified">217         if (contantPosition != chunkHeader.getConstantPoolPosition()) {</span>
218             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Found new constant pool data. Filling up pools with new values&quot;);
219             constantLookups.forEach(c -&gt; c.getLatestPool().setAllResolved(false));
<span class="line-modified">220             fillConstantPools(contantPosition + chunkHeader.getAbsoluteChunkStart());</span>
221             constantLookups.forEach(c -&gt; c.getLatestPool().setResolving());
222             constantLookups.forEach(c -&gt; c.getLatestPool().resolve());
223             constantLookups.forEach(c -&gt; c.getLatestPool().setResolved());
224         }
225         input.position(lastValid);
226         return null;
227     }
228 
229     /**
230      * Reads an event and returns null when the chunk ends
231      */
232     public RecordedEvent readEvent() throws IOException {
233         long absoluteChunkEnd = chunkHeader.getEnd();
234         while (input.position() &lt; absoluteChunkEnd) {
235             long pos = input.position();
236             int size = input.readInt();
237             if (size == 0) {
238                 throw new IOException(&quot;Event can&#39;t have zero size&quot;);
239             }
240             long typeId = input.readLong();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
170                 }
171                 String name = ep.getEventType().getName();
172                 ep.setOrdered(configuration.ordered);
173                 ep.setReuse(configuration.reuse);
174                 ep.setFilterStart(configuration.filterStart);
175                 ep.setFilterEnd(configuration.filterEnd);
176                 long threshold = configuration.eventFilter.getThreshold(name);
177                 if (threshold &gt;= 0) {
178                     ep.setEnabled(true);
179                     ep.setThresholdNanos(threshold);
180                 } else {
181                     ep.setEnabled(false);
182                     ep.setThresholdNanos(Long.MAX_VALUE);
183                 }
184             }
185         });
186     }
187 
188     /**
189      * Reads an event and returns null when segment or chunk ends.


190      */
191     RecordedEvent readStreamingEvent() throws IOException {
192         long absoluteChunkEnd = chunkHeader.getEnd();
193         RecordedEvent event = readEvent();
194         if (event != null) {
195             return event;
196         }
197         long lastValid = absoluteChunkEnd;
198         long metadataPosition = chunkHeader.getMetataPosition();
<span class="line-modified">199         long constantPosition = chunkHeader.getConstantPoolPosition();</span>
200         chunkFinished = awaitUpdatedHeader(absoluteChunkEnd, configuration.filterEnd);
201         if (chunkFinished) {
202             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;At chunk end&quot;);
203             return null;
204         }
205         absoluteChunkEnd = chunkHeader.getEnd();
206         // Read metadata and constant pools for the next segment
207         if (chunkHeader.getMetataPosition() != metadataPosition) {
208             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Found new metadata in chunk. Rebuilding types and parsers&quot;);
209             MetadataDescriptor metadata = chunkHeader.readMetadata(previousMetadata);
210             ParserFactory factory = new ParserFactory(metadata, constantLookups, timeConverter);
211             parsers = factory.getParsers();
212             typeMap = factory.getTypeMap();
213             updateConfiguration();
214         }
<span class="line-modified">215         if (constantPosition != chunkHeader.getConstantPoolPosition()) {</span>
216             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Found new constant pool data. Filling up pools with new values&quot;);
217             constantLookups.forEach(c -&gt; c.getLatestPool().setAllResolved(false));
<span class="line-modified">218             fillConstantPools(constantPosition + chunkHeader.getAbsoluteChunkStart());</span>
219             constantLookups.forEach(c -&gt; c.getLatestPool().setResolving());
220             constantLookups.forEach(c -&gt; c.getLatestPool().resolve());
221             constantLookups.forEach(c -&gt; c.getLatestPool().setResolved());
222         }
223         input.position(lastValid);
224         return null;
225     }
226 
227     /**
228      * Reads an event and returns null when the chunk ends
229      */
230     public RecordedEvent readEvent() throws IOException {
231         long absoluteChunkEnd = chunkHeader.getEnd();
232         while (input.position() &lt; absoluteChunkEnd) {
233             long pos = input.position();
234             int size = input.readInt();
235             if (size == 0) {
236                 throw new IOException(&quot;Event can&#39;t have zero size&quot;);
237             }
238             long typeId = input.readLong();
</pre>
</td>
</tr>
</table>
<center><a href="../WriteableUserPath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ConstantMap.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
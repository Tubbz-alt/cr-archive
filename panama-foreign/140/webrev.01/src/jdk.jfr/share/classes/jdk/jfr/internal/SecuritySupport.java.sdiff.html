<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="RequestEngine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Type.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 60 import java.util.concurrent.Callable;
 61 
 62 import jdk.internal.misc.Unsafe;
 63 import jdk.internal.module.Modules;
 64 import jdk.jfr.Event;
 65 import jdk.jfr.FlightRecorder;
 66 import jdk.jfr.FlightRecorderListener;
 67 import jdk.jfr.FlightRecorderPermission;
 68 import jdk.jfr.Recording;
 69 import jdk.jfr.internal.consumer.FileAccess;
 70 
 71 /**
 72  * Contains JFR code that does
 73  * {@link AccessController#doPrivileged(PrivilegedAction)}
 74  */
 75 public final class SecuritySupport {
 76     private final static Unsafe unsafe = Unsafe.getUnsafe();
 77     private final static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
 78     private final static Module JFR_MODULE = Event.class.getModule();
 79     public  final static SafePath JFC_DIRECTORY = getPathInProperty(&quot;java.home&quot;, &quot;lib/jfr&quot;);
<span class="line-modified"> 80     public final static FileAccess PRIVILIGED = new Privileged();</span>
 81     static final SafePath USER_HOME = getPathInProperty(&quot;user.home&quot;, null);
 82     static final SafePath JAVA_IO_TMPDIR = getPathInProperty(&quot;java.io.tmpdir&quot;, null);
 83 
 84     static {
 85         // ensure module java.base can read module jdk.jfr as early as possible
 86         addReadEdge(Object.class);
 87         addHandlerExport(Object.class);
 88         addEventsExport(Object.class);
 89         addInstrumentExport(Object.class);
 90     }
 91 
 92     final static class SecureRecorderListener implements FlightRecorderListener {
 93 
 94         private final AccessControlContext context;
 95         private final FlightRecorderListener changeListener;
 96 
 97         SecureRecorderListener(AccessControlContext context, FlightRecorderListener changeListener) {
 98             this.context = Objects.requireNonNull(context);
 99             this.changeListener = Objects.requireNonNull(changeListener);
100         }
</pre>
<hr />
<pre>
436         unsafe.ensureClassInitialized(clazz);
437     }
438 
439     static Class&lt;?&gt; defineClass(Class&lt;?&gt; lookupClass, byte[] bytes) {
440         return AccessController.doPrivileged(new PrivilegedAction&lt;Class&lt;?&gt;&gt;() {
441             @Override
442             public Class&lt;?&gt; run() {
443                 try {
444                     return MethodHandles.privateLookupIn(lookupClass, LOOKUP).defineClass(bytes);
445                 } catch (IllegalAccessException e) {
446                     throw new InternalError(e);
447                 }
448             }
449         });
450     }
451 
452     public static Thread createThreadWitNoPermissions(String threadName, Runnable runnable) {
453         return doPrivilegedWithReturn(() -&gt; new Thread(runnable, threadName), new Permission[0]);
454     }
455 
<span class="line-modified">456     static void setDaemonThread(Thread t, boolean daeomn) {</span>
<span class="line-modified">457       doPrivileged(()-&gt; t.setDaemon(daeomn), new RuntimePermission(&quot;modifyThread&quot;));</span>
458     }
459 
460     public static SafePath getAbsolutePath(SafePath path) throws IOException {
461         return new SafePath(doPrivilegedIOWithReturn((()-&gt; path.toPath().toAbsolutePath())));
462     }
463 
464     private final static class Privileged extends FileAccess {
465         @Override
466         public RandomAccessFile openRAF(File f, String mode) throws IOException {
467             return doPrivilegedIOWithReturn( () -&gt; new RandomAccessFile(f, mode));
468         }
469 
470         @Override
471         public  DirectoryStream&lt;Path&gt; newDirectoryStream(Path directory)  throws IOException  {
472             return doPrivilegedIOWithReturn( () -&gt; Files.newDirectoryStream(directory));
473         }
474 
475         @Override
476         public  String getAbsolutePath(File f) throws IOException {
477             return doPrivilegedIOWithReturn( () -&gt; f.getAbsolutePath());
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 60 import java.util.concurrent.Callable;
 61 
 62 import jdk.internal.misc.Unsafe;
 63 import jdk.internal.module.Modules;
 64 import jdk.jfr.Event;
 65 import jdk.jfr.FlightRecorder;
 66 import jdk.jfr.FlightRecorderListener;
 67 import jdk.jfr.FlightRecorderPermission;
 68 import jdk.jfr.Recording;
 69 import jdk.jfr.internal.consumer.FileAccess;
 70 
 71 /**
 72  * Contains JFR code that does
 73  * {@link AccessController#doPrivileged(PrivilegedAction)}
 74  */
 75 public final class SecuritySupport {
 76     private final static Unsafe unsafe = Unsafe.getUnsafe();
 77     private final static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
 78     private final static Module JFR_MODULE = Event.class.getModule();
 79     public  final static SafePath JFC_DIRECTORY = getPathInProperty(&quot;java.home&quot;, &quot;lib/jfr&quot;);
<span class="line-modified"> 80     public final static FileAccess PRIVILEGED = new Privileged();</span>
 81     static final SafePath USER_HOME = getPathInProperty(&quot;user.home&quot;, null);
 82     static final SafePath JAVA_IO_TMPDIR = getPathInProperty(&quot;java.io.tmpdir&quot;, null);
 83 
 84     static {
 85         // ensure module java.base can read module jdk.jfr as early as possible
 86         addReadEdge(Object.class);
 87         addHandlerExport(Object.class);
 88         addEventsExport(Object.class);
 89         addInstrumentExport(Object.class);
 90     }
 91 
 92     final static class SecureRecorderListener implements FlightRecorderListener {
 93 
 94         private final AccessControlContext context;
 95         private final FlightRecorderListener changeListener;
 96 
 97         SecureRecorderListener(AccessControlContext context, FlightRecorderListener changeListener) {
 98             this.context = Objects.requireNonNull(context);
 99             this.changeListener = Objects.requireNonNull(changeListener);
100         }
</pre>
<hr />
<pre>
436         unsafe.ensureClassInitialized(clazz);
437     }
438 
439     static Class&lt;?&gt; defineClass(Class&lt;?&gt; lookupClass, byte[] bytes) {
440         return AccessController.doPrivileged(new PrivilegedAction&lt;Class&lt;?&gt;&gt;() {
441             @Override
442             public Class&lt;?&gt; run() {
443                 try {
444                     return MethodHandles.privateLookupIn(lookupClass, LOOKUP).defineClass(bytes);
445                 } catch (IllegalAccessException e) {
446                     throw new InternalError(e);
447                 }
448             }
449         });
450     }
451 
452     public static Thread createThreadWitNoPermissions(String threadName, Runnable runnable) {
453         return doPrivilegedWithReturn(() -&gt; new Thread(runnable, threadName), new Permission[0]);
454     }
455 
<span class="line-modified">456     static void setDaemonThread(Thread t, boolean daemon) {</span>
<span class="line-modified">457       doPrivileged(()-&gt; t.setDaemon(daemon), new RuntimePermission(&quot;modifyThread&quot;));</span>
458     }
459 
460     public static SafePath getAbsolutePath(SafePath path) throws IOException {
461         return new SafePath(doPrivilegedIOWithReturn((()-&gt; path.toPath().toAbsolutePath())));
462     }
463 
464     private final static class Privileged extends FileAccess {
465         @Override
466         public RandomAccessFile openRAF(File f, String mode) throws IOException {
467             return doPrivilegedIOWithReturn( () -&gt; new RandomAccessFile(f, mode));
468         }
469 
470         @Override
471         public  DirectoryStream&lt;Path&gt; newDirectoryStream(Path directory)  throws IOException  {
472             return doPrivilegedIOWithReturn( () -&gt; Files.newDirectoryStream(directory));
473         }
474 
475         @Override
476         public  String getAbsolutePath(File f) throws IOException {
477             return doPrivilegedIOWithReturn( () -&gt; f.getAbsolutePath());
</pre>
</td>
</tr>
</table>
<center><a href="RequestEngine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Type.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
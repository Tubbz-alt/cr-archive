<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PrivateAccess.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RequestEngine.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 66         this.unFinishedFile = findFileName(repositoryPath, fileName, &quot;.jfr&quot;);
 67         this.file = findFileName(repositoryPath, fileName, &quot;.jfr&quot;);
 68         this.unFinishedRAF = SecuritySupport.createRandomAccessFile(unFinishedFile);
 69  //       SecuritySupport.touch(file);
 70     }
 71 
 72     private static SafePath findFileName(SafePath directory, String name, String extension) throws Exception {
 73         Path p = directory.toPath().resolve(name + extension);
 74         for (int i = 1; i &lt; MAX_CHUNK_NAMES; i++) {
 75             SafePath s = new SafePath(p);
 76             if (!SecuritySupport.exists(s)) {
 77                 return s;
 78             }
 79             String extendedName = String.format(&quot;%s_%02d%s&quot;, name, i, extension);
 80             p = directory.toPath().resolve(extendedName);
 81         }
 82         p = directory.toPath().resolve(name + &quot;_&quot; + System.currentTimeMillis() + extension);
 83         return SecuritySupport.toRealPath(new SafePath(p));
 84     }
 85 
<span class="line-modified"> 86     public SafePath getUnfishedFile() {</span>
 87         return unFinishedFile;
 88     }
 89 
 90     void finish(Instant endTime) {
 91         try {
 92             finishWithException(endTime);
 93         } catch (IOException e) {
<span class="line-modified"> 94             Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Could not finish chunk. &quot; + e.getMessage());</span>
 95         }
 96     }
 97 
 98     private void finishWithException(Instant endTime) throws IOException {
 99         unFinishedRAF.close();
100         this.size = finish(unFinishedFile, file);
101         this.endTime = endTime;
102         Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, () -&gt; &quot;Chunk finished: &quot; + file);
103     }
104 
105     private static long finish(SafePath unFinishedFile, SafePath file) throws IOException {
106         Objects.requireNonNull(unFinishedFile);
107         Objects.requireNonNull(file);
108         return SecuritySupport.getFileSize(file);
109     }
110 
111     public Instant getStartTime() {
112         return startTime;
113     }
114 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 66         this.unFinishedFile = findFileName(repositoryPath, fileName, &quot;.jfr&quot;);
 67         this.file = findFileName(repositoryPath, fileName, &quot;.jfr&quot;);
 68         this.unFinishedRAF = SecuritySupport.createRandomAccessFile(unFinishedFile);
 69  //       SecuritySupport.touch(file);
 70     }
 71 
 72     private static SafePath findFileName(SafePath directory, String name, String extension) throws Exception {
 73         Path p = directory.toPath().resolve(name + extension);
 74         for (int i = 1; i &lt; MAX_CHUNK_NAMES; i++) {
 75             SafePath s = new SafePath(p);
 76             if (!SecuritySupport.exists(s)) {
 77                 return s;
 78             }
 79             String extendedName = String.format(&quot;%s_%02d%s&quot;, name, i, extension);
 80             p = directory.toPath().resolve(extendedName);
 81         }
 82         p = directory.toPath().resolve(name + &quot;_&quot; + System.currentTimeMillis() + extension);
 83         return SecuritySupport.toRealPath(new SafePath(p));
 84     }
 85 
<span class="line-modified"> 86     public SafePath getUnfinishedFile() {</span>
 87         return unFinishedFile;
 88     }
 89 
 90     void finish(Instant endTime) {
 91         try {
 92             finishWithException(endTime);
 93         } catch (IOException e) {
<span class="line-modified"> 94             Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Could not finish chunk. &quot; + e.getClass() + &quot; &quot;+ e.getMessage());</span>
 95         }
 96     }
 97 
 98     private void finishWithException(Instant endTime) throws IOException {
 99         unFinishedRAF.close();
100         this.size = finish(unFinishedFile, file);
101         this.endTime = endTime;
102         Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, () -&gt; &quot;Chunk finished: &quot; + file);
103     }
104 
105     private static long finish(SafePath unFinishedFile, SafePath file) throws IOException {
106         Objects.requireNonNull(unFinishedFile);
107         Objects.requireNonNull(file);
108         return SecuritySupport.getFileSize(file);
109     }
110 
111     public Instant getStartTime() {
112         return startTime;
113     }
114 
</pre>
</td>
</tr>
</table>
<center><a href="PrivateAccess.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RequestEngine.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
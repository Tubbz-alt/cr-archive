<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordedObject.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.consumer;
 27 
 28 import java.io.IOException;
 29 import java.io.PrintWriter;
 30 import java.io.StringWriter;
 31 import java.time.Duration;
 32 import java.time.Instant;
 33 import java.time.OffsetDateTime;
 34 import java.util.Comparator;
 35 import java.util.List;
 36 import java.util.Objects;
 37 
 38 import jdk.jfr.Timespan;
 39 import jdk.jfr.Timestamp;
 40 import jdk.jfr.ValueDescriptor;
 41 import jdk.jfr.internal.consumer.JdkJfrConsumer;
 42 import jdk.jfr.internal.consumer.ObjectFactory;
 43 import jdk.jfr.internal.PrivateAccess;
 44 import jdk.jfr.internal.Type;
 45 import jdk.jfr.internal.consumer.ObjectContext;
 46 import jdk.jfr.internal.tool.PrettyWriter;
 47 
 48 /**
 49  * A complex data type that consists of one or more fields.
 50  * &lt;p&gt;
 51  * This class provides methods to select and query nested objects by passing a
 52  * dot {@code &quot;.&quot;} delimited {@code String} object (for instance,
 53  * {@code &quot;aaa.bbb&quot;}). A method evaluates a nested object from left to right,
 54  * and if a part is {@code null}, it throws {@code NullPointerException}.
 55  *
 56  * @since 9
 57  */
 58 public class RecordedObject {
 59 
 60     static{
 61         JdkJfrConsumer access = new JdkJfrConsumer() {
 62             public List&lt;Type&gt; readTypes(RecordingFile file) throws IOException {
 63                 return file.readTypes();
 64             }
 65 
 66             public boolean isLastEventInChunk(RecordingFile file) {
 67                 return file.isLastEventInChunk();
 68             }
 69 
 70             @Override
 71             public Object getOffsetDataTime(RecordedObject event, String name) {
 72                 return event.getOffsetDateTime(name);
 73             }
 74 
 75             @Override
 76             public RecordedClass newRecordedClass(ObjectContext objectContext, long id, Object[] values) {
 77                 return new RecordedClass(objectContext, id, values);
 78             }
 79 
 80             @Override
 81             public RecordedClassLoader newRecordedClassLoader(ObjectContext objectContext, long id, Object[] values) {
 82                 return new RecordedClassLoader(objectContext, id, values);
 83             }
 84 
 85             @Override
 86             public Comparator&lt;? super RecordedEvent&gt; eventComparator() {
 87                 return new Comparator&lt;RecordedEvent&gt;()  {
 88                     @Override
 89                     public int compare(RecordedEvent e1, RecordedEvent e2) {
 90                         return Long.compare(e1.endTimeTicks, e2.endTimeTicks);
 91                     }
 92                 };
 93             }
 94 
 95             @Override
 96             public RecordedStackTrace newRecordedStackTrace(ObjectContext objectContext, Object[] values) {
 97                 return new RecordedStackTrace(objectContext, values);
 98             }
 99 
100             @Override
101             public RecordedThreadGroup newRecordedThreadGroup(ObjectContext objectContext, Object[] values) {
102                 return new RecordedThreadGroup(objectContext, values);
103             }
104 
105             @Override
106             public RecordedFrame newRecordedFrame(ObjectContext objectContext, Object[] values) {
107                 return new RecordedFrame(objectContext, values);
108             }
109 
110             @Override
111             public RecordedThread newRecordedThread(ObjectContext objectContext, long id, Object[] values) {
112                 return new RecordedThread(objectContext, id, values);
113             }
114 
115             @Override
116             public RecordedMethod newRecordedMethod(ObjectContext objectContext, Object[] values) {
117                 return new RecordedMethod(objectContext, values);
118             }
119 
120             @Override
121             public RecordedEvent newRecordedEvent(ObjectContext objectContext, Object[] values, long startTimeTicks, long endTimeTicks) {
122                 return new RecordedEvent(objectContext, values, startTimeTicks, endTimeTicks);
123             }
124 
125             @Override
126             public void setStartTicks(RecordedEvent event, long startTicks) {
127                event.startTimeTicks = startTicks;
128             }
129 
130             @Override
131             public void setEndTicks(RecordedEvent event, long endTicks) {
132                event.endTimeTicks = endTicks;
133             }
134 
135             @Override
136             public Object[] eventValues(RecordedEvent event) {
137                 return event.objects;
138             }
139         };
140         JdkJfrConsumer.setAccess(access);
141     }
142 
143     private final static class UnsignedValue {
144         private final Object o;
145 
146         UnsignedValue(Object o) {
147             this.o = o;
148         }
149 
150         Object value() {
151             return o;
152         }
153     }
154 
155     final Object[] objects;
156     final ObjectContext objectContext;
157 
158     // package private, not to be subclassed outside this package
159     RecordedObject(ObjectContext objectContext, Object[] objects) {
160         this.objectContext = objectContext;
161         this.objects = objects;
162     }
163 
164     // package private
165     final &lt;T&gt; T getTyped(String name, Class&lt;T&gt; clazz, T defaultValue) {
166         // Unnecessary to check field presence twice, but this
167         // will do for now.
168         if (!hasField(name)) {
169             return defaultValue;
170         }
171         T object = getValue(name);
172         if (object == null || object.getClass().isAssignableFrom(clazz)) {
173             return object;
174         } else {
175             return defaultValue;
176         }
177     }
178 
179     /**
180      * Returns {@code true} if a field with the given name exists, {@code false}
181      * otherwise.
182      *
183      * @param name name of the field to get, not {@code null}
184      *
185      * @return {@code true} if the field exists, {@code false} otherwise.
186      *
187      * @see #getFields()
188      */
189     public boolean hasField(String name) {
190         Objects.requireNonNull(name);
191         for (ValueDescriptor v : objectContext.fields) {
192             if (v.getName().equals(name)) {
193                 return true;
194             }
195         }
196         int dotIndex = name.indexOf(&quot;.&quot;);
197         if (dotIndex &gt; 0) {
198             String structName = name.substring(0, dotIndex);
199             for (ValueDescriptor v : objectContext.fields) {
200                 if (!v.getFields().isEmpty() &amp;&amp; v.getName().equals(structName)) {
201                     RecordedObject child = getValue(structName);
202                     if (child != null) {
203                         return child.hasField(name.substring(dotIndex + 1));
204                     }
205                 }
206             }
207         }
208         return false;
209     }
210 
211     /**
212      * Returns the value of the field with the given name.
213      * &lt;p&gt;
214      * The return type may be a primitive type or a subclass of
215      * {@link RecordedObject}.
216      * &lt;p&gt;
217      * It&#39;s possible to index into a nested object by using {@code &quot;.&quot;} (for
218      * instance {@code &quot;thread.group.parent.name}&quot;).
219      * &lt;p&gt;
220      * A field might change or be removed in a future JDK release. A best practice
221      * for callers of this method is to validate the field before attempting access.
222      * &lt;p&gt;
223      * Example
224      *
225      * &lt;pre&gt;
226      * &lt;code&gt;
227      * if (event.hasField(&quot;intValue&quot;)) {
228      *   int intValue = event.getValue(&quot;intValue&quot;);
229      *   System.out.println(&quot;Int value: &quot; + intValue);
230      * }
231      *
232      * if (event.hasField(&quot;objectClass&quot;)) {
233      *   RecordedClass clazz = event.getValue(&quot;objectClass&quot;);
234      *   System.out.println(&quot;Class name: &quot; + clazz.getName());
235      * }
236      *
237      * if (event.hasField(&quot;sampledThread&quot;)) {
238      *   RecordedThread sampledThread = event.getValue(&quot;sampledThread&quot;);
239      *   System.out.println(&quot;Sampled thread: &quot; + sampledThread.getName());
240      * }
241      * &lt;/code&gt;
242      * &lt;/pre&gt;
243      *
244      * @param &lt;T&gt; the return type
245      * @param  name of the field to get, not {@code null}
246      * @throws IllegalArgumentException if no field called {@code name} exists
247      *
248      * @return the value, can be {@code null}
249      *
250      * @see #hasField(String)
251      *
252      */
253     final public &lt;T&gt; T getValue(String name) {
254         @SuppressWarnings(&quot;unchecked&quot;)
255         T t = (T) getValue(name, false);
256         return t;
257     }
258 
259     protected Object objectAt(int index) {
260         return objects[index];
261     }
262 
263     private Object getValue(String name, boolean allowUnsigned) {
264         Objects.requireNonNull(name);
265         int index = 0;
266         for (ValueDescriptor v : objectContext.fields) {
267             if (name.equals(v.getName())) {
268                 Object object = objectAt(index);
269                 if (object == null) {
270                     // error or missing
271                     return null;
272                 }
273                 if (v.getFields().isEmpty()) {
274                     if (allowUnsigned &amp;&amp; PrivateAccess.getInstance().isUnsigned(v)) {
275                         // Types that are meaningless to widen
276                         if (object instanceof Character || object instanceof Long) {
277                             return object;
278                         }
279                         return new UnsignedValue(object);
280                     }
281                     return object; // primitives and primitive arrays
282                 } else {
283                     if (object instanceof RecordedObject) {
284                         // known types from factory
285                         return object;
286                     }
287                     // must be array type
288                     Object[] array = (Object[]) object;
289                     if (v.isArray()) {
290                         // struct array
291                         return structifyArray(v, array, 0);
292                     }
293                     // struct
294                     return new RecordedObject(objectContext.getInstance(v), (Object[]) object);
295                 }
296             }
297             index++;
298         }
299 
300         int dotIndex = name.indexOf(&quot;.&quot;);
301         if (dotIndex &gt; 0) {
302             String structName = name.substring(0, dotIndex);
303             for (ValueDescriptor v : objectContext.fields) {
304                 if (!v.getFields().isEmpty() &amp;&amp; v.getName().equals(structName)) {
305                     RecordedObject child = getValue(structName);
306                     String subName = name.substring(dotIndex + 1);
307                     if (child != null) {
308                         return child.getValue(subName, allowUnsigned);
309                     } else {
310                         // Call getValueDescriptor to trigger IllegalArgumentException if the name is
311                         // incorrect. Type can&#39;t be validate due to type erasure
312                         getValueDescriptor(v.getFields(), subName, null);
313                         throw new NullPointerException(&quot;Field value for \&quot;&quot; + structName + &quot;\&quot; was null. Can&#39;t access nested field \&quot;&quot; + subName + &quot;\&quot;&quot;);
314                     }
315                 }
316             }
317         }
318         throw new IllegalArgumentException(&quot;Could not find field with name &quot; + name);
319     }
320 
321     // Returns the leaf value descriptor matches both name or value, or throws an
322     // IllegalArgumentException
323     private ValueDescriptor getValueDescriptor(List&lt;ValueDescriptor&gt; descriptors, String name, String leafType) {
324         int dotIndex = name.indexOf(&quot;.&quot;);
325         if (dotIndex &gt; 0) {
326             String first = name.substring(0, dotIndex);
327             String second = name.substring(dotIndex + 1);
328             for (ValueDescriptor v : descriptors) {
329                 if (v.getName().equals(first)) {
330                     List&lt;ValueDescriptor&gt; fields = v.getFields();
331                     if (!fields.isEmpty()) {
332                         return getValueDescriptor(v.getFields(), second, leafType);
333                     }
334                 }
335             }
336             throw new IllegalArgumentException(&quot;Attempt to get unknown field \&quot;&quot; + first + &quot;\&quot;&quot;);
337         }
338         for (ValueDescriptor v : descriptors) {
339             if (v.getName().equals(name)) {
340                 if (leafType != null &amp;&amp; !v.getTypeName().equals(leafType)) {
341                     throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal data type conversion &quot; + leafType);
342                 }
343                 return v;
344             }
345         }
346         throw new IllegalArgumentException(&quot;\&quot;Attempt to get unknown field \&quot;&quot; + name + &quot;\&quot;&quot;);
347     }
348 
349     // Gets a value, but checks that type and name is correct first
350     // This is to prevent a call to getString on a thread field, that is
351     // null to succeed.
352     private &lt;T&gt; T getTypedValue(String name, String typeName) {
353         Objects.requireNonNull(name);
354         // Validate name and type first
355         getValueDescriptor(objectContext.fields, name, typeName);
356         return getValue(name);
357     }
358 
359     private Object[] structifyArray(ValueDescriptor v, Object[] array, int dimension) {
360         if (array == null) {
361             return null;
362         }
363         Object[] structArray = new Object[array.length];
364         ObjectContext objContext = objectContext.getInstance(v);
365         for (int i = 0; i &lt; structArray.length; i++) {
366             Object arrayElement = array[i];
367             if (dimension == 0) {
368                 // No general way to handle structarrays
369                 // without invoking ObjectFactory for every instance (which may require id)
370                 if (isStackFrameType(v.getTypeName())) {
371                     structArray[i] = new RecordedFrame(objContext, (Object[]) arrayElement);
372                 } else {
373                     structArray[i] = new RecordedObject(objContext, (Object[]) arrayElement);
374                 }
375             } else {
376                 structArray[i] = structifyArray(v, (Object[]) arrayElement, dimension - 1);
377             }
378         }
379         return structArray;
380     }
381 
382     private boolean isStackFrameType(String typeName) {
383         if (ObjectFactory.STACK_FRAME_VERSION_1.equals(typeName)) {
384             return true;
385         }
386         if (ObjectFactory.STACK_FRAME_VERSION_2.equals(typeName)) {
387             return true;
388         }
389         return false;
390     }
391 
392     /**
393      * Returns an immutable list of the fields for this object.
394      *
395      * @return the fields, not {@code null}
396      */
397     public List&lt;ValueDescriptor&gt; getFields() {
398         return objectContext.fields;
399     }
400 
401     /**
402      * Returns the value of a field of type {@code boolean}.
403      * &lt;p&gt;
404      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
405      * {@code &quot;aaa.bbb&quot;}).
406      * &lt;p&gt;
407      * A field might change or be removed in a future JDK release. A best practice
408      * for callers of this method is to validate the field before attempting access.
409      *
410      * @param name name of the field to get, not {@code null}
411      *
412      * @return the value of the field, {@code true} or {@code false}
413      *
414      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field is
415      *         not of type {@code boolean}
416      *
417      * @see #hasField(String)
418      * @see #getValue(String)
419      */
420     public final boolean getBoolean(String name) {
421         Object o = getValue(name);
422         if (o instanceof Boolean) {
423             return ((Boolean) o).booleanValue();
424         }
425         throw newIllegalArgumentException(name, &quot;boolean&quot;);
426     }
427 
428     /**
429      * Returns the value of a field of type {@code byte}.
430      * &lt;p&gt;
431      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
432      * {@code &quot;foo.bar&quot;}).
433      * &lt;p&gt;
434      * A field might change or be removed in a future JDK release. A best practice
435      * for callers of this method is to validate the field before attempting access.
436      *
437      * @param name of the field to get, not {@code null}
438      *
439      * @return the value of the field
440      *
441      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field is
442      *         not of type {@code byte}
443      *
444      * @see #hasField(String)
445      * @see #getValue(String)
446      */
447     public final byte getByte(String name) {
448         Object o = getValue(name);
449         if (o instanceof Byte) {
450             return ((Byte) o).byteValue();
451         }
452         throw newIllegalArgumentException(name, &quot;byte&quot;);
453     }
454 
455     /**
456      * Returns the value of a field of type {@code char}.
457      * &lt;p&gt;
458      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
459      * {@code &quot;aaa.bbb&quot;}).
460      * &lt;p&gt;
461      * A field might change or be removed in a future JDK release. A best practice
462      * for callers of this method is to validate the field before attempting access.
463      *
464      * @param name of the field to get, not {@code null}
465      *
466      * @return the value of the field as a {@code char}
467      *
468      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field is
469      *         not of type {@code char}
470      *
471      * @see #hasField(String)
472      * @see #getValue(String)
473      */
474     public final char getChar(String name) {
475         Object o = getValue(name);
476         if (o instanceof Character) {
477             return ((Character) o).charValue();
478         }
479 
480         throw newIllegalArgumentException(name, &quot;char&quot;);
481     }
482 
483     /**
484      * Returns the value of a field of type {@code short} or of another primitive
485      * type convertible to type {@code short} by a widening conversion.
486      * &lt;p&gt;
487      * This method can be used on the following types: {@code short} and {@code byte}.
488      * &lt;p&gt;
489      * If the field has the {@code @Unsigned} annotation and is of a narrower type
490      * than {@code short}, then the value is returned as an unsigned.
491      * &lt;p&gt;
492      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
493      * {@code &quot;aaa.bbb&quot;}).
494      * &lt;p&gt;
495      * A field might change or be removed in a future JDK release. A best practice
496      * for callers of this method is to validate the field before attempting access.
497      *
498      * @param name of the field to get, not {@code null}
499      *
500      * @return the value of the field converted to type {@code short}
501      *
502      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
503      *         value can&#39;t be converted to the type {@code short} by a widening
504      *         conversion
505      *
506      * @see #hasField(String)
507      * @see #getValue(String)
508      */
509     public final short getShort(String name) {
510         Object o = getValue(name, true);
511         if (o instanceof Short) {
512             return ((Short) o).shortValue();
513         }
514         if (o instanceof Byte) {
515             return ((Byte) o).byteValue();
516         }
517         if (o instanceof UnsignedValue) {
518             Object u = ((UnsignedValue) o).value();
519             if (u instanceof Short) {
520                 return ((Short) u).shortValue();
521             }
522             if (u instanceof Byte) {
523                 return (short) Byte.toUnsignedInt(((Byte) u));
524             }
525         }
526         throw newIllegalArgumentException(name, &quot;short&quot;);
527     }
528 
529     /**
530      * Returns the value of a field of type {@code int} or of another primitive type
531      * that is convertible to type {@code int} by a widening conversion.
532      * &lt;p&gt;
533      * This method can be used on fields of the following types: {@code int},
534      * {@code short}, {@code char}, and {@code byte}.
535      * &lt;p&gt;
536      * If the field has the {@code @Unsigned} annotation and is of a narrower type
537      * than {@code int}, then the value will be returned as an unsigned.
538      * &lt;p&gt;
539      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
540      * {@code &quot;aaa.bbb&quot;}).
541      * &lt;p&gt;
542      * A field might change or be removed in a future JDK release. A best practice
543      * for callers of this method is to validate the field before attempting access.
544      *
545      * @param name of the field to get, not {@code null}
546      *
547      * @return the value of the field converted to type {@code int}
548      *
549      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
550      *         value can&#39;t be converted to the type {@code int} by a widening
551      *         conversion
552      *
553      * @see #hasField(String)
554      * @see #getValue(String)
555      */
556     public final int getInt(String name) {
557         Object o = getValue(name, true);
558         if (o instanceof Integer) {
559             return ((Integer) o).intValue();
560         }
561         if (o instanceof Short) {
562             return ((Short) o).intValue();
563         }
564         if (o instanceof Character) {
565             return ((Character) o).charValue();
566         }
567         if (o instanceof Byte) {
568             return ((Byte) o).intValue();
569         }
570         if (o instanceof UnsignedValue) {
571             Object u = ((UnsignedValue) o).value();
572             if (u instanceof Integer) {
573                 return ((Integer) u).intValue();
574             }
575             if (u instanceof Short) {
576                 return Short.toUnsignedInt(((Short) u));
577             }
578             if (u instanceof Byte) {
579                 return Byte.toUnsignedInt(((Byte) u));
580             }
581         }
582         throw newIllegalArgumentException(name, &quot;int&quot;);
583     }
584 
585     /**
586      * Returns the value of a field of type {@code float} or of another primitive
587      * type convertible to type {@code float} by a widening conversion.
588      * &lt;p&gt;
589      * This method can be used on fields of the following types: {@code float},
590      * {@code long}, {@code int}, {@code short}, {@code char}, and {@code byte}.
591      * &lt;p&gt;
592      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
593      * {@code &quot;aaa.bbb&quot;}).
594      * &lt;p&gt;
595      * A field might change or be removed in a future JDK release. A best practice
596      * for callers of this method is to validate the field before attempting access.
597      *
598      * @param name of the field to get, not {@code null}
599      *
600      * @return the value of the field converted to type {@code float}
601      *
602      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
603      *         value can&#39;t be converted to the type {@code float} by a widening
604      *         conversion
605      *
606      * @see #hasField(String)
607      * @see #getValue(String)
608      */
609     public final float getFloat(String name) {
610         Object o = getValue(name);
611         if (o instanceof Float) {
612             return ((Float) o).floatValue();
613         }
614         if (o instanceof Long) {
615             return ((Long) o).floatValue();
616         }
617         if (o instanceof Integer) {
618             return ((Integer) o).floatValue();
619         }
620         if (o instanceof Short) {
621             return ((Short) o).floatValue();
622         }
623         if (o instanceof Byte) {
624             return ((Byte) o).byteValue();
625         }
626         if (o instanceof Character) {
627             return ((Character) o).charValue();
628         }
629         throw newIllegalArgumentException(name, &quot;float&quot;);
630     }
631 
632     /**
633      * Returns the value of a field of type {@code long} or of another primitive
634      * type that is convertible to type {@code long} by a widening conversion.
635      * &lt;p&gt;
636      * This method can be used on fields of the following types: {@code long},
637      * {@code int}, {@code short}, {@code char}, and {@code byte}.
638      * &lt;p&gt;
639      * If the field has the {@code @Unsigned} annotation and is of a narrower type
640      * than {@code long}, then the value will be returned as an unsigned.
641      * &lt;p&gt;
642      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
643      * {@code &quot;aaa.bbb&quot;}).
644      * &lt;p&gt;
645      * A field might change or be removed in a future JDK release. A best practice
646      * for callers of this method is to validate the field before attempting access.
647      *
648      * @param name of the field to get, not {@code null}
649      *
650      * @return the value of the field converted to type {@code long}
651      *
652      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
653      *         value can&#39;t be converted to the type {@code long} via a widening
654      *         conversion
655      *
656      * @see #hasField(String)
657      * @see #getValue(String)
658      */
659     public final long getLong(String name) {
660         Object o = getValue(name, true);
661         if (o instanceof Long) {
662             return ((Long) o).longValue();
663         }
664         if (o instanceof Integer) {
665             return ((Integer) o).longValue();
666         }
667         if (o instanceof Short) {
668             return ((Short) o).longValue();
669         }
670         if (o instanceof Character) {
671             return ((Character) o).charValue();
672         }
673         if (o instanceof Byte) {
674             return ((Byte) o).longValue();
675         }
676         if (o instanceof UnsignedValue) {
677             Object u = ((UnsignedValue) o).value();
678             if (u instanceof Integer) {
679                 return Integer.toUnsignedLong(((Integer) u));
680             }
681             if (u instanceof Short) {
682                 return Short.toUnsignedLong(((Short) u));
683             }
684             if (u instanceof Byte) {
685                 return Byte.toUnsignedLong(((Byte) u));
686             }
687         }
688         throw newIllegalArgumentException(name, &quot;long&quot;);
689     }
690 
691     /**
692      * Returns the value of a field of type {@code double} or of another primitive
693      * type that is convertible to type {@code double} by a widening conversion.
694      * &lt;p&gt;
695      * This method can be used on fields of the following types: {@code double}, {@code float},
696      * {@code long}, {@code int}, {@code short}, {@code char}, and {@code byte}.
697      * &lt;p&gt;
698      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
699      * {@code &quot;aaa.bbb&quot;}).
700      * &lt;p&gt;
701      * A field might change or be removed in a future JDK release. A best practice
702      * for callers of this method is to validate the field before attempting access.
703      *
704      * @param name of the field to get, not {@code null}
705      *
706      * @return the value of the field converted to type {@code double}
707      *
708      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
709      *         value can&#39;t be converted to the type {@code double} by a widening
710      *         conversion
711      *
712      * @see #hasField(String)
713      * @see #getValue(String)
714      */
715     public final double getDouble(String name) {
716         Object o = getValue(name);
717         if (o instanceof Double) {
718             return ((Double) o).doubleValue();
719         }
720         if (o instanceof Float) {
721             return ((Float) o).doubleValue();
722         }
723         if (o instanceof Long) {
724             return ((Long) o).doubleValue();
725         }
726         if (o instanceof Integer) {
727             return ((Integer) o).doubleValue();
728         }
729         if (o instanceof Short) {
730             return ((Short) o).doubleValue();
731         }
732         if (o instanceof Byte) {
733             return ((Byte) o).byteValue();
734         }
735         if (o instanceof Character) {
736             return ((Character) o).charValue();
737         }
738         throw newIllegalArgumentException(name, &quot;double&quot;);
739     }
740 
741     /**
742      * Returns the value of a field of type {@code String}.
743      * &lt;p&gt;
744      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
745      * {@code &quot;foo.bar&quot;}).
746      * &lt;p&gt;
747      * A field might change or be removed in a future JDK release. A best practice
748      * for callers of this method is to validate the field before attempting access.
749      *
750      * @param name of the field to get, not {@code null}
751      *
752      * @return the value of the field as a {@code String}, can be {@code null}
753      *
754      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
755      *         isn&#39;t of type {@code String}
756      *
757      * @see #hasField(String)
758      * @see #getValue(String)
759      */
760     public final String getString(String name) {
761         return getTypedValue(name, &quot;java.lang.String&quot;);
762     }
763 
764     /**
765      * Returns the value of a timespan field.
766      * &lt;p&gt;
767      * This method can be used on fields annotated with {@code @Timespan}, and of
768      * the following types: {@code long}, {@code int}, {@code short}, {@code char},
769      * and {@code byte}.
770      * &lt;p&gt;
771      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
772      * {@code &quot;aaa.bbb&quot;}).
773      * &lt;p&gt;
774      * A field might change or be removed in a future JDK release. A best practice
775      * for callers of this method is to validate the field before attempting access.
776      *
777      * @param name of the field to get, not {@code null}
778      *
779      * @return a time span represented as a {@code Duration}, not {@code null}
780      *
781      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
782      *         value can&#39;t be converted to a {@code Duration} object
783      *
784      * @see #hasField(String)
785      * @see #getValue(String)
786      */
787     public final Duration getDuration(String name) {
788         Object o = getValue(name);
789         if (o instanceof Long) {
790             return getDuration(((Long) o).longValue(), name);
791         }
792         if (o instanceof Integer) {
793             return getDuration(((Integer) o).longValue(), name);
794         }
795         if (o instanceof Short) {
796             return getDuration(((Short) o).longValue(), name);
797         }
798         if (o instanceof Character) {
799             return getDuration(((Character) o).charValue(), name);
800         }
801         if (o instanceof Byte) {
802             return getDuration(((Byte) o).longValue(), name);
803         }
804         if (o instanceof UnsignedValue) {
805             Object u = ((UnsignedValue) o).value();
806             if (u instanceof Integer) {
807                 return getDuration(Integer.toUnsignedLong((Integer) u), name);
808             }
809             if (u instanceof Short) {
810                 return getDuration(Short.toUnsignedLong((Short) u), name);
811             }
812             if (u instanceof Byte) {
813                 return getDuration(Short.toUnsignedLong((Byte) u), name);
814             }
815         }
816         throw newIllegalArgumentException(name, &quot;java.time.Duration&quot;);
817     }
818 
819     private Duration getDuration(long timespan, String name) throws InternalError {
820         ValueDescriptor v = getValueDescriptor(objectContext.fields, name, null);
821         if (timespan == Long.MIN_VALUE) {
822             return Duration.ofSeconds(Long.MIN_VALUE, 0);
823         }
824         Timespan ts = v.getAnnotation(Timespan.class);
825         if (ts != null) {
826             switch (ts.value()) {
827             case Timespan.MICROSECONDS:
828                 return Duration.ofNanos(1000 * timespan);
829             case Timespan.SECONDS:
830                 return Duration.ofSeconds(timespan);
831             case Timespan.MILLISECONDS:
832                 return Duration.ofMillis(timespan);
833             case Timespan.NANOSECONDS:
834                 return Duration.ofNanos(timespan);
835             case Timespan.TICKS:
836                 return Duration.ofNanos(objectContext.convertTimespan(timespan));
837             }
838             throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal timespan unit &quot; + ts.value());
839         }
840         throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with missing @Timespan&quot;);
841     }
842 
843     /**
844      * Returns the value of a timestamp field.
845      * &lt;p&gt;
846      * This method can be used on fields annotated with {@code @Timestamp}, and of
847      * the following types: {@code long}, {@code int}, {@code short}, {@code char}
848      * and {@code byte}.
849      * &lt;p&gt;
850      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
851      * {@code &quot;aaa.bbb&quot;}).
852      * &lt;p&gt;
853      * A field might change or be removed in a future JDK release. A best practice
854      * for callers of this method is to validate the field before attempting access.
855      *
856      * @param name of the field to get, not {@code null}
857      *
858      * @return a timstamp represented as an {@code Instant}, not {@code null}
859      *
860      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
861      *         value can&#39;t be converted to an {@code Instant} object
862      *
863      * @see #hasField(String)
864      * @see #getValue(String)
865      */
866     public final Instant getInstant(String name) {
867         Object o = getValue(name, true);
868         if (o instanceof Long) {
869             return getInstant(((Long) o).longValue(), name);
870         }
871         if (o instanceof Integer) {
872             return getInstant(((Integer) o).longValue(), name);
873         }
874         if (o instanceof Short) {
875             return getInstant(((Short) o).longValue(), name);
876         }
877         if (o instanceof Character) {
878             return getInstant(((Character) o).charValue(), name);
879         }
880         if (o instanceof Byte) {
881             return getInstant(((Byte) o).longValue(), name);
882         }
883         if (o instanceof UnsignedValue) {
884             Object u = ((UnsignedValue) o).value();
885             if (u instanceof Integer) {
886                 return getInstant(Integer.toUnsignedLong((Integer) u), name);
887             }
888             if (u instanceof Short) {
889                 return getInstant(Short.toUnsignedLong((Short) u), name);
890             }
891             if (u instanceof Byte) {
892                 return getInstant(Short.toUnsignedLong((Byte) u), name);
893             }
894         }
895         throw newIllegalArgumentException(name, &quot;java.time.Instant&quot;);
896     }
897 
898     private Instant getInstant(long timestamp, String name) {
899         ValueDescriptor v = getValueDescriptor(objectContext.fields, name, null);
900         Timestamp ts = v.getAnnotation(Timestamp.class);
901         if (ts != null) {
902             if (timestamp == Long.MIN_VALUE) {
903                 return Instant.MIN;
904             }
905             switch (ts.value()) {
906             case Timestamp.MILLISECONDS_SINCE_EPOCH:
907                 return Instant.ofEpochMilli(timestamp);
908             case Timestamp.TICKS:
909                 return Instant.ofEpochSecond(0, objectContext.convertTimestamp(timestamp));
910             }
911             throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal timestamp unit &quot; + ts.value());
912         }
913         throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with missing @Timestamp&quot;);
914     }
915 
916     /**
917      * Returns the value of a field of type {@code Class}.
918      * &lt;p&gt;
919      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
920      * {@code &quot;aaa.bbb&quot;}).
921      * &lt;p&gt;
922      * A field might change or be removed in a future JDK release. A best practice
923      * for callers of this method is to validate the field before attempting access.
924      *
925      * @param name of the field to get, not {@code null}
926      *
927      * @return the value of the field as a {@code RecordedClass}, can be
928      *         {@code null}
929      *
930      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
931      *         isn&#39;t of type {@code Class}
932      *
933      * @see #hasField(String)
934      * @see #getValue(String)
935      */
936     public final RecordedClass getClass(String name) {
937         return getTypedValue(name, &quot;java.lang.Class&quot;);
938     }
939 
940     /**
941      * Returns the value of a field of type {@code Thread}.
942      * &lt;p&gt;
943      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
944      * {@code &quot;foo.bar&quot;}).
945      * &lt;p&gt;
946      * A field might change or be removed in a future JDK release. A best practice
947      * for callers of this method is to validate the field before attempting access.
948      *
949      * @param name of the field to get, not {@code null}
950      *
951      * @return the value of the field as a {@code RecordedThread} object, can be
952      *         {@code null}
953      *
954      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field
955      *         isn&#39;t of type {@code Thread}
956      *
957      * @see #hasField(String)
958      * @see #getValue(String)
959      */
960     public final RecordedThread getThread(String name) {
961         return getTypedValue(name, &quot;java.lang.Thread&quot;);
962     }
963 
964     /**
965      * Returns a textual representation of this object.
966      *
967      * @return textual description of this object
968      */
969     @Override
970     final public String toString() {
971         StringWriter s = new StringWriter();
972         PrettyWriter p = new PrettyWriter(new PrintWriter(s));
973         p.setStackDepth(5);
974         if (this instanceof RecordedEvent) {
975             p.print((RecordedEvent) this);
976         } else {
977             p.print(this, &quot;&quot;);
978         }
979         p.flush(true);
980         return s.toString();
981     }
982 
983     // package private for now. Used by EventWriter
984     private OffsetDateTime getOffsetDateTime(String name) {
985         Instant instant = getInstant(name);
986         if (instant.equals(Instant.MIN)) {
987             return OffsetDateTime.MIN;
988         }
989         return OffsetDateTime.ofInstant(getInstant(name), objectContext.getZoneOffset());
990     }
991 
992     private static IllegalArgumentException newIllegalArgumentException(String name, String typeName) {
993         return new IllegalArgumentException(&quot;Attempt to get field \&quot;&quot; + name + &quot;\&quot; with illegal data type conversion &quot; + typeName);
994     }
995 }
    </pre>
  </body>
</html>
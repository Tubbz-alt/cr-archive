diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java
@@ -81,18 +81,18 @@
     private final LinkedList<RepositoryChunk> chunks = new LinkedList<>();
     private volatile Recording recording;
     private TimerTask stopTask;
     private TimerTask startTask;
     private AccessControlContext noDestinationDumpOnExitAccessControlContext;
-    private boolean shuoldWriteActiveRecordingEvent = true;
+    private boolean shouldWriteActiveRecordingEvent = true;
     private Duration flushInterval = Duration.ofSeconds(1);
     private long finalStartChunkNanos = Long.MIN_VALUE;
 
     PlatformRecording(PlatformRecorder recorder, long id) {
         // Typically the access control context is taken
-        // when you call dump(Path) or setDdestination(Path),
-        // but if no destination is set and dumponexit=true
+        // when you call dump(Path) or setDestination(Path),
+        // but if no destination is set and dumpOnExit=true
         // the control context of the recording is taken when the
         // Recording object is constructed. This works well for
         // -XX:StartFlightRecording and JFR.dump
         this.noDestinationDumpOnExitAccessControlContext = AccessController.getContext();
         this.id = id;
@@ -201,11 +201,11 @@
         }
     }
 
     private void ensureOkForSchedule() {
         if (getState() != RecordingState.NEW) {
-            throw new IllegalStateException("Only a new recoridng can be scheduled for start");
+            throw new IllegalStateException("Only a new recording can be scheduled for start");
         }
     }
 
     private TimerTask createStartTask() {
         // Taking ref. to recording here.
@@ -680,15 +680,15 @@
     public AccessControlContext getNoDestinationDumpOnExitAccessControlContext() {
         return noDestinationDumpOnExitAccessControlContext;
     }
 
     void setShouldWriteActiveRecordingEvent(boolean shouldWrite) {
-        this.shuoldWriteActiveRecordingEvent = shouldWrite;
+        this.shouldWriteActiveRecordingEvent = shouldWrite;
     }
 
     boolean shouldWriteMetadataEvent() {
-        return shuoldWriteActiveRecordingEvent;
+        return shouldWriteActiveRecordingEvent;
     }
 
     // Dump running and stopped recordings
     public void dump(WriteableUserPath writeableUserPath) throws IOException {
         synchronized (recorder) {
@@ -698,11 +698,11 @@
         }
     }
 
     public void dumpStopped(WriteableUserPath userPath) throws IOException {
         synchronized (recorder) {
-                userPath.doPriviligedIO(() -> {
+                userPath.doPrivilegedIO(() -> {
                     try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
                         cc.transferTo(fc);
                         fc.force(true);
                     }
                     return null;

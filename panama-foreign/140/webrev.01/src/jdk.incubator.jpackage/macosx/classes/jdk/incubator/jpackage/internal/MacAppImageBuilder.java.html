<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.File;
 29 import java.io.FileInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.Writer;
 33 import java.math.BigInteger;
 34 import java.nio.file.Files;
 35 import java.nio.file.Path;
 36 import java.nio.file.StandardCopyOption;
 37 import java.nio.file.attribute.PosixFilePermission;
 38 import java.text.MessageFormat;
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.EnumSet;
 42 import java.util.HashMap;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Objects;
 46 import java.util.Optional;
 47 import java.util.ResourceBundle;
 48 import java.util.Set;
 49 import java.util.concurrent.atomic.AtomicReference;
 50 import java.util.function.Consumer;
 51 import java.util.stream.Stream;
 52 import javax.xml.parsers.DocumentBuilder;
 53 import javax.xml.parsers.DocumentBuilderFactory;
 54 import javax.xml.xpath.XPath;
 55 import javax.xml.xpath.XPathConstants;
 56 import javax.xml.xpath.XPathFactory;
 57 
 58 import static jdk.incubator.jpackage.internal.StandardBundlerParam.*;
 59 import static jdk.incubator.jpackage.internal.MacBaseInstallerBundler.*;
 60 import static jdk.incubator.jpackage.internal.MacAppBundler.*;
 61 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 62 
 63 public class MacAppImageBuilder extends AbstractAppImageBuilder {
 64 
 65     private static final ResourceBundle I18N = ResourceBundle.getBundle(
 66             &quot;jdk.incubator.jpackage.internal.resources.MacResources&quot;);
 67 
 68     private static final String TEMPLATE_BUNDLE_ICON = &quot;java.icns&quot;;
 69     private static final String OS_TYPE_CODE = &quot;APPL&quot;;
 70     private static final String TEMPLATE_INFO_PLIST_LITE =
 71             &quot;Info-lite.plist.template&quot;;
 72     private static final String TEMPLATE_RUNTIME_INFO_PLIST =
 73             &quot;Runtime-Info.plist.template&quot;;
 74 
 75     private final Path root;
 76     private final Path contentsDir;
 77     private final Path appDir;
 78     private final Path javaModsDir;
 79     private final Path resourcesDir;
 80     private final Path macOSDir;
 81     private final Path runtimeDir;
 82     private final Path runtimeRoot;
 83     private final Path mdir;
 84 
 85     private static List&lt;String&gt; keyChains;
 86 
 87     public static final BundlerParamInfo&lt;Boolean&gt;
 88             MAC_CONFIGURE_LAUNCHER_IN_PLIST = new StandardBundlerParam&lt;&gt;(
 89                     &quot;mac.configure-launcher-in-plist&quot;,
 90                     Boolean.class,
 91                     params -&gt; Boolean.FALSE,
 92                     (s, p) -&gt; Boolean.valueOf(s));
 93 
 94     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_NAME =
 95             new StandardBundlerParam&lt;&gt;(
 96                     Arguments.CLIOptions.MAC_BUNDLE_NAME.getId(),
 97                     String.class,
 98                     params -&gt; null,
 99                     (s, p) -&gt; s);
100 
101     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_IDENTIFIER =
102             new StandardBundlerParam&lt;&gt;(
103                     Arguments.CLIOptions.MAC_BUNDLE_IDENTIFIER.getId(),
104                     String.class,
105                     params -&gt; {
106                         // Get identifier from app image if user provided
107                         // app image and did not provide the identifier via CLI.
108                         String identifier = extractBundleIdentifier(params);
109                         if (identifier != null) {
110                             return identifier;
111                         }
112 
113                         identifier = IDENTIFIER.fetchFrom(params);
114                         if (identifier != null) {
115                             return identifier;
116                         }
117                         // the IDENTIFIER (above) will default to derive from
118                         // the main-class, in case there is no main-class
119                         // (such as runtime installer) revert to the name.
120                         // any of these could be invalid, so check later.
121                         return APP_NAME.fetchFrom(params);
122                     },
123                     (s, p) -&gt; s);
124 
125     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_VERSION =
126             new StandardBundlerParam&lt;&gt;(
127                     &quot;mac.CFBundleVersion&quot;,
128                     String.class,
129                     p -&gt; {
130                         String s = VERSION.fetchFrom(p);
131                         if (validCFBundleVersion(s)) {
132                             return s;
133                         } else {
134                             return &quot;100&quot;;
135                         }
136                     },
137                     (s, p) -&gt; s);
138 
139     public static final BundlerParamInfo&lt;File&gt; ICON_ICNS =
140             new StandardBundlerParam&lt;&gt;(
141             &quot;icon.icns&quot;,
142             File.class,
143             params -&gt; {
144                 File f = ICON.fetchFrom(params);
145                 if (f != null &amp;&amp; !f.getName().toLowerCase().endsWith(&quot;.icns&quot;)) {
146                     Log.error(MessageFormat.format(
147                             I18N.getString(&quot;message.icon-not-icns&quot;), f));
148                     return null;
149                 }
150                 return f;
151             },
152             (s, p) -&gt; new File(s));
153 
154     public static final StandardBundlerParam&lt;Boolean&gt; SIGN_BUNDLE  =
155             new StandardBundlerParam&lt;&gt;(
156             Arguments.CLIOptions.MAC_SIGN.getId(),
157             Boolean.class,
158             params -&gt; false,
159             // valueOf(null) is false, we actually do want null in some cases
160             (s, p) -&gt; (s == null || &quot;null&quot;.equalsIgnoreCase(s)) ?
161                     null : Boolean.valueOf(s)
162         );
163 
164     public MacAppImageBuilder(Map&lt;String, Object&gt; params, Path imageOutDir)
165             throws IOException {
166         super(params, imageOutDir.resolve(APP_NAME.fetchFrom(params)
167                 + &quot;.app/Contents/runtime/Contents/Home&quot;));
168 
169         Objects.requireNonNull(imageOutDir);
170 
171         this.root = imageOutDir.resolve(APP_NAME.fetchFrom(params) + &quot;.app&quot;);
172         this.contentsDir = root.resolve(&quot;Contents&quot;);
173         this.appDir = contentsDir.resolve(&quot;app&quot;);
174         this.javaModsDir = appDir.resolve(&quot;mods&quot;);
175         this.resourcesDir = contentsDir.resolve(&quot;Resources&quot;);
176         this.macOSDir = contentsDir.resolve(&quot;MacOS&quot;);
177         this.runtimeDir = contentsDir.resolve(&quot;runtime&quot;);
178         this.runtimeRoot = runtimeDir.resolve(&quot;Contents/Home&quot;);
179         this.mdir = runtimeRoot.resolve(&quot;lib&quot;);
180         Files.createDirectories(appDir);
181         Files.createDirectories(resourcesDir);
182         Files.createDirectories(macOSDir);
183         Files.createDirectories(runtimeDir);
184     }
185 
186     private void writeEntry(InputStream in, Path dstFile) throws IOException {
187         Files.createDirectories(dstFile.getParent());
188         Files.copy(in, dstFile);
189     }
190 
191     public static boolean validCFBundleVersion(String v) {
192         // CFBundleVersion (String - iOS, OS X) specifies the build version
193         // number of the bundle, which identifies an iteration (released or
194         // unreleased) of the bundle. The build version number should be a
195         // string comprised of three non-negative, period-separated integers
196         // with the first integer being greater than zero. The string should
197         // only contain numeric (0-9) and period (.) characters. Leading zeros
198         // are truncated from each integer and will be ignored (that is,
199         // 1.02.3 is equivalent to 1.2.3). This key is not localizable.
200 
201         if (v == null) {
202             return false;
203         }
204 
205         String p[] = v.split(&quot;\\.&quot;);
206         if (p.length &gt; 3 || p.length &lt; 1) {
207             Log.verbose(I18N.getString(
208                     &quot;message.version-string-too-many-components&quot;));
209             return false;
210         }
211 
212         try {
213             BigInteger n = new BigInteger(p[0]);
214             if (BigInteger.ONE.compareTo(n) &gt; 0) {
215                 Log.verbose(I18N.getString(
216                         &quot;message.version-string-first-number-not-zero&quot;));
217                 return false;
218             }
219             if (p.length &gt; 1) {
220                 n = new BigInteger(p[1]);
221                 if (BigInteger.ZERO.compareTo(n) &gt; 0) {
222                     Log.verbose(I18N.getString(
223                             &quot;message.version-string-no-negative-numbers&quot;));
224                     return false;
225                 }
226             }
227             if (p.length &gt; 2) {
228                 n = new BigInteger(p[2]);
229                 if (BigInteger.ZERO.compareTo(n) &gt; 0) {
230                     Log.verbose(I18N.getString(
231                             &quot;message.version-string-no-negative-numbers&quot;));
232                     return false;
233                 }
234             }
235         } catch (NumberFormatException ne) {
236             Log.verbose(I18N.getString(&quot;message.version-string-numbers-only&quot;));
237             Log.verbose(ne);
238             return false;
239         }
240 
241         return true;
242     }
243 
244     @Override
245     public Path getAppDir() {
246         return appDir;
247     }
248 
249     @Override
250     public Path getAppModsDir() {
251         return javaModsDir;
252     }
253 
254     @Override
255     public void prepareApplicationFiles(Map&lt;String, ? super Object&gt; params)
256             throws IOException {
257         Map&lt;String, ? super Object&gt; originalParams = new HashMap&lt;&gt;(params);
258         // Generate PkgInfo
259         File pkgInfoFile = new File(contentsDir.toFile(), &quot;PkgInfo&quot;);
260         pkgInfoFile.createNewFile();
261         writePkgInfo(pkgInfoFile);
262 
263         Path executable = macOSDir.resolve(getLauncherName(params));
264 
265         // create the main app launcher
266         try (InputStream is_launcher =
267                 getResourceAsStream(&quot;jpackageapplauncher&quot;)) {
268             // Copy executable and library to MacOS folder
269             writeEntry(is_launcher, executable);
270         }
271         executable.toFile().setExecutable(true, false);
272         // generate main app launcher config file
273         File cfg = new File(root.toFile(), getLauncherCfgName(params));
274         writeCfgFile(params, cfg);
275 
276         // create additional app launcher(s) and config file(s)
277         List&lt;Map&lt;String, ? super Object&gt;&gt; entryPoints =
278                 StandardBundlerParam.ADD_LAUNCHERS.fetchFrom(params);
279         for (Map&lt;String, ? super Object&gt; entryPoint : entryPoints) {
280             Map&lt;String, ? super Object&gt; tmp =
281                     AddLauncherArguments.merge(originalParams, entryPoint);
282 
283             // add executable for add launcher
284             Path addExecutable = macOSDir.resolve(getLauncherName(tmp));
285             try (InputStream is = getResourceAsStream(&quot;jpackageapplauncher&quot;);) {
286                 writeEntry(is, addExecutable);
287             }
288             addExecutable.toFile().setExecutable(true, false);
289 
290             // add config file for add launcher
291             cfg = new File(root.toFile(), getLauncherCfgName(tmp));
292             writeCfgFile(tmp, cfg);
293         }
294 
295         // Copy class path entries to Java folder
296         copyClassPathEntries(appDir, params);
297 
298         /*********** Take care of &quot;config&quot; files *******/
299 
300         createResource(TEMPLATE_BUNDLE_ICON, params)
301                 .setCategory(&quot;icon&quot;)
302                 .setExternal(ICON_ICNS.fetchFrom(params))
303                 .saveToFile(resourcesDir.resolve(APP_NAME.fetchFrom(params)
304                         + &quot;.icns&quot;));
305 
306         // copy file association icons
307         for (Map&lt;String, ?
308                 super Object&gt; fa : FILE_ASSOCIATIONS.fetchFrom(params)) {
309             File f = FA_ICON.fetchFrom(fa);
310             if (f != null &amp;&amp; f.exists()) {
311                 try (InputStream in2 = new FileInputStream(f)) {
312                     Files.copy(in2, resourcesDir.resolve(f.getName()));
313                 }
314 
315             }
316         }
317 
318         copyRuntimeFiles(params);
319         sign(params);
320     }
321 
322     @Override
323     public void prepareJreFiles(Map&lt;String, ? super Object&gt; params)
324             throws IOException {
325         copyRuntimeFiles(params);
326         sign(params);
327     }
328 
329     @Override
330     File getRuntimeImageDir(File runtimeImageTop) {
331         File home = new File(runtimeImageTop, &quot;Contents/Home&quot;);
332         return (home.exists() ? home : runtimeImageTop);
333     }
334 
335     private void copyRuntimeFiles(Map&lt;String, ? super Object&gt; params)
336             throws IOException {
337         // Generate Info.plist
338         writeInfoPlist(contentsDir.resolve(&quot;Info.plist&quot;).toFile(), params);
339 
340         // generate java runtime info.plist
341         writeRuntimeInfoPlist(
342                 runtimeDir.resolve(&quot;Contents/Info.plist&quot;).toFile(), params);
343 
344         // copy library
345         Path runtimeMacOSDir = Files.createDirectories(
346                 runtimeDir.resolve(&quot;Contents/MacOS&quot;));
347 
348         // JDK 9, 10, and 11 have extra &#39;/jli/&#39; subdir
349         Path jli = runtimeRoot.resolve(&quot;lib/libjli.dylib&quot;);
350         if (!Files.exists(jli)) {
351             jli = runtimeRoot.resolve(&quot;lib/jli/libjli.dylib&quot;);
352         }
353 
354         Files.copy(jli, runtimeMacOSDir.resolve(&quot;libjli.dylib&quot;));
355     }
356 
357     private void sign(Map&lt;String, ? super Object&gt; params) throws IOException {
358         if (Optional.ofNullable(
359                 SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {
360             try {
361                 addNewKeychain(params);
362             } catch (InterruptedException e) {
363                 Log.error(e.getMessage());
364             }
365             String signingIdentity =
366                     DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);
367             if (signingIdentity != null) {
368                 prepareEntitlements(params);
369                 signAppBundle(params, root, signingIdentity,
370                         BUNDLE_ID_SIGNING_PREFIX.fetchFrom(params),
371                         getConfig_Entitlements(params));
372             }
373             restoreKeychainList(params);
374         }
375     }
376 
377     static File getConfig_Entitlements(Map&lt;String, ? super Object&gt; params) {
378         return new File(CONFIG_ROOT.fetchFrom(params),
379                 getLauncherName(params) + &quot;.entitlements&quot;);
380     }
381 
382     static void prepareEntitlements(Map&lt;String, ? super Object&gt; params)
383             throws IOException {
384         createResource(&quot;entitlements.plist&quot;, params)
385                 .setCategory(I18N.getString(&quot;resource.entitlements&quot;))
386                 .saveToFile(getConfig_Entitlements(params));
387     }
388 
389     private static String getLauncherName(Map&lt;String, ? super Object&gt; params) {
390         if (APP_NAME.fetchFrom(params) != null) {
391             return APP_NAME.fetchFrom(params);
392         } else {
393             return MAIN_CLASS.fetchFrom(params);
394         }
395     }
396 
397     public static String getLauncherCfgName(
398             Map&lt;String, ? super Object&gt; params) {
399         return &quot;Contents/app/&quot; + APP_NAME.fetchFrom(params) + &quot;.cfg&quot;;
400     }
401 
402     private void copyClassPathEntries(Path javaDirectory,
403             Map&lt;String, ? super Object&gt; params) throws IOException {
404         List&lt;RelativeFileSet&gt; resourcesList =
405                 APP_RESOURCES_LIST.fetchFrom(params);
406         if (resourcesList == null) {
407             throw new RuntimeException(
408                     I18N.getString(&quot;message.null-classpath&quot;));
409         }
410 
411         for (RelativeFileSet classPath : resourcesList) {
412             File srcdir = classPath.getBaseDirectory();
413             for (String fname : classPath.getIncludedFiles()) {
414                 copyEntry(javaDirectory, srcdir, fname);
415             }
416         }
417     }
418 
419     private String getBundleName(Map&lt;String, ? super Object&gt; params) {
420         if (MAC_CF_BUNDLE_NAME.fetchFrom(params) != null) {
421             String bn = MAC_CF_BUNDLE_NAME.fetchFrom(params);
422             if (bn.length() &gt; 16) {
423                 Log.error(MessageFormat.format(I18N.getString(
424                         &quot;message.bundle-name-too-long-warning&quot;),
425                         MAC_CF_BUNDLE_NAME.getID(), bn));
426             }
427             return MAC_CF_BUNDLE_NAME.fetchFrom(params);
428         } else if (APP_NAME.fetchFrom(params) != null) {
429             return APP_NAME.fetchFrom(params);
430         } else {
431             String nm = MAIN_CLASS.fetchFrom(params);
432             if (nm.length() &gt; 16) {
433                 nm = nm.substring(0, 16);
434             }
435             return nm;
436         }
437     }
438 
439     private void writeRuntimeInfoPlist(File file,
440             Map&lt;String, ? super Object&gt; params) throws IOException {
441         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
442         String identifier = StandardBundlerParam.isRuntimeInstaller(params) ?
443                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) :
444                 &quot;com.oracle.java.&quot; + MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);
445         data.put(&quot;CF_BUNDLE_IDENTIFIER&quot;, identifier);
446         String name = StandardBundlerParam.isRuntimeInstaller(params) ?
447                 getBundleName(params): &quot;Java Runtime Image&quot;;
448         data.put(&quot;CF_BUNDLE_NAME&quot;, name);
449         data.put(&quot;CF_BUNDLE_VERSION&quot;, VERSION.fetchFrom(params));
450         data.put(&quot;CF_BUNDLE_SHORT_VERSION_STRING&quot;, VERSION.fetchFrom(params));
451 
452         createResource(TEMPLATE_RUNTIME_INFO_PLIST, params)
453                 .setPublicName(&quot;Runtime-Info.plist&quot;)
454                 .setCategory(I18N.getString(&quot;resource.runtime-info-plist&quot;))
455                 .setSubstitutionData(data)
456                 .saveToFile(file);
457     }
458 
459     private void writeInfoPlist(File file, Map&lt;String, ? super Object&gt; params)
460             throws IOException {
461         Log.verbose(MessageFormat.format(I18N.getString(
462                 &quot;message.preparing-info-plist&quot;), file.getAbsolutePath()));
463 
464         //prepare config for exe
465         //Note: do not need CFBundleDisplayName if we don&#39;t support localization
466         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
467         data.put(&quot;DEPLOY_ICON_FILE&quot;, APP_NAME.fetchFrom(params) + &quot;.icns&quot;);
468         data.put(&quot;DEPLOY_BUNDLE_IDENTIFIER&quot;,
469                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params));
470         data.put(&quot;DEPLOY_BUNDLE_NAME&quot;,
471                 getBundleName(params));
472         data.put(&quot;DEPLOY_BUNDLE_COPYRIGHT&quot;,
473                 COPYRIGHT.fetchFrom(params) != null ?
474                 COPYRIGHT.fetchFrom(params) : &quot;Unknown&quot;);
475         data.put(&quot;DEPLOY_LAUNCHER_NAME&quot;, getLauncherName(params));
476         data.put(&quot;DEPLOY_BUNDLE_SHORT_VERSION&quot;,
477                 VERSION.fetchFrom(params) != null ?
478                 VERSION.fetchFrom(params) : &quot;1.0.0&quot;);
479         data.put(&quot;DEPLOY_BUNDLE_CFBUNDLE_VERSION&quot;,
480                 MAC_CF_BUNDLE_VERSION.fetchFrom(params) != null ?
481                 MAC_CF_BUNDLE_VERSION.fetchFrom(params) : &quot;100&quot;);
482 
483         boolean hasMainJar = MAIN_JAR.fetchFrom(params) != null;
484         boolean hasMainModule =
485                 StandardBundlerParam.MODULE.fetchFrom(params) != null;
486 
487         if (hasMainJar) {
488             data.put(&quot;DEPLOY_MAIN_JAR_NAME&quot;, MAIN_JAR.fetchFrom(params).
489                     getIncludedFiles().iterator().next());
490         }
491         else if (hasMainModule) {
492             data.put(&quot;DEPLOY_MODULE_NAME&quot;,
493                     StandardBundlerParam.MODULE.fetchFrom(params));
494         }
495 
496         StringBuilder sb = new StringBuilder();
497         List&lt;String&gt; jvmOptions = JAVA_OPTIONS.fetchFrom(params);
498 
499         String newline = &quot;&quot;; //So we don&#39;t add extra line after last append
500         for (String o : jvmOptions) {
501             sb.append(newline).append(
502                     &quot;    &lt;string&gt;&quot;).append(o).append(&quot;&lt;/string&gt;&quot;);
503             newline = &quot;\n&quot;;
504         }
505 
506         data.put(&quot;DEPLOY_JAVA_OPTIONS&quot;, sb.toString());
507 
508         sb = new StringBuilder();
509         List&lt;String&gt; args = ARGUMENTS.fetchFrom(params);
510         newline = &quot;&quot;;
511         // So we don&#39;t add unneccessary extra line after last append
512 
513         for (String o : args) {
514             sb.append(newline).append(&quot;    &lt;string&gt;&quot;).append(o).append(
515                     &quot;&lt;/string&gt;&quot;);
516             newline = &quot;\n&quot;;
517         }
518         data.put(&quot;DEPLOY_ARGUMENTS&quot;, sb.toString());
519 
520         newline = &quot;&quot;;
521 
522         data.put(&quot;DEPLOY_LAUNCHER_CLASS&quot;, MAIN_CLASS.fetchFrom(params));
523 
524         data.put(&quot;DEPLOY_APP_CLASSPATH&quot;,
525                   getCfgClassPath(CLASSPATH.fetchFrom(params)));
526 
527         StringBuilder bundleDocumentTypes = new StringBuilder();
528         StringBuilder exportedTypes = new StringBuilder();
529         for (Map&lt;String, ? super Object&gt;
530                 fileAssociation : FILE_ASSOCIATIONS.fetchFrom(params)) {
531 
532             List&lt;String&gt; extensions = FA_EXTENSIONS.fetchFrom(fileAssociation);
533 
534             if (extensions == null) {
535                 Log.verbose(I18N.getString(
536                         &quot;message.creating-association-with-null-extension&quot;));
537             }
538 
539             List&lt;String&gt; mimeTypes = FA_CONTENT_TYPE.fetchFrom(fileAssociation);
540             String itemContentType = MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params)
541                     + &quot;.&quot; + ((extensions == null || extensions.isEmpty())
542                     ? &quot;mime&quot; : extensions.get(0));
543             String description = FA_DESCRIPTION.fetchFrom(fileAssociation);
544             File icon = FA_ICON.fetchFrom(fileAssociation);
545 
546             bundleDocumentTypes.append(&quot;    &lt;dict&gt;\n&quot;)
547                     .append(&quot;      &lt;key&gt;LSItemContentTypes&lt;/key&gt;\n&quot;)
548                     .append(&quot;      &lt;array&gt;\n&quot;)
549                     .append(&quot;        &lt;string&gt;&quot;)
550                     .append(itemContentType)
551                     .append(&quot;&lt;/string&gt;\n&quot;)
552                     .append(&quot;      &lt;/array&gt;\n&quot;)
553                     .append(&quot;\n&quot;)
554                     .append(&quot;      &lt;key&gt;CFBundleTypeName&lt;/key&gt;\n&quot;)
555                     .append(&quot;      &lt;string&gt;&quot;)
556                     .append(description)
557                     .append(&quot;&lt;/string&gt;\n&quot;)
558                     .append(&quot;\n&quot;)
559                     .append(&quot;      &lt;key&gt;LSHandlerRank&lt;/key&gt;\n&quot;)
560                     .append(&quot;      &lt;string&gt;Owner&lt;/string&gt;\n&quot;)
561                             // TODO make a bundler arg
562                     .append(&quot;\n&quot;)
563                     .append(&quot;      &lt;key&gt;CFBundleTypeRole&lt;/key&gt;\n&quot;)
564                     .append(&quot;      &lt;string&gt;Editor&lt;/string&gt;\n&quot;)
565                             // TODO make a bundler arg
566                     .append(&quot;\n&quot;)
567                     .append(&quot;      &lt;key&gt;LSIsAppleDefaultForType&lt;/key&gt;\n&quot;)
568                     .append(&quot;      &lt;true/&gt;\n&quot;)
569                             // TODO make a bundler arg
570                     .append(&quot;\n&quot;);
571 
572             if (icon != null &amp;&amp; icon.exists()) {
573                 bundleDocumentTypes
574                         .append(&quot;      &lt;key&gt;CFBundleTypeIconFile&lt;/key&gt;\n&quot;)
575                         .append(&quot;      &lt;string&gt;&quot;)
576                         .append(icon.getName())
577                         .append(&quot;&lt;/string&gt;\n&quot;);
578             }
579             bundleDocumentTypes.append(&quot;    &lt;/dict&gt;\n&quot;);
580 
581             exportedTypes.append(&quot;    &lt;dict&gt;\n&quot;)
582                     .append(&quot;      &lt;key&gt;UTTypeIdentifier&lt;/key&gt;\n&quot;)
583                     .append(&quot;      &lt;string&gt;&quot;)
584                     .append(itemContentType)
585                     .append(&quot;&lt;/string&gt;\n&quot;)
586                     .append(&quot;\n&quot;)
587                     .append(&quot;      &lt;key&gt;UTTypeDescription&lt;/key&gt;\n&quot;)
588                     .append(&quot;      &lt;string&gt;&quot;)
589                     .append(description)
590                     .append(&quot;&lt;/string&gt;\n&quot;)
591                     .append(&quot;      &lt;key&gt;UTTypeConformsTo&lt;/key&gt;\n&quot;)
592                     .append(&quot;      &lt;array&gt;\n&quot;)
593                     .append(&quot;          &lt;string&gt;public.data&lt;/string&gt;\n&quot;)
594                             //TODO expose this?
595                     .append(&quot;      &lt;/array&gt;\n&quot;)
596                     .append(&quot;\n&quot;);
597 
598             if (icon != null &amp;&amp; icon.exists()) {
599                 exportedTypes.append(&quot;      &lt;key&gt;UTTypeIconFile&lt;/key&gt;\n&quot;)
600                         .append(&quot;      &lt;string&gt;&quot;)
601                         .append(icon.getName())
602                         .append(&quot;&lt;/string&gt;\n&quot;)
603                         .append(&quot;\n&quot;);
604             }
605 
606             exportedTypes.append(&quot;\n&quot;)
607                     .append(&quot;      &lt;key&gt;UTTypeTagSpecification&lt;/key&gt;\n&quot;)
608                     .append(&quot;      &lt;dict&gt;\n&quot;)
609                             // TODO expose via param? .append(
610                             // &quot;        &lt;key&gt;com.apple.ostype&lt;/key&gt;\n&quot;);
611                             // TODO expose via param? .append(
612                             // &quot;        &lt;string&gt;ABCD&lt;/string&gt;\n&quot;)
613                     .append(&quot;\n&quot;);
614 
615             if (extensions != null &amp;&amp; !extensions.isEmpty()) {
616                 exportedTypes.append(
617                         &quot;        &lt;key&gt;public.filename-extension&lt;/key&gt;\n&quot;)
618                         .append(&quot;        &lt;array&gt;\n&quot;);
619 
620                 for (String ext : extensions) {
621                     exportedTypes.append(&quot;          &lt;string&gt;&quot;)
622                             .append(ext)
623                             .append(&quot;&lt;/string&gt;\n&quot;);
624                 }
625                 exportedTypes.append(&quot;        &lt;/array&gt;\n&quot;);
626             }
627             if (mimeTypes != null &amp;&amp; !mimeTypes.isEmpty()) {
628                 exportedTypes.append(&quot;        &lt;key&gt;public.mime-type&lt;/key&gt;\n&quot;)
629                         .append(&quot;        &lt;array&gt;\n&quot;);
630 
631                 for (String mime : mimeTypes) {
632                     exportedTypes.append(&quot;          &lt;string&gt;&quot;)
633                             .append(mime)
634                             .append(&quot;&lt;/string&gt;\n&quot;);
635                 }
636                 exportedTypes.append(&quot;        &lt;/array&gt;\n&quot;);
637             }
638             exportedTypes.append(&quot;      &lt;/dict&gt;\n&quot;)
639                     .append(&quot;    &lt;/dict&gt;\n&quot;);
640         }
641         String associationData;
642         if (bundleDocumentTypes.length() &gt; 0) {
643             associationData =
644                     &quot;\n  &lt;key&gt;CFBundleDocumentTypes&lt;/key&gt;\n  &lt;array&gt;\n&quot;
645                     + bundleDocumentTypes.toString()
646                     + &quot;  &lt;/array&gt;\n\n&quot;
647                     + &quot;  &lt;key&gt;UTExportedTypeDeclarations&lt;/key&gt;\n  &lt;array&gt;\n&quot;
648                     + exportedTypes.toString()
649                     + &quot;  &lt;/array&gt;\n&quot;;
650         } else {
651             associationData = &quot;&quot;;
652         }
653         data.put(&quot;DEPLOY_FILE_ASSOCIATIONS&quot;, associationData);
654 
655         createResource(TEMPLATE_INFO_PLIST_LITE, params)
656                 .setCategory(I18N.getString(&quot;resource.app-info-plist&quot;))
657                 .setSubstitutionData(data)
658                 .setPublicName(&quot;Info.plist&quot;)
659                 .saveToFile(file);
660     }
661 
662     private void writePkgInfo(File file) throws IOException {
663         //hardcoded as it does not seem we need to change it ever
664         String signature = &quot;????&quot;;
665 
666         try (Writer out = Files.newBufferedWriter(file.toPath())) {
667             out.write(OS_TYPE_CODE + signature);
668             out.flush();
669         }
670     }
671 
672     public static void addNewKeychain(Map&lt;String, ? super Object&gt; params)
673                                     throws IOException, InterruptedException {
674         if (Platform.getMajorVersion() &lt; 10 ||
675                 (Platform.getMajorVersion() == 10 &amp;&amp;
676                 Platform.getMinorVersion() &lt; 12)) {
677             // we need this for OS X 10.12+
678             return;
679         }
680 
681         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
682         if (keyChain == null || keyChain.isEmpty()) {
683             return;
684         }
685 
686         // get current keychain list
687         String keyChainPath = new File (keyChain).getAbsolutePath().toString();
688         List&lt;String&gt; keychainList = new ArrayList&lt;&gt;();
689         int ret = IOUtils.getProcessOutput(
690                 keychainList, &quot;security&quot;, &quot;list-keychains&quot;);
691         if (ret != 0) {
692             Log.error(I18N.getString(&quot;message.keychain.error&quot;));
693             return;
694         }
695 
696         boolean contains = keychainList.stream().anyMatch(
697                     str -&gt; str.trim().equals(&quot;\&quot;&quot;+keyChainPath.trim()+&quot;\&quot;&quot;));
698         if (contains) {
699             // keychain is already added in the search list
700             return;
701         }
702 
703         keyChains = new ArrayList&lt;&gt;();
704         // remove &quot;
705         keychainList.forEach((String s) -&gt; {
706             String path = s.trim();
707             if (path.startsWith(&quot;\&quot;&quot;) &amp;&amp; path.endsWith(&quot;\&quot;&quot;)) {
708                 path = path.substring(1, path.length()-1);
709             }
710             keyChains.add(path);
711         });
712 
713         List&lt;String&gt; args = new ArrayList&lt;&gt;();
714         args.add(&quot;security&quot;);
715         args.add(&quot;list-keychains&quot;);
716         args.add(&quot;-s&quot;);
717 
718         args.addAll(keyChains);
719         args.add(keyChain);
720 
721         ProcessBuilder  pb = new ProcessBuilder(args);
722         IOUtils.exec(pb);
723     }
724 
725     public static void restoreKeychainList(Map&lt;String, ? super Object&gt; params)
726             throws IOException{
727         if (Platform.getMajorVersion() &lt; 10 ||
728                 (Platform.getMajorVersion() == 10 &amp;&amp;
729                 Platform.getMinorVersion() &lt; 12)) {
730             // we need this for OS X 10.12+
731             return;
732         }
733 
734         if (keyChains == null || keyChains.isEmpty()) {
735             return;
736         }
737 
738         List&lt;String&gt; args = new ArrayList&lt;&gt;();
739         args.add(&quot;security&quot;);
740         args.add(&quot;list-keychains&quot;);
741         args.add(&quot;-s&quot;);
742 
743         args.addAll(keyChains);
744 
745         ProcessBuilder  pb = new ProcessBuilder(args);
746         IOUtils.exec(pb);
747     }
748 
749     static void signAppBundle(
750             Map&lt;String, ? super Object&gt; params, Path appLocation,
751             String signingIdentity, String identifierPrefix, File entitlements)
752             throws IOException {
753         AtomicReference&lt;IOException&gt; toThrow = new AtomicReference&lt;&gt;();
754         String appExecutable = &quot;/Contents/MacOS/&quot; + APP_NAME.fetchFrom(params);
755         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
756 
757         // sign all dylibs and executables
758         try (Stream&lt;Path&gt; stream = Files.walk(appLocation)) {
759             stream.peek(path -&gt; { // fix permissions
760                 try {
761                     Set&lt;PosixFilePermission&gt; pfp =
762                             Files.getPosixFilePermissions(path);
763                     if (!pfp.contains(PosixFilePermission.OWNER_WRITE)) {
764                         pfp = EnumSet.copyOf(pfp);
765                         pfp.add(PosixFilePermission.OWNER_WRITE);
766                         Files.setPosixFilePermissions(path, pfp);
767                     }
768                 } catch (IOException e) {
769                     Log.verbose(e);
770                 }
771             }).filter(p -&gt; Files.isRegularFile(p) &amp;&amp;
772                       (Files.isExecutable(p) || p.toString().endsWith(&quot;.dylib&quot;))
773                       &amp;&amp; !(p.toString().endsWith(appExecutable)
774                       || p.toString().contains(&quot;/Contents/runtime&quot;)
775                       || p.toString().contains(&quot;/Contents/Frameworks&quot;))
776                      ).forEach(p -&gt; {
777                 // noinspection ThrowableResultOfMethodCallIgnored
778                 if (toThrow.get() != null) return;
779 
780                 // If p is a symlink then skip the signing process.
781                 if (Files.isSymbolicLink(p)) {
782                     Log.verbose(MessageFormat.format(I18N.getString(
783                             &quot;message.ignoring.symlink&quot;), p.toString()));
784                 } else if (isFileSigned(p)) {
785                     // executable or lib already signed
786                     Log.verbose(MessageFormat.format(I18N.getString(
787                             &quot;message.already.signed&quot;), p.toString()));
788                 } else {
789                     List&lt;String&gt; args = new ArrayList&lt;&gt;();
790                     args.addAll(Arrays.asList(&quot;codesign&quot;,
791                             &quot;--timestamp&quot;,
792                             &quot;--options&quot;, &quot;runtime&quot;,
793                             &quot;-s&quot;, signingIdentity,
794                             &quot;--prefix&quot;, identifierPrefix,
795                             &quot;-vvvv&quot;));
796                     if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
797                         args.add(&quot;--keychain&quot;);
798                         args.add(keyChain);
799                     }
800 
801                     if (Files.isExecutable(p)) {
802                         if (entitlements != null) {
803                             args.add(&quot;--entitlements&quot;);
804                             args.add(entitlements.toString());
805                         }
806                     }
807 
808                     args.add(p.toString());
809 
810                     try {
811                         Set&lt;PosixFilePermission&gt; oldPermissions =
812                                 Files.getPosixFilePermissions(p);
813                         File f = p.toFile();
814                         f.setWritable(true, true);
815 
816                         ProcessBuilder pb = new ProcessBuilder(args);
817 
818                         IOUtils.exec(pb);
819 
820                         Files.setPosixFilePermissions(p, oldPermissions);
821                     } catch (IOException ioe) {
822                         toThrow.set(ioe);
823                     }
824                 }
825             });
826         }
827         IOException ioe = toThrow.get();
828         if (ioe != null) {
829             throw ioe;
830         }
831 
832         // sign all runtime and frameworks
833         Consumer&lt;? super Path&gt; signIdentifiedByPList = path -&gt; {
834             //noinspection ThrowableResultOfMethodCallIgnored
835             if (toThrow.get() != null) return;
836 
837             try {
838                 List&lt;String&gt; args = new ArrayList&lt;&gt;();
839                 args.addAll(Arrays.asList(&quot;codesign&quot;,
840                         &quot;--timestamp&quot;,
841                         &quot;--options&quot;, &quot;runtime&quot;,
842                         &quot;--force&quot;,
843                         &quot;-s&quot;, signingIdentity, // sign with this key
844                         &quot;--prefix&quot;, identifierPrefix,
845                         // use the identifier as a prefix
846                         &quot;-vvvv&quot;));
847 
848                 if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
849                     args.add(&quot;--keychain&quot;);
850                     args.add(keyChain);
851                 }
852                 args.add(path.toString());
853                 ProcessBuilder pb = new ProcessBuilder(args);
854 
855                 IOUtils.exec(pb);
856             } catch (IOException e) {
857                 toThrow.set(e);
858             }
859         };
860 
861         Path javaPath = appLocation.resolve(&quot;Contents/runtime&quot;);
862         if (Files.isDirectory(javaPath)) {
863             signIdentifiedByPList.accept(javaPath);
864 
865             ioe = toThrow.get();
866             if (ioe != null) {
867                 throw ioe;
868             }
869         }
870         Path frameworkPath = appLocation.resolve(&quot;Contents/Frameworks&quot;);
871         if (Files.isDirectory(frameworkPath)) {
872             Files.list(frameworkPath)
873                     .forEach(signIdentifiedByPList);
874 
875             ioe = toThrow.get();
876             if (ioe != null) {
877                 throw ioe;
878             }
879         }
880 
881         // sign the app itself
882         List&lt;String&gt; args = new ArrayList&lt;&gt;();
883         args.addAll(Arrays.asList(&quot;codesign&quot;,
884                 &quot;--timestamp&quot;,
885                 &quot;--options&quot;, &quot;runtime&quot;,
886                 &quot;--force&quot;,
887                 &quot;-s&quot;, signingIdentity,
888                 &quot;-vvvv&quot;));
889 
890         if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
891             args.add(&quot;--keychain&quot;);
892             args.add(keyChain);
893         }
894 
895         if (entitlements != null) {
896             args.add(&quot;--entitlements&quot;);
897             args.add(entitlements.toString());
898         }
899 
900         args.add(appLocation.toString());
901 
902         ProcessBuilder pb =
903                 new ProcessBuilder(args.toArray(new String[args.size()]));
904 
905         IOUtils.exec(pb);
906     }
907 
908     private static boolean isFileSigned(Path file) {
909         ProcessBuilder pb =
910                 new ProcessBuilder(&quot;codesign&quot;, &quot;--verify&quot;, file.toString());
911 
912         try {
913             IOUtils.exec(pb);
914         } catch (IOException ex) {
915             return false;
916         }
917 
918         return true;
919     }
920 
921     private static String extractBundleIdentifier(Map&lt;String, Object&gt; params) {
922         if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {
923             return null;
924         }
925 
926         try {
927             File infoPList = new File(PREDEFINED_APP_IMAGE.fetchFrom(params) +
928                                       File.separator + &quot;Contents&quot; +
929                                       File.separator + &quot;Info.plist&quot;);
930 
931             DocumentBuilderFactory dbf
932                     = DocumentBuilderFactory.newDefaultInstance();
933             dbf.setFeature(&quot;http://apache.org/xml/features/&quot; +
934                            &quot;nonvalidating/load-external-dtd&quot;, false);
935             DocumentBuilder b = dbf.newDocumentBuilder();
936             org.w3c.dom.Document doc = b.parse(new FileInputStream(
937                     infoPList.getAbsolutePath()));
938 
939             XPath xPath = XPathFactory.newInstance().newXPath();
940             // Query for the value of &lt;string&gt; element preceding &lt;key&gt;
941             // element with value equal to CFBundleIdentifier
942             String v = (String) xPath.evaluate(
943                     &quot;//string[preceding-sibling::key = \&quot;CFBundleIdentifier\&quot;][1]&quot;,
944                     doc, XPathConstants.STRING);
945 
946             if (v != null &amp;&amp; !v.isEmpty()) {
947                 return v;
948             }
949         } catch (Exception ex) {
950             Log.verbose(ex);
951         }
952 
953         return null;
954     }
955 
956 }
    </pre>
  </body>
</html>
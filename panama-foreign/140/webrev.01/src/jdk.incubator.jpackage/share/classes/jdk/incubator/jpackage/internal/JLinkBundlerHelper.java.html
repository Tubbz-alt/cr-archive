<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/JLinkBundlerHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.StringReader;
 31 import java.io.PrintWriter;
 32 import java.io.StringWriter;
 33 import java.nio.file.Files;
 34 import java.nio.file.Path;
 35 import java.text.MessageFormat;
 36 import java.util.ArrayList;
 37 import java.util.Collection;
 38 import java.util.Collections;
 39 import java.util.EnumSet;
 40 import java.util.HashMap;
 41 import java.util.HashSet;
 42 import java.util.Iterator;
 43 import java.util.LinkedHashMap;
 44 import java.util.LinkedHashSet;
 45 import java.util.List;
 46 import java.util.Map;
 47 import java.util.Properties;
 48 import java.util.ResourceBundle;
 49 import java.util.Set;
 50 import java.util.Optional;
 51 import java.util.Arrays;
 52 import java.util.stream.Collectors;
 53 import java.util.stream.Stream;
 54 import java.util.regex.Matcher;
 55 import java.util.spi.ToolProvider;
 56 import java.util.jar.JarFile;
 57 import java.lang.module.Configuration;
 58 import java.lang.module.ResolvedModule;
 59 import java.lang.module.ModuleDescriptor;
 60 import java.lang.module.ModuleFinder;
 61 import java.lang.module.ModuleReference;
 62 import jdk.internal.module.ModulePath;
 63 
 64 
 65 final class JLinkBundlerHelper {
 66 
 67     private static final ResourceBundle I18N = ResourceBundle.getBundle(
 68             &quot;jdk.incubator.jpackage.internal.resources.MainResources&quot;);
 69 
 70     static final ToolProvider JLINK_TOOL =
 71             ToolProvider.findFirst(&quot;jlink&quot;).orElseThrow();
 72 
 73     static File getMainJar(Map&lt;String, ? super Object&gt; params) {
 74         File result = null;
 75         RelativeFileSet fileset =
 76                 StandardBundlerParam.MAIN_JAR.fetchFrom(params);
 77 
 78         if (fileset != null) {
 79             String filename = fileset.getIncludedFiles().iterator().next();
 80             result = fileset.getBaseDirectory().toPath().
 81                     resolve(filename).toFile();
 82 
 83             if (result == null || !result.exists()) {
 84                 String srcdir =
 85                     StandardBundlerParam.SOURCE_DIR.fetchFrom(params);
 86 
 87                 if (srcdir != null) {
 88                     result = new File(srcdir + File.separator + filename);
 89                 }
 90             }
 91         }
 92 
 93         return result;
 94     }
 95 
 96     static String getMainClassFromModule(Map&lt;String, ? super Object&gt; params) {
 97         String mainModule = StandardBundlerParam.MODULE.fetchFrom(params);
 98         if (mainModule != null)  {
 99 
100             int index = mainModule.indexOf(&quot;/&quot;);
101             if (index &gt; 0) {
102                 return mainModule.substring(index + 1);
103             } else {
104                 ModuleDescriptor descriptor =
105                         JLinkBundlerHelper.getMainModuleDescription(params);
106                 if (descriptor != null) {
107                     Optional&lt;String&gt; mainClass = descriptor.mainClass();
108                     if (mainClass.isPresent()) {
109                         Log.verbose(MessageFormat.format(I18N.getString(
110                                     &quot;message.module-class&quot;),
111                                     mainClass.get(),
112                                     JLinkBundlerHelper.getMainModule(params)));
113                         return mainClass.get();
114                     }
115                 }
116             }
117         }
118         return null;
119     }
120 
121     static String getMainModule(Map&lt;String, ? super Object&gt; params) {
122         String result = null;
123         String mainModule = StandardBundlerParam.MODULE.fetchFrom(params);
124 
125         if (mainModule != null) {
126             int index = mainModule.indexOf(&quot;/&quot;);
127 
128             if (index &gt; 0) {
129                 result = mainModule.substring(0, index);
130             } else {
131                 result = mainModule;
132             }
133         }
134 
135         return result;
136     }
137 
138     static void execute(Map&lt;String, ? super Object&gt; params,
139             AbstractAppImageBuilder imageBuilder)
140             throws IOException, Exception {
141 
142         List&lt;Path&gt; modulePath =
143                 StandardBundlerParam.MODULE_PATH.fetchFrom(params);
144         Set&lt;String&gt; addModules =
145                 StandardBundlerParam.ADD_MODULES.fetchFrom(params);
146         Set&lt;String&gt; limitModules =
147                 StandardBundlerParam.LIMIT_MODULES.fetchFrom(params);
148         List&lt;String&gt; options =
149                 StandardBundlerParam.JLINK_OPTIONS.fetchFrom(params);
150         Path outputDir = imageBuilder.getRuntimeRoot();
151         File mainJar = getMainJar(params);
152         ModFile.ModType mainJarType = ModFile.ModType.Unknown;
153 
154         if (mainJar != null) {
155             mainJarType = new ModFile(mainJar).getModType();
156         } else if (StandardBundlerParam.MODULE.fetchFrom(params) == null) {
157             // user specified only main class, all jars will be on the classpath
158             mainJarType = ModFile.ModType.UnnamedJar;
159         }
160 
161         boolean bindServices =
162                 StandardBundlerParam.BIND_SERVICES.fetchFrom(params);
163 
164         // Modules
165         String mainModule = getMainModule(params);
166         if (mainModule == null) {
167             if (mainJarType == ModFile.ModType.UnnamedJar) {
168                 if (addModules.isEmpty()) {
169                     // The default for an unnamed jar is ALL_DEFAULT
170                     addModules.add(ModuleHelper.ALL_DEFAULT);
171                 }
172             } else if (mainJarType == ModFile.ModType.Unknown ||
173                     mainJarType == ModFile.ModType.ModularJar) {
174                 addModules.add(ModuleHelper.ALL_DEFAULT);
175             }
176         }
177 
178         Set&lt;String&gt; modules = new ModuleHelper(
179                 modulePath, addModules, limitModules).modules();
180 
181         if (mainModule != null) {
182             modules.add(mainModule);
183         }
184 
185         runJLink(outputDir, modulePath, modules, limitModules,
186                 options, bindServices);
187 
188         imageBuilder.prepareApplicationFiles(params);
189     }
190 
191 
192     // Returns the path to the JDK modules in the user defined module path.
193     static Path findPathOfModule( List&lt;Path&gt; modulePath, String moduleName) {
194 
195         for (Path path : modulePath) {
196             Path moduleNamePath = path.resolve(moduleName);
197 
198             if (Files.exists(moduleNamePath)) {
199                 return path;
200             }
201         }
202 
203         return null;
204     }
205 
206     static ModuleDescriptor getMainModuleDescription(Map&lt;String, ? super Object&gt; params) {
207         boolean hasModule = params.containsKey(StandardBundlerParam.MODULE.getID());
208         if (hasModule) {
209             List&lt;Path&gt; modulePath = StandardBundlerParam.MODULE_PATH.fetchFrom(params);
210             if (!modulePath.isEmpty()) {
211                 ModuleFinder finder = ModuleFinder.of(modulePath.toArray(new Path[0]));
212                 String mainModule = JLinkBundlerHelper.getMainModule(params);
213                 Optional&lt;ModuleReference&gt; omref = finder.find(mainModule);
214                 if (omref.isPresent()) {
215                     return omref.get().descriptor();
216                 }
217             }
218         }
219 
220         return null;
221     }
222 
223     /*
224      * Returns the set of modules that would be visible by default for
225      * a non-modular-aware application consisting of the given elements.
226      */
227     private static Set&lt;String&gt; getDefaultModules(
228             Collection&lt;Path&gt; paths, Collection&lt;String&gt; addModules) {
229 
230         // the modules in the run-time image that export an API
231         Stream&lt;String&gt; systemRoots = ModuleFinder.ofSystem().findAll().stream()
232                 .map(ModuleReference::descriptor)
233                 .filter(JLinkBundlerHelper::exportsAPI)
234                 .map(ModuleDescriptor::name);
235 
236         Set&lt;String&gt; roots = Stream.concat(systemRoots,
237                  addModules.stream()).collect(Collectors.toSet());
238 
239         ModuleFinder finder = createModuleFinder(paths);
240 
241         return Configuration.empty()
242                 .resolveAndBind(finder, ModuleFinder.of(), roots)
243                 .modules()
244                 .stream()
245                 .map(ResolvedModule::name)
246                 .collect(Collectors.toSet());
247     }
248 
249     /*
250      * Returns true if the given module exports an API to all module.
251      */
252     private static boolean exportsAPI(ModuleDescriptor descriptor) {
253         return descriptor.exports()
254                 .stream()
255                 .anyMatch(e -&gt; !e.isQualified());
256     }
257 
258     private static ModuleFinder createModuleFinder(Collection&lt;Path&gt; modulePath) {
259         return ModuleFinder.compose(
260                 ModulePath.of(JarFile.runtimeVersion(), true,
261                         modulePath.toArray(Path[]::new)),
262                 ModuleFinder.ofSystem());
263     }
264 
265     private static class ModuleHelper {
266         // The token for &quot;all modules on the module path&quot;.
267         private static final String ALL_MODULE_PATH = &quot;ALL-MODULE-PATH&quot;;
268 
269         // The token for &quot;all valid runtime modules&quot;.
270         static final String ALL_DEFAULT = &quot;ALL-DEFAULT&quot;;
271 
272         private final Set&lt;String&gt; modules = new HashSet&lt;&gt;();
273         ModuleHelper(List&lt;Path&gt; paths, Set&lt;String&gt; addModules,
274                 Set&lt;String&gt; limitModules) {
275             boolean addAllModulePath = false;
276             boolean addDefaultMods = false;
277 
278             for (Iterator&lt;String&gt; iterator = addModules.iterator();
279                     iterator.hasNext();) {
280                 String module = iterator.next();
281 
282                 switch (module) {
283                     case ALL_MODULE_PATH:
284                         iterator.remove();
285                         addAllModulePath = true;
286                         break;
287                     case ALL_DEFAULT:
288                         iterator.remove();
289                         addDefaultMods = true;
290                         break;
291                     default:
292                         this.modules.add(module);
293                 }
294             }
295 
296             if (addAllModulePath) {
297                 this.modules.addAll(getModuleNamesFromPath(paths));
298             } else if (addDefaultMods) {
299                 this.modules.addAll(getDefaultModules(
300                         paths, addModules));
301             }
302         }
303 
304         Set&lt;String&gt; modules() {
305             return modules;
306         }
307 
308         private static Set&lt;String&gt; getModuleNamesFromPath(List&lt;Path&gt; paths) {
309 
310             return createModuleFinder(paths)
311                     .findAll()
312                     .stream()
313                     .map(ModuleReference::descriptor)
314                     .map(ModuleDescriptor::name)
315                     .collect(Collectors.toSet());
316         }
317     }
318 
319     private static void runJLink(Path output, List&lt;Path&gt; modulePath,
320             Set&lt;String&gt; modules, Set&lt;String&gt; limitModules,
321             List&lt;String&gt; options, boolean bindServices)
322             throws PackagerException {
323 
324         // This is just to ensure jlink is given a non-existant directory
325         // The passed in output path should be non-existant or empty directory
326         try {
327             IOUtils.deleteRecursive(output.toFile());
328         } catch (IOException ioe) {
329             throw new PackagerException(ioe);
330         }
331 
332         ArrayList&lt;String&gt; args = new ArrayList&lt;String&gt;();
333         args.add(&quot;--output&quot;);
334         args.add(output.toString());
335         if (modulePath != null &amp;&amp; !modulePath.isEmpty()) {
336             args.add(&quot;--module-path&quot;);
337             args.add(getPathList(modulePath));
338         }
339         if (modules != null &amp;&amp; !modules.isEmpty()) {
340             args.add(&quot;--add-modules&quot;);
341             args.add(getStringList(modules));
342         }
343         if (limitModules != null &amp;&amp; !limitModules.isEmpty()) {
344             args.add(&quot;--limit-modules&quot;);
345             args.add(getStringList(limitModules));
346         }
347         if (options != null) {
348             for (String option : options) {
349                 if (option.startsWith(&quot;--output&quot;) ||
350                         option.startsWith(&quot;--add-modules&quot;) ||
351                         option.startsWith(&quot;--module-path&quot;)) {
352                     throw new PackagerException(&quot;error.blocked.option&quot;, option);
353                 }
354                 args.add(option);
355             }
356         }
357         if (bindServices) {
358             args.add(&quot;--bind-services&quot;);
359         }
360 
361         StringWriter writer = new StringWriter();
362         PrintWriter pw = new PrintWriter(writer);
363 
364         Log.verbose(&quot;jlink arguments: &quot; + args);
365         int retVal = JLINK_TOOL.run(pw, pw, args.toArray(new String[0]));
366         String jlinkOut = writer.toString();
367 
368         if (retVal != 0) {
369             throw new PackagerException(&quot;error.jlink.failed&quot; , jlinkOut);
370         } else if (jlinkOut.length() &gt; 0) {
371             Log.verbose(&quot;jlink output: &quot; + jlinkOut);
372         }
373     }
374 
375     private static String getPathList(List&lt;Path&gt; pathList) {
376         String ret = null;
377         for (Path p : pathList) {
378             String s =  Matcher.quoteReplacement(p.toString());
379             if (ret == null) {
380                 ret = s;
381             } else {
382                 ret += File.pathSeparator +  s;
383             }
384         }
385         return ret;
386     }
387 
388     private static String getStringList(Set&lt;String&gt; strings) {
389         String ret = null;
390         for (String s : strings) {
391             if (ret == null) {
392                 ret = s;
393             } else {
394                 ret += &quot;,&quot; + s;
395             }
396         }
397         return (ret == null) ? null : Matcher.quoteReplacement(ret);
398     }
399 }
    </pre>
  </body>
</html>
diff a/src/jdk.incubator.jpackage/windows/native/libjpackage/WindowsRegistry.cpp b/src/jdk.incubator.jpackage/windows/native/libjpackage/WindowsRegistry.cpp
--- a/src/jdk.incubator.jpackage/windows/native/libjpackage/WindowsRegistry.cpp
+++ b/src/jdk.incubator.jpackage/windows/native/libjpackage/WindowsRegistry.cpp
@@ -21,21 +21,54 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-#include <Windows.h>
-#include <tchar.h>
-#include <strsafe.h>
-#include <jni.h>
-
-#include "Utils.h"
+#include "JniUtils.h"
+#include "FileUtils.h"
+#include "ErrorHandling.h"
 
 #pragma comment(lib, "advapi32")
 
-// Max value name size per MSDN plus NULL
-#define VALUE_NAME_SIZE 16384
+namespace {
+
+std::wstring GetLongPath(const std::wstring& path) {
+    const std::wstring cleanPath = FileUtils::removeTrailingSlash(path);
+    if (cleanPath.size() != path.size()) {
+        return GetLongPath(cleanPath);
+    }
+
+    enum { BUFFER_SIZE = 4096 };
+
+    std::wstring result;
+
+    TCHAR *pBuffer = new TCHAR[BUFFER_SIZE];
+    if (pBuffer != NULL) {
+        DWORD dwResult = GetLongPathName(path.c_str(), pBuffer, BUFFER_SIZE);
+        if (dwResult > 0 && dwResult < BUFFER_SIZE) {
+            result = std::wstring(pBuffer);
+        } else {
+            delete [] pBuffer;
+            pBuffer = new TCHAR[dwResult];
+            if (pBuffer != NULL) {
+                DWORD dwResult2 =
+                        GetLongPathName(path.c_str(), pBuffer, dwResult);
+                if (dwResult2 == (dwResult - 1)) {
+                    result = std::wstring(pBuffer);
+                }
+            }
+        }
+
+        if (pBuffer != NULL) {
+            delete [] pBuffer;
+        }
+    }
+
+    return result;
+}
+
+} // namespace
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 #undef jdk_incubator_jpackage_internal_WindowsRegistry_HKEY_LOCAL_MACHINE
@@ -50,16 +83,18 @@
             Java_jdk_incubator_jpackage_internal_WindowsRegistry_readDwordValue(
             JNIEnv *pEnv, jclass c, jint key, jstring jSubKey,
             jstring jValue, jint defaultValue) {
         jint jResult = defaultValue;
 
+        JP_TRY;
+
         if (key != jdk_incubator_jpackage_internal_WindowsRegistry_HKEY_LOCAL_MACHINE) {
-            return jResult;
+            JP_THROW("Inavlid Windows registry key id");
         }
 
-        wstring subKey = GetStringFromJString(pEnv, jSubKey);
-        wstring value = GetStringFromJString(pEnv, jValue);
+        const std::wstring subKey = jni::toUnicodeString(pEnv, jSubKey);
+        const std::wstring value = jni::toUnicodeString(pEnv, jValue);
 
         HKEY hSubKey = NULL;
         LSTATUS status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, subKey.c_str(), 0,
                 KEY_QUERY_VALUE, &hSubKey);
         if (status == ERROR_SUCCESS) {
@@ -72,10 +107,12 @@
             }
 
             RegCloseKey(hSubKey);
         }
 
+        JP_CATCH_ALL;
+
         return jResult;
     }
 
     /*
      * Class:     jdk_incubator_jpackage_internal_WindowsRegistry
@@ -83,22 +120,27 @@
      * Signature: (ILjava/lang/String;)J
      */
     JNIEXPORT jlong JNICALL
             Java_jdk_incubator_jpackage_internal_WindowsRegistry_openRegistryKey(
             JNIEnv *pEnv, jclass c, jint key, jstring jSubKey) {
+
+        JP_TRY;
+
         if (key != jdk_incubator_jpackage_internal_WindowsRegistry_HKEY_LOCAL_MACHINE) {
-            return 0;
+            JP_THROW("Inavlid Windows registry key id");
         }
 
-        wstring subKey = GetStringFromJString(pEnv, jSubKey);
+        const std::wstring subKey = jni::toUnicodeString(pEnv, jSubKey);
         HKEY hSubKey = NULL;
         LSTATUS status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, subKey.c_str(), 0,
                 KEY_QUERY_VALUE, &hSubKey);
         if (status == ERROR_SUCCESS) {
             return (jlong)hSubKey;
         }
 
+        JP_CATCH_ALL;
+
         return 0;
     }
 
     /*
      * Class:     jdk_incubator_jpackage_internal_WindowsRegistry
@@ -106,23 +148,31 @@
      * Signature: (JI)Ljava/lang/String;
      */
     JNIEXPORT jstring JNICALL
             Java_jdk_incubator_jpackage_internal_WindowsRegistry_enumRegistryValue(
             JNIEnv *pEnv, jclass c, jlong lKey, jint jIndex) {
+
+        JP_TRY;
+
+        // Max value name size per MSDN plus NULL
+        enum { VALUE_NAME_SIZE = 16384 };
+
         HKEY hKey = (HKEY)lKey;
         TCHAR valueName[VALUE_NAME_SIZE] = {0}; // Max size per MSDN plus NULL
         DWORD cchValueName = VALUE_NAME_SIZE;
         LSTATUS status = RegEnumValue(hKey, (DWORD)jIndex, valueName,
                 &cchValueName, NULL, NULL, NULL, NULL);
         if (status == ERROR_SUCCESS) {
             size_t chLength = 0;
             if (StringCchLength(valueName, VALUE_NAME_SIZE, &chLength)
                     == S_OK) {
-                return GetJStringFromString(pEnv, valueName, (jsize)chLength);
+                return jni::toJString(pEnv, std::wstring(valueName, chLength));
             }
         }
 
+        JP_CATCH_ALL;
+
         return NULL;
     }
 
     /*
      * Class:     jdk_incubator_jpackage_internal_WindowsRegistry
@@ -142,28 +192,29 @@
      * Signature: (Ljava/lang/String;Ljava/lang/String;)Z
      */
      JNIEXPORT jboolean JNICALL
             Java_jdk_incubator_jpackage_internal_WindowsRegistry_comparePaths(
             JNIEnv *pEnv, jclass c, jstring jPath1, jstring jPath2) {
-         wstring path1 = GetStringFromJString(pEnv, jPath1);
-         wstring path2 = GetStringFromJString(pEnv, jPath2);
+
+         JP_TRY;
+
+         std::wstring path1 = jni::toUnicodeString(pEnv, jPath1);
+         std::wstring path2 = jni::toUnicodeString(pEnv, jPath2);
 
          path1 = GetLongPath(path1);
          path2 = GetLongPath(path2);
 
-         if (path1.length() == 0 || path2.length() == 0) {
-             return JNI_FALSE;
-         }
-
-         if (path1.length() != path2.length()) {
+         if (path1.empty() || path2.empty()) {
              return JNI_FALSE;
          }
 
-         if (_tcsnicmp(path1.c_str(), path2.c_str(), path1.length()) == 0) {
+         if (tstrings::equals(path1, path2, tstrings::IGNORE_CASE)) {
              return JNI_TRUE;
          }
 
+         JP_CATCH_ALL;
+
          return JNI_FALSE;
      }
 
 #ifdef __cplusplus
 }

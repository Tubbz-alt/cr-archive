<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/windows/native/libjpackage/VersionInfo.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;sstream&gt;
 27 #include &lt;iomanip&gt;
 28 #include &quot;VersionInfo.h&quot;
 29 #include &quot;ResourceEditor.h&quot;
 30 #include &quot;ErrorHandling.h&quot;
 31 #include &quot;Toolbox.h&quot;
 32 
 33 
 34 VersionInfo::VersionInfo() {
 35 
 36 }
 37 
 38 namespace {
 39 
 40 class FixedFileVersion {
 41 public:
 42     FixedFileVersion(const std::wstring&amp; value) {
 43         if (4 != swscanf_s(value.c_str(), L&quot;%d.%d.%d.%d&quot;, components + 0,
 44                 components + 1, components + 2, components + 3)) {
 45             JP_THROW(tstrings::any()
 46                     &lt;&lt; &quot;Malformed file version value: [&quot;
 47                     &lt;&lt; value
 48                     &lt;&lt; &quot;]&quot;);
 49             forEach(components, [&amp;value](int component) -&gt; void {
 50                 if (USHRT_MAX &lt; component) {
 51                     JP_THROW(tstrings::any()
 52                         &lt;&lt; &quot;Invalid file version value: [&quot;
 53                         &lt;&lt; value
 54                         &lt;&lt; &quot;]&quot;);
 55                 }
 56             });
 57         }
 58     }
 59 
 60     void apply(DWORD&amp; ms, DWORD&amp; ls) const {
 61         ms = MAKELONG(components[1], components[0]);
 62         ls = MAKELONG(components[3], components[2]);
 63     }
 64 
 65 private:
 66     int components[4];
 67 };
 68 
 69 
 70 std::ostream&amp; writeWORD(std::ostream&amp; cout, size_t v) {
 71     if (USHRT_MAX &lt; v) {
 72         JP_THROW(&quot;Invalid WORD value&quot;);
 73     }
 74     return cout.write(reinterpret_cast&lt;const char*&gt;(&amp;v), sizeof(WORD));
 75 }
 76 
 77 
 78 std::ostream&amp; writeDWORD(std::ostream&amp; cout, size_t v) {
 79     if (UINT_MAX &lt; v) {
 80         JP_THROW(&quot;Invalid DWORD value&quot;);
 81     }
 82 
 83     return cout.write(reinterpret_cast&lt;const char*&gt;(&amp;v), sizeof(DWORD));
 84 }
 85 
 86 
 87 std::ostream&amp; write(std::ostream&amp; cout, const VS_FIXEDFILEINFO&amp; v) {
 88     return cout.write(reinterpret_cast&lt;const char*&gt;(&amp;v), sizeof(v));
 89 }
 90 
 91 std::ostream&amp; write(std::ostream&amp; cout, const std::wstring&amp; s) {
 92     return cout.write(reinterpret_cast&lt;const char*&gt;(s.c_str()),
 93             (s.size() + 1 /* trailing 0 */) * sizeof(wchar_t));
 94 }
 95 
 96 void add32bitPadding(std::ostream&amp; cout) {
 97     enum { WordAlign = 2 };
 98     const std::streampos pos = cout.tellp();
 99     if (pos % 2) {
100         JP_THROW(&quot;Invalid data written in the stream&quot;);
101     }
102     const int padding = WordAlign - (pos / 2) % WordAlign;
103     if (WordAlign != padding) {
104         for (int i = 0; i &lt; padding; ++i) {
105             writeWORD(cout, 0);
106         }
107     }
108 }
109 
110 
111 class StreamSize {
112 public:
113     StreamSize(std::ostream&amp; out): stream(out), anchor(out.tellp()) {
114         writeWORD(stream, 0); // placeholder
115     }
116 
117     ~StreamSize() {
118         JP_TRY;
119 
120         const std::streampos curPos = stream.tellp();
121         const std::streampos size = curPos - anchor;
122         stream.seekp(anchor);
123         if (size &lt; 0) {
124             JP_THROW(&quot;Invalid negative size value&quot;);
125         }
126         writeWORD(stream, (size_t) size);
127         stream.seekp(curPos);
128 
129         JP_CATCH_ALL;
130     }
131 
132 private:
133     std::ostream&amp; stream;
134     std::streampos anchor;
135 };
136 
137 } // namespace
138 
139 VersionInfo&amp; VersionInfo::setProperty(
140         const std::wstring&amp; id, const std::wstring&amp; value) {
141     props[id] = value;
142 
143     if (id == L&quot;FIXEDFILEINFO_FileVersion&quot;) {
144         // Validate input
145         const ::FixedFileVersion validate(value);
146     }
147     return *this;
148 }
149 
150 
151 const VersionInfo&amp; VersionInfo::apply(
152         const ResourceEditor::FileLock&amp; fileLock) const {
153     if (props.find(L&quot;FIXEDFILEINFO_FileVersion&quot;) == props.end()) {
154         JP_THROW(&quot;Missing mandatory FILEVERSION property&quot;);
155     }
156 
157     std::stringstream buf(
158             std::stringstream::in | std::stringstream::out | std::stringstream::binary);
159     buf.exceptions(std::ios::failbit | std::ios::badbit);
160 
161     fillBuffer(buf);
162 
163     buf.seekg(0);
164 
165     ResourceEditor()
166         .id(MAKEINTRESOURCE(VS_VERSION_INFO))
167         .type(RT_VERSION)
168         .apply(fileLock, buf);
169     return *this;
170 }
171 
172 
173 void VersionInfo::fillBuffer(std::ostream&amp; buf) const {
174     // Fill VS_VERSIONINFO pseudo structure
175     StreamSize versionInfoLength(buf); // wLength
176     writeWORD(buf, sizeof(VS_FIXEDFILEINFO)); // wValueLength
177     writeWORD(buf, 0); // wType
178     write(buf, L&quot;VS_VERSION_INFO&quot;); // szKey
179     add32bitPadding(buf); // Padding1
180     write(buf, createFIXEDFILEINFO()); // Value
181     add32bitPadding(buf); // Padding2
182 
183     const DWORD neutralLangId = (0x04b0 | MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) &lt;&lt; 16);
184     const DWORD engLangId = (0x04b0 | MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) &lt;&lt; 16);
185 
186     do {
187         // Fill StringFileInfo pseudo structure
188         StreamSize stringFileInfoLength(buf); // wLength
189         writeWORD(buf, 0); // wValueLength
190         writeWORD(buf, 1); // wType
191         write(buf, L&quot;StringFileInfo&quot;); // szKey
192         add32bitPadding(buf); // Padding
193 
194         // Fill StringTable pseudo structure
195         StreamSize stringTableLength(buf); // wLength
196         writeWORD(buf, 0); // wValueLength
197         writeWORD(buf, 1); // wType
198 
199         const std::wstring strLangId = (std::wstringstream()
200             &lt;&lt; std::uppercase
201             &lt;&lt; std::hex
202             &lt;&lt; std::setw(8)
203             &lt;&lt; std::setfill(L&#39;0&#39;)
204             &lt;&lt; engLangId).str();
205         write(buf, strLangId); // szKey
206         add32bitPadding(buf); // Padding
207 
208         forEach(props, [&amp;buf](const PropertyMap::value_type&amp; entry) -&gt; void {
209             if (entry.first.rfind(L&quot;FIXEDFILEINFO_&quot;, 0) == 0) {
210                 // Ignore properties to be used to initialize data in
211                 // VS_FIXEDFILEINFO structure.
212                 return;
213             }
214 
215             // Fill String pseudo structure
216             StreamSize stringLength(buf); // wLength
217             writeWORD(buf, entry.second.size()); // wValueLength
218             writeWORD(buf, 1); // wType
219             write(buf, entry.first); // wKey
220             add32bitPadding(buf); // Padding1
221             write(buf, entry.second); // Value
222             add32bitPadding(buf); // Padding2
223         });
224     } while (0);
225 
226     // Fill VarFileInfo pseudo structure
227     StreamSize varFileInfoLength(buf); // wLength
228     writeWORD(buf, 0); // wValueLength
229     writeWORD(buf, 1); // wType
230     write(buf, L&quot;VarFileInfo&quot;); // szKey
231     add32bitPadding(buf); // Padding
232 
233     // Fill Var pseudo structure
234     StreamSize varLength(buf); // wLength
235     writeWORD(buf, sizeof(DWORD)); // wValueLength
236     writeWORD(buf, 0); // wType
237     write(buf, L&quot;Translation&quot;); // szKey
238     add32bitPadding(buf); // Padding
239     writeDWORD(buf, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)); // Value
240 }
241 
242 
243 VS_FIXEDFILEINFO VersionInfo::createFIXEDFILEINFO() const {
244     const ::FixedFileVersion fileVersion(props.find(
245             L&quot;FIXEDFILEINFO_FileVersion&quot;)-&gt;second);
246 
247     VS_FIXEDFILEINFO result;
248     ZeroMemory(&amp;result, sizeof(result));
249 
250     result.dwSignature = 0xFEEF04BD;
251     result.dwStrucVersion = 0x00010000;
252     result.dwFileOS = VOS_NT_WINDOWS32;
253     result.dwFileType = VFT_APP;
254 
255     fileVersion.apply(result.dwFileVersionMS, result.dwFileVersionLS);
256 
257     PropertyMap::const_iterator entry = props.find(
258             L&quot;FIXEDFILEINFO_ProductVersion&quot;);
259     if (entry == props.end()) {
260         fileVersion.apply(result.dwProductVersionMS, result.dwProductVersionLS);
261     } else {
262         bool fatalError = false;
263         try {
264             const ::FixedFileVersion productVersion(entry-&gt;second);
265             fatalError = true;
266             productVersion.apply(result.dwProductVersionMS,
267                     result.dwProductVersionLS);
268         } catch (const std::exception&amp;) {
269             if (fatalError) {
270                 throw;
271             }
272             // Failed to parse product version as four component version string.
273             fileVersion.apply(result.dwProductVersionMS,
274                     result.dwProductVersionLS);
275         }
276     }
277 
278     return result;
279 }
    </pre>
  </body>
</html>
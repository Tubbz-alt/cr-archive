<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.formats.html;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Collections;
 30 import java.util.List;
 31 import java.util.Map;
 32 import java.util.Set;
 33 import java.util.SortedSet;
 34 import java.util.TreeMap;
 35 import java.util.TreeSet;
 36 
 37 import javax.lang.model.element.Element;
 38 import javax.lang.model.element.ModuleElement;
 39 import javax.lang.model.element.PackageElement;
 40 import javax.lang.model.element.TypeElement;
 41 import javax.lang.model.util.ElementFilter;
 42 
 43 import com.sun.source.doctree.DocTree;
 44 import jdk.javadoc.doclet.DocletEnvironment.ModuleMode;
 45 import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;
 46 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
 47 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 48 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 49 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
 50 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 51 import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;
 52 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
 53 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
 54 import jdk.javadoc.internal.doclets.formats.html.markup.Table;
 55 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
 56 import jdk.javadoc.internal.doclets.toolkit.Content;
 57 import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;
 58 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 59 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 60 
 61 /**
 62  * Class to generate file for each module contents in the right-hand frame. This will list all the
 63  * required modules, packages and service types for the module. A click on any of the links will update
 64  * the frame with the clicked element page.
 65  *
 66  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 67  *  If you write code that depends on this, you do so at your own risk.
 68  *  This code and its internal interfaces are subject to change or
 69  *  deletion without notice.&lt;/b&gt;
 70  */
 71 public class ModuleWriterImpl extends HtmlDocletWriter implements ModuleSummaryWriter {
 72 
 73     /**
 74      * The module being documented.
 75      */
 76     protected ModuleElement mdle;
 77 
 78     /**
 79      * The module mode for this javadoc run. It can be set to &quot;api&quot; or &quot;all&quot;.
 80      */
 81     private final ModuleMode moduleMode;
 82 
 83     /**
 84      * Map of module elements and modifiers required by this module.
 85      */
 86     private final Map&lt;ModuleElement, Content&gt; requires
 87             = new TreeMap&lt;&gt;(comparators.makeModuleComparator());
 88 
 89     /**
 90      * Map of indirect modules and modifiers, transitive closure, required by this module.
 91      */
 92     private final Map&lt;ModuleElement, Content&gt; indirectModules
 93             = new TreeMap&lt;&gt;(comparators.makeModuleComparator());
 94 
 95     /**
 96      * Details about a package in a module.
 97      * A package may be not exported, or exported to some modules, or exported to all modules.
 98      * A package may be not opened, or opened to some modules, or opened to all modules.
 99      * A package that is neither exported or opened to any modules is a concealed package.
100      * An open module opens all its packages to all modules.
101      */
102     class PackageEntry {
103         /**
104          * Summary of package exports:
105          * If null, the package is not exported to any modules;
106          * if empty, the package is exported to all modules;
107          * otherwise, the package is exported to these modules.
108          */
109         Set&lt;ModuleElement&gt; exportedTo;
110 
111         /**
112          * Summary of package opens:
113          * If null, the package is not opened to any modules;
114          * if empty, the package is opened to all modules;
115          * otherwise, the package is opened to these modules.
116          */
117         Set&lt;ModuleElement&gt; openedTo;
118     }
119 
120     /**
121      * Map of packages of this module, and details of whether they are exported or opened.
122      */
123     private final Map&lt;PackageElement, PackageEntry&gt; packages = new TreeMap&lt;&gt;(utils.comparators.makePackageComparator());
124 
125     /**
126      * Map of indirect modules (transitive closure) and their exported packages.
127      */
128     private final Map&lt;ModuleElement, SortedSet&lt;PackageElement&gt;&gt; indirectPackages
129             = new TreeMap&lt;&gt;(comparators.makeModuleComparator());
130 
131     /**
132      * Map of indirect modules (transitive closure) and their open packages.
133      */
134     private final Map&lt;ModuleElement, SortedSet&lt;PackageElement&gt;&gt; indirectOpenPackages
135             = new TreeMap&lt;&gt;(comparators.makeModuleComparator());
136 
137     /**
138      * Set of services used by the module.
139      */
140     private final SortedSet&lt;TypeElement&gt; uses
141             = new TreeSet&lt;&gt;(comparators.makeAllClassesComparator());
142 
143     /**
144      * Map of services used by the module and specified using @uses javadoc tag, and description.
145      */
146     private final Map&lt;TypeElement, Content&gt; usesTrees
147             = new TreeMap&lt;&gt;(comparators.makeAllClassesComparator());
148 
149     /**
150      * Map of services provided by this module, and set of its implementations.
151      */
152     private final Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; provides
153             = new TreeMap&lt;&gt;(comparators.makeAllClassesComparator());
154 
155     /**
156      * Map of services provided by the module and specified using @provides javadoc tag, and
157      * description.
158      */
159     private final Map&lt;TypeElement, Content&gt; providesTrees
160             = new TreeMap&lt;&gt;(comparators.makeAllClassesComparator());
161 
162     private final Navigation navBar;
163 
164     private final BodyContents bodyContents = new BodyContents();
165 
166     /**
167      * Constructor to construct ModuleWriter object and to generate &quot;moduleName-summary.html&quot; file.
168      *
169      * @param configuration the configuration of the doclet.
170      * @param mdle        Module under consideration.
171      */
172     public ModuleWriterImpl(HtmlConfiguration configuration, ModuleElement mdle) {
173         super(configuration, configuration.docPaths.moduleSummary(mdle));
174         this.mdle = mdle;
175         this.moduleMode = configuration.docEnv.getModuleMode();
176         this.navBar = new Navigation(mdle, configuration, PageMode.MODULE, path);
177         computeModulesData();
178     }
179 
180     /**
181      * Get the module header.
182      *
183      * @param heading the heading for the section
184      */
185     @Override
186     public Content getModuleHeader(String heading) {
187         HtmlTree bodyTree = getBody(getWindowTitle(mdle.getQualifiedName().toString()));
188         Content headerContent = new ContentBuilder();
189         addTop(headerContent);
190         navBar.setDisplaySummaryModuleDescLink(!utils.getFullBody(mdle).isEmpty() &amp;&amp; !options.noComment());
191         navBar.setDisplaySummaryModulesLink(display(requires) || display(indirectModules));
192         navBar.setDisplaySummaryPackagesLink(display(packages) || display(indirectPackages)
193                 || display(indirectOpenPackages));
194         navBar.setDisplaySummaryServicesLink(displayServices(uses, usesTrees) || displayServices(provides.keySet(), providesTrees));
195         navBar.setUserHeader(getUserHeaderFooter(true));
196         headerContent.add(navBar.getContent(Navigation.Position.TOP));
197         HtmlTree div = new HtmlTree(TagName.DIV);
198         div.setStyle(HtmlStyle.header);
199         Content annotationContent = new HtmlTree(TagName.P);
200         addAnnotationInfo(mdle, annotationContent);
201         div.add(annotationContent);
202         Content label = mdle.isOpen() &amp;&amp; (configuration.docEnv.getModuleMode() == ModuleMode.ALL)
203                 ? contents.openModuleLabel : contents.moduleLabel;
204         Content tHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,
205                 HtmlStyle.title, label);
206         tHeading.add(Entity.NO_BREAK_SPACE);
207         Content moduleHead = new RawHtml(heading);
208         tHeading.add(moduleHead);
209         div.add(tHeading);
210         bodyContents.setHeader(headerContent)
211                 .addMainContent(div);
212         return bodyTree;
213     }
214 
215     /**
216      * Get the content header.
217      */
218     @Override
219     public Content getContentHeader() {
220         return new ContentBuilder();
221     }
222 
223     /**
224      * Get the summary section header.
225      */
226     @Override
227     public Content getSummariesList() {
228         return new HtmlTree(TagName.UL).setStyle(HtmlStyle.summaryList);
229     }
230 
231     /**
232      * Get the summary tree.
233      *
234      * @param summaryContentTree the content tree to be added to the summary tree.
235      */
236     @Override
237     public Content getSummaryTree(Content summaryContentTree) {
238         return HtmlTree.SECTION(HtmlStyle.summary, summaryContentTree);
239     }
240 
241     /**
242      * Compute the modules data that will be displayed in various tables on the module summary page.
243      */
244     public void computeModulesData() {
245         CommentHelper ch = utils.getCommentHelper(mdle);
246         // Get module dependencies using the module&#39;s transitive closure.
247         Map&lt;ModuleElement, String&gt; dependentModules = utils.getDependentModules(mdle);
248         // Add all dependent modules to indirect modules set. We will remove the modules,
249         // listed using the requires directive, from this set to come up with the table of indirect
250         // required modules.
251         dependentModules.forEach((module, mod) -&gt; {
252             if (shouldDocument(module)) {
253                 indirectModules.put(module, new StringContent(mod));
254             }
255         });
256         ElementFilter.requiresIn(mdle.getDirectives()).forEach(directive -&gt; {
257             ModuleElement m = directive.getDependency();
258             if (shouldDocument(m)) {
259                 if (moduleMode == ModuleMode.ALL || directive.isTransitive()) {
260                     requires.put(m, new StringContent(utils.getModifiers(directive)));
261                 } else {
262                     // For api mode, just keep the public requires in dependentModules for display of
263                     // indirect packages in the &quot;Packages&quot; section.
264                     dependentModules.remove(m);
265                 }
266                 indirectModules.remove(m);
267             }
268         });
269 
270         // Get all packages if module is open or if displaying concealed modules
271         for (PackageElement pkg : utils.getModulePackageMap().getOrDefault(mdle, Collections.emptySet())) {
272             if (shouldDocument(pkg) &amp;&amp; (mdle.isOpen() || moduleMode == ModuleMode.ALL)) {
273                 PackageEntry e = new PackageEntry();
274                 if (mdle.isOpen()) {
275                     e.openedTo = Collections.emptySet();
276                 }
277                 packages.put(pkg, e);
278             }
279         }
280 
281         // Get all exported packages for the module, using the exports directive for the module.
282         for (ModuleElement.ExportsDirective directive : ElementFilter.exportsIn(mdle.getDirectives())) {
283             PackageElement p = directive.getPackage();
284             if (shouldDocument(p)) {
285                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
286                 // Include package if in details mode, or exported to all (i.e. targetModules == null)
287                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
288                     PackageEntry packageEntry = packages.computeIfAbsent(p, pkg -&gt; new PackageEntry());
289                     SortedSet&lt;ModuleElement&gt; mdleList = new TreeSet&lt;&gt;(utils.comparators.makeModuleComparator());
290                     if (targetMdles != null) {
291                         mdleList.addAll(targetMdles);
292                     }
293                     packageEntry.exportedTo = mdleList;
294                 }
295             }
296         }
297 
298         // Get all opened packages for the module, using the opens directive for the module.
299         // If it is an open module, there will be no separate opens directives.
300         for (ModuleElement.OpensDirective directive : ElementFilter.opensIn(mdle.getDirectives())) {
301             PackageElement p = directive.getPackage();
302             if (shouldDocument(p)) {
303                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
304                 // Include package if in details mode, or opened to all (i.e. targetModules == null)
305                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
306                     PackageEntry packageEntry = packages.computeIfAbsent(p, pkg -&gt; new PackageEntry());
307                     SortedSet&lt;ModuleElement&gt; mdleList = new TreeSet&lt;&gt;(utils.comparators.makeModuleComparator());
308                     if (targetMdles != null) {
309                         mdleList.addAll(targetMdles);
310                     }
311                     packageEntry.openedTo = mdleList;
312                 }
313             }
314         }
315 
316         // Get all the exported and opened packages, for the transitive closure of the module, to be displayed in
317         // the indirect packages tables.
318         dependentModules.forEach((module, mod) -&gt; {
319             SortedSet&lt;PackageElement&gt; exportedPackages = new TreeSet&lt;&gt;(utils.comparators.makePackageComparator());
320             ElementFilter.exportsIn(module.getDirectives()).forEach(directive -&gt; {
321                 PackageElement pkg = directive.getPackage();
322                 if (shouldDocument(pkg)) {
323                     // Qualified exports are not displayed in API mode
324                     if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
325                         exportedPackages.add(pkg);
326                     }
327                 }
328             });
329             // If none of the indirect modules have exported packages to be displayed, we should not be
330             // displaying the table and so it should not be added to the map.
331             if (!exportedPackages.isEmpty()) {
332                 indirectPackages.put(module, exportedPackages);
333             }
334             SortedSet&lt;PackageElement&gt; openPackages = new TreeSet&lt;&gt;(utils.comparators.makePackageComparator());
335             if (module.isOpen()) {
336                 openPackages.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));
337             } else {
338                 ElementFilter.opensIn(module.getDirectives()).forEach(directive -&gt; {
339                     PackageElement pkg = directive.getPackage();
340                     if (shouldDocument(pkg)) {
341                         // Qualified opens are not displayed in API mode
342                         if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
343                             openPackages.add(pkg);
344                         }
345                     }
346                 });
347             }
348             // If none of the indirect modules have opened packages to be displayed, we should not be
349             // displaying the table and so it should not be added to the map.
350             if (!openPackages.isEmpty()) {
351                 indirectOpenPackages.put(module, openPackages);
352             }
353         });
354         // Get all the services listed as uses directive.
355         ElementFilter.usesIn(mdle.getDirectives()).forEach(directive -&gt; {
356             TypeElement u = directive.getService();
357             if (shouldDocument(u)) {
358                 uses.add(u);
359             }
360         });
361         // Get all the services and implementations listed as provides directive.
362         ElementFilter.providesIn(mdle.getDirectives()).forEach(directive -&gt; {
363             TypeElement u = directive.getService();
364             if (shouldDocument(u)) {
365                 List&lt;? extends TypeElement&gt; implList = directive.getImplementations();
366                 SortedSet&lt;TypeElement&gt; implSet = new TreeSet&lt;&gt;(utils.comparators.makeAllClassesComparator());
367                 implSet.addAll(implList);
368                 provides.put(u, implSet);
369             }
370         });
371         // Generate the map of all services listed using @provides, and the description.
372         utils.getBlockTags(mdle, DocTree.Kind.PROVIDES).forEach(tree -&gt; {
373             TypeElement t = ch.getServiceType(tree);
374             if (t != null) {
375                 providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
376             }
377         });
378         // Generate the map of all services listed using @uses, and the description.
379         utils.getBlockTags(mdle, DocTree.Kind.USES).forEach(tree -&gt; {
380             TypeElement t = ch.getServiceType(tree);
381             if (t != null) {
382                 usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
383             }
384         });
385     }
386 
387     /**
388      * Returns true if the element should be documented on the module summary page.
389      *
390      * @param element the element to be checked
391      * @return true if the element should be documented
392      */
393     public boolean shouldDocument(Element element) {
394         return (moduleMode == ModuleMode.ALL || utils.isIncluded(element));
395     }
396 
397     /**
398      * Returns true if there are elements to be displayed.
399      *
400      * @param section set of elements
401      * @return true if there are elements to be displayed
402      */
403     public boolean display(Set&lt;? extends Element&gt; section) {
404         return section != null &amp;&amp; !section.isEmpty();
405     }
406 
407     /**
408      * Returns true if there are elements to be displayed.
409      *
410      * @param section map of elements.
411      * @return true if there are elements to be displayed
412      */
413     public boolean display(Map&lt;? extends Element, ?&gt; section) {
414         return section != null &amp;&amp; !section.isEmpty();
415     }
416 
417     /*
418      * Returns true, in API mode, if at least one type element in
419      * the typeElements set is referenced by a javadoc tag in tagsMap.
420      */
421     private boolean displayServices(Set&lt;TypeElement&gt; typeElements,
422                                     Map&lt;TypeElement, Content&gt; tagsMap) {
423         return typeElements != null &amp;&amp;
424                 typeElements.stream().anyMatch(v -&gt; displayServiceDirective(v, tagsMap));
425     }
426 
427     /*
428      * Returns true, in API mode, if the type element is referenced
429      * from a javadoc tag in tagsMap.
430      */
431     private boolean displayServiceDirective(TypeElement typeElement,
432                                             Map&lt;TypeElement, Content&gt; tagsMap) {
433         return moduleMode == ModuleMode.ALL || tagsMap.containsKey(typeElement);
434     }
435 
436     /**
437      * Add the summary header.
438      *
439      * @param startMarker the marker comment
440      * @param heading the heading for the section
441      * @param htmltree the content tree to which the information is added
442      */
443     public void addSummaryHeader(Content startMarker, Content heading,
444             Content htmltree) {
445         htmltree.add(startMarker);
446         htmltree.add(HtmlTree.HEADING(Headings.ModuleDeclaration.SUMMARY_HEADING, heading));
447     }
448 
449     /**
450      * Get a table, with two columns.
451      *
452      * @param caption the table caption
453      * @param tableStyle the table style
454      * @param tableHeader the table header
455      * @return a content object
456      */
457     private Table getTable2(Content caption, HtmlStyle tableStyle,
458             TableHeader tableHeader) {
459         return new Table(tableStyle)
460                 .setCaption(caption)
461                 .setHeader(tableHeader)
462                 .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);
463     }
464 
465     /**
466      * Get a table, with three columns, with the second column being the defining column.
467      *
468      * @param caption the table caption
469      * @param tableSummary the summary for the table
470      * @param tableStyle the table style
471      * @param tableHeader the table header
472      * @return a content object
473      */
474     private Table getTable3(Content caption, String tableSummary, HtmlStyle tableStyle,
475             TableHeader tableHeader) {
476         return new Table(tableStyle)
477                 .setCaption(caption)
478                 .setHeader(tableHeader)
479                 .setRowScopeColumn(1)
480                 .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);
481     }
482 
483     @Override
484     public void addModulesSummary(Content summariesList) {
485         if (display(requires) || display(indirectModules)) {
486             TableHeader requiresTableHeader =
487                     new TableHeader(contents.modifierLabel, contents.moduleLabel,
488                             contents.descriptionLabel);
489             HtmlTree section = HtmlTree.SECTION(HtmlStyle.modulesSummary)
490                     .setId(SectionName.MODULES.getName());
491             addSummaryHeader(MarkerComments.START_OF_MODULES_SUMMARY, contents.navModules, section);
492             if (display(requires)) {
493                 String text = resources.getText(&quot;doclet.Requires_Summary&quot;);
494                 String tableSummary = resources.getText(&quot;doclet.Member_Table_Summary&quot;,
495                         text,
496                         resources.getText(&quot;doclet.modules&quot;));
497                 Content caption = getTableCaption(new StringContent(text));
498                 Table table = getTable3(caption, tableSummary, HtmlStyle.requiresSummary,
499                             requiresTableHeader);
500                 addModulesList(requires, table);
501                 section.add(table);
502             }
503             // Display indirect modules table in both &quot;api&quot; and &quot;all&quot; mode.
504             if (display(indirectModules)) {
505                 String amrText = resources.getText(&quot;doclet.Indirect_Requires_Summary&quot;);
506                 String amrTableSummary = resources.getText(&quot;doclet.Member_Table_Summary&quot;,
507                         amrText,
508                         resources.getText(&quot;doclet.modules&quot;));
509                 Content amrCaption = getTableCaption(new StringContent(amrText));
510                 Table amrTable = getTable3(amrCaption, amrTableSummary, HtmlStyle.requiresSummary,
511                             requiresTableHeader);
512                 addModulesList(indirectModules, amrTable);
513                 section.add(amrTable);
514             }
515             summariesList.add(HtmlTree.LI(section));
516         }
517     }
518 
519     /**
520      * Add the list of modules.
521      *
522      * @param mdleMap map of modules and modifiers
523      * @param table the table to which the list will be added
524      */
525     private void addModulesList(Map&lt;ModuleElement, Content&gt; mdleMap, Table table) {
526         for (ModuleElement m : mdleMap.keySet()) {
527             Content modifiers = mdleMap.get(m);
528             Content moduleLink = getModuleLink(m, new StringContent(m.getQualifiedName()));
529             Content moduleSummary = new ContentBuilder();
530             addSummaryComment(m, moduleSummary);
531             table.addRow(modifiers, moduleLink, moduleSummary);
532         }
533     }
534 
535     @Override
536     public void addPackagesSummary(Content summariesList) {
537         if (display(packages)
538                 || display(indirectPackages) || display(indirectOpenPackages)) {
539             HtmlTree section = HtmlTree.SECTION(HtmlStyle.packagesSummary)
540                     .setId(SectionName.PACKAGES.getName());;
541             addSummaryHeader(MarkerComments.START_OF_PACKAGES_SUMMARY, contents.navPackages, section);
542             if (display(packages)) {
543                 addPackageSummary(section);
544             }
545             TableHeader indirectPackagesHeader =
546                     new TableHeader(contents.fromLabel, contents.packagesLabel);
547             if (display(indirectPackages)) {
548                 String aepText = resources.getText(&quot;doclet.Indirect_Exports_Summary&quot;);
549                 Table aepTable = getTable2(new StringContent(aepText),
550                         HtmlStyle.packagesSummary, indirectPackagesHeader);
551                 addIndirectPackages(aepTable, indirectPackages);
552                 section.add(aepTable);
553             }
554             if (display(indirectOpenPackages)) {
555                 String aopText = resources.getText(&quot;doclet.Indirect_Opens_Summary&quot;);
556                 Table aopTable = getTable2(new StringContent(aopText), HtmlStyle.packagesSummary,
557                         indirectPackagesHeader);
558                 addIndirectPackages(aopTable, indirectOpenPackages);
559                 section.add(aopTable);
560             }
561             summariesList.add(HtmlTree.LI(section));
562         }
563     }
564 
565     /**
566      * Add the package summary for the module.
567      *
568      * @param li
569      */
570     public void addPackageSummary(HtmlTree li) {
571         Table table = new Table(HtmlStyle.packagesSummary)
572                 .setDefaultTab(resources.getText(&quot;doclet.All_Packages&quot;))
573                 .addTab(resources.getText(&quot;doclet.Exported_Packages_Summary&quot;), this::isExported)
574                 .addTab(resources.getText(&quot;doclet.Opened_Packages_Summary&quot;), this::isOpened)
575                 .addTab(resources.getText(&quot;doclet.Concealed_Packages_Summary&quot;), this::isConcealed)
576                 .setTabScript(i -&gt; String.format(&quot;show(%d);&quot;, i));
577 
578         // Determine whether to show the &quot;Exported To&quot; and &quot;Opened To&quot; columns,
579         // based on whether such columns would provide &quot;useful&quot; info.
580         int numExports = 0;
581         int numUnqualifiedExports = 0;
582         int numOpens = 0;
583         int numUnqualifiedOpens = 0;
584 
585         for (PackageEntry e : packages.values()) {
586             if (e.exportedTo != null) {
587                 numExports++;
588                 if (e.exportedTo.isEmpty()) {
589                     numUnqualifiedExports++;
590                 }
591             }
592             if (e.openedTo != null) {
593                 numOpens++;
594                 if (e.openedTo.isEmpty()) {
595                     numUnqualifiedOpens++;
596                 }
597             }
598         }
599 
600         boolean showExportedTo = numExports &gt; 0 &amp;&amp; (numOpens &gt; 0   || numUnqualifiedExports &lt; packages.size());
601         boolean showOpenedTo   = numOpens &gt; 0   &amp;&amp; (numExports &gt; 0 || numUnqualifiedOpens &lt; packages.size());
602 
603         // Create the table header and column styles.
604         List&lt;Content&gt; colHeaders = new ArrayList&lt;&gt;();
605         List&lt;HtmlStyle&gt; colStyles = new ArrayList&lt;&gt;();
606         colHeaders.add(contents.packageLabel);
607         colStyles.add(HtmlStyle.colFirst);
608 
609         if (showExportedTo) {
610             colHeaders.add(contents.exportedTo);
611             colStyles.add(HtmlStyle.colSecond);
612         }
613 
614         if (showOpenedTo) {
615             colHeaders.add(contents.openedTo);
616             colStyles.add(HtmlStyle.colSecond);
617         }
618 
619         colHeaders.add(contents.descriptionLabel);
620         colStyles.add(HtmlStyle.colLast);
621 
622         table.setHeader(new TableHeader(colHeaders).styles(colStyles))
623                 .setColumnStyles(colStyles);
624 
625         // Add the table rows, based on the &quot;packages&quot; map.
626         for (Map.Entry&lt;PackageElement, PackageEntry&gt; e : packages.entrySet()) {
627             PackageElement pkg = e.getKey();
628             PackageEntry entry = e.getValue();
629             List&lt;Content&gt; row = new ArrayList&lt;&gt;();
630             Content pkgLinkContent = getPackageLink(pkg, new StringContent(utils.getPackageName(pkg)));
631             row.add(pkgLinkContent);
632 
633             if (showExportedTo) {
634                 row.add(getPackageExportOpensTo(entry.exportedTo));
635             }
636             if (showOpenedTo) {
637                 row.add(getPackageExportOpensTo(entry.openedTo));
638             }
639             Content summary = new ContentBuilder();
640             addSummaryComment(pkg, summary);
641             row.add(summary);
642 
643             table.addRow(pkg, row);
644         }
645 
646         li.add(table);
647         if (table.needsScript()) {
648             mainBodyScript.append(table.getScript());
649         }
650     }
651 
652     private boolean isExported(Element e) {
653         PackageEntry entry = packages.get((PackageElement) e);
654         return (entry != null) &amp;&amp; (entry.exportedTo != null);
655     }
656 
657     private boolean isOpened(Element e) {
658         PackageEntry entry = packages.get((PackageElement) e);
659         return (entry != null) &amp;&amp; (entry.openedTo != null);
660     }
661 
662     private boolean isConcealed(Element e) {
663         PackageEntry entry = packages.get((PackageElement) e);
664         return (entry != null) &amp;&amp; (entry.exportedTo == null) &amp;&amp; (entry.openedTo == null);
665     }
666 
667     private Content getPackageExportOpensTo(Set&lt;ModuleElement&gt; modules) {
668         if (modules == null) {
669             return new StringContent(resources.getText(&quot;doclet.None&quot;));
670         } else if (modules.isEmpty()) {
671             return new StringContent(resources.getText(&quot;doclet.All_Modules&quot;));
672         } else {
673             Content list = new ContentBuilder();
674             for (ModuleElement m : modules) {
675                 if (!list.isEmpty()) {
676                     list.add(new StringContent(&quot;, &quot;));
677                 }
678                 list.add(getModuleLink(m, new StringContent(m.getQualifiedName())));
679             }
680             return list;
681         }
682     }
683 
684     /**
685      * Add the indirect packages for the module being documented.
686      *
687      * @param table the table to which the content rows will be added
688      * @param ip indirect packages to be added
689      */
690     public void addIndirectPackages(Table table, Map&lt;ModuleElement, SortedSet&lt;PackageElement&gt;&gt; ip) {
691         for (Map.Entry&lt;ModuleElement, SortedSet&lt;PackageElement&gt;&gt; entry : ip.entrySet()) {
692             ModuleElement m = entry.getKey();
693             SortedSet&lt;PackageElement&gt; pkgList = entry.getValue();
694             Content moduleLinkContent = getModuleLink(m, new StringContent(m.getQualifiedName()));
695             Content list = new ContentBuilder();
696             String sep = &quot;&quot;;
697             for (PackageElement pkg : pkgList) {
698                 list.add(sep);
699                 list.add(getPackageLink(pkg, new StringContent(utils.getPackageName(pkg))));
700                 sep = &quot; &quot;;
701             }
702             table.addRow(moduleLinkContent, list);
703         }
704     }
705 
706     @Override
707     public void addServicesSummary(Content summariesList) {
708 
709         boolean haveUses = displayServices(uses, usesTrees);
710         boolean haveProvides = displayServices(provides.keySet(), providesTrees);
711 
712         if (haveProvides || haveUses) {
713             HtmlTree section = HtmlTree.SECTION(HtmlStyle.servicesSummary)
714                     .setId(SectionName.SERVICES.getName());
715             addSummaryHeader(MarkerComments.START_OF_SERVICES_SUMMARY, contents.navServices, section);
716             TableHeader usesProvidesTableHeader =
717                     new TableHeader(contents.typeLabel, contents.descriptionLabel);
718             if (haveProvides) {
719                 String label = resources.getText(&quot;doclet.Provides_Summary&quot;);
720                 Table table = getTable2(new StringContent(label), HtmlStyle.providesSummary,
721                         usesProvidesTableHeader);
722                 addProvidesList(table);
723                 if (!table.isEmpty()) {
724                     section.add(table);
725                 }
726             }
727             if (haveUses){
728                 String label = resources.getText(&quot;doclet.Uses_Summary&quot;);
729                 Table table = getTable2(new StringContent(label), HtmlStyle.usesSummary,
730                         usesProvidesTableHeader);
731                 addUsesList(table);
732                 if (!table.isEmpty()) {
733                     section.add(table);
734                 }
735             }
736             summariesList.add(HtmlTree.LI(section));
737         }
738     }
739 
740     /**
741      * Add the uses list for the module.
742      *
743      * @param table the table to which the services used will be added
744      */
745     public void addUsesList(Table table) {
746         Content typeLinkContent;
747         Content description;
748         for (TypeElement t : uses) {
749             if (!displayServiceDirective(t, usesTrees)) {
750                 continue;
751             }
752             typeLinkContent = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, t));
753             Content summary = new ContentBuilder();
754             if (display(usesTrees)) {
755                 description = usesTrees.get(t);
756                 if (description != null &amp;&amp; !description.isEmpty()) {
757                     summary.add(HtmlTree.DIV(HtmlStyle.block, description));
758                 } else {
759                     addSummaryComment(t, summary);
760                 }
761             } else {
762                 summary.add(Entity.NO_BREAK_SPACE);
763             }
764             table.addRow(typeLinkContent, summary);
765         }
766     }
767 
768     /**
769      * Add the provides list for the module.
770      *
771      * @param table the table to which the services provided will be added
772      */
773     public void addProvidesList(Table table) {
774         SortedSet&lt;TypeElement&gt; implSet;
775         Content description;
776         for (Map.Entry&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; entry : provides.entrySet()) {
777             TypeElement srv = entry.getKey();
778             if (!displayServiceDirective(srv, providesTrees)) {
779                 continue;
780             }
781             implSet = entry.getValue();
782             Content srvLinkContent = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, srv));
783             Content desc = new ContentBuilder();
784             if (display(providesTrees)) {
785                 description = providesTrees.get(srv);
786                 desc.add((description != null &amp;&amp; !description.isEmpty())
787                         ? HtmlTree.DIV(HtmlStyle.block, description)
788                         : Entity.NO_BREAK_SPACE);
789             } else {
790                 desc.add(Entity.NO_BREAK_SPACE);
791                 }
792             // Only display the implementation details in the &quot;all&quot; mode.
793             if (moduleMode == ModuleMode.ALL &amp;&amp; !implSet.isEmpty()) {
794                 desc.add(new HtmlTree(TagName.BR));
795                 desc.add(&quot;(&quot;);
796                 HtmlTree implSpan = HtmlTree.SPAN(HtmlStyle.implementationLabel, contents.implementation);
797                 desc.add(implSpan);
798                 desc.add(Entity.NO_BREAK_SPACE);
799                 String sep = &quot;&quot;;
800                 for (TypeElement impl : implSet) {
801                     desc.add(sep);
802                     desc.add(getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, impl)));
803                     sep = &quot;, &quot;;
804                 }
805                 desc.add(&quot;)&quot;);
806             }
807             table.addRow(srvLinkContent, desc);
808         }
809     }
810 
811     /**
812      * Add the module deprecation information to the documentation tree.
813      *
814      * @param div the content tree to which the deprecation information will be added
815      */
816     public void addDeprecationInfo(Content div) {
817         List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(mdle, DocTree.Kind.DEPRECATED);
818         if (utils.isDeprecated(mdle)) {
819             CommentHelper ch = utils.getCommentHelper(mdle);
820             HtmlTree deprDiv = new HtmlTree(TagName.DIV);
821             deprDiv.setStyle(HtmlStyle.deprecationBlock);
822             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(mdle));
823             deprDiv.add(deprPhrase);
824             if (!deprs.isEmpty()) {
825                 List&lt;? extends DocTree&gt; commentTags = ch.getDescription(deprs.get(0));
826                 if (!commentTags.isEmpty()) {
827                     addInlineDeprecatedComment(mdle, deprs.get(0), deprDiv);
828                 }
829             }
830             div.add(deprDiv);
831         }
832     }
833 
834     @Override
835     public void addModuleDescription(Content moduleContentTree) {
836         if (!utils.getFullBody(mdle).isEmpty()) {
837             HtmlTree tree = HtmlTree.SECTION(HtmlStyle.moduleDescription);
838             tree.setId(SectionName.MODULE_DESCRIPTION.getName());
839             addDeprecationInfo(tree);
840             tree.add(MarkerComments.START_OF_MODULE_DESCRIPTION);
841             addInlineComment(mdle, tree);
842             moduleContentTree.add(tree);
843         }
844     }
845 
846     @Override
847     public void addModuleTags(Content moduleContentTree) {
848         Content tree = HtmlTree.SECTION(HtmlStyle.moduleTags);
849         addTagsInfo(mdle, tree);
850         moduleContentTree.add(tree);
851     }
852 
853     @Override
854     public void addModuleContent(Content moduleContentTree) {
855         bodyContents.addMainContent(moduleContentTree);
856     }
857 
858     @Override
859     public void addModuleFooter() {
860         Content htmlTree = HtmlTree.FOOTER();
861         navBar.setUserFooter(getUserHeaderFooter(false));
862         htmlTree.add(navBar.getContent(Navigation.Position.BOTTOM));
863         addBottom(htmlTree);
864         bodyContents.setFooter(htmlTree);
865     }
866 
867     @Override
868     public void printDocument(Content contentTree) throws DocFileIOException {
869         contentTree.add(bodyContents);
870         printHtmlDocument(configuration.metakeywords.getMetaKeywordsForModule(mdle),
871                 getDescription(&quot;declaration&quot;, mdle), getLocalStylesheets(mdle), contentTree);
872     }
873 
874     /**
875      * Add the module package deprecation information to the documentation tree.
876      *
877      * @param li the content tree to which the deprecation information will be added
878      * @param pkg the PackageDoc that is added
879      */
880     public void addPackageDeprecationInfo(Content li, PackageElement pkg) {
881         List&lt;? extends DocTree&gt; deprs;
882         if (utils.isDeprecated(pkg)) {
883             deprs = utils.getDeprecatedTrees(pkg);
884             HtmlTree deprDiv = new HtmlTree(TagName.DIV);
885             deprDiv.setStyle(HtmlStyle.deprecationBlock);
886             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(pkg));
887             deprDiv.add(deprPhrase);
888             if (!deprs.isEmpty()) {
889                 CommentHelper ch = utils.getCommentHelper(pkg);
890                 List&lt;? extends DocTree&gt; commentTags = ch.getDescription(deprs.get(0));
891                 if (!commentTags.isEmpty()) {
892                     addInlineDeprecatedComment(pkg, deprs.get(0), deprDiv);
893                 }
894             }
895             li.add(deprDiv);
896         }
897     }
898 }
    </pre>
  </body>
</html>
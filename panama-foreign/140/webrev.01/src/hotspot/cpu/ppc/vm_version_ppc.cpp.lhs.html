<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/vm_version_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2020 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;asm/macroAssembler.inline.hpp&quot;
  30 #include &quot;compiler/disassembler.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/os.hpp&quot;
  34 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  35 #include &quot;runtime/vm_version.hpp&quot;
  36 #include &quot;utilities/align.hpp&quot;
  37 #include &quot;utilities/defaultStream.hpp&quot;
  38 #include &quot;utilities/globalDefinitions.hpp&quot;
  39 #include &quot;utilities/powerOfTwo.hpp&quot;
  40 
  41 #include &lt;sys/sysinfo.h&gt;
  42 #if defined(_AIX)
  43 #include &lt;libperfstat.h&gt;
  44 #endif
  45 
  46 #if defined(LINUX) &amp;&amp; defined(VM_LITTLE_ENDIAN)
  47 #include &lt;sys/auxv.h&gt;
  48 
  49 #ifndef PPC_FEATURE2_HTM_NOSC
  50 #define PPC_FEATURE2_HTM_NOSC (1 &lt;&lt; 24)
  51 #endif
  52 #endif
  53 
  54 bool VM_Version::_is_determine_features_test_running = false;
  55 uint64_t VM_Version::_dscr_val = 0;
  56 
  57 #define MSG(flag)   \
  58   if (flag &amp;&amp; !FLAG_IS_DEFAULT(flag))                                  \
  59       jio_fprintf(defaultStream::error_stream(),                       \
  60                   &quot;warning: -XX:+&quot; #flag &quot; requires -XX:+UseSIGTRAP\n&quot; \
  61                   &quot;         -XX:+&quot; #flag &quot; will be disabled!\n&quot;);
  62 
  63 void VM_Version::initialize() {
  64 
  65   // Test which instructions are supported and measure cache line size.
  66   determine_features();
  67 
  68   // If PowerArchitecturePPC64 hasn&#39;t been specified explicitly determine from features.
  69   if (FLAG_IS_DEFAULT(PowerArchitecturePPC64)) {
  70     if (VM_Version::has_darn()) {
  71       FLAG_SET_ERGO(PowerArchitecturePPC64, 9);
  72     } else if (VM_Version::has_lqarx()) {
  73       FLAG_SET_ERGO(PowerArchitecturePPC64, 8);
  74     } else if (VM_Version::has_popcntw()) {
  75       FLAG_SET_ERGO(PowerArchitecturePPC64, 7);
  76     } else if (VM_Version::has_cmpb()) {
  77       FLAG_SET_ERGO(PowerArchitecturePPC64, 6);
  78     } else if (VM_Version::has_popcntb()) {
  79       FLAG_SET_ERGO(PowerArchitecturePPC64, 5);
  80     } else {
  81       FLAG_SET_ERGO(PowerArchitecturePPC64, 0);
  82     }
  83   }
  84 
  85   bool PowerArchitecturePPC64_ok = false;
  86   switch (PowerArchitecturePPC64) {
  87     case 9: if (!VM_Version::has_darn()   ) break;
  88     case 8: if (!VM_Version::has_lqarx()  ) break;
  89     case 7: if (!VM_Version::has_popcntw()) break;
  90     case 6: if (!VM_Version::has_cmpb()   ) break;
  91     case 5: if (!VM_Version::has_popcntb()) break;
  92     case 0: PowerArchitecturePPC64_ok = true; break;
  93     default: break;
  94   }
  95   guarantee(PowerArchitecturePPC64_ok, &quot;PowerArchitecturePPC64 cannot be set to &quot;
  96             UINTX_FORMAT &quot; on this machine&quot;, PowerArchitecturePPC64);
  97 
  98   // Power 8: Configure Data Stream Control Register.
  99   if (PowerArchitecturePPC64 &gt;= 8 &amp;&amp; has_mfdscr()) {
 100     config_dscr();
 101   }
 102 
 103   if (!UseSIGTRAP) {
 104     MSG(TrapBasedICMissChecks);
 105     MSG(TrapBasedNotEntrantChecks);
 106     MSG(TrapBasedNullChecks);
 107     FLAG_SET_ERGO(TrapBasedNotEntrantChecks, false);
 108     FLAG_SET_ERGO(TrapBasedNullChecks,       false);
 109     FLAG_SET_ERGO(TrapBasedICMissChecks,     false);
 110   }
 111 
 112 #ifdef COMPILER2
 113   if (!UseSIGTRAP) {
 114     MSG(TrapBasedRangeChecks);
 115     FLAG_SET_ERGO(TrapBasedRangeChecks, false);
 116   }
 117 
 118   // On Power6 test for section size.
 119   if (PowerArchitecturePPC64 == 6) {
 120     determine_section_size();
 121   // TODO: PPC port } else {
 122   // TODO: PPC port PdScheduling::power6SectorSize = 0x20;
 123   }
 124 
 125   if (PowerArchitecturePPC64 &gt;= 8) {
 126     if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {
 127       FLAG_SET_ERGO(SuperwordUseVSX, true);
 128     }
 129   } else {
 130     if (SuperwordUseVSX) {
 131       warning(&quot;SuperwordUseVSX specified, but needs at least Power8.&quot;);
 132       FLAG_SET_DEFAULT(SuperwordUseVSX, false);
 133     }
 134   }
 135   MaxVectorSize = SuperwordUseVSX ? 16 : 8;
 136 
 137   if (PowerArchitecturePPC64 &gt;= 9) {
 138     if (FLAG_IS_DEFAULT(UseCountTrailingZerosInstructionsPPC64)) {
 139       FLAG_SET_ERGO(UseCountTrailingZerosInstructionsPPC64, true);
 140     }
 141     if (FLAG_IS_DEFAULT(UseCharacterCompareIntrinsics)) {
 142       FLAG_SET_ERGO(UseCharacterCompareIntrinsics, true);
 143     }
 144     if (FLAG_IS_DEFAULT(UseVectorByteReverseInstructionsPPC64)) {
 145       FLAG_SET_ERGO(UseVectorByteReverseInstructionsPPC64, true);
 146     }
 147   } else {
 148     if (UseCountTrailingZerosInstructionsPPC64) {
 149       warning(&quot;UseCountTrailingZerosInstructionsPPC64 specified, but needs at least Power9.&quot;);
 150       FLAG_SET_DEFAULT(UseCountTrailingZerosInstructionsPPC64, false);
 151     }
 152     if (UseCharacterCompareIntrinsics) {
 153       warning(&quot;UseCharacterCompareIntrinsics specified, but needs at least Power9.&quot;);
 154       FLAG_SET_DEFAULT(UseCharacterCompareIntrinsics, false);
 155     }
 156     if (UseVectorByteReverseInstructionsPPC64) {
 157       warning(&quot;UseVectorByteReverseInstructionsPPC64 specified, but needs at least Power9.&quot;);
 158       FLAG_SET_DEFAULT(UseVectorByteReverseInstructionsPPC64, false);
 159     }
 160   }
 161 #endif
 162 
 163   // Create and print feature-string.
 164   char buf[(num_features+1) * 16]; // Max 16 chars per feature.
 165   jio_snprintf(buf, sizeof(buf),
 166                &quot;ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;,
 167                (has_fsqrt()   ? &quot; fsqrt&quot;   : &quot;&quot;),
 168                (has_isel()    ? &quot; isel&quot;    : &quot;&quot;),
 169                (has_lxarxeh() ? &quot; lxarxeh&quot; : &quot;&quot;),
 170                (has_cmpb()    ? &quot; cmpb&quot;    : &quot;&quot;),
 171                (has_popcntb() ? &quot; popcntb&quot; : &quot;&quot;),
 172                (has_popcntw() ? &quot; popcntw&quot; : &quot;&quot;),
 173                (has_fcfids()  ? &quot; fcfids&quot;  : &quot;&quot;),
 174                (has_vand()    ? &quot; vand&quot;    : &quot;&quot;),
 175                (has_lqarx()   ? &quot; lqarx&quot;   : &quot;&quot;),
 176                (has_vcipher() ? &quot; aes&quot;     : &quot;&quot;),
 177                (has_vpmsumb() ? &quot; vpmsumb&quot; : &quot;&quot;),
 178                (has_mfdscr()  ? &quot; mfdscr&quot;  : &quot;&quot;),
 179                (has_vsx()     ? &quot; vsx&quot;     : &quot;&quot;),
 180                (has_ldbrx()   ? &quot; ldbrx&quot;   : &quot;&quot;),
 181                (has_stdbrx()  ? &quot; stdbrx&quot;  : &quot;&quot;),
 182                (has_vshasig() ? &quot; sha&quot;     : &quot;&quot;),
 183                (has_tm()      ? &quot; rtm&quot;     : &quot;&quot;),
 184                (has_darn()    ? &quot; darn&quot;    : &quot;&quot;)
 185                // Make sure number of %s matches num_features!
 186               );
 187   _features_string = os::strdup(buf);
 188   if (Verbose) {
 189     print_features();
 190   }
 191 
 192   // PPC64 supports 8-byte compare-exchange operations (see Atomic::cmpxchg)
 193   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
 194   _supports_cx8 = true;
 195 
 196   // Used by C1.
 197   _supports_atomic_getset4 = true;
 198   _supports_atomic_getadd4 = true;
 199   _supports_atomic_getset8 = true;
 200   _supports_atomic_getadd8 = true;
 201 
 202   intx cache_line_size = L1_data_cache_line_size();
 203 
 204   if (PowerArchitecturePPC64 &gt;= 9) {
 205     if (os::supports_map_sync() == true) {
 206       _data_cache_line_flush_size = cache_line_size;
 207     }
 208   }
 209 
 210   if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) AllocatePrefetchStyle = 1;
 211 
<a name="1" id="anc1"></a><span class="line-modified"> 212   if (AllocatePrefetchStyle == 4) {</span>
<span class="line-modified"> 213     AllocatePrefetchStepSize = cache_line_size; // Need exact value.</span>
<span class="line-modified"> 214     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 12; // Use larger blocks by default.</span>
<span class="line-modified"> 215     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 2*cache_line_size; // Default is not defined?</span>
<span class="line-removed"> 216   } else {</span>
<span class="line-removed"> 217     if (cache_line_size &gt; AllocatePrefetchStepSize) AllocatePrefetchStepSize = cache_line_size;</span>
<span class="line-removed"> 218     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 3; // Optimistic value.</span>
<span class="line-removed"> 219     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 3*cache_line_size; // Default is not defined?</span>
<span class="line-removed"> 220   }</span>
 221 
 222   assert(AllocatePrefetchLines &gt; 0, &quot;invalid value&quot;);
 223   if (AllocatePrefetchLines &lt; 1) { // Set valid value in product VM.
 224     AllocatePrefetchLines = 1; // Conservative value.
 225   }
 226 
 227   if (AllocatePrefetchStyle == 3 &amp;&amp; AllocatePrefetchDistance &lt; cache_line_size) {
 228     AllocatePrefetchStyle = 1; // Fall back if inappropriate.
 229   }
 230 
 231   assert(AllocatePrefetchStyle &gt;= 0, &quot;AllocatePrefetchStyle should be positive&quot;);
 232 
 233   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp; (cache_line_size &gt; ContendedPaddingWidth)) {
 234     ContendedPaddingWidth = cache_line_size;
 235   }
 236 
 237   // If running on Power8 or newer hardware, the implementation uses the available vector instructions.
 238   // In all other cases, the implementation uses only generally available instructions.
 239   if (!UseCRC32Intrinsics) {
 240     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
 241       FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
 242     }
 243   }
 244 
 245   // Implementation does not use any of the vector instructions available with Power8.
 246   // Their exploitation is still pending (aka &quot;work in progress&quot;).
 247   if (!UseCRC32CIntrinsics) {
 248     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 249       FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
 250     }
 251   }
 252 
 253   // TODO: Provide implementation.
 254   if (UseAdler32Intrinsics) {
 255     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
 256     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
 257   }
 258 
 259   // The AES intrinsic stubs require AES instruction support.
 260   if (has_vcipher()) {
 261     if (FLAG_IS_DEFAULT(UseAES)) {
 262       UseAES = true;
 263     }
 264   } else if (UseAES) {
 265     if (!FLAG_IS_DEFAULT(UseAES))
 266       warning(&quot;AES instructions are not available on this CPU&quot;);
 267     FLAG_SET_DEFAULT(UseAES, false);
 268   }
 269 
 270   if (UseAES &amp;&amp; has_vcipher()) {
 271     if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 272       UseAESIntrinsics = true;
 273     }
 274   } else if (UseAESIntrinsics) {
 275     if (!FLAG_IS_DEFAULT(UseAESIntrinsics))
 276       warning(&quot;AES intrinsics are not available on this CPU&quot;);
 277     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 278   }
 279 
 280   if (UseAESCTRIntrinsics) {
 281     warning(&quot;AES/CTR intrinsics are not available on this CPU&quot;);
 282     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 283   }
 284 
 285   if (UseGHASHIntrinsics) {
 286     warning(&quot;GHASH intrinsics are not available on this CPU&quot;);
 287     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 288   }
 289 
 290   if (FLAG_IS_DEFAULT(UseFMA)) {
 291     FLAG_SET_DEFAULT(UseFMA, true);
 292   }
 293 
 294   if (has_vshasig()) {
 295     if (FLAG_IS_DEFAULT(UseSHA)) {
 296       UseSHA = true;
 297     }
 298   } else if (UseSHA) {
 299     if (!FLAG_IS_DEFAULT(UseSHA))
 300       warning(&quot;SHA instructions are not available on this CPU&quot;);
 301     FLAG_SET_DEFAULT(UseSHA, false);
 302   }
 303 
 304   if (UseSHA1Intrinsics) {
 305     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
 306     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 307   }
 308 
 309   if (UseSHA &amp;&amp; has_vshasig()) {
 310     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
 311       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 312     }
 313   } else if (UseSHA256Intrinsics) {
 314     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 315     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 316   }
 317 
 318   if (UseSHA &amp;&amp; has_vshasig()) {
 319     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 320       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 321     }
 322   } else if (UseSHA512Intrinsics) {
 323     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 324     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 325   }
 326 
 327   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 328     FLAG_SET_DEFAULT(UseSHA, false);
 329   }
 330 
 331 #ifdef COMPILER2
 332   if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
 333     UseSquareToLenIntrinsic = true;
 334   }
 335   if (FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
 336     UseMulAddIntrinsic = true;
 337   }
 338   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
 339     UseMultiplyToLenIntrinsic = true;
 340   }
 341   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
 342     UseMontgomeryMultiplyIntrinsic = true;
 343   }
 344   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
 345     UseMontgomerySquareIntrinsic = true;
 346   }
 347 #endif
 348 
 349   if (UseVectorizedMismatchIntrinsic) {
 350     warning(&quot;UseVectorizedMismatchIntrinsic specified, but not available on this CPU.&quot;);
 351     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
 352   }
 353 
 354 
 355   // Adjust RTM (Restricted Transactional Memory) flags.
 356   if (UseRTMLocking) {
 357     // If CPU or OS do not support TM:
 358     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 359     // setting during arguments processing. See use_biased_locking().
 360     // VM_Version_init() is executed after UseBiasedLocking is used
 361     // in Thread::allocate().
 362     if (PowerArchitecturePPC64 &lt; 8) {
 363       vm_exit_during_initialization(&quot;RTM instructions are not available on this CPU.&quot;);
 364     }
 365 
 366     if (!has_tm()) {
 367       vm_exit_during_initialization(&quot;RTM is not supported on this OS version.&quot;);
 368     }
 369   }
 370 
 371   if (UseRTMLocking) {
 372 #if INCLUDE_RTM_OPT
 373     if (!FLAG_IS_CMDLINE(UseRTMLocking)) {
 374       // RTM locking should be used only for applications with
 375       // high lock contention. For now we do not use it by default.
 376       vm_exit_during_initialization(&quot;UseRTMLocking flag should be only set on command line&quot;);
 377     }
 378 #else
 379     // Only C2 does RTM locking optimization.
 380     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 381     // setting during arguments processing. See use_biased_locking().
 382     vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
 383 #endif
 384   } else { // !UseRTMLocking
 385     if (UseRTMForStackLocks) {
 386       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
 387         warning(&quot;UseRTMForStackLocks flag should be off when UseRTMLocking flag is off&quot;);
 388       }
 389       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
 390     }
 391     if (UseRTMDeopt) {
 392       FLAG_SET_DEFAULT(UseRTMDeopt, false);
 393     }
 394 #ifdef COMPILER2
 395     if (PrintPreciseRTMLockingStatistics) {
 396       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
 397     }
 398 #endif
 399   }
 400 
 401   // This machine allows unaligned memory accesses
 402   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
 403     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
 404   }
 405 
 406   check_virtualizations();
 407 }
 408 
 409 void VM_Version::check_virtualizations() {
 410 #if defined(_AIX)
 411   int rc = 0;
 412   perfstat_partition_total_t pinfo;
 413   rc = perfstat_partition_total(NULL, &amp;pinfo, sizeof(perfstat_partition_total_t), 1);
 414   if (rc == 1) {
 415     Abstract_VM_Version::_detected_virtualization = PowerVM;
 416   }
 417 #else
 418   const char* info_file = &quot;/proc/ppc64/lparcfg&quot;;
 419   // system_type=...qemu indicates PowerKVM
 420   // e.g. system_type=IBM pSeries (emulated by qemu)
 421   char line[500];
 422   FILE* fp = fopen(info_file, &quot;r&quot;);
 423   if (fp == NULL) {
 424     return;
 425   }
 426   const char* system_type=&quot;system_type=&quot;;  // in case this line contains qemu, it is KVM
 427   const char* num_lpars=&quot;NumLpars=&quot;; // in case of non-KVM : if this line is found it is PowerVM
 428   bool num_lpars_found = false;
 429 
 430   while (fgets(line, sizeof(line), fp) != NULL) {
 431     if (strncmp(line, system_type, strlen(system_type)) == 0) {
 432       if (strstr(line, &quot;qemu&quot;) != 0) {
 433         Abstract_VM_Version::_detected_virtualization = PowerKVM;
 434         fclose(fp);
 435         return;
 436       }
 437     }
 438     if (strncmp(line, num_lpars, strlen(num_lpars)) == 0) {
 439       num_lpars_found = true;
 440     }
 441   }
 442   if (num_lpars_found) {
 443     Abstract_VM_Version::_detected_virtualization = PowerVM;
 444   } else {
 445     Abstract_VM_Version::_detected_virtualization = PowerFullPartitionMode;
 446   }
 447   fclose(fp);
 448 #endif
 449 }
 450 
 451 void VM_Version::print_platform_virtualization_info(outputStream* st) {
 452 #if defined(_AIX)
 453   // more info about perfstat API see
 454   // https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/com.ibm.aix.prftools/idprftools_perfstat_glob_partition.htm
 455   int rc = 0;
 456   perfstat_partition_total_t pinfo;
 457   memset(&amp;pinfo, 0, sizeof(perfstat_partition_total_t));
 458   rc = perfstat_partition_total(NULL, &amp;pinfo, sizeof(perfstat_partition_total_t), 1);
 459   if (rc != 1) {
 460     return;
 461   } else {
 462     st-&gt;print_cr(&quot;Virtualization type   : PowerVM&quot;);
 463   }
 464   // CPU information
 465   perfstat_cpu_total_t cpuinfo;
 466   memset(&amp;cpuinfo, 0, sizeof(perfstat_cpu_total_t));
 467   rc = perfstat_cpu_total(NULL, &amp;cpuinfo, sizeof(perfstat_cpu_total_t), 1);
 468   if (rc != 1) {
 469     return;
 470   }
 471 
 472   st-&gt;print_cr(&quot;Processor description : %s&quot;, cpuinfo.description);
 473   st-&gt;print_cr(&quot;Processor speed       : %llu Hz&quot;, cpuinfo.processorHZ);
 474 
 475   st-&gt;print_cr(&quot;LPAR partition name           : %s&quot;, pinfo.name);
 476   st-&gt;print_cr(&quot;LPAR partition number         : %u&quot;, pinfo.lpar_id);
 477   st-&gt;print_cr(&quot;LPAR partition type           : %s&quot;, pinfo.type.b.shared_enabled ? &quot;shared&quot; : &quot;dedicated&quot;);
 478   st-&gt;print_cr(&quot;LPAR mode                     : %s&quot;, pinfo.type.b.donate_enabled ? &quot;donating&quot; : pinfo.type.b.capped ? &quot;capped&quot; : &quot;uncapped&quot;);
 479   st-&gt;print_cr(&quot;LPAR partition group ID       : %u&quot;, pinfo.group_id);
 480   st-&gt;print_cr(&quot;LPAR shared pool ID           : %u&quot;, pinfo.pool_id);
 481 
 482   st-&gt;print_cr(&quot;AMS (active memory sharing)   : %s&quot;, pinfo.type.b.ams_capable ? &quot;capable&quot; : &quot;not capable&quot;);
 483   st-&gt;print_cr(&quot;AMS (active memory sharing)   : %s&quot;, pinfo.type.b.ams_enabled ? &quot;on&quot; : &quot;off&quot;);
 484   st-&gt;print_cr(&quot;AME (active memory expansion) : %s&quot;, pinfo.type.b.ame_enabled ? &quot;on&quot; : &quot;off&quot;);
 485 
 486   if (pinfo.type.b.ame_enabled) {
 487     st-&gt;print_cr(&quot;AME true memory in bytes      : %llu&quot;, pinfo.true_memory);
 488     st-&gt;print_cr(&quot;AME expanded memory in bytes  : %llu&quot;, pinfo.expanded_memory);
 489   }
 490 
 491   st-&gt;print_cr(&quot;SMT : %s&quot;, pinfo.type.b.smt_capable ? &quot;capable&quot; : &quot;not capable&quot;);
 492   st-&gt;print_cr(&quot;SMT : %s&quot;, pinfo.type.b.smt_enabled ? &quot;on&quot; : &quot;off&quot;);
 493   int ocpus = pinfo.online_cpus &gt; 0 ?  pinfo.online_cpus : 1;
 494   st-&gt;print_cr(&quot;LPAR threads              : %d&quot;, cpuinfo.ncpus/ocpus);
 495   st-&gt;print_cr(&quot;LPAR online virtual cpus  : %d&quot;, pinfo.online_cpus);
 496   st-&gt;print_cr(&quot;LPAR logical cpus         : %d&quot;, cpuinfo.ncpus);
 497   st-&gt;print_cr(&quot;LPAR maximum virtual cpus : %u&quot;, pinfo.max_cpus);
 498   st-&gt;print_cr(&quot;LPAR minimum virtual cpus : %u&quot;, pinfo.min_cpus);
 499   st-&gt;print_cr(&quot;LPAR entitled capacity    : %4.2f&quot;, (double) (pinfo.entitled_proc_capacity/100.0));
 500   st-&gt;print_cr(&quot;LPAR online memory        : %llu MB&quot;, pinfo.online_memory);
 501   st-&gt;print_cr(&quot;LPAR maximum memory       : %llu MB&quot;, pinfo.max_memory);
 502   st-&gt;print_cr(&quot;LPAR minimum memory       : %llu MB&quot;, pinfo.min_memory);
 503 #else
 504   const char* info_file = &quot;/proc/ppc64/lparcfg&quot;;
 505   const char* kw[] = { &quot;system_type=&quot;, // qemu indicates PowerKVM
 506                        &quot;partition_entitled_capacity=&quot;, // entitled processor capacity percentage
 507                        &quot;partition_max_entitled_capacity=&quot;,
 508                        &quot;capacity_weight=&quot;, // partition CPU weight
 509                        &quot;partition_active_processors=&quot;,
 510                        &quot;partition_potential_processors=&quot;,
 511                        &quot;entitled_proc_capacity_available=&quot;,
 512                        &quot;capped=&quot;, // 0 - uncapped, 1 - vcpus capped at entitled processor capacity percentage
 513                        &quot;shared_processor_mode=&quot;, // (non)dedicated partition
 514                        &quot;system_potential_processors=&quot;,
 515                        &quot;pool=&quot;, // CPU-pool number
 516                        &quot;pool_capacity=&quot;,
 517                        &quot;NumLpars=&quot;, // on non-KVM machines, NumLpars is not found for full partition mode machines
 518                        NULL };
 519   if (!print_matching_lines_from_file(info_file, st, kw)) {
 520     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);
 521   }
 522 #endif
 523 }
 524 
 525 bool VM_Version::use_biased_locking() {
 526 #if INCLUDE_RTM_OPT
 527   // RTM locking is most useful when there is high lock contention and
 528   // low data contention. With high lock contention the lock is usually
 529   // inflated and biased locking is not suitable for that case.
 530   // RTM locking code requires that biased locking is off.
 531   // Note: we can&#39;t switch off UseBiasedLocking in get_processor_features()
 532   // because it is used by Thread::allocate() which is called before
 533   // VM_Version::initialize().
 534   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
 535     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
 536       FLAG_SET_DEFAULT(UseBiasedLocking, false);
 537     } else {
 538       warning(&quot;Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.&quot; );
 539       UseBiasedLocking = false;
 540     }
 541   }
 542 #endif
 543   return UseBiasedLocking;
 544 }
 545 
 546 void VM_Version::print_features() {
 547   tty-&gt;print_cr(&quot;Version: %s L1_data_cache_line_size=%d&quot;, features_string(), L1_data_cache_line_size());
 548 
 549   if (Verbose) {
 550     if (ContendedPaddingWidth &gt; 0) {
 551       tty-&gt;cr();
 552       tty-&gt;print_cr(&quot;ContendedPaddingWidth &quot; INTX_FORMAT, ContendedPaddingWidth);
 553     }
 554   }
 555 }
 556 
 557 #ifdef COMPILER2
 558 // Determine section size on power6: If section size is 8 instructions,
 559 // there should be a difference between the two testloops of ~15 %. If
 560 // no difference is detected the section is assumed to be 32 instructions.
 561 void VM_Version::determine_section_size() {
 562 
 563   int unroll = 80;
 564 
 565   const int code_size = (2* unroll * 32 + 100)*BytesPerInstWord;
 566 
 567   // Allocate space for the code.
 568   ResourceMark rm;
 569   CodeBuffer cb(&quot;detect_section_size&quot;, code_size, 0);
 570   MacroAssembler* a = new MacroAssembler(&amp;cb);
 571 
 572   uint32_t *code = (uint32_t *)a-&gt;pc();
 573   // Emit code.
 574   void (*test1)() = (void(*)())(void *)a-&gt;function_entry();
 575 
 576   Label l1;
 577 
 578   a-&gt;li(R4, 1);
 579   a-&gt;sldi(R4, R4, 28);
 580   a-&gt;b(l1);
 581   a-&gt;align(CodeEntryAlignment);
 582 
 583   a-&gt;bind(l1);
 584 
 585   for (int i = 0; i &lt; unroll; i++) {
 586     // Schleife 1
 587     // ------- sector 0 ------------
 588     // ;; 0
 589     a-&gt;nop();                   // 1
 590     a-&gt;fpnop0();                // 2
 591     a-&gt;fpnop1();                // 3
 592     a-&gt;addi(R4,R4, -1); // 4
 593 
 594     // ;;  1
 595     a-&gt;nop();                   // 5
 596     a-&gt;fmr(F6, F6);             // 6
 597     a-&gt;fmr(F7, F7);             // 7
 598     a-&gt;endgroup();              // 8
 599     // ------- sector 8 ------------
 600 
 601     // ;;  2
 602     a-&gt;nop();                   // 9
 603     a-&gt;nop();                   // 10
 604     a-&gt;fmr(F8, F8);             // 11
 605     a-&gt;fmr(F9, F9);             // 12
 606 
 607     // ;;  3
 608     a-&gt;nop();                   // 13
 609     a-&gt;fmr(F10, F10);           // 14
 610     a-&gt;fmr(F11, F11);           // 15
 611     a-&gt;endgroup();              // 16
 612     // -------- sector 16 -------------
 613 
 614     // ;;  4
 615     a-&gt;nop();                   // 17
 616     a-&gt;nop();                   // 18
 617     a-&gt;fmr(F15, F15);           // 19
 618     a-&gt;fmr(F16, F16);           // 20
 619 
 620     // ;;  5
 621     a-&gt;nop();                   // 21
 622     a-&gt;fmr(F17, F17);           // 22
 623     a-&gt;fmr(F18, F18);           // 23
 624     a-&gt;endgroup();              // 24
 625     // ------- sector 24  ------------
 626 
 627     // ;;  6
 628     a-&gt;nop();                   // 25
 629     a-&gt;nop();                   // 26
 630     a-&gt;fmr(F19, F19);           // 27
 631     a-&gt;fmr(F20, F20);           // 28
 632 
 633     // ;;  7
 634     a-&gt;nop();                   // 29
 635     a-&gt;fmr(F21, F21);           // 30
 636     a-&gt;fmr(F22, F22);           // 31
 637     a-&gt;brnop0();                // 32
 638 
 639     // ------- sector 32 ------------
 640   }
 641 
 642   // ;; 8
 643   a-&gt;cmpdi(CCR0, R4, unroll);   // 33
 644   a-&gt;bge(CCR0, l1);             // 34
 645   a-&gt;blr();
 646 
 647   // Emit code.
 648   void (*test2)() = (void(*)())(void *)a-&gt;function_entry();
 649   // uint32_t *code = (uint32_t *)a-&gt;pc();
 650 
 651   Label l2;
 652 
 653   a-&gt;li(R4, 1);
 654   a-&gt;sldi(R4, R4, 28);
 655   a-&gt;b(l2);
 656   a-&gt;align(CodeEntryAlignment);
 657 
 658   a-&gt;bind(l2);
 659 
 660   for (int i = 0; i &lt; unroll; i++) {
 661     // Schleife 2
 662     // ------- sector 0 ------------
 663     // ;; 0
 664     a-&gt;brnop0();                  // 1
 665     a-&gt;nop();                     // 2
 666     //a-&gt;cmpdi(CCR0, R4, unroll);
 667     a-&gt;fpnop0();                  // 3
 668     a-&gt;fpnop1();                  // 4
 669     a-&gt;addi(R4,R4, -1);           // 5
 670 
 671     // ;; 1
 672 
 673     a-&gt;nop();                     // 6
 674     a-&gt;fmr(F6, F6);               // 7
 675     a-&gt;fmr(F7, F7);               // 8
 676     // ------- sector 8 ---------------
 677 
 678     // ;; 2
 679     a-&gt;endgroup();                // 9
 680 
 681     // ;; 3
 682     a-&gt;nop();                     // 10
 683     a-&gt;nop();                     // 11
 684     a-&gt;fmr(F8, F8);               // 12
 685 
 686     // ;; 4
 687     a-&gt;fmr(F9, F9);               // 13
 688     a-&gt;nop();                     // 14
 689     a-&gt;fmr(F10, F10);             // 15
 690 
 691     // ;; 5
 692     a-&gt;fmr(F11, F11);             // 16
 693     // -------- sector 16 -------------
 694 
 695     // ;; 6
 696     a-&gt;endgroup();                // 17
 697 
 698     // ;; 7
 699     a-&gt;nop();                     // 18
 700     a-&gt;nop();                     // 19
 701     a-&gt;fmr(F15, F15);             // 20
 702 
 703     // ;; 8
 704     a-&gt;fmr(F16, F16);             // 21
 705     a-&gt;nop();                     // 22
 706     a-&gt;fmr(F17, F17);             // 23
 707 
 708     // ;; 9
 709     a-&gt;fmr(F18, F18);             // 24
 710     // -------- sector 24 -------------
 711 
 712     // ;; 10
 713     a-&gt;endgroup();                // 25
 714 
 715     // ;; 11
 716     a-&gt;nop();                     // 26
 717     a-&gt;nop();                     // 27
 718     a-&gt;fmr(F19, F19);             // 28
 719 
 720     // ;; 12
 721     a-&gt;fmr(F20, F20);             // 29
 722     a-&gt;nop();                     // 30
 723     a-&gt;fmr(F21, F21);             // 31
 724 
 725     // ;; 13
 726     a-&gt;fmr(F22, F22);             // 32
 727   }
 728 
 729   // -------- sector 32 -------------
 730   // ;; 14
 731   a-&gt;cmpdi(CCR0, R4, unroll); // 33
 732   a-&gt;bge(CCR0, l2);           // 34
 733 
 734   a-&gt;blr();
 735   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 736   a-&gt;flush();
 737 
 738   cb.insts()-&gt;set_end((u_char*)code_end);
 739 
 740   double loop1_seconds,loop2_seconds, rel_diff;
 741   uint64_t start1, stop1;
 742 
 743   start1 = os::current_thread_cpu_time(false);
 744   (*test1)();
 745   stop1 = os::current_thread_cpu_time(false);
 746   loop1_seconds = (stop1- start1) / (1000 *1000 *1000.0);
 747 
 748 
 749   start1 = os::current_thread_cpu_time(false);
 750   (*test2)();
 751   stop1 = os::current_thread_cpu_time(false);
 752 
 753   loop2_seconds = (stop1 - start1) / (1000 *1000 *1000.0);
 754 
 755   rel_diff = (loop2_seconds - loop1_seconds) / loop1_seconds *100;
 756 
 757   if (PrintAssembly || PrintStubCode) {
 758     ttyLocker ttyl;
 759     tty-&gt;print_cr(&quot;Decoding section size detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
 760     // Use existing decode function. This enables the [MachCode] format which is needed to DecodeErrorFile.
 761     Disassembler::decode(&amp;cb, (u_char*)code, (u_char*)code_end, tty);
 762     tty-&gt;print_cr(&quot;Time loop1 :%f&quot;, loop1_seconds);
 763     tty-&gt;print_cr(&quot;Time loop2 :%f&quot;, loop2_seconds);
 764     tty-&gt;print_cr(&quot;(time2 - time1) / time1 = %f %%&quot;, rel_diff);
 765 
 766     if (rel_diff &gt; 12.0) {
 767       tty-&gt;print_cr(&quot;Section Size 8 Instructions&quot;);
 768     } else{
 769       tty-&gt;print_cr(&quot;Section Size 32 Instructions or Power5&quot;);
 770     }
 771   }
 772 
 773 #if 0 // TODO: PPC port
 774   // Set sector size (if not set explicitly).
 775   if (FLAG_IS_DEFAULT(Power6SectorSize128PPC64)) {
 776     if (rel_diff &gt; 12.0) {
 777       PdScheduling::power6SectorSize = 0x20;
 778     } else {
 779       PdScheduling::power6SectorSize = 0x80;
 780     }
 781   } else if (Power6SectorSize128PPC64) {
 782     PdScheduling::power6SectorSize = 0x80;
 783   } else {
 784     PdScheduling::power6SectorSize = 0x20;
 785   }
 786 #endif
 787   if (UsePower6SchedulerPPC64) Unimplemented();
 788 }
 789 #endif // COMPILER2
 790 
 791 void VM_Version::determine_features() {
 792 #if defined(ABI_ELFv2)
 793   // 1 InstWord per call for the blr instruction.
 794   const int code_size = (num_features+1+2*1)*BytesPerInstWord;
 795 #else
 796   // 7 InstWords for each call (function descriptor + blr instruction).
 797   const int code_size = (num_features+1+2*7)*BytesPerInstWord;
 798 #endif
 799   int features = 0;
 800 
 801   // create test area
 802   enum { BUFFER_SIZE = 2*4*K }; // Needs to be &gt;=2* max cache line size (cache line size can&#39;t exceed min page size).
 803   char test_area[BUFFER_SIZE];
 804   char *mid_of_test_area = &amp;test_area[BUFFER_SIZE&gt;&gt;1];
 805 
 806   // Allocate space for the code.
 807   ResourceMark rm;
 808   CodeBuffer cb(&quot;detect_cpu_features&quot;, code_size, 0);
 809   MacroAssembler* a = new MacroAssembler(&amp;cb);
 810 
 811   // Must be set to true so we can generate the test code.
 812   _features = VM_Version::all_features_m;
 813 
 814   // Emit code.
 815   void (*test)(address addr, uint64_t offset)=(void(*)(address addr, uint64_t offset))(void *)a-&gt;function_entry();
 816   uint32_t *code = (uint32_t *)a-&gt;pc();
 817   // Don&#39;t use R0 in ldarx.
 818   // Keep R3_ARG1 unmodified, it contains &amp;field (see below).
 819   // Keep R4_ARG2 unmodified, it contains offset = 0 (see below).
 820   a-&gt;fsqrt(F3, F4);                            // code[0]  -&gt; fsqrt_m
 821   a-&gt;fsqrts(F3, F4);                           // code[1]  -&gt; fsqrts_m
 822   a-&gt;isel(R7, R5, R6, 0);                      // code[2]  -&gt; isel_m
 823   a-&gt;ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -&gt; lxarx_m
 824   a-&gt;cmpb(R7, R5, R6);                         // code[4]  -&gt; cmpb
 825   a-&gt;popcntb(R7, R5);                          // code[5]  -&gt; popcntb
 826   a-&gt;popcntw(R7, R5);                          // code[6]  -&gt; popcntw
 827   a-&gt;fcfids(F3, F4);                           // code[7]  -&gt; fcfids
 828   a-&gt;vand(VR0, VR0, VR0);                      // code[8]  -&gt; vand
 829   // arg0 of lqarx must be an even register, (arg1 + arg2) must be a multiple of 16
 830   a-&gt;lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -&gt; lqarx_m
 831   a-&gt;vcipher(VR0, VR1, VR2);                   // code[10] -&gt; vcipher
 832   a-&gt;vpmsumb(VR0, VR1, VR2);                   // code[11] -&gt; vpmsumb
 833   a-&gt;mfdscr(R0);                               // code[12] -&gt; mfdscr
 834   a-&gt;lxvd2x(VSR0, R3_ARG1);                    // code[13] -&gt; vsx
 835   a-&gt;ldbrx(R7, R3_ARG1, R4_ARG2);              // code[14] -&gt; ldbrx
 836   a-&gt;stdbrx(R7, R3_ARG1, R4_ARG2);             // code[15] -&gt; stdbrx
 837   a-&gt;vshasigmaw(VR0, VR1, 1, 0xF);             // code[16] -&gt; vshasig
 838   // rtm is determined by OS
 839   a-&gt;darn(R7);                                 // code[17] -&gt; darn
 840   a-&gt;blr();
 841 
 842   // Emit function to set one cache line to zero. Emit function descriptor and get pointer to it.
 843   void (*zero_cacheline_func_ptr)(char*) = (void(*)(char*))(void *)a-&gt;function_entry();
 844   a-&gt;dcbz(R3_ARG1); // R3_ARG1 = addr
 845   a-&gt;blr();
 846 
 847   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 848   a-&gt;flush();
 849   _features = VM_Version::unknown_m;
 850 
 851   // Print the detection code.
 852   if (PrintAssembly) {
 853     ttyLocker ttyl;
 854     tty-&gt;print_cr(&quot;Decoding cpu-feature detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
 855     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 856   }
 857 
 858   // Measure cache line size.
 859   memset(test_area, 0xFF, BUFFER_SIZE); // Fill test area with 0xFF.
 860   (*zero_cacheline_func_ptr)(mid_of_test_area); // Call function which executes dcbz to the middle.
 861   int count = 0; // count zeroed bytes
 862   for (int i = 0; i &lt; BUFFER_SIZE; i++) if (test_area[i] == 0) count++;
 863   guarantee(is_power_of_2(count), &quot;cache line size needs to be a power of 2&quot;);
 864   _L1_data_cache_line_size = count;
 865 
 866   // Execute code. Illegal instructions will be replaced by 0 in the signal handler.
 867   VM_Version::_is_determine_features_test_running = true;
 868   // We must align the first argument to 16 bytes because of the lqarx check.
 869   (*test)(align_up((address)mid_of_test_area, 16), 0);
 870   VM_Version::_is_determine_features_test_running = false;
 871 
 872   // determine which instructions are legal.
 873   int feature_cntr = 0;
 874   if (code[feature_cntr++]) features |= fsqrt_m;
 875   if (code[feature_cntr++]) features |= fsqrts_m;
 876   if (code[feature_cntr++]) features |= isel_m;
 877   if (code[feature_cntr++]) features |= lxarxeh_m;
 878   if (code[feature_cntr++]) features |= cmpb_m;
 879   if (code[feature_cntr++]) features |= popcntb_m;
 880   if (code[feature_cntr++]) features |= popcntw_m;
 881   if (code[feature_cntr++]) features |= fcfids_m;
 882   if (code[feature_cntr++]) features |= vand_m;
 883   if (code[feature_cntr++]) features |= lqarx_m;
 884   if (code[feature_cntr++]) features |= vcipher_m;
 885   if (code[feature_cntr++]) features |= vpmsumb_m;
 886   if (code[feature_cntr++]) features |= mfdscr_m;
 887   if (code[feature_cntr++]) features |= vsx_m;
 888   if (code[feature_cntr++]) features |= ldbrx_m;
 889   if (code[feature_cntr++]) features |= stdbrx_m;
 890   if (code[feature_cntr++]) features |= vshasig_m;
 891   // feature rtm_m is determined by OS
 892   if (code[feature_cntr++]) features |= darn_m;
 893 
 894   // Print the detection code.
 895   if (PrintAssembly) {
 896     ttyLocker ttyl;
 897     tty-&gt;print_cr(&quot;Decoding cpu-feature detection stub at &quot; INTPTR_FORMAT &quot; after execution:&quot;, p2i(code));
 898     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 899   }
 900 
 901   _features = features;
 902 
 903 #ifdef AIX
 904   // To enable it on AIX it&#39;s necessary POWER8 or above and at least AIX 7.2.
 905   // Actually, this is supported since AIX 7.1.. Unfortunately, this first
 906   // contained bugs, so that it can only be enabled after AIX 7.1.3.30.
 907   // The Java property os.version, which is used in RTM tests to decide
 908   // whether the feature is available, only knows major and minor versions.
 909   // We don&#39;t want to change this property, as user code might depend on it.
 910   // So the tests can not check on subversion 3.30, and we only enable RTM
 911   // with AIX 7.2.
 912   if (has_lqarx()) { // POWER8 or above
 913     if (os::Aix::os_version() &gt;= 0x07020000) { // At least AIX 7.2.
 914       _features |= rtm_m;
 915     }
 916   }
 917 #endif
 918 #if defined(LINUX) &amp;&amp; defined(VM_LITTLE_ENDIAN)
 919   unsigned long auxv = getauxval(AT_HWCAP2);
 920 
 921   if (auxv &amp; PPC_FEATURE2_HTM_NOSC) {
 922     if (auxv &amp; PPC_FEATURE2_HAS_HTM) {
 923       // TM on POWER8 and POWER9 in compat mode (VM) is supported by the JVM.
 924       // TM on POWER9 DD2.1 NV (baremetal) is not supported by the JVM (TM on
 925       // POWER9 DD2.1 NV has a few issues that need a couple of firmware
 926       // and kernel workarounds, so there is a new mode only supported
 927       // on non-virtualized P9 machines called HTM with no Suspend Mode).
 928       // TM on POWER9 D2.2+ NV is not supported at all by Linux.
 929       _features |= rtm_m;
 930     }
 931   }
 932 #endif
 933 }
 934 
 935 // Power 8: Configure Data Stream Control Register.
 936 void VM_Version::config_dscr() {
 937   // 7 InstWords for each call (function descriptor + blr instruction).
 938   const int code_size = (2+2*7)*BytesPerInstWord;
 939 
 940   // Allocate space for the code.
 941   ResourceMark rm;
 942   CodeBuffer cb(&quot;config_dscr&quot;, code_size, 0);
 943   MacroAssembler* a = new MacroAssembler(&amp;cb);
 944 
 945   // Emit code.
 946   uint64_t (*get_dscr)() = (uint64_t(*)())(void *)a-&gt;function_entry();
 947   uint32_t *code = (uint32_t *)a-&gt;pc();
 948   a-&gt;mfdscr(R3);
 949   a-&gt;blr();
 950 
 951   void (*set_dscr)(long) = (void(*)(long))(void *)a-&gt;function_entry();
 952   a-&gt;mtdscr(R3);
 953   a-&gt;blr();
 954 
 955   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 956   a-&gt;flush();
 957 
 958   // Print the detection code.
 959   if (PrintAssembly) {
 960     ttyLocker ttyl;
 961     tty-&gt;print_cr(&quot;Decoding dscr configuration stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
 962     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 963   }
 964 
 965   // Apply the configuration if needed.
 966   _dscr_val = (*get_dscr)();
 967   if (Verbose) {
 968     tty-&gt;print_cr(&quot;dscr value was 0x%lx&quot; , _dscr_val);
 969   }
 970   bool change_requested = false;
 971   if (DSCR_PPC64 != (uintx)-1) {
 972     _dscr_val = DSCR_PPC64;
 973     change_requested = true;
 974   }
 975   if (DSCR_DPFD_PPC64 &lt;= 7) {
 976     uint64_t mask = 0x7;
 977     if ((_dscr_val &amp; mask) != DSCR_DPFD_PPC64) {
 978       _dscr_val = (_dscr_val &amp; ~mask) | (DSCR_DPFD_PPC64);
 979       change_requested = true;
 980     }
 981   }
 982   if (DSCR_URG_PPC64 &lt;= 7) {
 983     uint64_t mask = 0x7 &lt;&lt; 6;
 984     if ((_dscr_val &amp; mask) != DSCR_DPFD_PPC64 &lt;&lt; 6) {
 985       _dscr_val = (_dscr_val &amp; ~mask) | (DSCR_URG_PPC64 &lt;&lt; 6);
 986       change_requested = true;
 987     }
 988   }
 989   if (change_requested) {
 990     (*set_dscr)(_dscr_val);
 991     if (Verbose) {
 992       tty-&gt;print_cr(&quot;dscr was set to 0x%lx&quot; , (*get_dscr)());
 993     }
 994   }
 995 }
 996 
 997 static uint64_t saved_features = 0;
 998 
 999 void VM_Version::allow_all() {
1000   saved_features = _features;
1001   _features      = all_features_m;
1002 }
1003 
1004 void VM_Version::revert() {
1005   _features = saved_features;
1006 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
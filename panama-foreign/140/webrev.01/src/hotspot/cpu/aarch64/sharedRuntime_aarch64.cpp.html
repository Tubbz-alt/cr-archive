<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;code/debugInfoRec.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;interpreter/interp_masm.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;nativeInst_aarch64.hpp&quot;
  38 #include &quot;oops/compiledICHolder.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/vframeArray.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;
  44 #include &quot;vmreg_aarch64.inline.hpp&quot;
  45 #ifdef COMPILER1
  46 #include &quot;c1/c1_Runtime1.hpp&quot;
  47 #endif
  48 #ifdef COMPILER2
  49 #include &quot;adfiles/ad_aarch64.hpp&quot;
  50 #include &quot;opto/runtime.hpp&quot;
  51 #endif
  52 #if INCLUDE_JVMCI
  53 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  54 #endif
  55 
  56 #define __ masm-&gt;
  57 
  58 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  59 
  60 class SimpleRuntimeFrame {
  61 
  62   public:
  63 
  64   // Most of the runtime stubs have this simple frame layout.
  65   // This class exists to make the layout shared in one place.
  66   // Offsets are for compiler stack slots, which are jints.
  67   enum layout {
  68     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
  69     // will override any oopMap setting for it. We must therefore force the layout
  70     // so that it agrees with the frame sender code.
  71     // we don&#39;t expect any arg reg save area so aarch64 asserts that
  72     // frame::arg_reg_save_area_bytes == 0
  73     rbp_off = 0,
  74     rbp_off2,
  75     return_off, return_off2,
  76     framesize
  77   };
  78 };
  79 
  80 // FIXME -- this is used by C1
  81 class RegisterSaver {
  82  public:
  83   static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);
  84   static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);
  85 
  86   // Offsets into the register save area
  87   // Used by deoptimization when it is managing result register
  88   // values on its own
  89 
  90   static int r0_offset_in_bytes(void)    { return (32 + r0-&gt;encoding()) * wordSize; }
  91   static int reg_offset_in_bytes(Register r)    { return r0_offset_in_bytes() + r-&gt;encoding() * wordSize; }
  92   static int rmethod_offset_in_bytes(void)    { return reg_offset_in_bytes(rmethod); }
  93   static int rscratch1_offset_in_bytes(void)    { return (32 + rscratch1-&gt;encoding()) * wordSize; }
  94   static int v0_offset_in_bytes(void)   { return 0; }
  95   static int return_offset_in_bytes(void) { return (32 /* floats*/ + 31 /* gregs*/) * wordSize; }
  96 
  97   // During deoptimization only the result registers need to be restored,
  98   // all the other values have already been extracted.
  99   static void restore_result_registers(MacroAssembler* masm);
 100 
 101     // Capture info about frame layout
 102   enum layout {
 103                 fpu_state_off = 0,
 104                 fpu_state_end = fpu_state_off + FPUStateSizeInWords - 1,
 105                 // The frame sender code expects that rfp will be in
 106                 // the &quot;natural&quot; place and will override any oopMap
 107                 // setting for it. We must therefore force the layout
 108                 // so that it agrees with the frame sender code.
 109                 r0_off = fpu_state_off + FPUStateSizeInWords,
 110                 rfp_off = r0_off + (RegisterImpl::number_of_registers - 2) * RegisterImpl::max_slots_per_register,
 111                 return_off = rfp_off + RegisterImpl::max_slots_per_register,      // slot for return address
 112                 reg_save_size = return_off + RegisterImpl::max_slots_per_register};
 113 
 114 };
 115 
 116 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
 117 #if COMPILER2_OR_JVMCI
 118   if (save_vectors) {
 119     // Save upper half of vector registers
 120     int vect_words = FloatRegisterImpl::number_of_registers * FloatRegisterImpl::extra_save_slots_per_register /
 121                      VMRegImpl::slots_per_word;
 122     additional_frame_words += vect_words;
 123   }
 124 #else
 125   assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 126 #endif
 127 
 128   int frame_size_in_bytes = align_up(additional_frame_words * wordSize +
 129                                      reg_save_size * BytesPerInt, 16);
 130   // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
 131   int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
 132   // The caller will allocate additional_frame_words
 133   int additional_frame_slots = additional_frame_words * wordSize / BytesPerInt;
 134   // CodeBlob frame size is in words.
 135   int frame_size_in_words = frame_size_in_bytes / wordSize;
 136   *total_frame_words = frame_size_in_words;
 137 
 138   // Save Integer and Float registers.
 139   __ enter();
 140   __ push_CPU_state(save_vectors);
 141 
 142   // Set an oopmap for the call site.  This oopmap will map all
 143   // oop-registers and debug-info registers as callee-saved.  This
 144   // will allow deoptimization at this safepoint to find all possible
 145   // debug-info recordings, as well as let GC find all oops.
 146 
 147   OopMapSet *oop_maps = new OopMapSet();
 148   OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
 149 
 150   for (int i = 0; i &lt; RegisterImpl::number_of_registers; i++) {
 151     Register r = as_Register(i);
 152     if (r &lt;= rfp &amp;&amp; r != rscratch1 &amp;&amp; r != rscratch2) {
 153       // SP offsets are in 4-byte words.
 154       // Register slots are 8 bytes wide, 32 floating-point registers.
 155       int sp_offset = RegisterImpl::max_slots_per_register * i +
 156                       FloatRegisterImpl::save_slots_per_register * FloatRegisterImpl::number_of_registers;
 157       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
 158                                 r-&gt;as_VMReg());
 159     }
 160   }
 161 
 162   for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
 163     FloatRegister r = as_FloatRegister(i);
 164     int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :
 165                                    (FloatRegisterImpl::save_slots_per_register * i);
 166     oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 167                               r-&gt;as_VMReg());
 168   }
 169 
 170   return oop_map;
 171 }
 172 
 173 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
 174 #if !COMPILER2_OR_JVMCI
 175   assert(!restore_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 176 #endif
 177   __ pop_CPU_state(restore_vectors);
 178   __ leave();
 179 
 180 }
 181 
 182 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 183 
 184   // Just restore result register. Only used by deoptimization. By
 185   // now any callee save register that needs to be restored to a c2
 186   // caller of the deoptee has been extracted into the vframeArray
 187   // and will be stuffed into the c2i adapter we create for later
 188   // restoration so only result registers need to be restored here.
 189 
 190   // Restore fp result register
 191   __ ldrd(v0, Address(sp, v0_offset_in_bytes()));
 192   // Restore integer result register
 193   __ ldr(r0, Address(sp, r0_offset_in_bytes()));
 194 
 195   // Pop all of the register save are off the stack
 196   __ add(sp, sp, align_up(return_offset_in_bytes(), 16));
 197 }
 198 
 199 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 200 // 8 bytes vector registers are saved by default on AArch64.
 201 bool SharedRuntime::is_wide_vector(int size) {
 202   return size &gt; 8;
 203 }
 204 
 205 size_t SharedRuntime::trampoline_size() {
 206   return 16;
 207 }
 208 
 209 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 210   __ mov(rscratch1, destination);
 211   __ br(rscratch1);
 212 }
 213 
 214 // The java_calling_convention describes stack locations as ideal slots on
 215 // a frame with no abi restrictions. Since we must observe abi restrictions
 216 // (like the placement of the register window) the slots must be biased by
 217 // the following value.
 218 static int reg2offset_in(VMReg r) {
 219   // Account for saved rfp and lr
 220   // This should really be in_preserve_stack_slots
 221   return (r-&gt;reg2stack() + 4) * VMRegImpl::stack_slot_size;
 222 }
 223 
 224 static int reg2offset_out(VMReg r) {
 225   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 226 }
 227 
 228 // ---------------------------------------------------------------------------
 229 // Read the array of BasicTypes from a signature, and compute where the
 230 // arguments should go.  Values in the VMRegPair regs array refer to 4-byte
 231 // quantities.  Values less than VMRegImpl::stack0 are registers, those above
 232 // refer to 4-byte stack slots.  All stack slots are based off of the stack pointer
 233 // as framesizes are fixed.
 234 // VMRegImpl::stack0 refers to the first slot 0(sp).
 235 // and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register
 236 // up to RegisterImpl::number_of_registers) are the 64-bit
 237 // integer registers.
 238 
 239 // Note: the INPUTS in sig_bt are in units of Java argument words,
 240 // which are 64-bit.  The OUTPUTS are in 32-bit units.
 241 
 242 // The Java calling convention is a &quot;shifted&quot; version of the C ABI.
 243 // By skipping the first C ABI register we can call non-static jni
 244 // methods with small numbers of arguments without having to shuffle
 245 // the arguments at all. Since we control the java ABI we ought to at
 246 // least get some advantage out of it.
 247 
 248 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 249                                            VMRegPair *regs,
 250                                            int total_args_passed,
 251                                            int is_outgoing) {
 252 
 253   // Create the mapping between argument positions and
 254   // registers.
 255   static const Register INT_ArgReg[Argument::n_int_register_parameters_j] = {
 256     j_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4, j_rarg5, j_rarg6, j_rarg7
 257   };
 258   static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_j] = {
 259     j_farg0, j_farg1, j_farg2, j_farg3,
 260     j_farg4, j_farg5, j_farg6, j_farg7
 261   };
 262 
 263 
 264   uint int_args = 0;
 265   uint fp_args = 0;
 266   uint stk_args = 0; // inc by 2 each time
 267 
 268   for (int i = 0; i &lt; total_args_passed; i++) {
 269     switch (sig_bt[i]) {
 270     case T_BOOLEAN:
 271     case T_CHAR:
 272     case T_BYTE:
 273     case T_SHORT:
 274     case T_INT:
 275       if (int_args &lt; Argument::n_int_register_parameters_j) {
 276         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 277       } else {
 278         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 279         stk_args += 2;
 280       }
 281       break;
 282     case T_VOID:
 283       // halves of T_LONG or T_DOUBLE
 284       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 285       regs[i].set_bad();
 286       break;
 287     case T_LONG:
 288       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 289       // fall through
 290     case T_OBJECT:
 291     case T_ARRAY:
 292     case T_ADDRESS:
 293       if (int_args &lt; Argument::n_int_register_parameters_j) {
 294         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 295       } else {
 296         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 297         stk_args += 2;
 298       }
 299       break;
 300     case T_FLOAT:
 301       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 302         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 303       } else {
 304         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 305         stk_args += 2;
 306       }
 307       break;
 308     case T_DOUBLE:
 309       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 310       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 311         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 312       } else {
 313         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 314         stk_args += 2;
 315       }
 316       break;
 317     default:
 318       ShouldNotReachHere();
 319       break;
 320     }
 321   }
 322 
 323   return align_up(stk_args, 2);
 324 }
 325 
 326 // Patch the callers callsite with entry to compiled code if it exists.
 327 static void patch_callers_callsite(MacroAssembler *masm) {
 328   Label L;
 329   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 330   __ cbz(rscratch1, L);
 331 
 332   __ enter();
 333   __ push_CPU_state();
 334 
 335   // VM needs caller&#39;s callsite
 336   // VM needs target method
 337   // This needs to be a long call since we will relocate this adapter to
 338   // the codeBuffer and it may not reach
 339 
 340 #ifndef PRODUCT
 341   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 342 #endif
 343 
 344   __ mov(c_rarg0, rmethod);
 345   __ mov(c_rarg1, lr);
 346   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 347   __ blr(rscratch1);
 348   __ maybe_isb();
 349 
 350   __ pop_CPU_state();
 351   // restore sp
 352   __ leave();
 353   __ bind(L);
 354 }
 355 
 356 static void gen_c2i_adapter(MacroAssembler *masm,
 357                             int total_args_passed,
 358                             int comp_args_on_stack,
 359                             const BasicType *sig_bt,
 360                             const VMRegPair *regs,
 361                             Label&amp; skip_fixup) {
 362   // Before we get into the guts of the C2I adapter, see if we should be here
 363   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 364   // interpreter, which means the caller made a static call to get here
 365   // (vcalls always get a compiled target if there is one).  Check for a
 366   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 367   patch_callers_callsite(masm);
 368 
 369   __ bind(skip_fixup);
 370 
 371   int words_pushed = 0;
 372 
 373   // Since all args are passed on the stack, total_args_passed *
 374   // Interpreter::stackElementSize is the space we need.
 375 
 376   int extraspace = total_args_passed * Interpreter::stackElementSize;
 377 
 378   __ mov(r13, sp);
 379 
 380   // stack is aligned, keep it that way
 381   extraspace = align_up(extraspace, 2*wordSize);
 382 
 383   if (extraspace)
 384     __ sub(sp, sp, extraspace);
 385 
 386   // Now write the args into the outgoing interpreter space
 387   for (int i = 0; i &lt; total_args_passed; i++) {
 388     if (sig_bt[i] == T_VOID) {
 389       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 390       continue;
 391     }
 392 
 393     // offset to start parameters
 394     int st_off   = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 395     int next_off = st_off - Interpreter::stackElementSize;
 396 
 397     // Say 4 args:
 398     // i   st_off
 399     // 0   32 T_LONG
 400     // 1   24 T_VOID
 401     // 2   16 T_OBJECT
 402     // 3    8 T_BOOL
 403     // -    0 return address
 404     //
 405     // However to make thing extra confusing. Because we can fit a long/double in
 406     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 407     // leaves one slot empty and only stores to a single slot. In this case the
 408     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 409 
 410     VMReg r_1 = regs[i].first();
 411     VMReg r_2 = regs[i].second();
 412     if (!r_1-&gt;is_valid()) {
 413       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 414       continue;
 415     }
 416     if (r_1-&gt;is_stack()) {
 417       // memory to memory use rscratch1
 418       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size
 419                     + extraspace
 420                     + words_pushed * wordSize);
 421       if (!r_2-&gt;is_valid()) {
 422         // sign extend??
 423         __ ldrw(rscratch1, Address(sp, ld_off));
 424         __ str(rscratch1, Address(sp, st_off));
 425 
 426       } else {
 427 
 428         __ ldr(rscratch1, Address(sp, ld_off));
 429 
 430         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 431         // T_DOUBLE and T_LONG use two slots in the interpreter
 432         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 433           // ld_off == LSW, ld_off+wordSize == MSW
 434           // st_off == MSW, next_off == LSW
 435           __ str(rscratch1, Address(sp, next_off));
 436 #ifdef ASSERT
 437           // Overwrite the unused slot with known junk
 438           __ mov(rscratch1, 0xdeadffffdeadaaaaul);
 439           __ str(rscratch1, Address(sp, st_off));
 440 #endif /* ASSERT */
 441         } else {
 442           __ str(rscratch1, Address(sp, st_off));
 443         }
 444       }
 445     } else if (r_1-&gt;is_Register()) {
 446       Register r = r_1-&gt;as_Register();
 447       if (!r_2-&gt;is_valid()) {
 448         // must be only an int (or less ) so move only 32bits to slot
 449         // why not sign extend??
 450         __ str(r, Address(sp, st_off));
 451       } else {
 452         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 453         // T_DOUBLE and T_LONG use two slots in the interpreter
 454         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 455           // long/double in gpr
 456 #ifdef ASSERT
 457           // Overwrite the unused slot with known junk
 458           __ mov(rscratch1, 0xdeadffffdeadaaabul);
 459           __ str(rscratch1, Address(sp, st_off));
 460 #endif /* ASSERT */
 461           __ str(r, Address(sp, next_off));
 462         } else {
 463           __ str(r, Address(sp, st_off));
 464         }
 465       }
 466     } else {
 467       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 468       if (!r_2-&gt;is_valid()) {
 469         // only a float use just part of the slot
 470         __ strs(r_1-&gt;as_FloatRegister(), Address(sp, st_off));
 471       } else {
 472 #ifdef ASSERT
 473         // Overwrite the unused slot with known junk
 474         __ mov(rscratch1, 0xdeadffffdeadaaacul);
 475         __ str(rscratch1, Address(sp, st_off));
 476 #endif /* ASSERT */
 477         __ strd(r_1-&gt;as_FloatRegister(), Address(sp, next_off));
 478       }
 479     }
 480   }
 481 
 482   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 483 
 484   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 485   __ br(rscratch1);
 486 }
 487 
 488 
 489 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
 490                                     int total_args_passed,
 491                                     int comp_args_on_stack,
 492                                     const BasicType *sig_bt,
 493                                     const VMRegPair *regs) {
 494 
 495   // Note: r13 contains the senderSP on entry. We must preserve it since
 496   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 497   // code goes non-entrant while we get args ready.
 498 
 499   // In addition we use r13 to locate all the interpreter args because
 500   // we must align the stack to 16 bytes.
 501 
 502   // Adapters are frameless.
 503 
 504   // An i2c adapter is frameless because the *caller* frame, which is
 505   // interpreted, routinely repairs its own esp (from
 506   // interpreter_frame_last_sp), even if a callee has modified the
 507   // stack pointer.  It also recalculates and aligns sp.
 508 
 509   // A c2i adapter is frameless because the *callee* frame, which is
 510   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 511   // which is set up via the senderSP register).
 512 
 513   // In other words, if *either* the caller or callee is interpreted, we can
 514   // get the stack pointer repaired after a call.
 515 
 516   // This is why c2i and i2c adapters cannot be indefinitely composed.
 517   // In particular, if a c2i adapter were to somehow call an i2c adapter,
 518   // both caller and callee would be compiled methods, and neither would
 519   // clean up the stack pointer changes performed by the two adapters.
 520   // If this happens, control eventually transfers back to the compiled
 521   // caller, but with an uncorrected stack, causing delayed havoc.
 522 
 523   if (VerifyAdapterCalls &amp;&amp;
 524       (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {
 525 #if 0
 526     // So, let&#39;s test for cascading c2i/i2c adapters right now.
 527     //  assert(Interpreter::contains($return_addr) ||
 528     //         StubRoutines::contains($return_addr),
 529     //         &quot;i2c adapter must return to an interpreter frame&quot;);
 530     __ block_comment(&quot;verify_i2c { &quot;);
 531     Label L_ok;
 532     if (Interpreter::code() != NULL)
 533       range_check(masm, rax, r11,
 534                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 535                   L_ok);
 536     if (StubRoutines::code1() != NULL)
 537       range_check(masm, rax, r11,
 538                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 539                   L_ok);
 540     if (StubRoutines::code2() != NULL)
 541       range_check(masm, rax, r11,
 542                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 543                   L_ok);
 544     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 545     __ block_comment(msg);
 546     __ stop(msg);
 547     __ bind(L_ok);
 548     __ block_comment(&quot;} verify_i2ce &quot;);
 549 #endif
 550   }
 551 
 552   // Cut-out for having no stack args.
 553   int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;
 554   if (comp_args_on_stack) {
 555     __ sub(rscratch1, sp, comp_words_on_stack * wordSize);
 556     __ andr(sp, rscratch1, -16);
 557   }
 558 
 559   // Will jump to the compiled code just as if compiled code was doing it.
 560   // Pre-load the register-jump target early, to schedule it better.
 561   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 562 
 563 #if INCLUDE_JVMCI
 564   if (EnableJVMCI || UseAOT) {
 565     // check if this call should be routed towards a specific entry point
 566     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 567     Label no_alternative_target;
 568     __ cbz(rscratch2, no_alternative_target);
 569     __ mov(rscratch1, rscratch2);
 570     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 571     __ bind(no_alternative_target);
 572   }
 573 #endif // INCLUDE_JVMCI
 574 
 575   // Now generate the shuffle code.
 576   for (int i = 0; i &lt; total_args_passed; i++) {
 577     if (sig_bt[i] == T_VOID) {
 578       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 579       continue;
 580     }
 581 
 582     // Pick up 0, 1 or 2 words from SP+offset.
 583 
 584     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
 585             &quot;scrambled load targets?&quot;);
 586     // Load in argument order going down.
 587     int ld_off = (total_args_passed - i - 1)*Interpreter::stackElementSize;
 588     // Point to interpreter value (vs. tag)
 589     int next_off = ld_off - Interpreter::stackElementSize;
 590     //
 591     //
 592     //
 593     VMReg r_1 = regs[i].first();
 594     VMReg r_2 = regs[i].second();
 595     if (!r_1-&gt;is_valid()) {
 596       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 597       continue;
 598     }
 599     if (r_1-&gt;is_stack()) {
 600       // Convert stack slot to an SP offset (+ wordSize to account for return address )
 601       int st_off = regs[i].first()-&gt;reg2stack()*VMRegImpl::stack_slot_size;
 602       if (!r_2-&gt;is_valid()) {
 603         // sign extend???
 604         __ ldrsw(rscratch2, Address(esp, ld_off));
 605         __ str(rscratch2, Address(sp, st_off));
 606       } else {
 607         //
 608         // We are using two optoregs. This can be either T_OBJECT,
 609         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 610         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 611         // So we must adjust where to pick up the data to match the
 612         // interpreter.
 613         //
 614         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 615         // are accessed as negative so LSW is at LOW address
 616 
 617         // ld_off is MSW so get LSW
 618         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 619                            next_off : ld_off;
 620         __ ldr(rscratch2, Address(esp, offset));
 621         // st_off is LSW (i.e. reg.first())
 622         __ str(rscratch2, Address(sp, st_off));
 623       }
 624     } else if (r_1-&gt;is_Register()) {  // Register argument
 625       Register r = r_1-&gt;as_Register();
 626       if (r_2-&gt;is_valid()) {
 627         //
 628         // We are using two VMRegs. This can be either T_OBJECT,
 629         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 630         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 631         // So we must adjust where to pick up the data to match the
 632         // interpreter.
 633 
 634         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 635                            next_off : ld_off;
 636 
 637         // this can be a misaligned move
 638         __ ldr(r, Address(esp, offset));
 639       } else {
 640         // sign extend and use a full word?
 641         __ ldrw(r, Address(esp, ld_off));
 642       }
 643     } else {
 644       if (!r_2-&gt;is_valid()) {
 645         __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));
 646       } else {
 647         __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));
 648       }
 649     }
 650   }
 651 
 652   // 6243940 We might end up in handle_wrong_method if
 653   // the callee is deoptimized as we race thru here. If that
 654   // happens we don&#39;t want to take a safepoint because the
 655   // caller frame will look interpreted and arguments are now
 656   // &quot;compiled&quot; so it is much better to make this transition
 657   // invisible to the stack walking code. Unfortunately if
 658   // we try and find the callee by normal means a safepoint
 659   // is possible. So we stash the desired callee in the thread
 660   // and the vm will find there should this case occur.
 661 
 662   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
 663 
 664   __ br(rscratch1);
 665 }
 666 
 667 // ---------------------------------------------------------------
 668 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 669                                                             int total_args_passed,
 670                                                             int comp_args_on_stack,
 671                                                             const BasicType *sig_bt,
 672                                                             const VMRegPair *regs,
 673                                                             AdapterFingerPrint* fingerprint) {
 674   address i2c_entry = __ pc();
 675 
 676   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
 677 
 678   address c2i_unverified_entry = __ pc();
 679   Label skip_fixup;
 680 
 681   Label ok;
 682 
 683   Register holder = rscratch2;
 684   Register receiver = j_rarg0;
 685   Register tmp = r10;  // A call-clobbered register not used for arg passing
 686 
 687   // -------------------------------------------------------------------------
 688   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 689   // to the interpreter.  The args start out packed in the compiled layout.  They
 690   // need to be unpacked into the interpreter layout.  This will almost always
 691   // require some stack space.  We grow the current (compiled) stack, then repack
 692   // the args.  We  finally end in a jump to the generic interpreter entry point.
 693   // On exit from the interpreter, the interpreter will restore our SP (lest the
 694   // compiled code, which relys solely on SP and not FP, get sick).
 695 
 696   {
 697     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 698     __ load_klass(rscratch1, receiver);
 699     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 700     __ cmp(rscratch1, tmp);
 701     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 702     __ br(Assembler::EQ, ok);
 703     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 704 
 705     __ bind(ok);
 706     // Method might have been compiled since the call site was patched to
 707     // interpreted; if that is the case treat it as a miss so we can get
 708     // the call site corrected.
 709     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 710     __ cbz(rscratch1, skip_fixup);
 711     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 712     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 713   }
 714 
 715   address c2i_entry = __ pc();
 716 
 717   // Class initialization barrier for static methods
 718   address c2i_no_clinit_check_entry = NULL;
 719   if (VM_Version::supports_fast_class_init_checks()) {
 720     Label L_skip_barrier;
 721 
 722     { // Bypass the barrier for non-static methods
 723       __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));
 724       __ andsw(zr, rscratch1, JVM_ACC_STATIC);
 725       __ br(Assembler::EQ, L_skip_barrier); // non-static
 726     }
 727 
 728     __ load_method_holder(rscratch2, rmethod);
 729     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
 730     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 731 
 732     __ bind(L_skip_barrier);
 733     c2i_no_clinit_check_entry = __ pc();
 734   }
 735 
 736   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 737   bs-&gt;c2i_entry_barrier(masm);
 738 
 739   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 740 
 741   __ flush();
 742   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);
 743 }
 744 
 745 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 746                                          VMRegPair *regs,
 747                                          VMRegPair *regs2,
 748                                          int total_args_passed) {
 749   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
 750 
 751 // We return the amount of VMRegImpl stack slots we need to reserve for all
 752 // the arguments NOT counting out_preserve_stack_slots.
 753 
 754     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
 755       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
 756     };
 757     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
 758       c_farg0, c_farg1, c_farg2, c_farg3,
 759       c_farg4, c_farg5, c_farg6, c_farg7
 760     };
 761 
 762     uint int_args = 0;
 763     uint fp_args = 0;
 764     uint stk_args = 0; // inc by 2 each time
 765 
 766     for (int i = 0; i &lt; total_args_passed; i++) {
 767       switch (sig_bt[i]) {
 768       case T_BOOLEAN:
 769       case T_CHAR:
 770       case T_BYTE:
 771       case T_SHORT:
 772       case T_INT:
 773         if (int_args &lt; Argument::n_int_register_parameters_c) {
 774           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 775         } else {
 776           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 777           stk_args += 2;
 778         }
 779         break;
 780       case T_LONG:
 781         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 782         // fall through
 783       case T_OBJECT:
 784       case T_ARRAY:
 785       case T_ADDRESS:
 786       case T_METADATA:
 787         if (int_args &lt; Argument::n_int_register_parameters_c) {
 788           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 789         } else {
 790           regs[i].set2(VMRegImpl::stack2reg(stk_args));
 791           stk_args += 2;
 792         }
 793         break;
 794       case T_FLOAT:
 795         if (fp_args &lt; Argument::n_float_register_parameters_c) {
 796           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 797         } else {
 798           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 799           stk_args += 2;
 800         }
 801         break;
 802       case T_DOUBLE:
 803         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 804         if (fp_args &lt; Argument::n_float_register_parameters_c) {
 805           regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 806         } else {
 807           regs[i].set2(VMRegImpl::stack2reg(stk_args));
 808           stk_args += 2;
 809         }
 810         break;
 811       case T_VOID: // Halves of longs and doubles
 812         assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 813         regs[i].set_bad();
 814         break;
 815       default:
 816         ShouldNotReachHere();
 817         break;
 818       }
 819     }
 820 
 821   return stk_args;
 822 }
 823 
 824 // On 64 bit we will store integer like items to the stack as
 825 // 64 bits items (sparc abi) even though java would only store
 826 // 32bits for a parameter. On 32bit it will simply be 32 bits
 827 // So this routine will do 32-&gt;32 on 32bit and 32-&gt;64 on 64bit
 828 static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
 829   if (src.first()-&gt;is_stack()) {
 830     if (dst.first()-&gt;is_stack()) {
 831       // stack to stack
 832       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
 833       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
 834     } else {
 835       // stack to reg
 836       __ ldrsw(dst.first()-&gt;as_Register(), Address(rfp, reg2offset_in(src.first())));
 837     }
 838   } else if (dst.first()-&gt;is_stack()) {
 839     // reg to stack
 840     // Do we really have to sign extend???
 841     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
 842     __ str(src.first()-&gt;as_Register(), Address(sp, reg2offset_out(dst.first())));
 843   } else {
 844     if (dst.first() != src.first()) {
 845       __ sxtw(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
 846     }
 847   }
 848 }
 849 
 850 // An oop arg. Must pass a handle not the oop itself
 851 static void object_move(MacroAssembler* masm,
 852                         OopMap* map,
 853                         int oop_handle_offset,
 854                         int framesize_in_slots,
 855                         VMRegPair src,
 856                         VMRegPair dst,
 857                         bool is_receiver,
 858                         int* receiver_offset) {
 859 
 860   // must pass a handle. First figure out the location we use as a handle
 861 
 862   Register rHandle = dst.first()-&gt;is_stack() ? rscratch2 : dst.first()-&gt;as_Register();
 863 
 864   // See if oop is NULL if it is we need no handle
 865 
 866   if (src.first()-&gt;is_stack()) {
 867 
 868     // Oop is already on the stack as an argument
 869     int offset_in_older_frame = src.first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
 870     map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));
 871     if (is_receiver) {
 872       *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;
 873     }
 874 
 875     __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
 876     __ lea(rHandle, Address(rfp, reg2offset_in(src.first())));
 877     // conditionally move a NULL
 878     __ cmp(rscratch1, zr);
 879     __ csel(rHandle, zr, rHandle, Assembler::EQ);
 880   } else {
 881 
 882     // Oop is in an a register we must store it to the space we reserve
 883     // on the stack for oop_handles and pass a handle if oop is non-NULL
 884 
 885     const Register rOop = src.first()-&gt;as_Register();
 886     int oop_slot;
 887     if (rOop == j_rarg0)
 888       oop_slot = 0;
 889     else if (rOop == j_rarg1)
 890       oop_slot = 1;
 891     else if (rOop == j_rarg2)
 892       oop_slot = 2;
 893     else if (rOop == j_rarg3)
 894       oop_slot = 3;
 895     else if (rOop == j_rarg4)
 896       oop_slot = 4;
 897     else if (rOop == j_rarg5)
 898       oop_slot = 5;
 899     else if (rOop == j_rarg6)
 900       oop_slot = 6;
 901     else {
 902       assert(rOop == j_rarg7, &quot;wrong register&quot;);
 903       oop_slot = 7;
 904     }
 905 
 906     oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;
 907     int offset = oop_slot*VMRegImpl::stack_slot_size;
 908 
 909     map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
 910     // Store oop in handle area, may be NULL
 911     __ str(rOop, Address(sp, offset));
 912     if (is_receiver) {
 913       *receiver_offset = offset;
 914     }
 915 
 916     __ cmp(rOop, zr);
 917     __ lea(rHandle, Address(sp, offset));
 918     // conditionally move a NULL
 919     __ csel(rHandle, zr, rHandle, Assembler::EQ);
 920   }
 921 
 922   // If arg is on the stack then place it otherwise it is already in correct reg.
 923   if (dst.first()-&gt;is_stack()) {
 924     __ str(rHandle, Address(sp, reg2offset_out(dst.first())));
 925   }
 926 }
 927 
 928 // A float arg may have to do float reg int reg conversion
 929 static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
 930   assert(src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack() ||
 931          src.first()-&gt;is_reg() &amp;&amp; dst.first()-&gt;is_reg(), &quot;Unexpected error&quot;);
 932   if (src.first()-&gt;is_stack()) {
 933     if (dst.first()-&gt;is_stack()) {
 934       __ ldrw(rscratch1, Address(rfp, reg2offset_in(src.first())));
 935       __ strw(rscratch1, Address(sp, reg2offset_out(dst.first())));
 936     } else {
 937       ShouldNotReachHere();
 938     }
 939   } else if (src.first() != dst.first()) {
 940     if (src.is_single_phys_reg() &amp;&amp; dst.is_single_phys_reg())
 941       __ fmovs(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
 942     else
 943       ShouldNotReachHere();
 944   }
 945 }
 946 
 947 // A long move
 948 static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
 949   if (src.first()-&gt;is_stack()) {
 950     if (dst.first()-&gt;is_stack()) {
 951       // stack to stack
 952       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
 953       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
 954     } else {
 955       // stack to reg
 956       __ ldr(dst.first()-&gt;as_Register(), Address(rfp, reg2offset_in(src.first())));
 957     }
 958   } else if (dst.first()-&gt;is_stack()) {
 959     // reg to stack
 960     // Do we really have to sign extend???
 961     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
 962     __ str(src.first()-&gt;as_Register(), Address(sp, reg2offset_out(dst.first())));
 963   } else {
 964     if (dst.first() != src.first()) {
 965       __ mov(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
 966     }
 967   }
 968 }
 969 
 970 
 971 // A double move
 972 static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
 973   assert(src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack() ||
 974          src.first()-&gt;is_reg() &amp;&amp; dst.first()-&gt;is_reg(), &quot;Unexpected error&quot;);
 975   if (src.first()-&gt;is_stack()) {
 976     if (dst.first()-&gt;is_stack()) {
 977       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
 978       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
 979     } else {
 980       ShouldNotReachHere();
 981     }
 982   } else if (src.first() != dst.first()) {
 983     if (src.is_single_phys_reg() &amp;&amp; dst.is_single_phys_reg())
 984       __ fmovd(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
 985     else
 986       ShouldNotReachHere();
 987   }
 988 }
 989 
 990 
 991 void SharedRuntime::save_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
 992   // We always ignore the frame_slots arg and just use the space just below frame pointer
 993   // which by this time is free to use
 994   switch (ret_type) {
 995   case T_FLOAT:
 996     __ strs(v0, Address(rfp, -wordSize));
 997     break;
 998   case T_DOUBLE:
 999     __ strd(v0, Address(rfp, -wordSize));
1000     break;
1001   case T_VOID:  break;
1002   default: {
1003     __ str(r0, Address(rfp, -wordSize));
1004     }
1005   }
1006 }
1007 
1008 void SharedRuntime::restore_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1009   // We always ignore the frame_slots arg and just use the space just below frame pointer
1010   // which by this time is free to use
1011   switch (ret_type) {
1012   case T_FLOAT:
1013     __ ldrs(v0, Address(rfp, -wordSize));
1014     break;
1015   case T_DOUBLE:
1016     __ ldrd(v0, Address(rfp, -wordSize));
1017     break;
1018   case T_VOID:  break;
1019   default: {
1020     __ ldr(r0, Address(rfp, -wordSize));
1021     }
1022   }
1023 }
1024 static void save_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1025   RegSet x;
1026   for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1027     if (args[i].first()-&gt;is_Register()) {
1028       x = x + args[i].first()-&gt;as_Register();
1029     } else if (args[i].first()-&gt;is_FloatRegister()) {
1030       __ strd(args[i].first()-&gt;as_FloatRegister(), Address(__ pre(sp, -2 * wordSize)));
1031     }
1032   }
1033   __ push(x, sp);
1034 }
1035 
1036 static void restore_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1037   RegSet x;
1038   for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1039     if (args[i].first()-&gt;is_Register()) {
1040       x = x + args[i].first()-&gt;as_Register();
1041     } else {
1042       ;
1043     }
1044   }
1045   __ pop(x, sp);
1046   for ( int i = arg_count - 1 ; i &gt;= first_arg ; i-- ) {
1047     if (args[i].first()-&gt;is_Register()) {
1048       ;
1049     } else if (args[i].first()-&gt;is_FloatRegister()) {
1050       __ ldrd(args[i].first()-&gt;as_FloatRegister(), Address(__ post(sp, 2 * wordSize)));
1051     }
1052   }
1053 }
1054 
1055 
1056 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true.  This
1057 // keeps a new JNI critical region from starting until a GC has been
1058 // forced.  Save down any oops in registers and describe them in an
1059 // OopMap.
1060 static void check_needs_gc_for_critical_native(MacroAssembler* masm,
1061                                                int stack_slots,
1062                                                int total_c_args,
1063                                                int total_in_args,
1064                                                int arg_save_area,
1065                                                OopMapSet* oop_maps,
1066                                                VMRegPair* in_regs,
1067                                                BasicType* in_sig_bt) { Unimplemented(); }
1068 
1069 // Unpack an array argument into a pointer to the body and the length
1070 // if the array is non-null, otherwise pass 0 for both.
1071 static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) { Unimplemented(); }
1072 
1073 
1074 class ComputeMoveOrder: public StackObj {
1075   class MoveOperation: public ResourceObj {
1076     friend class ComputeMoveOrder;
1077    private:
1078     VMRegPair        _src;
1079     VMRegPair        _dst;
1080     int              _src_index;
1081     int              _dst_index;
1082     bool             _processed;
1083     MoveOperation*  _next;
1084     MoveOperation*  _prev;
1085 
1086     static int get_id(VMRegPair r) { Unimplemented(); return 0; }
1087 
1088    public:
1089     MoveOperation(int src_index, VMRegPair src, int dst_index, VMRegPair dst):
1090       _src(src)
1091     , _dst(dst)
1092     , _src_index(src_index)
1093     , _dst_index(dst_index)
1094     , _processed(false)
1095     , _next(NULL)
1096     , _prev(NULL) { Unimplemented(); }
1097 
1098     VMRegPair src() const              { Unimplemented(); return _src; }
1099     int src_id() const                 { Unimplemented(); return 0; }
1100     int src_index() const              { Unimplemented(); return 0; }
1101     VMRegPair dst() const              { Unimplemented(); return _src; }
1102     void set_dst(int i, VMRegPair dst) { Unimplemented(); }
1103     int dst_index() const              { Unimplemented(); return 0; }
1104     int dst_id() const                 { Unimplemented(); return 0; }
1105     MoveOperation* next() const        { Unimplemented(); return 0; }
1106     MoveOperation* prev() const        { Unimplemented(); return 0; }
1107     void set_processed()               { Unimplemented(); }
1108     bool is_processed() const          { Unimplemented(); return 0; }
1109 
1110     // insert
1111     void break_cycle(VMRegPair temp_register) { Unimplemented(); }
1112 
1113     void link(GrowableArray&lt;MoveOperation*&gt;&amp; killer) { Unimplemented(); }
1114   };
1115 
1116  private:
1117   GrowableArray&lt;MoveOperation*&gt; edges;
1118 
1119  public:
1120   ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,
1121                     BasicType* in_sig_bt, GrowableArray&lt;int&gt;&amp; arg_order, VMRegPair tmp_vmreg) { Unimplemented(); }
1122 
1123   // Collected all the move operations
1124   void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) { Unimplemented(); }
1125 
1126   // Walk the edges breaking cycles between moves.  The result list
1127   // can be walked in order to produce the proper set of loads
1128   GrowableArray&lt;MoveOperation*&gt;* get_store_order(VMRegPair temp_register) { Unimplemented(); return 0; }
1129 };
1130 
1131 
1132 static void rt_call(MacroAssembler* masm, address dest, int gpargs, int fpargs, int type) {
1133   CodeBlob *cb = CodeCache::find_blob(dest);
1134   if (cb) {
1135     __ far_call(RuntimeAddress(dest));
1136   } else {
1137     assert((unsigned)gpargs &lt; 256, &quot;eek!&quot;);
1138     assert((unsigned)fpargs &lt; 32, &quot;eek!&quot;);
1139     __ lea(rscratch1, RuntimeAddress(dest));
1140     __ blr(rscratch1);
1141     __ maybe_isb();
1142   }
1143 }
1144 
1145 static void verify_oop_args(MacroAssembler* masm,
1146                             const methodHandle&amp; method,
1147                             const BasicType* sig_bt,
1148                             const VMRegPair* regs) {
1149   Register temp_reg = r19;  // not part of any compiled calling seq
1150   if (VerifyOops) {
1151     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1152       if (sig_bt[i] == T_OBJECT ||
1153           sig_bt[i] == T_ARRAY) {
1154         VMReg r = regs[i].first();
1155         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1156         if (r-&gt;is_stack()) {
1157           __ ldr(temp_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1158           __ verify_oop(temp_reg);
1159         } else {
1160           __ verify_oop(r-&gt;as_Register());
1161         }
1162       }
1163     }
1164   }
1165 }
1166 
1167 static void gen_special_dispatch(MacroAssembler* masm,
1168                                  const methodHandle&amp; method,
1169                                  const BasicType* sig_bt,
1170                                  const VMRegPair* regs) {
1171   verify_oop_args(masm, method, sig_bt, regs);
1172   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1173 
1174   // Now write the args into the outgoing interpreter space
1175   bool     has_receiver   = false;
1176   Register receiver_reg   = noreg;
1177   int      member_arg_pos = -1;
1178   Register member_reg     = noreg;
1179   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
1180   if (ref_kind != 0) {
1181     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
1182     member_reg = r19;  // known to be free at this point
1183     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
1184   } else if (iid == vmIntrinsics::_invokeBasic) {
1185     has_receiver = true;
1186   } else {
1187     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
1188   }
1189 
1190   if (member_reg != noreg) {
1191     // Load the member_arg into register, if necessary.
1192     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
1193     VMReg r = regs[member_arg_pos].first();
1194     if (r-&gt;is_stack()) {
1195       __ ldr(member_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1196     } else {
1197       // no data motion is needed
1198       member_reg = r-&gt;as_Register();
1199     }
1200   }
1201 
1202   if (has_receiver) {
1203     // Make sure the receiver is loaded into a register.
1204     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
1205     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
1206     VMReg r = regs[0].first();
1207     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
1208     if (r-&gt;is_stack()) {
1209       // Porting note:  This assumes that compiled calling conventions always
1210       // pass the receiver oop in a register.  If this is not true on some
1211       // platform, pick a temp and load the receiver from stack.
1212       fatal(&quot;receiver always in a register&quot;);
1213       receiver_reg = r2;  // known to be free at this point
1214       __ ldr(receiver_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1215     } else {
1216       // no data motion is needed
1217       receiver_reg = r-&gt;as_Register();
1218     }
1219   }
1220 
1221   // Figure out which address we are really jumping to:
1222   MethodHandles::generate_method_handle_dispatch(masm, iid,
1223                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
1224 }
1225 
1226 // ---------------------------------------------------------------------------
1227 // Generate a native wrapper for a given method.  The method takes arguments
1228 // in the Java compiled code convention, marshals them to the native
1229 // convention (handlizes oops, etc), transitions to native, makes the call,
1230 // returns to java state (possibly blocking), unhandlizes any result and
1231 // returns.
1232 //
1233 // Critical native functions are a shorthand for the use of
1234 // GetPrimtiveArrayCritical and disallow the use of any other JNI
1235 // functions.  The wrapper is expected to unpack the arguments before
1236 // passing them to the callee and perform checks before and after the
1237 // native call to ensure that they GCLocker
1238 // lock_critical/unlock_critical semantics are followed.  Some other
1239 // parts of JNI setup are skipped like the tear down of the JNI handle
1240 // block and the check for pending exceptions it&#39;s impossible for them
1241 // to be thrown.
1242 //
1243 // They are roughly structured like this:
1244 //    if (GCLocker::needs_gc())
1245 //      SharedRuntime::block_for_jni_critical();
1246 //    tranistion to thread_in_native
1247 //    unpack arrray arguments and call native entry point
1248 //    check for safepoint in progress
1249 //    check if any thread suspend flags are set
1250 //      call into JVM and possible unlock the JNI critical
1251 //      if a GC was suppressed while in the critical native.
1252 //    transition back to thread_in_Java
1253 //    return to caller
1254 //
1255 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
1256                                                 const methodHandle&amp; method,
1257                                                 int compile_id,
1258                                                 BasicType* in_sig_bt,
1259                                                 VMRegPair* in_regs,
1260                                                 BasicType ret_type,
1261                                                 address critical_entry) {
1262   if (method-&gt;is_method_handle_intrinsic()) {
1263     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1264     intptr_t start = (intptr_t)__ pc();
1265     int vep_offset = ((intptr_t)__ pc()) - start;
1266 
1267     // First instruction must be a nop as it may need to be patched on deoptimisation
1268     __ nop();
1269     gen_special_dispatch(masm,
1270                          method,
1271                          in_sig_bt,
1272                          in_regs);
1273     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1274     __ flush();
1275     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1276     return nmethod::new_native_nmethod(method,
1277                                        compile_id,
1278                                        masm-&gt;code(),
1279                                        vep_offset,
1280                                        frame_complete,
1281                                        stack_slots / VMRegImpl::slots_per_word,
1282                                        in_ByteSize(-1),
1283                                        in_ByteSize(-1),
1284                                        (OopMapSet*)NULL);
1285   }
1286   bool is_critical_native = true;
1287   address native_func = critical_entry;
1288   if (native_func == NULL) {
1289     native_func = method-&gt;native_function();
1290     is_critical_native = false;
1291   }
1292   assert(native_func != NULL, &quot;must have function&quot;);
1293 
1294   // An OopMap for lock (and class if static)
1295   OopMapSet *oop_maps = new OopMapSet();
1296   intptr_t start = (intptr_t)__ pc();
1297 
1298   // We have received a description of where all the java arg are located
1299   // on entry to the wrapper. We need to convert these args to where
1300   // the jni function will expect them. To figure out where they go
1301   // we convert the java signature to a C signature by inserting
1302   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1303 
1304   const int total_in_args = method-&gt;size_of_parameters();
1305   int total_c_args = total_in_args;
1306   if (!is_critical_native) {
1307     total_c_args += 1;
1308     if (method-&gt;is_static()) {
1309       total_c_args++;
1310     }
1311   } else {
1312     for (int i = 0; i &lt; total_in_args; i++) {
1313       if (in_sig_bt[i] == T_ARRAY) {
1314         total_c_args++;
1315       }
1316     }
1317   }
1318 
1319   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1320   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1321   BasicType* in_elem_bt = NULL;
1322 
1323   int argc = 0;
1324   if (!is_critical_native) {
1325     out_sig_bt[argc++] = T_ADDRESS;
1326     if (method-&gt;is_static()) {
1327       out_sig_bt[argc++] = T_OBJECT;
1328     }
1329 
1330     for (int i = 0; i &lt; total_in_args ; i++ ) {
1331       out_sig_bt[argc++] = in_sig_bt[i];
1332     }
1333   } else {
1334     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1335     SignatureStream ss(method-&gt;signature());
1336     for (int i = 0; i &lt; total_in_args ; i++ ) {
1337       if (in_sig_bt[i] == T_ARRAY) {
1338         // Arrays are passed as int, elem* pair
1339         out_sig_bt[argc++] = T_INT;
1340         out_sig_bt[argc++] = T_ADDRESS;
1341         ss.skip_array_prefix(1);  // skip one &#39;[&#39;
1342         assert(ss.is_primitive(), &quot;primitive type expected&quot;);
1343         in_elem_bt[i] = ss.type();
1344       } else {
1345         out_sig_bt[argc++] = in_sig_bt[i];
1346         in_elem_bt[i] = T_VOID;
1347       }
1348       if (in_sig_bt[i] != T_VOID) {
1349         assert(in_sig_bt[i] == ss.type() ||
1350                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);
1351         ss.next();
1352       }
1353     }
1354   }
1355 
1356   // Now figure out where the args must be stored and how much stack space
1357   // they require.
1358   int out_arg_slots;
1359   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
1360 
1361   // Compute framesize for the wrapper.  We need to handlize all oops in
1362   // incoming registers
1363 
1364   // Calculate the total number of stack slots we will need.
1365 
1366   // First count the abi requirement plus all of the outgoing args
1367   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
1368 
1369   // Now the space for the inbound oop handle area
1370   int total_save_slots = 8 * VMRegImpl::slots_per_word;  // 8 arguments passed in registers
1371   if (is_critical_native) {
1372     // Critical natives may have to call out so they need a save area
1373     // for register arguments.
1374     int double_slots = 0;
1375     int single_slots = 0;
1376     for ( int i = 0; i &lt; total_in_args; i++) {
1377       if (in_regs[i].first()-&gt;is_Register()) {
1378         const Register reg = in_regs[i].first()-&gt;as_Register();
1379         switch (in_sig_bt[i]) {
1380           case T_BOOLEAN:
1381           case T_BYTE:
1382           case T_SHORT:
1383           case T_CHAR:
1384           case T_INT:  single_slots++; break;
1385           case T_ARRAY:  // specific to LP64 (7145024)
1386           case T_LONG: double_slots++; break;
1387           default:  ShouldNotReachHere();
1388         }
1389       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1390         ShouldNotReachHere();
1391       }
1392     }
1393     total_save_slots = double_slots * 2 + single_slots;
1394     // align the save area
1395     if (double_slots != 0) {
1396       stack_slots = align_up(stack_slots, 2);
1397     }
1398   }
1399 
1400   int oop_handle_offset = stack_slots;
1401   stack_slots += total_save_slots;
1402 
1403   // Now any space we need for handlizing a klass if static method
1404 
1405   int klass_slot_offset = 0;
1406   int klass_offset = -1;
1407   int lock_slot_offset = 0;
1408   bool is_static = false;
1409 
1410   if (method-&gt;is_static()) {
1411     klass_slot_offset = stack_slots;
1412     stack_slots += VMRegImpl::slots_per_word;
1413     klass_offset = klass_slot_offset * VMRegImpl::stack_slot_size;
1414     is_static = true;
1415   }
1416 
1417   // Plus a lock if needed
1418 
1419   if (method-&gt;is_synchronized()) {
1420     lock_slot_offset = stack_slots;
1421     stack_slots += VMRegImpl::slots_per_word;
1422   }
1423 
1424   // Now a place (+2) to save return values or temp during shuffling
1425   // + 4 for return address (which we own) and saved rfp
1426   stack_slots += 6;
1427 
1428   // Ok The space we have allocated will look like:
1429   //
1430   //
1431   // FP-&gt; |                     |
1432   //      |---------------------|
1433   //      | 2 slots for moves   |
1434   //      |---------------------|
1435   //      | lock box (if sync)  |
1436   //      |---------------------| &lt;- lock_slot_offset
1437   //      | klass (if static)   |
1438   //      |---------------------| &lt;- klass_slot_offset
1439   //      | oopHandle area      |
1440   //      |---------------------| &lt;- oop_handle_offset (8 java arg registers)
1441   //      | outbound memory     |
1442   //      | based arguments     |
1443   //      |                     |
1444   //      |---------------------|
1445   //      |                     |
1446   // SP-&gt; | out_preserved_slots |
1447   //
1448   //
1449 
1450 
1451   // Now compute actual number of stack words we need rounding to make
1452   // stack properly aligned.
1453   stack_slots = align_up(stack_slots, StackAlignmentInSlots);
1454 
1455   int stack_size = stack_slots * VMRegImpl::stack_slot_size;
1456 
1457   // First thing make an ic check to see if we should even be here
1458 
1459   // We are free to use all registers as temps without saving them and
1460   // restoring them except rfp. rfp is the only callee save register
1461   // as far as the interpreter and the compiler(s) are concerned.
1462 
1463 
1464   const Register ic_reg = rscratch2;
1465   const Register receiver = j_rarg0;
1466 
1467   Label hit;
1468   Label exception_pending;
1469 
1470   assert_different_registers(ic_reg, receiver, rscratch1);
1471   __ verify_oop(receiver);
1472   __ cmp_klass(receiver, ic_reg, rscratch1);
1473   __ br(Assembler::EQ, hit);
1474 
1475   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1476 
1477   // Verified entry point must be aligned
1478   __ align(8);
1479 
1480   __ bind(hit);
1481 
1482   int vep_offset = ((intptr_t)__ pc()) - start;
1483 
1484   // If we have to make this method not-entrant we&#39;ll overwrite its
1485   // first instruction with a jump.  For this action to be legal we
1486   // must ensure that this first instruction is a B, BL, NOP, BKPT,
1487   // SVC, HVC, or SMC.  Make it a NOP.
1488   __ nop();
1489 
1490   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {
1491     Label L_skip_barrier;
1492     __ mov_metadata(rscratch2, method-&gt;method_holder()); // InstanceKlass*
1493     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
1494     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
1495 
1496     __ bind(L_skip_barrier);
1497   }
1498 
1499   // Generate stack overflow check
1500   if (UseStackBanging) {
1501     __ bang_stack_with_offset(JavaThread::stack_shadow_zone_size());
1502   } else {
1503     Unimplemented();
1504   }
1505 
1506   // Generate a new frame for the wrapper.
1507   __ enter();
1508   // -2 because return address is already present and so is saved rfp
1509   __ sub(sp, sp, stack_size - 2*wordSize);
1510 
1511   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1512   bs-&gt;nmethod_entry_barrier(masm);
1513 
1514   // Frame is now completed as far as size and linkage.
1515   int frame_complete = ((intptr_t)__ pc()) - start;
1516 
1517   // We use r20 as the oop handle for the receiver/klass
1518   // It is callee save so it survives the call to native
1519 
1520   const Register oop_handle_reg = r20;
1521 
1522   if (is_critical_native) {
1523     check_needs_gc_for_critical_native(masm, stack_slots, total_c_args, total_in_args,
1524                                        oop_handle_offset, oop_maps, in_regs, in_sig_bt);
1525   }
1526 
1527   //
1528   // We immediately shuffle the arguments so that any vm call we have to
1529   // make from here on out (sync slow path, jvmti, etc.) we will have
1530   // captured the oops from our caller and have a valid oopMap for
1531   // them.
1532 
1533   // -----------------
1534   // The Grand Shuffle
1535 
1536   // The Java calling convention is either equal (linux) or denser (win64) than the
1537   // c calling convention. However the because of the jni_env argument the c calling
1538   // convention always has at least one more (and two for static) arguments than Java.
1539   // Therefore if we move the args from java -&gt; c backwards then we will never have
1540   // a register-&gt;register conflict and we don&#39;t have to build a dependency graph
1541   // and figure out how to break any cycles.
1542   //
1543 
1544   // Record esp-based slot for receiver on stack for non-static methods
1545   int receiver_offset = -1;
1546 
1547   // This is a trick. We double the stack slots so we can claim
1548   // the oops in the caller&#39;s frame. Since we are sure to have
1549   // more args than the caller doubling is enough to make
1550   // sure we can capture all the incoming oop args from the
1551   // caller.
1552   //
1553   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1554 
1555   // Mark location of rfp (someday)
1556   // map-&gt;set_callee_saved(VMRegImpl::stack2reg( stack_slots - 2), stack_slots * 2, 0, vmreg(rfp));
1557 
1558 
1559   int float_args = 0;
1560   int int_args = 0;
1561 
1562 #ifdef ASSERT
1563   bool reg_destroyed[RegisterImpl::number_of_registers];
1564   bool freg_destroyed[FloatRegisterImpl::number_of_registers];
1565   for ( int r = 0 ; r &lt; RegisterImpl::number_of_registers ; r++ ) {
1566     reg_destroyed[r] = false;
1567   }
1568   for ( int f = 0 ; f &lt; FloatRegisterImpl::number_of_registers ; f++ ) {
1569     freg_destroyed[f] = false;
1570   }
1571 
1572 #endif /* ASSERT */
1573 
1574   // This may iterate in two different directions depending on the
1575   // kind of native it is.  The reason is that for regular JNI natives
1576   // the incoming and outgoing registers are offset upwards and for
1577   // critical natives they are offset down.
1578   GrowableArray&lt;int&gt; arg_order(2 * total_in_args);
1579   VMRegPair tmp_vmreg;
1580   tmp_vmreg.set2(r19-&gt;as_VMReg());
1581 
1582   if (!is_critical_native) {
1583     for (int i = total_in_args - 1, c_arg = total_c_args - 1; i &gt;= 0; i--, c_arg--) {
1584       arg_order.push(i);
1585       arg_order.push(c_arg);
1586     }
1587   } else {
1588     // Compute a valid move order, using tmp_vmreg to break any cycles
1589     ComputeMoveOrder cmo(total_in_args, in_regs, total_c_args, out_regs, in_sig_bt, arg_order, tmp_vmreg);
1590   }
1591 
1592   int temploc = -1;
1593   for (int ai = 0; ai &lt; arg_order.length(); ai += 2) {
1594     int i = arg_order.at(ai);
1595     int c_arg = arg_order.at(ai + 1);
1596     __ block_comment(err_msg(&quot;move %d -&gt; %d&quot;, i, c_arg));
1597     if (c_arg == -1) {
1598       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
1599       // This arg needs to be moved to a temporary
1600       __ mov(tmp_vmreg.first()-&gt;as_Register(), in_regs[i].first()-&gt;as_Register());
1601       in_regs[i] = tmp_vmreg;
1602       temploc = i;
1603       continue;
1604     } else if (i == -1) {
1605       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
1606       // Read from the temporary location
1607       assert(temploc != -1, &quot;must be valid&quot;);
1608       i = temploc;
1609       temploc = -1;
1610     }
1611 #ifdef ASSERT
1612     if (in_regs[i].first()-&gt;is_Register()) {
1613       assert(!reg_destroyed[in_regs[i].first()-&gt;as_Register()-&gt;encoding()], &quot;destroyed reg!&quot;);
1614     } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1615       assert(!freg_destroyed[in_regs[i].first()-&gt;as_FloatRegister()-&gt;encoding()], &quot;destroyed reg!&quot;);
1616     }
1617     if (out_regs[c_arg].first()-&gt;is_Register()) {
1618       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1619     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1620       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1621     }
1622 #endif /* ASSERT */
1623     switch (in_sig_bt[i]) {
1624       case T_ARRAY:
1625         if (is_critical_native) {
1626           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1627           c_arg++;
1628 #ifdef ASSERT
1629           if (out_regs[c_arg].first()-&gt;is_Register()) {
1630             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1631           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1632             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1633           }
1634 #endif
1635           int_args++;
1636           break;
1637         }
1638       case T_OBJECT:
1639         assert(!is_critical_native, &quot;no oop arguments&quot;);
1640         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1641                     ((i == 0) &amp;&amp; (!is_static)),
1642                     &amp;receiver_offset);
1643         int_args++;
1644         break;
1645       case T_VOID:
1646         break;
1647 
1648       case T_FLOAT:
1649         float_move(masm, in_regs[i], out_regs[c_arg]);
1650         float_args++;
1651         break;
1652 
1653       case T_DOUBLE:
1654         assert( i + 1 &lt; total_in_args &amp;&amp;
1655                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1656                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1657         double_move(masm, in_regs[i], out_regs[c_arg]);
1658         float_args++;
1659         break;
1660 
1661       case T_LONG :
1662         long_move(masm, in_regs[i], out_regs[c_arg]);
1663         int_args++;
1664         break;
1665 
1666       case T_ADDRESS: assert(false, &quot;found T_ADDRESS in java args&quot;);
1667 
1668       default:
1669         move32_64(masm, in_regs[i], out_regs[c_arg]);
1670         int_args++;
1671     }
1672   }
1673 
1674   // point c_arg at the first arg that is already loaded in case we
1675   // need to spill before we call out
1676   int c_arg = total_c_args - total_in_args;
1677 
1678   // Pre-load a static method&#39;s oop into c_rarg1.
1679   if (method-&gt;is_static() &amp;&amp; !is_critical_native) {
1680 
1681     //  load oop into a register
1682     __ movoop(c_rarg1,
1683               JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()),
1684               /*immediate*/true);
1685 
1686     // Now handlize the static class mirror it&#39;s known not-null.
1687     __ str(c_rarg1, Address(sp, klass_offset));
1688     map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
1689 
1690     // Now get the handle
1691     __ lea(c_rarg1, Address(sp, klass_offset));
1692     // and protect the arg if we must spill
1693     c_arg--;
1694   }
1695 
1696   // Change state to native (we save the return address in the thread, since it might not
1697   // be pushed on the stack when we do a stack traversal).
1698   // We use the same pc/oopMap repeatedly when we call out
1699 
1700   Label native_return;
1701   __ set_last_Java_frame(sp, noreg, native_return, rscratch1);
1702 
1703   Label dtrace_method_entry, dtrace_method_entry_done;
1704   {
1705     unsigned long offset;
1706     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1707     __ ldrb(rscratch1, Address(rscratch1, offset));
1708     __ cbnzw(rscratch1, dtrace_method_entry);
1709     __ bind(dtrace_method_entry_done);
1710   }
1711 
1712   // RedefineClasses() tracing support for obsolete method entry
1713   if (log_is_enabled(Trace, redefine, class, obsolete)) {
1714     // protect the args we&#39;ve loaded
1715     save_args(masm, total_c_args, c_arg, out_regs);
1716     __ mov_metadata(c_rarg1, method());
1717     __ call_VM_leaf(
1718       CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry),
1719       rthread, c_rarg1);
1720     restore_args(masm, total_c_args, c_arg, out_regs);
1721   }
1722 
1723   // Lock a synchronized method
1724 
1725   // Register definitions used by locking and unlocking
1726 
1727   const Register swap_reg = r0;
1728   const Register obj_reg  = r19;  // Will contain the oop
1729   const Register lock_reg = r13;  // Address of compiler lock object (BasicLock)
1730   const Register old_hdr  = r13;  // value of old header at unlock time
1731   const Register tmp = lr;
1732 
1733   Label slow_path_lock;
1734   Label lock_done;
1735 
1736   if (method-&gt;is_synchronized()) {
1737     assert(!is_critical_native, &quot;unhandled&quot;);
1738 
1739     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
1740 
1741     // Get the handle (the 2nd argument)
1742     __ mov(oop_handle_reg, c_rarg1);
1743 
1744     // Get address of the box
1745 
1746     __ lea(lock_reg, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
1747 
1748     // Load the oop from the handle
1749     __ ldr(obj_reg, Address(oop_handle_reg, 0));
1750 
1751     __ resolve(IS_NOT_NULL, obj_reg);
1752 
1753     if (UseBiasedLocking) {
1754       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, lock_done, &amp;slow_path_lock);
1755     }
1756 
1757     // Load (object-&gt;mark() | 1) into swap_reg %r0
1758     __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1759     __ orr(swap_reg, rscratch1, 1);
1760 
1761     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
1762     __ str(swap_reg, Address(lock_reg, mark_word_offset));
1763 
1764     // src -&gt; dest iff dest == r0 else r0 &lt;- dest
1765     { Label here;
1766       __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, lock_done, /*fallthrough*/NULL);
1767     }
1768 
1769     // Hmm should this move to the slow path code area???
1770 
1771     // Test if the oopMark is an obvious stack pointer, i.e.,
1772     //  1) (mark &amp; 3) == 0, and
1773     //  2) sp &lt;= mark &lt; mark + os::pagesize()
1774     // These 3 tests can be done by evaluating the following
1775     // expression: ((mark - sp) &amp; (3 - os::vm_page_size())),
1776     // assuming both stack pointer and pagesize have their
1777     // least significant 2 bits clear.
1778     // NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg
1779 
1780     __ sub(swap_reg, sp, swap_reg);
1781     __ neg(swap_reg, swap_reg);
1782     __ ands(swap_reg, swap_reg, 3 - os::vm_page_size());
1783 
1784     // Save the test result, for recursive case, the result is zero
1785     __ str(swap_reg, Address(lock_reg, mark_word_offset));
1786     __ br(Assembler::NE, slow_path_lock);
1787 
1788     // Slow path will re-enter here
1789 
1790     __ bind(lock_done);
1791   }
1792 
1793 
1794   // Finally just about ready to make the JNI call
1795 
1796   // get JNIEnv* which is first argument to native
1797   if (!is_critical_native) {
1798     __ lea(c_rarg0, Address(rthread, in_bytes(JavaThread::jni_environment_offset())));
1799   }
1800 
1801   // Now set thread in native
1802   __ mov(rscratch1, _thread_in_native);
1803   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1804   __ stlrw(rscratch1, rscratch2);
1805 
1806   {
1807     int return_type = 0;
1808     switch (ret_type) {
1809     case T_VOID: break;
1810       return_type = 0; break;
1811     case T_CHAR:
1812     case T_BYTE:
1813     case T_SHORT:
1814     case T_INT:
1815     case T_BOOLEAN:
1816     case T_LONG:
1817       return_type = 1; break;
1818     case T_ARRAY:
1819     case T_OBJECT:
1820       return_type = 1; break;
1821     case T_FLOAT:
1822       return_type = 2; break;
1823     case T_DOUBLE:
1824       return_type = 3; break;
1825     default:
1826       ShouldNotReachHere();
1827     }
1828     rt_call(masm, native_func,
1829             int_args + 2, // AArch64 passes up to 8 args in int registers
1830             float_args,   // and up to 8 float args
1831             return_type);
1832   }
1833 
1834   __ bind(native_return);
1835 
1836   intptr_t return_pc = (intptr_t) __ pc();
1837   oop_maps-&gt;add_gc_map(return_pc - start, map);
1838 
1839   // Unpack native results.
1840   switch (ret_type) {
1841   case T_BOOLEAN: __ c2bool(r0);                     break;
1842   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
1843   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
1844   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
1845   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
1846   case T_DOUBLE :
1847   case T_FLOAT  :
1848     // Result is in v0 we&#39;ll save as needed
1849     break;
1850   case T_ARRAY:                 // Really a handle
1851   case T_OBJECT:                // Really a handle
1852       break; // can&#39;t de-handlize until after safepoint check
1853   case T_VOID: break;
1854   case T_LONG: break;
1855   default       : ShouldNotReachHere();
1856   }
1857 
1858   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
1859   // This additional state is necessary because reading and testing the synchronization
1860   // state is not atomic w.r.t. GC, as this scenario demonstrates:
1861   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
1862   //     VM thread changes sync state to synchronizing and suspends threads for GC.
1863   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
1864   //     didn&#39;t see any synchronization is progress, and escapes.
1865   __ mov(rscratch1, _thread_in_native_trans);
1866 
1867   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
1868 
1869   // Force this write out before the read below
1870   __ dmb(Assembler::ISH);
1871 
1872   // check for safepoint operation in progress and/or pending suspend requests
1873   Label safepoint_in_progress, safepoint_in_progress_done;
1874   {
1875     __ safepoint_poll_acquire(safepoint_in_progress);
1876     __ ldrw(rscratch1, Address(rthread, JavaThread::suspend_flags_offset()));
1877     __ cbnzw(rscratch1, safepoint_in_progress);
1878     __ bind(safepoint_in_progress_done);
1879   }
1880 
1881   // change thread state
1882   Label after_transition;
1883   __ mov(rscratch1, _thread_in_Java);
1884   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1885   __ stlrw(rscratch1, rscratch2);
1886   __ bind(after_transition);
1887 
1888   Label reguard;
1889   Label reguard_done;
1890   __ ldrb(rscratch1, Address(rthread, JavaThread::stack_guard_state_offset()));
1891   __ cmpw(rscratch1, JavaThread::stack_guard_yellow_reserved_disabled);
1892   __ br(Assembler::EQ, reguard);
1893   __ bind(reguard_done);
1894 
1895   // native result if any is live
1896 
1897   // Unlock
1898   Label unlock_done;
1899   Label slow_path_unlock;
1900   if (method-&gt;is_synchronized()) {
1901 
1902     // Get locked oop from the handle we passed to jni
1903     __ ldr(obj_reg, Address(oop_handle_reg, 0));
1904 
1905     __ resolve(IS_NOT_NULL, obj_reg);
1906 
1907     Label done;
1908 
1909     if (UseBiasedLocking) {
1910       __ biased_locking_exit(obj_reg, old_hdr, done);
1911     }
1912 
1913     // Simple recursive lock?
1914 
1915     __ ldr(rscratch1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
1916     __ cbz(rscratch1, done);
1917 
1918     // Must save r0 if if it is live now because cmpxchg must use it
1919     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
1920       save_native_result(masm, ret_type, stack_slots);
1921     }
1922 
1923 
1924     // get address of the stack lock
1925     __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
1926     //  get old displaced header
1927     __ ldr(old_hdr, Address(r0, 0));
1928 
1929     // Atomic swap old header if oop still contains the stack lock
1930     Label succeed;
1931     __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, succeed, &amp;slow_path_unlock);
1932     __ bind(succeed);
1933 
1934     // slow path re-enters here
1935     __ bind(unlock_done);
1936     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
1937       restore_native_result(masm, ret_type, stack_slots);
1938     }
1939 
1940     __ bind(done);
1941   }
1942 
1943   Label dtrace_method_exit, dtrace_method_exit_done;
1944   {
1945     unsigned long offset;
1946     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1947     __ ldrb(rscratch1, Address(rscratch1, offset));
1948     __ cbnzw(rscratch1, dtrace_method_exit);
1949     __ bind(dtrace_method_exit_done);
1950   }
1951 
1952   __ reset_last_Java_frame(false);
1953 
1954   // Unbox oop result, e.g. JNIHandles::resolve result.
1955   if (is_reference_type(ret_type)) {
1956     __ resolve_jobject(r0, rthread, rscratch2);
1957   }
1958 
1959   if (CheckJNICalls) {
1960     // clear_pending_jni_exception_check
1961     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
1962   }
1963 
1964   if (!is_critical_native) {
1965     // reset handle block
1966     __ ldr(r2, Address(rthread, JavaThread::active_handles_offset()));
1967     __ str(zr, Address(r2, JNIHandleBlock::top_offset_in_bytes()));
1968   }
1969 
1970   __ leave();
1971 
1972   if (!is_critical_native) {
1973     // Any exception pending?
1974     __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
1975     __ cbnz(rscratch1, exception_pending);
1976   }
1977 
1978   // We&#39;re done
1979   __ ret(lr);
1980 
1981   // Unexpected paths are out of line and go here
1982 
1983   if (!is_critical_native) {
1984     // forward the exception
1985     __ bind(exception_pending);
1986 
1987     // and forward the exception
1988     __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
1989   }
1990 
1991   // Slow path locking &amp; unlocking
1992   if (method-&gt;is_synchronized()) {
1993 
1994     __ block_comment(&quot;Slow path lock {&quot;);
1995     __ bind(slow_path_lock);
1996 
1997     // has last_Java_frame setup. No exceptions so do vanilla call not call_VM
1998     // args are (oop obj, BasicLock* lock, JavaThread* thread)
1999 
2000     // protect the args we&#39;ve loaded
2001     save_args(masm, total_c_args, c_arg, out_regs);
2002 
2003     __ mov(c_rarg0, obj_reg);
2004     __ mov(c_rarg1, lock_reg);
2005     __ mov(c_rarg2, rthread);
2006 
2007     // Not a leaf but we have last_Java_frame setup as we want
2008     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), 3);
2009     restore_args(masm, total_c_args, c_arg, out_regs);
2010 
2011 #ifdef ASSERT
2012     { Label L;
2013       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2014       __ cbz(rscratch1, L);
2015       __ stop(&quot;no pending exception allowed on exit from monitorenter&quot;);
2016       __ bind(L);
2017     }
2018 #endif
2019     __ b(lock_done);
2020 
2021     __ block_comment(&quot;} Slow path lock&quot;);
2022 
2023     __ block_comment(&quot;Slow path unlock {&quot;);
2024     __ bind(slow_path_unlock);
2025 
2026     // If we haven&#39;t already saved the native result we must save it now as xmm registers
2027     // are still exposed.
2028 
2029     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2030       save_native_result(masm, ret_type, stack_slots);
2031     }
2032 
2033     __ mov(c_rarg2, rthread);
2034     __ lea(c_rarg1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2035     __ mov(c_rarg0, obj_reg);
2036 
2037     // Save pending exception around call to VM (which contains an EXCEPTION_MARK)
2038     // NOTE that obj_reg == r19 currently
2039     __ ldr(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2040     __ str(zr, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2041 
2042     rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C), 3, 0, 1);
2043 
2044 #ifdef ASSERT
2045     {
2046       Label L;
2047       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2048       __ cbz(rscratch1, L);
2049       __ stop(&quot;no pending exception allowed on exit complete_monitor_unlocking_C&quot;);
2050       __ bind(L);
2051     }
2052 #endif /* ASSERT */
2053 
2054     __ str(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2055 
2056     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2057       restore_native_result(masm, ret_type, stack_slots);
2058     }
2059     __ b(unlock_done);
2060 
2061     __ block_comment(&quot;} Slow path unlock&quot;);
2062 
2063   } // synchronized
2064 
2065   // SLOW PATH Reguard the stack if needed
2066 
2067   __ bind(reguard);
2068   save_native_result(masm, ret_type, stack_slots);
2069   rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), 0, 0, 0);
2070   restore_native_result(masm, ret_type, stack_slots);
2071   // and continue
2072   __ b(reguard_done);
2073 
2074   // SLOW PATH safepoint
2075   {
2076     __ block_comment(&quot;safepoint {&quot;);
2077     __ bind(safepoint_in_progress);
2078 
2079     // Don&#39;t use call_VM as it will see a possible pending exception and forward it
2080     // and never return here preventing us from clearing _last_native_pc down below.
2081     //
2082     save_native_result(masm, ret_type, stack_slots);
2083     __ mov(c_rarg0, rthread);
2084 #ifndef PRODUCT
2085   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2086 #endif
2087     if (!is_critical_native) {
2088       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
2089     } else {
2090       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
2091     }
2092     __ blr(rscratch1);
2093     __ maybe_isb();
2094     // Restore any method result value
2095     restore_native_result(masm, ret_type, stack_slots);
2096 
2097     if (is_critical_native) {
2098       // The call above performed the transition to thread_in_Java so
2099       // skip the transition logic above.
2100       __ b(after_transition);
2101     }
2102 
2103     __ b(safepoint_in_progress_done);
2104     __ block_comment(&quot;} safepoint&quot;);
2105   }
2106 
2107   // SLOW PATH dtrace support
2108   {
2109     __ block_comment(&quot;dtrace entry {&quot;);
2110     __ bind(dtrace_method_entry);
2111 
2112     // We have all of the arguments setup at this point. We must not touch any register
2113     // argument registers at this point (what if we save/restore them there are no oop?
2114 
2115     save_args(masm, total_c_args, c_arg, out_regs);
2116     __ mov_metadata(c_rarg1, method());
2117     __ call_VM_leaf(
2118       CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),
2119       rthread, c_rarg1);
2120     restore_args(masm, total_c_args, c_arg, out_regs);
2121     __ b(dtrace_method_entry_done);
2122     __ block_comment(&quot;} dtrace entry&quot;);
2123   }
2124 
2125   {
2126     __ block_comment(&quot;dtrace exit {&quot;);
2127     __ bind(dtrace_method_exit);
2128     save_native_result(masm, ret_type, stack_slots);
2129     __ mov_metadata(c_rarg1, method());
2130     __ call_VM_leaf(
2131          CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),
2132          rthread, c_rarg1);
2133     restore_native_result(masm, ret_type, stack_slots);
2134     __ b(dtrace_method_exit_done);
2135     __ block_comment(&quot;} dtrace exit&quot;);
2136   }
2137 
2138 
2139   __ flush();
2140 
2141   nmethod *nm = nmethod::new_native_nmethod(method,
2142                                             compile_id,
2143                                             masm-&gt;code(),
2144                                             vep_offset,
2145                                             frame_complete,
2146                                             stack_slots / VMRegImpl::slots_per_word,
2147                                             (is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2148                                             in_ByteSize(lock_slot_offset*VMRegImpl::stack_slot_size),
2149                                             oop_maps);
2150 
2151   if (is_critical_native) {
2152     nm-&gt;set_lazy_critical_native(true);
2153   }
2154 
2155   return nm;
2156 
2157 }
2158 
2159 // this function returns the adjust size (in number of words) to a c2i adapter
2160 // activation for use during deoptimization
2161 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
2162   assert(callee_locals &gt;= callee_parameters,
2163           &quot;test and remove; got more parms than locals&quot;);
2164   if (callee_locals &lt; callee_parameters)
2165     return 0;                   // No adjustment for negative locals
2166   int diff = (callee_locals - callee_parameters) * Interpreter::stackElementWords;
2167   // diff is counted in stack words
2168   return align_up(diff, 2);
2169 }
2170 
2171 
2172 //------------------------------generate_deopt_blob----------------------------
2173 void SharedRuntime::generate_deopt_blob() {
2174   // Allocate space for the code
2175   ResourceMark rm;
2176   // Setup code generation tools
2177   int pad = 0;
2178 #if INCLUDE_JVMCI
2179   if (EnableJVMCI || UseAOT) {
2180     pad += 512; // Increase the buffer size when compiling for JVMCI
2181   }
2182 #endif
2183   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048+pad, 1024);
2184   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2185   int frame_size_in_words;
2186   OopMap* map = NULL;
2187   OopMapSet *oop_maps = new OopMapSet();
2188 
2189   // -------------
2190   // This code enters when returning to a de-optimized nmethod.  A return
2191   // address has been pushed on the the stack, and return values are in
2192   // registers.
2193   // If we are doing a normal deopt then we were called from the patched
2194   // nmethod from the point we returned to the nmethod. So the return
2195   // address on the stack is wrong by NativeCall::instruction_size
2196   // We will adjust the value so it looks like we have the original return
2197   // address on the stack (like when we eagerly deoptimized).
2198   // In the case of an exception pending when deoptimizing, we enter
2199   // with a return address on the stack that points after the call we patched
2200   // into the exception handler. We have the following register state from,
2201   // e.g., the forward exception stub (see stubGenerator_x86_64.cpp).
2202   //    r0: exception oop
2203   //    r19: exception handler
2204   //    r3: throwing pc
2205   // So in this case we simply jam r3 into the useless return address and
2206   // the stack looks just like we want.
2207   //
2208   // At this point we need to de-opt.  We save the argument return
2209   // registers.  We call the first C routine, fetch_unroll_info().  This
2210   // routine captures the return values and returns a structure which
2211   // describes the current frame size and the sizes of all replacement frames.
2212   // The current frame is compiled code and may contain many inlined
2213   // functions, each with their own JVM state.  We pop the current frame, then
2214   // push all the new frames.  Then we call the C routine unpack_frames() to
2215   // populate these frames.  Finally unpack_frames() returns us the new target
2216   // address.  Notice that callee-save registers are BLOWN here; they have
2217   // already been captured in the vframeArray at the time the return PC was
2218   // patched.
2219   address start = __ pc();
2220   Label cont;
2221 
2222   // Prolog for non exception case!
2223 
2224   // Save everything in sight.
2225   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2226 
2227   // Normal deoptimization.  Save exec mode for unpack_frames.
2228   __ movw(rcpool, Deoptimization::Unpack_deopt); // callee-saved
2229   __ b(cont);
2230 
2231   int reexecute_offset = __ pc() - start;
2232 #if INCLUDE_JVMCI &amp;&amp; !defined(COMPILER1)
2233   if (EnableJVMCI &amp;&amp; UseJVMCICompiler) {
2234     // JVMCI does not use this kind of deoptimization
2235     __ should_not_reach_here();
2236   }
2237 #endif
2238 
2239   // Reexecute case
2240   // return address is the pc describes what bci to do re-execute at
2241 
2242   // No need to update map as each call to save_live_registers will produce identical oopmap
2243   (void) RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2244 
2245   __ movw(rcpool, Deoptimization::Unpack_reexecute); // callee-saved
2246   __ b(cont);
2247 
2248 #if INCLUDE_JVMCI
2249   Label after_fetch_unroll_info_call;
2250   int implicit_exception_uncommon_trap_offset = 0;
2251   int uncommon_trap_offset = 0;
2252 
2253   if (EnableJVMCI || UseAOT) {
2254     implicit_exception_uncommon_trap_offset = __ pc() - start;
2255 
2256     __ ldr(lr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2257     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2258 
2259     uncommon_trap_offset = __ pc() - start;
2260 
2261     // Save everything in sight.
2262     RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2263     // fetch_unroll_info needs to call last_java_frame()
2264     Label retaddr;
2265     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2266 
2267     __ ldrw(c_rarg1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2268     __ movw(rscratch1, -1);
2269     __ strw(rscratch1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2270 
2271     __ movw(rcpool, (int32_t)Deoptimization::Unpack_reexecute);
2272     __ mov(c_rarg0, rthread);
2273     __ movw(c_rarg2, rcpool); // exec mode
2274     __ lea(rscratch1,
2275            RuntimeAddress(CAST_FROM_FN_PTR(address,
2276                                            Deoptimization::uncommon_trap)));
2277     __ blr(rscratch1);
2278     __ bind(retaddr);
2279     oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
2280 
2281     __ reset_last_Java_frame(false);
2282 
2283     __ b(after_fetch_unroll_info_call);
2284   } // EnableJVMCI
2285 #endif // INCLUDE_JVMCI
2286 
2287   int exception_offset = __ pc() - start;
2288 
2289   // Prolog for exception case
2290 
2291   // all registers are dead at this entry point, except for r0, and
2292   // r3 which contain the exception oop and exception pc
2293   // respectively.  Set them in TLS and fall thru to the
2294   // unpack_with_exception_in_tls entry point.
2295 
2296   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
2297   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
2298 
2299   int exception_in_tls_offset = __ pc() - start;
2300 
2301   // new implementation because exception oop is now passed in JavaThread
2302 
2303   // Prolog for exception case
2304   // All registers must be preserved because they might be used by LinearScan
2305   // Exceptiop oop and throwing PC are passed in JavaThread
2306   // tos: stack at point of call to method that threw the exception (i.e. only
2307   // args are on the stack, no return address)
2308 
2309   // The return address pushed by save_live_registers will be patched
2310   // later with the throwing pc. The correct value is not available
2311   // now because loading it from memory would destroy registers.
2312 
2313   // NB: The SP at this point must be the SP of the method that is
2314   // being deoptimized.  Deoptimization assumes that the frame created
2315   // here by save_live_registers is immediately below the method&#39;s SP.
2316   // This is a somewhat fragile mechanism.
2317 
2318   // Save everything in sight.
2319   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2320 
2321   // Now it is safe to overwrite any register
2322 
2323   // Deopt during an exception.  Save exec mode for unpack_frames.
2324   __ mov(rcpool, Deoptimization::Unpack_exception); // callee-saved
2325 
2326   // load throwing pc from JavaThread and patch it as the return address
2327   // of the current frame. Then clear the field in JavaThread
2328 
2329   __ ldr(r3, Address(rthread, JavaThread::exception_pc_offset()));
2330   __ str(r3, Address(rfp, wordSize));
2331   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
2332 
2333 #ifdef ASSERT
2334   // verify that there is really an exception oop in JavaThread
2335   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
2336   __ verify_oop(r0);
2337 
2338   // verify that there is no pending exception
2339   Label no_pending_exception;
2340   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2341   __ cbz(rscratch1, no_pending_exception);
2342   __ stop(&quot;must not have pending exception here&quot;);
2343   __ bind(no_pending_exception);
2344 #endif
2345 
2346   __ bind(cont);
2347 
2348   // Call C code.  Need thread and this frame, but NOT official VM entry
2349   // crud.  We cannot block on this call, no GC can happen.
2350   //
2351   // UnrollBlock* fetch_unroll_info(JavaThread* thread)
2352 
2353   // fetch_unroll_info needs to call last_java_frame().
2354 
2355   Label retaddr;
2356   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2357 #ifdef ASSERT0
2358   { Label L;
2359     __ ldr(rscratch1, Address(rthread,
2360                               JavaThread::last_Java_fp_offset()));
2361     __ cbz(rscratch1, L);
2362     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2363     __ bind(L);
2364   }
2365 #endif // ASSERT
2366   __ mov(c_rarg0, rthread);
2367   __ mov(c_rarg1, rcpool);
2368   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
2369   __ blr(rscratch1);
2370   __ bind(retaddr);
2371 
2372   // Need to have an oopmap that tells fetch_unroll_info where to
2373   // find any register it might need.
2374   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2375 
2376   __ reset_last_Java_frame(false);
2377 
2378 #if INCLUDE_JVMCI
2379   if (EnableJVMCI || UseAOT) {
2380     __ bind(after_fetch_unroll_info_call);
2381   }
2382 #endif
2383 
2384   // Load UnrollBlock* into r5
2385   __ mov(r5, r0);
2386 
2387   __ ldrw(rcpool, Address(r5, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2388    Label noException;
2389   __ cmpw(rcpool, Deoptimization::Unpack_exception);   // Was exception pending?
2390   __ br(Assembler::NE, noException);
2391   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
2392   // QQQ this is useless it was NULL above
2393   __ ldr(r3, Address(rthread, JavaThread::exception_pc_offset()));
2394   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
2395   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
2396 
2397   __ verify_oop(r0);
2398 
2399   // Overwrite the result registers with the exception results.
2400   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2401   // I think this is useless
2402   // __ str(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2403 
2404   __ bind(noException);
2405 
2406   // Only register save data is on the stack.
2407   // Now restore the result registers.  Everything else is either dead
2408   // or captured in the vframeArray.
2409   RegisterSaver::restore_result_registers(masm);
2410 
2411   // All of the register save area has been popped of the stack. Only the
2412   // return address remains.
2413 
2414   // Pop all the frames we must move/replace.
2415   //
2416   // Frame picture (youngest to oldest)
2417   // 1: self-frame (no frame link)
2418   // 2: deopting frame  (no frame link)
2419   // 3: caller of deopting frame (could be compiled/interpreted).
2420   //
2421   // Note: by leaving the return address of self-frame on the stack
2422   // and using the size of frame 2 to adjust the stack
2423   // when we are done the return to frame 3 will still be on the stack.
2424 
2425   // Pop deoptimized frame
2426   __ ldrw(r2, Address(r5, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
2427   __ sub(r2, r2, 2 * wordSize);
2428   __ add(sp, sp, r2);
2429   __ ldp(rfp, lr, __ post(sp, 2 * wordSize));
2430   // LR should now be the return address to the caller (3)
2431 
2432 #ifdef ASSERT
2433   // Compilers generate code that bang the stack by as much as the
2434   // interpreter would need. So this stack banging should never
2435   // trigger a fault. Verify that it does not on non product builds.
2436   if (UseStackBanging) {
2437     __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
2438     __ bang_stack_size(r19, r2);
2439   }
2440 #endif
2441   // Load address of array of frame pcs into r2
2442   __ ldr(r2, Address(r5, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2443 
2444   // Trash the old pc
2445   // __ addptr(sp, wordSize);  FIXME ????
2446 
2447   // Load address of array of frame sizes into r4
2448   __ ldr(r4, Address(r5, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
2449 
2450   // Load counter into r3
2451   __ ldrw(r3, Address(r5, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
2452 
2453   // Now adjust the caller&#39;s stack to make up for the extra locals
2454   // but record the original sp so that we can save it in the skeletal interpreter
2455   // frame and the stack walking of interpreter_sender will get the unextended sp
2456   // value and not the &quot;real&quot; sp value.
2457 
2458   const Register sender_sp = r6;
2459 
2460   __ mov(sender_sp, sp);
2461   __ ldrw(r19, Address(r5,
2462                        Deoptimization::UnrollBlock::
2463                        caller_adjustment_offset_in_bytes()));
2464   __ sub(sp, sp, r19);
2465 
2466   // Push interpreter frames in a loop
2467   __ mov(rscratch1, (address)0xDEADDEAD);        // Make a recognizable pattern
2468   __ mov(rscratch2, rscratch1);
2469   Label loop;
2470   __ bind(loop);
2471   __ ldr(r19, Address(__ post(r4, wordSize)));          // Load frame size
2472   __ sub(r19, r19, 2*wordSize);           // We&#39;ll push pc and fp by hand
2473   __ ldr(lr, Address(__ post(r2, wordSize)));  // Load pc
2474   __ enter();                           // Save old &amp; set new fp
2475   __ sub(sp, sp, r19);                  // Prolog
2476   // This value is corrected by layout_activation_impl
2477   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
2478   __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); // Make it walkable
2479   __ mov(sender_sp, sp);               // Pass sender_sp to next frame
2480   __ sub(r3, r3, 1);                   // Decrement counter
2481   __ cbnz(r3, loop);
2482 
2483     // Re-push self-frame
2484   __ ldr(lr, Address(r2));
2485   __ enter();
2486 
2487   // Allocate a full sized register save area.  We subtract 2 because
2488   // enter() just pushed 2 words
2489   __ sub(sp, sp, (frame_size_in_words - 2) * wordSize);
2490 
2491   // Restore frame locals after moving the frame
2492   __ strd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2493   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2494 
2495   // Call C code.  Need thread but NOT official VM entry
2496   // crud.  We cannot block on this call, no GC can happen.  Call should
2497   // restore return values to their stack-slots with the new SP.
2498   //
2499   // void Deoptimization::unpack_frames(JavaThread* thread, int exec_mode)
2500 
2501   // Use rfp because the frames look interpreted now
2502   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2503   address the_pc = __ pc();
2504   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2505 
2506   __ mov(c_rarg0, rthread);
2507   __ movw(c_rarg1, rcpool); // second arg: exec_mode
2508   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
2509   __ blr(rscratch1);
2510 
2511   // Set an oopmap for the call site
2512   // Use the same PC we used for the last java frame
2513   oop_maps-&gt;add_gc_map(the_pc - start,
2514                        new OopMap( frame_size_in_words, 0 ));
2515 
2516   // Clear fp AND pc
2517   __ reset_last_Java_frame(true);
2518 
2519   // Collect return values
2520   __ ldrd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2521   __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2522   // I think this is useless (throwing pc?)
2523   // __ ldr(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2524 
2525   // Pop self-frame.
2526   __ leave();                           // Epilog
2527 
2528   // Jump to interpreter
2529   __ ret(lr);
2530 
2531   // Make sure all code is generated
2532   masm-&gt;flush();
2533 
2534   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
2535   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
2536 #if INCLUDE_JVMCI
2537   if (EnableJVMCI || UseAOT) {
2538     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
2539     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
2540   }
2541 #endif
2542 }
2543 
2544 uint SharedRuntime::out_preserve_stack_slots() {
2545   return 0;
2546 }
2547 
2548 #ifdef COMPILER2
2549 //------------------------------generate_uncommon_trap_blob--------------------
2550 void SharedRuntime::generate_uncommon_trap_blob() {
2551   // Allocate space for the code
2552   ResourceMark rm;
2553   // Setup code generation tools
2554   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
2555   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2556 
2557   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
2558 
2559   address start = __ pc();
2560 
2561   // Push self-frame.  We get here with a return address in LR
2562   // and sp should be 16 byte aligned
2563   // push rfp and retaddr by hand
2564   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
2565   // we don&#39;t expect an arg reg save area
2566 #ifndef PRODUCT
2567   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2568 #endif
2569   // compiler left unloaded_class_index in j_rarg0 move to where the
2570   // runtime expects it.
2571   if (c_rarg1 != j_rarg0) {
2572     __ movw(c_rarg1, j_rarg0);
2573   }
2574 
2575   // we need to set the past SP to the stack pointer of the stub frame
2576   // and the pc to the address where this runtime call will return
2577   // although actually any pc in this code blob will do).
2578   Label retaddr;
2579   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2580 
2581   // Call C code.  Need thread but NOT official VM entry
2582   // crud.  We cannot block on this call, no GC can happen.  Call should
2583   // capture callee-saved registers as well as return values.
2584   // Thread is in rdi already.
2585   //
2586   // UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);
2587   //
2588   // n.b. 2 gp args, 0 fp args, integral return type
2589 
2590   __ mov(c_rarg0, rthread);
2591   __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);
2592   __ lea(rscratch1,
2593          RuntimeAddress(CAST_FROM_FN_PTR(address,
2594                                          Deoptimization::uncommon_trap)));
2595   __ blr(rscratch1);
2596   __ bind(retaddr);
2597 
2598   // Set an oopmap for the call site
2599   OopMapSet* oop_maps = new OopMapSet();
2600   OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
2601 
2602   // location of rfp is known implicitly by the frame sender code
2603 
2604   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2605 
2606   __ reset_last_Java_frame(false);
2607 
2608   // move UnrollBlock* into r4
2609   __ mov(r4, r0);
2610 
2611 #ifdef ASSERT
2612   { Label L;
2613     __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2614     __ cmpw(rscratch1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2615     __ br(Assembler::EQ, L);
2616     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2617     __ bind(L);
2618   }
2619 #endif
2620 
2621   // Pop all the frames we must move/replace.
2622   //
2623   // Frame picture (youngest to oldest)
2624   // 1: self-frame (no frame link)
2625   // 2: deopting frame  (no frame link)
2626   // 3: caller of deopting frame (could be compiled/interpreted).
2627 
2628   // Pop self-frame.  We have no frame, and must rely only on r0 and sp.
2629   __ add(sp, sp, (SimpleRuntimeFrame::framesize) &lt;&lt; LogBytesPerInt); // Epilog!
2630 
2631   // Pop deoptimized frame (int)
2632   __ ldrw(r2, Address(r4,
2633                       Deoptimization::UnrollBlock::
2634                       size_of_deoptimized_frame_offset_in_bytes()));
2635   __ sub(r2, r2, 2 * wordSize);
2636   __ add(sp, sp, r2);
2637   __ ldp(rfp, lr, __ post(sp, 2 * wordSize));
2638   // LR should now be the return address to the caller (3) frame
2639 
2640 #ifdef ASSERT
2641   // Compilers generate code that bang the stack by as much as the
2642   // interpreter would need. So this stack banging should never
2643   // trigger a fault. Verify that it does not on non product builds.
2644   if (UseStackBanging) {
2645     __ ldrw(r1, Address(r4,
2646                         Deoptimization::UnrollBlock::
2647                         total_frame_sizes_offset_in_bytes()));
2648     __ bang_stack_size(r1, r2);
2649   }
2650 #endif
2651 
2652   // Load address of array of frame pcs into r2 (address*)
2653   __ ldr(r2, Address(r4,
2654                      Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2655 
2656   // Load address of array of frame sizes into r5 (intptr_t*)
2657   __ ldr(r5, Address(r4,
2658                      Deoptimization::UnrollBlock::
2659                      frame_sizes_offset_in_bytes()));
2660 
2661   // Counter
2662   __ ldrw(r3, Address(r4,
2663                       Deoptimization::UnrollBlock::
2664                       number_of_frames_offset_in_bytes())); // (int)
2665 
2666   // Now adjust the caller&#39;s stack to make up for the extra locals but
2667   // record the original sp so that we can save it in the skeletal
2668   // interpreter frame and the stack walking of interpreter_sender
2669   // will get the unextended sp value and not the &quot;real&quot; sp value.
2670 
2671   const Register sender_sp = r8;
2672 
2673   __ mov(sender_sp, sp);
2674   __ ldrw(r1, Address(r4,
2675                       Deoptimization::UnrollBlock::
2676                       caller_adjustment_offset_in_bytes())); // (int)
2677   __ sub(sp, sp, r1);
2678 
2679   // Push interpreter frames in a loop
2680   Label loop;
2681   __ bind(loop);
2682   __ ldr(r1, Address(r5, 0));       // Load frame size
2683   __ sub(r1, r1, 2 * wordSize);     // We&#39;ll push pc and rfp by hand
2684   __ ldr(lr, Address(r2, 0));       // Save return address
2685   __ enter();                       // and old rfp &amp; set new rfp
2686   __ sub(sp, sp, r1);               // Prolog
2687   __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); // Make it walkable
2688   // This value is corrected by layout_activation_impl
2689   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
2690   __ mov(sender_sp, sp);          // Pass sender_sp to next frame
2691   __ add(r5, r5, wordSize);       // Bump array pointer (sizes)
2692   __ add(r2, r2, wordSize);       // Bump array pointer (pcs)
2693   __ subsw(r3, r3, 1);            // Decrement counter
2694   __ br(Assembler::GT, loop);
2695   __ ldr(lr, Address(r2, 0));     // save final return address
2696   // Re-push self-frame
2697   __ enter();                     // &amp; old rfp &amp; set new rfp
2698 
2699   // Use rfp because the frames look interpreted now
2700   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
2701   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2702   address the_pc = __ pc();
2703   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2704 
2705   // Call C code.  Need thread but NOT official VM entry
2706   // crud.  We cannot block on this call, no GC can happen.  Call should
2707   // restore return values to their stack-slots with the new SP.
2708   // Thread is in rdi already.
2709   //
2710   // BasicType unpack_frames(JavaThread* thread, int exec_mode);
2711   //
2712   // n.b. 2 gp args, 0 fp args, integral return type
2713 
2714   // sp should already be aligned
2715   __ mov(c_rarg0, rthread);
2716   __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2717   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
2718   __ blr(rscratch1);
2719 
2720   // Set an oopmap for the call site
2721   // Use the same PC we used for the last java frame
2722   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
2723 
2724   // Clear fp AND pc
2725   __ reset_last_Java_frame(true);
2726 
2727   // Pop self-frame.
2728   __ leave();                 // Epilog
2729 
2730   // Jump to interpreter
2731   __ ret(lr);
2732 
2733   // Make sure all code is generated
2734   masm-&gt;flush();
2735 
2736   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
2737                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);
2738 }
2739 #endif // COMPILER2
2740 
2741 
2742 //------------------------------generate_handler_blob------
2743 //
2744 // Generate a special Compile2Runtime blob that saves all registers,
2745 // and setup oopmap.
2746 //
2747 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
2748   ResourceMark rm;
2749   OopMapSet *oop_maps = new OopMapSet();
2750   OopMap* map;
2751 
2752   // Allocate space for the code.  Setup code generation tools.
2753   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
2754   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2755 
2756   address start   = __ pc();
2757   address call_pc = NULL;
2758   int frame_size_in_words;
2759   bool cause_return = (poll_type == POLL_AT_RETURN);
2760   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
2761 
2762   // Save Integer and Float registers.
2763   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
2764 
2765   // The following is basically a call_VM.  However, we need the precise
2766   // address of the call in order to generate an oopmap. Hence, we do all the
2767   // work outselves.
2768 
2769   Label retaddr;
2770   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2771 
2772   // The return address must always be correct so that frame constructor never
2773   // sees an invalid pc.
2774 
2775   if (!cause_return) {
2776     // overwrite the return address pushed by save_live_registers
2777     // Additionally, r20 is a callee-saved register so we can look at
2778     // it later to determine if someone changed the return address for
2779     // us!
2780     __ ldr(r20, Address(rthread, JavaThread::saved_exception_pc_offset()));
2781     __ str(r20, Address(rfp, wordSize));
2782   }
2783 
2784   // Do the call
2785   __ mov(c_rarg0, rthread);
2786   __ lea(rscratch1, RuntimeAddress(call_ptr));
2787   __ blr(rscratch1);
2788   __ bind(retaddr);
2789 
2790   // Set an oopmap for the call site.  This oopmap will map all
2791   // oop-registers and debug-info registers as callee-saved.  This
2792   // will allow deoptimization at this safepoint to find all possible
2793   // debug-info recordings, as well as let GC find all oops.
2794 
2795   oop_maps-&gt;add_gc_map( __ pc() - start, map);
2796 
2797   Label noException;
2798 
2799   __ reset_last_Java_frame(false);
2800 
2801   __ maybe_isb();
2802   __ membar(Assembler::LoadLoad | Assembler::LoadStore);
2803 
2804   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2805   __ cbz(rscratch1, noException);
2806 
2807   // Exception pending
2808 
2809   RegisterSaver::restore_live_registers(masm, save_vectors);
2810 
2811   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2812 
2813   // No exception case
2814   __ bind(noException);
2815 
2816   Label no_adjust, bail;
2817   if (!cause_return) {
2818     // If our stashed return pc was modified by the runtime we avoid touching it
2819     __ ldr(rscratch1, Address(rfp, wordSize));
2820     __ cmp(r20, rscratch1);
2821     __ br(Assembler::NE, no_adjust);
2822 
2823 #ifdef ASSERT
2824     // Verify the correct encoding of the poll we&#39;re about to skip.
2825     // See NativeInstruction::is_ldrw_to_zr()
2826     __ ldrw(rscratch1, Address(r20));
2827     __ ubfx(rscratch2, rscratch1, 22, 10);
2828     __ cmpw(rscratch2, 0b1011100101);
2829     __ br(Assembler::NE, bail);
2830     __ ubfx(rscratch2, rscratch1, 0, 5);
2831     __ cmpw(rscratch2, 0b11111);
2832     __ br(Assembler::NE, bail);
2833 #endif
2834     // Adjust return pc forward to step over the safepoint poll instruction
2835     __ add(r20, r20, NativeInstruction::instruction_size);
2836     __ str(r20, Address(rfp, wordSize));
2837   }
2838 
2839   __ bind(no_adjust);
2840   // Normal exit, restore registers and exit.
2841   RegisterSaver::restore_live_registers(masm, save_vectors);
2842 
2843   __ ret(lr);
2844 
2845 #ifdef ASSERT
2846   __ bind(bail);
2847   __ stop(&quot;Attempting to adjust pc to skip safepoint poll but the return point is not what we expected&quot;);
2848 #endif
2849 
2850   // Make sure all code is generated
2851   masm-&gt;flush();
2852 
2853   // Fill-out other meta info
2854   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_in_words);
2855 }
2856 
2857 //
2858 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss
2859 //
2860 // Generate a stub that calls into vm to find out the proper destination
2861 // of a java call. All the argument registers are live at this point
2862 // but since this is generic code we don&#39;t know what they are and the caller
2863 // must do any gc of the args.
2864 //
2865 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
2866   assert (StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
2867 
2868   // allocate space for the code
2869   ResourceMark rm;
2870 
2871   CodeBuffer buffer(name, 1000, 512);
2872   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
2873 
2874   int frame_size_in_words;
2875 
2876   OopMapSet *oop_maps = new OopMapSet();
2877   OopMap* map = NULL;
2878 
2879   int start = __ offset();
2880 
2881   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2882 
2883   int frame_complete = __ offset();
2884 
2885   {
2886     Label retaddr;
2887     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2888 
2889     __ mov(c_rarg0, rthread);
2890     __ lea(rscratch1, RuntimeAddress(destination));
2891 
2892     __ blr(rscratch1);
2893     __ bind(retaddr);
2894   }
2895 
2896   // Set an oopmap for the call site.
2897   // We need this not only for callee-saved registers, but also for volatile
2898   // registers that the compiler might be keeping live across a safepoint.
2899 
2900   oop_maps-&gt;add_gc_map( __ offset() - start, map);
2901 
2902   __ maybe_isb();
2903 
2904   // r0 contains the address we are going to jump to assuming no exception got installed
2905 
2906   // clear last_Java_sp
2907   __ reset_last_Java_frame(false);
2908   // check for pending exceptions
2909   Label pending;
2910   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2911   __ cbnz(rscratch1, pending);
2912 
2913   // get the returned Method*
2914   __ get_vm_result_2(rmethod, rthread);
2915   __ str(rmethod, Address(sp, RegisterSaver::reg_offset_in_bytes(rmethod)));
2916 
2917   // r0 is where we want to jump, overwrite rscratch1 which is saved and scratch
2918   __ str(r0, Address(sp, RegisterSaver::rscratch1_offset_in_bytes()));
2919   RegisterSaver::restore_live_registers(masm);
2920 
2921   // We are back the the original state on entry and ready to go.
2922 
2923   __ br(rscratch1);
2924 
2925   // Pending exception after the safepoint
2926 
2927   __ bind(pending);
2928 
2929   RegisterSaver::restore_live_registers(masm);
2930 
2931   // exception pending =&gt; remove activation and forward to exception handler
2932 
2933   __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
2934 
2935   __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
2936   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2937 
2938   // -------------
2939   // make sure all code is generated
2940   masm-&gt;flush();
2941 
2942   // return the  blob
2943   // frame_size_words or bytes??
2944   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_words, oop_maps, true);
2945 }
2946 
2947 #ifdef COMPILER2
2948 // This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame
2949 //
2950 //------------------------------generate_exception_blob---------------------------
2951 // creates exception blob at the end
2952 // Using exception blob, this code is jumped from a compiled method.
2953 // (see emit_exception_handler in x86_64.ad file)
2954 //
2955 // Given an exception pc at a call we call into the runtime for the
2956 // handler in this method. This handler might merely restore state
2957 // (i.e. callee save registers) unwind the frame and jump to the
2958 // exception handler for the nmethod if there is no Java level handler
2959 // for the nmethod.
2960 //
2961 // This code is entered with a jmp.
2962 //
2963 // Arguments:
2964 //   r0: exception oop
2965 //   r3: exception pc
2966 //
2967 // Results:
2968 //   r0: exception oop
2969 //   r3: exception pc in caller or ???
2970 //   destination: exception handler of caller
2971 //
2972 // Note: the exception pc MUST be at a call (precise debug information)
2973 //       Registers r0, r3, r2, r4, r5, r8-r11 are not callee saved.
2974 //
2975 
2976 void OptoRuntime::generate_exception_blob() {
2977   assert(!OptoRuntime::is_callee_saved_register(R3_num), &quot;&quot;);
2978   assert(!OptoRuntime::is_callee_saved_register(R0_num), &quot;&quot;);
2979   assert(!OptoRuntime::is_callee_saved_register(R2_num), &quot;&quot;);
2980 
2981   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
2982 
2983   // Allocate space for the code
2984   ResourceMark rm;
2985   // Setup code generation tools
2986   CodeBuffer buffer(&quot;exception_blob&quot;, 2048, 1024);
2987   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2988 
2989   // TODO check various assumptions made here
2990   //
2991   // make sure we do so before running this
2992 
2993   address start = __ pc();
2994 
2995   // push rfp and retaddr by hand
2996   // Exception pc is &#39;return address&#39; for stack walker
2997   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
2998   // there are no callee save registers and we don&#39;t expect an
2999   // arg reg save area
3000 #ifndef PRODUCT
3001   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
3002 #endif
3003   // Store exception in Thread object. We cannot pass any arguments to the
3004   // handle_exception call, since we do not want to make any assumption
3005   // about the size of the frame where the exception happened in.
3006   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
3007   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
3008 
3009   // This call does all the hard work.  It checks if an exception handler
3010   // exists in the method.
3011   // If so, it returns the handler address.
3012   // If not, it prepares for stack-unwinding, restoring the callee-save
3013   // registers of the frame being removed.
3014   //
3015   // address OptoRuntime::handle_exception_C(JavaThread* thread)
3016   //
3017   // n.b. 1 gp arg, 0 fp args, integral return type
3018 
3019   // the stack should always be aligned
3020   address the_pc = __ pc();
3021   __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);
3022   __ mov(c_rarg0, rthread);
3023   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
3024   __ blr(rscratch1);
3025   __ maybe_isb();
3026 
3027   // Set an oopmap for the call site.  This oopmap will only be used if we
3028   // are unwinding the stack.  Hence, all locations will be dead.
3029   // Callee-saved registers will be the same as the frame above (i.e.,
3030   // handle_exception_stub), since they were restored when we got the
3031   // exception.
3032 
3033   OopMapSet* oop_maps = new OopMapSet();
3034 
3035   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
3036 
3037   __ reset_last_Java_frame(false);
3038 
3039   // Restore callee-saved registers
3040 
3041   // rfp is an implicitly saved callee saved register (i.e. the calling
3042   // convention will save restore it in prolog/epilog) Other than that
3043   // there are no callee save registers now that adapter frames are gone.
3044   // and we dont&#39; expect an arg reg save area
3045   __ ldp(rfp, r3, Address(__ post(sp, 2 * wordSize)));
3046 
3047   // r0: exception handler
3048 
3049   // We have a handler in r0 (could be deopt blob).
3050   __ mov(r8, r0);
3051 
3052   // Get the exception oop
3053   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
3054   // Get the exception pc in case we are deoptimized
3055   __ ldr(r4, Address(rthread, JavaThread::exception_pc_offset()));
3056 #ifdef ASSERT
3057   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3058   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3059 #endif
3060   // Clear the exception oop so GC no longer processes it as a root.
3061   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3062 
3063   // r0: exception oop
3064   // r8:  exception handler
3065   // r4: exception pc
3066   // Jump to handler
3067 
3068   __ br(r8);
3069 
3070   // Make sure all code is generated
3071   masm-&gt;flush();
3072 
3073   // Set exception blob
3074   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3075 }
3076 #endif // COMPILER2
    </pre>
  </body>
</html>
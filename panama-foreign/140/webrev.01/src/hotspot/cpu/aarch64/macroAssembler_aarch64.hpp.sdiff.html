<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
 159 
 160   // Add constant to memory word
 161   void addmw(Address a, int imm, Register scratch) {
 162     ldrw(scratch, a);
 163     if (imm &gt; 0)
 164       addw(scratch, scratch, (unsigned)imm);
 165     else
 166       subw(scratch, scratch, (unsigned)-imm);
 167     strw(scratch, a);
 168   }
 169 
 170   void bind(Label&amp; L) {
 171     Assembler::bind(L);
 172     code()-&gt;clear_last_insn();
 173   }
 174 
 175   void membar(Membar_mask_bits order_constraint);
 176 
 177   using Assembler::ldr;
 178   using Assembler::str;


 179 
 180   void ldr(Register Rx, const Address &amp;adr);
 181   void ldrw(Register Rw, const Address &amp;adr);
 182   void str(Register Rx, const Address &amp;adr);
 183   void strw(Register Rx, const Address &amp;adr);
 184 
 185   // Frame creation and destruction shared between JITs.
 186   void build_frame(int framesize);
 187   void remove_frame(int framesize);
 188 
 189   virtual void _call_Unimplemented(address call_site) {
 190     mov(rscratch2, call_site);
 191   }
 192 
 193 #define call_Unimplemented() _call_Unimplemented((address)__PRETTY_FUNCTION__)
 194 
 195   // aliases defined in AARCH64 spec
 196 
 197   template&lt;class T&gt;
 198   inline void cmpw(Register Rd, T imm)  { subsw(zr, Rd, imm); }
</pre>
<hr />
<pre>
 792 
 793   void set_last_Java_frame(Register last_java_sp,
 794                            Register last_java_fp,
 795                            Register last_java_pc,
 796                            Register scratch);
 797 
 798   void reset_last_Java_frame(Register thread);
 799 
 800   // thread in the default location (rthread)
 801   void reset_last_Java_frame(bool clear_fp);
 802 
 803   // Stores
 804   void store_check(Register obj);                // store check for obj - register is destroyed afterwards
 805   void store_check(Register obj, Address dst);   // same as above, dst is exact store location (reg. is destroyed)
 806 
 807   void resolve_jobject(Register value, Register thread, Register tmp);
 808 
 809   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 810   void c2bool(Register x);
 811 

 812   void load_method_holder(Register holder, Register method);
 813 
 814   // oop manipulations
 815   void load_klass(Register dst, Register src);
 816   void store_klass(Register dst, Register src);
 817   void cmp_klass(Register oop, Register trial_klass, Register tmp);
 818 

 819   void resolve_oop_handle(Register result, Register tmp = r5);
 820   void load_mirror(Register dst, Register method, Register tmp = r5);
 821 
 822   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 823                       Register tmp1, Register tmp_thread);
 824 
 825   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 826                        Register tmp1, Register tmp_thread);
 827 
 828   // Resolves obj for access. Result is placed in the same register.
 829   // All other registers are preserved.
 830   void resolve(DecoratorSet decorators, Register obj);
 831 
 832   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 833                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 834 
 835   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 836                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 837   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 838                       Register tmp_thread = noreg, DecoratorSet decorators = 0);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
 159 
 160   // Add constant to memory word
 161   void addmw(Address a, int imm, Register scratch) {
 162     ldrw(scratch, a);
 163     if (imm &gt; 0)
 164       addw(scratch, scratch, (unsigned)imm);
 165     else
 166       subw(scratch, scratch, (unsigned)-imm);
 167     strw(scratch, a);
 168   }
 169 
 170   void bind(Label&amp; L) {
 171     Assembler::bind(L);
 172     code()-&gt;clear_last_insn();
 173   }
 174 
 175   void membar(Membar_mask_bits order_constraint);
 176 
 177   using Assembler::ldr;
 178   using Assembler::str;
<span class="line-added"> 179   using Assembler::ldrw;</span>
<span class="line-added"> 180   using Assembler::strw;</span>
 181 
 182   void ldr(Register Rx, const Address &amp;adr);
 183   void ldrw(Register Rw, const Address &amp;adr);
 184   void str(Register Rx, const Address &amp;adr);
 185   void strw(Register Rx, const Address &amp;adr);
 186 
 187   // Frame creation and destruction shared between JITs.
 188   void build_frame(int framesize);
 189   void remove_frame(int framesize);
 190 
 191   virtual void _call_Unimplemented(address call_site) {
 192     mov(rscratch2, call_site);
 193   }
 194 
 195 #define call_Unimplemented() _call_Unimplemented((address)__PRETTY_FUNCTION__)
 196 
 197   // aliases defined in AARCH64 spec
 198 
 199   template&lt;class T&gt;
 200   inline void cmpw(Register Rd, T imm)  { subsw(zr, Rd, imm); }
</pre>
<hr />
<pre>
 794 
 795   void set_last_Java_frame(Register last_java_sp,
 796                            Register last_java_fp,
 797                            Register last_java_pc,
 798                            Register scratch);
 799 
 800   void reset_last_Java_frame(Register thread);
 801 
 802   // thread in the default location (rthread)
 803   void reset_last_Java_frame(bool clear_fp);
 804 
 805   // Stores
 806   void store_check(Register obj);                // store check for obj - register is destroyed afterwards
 807   void store_check(Register obj, Address dst);   // same as above, dst is exact store location (reg. is destroyed)
 808 
 809   void resolve_jobject(Register value, Register thread, Register tmp);
 810 
 811   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 812   void c2bool(Register x);
 813 
<span class="line-added"> 814   void load_method_holder_cld(Register rresult, Register rmethod);</span>
 815   void load_method_holder(Register holder, Register method);
 816 
 817   // oop manipulations
 818   void load_klass(Register dst, Register src);
 819   void store_klass(Register dst, Register src);
 820   void cmp_klass(Register oop, Register trial_klass, Register tmp);
 821 
<span class="line-added"> 822   void resolve_weak_handle(Register result, Register tmp);</span>
 823   void resolve_oop_handle(Register result, Register tmp = r5);
 824   void load_mirror(Register dst, Register method, Register tmp = r5);
 825 
 826   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 827                       Register tmp1, Register tmp_thread);
 828 
 829   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 830                        Register tmp1, Register tmp_thread);
 831 
 832   // Resolves obj for access. Result is placed in the same register.
 833   // All other registers are preserved.
 834   void resolve(DecoratorSet decorators, Register obj);
 835 
 836   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 837                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 838 
 839   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 840                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 841   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 842                       Register tmp_thread = noreg, DecoratorSet decorators = 0);
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
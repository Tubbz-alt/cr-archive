<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gc/z/zArguments_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3676     adr = Address(rscratch2);
3677     break;
3678   }
3679   ldr(rscratch1, adr);
3680   add(rscratch1, rscratch1, src);
3681   str(rscratch1, adr);
3682 }
3683 
3684 void MacroAssembler::cmpptr(Register src1, Address src2) {
3685   unsigned long offset;
3686   adrp(rscratch1, src2, offset);
3687   ldr(rscratch1, Address(rscratch1, offset));
3688   cmp(src1, rscratch1);
3689 }
3690 
3691 void MacroAssembler::cmpoop(Register obj1, Register obj2) {
3692   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3693   bs-&gt;obj_equals(this, obj1, obj2);
3694 }
3695 





3696 void MacroAssembler::load_method_holder(Register holder, Register method) {
3697   ldr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
3698   ldr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
3699   ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
3700 }
3701 
3702 void MacroAssembler::load_klass(Register dst, Register src) {
3703   if (UseCompressedClassPointers) {
3704     ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3705     decode_klass_not_null(dst);
3706   } else {
3707     ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3708   }
3709 }
3710 
3711 // ((OopHandle)result).resolve();
3712 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3713   // OopHandle::resolve is an indirection.
3714   access_load_at(T_OBJECT, IN_NATIVE, result, Address(result, 0), tmp, noreg);
3715 }
3716 
















3717 void MacroAssembler::load_mirror(Register dst, Register method, Register tmp) {
3718   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3719   ldr(dst, Address(rmethod, Method::const_offset()));
3720   ldr(dst, Address(dst, ConstMethod::constants_offset()));
3721   ldr(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));
3722   ldr(dst, Address(dst, mirror_offset));
3723   resolve_oop_handle(dst, tmp);
3724 }
3725 
3726 void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {
3727   if (UseCompressedClassPointers) {
3728     ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
3729     if (CompressedKlassPointers::base() == NULL) {
3730       cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());
3731       return;
3732     } else if (((uint64_t)CompressedKlassPointers::base() &amp; 0xffffffff) == 0
3733                &amp;&amp; CompressedKlassPointers::shift() == 0) {
3734       // Only the bottom 32 bits matter
3735       cmpw(trial_klass, tmp);
3736       return;
</pre>
<hr />
<pre>
4091 }
4092 
4093 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4094                                     Register thread_tmp, DecoratorSet decorators) {
4095   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4096 }
4097 
4098 // Used for storing NULLs.
4099 void MacroAssembler::store_heap_oop_null(Address dst) {
4100   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);
4101 }
4102 
4103 Address MacroAssembler::allocate_metadata_address(Metadata* obj) {
4104   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
4105   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
4106   RelocationHolder rspec = metadata_Relocation::spec(index);
4107   return Address((address)obj, rspec);
4108 }
4109 
4110 // Move an oop into a register.  immediate is true if we want
<span class="line-modified">4111 // immediate instrcutions, i.e. we are not going to patch this</span>
<span class="line-modified">4112 // instruction while the code is being executed by another thread.  In</span>
<span class="line-modified">4113 // that case we can use move immediates rather than the constant pool.</span>
4114 void MacroAssembler::movoop(Register dst, jobject obj, bool immediate) {
4115   int oop_index;
4116   if (obj == NULL) {
4117     oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
4118   } else {
4119 #ifdef ASSERT
4120     {
4121       ThreadInVMfromUnknown tiv;
4122       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4123     }
4124 #endif
4125     oop_index = oop_recorder()-&gt;find_index(obj);
4126   }
4127   RelocationHolder rspec = oop_Relocation::spec(oop_index);
<span class="line-modified">4128   if (! immediate) {</span>




4129     address dummy = address(uintptr_t(pc()) &amp; -wordSize); // A nearby aligned address
4130     ldr_constant(dst, Address(dummy, rspec));
4131   } else
4132     mov(dst, Address((address)obj, rspec));

4133 }
4134 
4135 // Move a metadata address into a register.
4136 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
4137   int oop_index;
4138   if (obj == NULL) {
4139     oop_index = oop_recorder()-&gt;allocate_metadata_index(obj);
4140   } else {
4141     oop_index = oop_recorder()-&gt;find_index(obj);
4142   }
4143   RelocationHolder rspec = metadata_Relocation::spec(oop_index);
4144   mov(dst, Address((address)obj, rspec));
4145 }
4146 
4147 Address MacroAssembler::constant_oop_address(jobject obj) {
4148 #ifdef ASSERT
4149   {
4150     ThreadInVMfromUnknown tiv;
4151     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4152     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
</pre>
</td>
<td>
<hr />
<pre>
3676     adr = Address(rscratch2);
3677     break;
3678   }
3679   ldr(rscratch1, adr);
3680   add(rscratch1, rscratch1, src);
3681   str(rscratch1, adr);
3682 }
3683 
3684 void MacroAssembler::cmpptr(Register src1, Address src2) {
3685   unsigned long offset;
3686   adrp(rscratch1, src2, offset);
3687   ldr(rscratch1, Address(rscratch1, offset));
3688   cmp(src1, rscratch1);
3689 }
3690 
3691 void MacroAssembler::cmpoop(Register obj1, Register obj2) {
3692   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3693   bs-&gt;obj_equals(this, obj1, obj2);
3694 }
3695 
<span class="line-added">3696 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {</span>
<span class="line-added">3697   load_method_holder(rresult, rmethod);</span>
<span class="line-added">3698   ldr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));</span>
<span class="line-added">3699 }</span>
<span class="line-added">3700 </span>
3701 void MacroAssembler::load_method_holder(Register holder, Register method) {
3702   ldr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
3703   ldr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
3704   ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
3705 }
3706 
3707 void MacroAssembler::load_klass(Register dst, Register src) {
3708   if (UseCompressedClassPointers) {
3709     ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3710     decode_klass_not_null(dst);
3711   } else {
3712     ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3713   }
3714 }
3715 
3716 // ((OopHandle)result).resolve();
3717 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3718   // OopHandle::resolve is an indirection.
3719   access_load_at(T_OBJECT, IN_NATIVE, result, Address(result, 0), tmp, noreg);
3720 }
3721 
<span class="line-added">3722 // ((WeakHandle)result).resolve();</span>
<span class="line-added">3723 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {</span>
<span class="line-added">3724   assert_different_registers(rresult, rtmp);</span>
<span class="line-added">3725   Label resolved;</span>
<span class="line-added">3726 </span>
<span class="line-added">3727   // A null weak handle resolves to null.</span>
<span class="line-added">3728   cbz(rresult, resolved);</span>
<span class="line-added">3729 </span>
<span class="line-added">3730   // Only 64 bit platforms support GCs that require a tmp register</span>
<span class="line-added">3731   // Only IN_HEAP loads require a thread_tmp register</span>
<span class="line-added">3732   // WeakHandle::resolve is an indirection like jweak.</span>
<span class="line-added">3733   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,</span>
<span class="line-added">3734                  rresult, Address(rresult), rtmp, /*tmp_thread*/noreg);</span>
<span class="line-added">3735   bind(resolved);</span>
<span class="line-added">3736 }</span>
<span class="line-added">3737 </span>
3738 void MacroAssembler::load_mirror(Register dst, Register method, Register tmp) {
3739   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3740   ldr(dst, Address(rmethod, Method::const_offset()));
3741   ldr(dst, Address(dst, ConstMethod::constants_offset()));
3742   ldr(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));
3743   ldr(dst, Address(dst, mirror_offset));
3744   resolve_oop_handle(dst, tmp);
3745 }
3746 
3747 void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {
3748   if (UseCompressedClassPointers) {
3749     ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
3750     if (CompressedKlassPointers::base() == NULL) {
3751       cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());
3752       return;
3753     } else if (((uint64_t)CompressedKlassPointers::base() &amp; 0xffffffff) == 0
3754                &amp;&amp; CompressedKlassPointers::shift() == 0) {
3755       // Only the bottom 32 bits matter
3756       cmpw(trial_klass, tmp);
3757       return;
</pre>
<hr />
<pre>
4112 }
4113 
4114 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4115                                     Register thread_tmp, DecoratorSet decorators) {
4116   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4117 }
4118 
4119 // Used for storing NULLs.
4120 void MacroAssembler::store_heap_oop_null(Address dst) {
4121   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);
4122 }
4123 
4124 Address MacroAssembler::allocate_metadata_address(Metadata* obj) {
4125   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
4126   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
4127   RelocationHolder rspec = metadata_Relocation::spec(index);
4128   return Address((address)obj, rspec);
4129 }
4130 
4131 // Move an oop into a register.  immediate is true if we want
<span class="line-modified">4132 // immediate instructions and nmethod entry barriers are not enabled.</span>
<span class="line-modified">4133 // i.e. we are not going to patch this instruction while the code is being</span>
<span class="line-modified">4134 // executed by another thread.</span>
4135 void MacroAssembler::movoop(Register dst, jobject obj, bool immediate) {
4136   int oop_index;
4137   if (obj == NULL) {
4138     oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
4139   } else {
4140 #ifdef ASSERT
4141     {
4142       ThreadInVMfromUnknown tiv;
4143       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4144     }
4145 #endif
4146     oop_index = oop_recorder()-&gt;find_index(obj);
4147   }
4148   RelocationHolder rspec = oop_Relocation::spec(oop_index);
<span class="line-modified">4149 </span>
<span class="line-added">4150   // nmethod entry barrier necessitate using the constant pool. They have to be</span>
<span class="line-added">4151   // ordered with respected to oop accesses.</span>
<span class="line-added">4152   // Using immediate literals would necessitate ISBs.</span>
<span class="line-added">4153   if (BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL || !immediate) {</span>
4154     address dummy = address(uintptr_t(pc()) &amp; -wordSize); // A nearby aligned address
4155     ldr_constant(dst, Address(dummy, rspec));
4156   } else
4157     mov(dst, Address((address)obj, rspec));
<span class="line-added">4158 </span>
4159 }
4160 
4161 // Move a metadata address into a register.
4162 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
4163   int oop_index;
4164   if (obj == NULL) {
4165     oop_index = oop_recorder()-&gt;allocate_metadata_index(obj);
4166   } else {
4167     oop_index = oop_recorder()-&gt;find_index(obj);
4168   }
4169   RelocationHolder rspec = metadata_Relocation::spec(oop_index);
4170   mov(dst, Address((address)obj, rspec));
4171 }
4172 
4173 Address MacroAssembler::constant_oop_address(jobject obj) {
4174 #ifdef ASSERT
4175   {
4176     ThreadInVMfromUnknown tiv;
4177     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4178     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="gc/z/zArguments_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
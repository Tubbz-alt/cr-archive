<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutines_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
4138 
4139       __ eor(rscratch2, tmpU, tmpL);
4140       __ cbz(rscratch2, DONE);
4141 
4142     // Find the first different characters in the longwords and
4143     // compute their difference.
4144     __ bind(CALCULATE_DIFFERENCE);
4145       __ rev(rscratch2, rscratch2);
4146       __ clz(rscratch2, rscratch2);
4147       __ andr(rscratch2, rscratch2, -16);
4148       __ lsrv(tmp1, tmp1, rscratch2);
4149       __ uxthw(tmp1, tmp1);
4150       __ lsrv(rscratch1, rscratch1, rscratch2);
4151       __ uxthw(rscratch1, rscratch1);
4152       __ subw(result, tmp1, rscratch1);
4153     __ bind(DONE);
4154       __ ret(lr);
4155     return entry;
4156   }
4157 












































4158   // r0  = result
4159   // r1  = str1
4160   // r2  = cnt1
4161   // r3  = str2
4162   // r4  = cnt2
4163   // r10 = tmp1
4164   // r11 = tmp2
4165   address generate_compare_long_string_same_encoding(bool isLL) {
4166     __ align(CodeEntryAlignment);
4167     StubCodeMark mark(this, &quot;StubRoutines&quot;, isLL
4168         ? &quot;compare_long_string_same_encoding LL&quot;
4169         : &quot;compare_long_string_same_encoding UU&quot;);
4170     address entry = __ pc();
4171     Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,
4172         tmp1 = r10, tmp2 = r11;
4173     Label SMALL_LOOP, LARGE_LOOP_PREFETCH, CHECK_LAST, DIFF2, TAIL,
4174         LENGTH_DIFF, DIFF, LAST_CHECK_AND_LENGTH_DIFF,
4175         DIFF_LAST_POSITION, DIFF_LAST_POSITION2;
4176     // exit from large loop when less than 64 bytes left to read or we&#39;re about
4177     // to prefetch memory behind array border
</pre>
<hr />
<pre>
5728                                                 throw_NullPointerException_at_call));
5729 
5730     // arraycopy stubs used by compilers
5731     generate_arraycopy_stubs();
5732 
5733     // has negatives stub for large arrays.
5734     StubRoutines::aarch64::_has_negatives = generate_has_negatives(StubRoutines::aarch64::_has_negatives_long);
5735 
5736     // array equals stub for large arrays.
5737     if (!UseSimpleArrayEquals) {
5738       StubRoutines::aarch64::_large_array_equals = generate_large_array_equals();
5739     }
5740 
5741     generate_compare_long_strings();
5742 
5743     generate_string_indexof_stubs();
5744 
5745     // byte_array_inflate stub for large arrays.
5746     StubRoutines::aarch64::_large_byte_array_inflate = generate_large_byte_array_inflate();
5747 




5748 #ifdef COMPILER2
5749     if (UseMultiplyToLenIntrinsic) {
5750       StubRoutines::_multiplyToLen = generate_multiplyToLen();
5751     }
5752 
5753     if (UseSquareToLenIntrinsic) {
5754       StubRoutines::_squareToLen = generate_squareToLen();
5755     }
5756 
5757     if (UseMulAddIntrinsic) {
5758       StubRoutines::_mulAdd = generate_mulAdd();
5759     }
5760 
5761     if (UseMontgomeryMultiplyIntrinsic) {
5762       StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;montgomeryMultiply&quot;);
5763       MontgomeryMultiplyGenerator g(_masm, /*squaring*/false);
5764       StubRoutines::_montgomeryMultiply = g.generate_multiply();
5765     }
5766 
5767     if (UseMontgomerySquareIntrinsic) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
4138 
4139       __ eor(rscratch2, tmpU, tmpL);
4140       __ cbz(rscratch2, DONE);
4141 
4142     // Find the first different characters in the longwords and
4143     // compute their difference.
4144     __ bind(CALCULATE_DIFFERENCE);
4145       __ rev(rscratch2, rscratch2);
4146       __ clz(rscratch2, rscratch2);
4147       __ andr(rscratch2, rscratch2, -16);
4148       __ lsrv(tmp1, tmp1, rscratch2);
4149       __ uxthw(tmp1, tmp1);
4150       __ lsrv(rscratch1, rscratch1, rscratch2);
4151       __ uxthw(rscratch1, rscratch1);
4152       __ subw(result, tmp1, rscratch1);
4153     __ bind(DONE);
4154       __ ret(lr);
4155     return entry;
4156   }
4157 
<span class="line-added">4158     address generate_method_entry_barrier() {</span>
<span class="line-added">4159     __ align(CodeEntryAlignment);</span>
<span class="line-added">4160     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;nmethod_entry_barrier&quot;);</span>
<span class="line-added">4161 </span>
<span class="line-added">4162     Label deoptimize_label;</span>
<span class="line-added">4163 </span>
<span class="line-added">4164     address start = __ pc();</span>
<span class="line-added">4165 </span>
<span class="line-added">4166     __ set_last_Java_frame(sp, rfp, lr, rscratch1);</span>
<span class="line-added">4167 </span>
<span class="line-added">4168     __ enter();</span>
<span class="line-added">4169     __ add(rscratch2, sp, wordSize);  // rscratch2 points to the saved lr</span>
<span class="line-added">4170 </span>
<span class="line-added">4171     __ sub(sp, sp, 4 * wordSize);  // four words for the returned {sp, fp, lr, pc}</span>
<span class="line-added">4172 </span>
<span class="line-added">4173     __ push_call_clobbered_registers();</span>
<span class="line-added">4174 </span>
<span class="line-added">4175     __ mov(c_rarg0, rscratch2);</span>
<span class="line-added">4176     __ call_VM_leaf</span>
<span class="line-added">4177          (CAST_FROM_FN_PTR</span>
<span class="line-added">4178           (address, BarrierSetNMethod::nmethod_stub_entry_barrier), 1);</span>
<span class="line-added">4179 </span>
<span class="line-added">4180     __ reset_last_Java_frame(true);</span>
<span class="line-added">4181 </span>
<span class="line-added">4182     __ mov(rscratch1, r0);</span>
<span class="line-added">4183 </span>
<span class="line-added">4184     __ pop_call_clobbered_registers();</span>
<span class="line-added">4185 </span>
<span class="line-added">4186     __ cbnz(rscratch1, deoptimize_label);</span>
<span class="line-added">4187 </span>
<span class="line-added">4188     __ leave();</span>
<span class="line-added">4189     __ ret(lr);</span>
<span class="line-added">4190 </span>
<span class="line-added">4191     __ BIND(deoptimize_label);</span>
<span class="line-added">4192 </span>
<span class="line-added">4193     __ ldp(/* new sp */ rscratch1, rfp, Address(sp, 0 * wordSize));</span>
<span class="line-added">4194     __ ldp(lr, /* new pc*/ rscratch2, Address(sp, 2 * wordSize));</span>
<span class="line-added">4195 </span>
<span class="line-added">4196     __ mov(sp, rscratch1);</span>
<span class="line-added">4197     __ br(rscratch2);</span>
<span class="line-added">4198 </span>
<span class="line-added">4199     return start;</span>
<span class="line-added">4200   }</span>
<span class="line-added">4201 </span>
4202   // r0  = result
4203   // r1  = str1
4204   // r2  = cnt1
4205   // r3  = str2
4206   // r4  = cnt2
4207   // r10 = tmp1
4208   // r11 = tmp2
4209   address generate_compare_long_string_same_encoding(bool isLL) {
4210     __ align(CodeEntryAlignment);
4211     StubCodeMark mark(this, &quot;StubRoutines&quot;, isLL
4212         ? &quot;compare_long_string_same_encoding LL&quot;
4213         : &quot;compare_long_string_same_encoding UU&quot;);
4214     address entry = __ pc();
4215     Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,
4216         tmp1 = r10, tmp2 = r11;
4217     Label SMALL_LOOP, LARGE_LOOP_PREFETCH, CHECK_LAST, DIFF2, TAIL,
4218         LENGTH_DIFF, DIFF, LAST_CHECK_AND_LENGTH_DIFF,
4219         DIFF_LAST_POSITION, DIFF_LAST_POSITION2;
4220     // exit from large loop when less than 64 bytes left to read or we&#39;re about
4221     // to prefetch memory behind array border
</pre>
<hr />
<pre>
5772                                                 throw_NullPointerException_at_call));
5773 
5774     // arraycopy stubs used by compilers
5775     generate_arraycopy_stubs();
5776 
5777     // has negatives stub for large arrays.
5778     StubRoutines::aarch64::_has_negatives = generate_has_negatives(StubRoutines::aarch64::_has_negatives_long);
5779 
5780     // array equals stub for large arrays.
5781     if (!UseSimpleArrayEquals) {
5782       StubRoutines::aarch64::_large_array_equals = generate_large_array_equals();
5783     }
5784 
5785     generate_compare_long_strings();
5786 
5787     generate_string_indexof_stubs();
5788 
5789     // byte_array_inflate stub for large arrays.
5790     StubRoutines::aarch64::_large_byte_array_inflate = generate_large_byte_array_inflate();
5791 
<span class="line-added">5792     BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();</span>
<span class="line-added">5793     if (bs_nm != NULL) {</span>
<span class="line-added">5794       StubRoutines::aarch64::_method_entry_barrier = generate_method_entry_barrier();</span>
<span class="line-added">5795     }</span>
5796 #ifdef COMPILER2
5797     if (UseMultiplyToLenIntrinsic) {
5798       StubRoutines::_multiplyToLen = generate_multiplyToLen();
5799     }
5800 
5801     if (UseSquareToLenIntrinsic) {
5802       StubRoutines::_squareToLen = generate_squareToLen();
5803     }
5804 
5805     if (UseMulAddIntrinsic) {
5806       StubRoutines::_mulAdd = generate_mulAdd();
5807     }
5808 
5809     if (UseMontgomeryMultiplyIntrinsic) {
5810       StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;montgomeryMultiply&quot;);
5811       MontgomeryMultiplyGenerator g(_masm, /*squaring*/false);
5812       StubRoutines::_montgomeryMultiply = g.generate_multiply();
5813     }
5814 
5815     if (UseMontgomerySquareIntrinsic) {
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutines_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shared/barrierSetAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 28 #include &quot;c1/c1_Runtime1.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;

 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;oops/arrayOop.hpp&quot;
 33 #include &quot;oops/markWord.hpp&quot;
 34 #include &quot;runtime/basicLock.hpp&quot;
 35 #include &quot;runtime/biasedLocking.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;runtime/sharedRuntime.hpp&quot;
 38 #include &quot;runtime/stubRoutines.hpp&quot;
 39 
 40 void C1_MacroAssembler::float_cmp(bool is_float, int unordered_result,
 41                                   FloatRegister f0, FloatRegister f1,
 42                                   Register result)
 43 {
 44   Label done;
 45   if (is_float) {
 46     fcmps(f0, f1);
 47   } else {
 48     fcmpd(f0, f1);
 49   }
</pre>
<hr />
<pre>
319   verify_oop(obj);
320 }
321 
322 
323 void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
324   verify_oop(receiver);
325   // explicit NULL check not needed since load from [klass_offset] causes a trap
326   // check against inline cache
327   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), &quot;must add explicit null check&quot;);
328 
329   cmp_klass(receiver, iCache, rscratch1);
330 }
331 
332 
333 void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {
334   assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
335   // Make sure there is enough stack space for this method&#39;s activation.
336   // Note that we do this before doing an enter().
337   generate_stack_overflow_check(bang_size_in_bytes);
338   MacroAssembler::build_frame(framesize + 2 * wordSize);




339 }
340 
341 void C1_MacroAssembler::remove_frame(int framesize) {
342   MacroAssembler::remove_frame(framesize + 2 * wordSize);
343 }
344 
345 
346 void C1_MacroAssembler::verified_entry() {
347   // If we have to make this method not-entrant we&#39;ll overwrite its
348   // first instruction with a jump.  For this action to be legal we
349   // must ensure that this first instruction is a B, BL, NOP, BKPT,
350   // SVC, HVC, or SMC.  Make it a NOP.
351   nop();
352 }
353 
354 void C1_MacroAssembler::load_parameter(int offset_in_words, Register reg) {
355   // rbp, + 0: link
356   //     + 1: return address
357   //     + 2: argument with offset 0
358   //     + 3: argument with offset 1
</pre>
</td>
<td>
<hr />
<pre>
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 28 #include &quot;c1/c1_Runtime1.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;</span>
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;interpreter/interpreter.hpp&quot;
 33 #include &quot;oops/arrayOop.hpp&quot;
 34 #include &quot;oops/markWord.hpp&quot;
 35 #include &quot;runtime/basicLock.hpp&quot;
 36 #include &quot;runtime/biasedLocking.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;runtime/sharedRuntime.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 
 41 void C1_MacroAssembler::float_cmp(bool is_float, int unordered_result,
 42                                   FloatRegister f0, FloatRegister f1,
 43                                   Register result)
 44 {
 45   Label done;
 46   if (is_float) {
 47     fcmps(f0, f1);
 48   } else {
 49     fcmpd(f0, f1);
 50   }
</pre>
<hr />
<pre>
320   verify_oop(obj);
321 }
322 
323 
324 void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
325   verify_oop(receiver);
326   // explicit NULL check not needed since load from [klass_offset] causes a trap
327   // check against inline cache
328   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), &quot;must add explicit null check&quot;);
329 
330   cmp_klass(receiver, iCache, rscratch1);
331 }
332 
333 
334 void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {
335   assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
336   // Make sure there is enough stack space for this method&#39;s activation.
337   // Note that we do this before doing an enter().
338   generate_stack_overflow_check(bang_size_in_bytes);
339   MacroAssembler::build_frame(framesize + 2 * wordSize);
<span class="line-added">340 </span>
<span class="line-added">341   // Insert nmethod entry barrier into frame.</span>
<span class="line-added">342   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added">343   bs-&gt;nmethod_entry_barrier(this);</span>
344 }
345 
346 void C1_MacroAssembler::remove_frame(int framesize) {
347   MacroAssembler::remove_frame(framesize + 2 * wordSize);
348 }
349 
350 
351 void C1_MacroAssembler::verified_entry() {
352   // If we have to make this method not-entrant we&#39;ll overwrite its
353   // first instruction with a jump.  For this action to be legal we
354   // must ensure that this first instruction is a B, BL, NOP, BKPT,
355   // SVC, HVC, or SMC.  Make it a NOP.
356   nop();
357 }
358 
359 void C1_MacroAssembler::load_parameter(int offset_in_words, Register reg) {
360   // rbp, + 0: link
361   //     + 1: return address
362   //     + 2: argument with offset 0
363   //     + 3: argument with offset 1
</pre>
</td>
</tr>
</table>
<center><a href="aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shared/barrierSetAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
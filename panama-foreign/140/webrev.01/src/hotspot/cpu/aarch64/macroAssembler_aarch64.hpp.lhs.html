<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="line-modified">   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  27 #define CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  28 
  29 #include &quot;asm/assembler.hpp&quot;
  30 #include &quot;oops/compressedOops.hpp&quot;
  31 #include &quot;utilities/powerOfTwo.hpp&quot;
  32 
  33 // MacroAssembler extends Assembler by frequently used macros.
  34 //
  35 // Instructions for which a &#39;better&#39; code sequence exists depending
  36 // on arguments should also go in here.
  37 
  38 class MacroAssembler: public Assembler {
  39   friend class LIR_Assembler;
  40 
  41  public:
  42   using Assembler::mov;
  43   using Assembler::movi;
  44 
  45  protected:
  46 
  47   // Support for VM calls
  48   //
  49   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  50   // may customize this version by overriding it for its purposes (e.g., to save/restore
  51   // additional registers when doing a VM call).
  52   virtual void call_VM_leaf_base(
  53     address entry_point,               // the entry point
  54     int     number_of_arguments,        // the number of arguments to pop after the call
  55     Label *retaddr = NULL
  56   );
  57 
  58   virtual void call_VM_leaf_base(
  59     address entry_point,               // the entry point
  60     int     number_of_arguments,        // the number of arguments to pop after the call
  61     Label &amp;retaddr) {
  62     call_VM_leaf_base(entry_point, number_of_arguments, &amp;retaddr);
  63   }
  64 
  65   // This is the base routine called by the different versions of call_VM. The interpreter
  66   // may customize this version by overriding it for its purposes (e.g., to save/restore
  67   // additional registers when doing a VM call).
  68   //
  69   // If no java_thread register is specified (noreg) than rthread will be used instead. call_VM_base
  70   // returns the register which contains the thread upon return. If a thread register has been
  71   // specified, the return value will correspond to that register. If no last_java_sp is specified
  72   // (noreg) than rsp will be used instead.
  73   virtual void call_VM_base(           // returns the register containing the thread upon return
  74     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  75     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  76     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  77     address  entry_point,              // the entry point
  78     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  79     bool     check_exceptions          // whether to check for pending exceptions after return
  80   );
  81 
  82   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  83 
  84   enum KlassDecodeMode {
  85     KlassDecodeNone,
  86     KlassDecodeZero,
  87     KlassDecodeXor,
  88     KlassDecodeMovk
  89   };
  90 
  91   KlassDecodeMode klass_decode_mode();
  92 
  93  private:
  94   static KlassDecodeMode _klass_decode_mode;
  95 
  96  public:
  97   MacroAssembler(CodeBuffer* code) : Assembler(code) {}
  98 
  99  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
 100  // The implementation is only non-empty for the InterpreterMacroAssembler,
 101  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
 102  virtual void check_and_handle_popframe(Register java_thread);
 103  virtual void check_and_handle_earlyret(Register java_thread);
 104 
 105   void safepoint_poll(Label&amp; slow_path);
 106   void safepoint_poll_acquire(Label&amp; slow_path);
 107 
 108   // Biased locking support
 109   // lock_reg and obj_reg must be loaded up with the appropriate values.
 110   // swap_reg is killed.
 111   // tmp_reg must be supplied and must not be rscratch1 or rscratch2
 112   // Optional slow case is for implementations (interpreter and C1) which branch to
 113   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 114   // Returns offset of first potentially-faulting instruction for null
 115   // check info (currently consumed only by C1). If
 116   // swap_reg_contains_mark is true then returns -1 as it is assumed
 117   // the calling code has already passed any potential faults.
 118   int biased_locking_enter(Register lock_reg, Register obj_reg,
 119                            Register swap_reg, Register tmp_reg,
 120                            bool swap_reg_contains_mark,
 121                            Label&amp; done, Label* slow_case = NULL,
 122                            BiasedLockingCounters* counters = NULL);
 123   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 124 
 125 
 126   // Helper functions for statistics gathering.
 127   // Unconditional atomic increment.
 128   void atomic_incw(Register counter_addr, Register tmp, Register tmp2);
 129   void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {
 130     lea(tmp1, counter_addr);
 131     atomic_incw(tmp1, tmp2, tmp3);
 132   }
 133   // Load Effective Address
 134   void lea(Register r, const Address &amp;a) {
 135     InstructionMark im(this);
 136     code_section()-&gt;relocate(inst_mark(), a.rspec());
 137     a.lea(this, r);
 138   }
 139 
 140   /* Sometimes we get misaligned loads and stores, usually from Unsafe
 141      accesses, and these can exceed the offset range. */
 142   Address legitimize_address(const Address &amp;a, int size, Register scratch) {
 143     if (a.getMode() == Address::base_plus_offset) {
 144       if (! Address::offset_ok_for_immed(a.offset(), exact_log2(size))) {
 145         block_comment(&quot;legitimize_address {&quot;);
 146         lea(scratch, a);
 147         block_comment(&quot;} legitimize_address&quot;);
 148         return Address(scratch);
 149       }
 150     }
 151     return a;
 152   }
 153 
 154   void addmw(Address a, Register incr, Register scratch) {
 155     ldrw(scratch, a);
 156     addw(scratch, scratch, incr);
 157     strw(scratch, a);
 158   }
 159 
 160   // Add constant to memory word
 161   void addmw(Address a, int imm, Register scratch) {
 162     ldrw(scratch, a);
 163     if (imm &gt; 0)
 164       addw(scratch, scratch, (unsigned)imm);
 165     else
 166       subw(scratch, scratch, (unsigned)-imm);
 167     strw(scratch, a);
 168   }
 169 
 170   void bind(Label&amp; L) {
 171     Assembler::bind(L);
 172     code()-&gt;clear_last_insn();
 173   }
 174 
 175   void membar(Membar_mask_bits order_constraint);
 176 
 177   using Assembler::ldr;
 178   using Assembler::str;
<a name="2" id="anc2"></a>

 179 
 180   void ldr(Register Rx, const Address &amp;adr);
 181   void ldrw(Register Rw, const Address &amp;adr);
 182   void str(Register Rx, const Address &amp;adr);
 183   void strw(Register Rx, const Address &amp;adr);
 184 
 185   // Frame creation and destruction shared between JITs.
 186   void build_frame(int framesize);
 187   void remove_frame(int framesize);
 188 
 189   virtual void _call_Unimplemented(address call_site) {
 190     mov(rscratch2, call_site);
 191   }
 192 
 193 #define call_Unimplemented() _call_Unimplemented((address)__PRETTY_FUNCTION__)
 194 
 195   // aliases defined in AARCH64 spec
 196 
 197   template&lt;class T&gt;
 198   inline void cmpw(Register Rd, T imm)  { subsw(zr, Rd, imm); }
 199 
 200   inline void cmp(Register Rd, unsigned char imm8)  { subs(zr, Rd, imm8); }
 201   inline void cmp(Register Rd, unsigned imm) __attribute__ ((deprecated));
 202 
 203   inline void cmnw(Register Rd, unsigned imm) { addsw(zr, Rd, imm); }
 204   inline void cmn(Register Rd, unsigned imm) { adds(zr, Rd, imm); }
 205 
 206   void cset(Register Rd, Assembler::Condition cond) {
 207     csinc(Rd, zr, zr, ~cond);
 208   }
 209   void csetw(Register Rd, Assembler::Condition cond) {
 210     csincw(Rd, zr, zr, ~cond);
 211   }
 212 
 213   void cneg(Register Rd, Register Rn, Assembler::Condition cond) {
 214     csneg(Rd, Rn, Rn, ~cond);
 215   }
 216   void cnegw(Register Rd, Register Rn, Assembler::Condition cond) {
 217     csnegw(Rd, Rn, Rn, ~cond);
 218   }
 219 
 220   inline void movw(Register Rd, Register Rn) {
 221     if (Rd == sp || Rn == sp) {
 222       addw(Rd, Rn, 0U);
 223     } else {
 224       orrw(Rd, zr, Rn);
 225     }
 226   }
 227   inline void mov(Register Rd, Register Rn) {
 228     assert(Rd != r31_sp &amp;&amp; Rn != r31_sp, &quot;should be&quot;);
 229     if (Rd == Rn) {
 230     } else if (Rd == sp || Rn == sp) {
 231       add(Rd, Rn, 0U);
 232     } else {
 233       orr(Rd, zr, Rn);
 234     }
 235   }
 236 
 237   inline void moviw(Register Rd, unsigned imm) { orrw(Rd, zr, imm); }
 238   inline void movi(Register Rd, unsigned imm) { orr(Rd, zr, imm); }
 239 
 240   inline void tstw(Register Rd, Register Rn) { andsw(zr, Rd, Rn); }
 241   inline void tst(Register Rd, Register Rn) { ands(zr, Rd, Rn); }
 242 
 243   inline void tstw(Register Rd, uint64_t imm) { andsw(zr, Rd, imm); }
 244   inline void tst(Register Rd, uint64_t imm) { ands(zr, Rd, imm); }
 245 
 246   inline void bfiw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 247     bfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 248   }
 249   inline void bfi(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 250     bfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 251   }
 252 
 253   inline void bfxilw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 254     bfmw(Rd, Rn, lsb, (lsb + width - 1));
 255   }
 256   inline void bfxil(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 257     bfm(Rd, Rn, lsb , (lsb + width - 1));
 258   }
 259 
 260   inline void sbfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 261     sbfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 262   }
 263   inline void sbfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 264     sbfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 265   }
 266 
 267   inline void sbfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 268     sbfmw(Rd, Rn, lsb, (lsb + width - 1));
 269   }
 270   inline void sbfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 271     sbfm(Rd, Rn, lsb , (lsb + width - 1));
 272   }
 273 
 274   inline void ubfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 275     ubfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 276   }
 277   inline void ubfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 278     ubfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 279   }
 280 
 281   inline void ubfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 282     ubfmw(Rd, Rn, lsb, (lsb + width - 1));
 283   }
 284   inline void ubfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 285     ubfm(Rd, Rn, lsb , (lsb + width - 1));
 286   }
 287 
 288   inline void asrw(Register Rd, Register Rn, unsigned imm) {
 289     sbfmw(Rd, Rn, imm, 31);
 290   }
 291 
 292   inline void asr(Register Rd, Register Rn, unsigned imm) {
 293     sbfm(Rd, Rn, imm, 63);
 294   }
 295 
 296   inline void lslw(Register Rd, Register Rn, unsigned imm) {
 297     ubfmw(Rd, Rn, ((32 - imm) &amp; 31), (31 - imm));
 298   }
 299 
 300   inline void lsl(Register Rd, Register Rn, unsigned imm) {
 301     ubfm(Rd, Rn, ((64 - imm) &amp; 63), (63 - imm));
 302   }
 303 
 304   inline void lsrw(Register Rd, Register Rn, unsigned imm) {
 305     ubfmw(Rd, Rn, imm, 31);
 306   }
 307 
 308   inline void lsr(Register Rd, Register Rn, unsigned imm) {
 309     ubfm(Rd, Rn, imm, 63);
 310   }
 311 
 312   inline void rorw(Register Rd, Register Rn, unsigned imm) {
 313     extrw(Rd, Rn, Rn, imm);
 314   }
 315 
 316   inline void ror(Register Rd, Register Rn, unsigned imm) {
 317     extr(Rd, Rn, Rn, imm);
 318   }
 319 
 320   inline void sxtbw(Register Rd, Register Rn) {
 321     sbfmw(Rd, Rn, 0, 7);
 322   }
 323   inline void sxthw(Register Rd, Register Rn) {
 324     sbfmw(Rd, Rn, 0, 15);
 325   }
 326   inline void sxtb(Register Rd, Register Rn) {
 327     sbfm(Rd, Rn, 0, 7);
 328   }
 329   inline void sxth(Register Rd, Register Rn) {
 330     sbfm(Rd, Rn, 0, 15);
 331   }
 332   inline void sxtw(Register Rd, Register Rn) {
 333     sbfm(Rd, Rn, 0, 31);
 334   }
 335 
 336   inline void uxtbw(Register Rd, Register Rn) {
 337     ubfmw(Rd, Rn, 0, 7);
 338   }
 339   inline void uxthw(Register Rd, Register Rn) {
 340     ubfmw(Rd, Rn, 0, 15);
 341   }
 342   inline void uxtb(Register Rd, Register Rn) {
 343     ubfm(Rd, Rn, 0, 7);
 344   }
 345   inline void uxth(Register Rd, Register Rn) {
 346     ubfm(Rd, Rn, 0, 15);
 347   }
 348   inline void uxtw(Register Rd, Register Rn) {
 349     ubfm(Rd, Rn, 0, 31);
 350   }
 351 
 352   inline void cmnw(Register Rn, Register Rm) {
 353     addsw(zr, Rn, Rm);
 354   }
 355   inline void cmn(Register Rn, Register Rm) {
 356     adds(zr, Rn, Rm);
 357   }
 358 
 359   inline void cmpw(Register Rn, Register Rm) {
 360     subsw(zr, Rn, Rm);
 361   }
 362   inline void cmp(Register Rn, Register Rm) {
 363     subs(zr, Rn, Rm);
 364   }
 365 
 366   inline void negw(Register Rd, Register Rn) {
 367     subw(Rd, zr, Rn);
 368   }
 369 
 370   inline void neg(Register Rd, Register Rn) {
 371     sub(Rd, zr, Rn);
 372   }
 373 
 374   inline void negsw(Register Rd, Register Rn) {
 375     subsw(Rd, zr, Rn);
 376   }
 377 
 378   inline void negs(Register Rd, Register Rn) {
 379     subs(Rd, zr, Rn);
 380   }
 381 
 382   inline void cmnw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 383     addsw(zr, Rn, Rm, kind, shift);
 384   }
 385   inline void cmn(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 386     adds(zr, Rn, Rm, kind, shift);
 387   }
 388 
 389   inline void cmpw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 390     subsw(zr, Rn, Rm, kind, shift);
 391   }
 392   inline void cmp(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 393     subs(zr, Rn, Rm, kind, shift);
 394   }
 395 
 396   inline void negw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 397     subw(Rd, zr, Rn, kind, shift);
 398   }
 399 
 400   inline void neg(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 401     sub(Rd, zr, Rn, kind, shift);
 402   }
 403 
 404   inline void negsw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 405     subsw(Rd, zr, Rn, kind, shift);
 406   }
 407 
 408   inline void negs(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 409     subs(Rd, zr, Rn, kind, shift);
 410   }
 411 
 412   inline void mnegw(Register Rd, Register Rn, Register Rm) {
 413     msubw(Rd, Rn, Rm, zr);
 414   }
 415   inline void mneg(Register Rd, Register Rn, Register Rm) {
 416     msub(Rd, Rn, Rm, zr);
 417   }
 418 
 419   inline void mulw(Register Rd, Register Rn, Register Rm) {
 420     maddw(Rd, Rn, Rm, zr);
 421   }
 422   inline void mul(Register Rd, Register Rn, Register Rm) {
 423     madd(Rd, Rn, Rm, zr);
 424   }
 425 
 426   inline void smnegl(Register Rd, Register Rn, Register Rm) {
 427     smsubl(Rd, Rn, Rm, zr);
 428   }
 429   inline void smull(Register Rd, Register Rn, Register Rm) {
 430     smaddl(Rd, Rn, Rm, zr);
 431   }
 432 
 433   inline void umnegl(Register Rd, Register Rn, Register Rm) {
 434     umsubl(Rd, Rn, Rm, zr);
 435   }
 436   inline void umull(Register Rd, Register Rn, Register Rm) {
 437     umaddl(Rd, Rn, Rm, zr);
 438   }
 439 
 440 #define WRAP(INSN)                                                            \
 441   void INSN(Register Rd, Register Rn, Register Rm, Register Ra) {             \
 442     if ((VM_Version::features() &amp; VM_Version::CPU_A53MAC) &amp;&amp; Ra != zr)        \
 443       nop();                                                                  \
 444     Assembler::INSN(Rd, Rn, Rm, Ra);                                          \
 445   }
 446 
 447   WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)
 448   WRAP(smaddl) WRAP(smsubl) WRAP(umaddl) WRAP(umsubl)
 449 #undef WRAP
 450 
 451 
 452   // macro assembly operations needed for aarch64
 453 
 454   // first two private routines for loading 32 bit or 64 bit constants
 455 private:
 456 
 457   void mov_immediate64(Register dst, u_int64_t imm64);
 458   void mov_immediate32(Register dst, u_int32_t imm32);
 459 
 460   int push(unsigned int bitset, Register stack);
 461   int pop(unsigned int bitset, Register stack);
 462 
 463   int push_fp(unsigned int bitset, Register stack);
 464   int pop_fp(unsigned int bitset, Register stack);
 465 
 466   void mov(Register dst, Address a);
 467 
 468 public:
 469   void push(RegSet regs, Register stack) { if (regs.bits()) push(regs.bits(), stack); }
 470   void pop(RegSet regs, Register stack) { if (regs.bits()) pop(regs.bits(), stack); }
 471 
 472   void push_fp(RegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }
 473   void pop_fp(RegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }
 474 
 475   // Push and pop everything that might be clobbered by a native
 476   // runtime call except rscratch1 and rscratch2.  (They are always
 477   // scratch, so we don&#39;t have to protect them.)  Only save the lower
 478   // 64 bits of each vector register.
 479   void push_call_clobbered_registers();
 480   void pop_call_clobbered_registers();
 481 
 482   // now mov instructions for loading absolute addresses and 32 or
 483   // 64 bit integers
 484 
 485   inline void mov(Register dst, address addr)
 486   {
 487     mov_immediate64(dst, (u_int64_t)addr);
 488   }
 489 
 490   inline void mov(Register dst, u_int64_t imm64)
 491   {
 492     mov_immediate64(dst, imm64);
 493   }
 494 
 495   inline void movw(Register dst, u_int32_t imm32)
 496   {
 497     mov_immediate32(dst, imm32);
 498   }
 499 
 500   inline void mov(Register dst, long l)
 501   {
 502     mov(dst, (u_int64_t)l);
 503   }
 504 
 505   inline void mov(Register dst, int i)
 506   {
 507     mov(dst, (long)i);
 508   }
 509 
 510   void mov(Register dst, RegisterOrConstant src) {
 511     if (src.is_register())
 512       mov(dst, src.as_register());
 513     else
 514       mov(dst, src.as_constant());
 515   }
 516 
 517   void movptr(Register r, uintptr_t imm64);
 518 
 519   void mov(FloatRegister Vd, SIMD_Arrangement T, u_int32_t imm32);
 520 
 521   void mov(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {
 522     orr(Vd, T, Vn, Vn);
 523   }
 524 
 525 public:
 526 
 527   // Generalized Test Bit And Branch, including a &quot;far&quot; variety which
 528   // spans more than 32KiB.
 529   void tbr(Condition cond, Register Rt, int bitpos, Label &amp;dest, bool far = false) {
 530     assert(cond == EQ || cond == NE, &quot;must be&quot;);
 531 
 532     if (far)
 533       cond = ~cond;
 534 
 535     void (Assembler::* branch)(Register Rt, int bitpos, Label &amp;L);
 536     if (cond == Assembler::EQ)
 537       branch = &amp;Assembler::tbz;
 538     else
 539       branch = &amp;Assembler::tbnz;
 540 
 541     if (far) {
 542       Label L;
 543       (this-&gt;*branch)(Rt, bitpos, L);
 544       b(dest);
 545       bind(L);
 546     } else {
 547       (this-&gt;*branch)(Rt, bitpos, dest);
 548     }
 549   }
 550 
 551   // macro instructions for accessing and updating floating point
 552   // status register
 553   //
 554   // FPSR : op1 == 011
 555   //        CRn == 0100
 556   //        CRm == 0100
 557   //        op2 == 001
 558 
 559   inline void get_fpsr(Register reg)
 560   {
 561     mrs(0b11, 0b0100, 0b0100, 0b001, reg);
 562   }
 563 
 564   inline void set_fpsr(Register reg)
 565   {
 566     msr(0b011, 0b0100, 0b0100, 0b001, reg);
 567   }
 568 
 569   inline void clear_fpsr()
 570   {
 571     msr(0b011, 0b0100, 0b0100, 0b001, zr);
 572   }
 573 
 574   // DCZID_EL0: op1 == 011
 575   //            CRn == 0000
 576   //            CRm == 0000
 577   //            op2 == 111
 578   inline void get_dczid_el0(Register reg)
 579   {
 580     mrs(0b011, 0b0000, 0b0000, 0b111, reg);
 581   }
 582 
 583   // CTR_EL0:   op1 == 011
 584   //            CRn == 0000
 585   //            CRm == 0000
 586   //            op2 == 001
 587   inline void get_ctr_el0(Register reg)
 588   {
 589     mrs(0b011, 0b0000, 0b0000, 0b001, reg);
 590   }
 591 
 592   // idiv variant which deals with MINLONG as dividend and -1 as divisor
 593   int corrected_idivl(Register result, Register ra, Register rb,
 594                       bool want_remainder, Register tmp = rscratch1);
 595   int corrected_idivq(Register result, Register ra, Register rb,
 596                       bool want_remainder, Register tmp = rscratch1);
 597 
 598   // Support for NULL-checks
 599   //
 600   // Generates code that causes a NULL OS exception if the content of reg is NULL.
 601   // If the accessed location is M[reg + offset] and the offset is known, provide the
 602   // offset. No explicit code generation is needed if the offset is within a certain
 603   // range (0 &lt;= offset &lt;= page_size).
 604 
 605   virtual void null_check(Register reg, int offset = -1);
 606   static bool needs_explicit_null_check(intptr_t offset);
 607   static bool uses_implicit_null_check(void* address);
 608 
 609   static address target_addr_for_insn(address insn_addr, unsigned insn);
 610   static address target_addr_for_insn(address insn_addr) {
 611     unsigned insn = *(unsigned*)insn_addr;
 612     return target_addr_for_insn(insn_addr, insn);
 613   }
 614 
 615   // Required platform-specific helpers for Label::patch_instructions.
 616   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 617   static int pd_patch_instruction_size(address branch, address target);
 618   static void pd_patch_instruction(address branch, address target, const char* file = NULL, int line = 0) {
 619     pd_patch_instruction_size(branch, target);
 620   }
 621   static address pd_call_destination(address branch) {
 622     return target_addr_for_insn(branch);
 623   }
 624 #ifndef PRODUCT
 625   static void pd_print_patched_instruction(address branch);
 626 #endif
 627 
 628   static int patch_oop(address insn_addr, address o);
 629   static int patch_narrow_klass(address insn_addr, narrowKlass n);
 630 
 631   address emit_trampoline_stub(int insts_call_instruction_offset, address target);
 632   void emit_static_call_stub();
 633 
 634   // The following 4 methods return the offset of the appropriate move instruction
 635 
 636   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 637   int load_unsigned_byte(Register dst, Address src);
 638   int load_unsigned_short(Register dst, Address src);
 639 
 640   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 641   int load_signed_byte(Register dst, Address src);
 642   int load_signed_short(Register dst, Address src);
 643 
 644   int load_signed_byte32(Register dst, Address src);
 645   int load_signed_short32(Register dst, Address src);
 646 
 647   // Support for sign-extension (hi:lo = extend_sign(lo))
 648   void extend_sign(Register hi, Register lo);
 649 
 650   // Load and store values by size and signed-ness
 651   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 652   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 653 
 654   // Support for inc/dec with optimal instruction selection depending on value
 655 
 656   // x86_64 aliases an unqualified register/address increment and
 657   // decrement to call incrementq and decrementq but also supports
 658   // explicitly sized calls to incrementq/decrementq or
 659   // incrementl/decrementl
 660 
 661   // for aarch64 the proper convention would be to use
 662   // increment/decrement for 64 bit operatons and
 663   // incrementw/decrementw for 32 bit operations. so when porting
 664   // x86_64 code we can leave calls to increment/decrement as is,
 665   // replace incrementq/decrementq with increment/decrement and
 666   // replace incrementl/decrementl with incrementw/decrementw.
 667 
 668   // n.b. increment/decrement calls with an Address destination will
 669   // need to use a scratch register to load the value to be
 670   // incremented. increment/decrement calls which add or subtract a
 671   // constant value greater than 2^12 will need to use a 2nd scratch
 672   // register to hold the constant. so, a register increment/decrement
 673   // may trash rscratch2 and an address increment/decrement trash
 674   // rscratch and rscratch2
 675 
 676   void decrementw(Address dst, int value = 1);
 677   void decrementw(Register reg, int value = 1);
 678 
 679   void decrement(Register reg, int value = 1);
 680   void decrement(Address dst, int value = 1);
 681 
 682   void incrementw(Address dst, int value = 1);
 683   void incrementw(Register reg, int value = 1);
 684 
 685   void increment(Register reg, int value = 1);
 686   void increment(Address dst, int value = 1);
 687 
 688 
 689   // Alignment
 690   void align(int modulus);
 691 
 692   // Stack frame creation/removal
 693   void enter()
 694   {
 695     stp(rfp, lr, Address(pre(sp, -2 * wordSize)));
 696     mov(rfp, sp);
 697   }
 698   void leave()
 699   {
 700     mov(sp, rfp);
 701     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
 702   }
 703 
 704   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 705   // The pointer will be loaded into the thread register.
 706   void get_thread(Register thread);
 707 
 708 
 709   // Support for VM calls
 710   //
 711   // It is imperative that all calls into the VM are handled via the call_VM macros.
 712   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 713   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 714 
 715 
 716   void call_VM(Register oop_result,
 717                address entry_point,
 718                bool check_exceptions = true);
 719   void call_VM(Register oop_result,
 720                address entry_point,
 721                Register arg_1,
 722                bool check_exceptions = true);
 723   void call_VM(Register oop_result,
 724                address entry_point,
 725                Register arg_1, Register arg_2,
 726                bool check_exceptions = true);
 727   void call_VM(Register oop_result,
 728                address entry_point,
 729                Register arg_1, Register arg_2, Register arg_3,
 730                bool check_exceptions = true);
 731 
 732   // Overloadings with last_Java_sp
 733   void call_VM(Register oop_result,
 734                Register last_java_sp,
 735                address entry_point,
 736                int number_of_arguments = 0,
 737                bool check_exceptions = true);
 738   void call_VM(Register oop_result,
 739                Register last_java_sp,
 740                address entry_point,
 741                Register arg_1, bool
 742                check_exceptions = true);
 743   void call_VM(Register oop_result,
 744                Register last_java_sp,
 745                address entry_point,
 746                Register arg_1, Register arg_2,
 747                bool check_exceptions = true);
 748   void call_VM(Register oop_result,
 749                Register last_java_sp,
 750                address entry_point,
 751                Register arg_1, Register arg_2, Register arg_3,
 752                bool check_exceptions = true);
 753 
 754   void get_vm_result  (Register oop_result, Register thread);
 755   void get_vm_result_2(Register metadata_result, Register thread);
 756 
 757   // These always tightly bind to MacroAssembler::call_VM_base
 758   // bypassing the virtual implementation
 759   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 760   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 761   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 762   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 763   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 764 
 765   void call_VM_leaf(address entry_point,
 766                     int number_of_arguments = 0);
 767   void call_VM_leaf(address entry_point,
 768                     Register arg_1);
 769   void call_VM_leaf(address entry_point,
 770                     Register arg_1, Register arg_2);
 771   void call_VM_leaf(address entry_point,
 772                     Register arg_1, Register arg_2, Register arg_3);
 773 
 774   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 775   // bypassing the virtual implementation
 776   void super_call_VM_leaf(address entry_point);
 777   void super_call_VM_leaf(address entry_point, Register arg_1);
 778   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 779   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 780   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 781 
 782   // last Java Frame (fills frame anchor)
 783   void set_last_Java_frame(Register last_java_sp,
 784                            Register last_java_fp,
 785                            address last_java_pc,
 786                            Register scratch);
 787 
 788   void set_last_Java_frame(Register last_java_sp,
 789                            Register last_java_fp,
 790                            Label &amp;last_java_pc,
 791                            Register scratch);
 792 
 793   void set_last_Java_frame(Register last_java_sp,
 794                            Register last_java_fp,
 795                            Register last_java_pc,
 796                            Register scratch);
 797 
 798   void reset_last_Java_frame(Register thread);
 799 
 800   // thread in the default location (rthread)
 801   void reset_last_Java_frame(bool clear_fp);
 802 
 803   // Stores
 804   void store_check(Register obj);                // store check for obj - register is destroyed afterwards
 805   void store_check(Register obj, Address dst);   // same as above, dst is exact store location (reg. is destroyed)
 806 
 807   void resolve_jobject(Register value, Register thread, Register tmp);
 808 
 809   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 810   void c2bool(Register x);
 811 
<a name="3" id="anc3"></a>
 812   void load_method_holder(Register holder, Register method);
 813 
 814   // oop manipulations
 815   void load_klass(Register dst, Register src);
 816   void store_klass(Register dst, Register src);
 817   void cmp_klass(Register oop, Register trial_klass, Register tmp);
 818 
<a name="4" id="anc4"></a>
 819   void resolve_oop_handle(Register result, Register tmp = r5);
 820   void load_mirror(Register dst, Register method, Register tmp = r5);
 821 
 822   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 823                       Register tmp1, Register tmp_thread);
 824 
 825   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 826                        Register tmp1, Register tmp_thread);
 827 
 828   // Resolves obj for access. Result is placed in the same register.
 829   // All other registers are preserved.
 830   void resolve(DecoratorSet decorators, Register obj);
 831 
 832   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 833                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 834 
 835   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 836                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 837   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 838                       Register tmp_thread = noreg, DecoratorSet decorators = 0);
 839 
 840   // currently unimplemented
 841   // Used for storing NULL. All other oop constants should be
 842   // stored using routines that take a jobject.
 843   void store_heap_oop_null(Address dst);
 844 
 845   void load_prototype_header(Register dst, Register src);
 846 
 847   void store_klass_gap(Register dst, Register src);
 848 
 849   // This dummy is to prevent a call to store_heap_oop from
 850   // converting a zero (like NULL) into a Register by giving
 851   // the compiler two choices it can&#39;t resolve
 852 
 853   void store_heap_oop(Address dst, void* dummy);
 854 
 855   void encode_heap_oop(Register d, Register s);
 856   void encode_heap_oop(Register r) { encode_heap_oop(r, r); }
 857   void decode_heap_oop(Register d, Register s);
 858   void decode_heap_oop(Register r) { decode_heap_oop(r, r); }
 859   void encode_heap_oop_not_null(Register r);
 860   void decode_heap_oop_not_null(Register r);
 861   void encode_heap_oop_not_null(Register dst, Register src);
 862   void decode_heap_oop_not_null(Register dst, Register src);
 863 
 864   void set_narrow_oop(Register dst, jobject obj);
 865 
 866   void encode_klass_not_null(Register r);
 867   void decode_klass_not_null(Register r);
 868   void encode_klass_not_null(Register dst, Register src);
 869   void decode_klass_not_null(Register dst, Register src);
 870 
 871   void set_narrow_klass(Register dst, Klass* k);
 872 
 873   // if heap base register is used - reinit it with the correct value
 874   void reinit_heapbase();
 875 
 876   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 877 
 878   void push_CPU_state(bool save_vectors = false);
 879   void pop_CPU_state(bool restore_vectors = false) ;
 880 
 881   // Round up to a power of two
 882   void round_to(Register reg, int modulus);
 883 
 884   // allocation
 885   void eden_allocate(
 886     Register obj,                      // result: pointer to object after successful allocation
 887     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 888     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 889     Register t1,                       // temp register
 890     Label&amp;   slow_case                 // continuation point if fast allocation fails
 891   );
 892   void tlab_allocate(
 893     Register obj,                      // result: pointer to object after successful allocation
 894     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 895     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 896     Register t1,                       // temp register
 897     Register t2,                       // temp register
 898     Label&amp;   slow_case                 // continuation point if fast allocation fails
 899   );
 900   void zero_memory(Register addr, Register len, Register t1);
 901   void verify_tlab();
 902 
 903   // interface method calling
 904   void lookup_interface_method(Register recv_klass,
 905                                Register intf_klass,
 906                                RegisterOrConstant itable_index,
 907                                Register method_result,
 908                                Register scan_temp,
 909                                Label&amp; no_such_interface,
 910                    bool return_method = true);
 911 
 912   // virtual method calling
 913   // n.b. x86 allows RegisterOrConstant for vtable_index
 914   void lookup_virtual_method(Register recv_klass,
 915                              RegisterOrConstant vtable_index,
 916                              Register method_result);
 917 
 918   // Test sub_klass against super_klass, with fast and slow paths.
 919 
 920   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 921   // One of the three labels can be NULL, meaning take the fall-through.
 922   // If super_check_offset is -1, the value is loaded up from super_klass.
 923   // No registers are killed, except temp_reg.
 924   void check_klass_subtype_fast_path(Register sub_klass,
 925                                      Register super_klass,
 926                                      Register temp_reg,
 927                                      Label* L_success,
 928                                      Label* L_failure,
 929                                      Label* L_slow_path,
 930                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 931 
 932   // The rest of the type check; must be wired to a corresponding fast path.
 933   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 934   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 935   // Updates the sub&#39;s secondary super cache as necessary.
 936   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 937   void check_klass_subtype_slow_path(Register sub_klass,
 938                                      Register super_klass,
 939                                      Register temp_reg,
 940                                      Register temp2_reg,
 941                                      Label* L_success,
 942                                      Label* L_failure,
 943                                      bool set_cond_codes = false);
 944 
 945   // Simplified, combined version, good for typical uses.
 946   // Falls through on failure.
 947   void check_klass_subtype(Register sub_klass,
 948                            Register super_klass,
 949                            Register temp_reg,
 950                            Label&amp; L_success);
 951 
 952   void clinit_barrier(Register klass,
 953                       Register thread,
 954                       Label* L_fast_path = NULL,
 955                       Label* L_slow_path = NULL);
 956 
 957   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 958 
 959 
 960   // Debugging
 961 
 962   // only if +VerifyOops
 963   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 964   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 965 
 966 // TODO: verify method and klass metadata (compare against vptr?)
 967   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 968   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 969 
 970 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 971 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 972 
 973   // only if +VerifyFPU
 974   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 975 
 976   // prints msg, dumps registers and stops execution
 977   void stop(const char* msg);
 978 
 979   // prints msg and continues
 980   void warn(const char* msg);
 981 
 982   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 983 
 984   void untested()                                { stop(&quot;untested&quot;); }
 985 
 986   void unimplemented(const char* what = &quot;&quot;);
 987 
 988   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 989 
 990   // Stack overflow checking
 991   void bang_stack_with_offset(int offset) {
 992     // stack grows down, caller passes positive offset
 993     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
 994     sub(rscratch2, sp, offset);
 995     str(zr, Address(rscratch2));
 996   }
 997 
 998   // Writes to stack successive pages until offset reached to check for
 999   // stack overflow + shadow pages.  Also, clobbers tmp
1000   void bang_stack_size(Register size, Register tmp);
1001 
1002   // Check for reserved stack access in method being exited (for JIT)
1003   void reserved_stack_check();
1004 
1005   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
1006                                                 Register tmp,
1007                                                 int offset);
1008 
1009   // Arithmetics
1010 
1011   void addptr(const Address &amp;dst, int32_t src);
1012   void cmpptr(Register src1, Address src2);
1013 
1014   void cmpoop(Register obj1, Register obj2);
1015 
1016   // Various forms of CAS
1017 
1018   void cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,
1019                           Label &amp;suceed, Label *fail);
1020   void cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,
1021                   Label &amp;suceed, Label *fail);
1022 
1023   void cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,
1024                   Label &amp;suceed, Label *fail);
1025 
1026   void atomic_add(Register prev, RegisterOrConstant incr, Register addr);
1027   void atomic_addw(Register prev, RegisterOrConstant incr, Register addr);
1028   void atomic_addal(Register prev, RegisterOrConstant incr, Register addr);
1029   void atomic_addalw(Register prev, RegisterOrConstant incr, Register addr);
1030 
1031   void atomic_xchg(Register prev, Register newv, Register addr);
1032   void atomic_xchgw(Register prev, Register newv, Register addr);
1033   void atomic_xchgal(Register prev, Register newv, Register addr);
1034   void atomic_xchgalw(Register prev, Register newv, Register addr);
1035 
1036   void orptr(Address adr, RegisterOrConstant src) {
1037     ldr(rscratch1, adr);
1038     if (src.is_register())
1039       orr(rscratch1, rscratch1, src.as_register());
1040     else
1041       orr(rscratch1, rscratch1, src.as_constant());
1042     str(rscratch1, adr);
1043   }
1044 
1045   // A generic CAS; success or failure is in the EQ flag.
1046   // Clobbers rscratch1
1047   void cmpxchg(Register addr, Register expected, Register new_val,
1048                enum operand_size size,
1049                bool acquire, bool release, bool weak,
1050                Register result);
1051 private:
1052   void compare_eq(Register rn, Register rm, enum operand_size size);
1053 
1054 public:
1055   // Calls
1056 
1057   address trampoline_call(Address entry, CodeBuffer *cbuf = NULL);
1058 
1059   static bool far_branches() {
1060     return ReservedCodeCacheSize &gt; branch_range || UseAOT;
1061   }
1062 
1063   // Jumps that can reach anywhere in the code cache.
1064   // Trashes tmp.
1065   void far_call(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1066   void far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1067 
1068   static int far_branch_size() {
1069     if (far_branches()) {
1070       return 3 * 4;  // adrp, add, br
1071     } else {
1072       return 4;
1073     }
1074   }
1075 
1076   // Emit the CompiledIC call idiom
1077   address ic_call(address entry, jint method_index = 0);
1078 
1079 public:
1080 
1081   // Data
1082 
1083   void mov_metadata(Register dst, Metadata* obj);
1084   Address allocate_metadata_address(Metadata* obj);
1085   Address constant_oop_address(jobject obj);
1086 
1087   void movoop(Register dst, jobject obj, bool immediate = false);
1088 
1089   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1090   void kernel_crc32(Register crc, Register buf, Register len,
1091         Register table0, Register table1, Register table2, Register table3,
1092         Register tmp, Register tmp2, Register tmp3);
1093   // CRC32 code for java.util.zip.CRC32C::updateBytes() instrinsic.
1094   void kernel_crc32c(Register crc, Register buf, Register len,
1095         Register table0, Register table1, Register table2, Register table3,
1096         Register tmp, Register tmp2, Register tmp3);
1097 
1098   // Stack push and pop individual 64 bit registers
1099   void push(Register src);
1100   void pop(Register dst);
1101 
1102   // push all registers onto the stack
1103   void pusha();
1104   void popa();
1105 
1106   void repne_scan(Register addr, Register value, Register count,
1107                   Register scratch);
1108   void repne_scanw(Register addr, Register value, Register count,
1109                    Register scratch);
1110 
1111   typedef void (MacroAssembler::* add_sub_imm_insn)(Register Rd, Register Rn, unsigned imm);
1112   typedef void (MacroAssembler::* add_sub_reg_insn)(Register Rd, Register Rn, Register Rm, enum shift_kind kind, unsigned shift);
1113 
1114   // If a constant does not fit in an immediate field, generate some
1115   // number of MOV instructions and then perform the operation
1116   void wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
1117                              add_sub_imm_insn insn1,
1118                              add_sub_reg_insn insn2);
1119   // Seperate vsn which sets the flags
1120   void wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,
1121                              add_sub_imm_insn insn1,
1122                              add_sub_reg_insn insn2);
1123 
1124 #define WRAP(INSN)                                                      \
1125   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1126     wrap_add_sub_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1127   }                                                                     \
1128                                                                         \
1129   void INSN(Register Rd, Register Rn, Register Rm,                      \
1130              enum shift_kind kind, unsigned shift = 0) {                \
1131     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1132   }                                                                     \
1133                                                                         \
1134   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1135     Assembler::INSN(Rd, Rn, Rm);                                        \
1136   }                                                                     \
1137                                                                         \
1138   void INSN(Register Rd, Register Rn, Register Rm,                      \
1139            ext::operation option, int amount = 0) {                     \
1140     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1141   }
1142 
1143   WRAP(add) WRAP(addw) WRAP(sub) WRAP(subw)
1144 
1145 #undef WRAP
1146 #define WRAP(INSN)                                                      \
1147   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1148     wrap_adds_subs_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1149   }                                                                     \
1150                                                                         \
1151   void INSN(Register Rd, Register Rn, Register Rm,                      \
1152              enum shift_kind kind, unsigned shift = 0) {                \
1153     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1154   }                                                                     \
1155                                                                         \
1156   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1157     Assembler::INSN(Rd, Rn, Rm);                                        \
1158   }                                                                     \
1159                                                                         \
1160   void INSN(Register Rd, Register Rn, Register Rm,                      \
1161            ext::operation option, int amount = 0) {                     \
1162     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1163   }
1164 
1165   WRAP(adds) WRAP(addsw) WRAP(subs) WRAP(subsw)
1166 
1167   void add(Register Rd, Register Rn, RegisterOrConstant increment);
1168   void addw(Register Rd, Register Rn, RegisterOrConstant increment);
1169   void sub(Register Rd, Register Rn, RegisterOrConstant decrement);
1170   void subw(Register Rd, Register Rn, RegisterOrConstant decrement);
1171 
1172   void adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset);
1173 
1174   void tableswitch(Register index, jint lowbound, jint highbound,
1175                    Label &amp;jumptable, Label &amp;jumptable_end, int stride = 1) {
1176     adr(rscratch1, jumptable);
1177     subsw(rscratch2, index, lowbound);
1178     subsw(zr, rscratch2, highbound - lowbound);
1179     br(Assembler::HS, jumptable_end);
1180     add(rscratch1, rscratch1, rscratch2,
1181         ext::sxtw, exact_log2(stride * Assembler::instruction_size));
1182     br(rscratch1);
1183   }
1184 
1185   // Form an address from base + offset in Rd.  Rd may or may not
1186   // actually be used: you must use the Address that is returned.  It
1187   // is up to you to ensure that the shift provided matches the size
1188   // of your data.
1189   Address form_address(Register Rd, Register base, long byte_offset, int shift);
1190 
1191   // Return true iff an address is within the 48-bit AArch64 address
1192   // space.
1193   bool is_valid_AArch64_address(address a) {
1194     return ((uint64_t)a &gt;&gt; 48) == 0;
1195   }
1196 
1197   // Load the base of the cardtable byte map into reg.
1198   void load_byte_map_base(Register reg);
1199 
1200   // Prolog generator routines to support switch between x86 code and
1201   // generated ARM code
1202 
1203   // routine to generate an x86 prolog for a stub function which
1204   // bootstraps into the generated ARM code which directly follows the
1205   // stub
1206   //
1207 
1208   public:
1209 
1210   void ldr_constant(Register dest, const Address &amp;const_addr) {
1211     if (NearCpool) {
1212       ldr(dest, const_addr);
1213     } else {
1214       unsigned long offset;
1215       adrp(dest, InternalAddress(const_addr.target()), offset);
1216       ldr(dest, Address(dest, offset));
1217     }
1218   }
1219 
1220   address read_polling_page(Register r, relocInfo::relocType rtype);
1221   void get_polling_page(Register dest, relocInfo::relocType rtype);
1222   address fetch_and_read_polling_page(Register r, relocInfo::relocType rtype);
1223 
1224   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1225   void update_byte_crc32(Register crc, Register val, Register table);
1226   void update_word_crc32(Register crc, Register v, Register tmp,
1227         Register table0, Register table1, Register table2, Register table3,
1228         bool upper = false);
1229 
1230   void has_negatives(Register ary1, Register len, Register result);
1231 
1232   void arrays_equals(Register a1, Register a2, Register result, Register cnt1,
1233                      Register tmp1, Register tmp2, Register tmp3, int elem_size);
1234 
1235   void string_equals(Register a1, Register a2, Register result, Register cnt1,
1236                      int elem_size);
1237 
1238   void fill_words(Register base, Register cnt, Register value);
1239   void zero_words(Register base, u_int64_t cnt);
1240   void zero_words(Register ptr, Register cnt);
1241   void zero_dcache_blocks(Register base, Register cnt);
1242 
1243   static const int zero_words_block_size;
1244 
1245   void byte_array_inflate(Register src, Register dst, Register len,
1246                           FloatRegister vtmp1, FloatRegister vtmp2,
1247                           FloatRegister vtmp3, Register tmp4);
1248 
1249   void char_array_compress(Register src, Register dst, Register len,
1250                            FloatRegister tmp1Reg, FloatRegister tmp2Reg,
1251                            FloatRegister tmp3Reg, FloatRegister tmp4Reg,
1252                            Register result);
1253 
1254   void encode_iso_array(Register src, Register dst,
1255                         Register len, Register result,
1256                         FloatRegister Vtmp1, FloatRegister Vtmp2,
1257                         FloatRegister Vtmp3, FloatRegister Vtmp4);
1258   void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,
1259                 FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,
1260                 FloatRegister tmpC1, FloatRegister tmpC2, FloatRegister tmpC3,
1261                 FloatRegister tmpC4, Register tmp1, Register tmp2,
1262                 Register tmp3, Register tmp4, Register tmp5);
1263   void generate_dsin_dcos(bool isCos, address npio2_hw, address two_over_pi,
1264       address pio2, address dsin_coef, address dcos_coef);
1265  private:
1266   // begin trigonometric functions support block
1267   void generate__ieee754_rem_pio2(address npio2_hw, address two_over_pi, address pio2);
1268   void generate__kernel_rem_pio2(address two_over_pi, address pio2);
1269   void generate_kernel_sin(FloatRegister x, bool iyIsOne, address dsin_coef);
1270   void generate_kernel_cos(FloatRegister x, address dcos_coef);
1271   // end trigonometric functions support block
1272   void add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,
1273                        Register src1, Register src2);
1274   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
1275     add2_with_carry(dest_hi, dest_hi, dest_lo, src1, src2);
1276   }
1277   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1278                              Register y, Register y_idx, Register z,
1279                              Register carry, Register product,
1280                              Register idx, Register kdx);
1281   void multiply_128_x_128_loop(Register y, Register z,
1282                                Register carry, Register carry2,
1283                                Register idx, Register jdx,
1284                                Register yz_idx1, Register yz_idx2,
1285                                Register tmp, Register tmp3, Register tmp4,
1286                                Register tmp7, Register product_hi);
1287   void kernel_crc32_using_crc32(Register crc, Register buf,
1288         Register len, Register tmp0, Register tmp1, Register tmp2,
1289         Register tmp3);
1290   void kernel_crc32c_using_crc32c(Register crc, Register buf,
1291         Register len, Register tmp0, Register tmp1, Register tmp2,
1292         Register tmp3);
1293 public:
1294   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z,
1295                        Register zlen, Register tmp1, Register tmp2, Register tmp3,
1296                        Register tmp4, Register tmp5, Register tmp6, Register tmp7);
1297   void mul_add(Register out, Register in, Register offs, Register len, Register k);
1298   // ISB may be needed because of a safepoint
1299   void maybe_isb() { isb(); }
1300 
1301 private:
1302   // Return the effective address r + (r1 &lt;&lt; ext) + offset.
1303   // Uses rscratch2.
1304   Address offsetted_address(Register r, Register r1, Address::extend ext,
1305                             int offset, int size);
1306 
1307 private:
1308   // Returns an address on the stack which is reachable with a ldr/str of size
1309   // Uses rscratch2 if the address is not directly reachable
1310   Address spill_address(int size, int offset, Register tmp=rscratch2);
1311 
1312   bool merge_alignment_check(Register base, size_t size, long cur_offset, long prev_offset) const;
1313 
1314   // Check whether two loads/stores can be merged into ldp/stp.
1315   bool ldst_can_merge(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store) const;
1316 
1317   // Merge current load/store with previous load/store into ldp/stp.
1318   void merge_ldst(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1319 
1320   // Try to merge two loads/stores into ldp/stp. If success, returns true else false.
1321   bool try_merge_ldst(Register rt, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1322 
1323 public:
1324   void spill(Register Rx, bool is64, int offset) {
1325     if (is64) {
1326       str(Rx, spill_address(8, offset));
1327     } else {
1328       strw(Rx, spill_address(4, offset));
1329     }
1330   }
1331   void spill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1332     str(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1333   }
1334   void unspill(Register Rx, bool is64, int offset) {
1335     if (is64) {
1336       ldr(Rx, spill_address(8, offset));
1337     } else {
1338       ldrw(Rx, spill_address(4, offset));
1339     }
1340   }
1341   void unspill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1342     ldr(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1343   }
1344   void spill_copy128(int src_offset, int dst_offset,
1345                      Register tmp1=rscratch1, Register tmp2=rscratch2) {
1346     if (src_offset &lt; 512 &amp;&amp; (src_offset &amp; 7) == 0 &amp;&amp;
1347         dst_offset &lt; 512 &amp;&amp; (dst_offset &amp; 7) == 0) {
1348       ldp(tmp1, tmp2, Address(sp, src_offset));
1349       stp(tmp1, tmp2, Address(sp, dst_offset));
1350     } else {
1351       unspill(tmp1, true, src_offset);
1352       spill(tmp1, true, dst_offset);
1353       unspill(tmp1, true, src_offset+8);
1354       spill(tmp1, true, dst_offset+8);
1355     }
1356   }
1357 
1358   void cache_wb(Address line);
1359   void cache_wbsync(bool is_pre);
1360 };
1361 
1362 #ifdef ASSERT
1363 inline bool AbstractAssembler::pd_check_instruction_mark() { return false; }
1364 #endif
1365 
1366 /**
1367  * class SkipIfEqual:
1368  *
1369  * Instantiating this class will result in assembly code being output that will
1370  * jump around any code emitted between the creation of the instance and it&#39;s
1371  * automatic destruction at the end of a scope block, depending on the value of
1372  * the flag passed to the constructor, which will be checked at run-time.
1373  */
1374 class SkipIfEqual {
1375  private:
1376   MacroAssembler* _masm;
1377   Label _label;
1378 
1379  public:
1380    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1381    ~SkipIfEqual();
1382 };
1383 
1384 struct tableswitch {
1385   Register _reg;
1386   int _insn_index; jint _first_key; jint _last_key;
1387   Label _after;
1388   Label _branches;
1389 };
1390 
1391 #endif // CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
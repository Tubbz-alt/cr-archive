<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 28 #include &quot;c1/c1_Runtime1.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 30 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;</span>
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;interpreter/interpreter.hpp&quot;
 33 #include &quot;oops/arrayOop.hpp&quot;
 34 #include &quot;oops/markWord.hpp&quot;
 35 #include &quot;runtime/basicLock.hpp&quot;
 36 #include &quot;runtime/biasedLocking.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;runtime/sharedRuntime.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 
 41 void C1_MacroAssembler::float_cmp(bool is_float, int unordered_result,
 42                                   FloatRegister f0, FloatRegister f1,
 43                                   Register result)
 44 {
 45   Label done;
 46   if (is_float) {
 47     fcmps(f0, f1);
 48   } else {
 49     fcmpd(f0, f1);
 50   }
 51   if (unordered_result &lt; 0) {
 52     // we want -1 for unordered or less than, 0 for equal and 1 for
 53     // greater than.
 54     cset(result, NE);  // Not equal or unordered
 55     cneg(result, result, LT);  // Less than or unordered
 56   } else {
 57     // we want -1 for less than, 0 for equal and 1 for unordered or
 58     // greater than.
 59     cset(result, NE);  // Not equal or unordered
 60     cneg(result, result, LO);  // Less than
 61   }
 62 }
 63 
 64 int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label&amp; slow_case) {
 65   const int aligned_mask = BytesPerWord -1;
 66   const int hdr_offset = oopDesc::mark_offset_in_bytes();
 67   assert(hdr != obj &amp;&amp; hdr != disp_hdr &amp;&amp; obj != disp_hdr, &quot;registers must be different&quot;);
 68   Label done;
 69   int null_check_offset = -1;
 70 
 71   verify_oop(obj);
 72 
 73   // save object being locked into the BasicObjectLock
 74   str(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
 75 
 76   if (UseBiasedLocking) {
 77     assert(scratch != noreg, &quot;should have scratch register at this point&quot;);
 78     null_check_offset = biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &amp;slow_case);
 79   } else {
 80     null_check_offset = offset();
 81   }
 82 
 83   // Load object header
 84   ldr(hdr, Address(obj, hdr_offset));
 85   // and mark it as unlocked
 86   orr(hdr, hdr, markWord::unlocked_value);
 87   // save unlocked object header into the displaced header location on the stack
 88   str(hdr, Address(disp_hdr, 0));
 89   // test if object header is still the same (i.e. unlocked), and if so, store the
 90   // displaced header address in the object header - if it is not the same, get the
 91   // object header instead
 92   lea(rscratch2, Address(obj, hdr_offset));
 93   cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, /*fallthough*/NULL);
 94   // if the object header was the same, we&#39;re done
 95   // if the object header was not the same, it is now in the hdr register
 96   // =&gt; test if it is a stack pointer into the same stack (recursive locking), i.e.:
 97   //
 98   // 1) (hdr &amp; aligned_mask) == 0
 99   // 2) sp &lt;= hdr
100   // 3) hdr &lt;= sp + page_size
101   //
102   // these 3 tests can be done by evaluating the following expression:
103   //
104   // (hdr - sp) &amp; (aligned_mask - page_size)
105   //
106   // assuming both the stack pointer and page_size have their least
107   // significant 2 bits cleared and page_size is a power of 2
108   mov(rscratch1, sp);
109   sub(hdr, hdr, rscratch1);
110   ands(hdr, hdr, aligned_mask - os::vm_page_size());
111   // for recursive locking, the result is zero =&gt; save it in the displaced header
112   // location (NULL in the displaced hdr location indicates recursive locking)
113   str(hdr, Address(disp_hdr, 0));
114   // otherwise we don&#39;t care about the result and handle locking via runtime call
115   cbnz(hdr, slow_case);
116   // done
117   bind(done);
118   if (PrintBiasedLockingStatistics) {
119     lea(rscratch2, ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));
120     addmw(Address(rscratch2, 0), 1, rscratch1);
121   }
122   return null_check_offset;
123 }
124 
125 
126 void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label&amp; slow_case) {
127   const int aligned_mask = BytesPerWord -1;
128   const int hdr_offset = oopDesc::mark_offset_in_bytes();
129   assert(hdr != obj &amp;&amp; hdr != disp_hdr &amp;&amp; obj != disp_hdr, &quot;registers must be different&quot;);
130   Label done;
131 
132   if (UseBiasedLocking) {
133     // load object
134     ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
135     biased_locking_exit(obj, hdr, done);
136   }
137 
138   // load displaced header
139   ldr(hdr, Address(disp_hdr, 0));
140   // if the loaded hdr is NULL we had recursive locking
141   // if we had recursive locking, we are done
142   cbz(hdr, done);
143   if (!UseBiasedLocking) {
144     // load object
145     ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
146   }
147   verify_oop(obj);
148   // test if object header is pointing to the displaced header, and if so, restore
149   // the displaced header in the object - if the object header is not pointing to
150   // the displaced header, get the object header instead
151   // if the object header was not pointing to the displaced header,
152   // we do unlocking via runtime call
153   if (hdr_offset) {
154     lea(rscratch1, Address(obj, hdr_offset));
155     cmpxchgptr(disp_hdr, hdr, rscratch1, rscratch2, done, &amp;slow_case);
156   } else {
157     cmpxchgptr(disp_hdr, hdr, obj, rscratch2, done, &amp;slow_case);
158   }
159   // done
160   bind(done);
161 }
162 
163 
164 // Defines obj, preserves var_size_in_bytes
165 void C1_MacroAssembler::try_allocate(Register obj, Register var_size_in_bytes, int con_size_in_bytes, Register t1, Register t2, Label&amp; slow_case) {
166   if (UseTLAB) {
167     tlab_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
168   } else {
169     eden_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
170   }
171 }
172 
173 void C1_MacroAssembler::initialize_header(Register obj, Register klass, Register len, Register t1, Register t2) {
174   assert_different_registers(obj, klass, len);
175   if (UseBiasedLocking &amp;&amp; !len-&gt;is_valid()) {
176     assert_different_registers(obj, klass, len, t1, t2);
177     ldr(t1, Address(klass, Klass::prototype_header_offset()));
178   } else {
179     // This assumes that all prototype bits fit in an int32_t
180     mov(t1, (int32_t)(intptr_t)markWord::prototype().value());
181   }
182   str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));
183 
184   if (UseCompressedClassPointers) { // Take care not to kill klass
185     encode_klass_not_null(t1, klass);
186     strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));
187   } else {
188     str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));
189   }
190 
191   if (len-&gt;is_valid()) {
192     strw(len, Address(obj, arrayOopDesc::length_offset_in_bytes()));
193   } else if (UseCompressedClassPointers) {
194     store_klass_gap(obj, zr);
195   }
196 }
197 
198 // preserves obj, destroys len_in_bytes
199 void C1_MacroAssembler::initialize_body(Register obj, Register len_in_bytes, int hdr_size_in_bytes, Register t1) {
200   assert(hdr_size_in_bytes &gt;= 0, &quot;header size must be positive or 0&quot;);
201   Label done;
202 
203   // len_in_bytes is positive and ptr sized
204   subs(len_in_bytes, len_in_bytes, hdr_size_in_bytes);
205   br(Assembler::EQ, done);
206 
207   // Preserve obj
208   if (hdr_size_in_bytes)
209     add(obj, obj, hdr_size_in_bytes);
210   zero_memory(obj, len_in_bytes, t1);
211   if (hdr_size_in_bytes)
212     sub(obj, obj, hdr_size_in_bytes);
213 
214   bind(done);
215 }
216 
217 
218 void C1_MacroAssembler::allocate_object(Register obj, Register t1, Register t2, int header_size, int object_size, Register klass, Label&amp; slow_case) {
219   assert_different_registers(obj, t1, t2); // XXX really?
220   assert(header_size &gt;= 0 &amp;&amp; object_size &gt;= header_size, &quot;illegal sizes&quot;);
221 
222   try_allocate(obj, noreg, object_size * BytesPerWord, t1, t2, slow_case);
223 
224   initialize_object(obj, klass, noreg, object_size * HeapWordSize, t1, t2, UseTLAB);
225 }
226 
227 void C1_MacroAssembler::initialize_object(Register obj, Register klass, Register var_size_in_bytes, int con_size_in_bytes, Register t1, Register t2, bool is_tlab_allocated) {
228   assert((con_size_in_bytes &amp; MinObjAlignmentInBytesMask) == 0,
229          &quot;con_size_in_bytes is not multiple of alignment&quot;);
230   const int hdr_size_in_bytes = instanceOopDesc::header_size() * HeapWordSize;
231 
232   initialize_header(obj, klass, noreg, t1, t2);
233 
234   if (!(UseTLAB &amp;&amp; ZeroTLAB &amp;&amp; is_tlab_allocated)) {
235      // clear rest of allocated space
236      const Register index = t2;
237      const int threshold = 16 * BytesPerWord;   // approximate break even point for code size (see comments below)
238      if (var_size_in_bytes != noreg) {
239        mov(index, var_size_in_bytes);
240        initialize_body(obj, index, hdr_size_in_bytes, t1);
241      } else if (con_size_in_bytes &lt;= threshold) {
242        // use explicit null stores
243        int i = hdr_size_in_bytes;
244        if (i &lt; con_size_in_bytes &amp;&amp; (con_size_in_bytes % (2 * BytesPerWord))) {
245          str(zr, Address(obj, i));
246          i += BytesPerWord;
247        }
248        for (; i &lt; con_size_in_bytes; i += 2 * BytesPerWord)
249          stp(zr, zr, Address(obj, i));
250      } else if (con_size_in_bytes &gt; hdr_size_in_bytes) {
251        block_comment(&quot;zero memory&quot;);
252       // use loop to null out the fields
253 
254        int words = (con_size_in_bytes - hdr_size_in_bytes) / BytesPerWord;
255        mov(index,  words / 8);
256 
257        const int unroll = 8; // Number of str(zr) instructions we&#39;ll unroll
258        int remainder = words % unroll;
259        lea(rscratch1, Address(obj, hdr_size_in_bytes + remainder * BytesPerWord));
260 
261        Label entry_point, loop;
262        b(entry_point);
263 
264        bind(loop);
265        sub(index, index, 1);
266        for (int i = -unroll; i &lt; 0; i++) {
267          if (-i == remainder)
268            bind(entry_point);
269          str(zr, Address(rscratch1, i * wordSize));
270        }
271        if (remainder == 0)
272          bind(entry_point);
273        add(rscratch1, rscratch1, unroll * wordSize);
274        cbnz(index, loop);
275 
276      }
277   }
278 
279   membar(StoreStore);
280 
281   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
282     assert(obj == r0, &quot;must be&quot;);
283     far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));
284   }
285 
286   verify_oop(obj);
287 }
288 void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, int f, Register klass, Label&amp; slow_case) {
289   assert_different_registers(obj, len, t1, t2, klass);
290 
291   // determine alignment mask
292   assert(!(BytesPerWord &amp; 1), &quot;must be a multiple of 2 for masking code to work&quot;);
293 
294   // check for negative or excessive length
295   mov(rscratch1, (int32_t)max_array_allocation_length);
296   cmp(len, rscratch1);
297   br(Assembler::HS, slow_case);
298 
299   const Register arr_size = t2; // okay to be the same
300   // align object end
301   mov(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);
302   add(arr_size, arr_size, len, ext::uxtw, f);
303   andr(arr_size, arr_size, ~MinObjAlignmentInBytesMask);
304 
305   try_allocate(obj, arr_size, 0, t1, t2, slow_case);
306 
307   initialize_header(obj, klass, len, t1, t2);
308 
309   // clear rest of allocated space
310   const Register len_zero = len;
311   initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);
312 
313   membar(StoreStore);
314 
315   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
316     assert(obj == r0, &quot;must be&quot;);
317     far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));
318   }
319 
320   verify_oop(obj);
321 }
322 
323 
324 void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
325   verify_oop(receiver);
326   // explicit NULL check not needed since load from [klass_offset] causes a trap
327   // check against inline cache
328   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), &quot;must add explicit null check&quot;);
329 
330   cmp_klass(receiver, iCache, rscratch1);
331 }
332 
333 
334 void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {
335   assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
336   // Make sure there is enough stack space for this method&#39;s activation.
337   // Note that we do this before doing an enter().
338   generate_stack_overflow_check(bang_size_in_bytes);
339   MacroAssembler::build_frame(framesize + 2 * wordSize);
<a name="2" id="anc2"></a><span class="line-added">340 </span>
<span class="line-added">341   // Insert nmethod entry barrier into frame.</span>
<span class="line-added">342   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added">343   bs-&gt;nmethod_entry_barrier(this);</span>
344 }
345 
346 void C1_MacroAssembler::remove_frame(int framesize) {
347   MacroAssembler::remove_frame(framesize + 2 * wordSize);
348 }
349 
350 
351 void C1_MacroAssembler::verified_entry() {
352   // If we have to make this method not-entrant we&#39;ll overwrite its
353   // first instruction with a jump.  For this action to be legal we
354   // must ensure that this first instruction is a B, BL, NOP, BKPT,
355   // SVC, HVC, or SMC.  Make it a NOP.
356   nop();
357 }
358 
359 void C1_MacroAssembler::load_parameter(int offset_in_words, Register reg) {
360   // rbp, + 0: link
361   //     + 1: return address
362   //     + 2: argument with offset 0
363   //     + 3: argument with offset 1
364   //     + 4: ...
365 
366   ldr(reg, Address(rfp, (offset_in_words + 2) * BytesPerWord));
367 }
368 
369 #ifndef PRODUCT
370 
371 void C1_MacroAssembler::verify_stack_oop(int stack_offset) {
372   if (!VerifyOops) return;
373   verify_oop_addr(Address(sp, stack_offset), &quot;oop&quot;);
374 }
375 
376 void C1_MacroAssembler::verify_not_null_oop(Register r) {
377   if (!VerifyOops) return;
378   Label not_null;
379   cbnz(r, not_null);
380   stop(&quot;non-null oop required&quot;);
381   bind(not_null);
382   verify_oop(r);
383 }
384 
385 void C1_MacroAssembler::invalidate_registers(bool inv_r0, bool inv_r19, bool inv_r2, bool inv_r3, bool inv_r4, bool inv_r5) {
386 #ifdef ASSERT
387   static int nn;
388   if (inv_r0) mov(r0, 0xDEAD);
389   if (inv_r19) mov(r19, 0xDEAD);
390   if (inv_r2) mov(r2, nn++);
391   if (inv_r3) mov(r3, 0xDEAD);
392   if (inv_r4) mov(r4, 0xDEAD);
393   if (inv_r5) mov(r5, 0xDEAD);
394 #endif
395 }
396 #endif // ifndef PRODUCT
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/solaris/os_solaris.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../linux/os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/classfile/classLoaderData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/solaris/os_solaris.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1408     // file i/o error - report dlerror() msg
1409     return NULL;
1410   }
1411 
1412   if (elf_head.e_ident[EI_DATA] != LITTLE_ENDIAN_ONLY(ELFDATA2LSB) BIG_ENDIAN_ONLY(ELFDATA2MSB)) {
1413     // handle invalid/out of range endianness values
1414     if (elf_head.e_ident[EI_DATA] == 0 || elf_head.e_ident[EI_DATA] &gt; 2) {
1415       return NULL;
1416     }
1417     change_endianness(elf_head.e_machine);
1418   }
1419 
1420   typedef struct {
1421     Elf32_Half    code;         // Actual value as defined in elf.h
1422     Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
1423     unsigned char elf_class;    // 32 or 64 bit
1424     unsigned char endianess;    // MSB or LSB
1425     char*         name;         // String representation
1426   } arch_t;
1427 
<span class="line-removed">1428 #ifndef EM_AARCH64</span>
<span class="line-removed">1429   #define EM_AARCH64    183               /* ARM AARCH64 */</span>
<span class="line-removed">1430 #endif</span>
<span class="line-removed">1431 </span>
1432   static const arch_t arch_array[]={
1433     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1434     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1435     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1436     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1437     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1438     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1439     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1440     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1441     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
1442     {EM_ARM,         EM_ARM,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;ARM&quot;},
1443     // we only support 64 bit z architecture
1444     {EM_S390,        EM_S390,    ELFCLASS64, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},
1445     {EM_AARCH64,     EM_AARCH64, ELFCLASS64, ELFDATA2LSB, (char*)&quot;AARCH64&quot;}
1446   };
1447 
1448 #if  (defined IA32)
1449   static  Elf32_Half running_arch_code=EM_386;
1450 #elif   (defined AMD64)
1451   static  Elf32_Half running_arch_code=EM_X86_64;
</pre>
</td>
<td>
<hr />
<pre>
1408     // file i/o error - report dlerror() msg
1409     return NULL;
1410   }
1411 
1412   if (elf_head.e_ident[EI_DATA] != LITTLE_ENDIAN_ONLY(ELFDATA2LSB) BIG_ENDIAN_ONLY(ELFDATA2MSB)) {
1413     // handle invalid/out of range endianness values
1414     if (elf_head.e_ident[EI_DATA] == 0 || elf_head.e_ident[EI_DATA] &gt; 2) {
1415       return NULL;
1416     }
1417     change_endianness(elf_head.e_machine);
1418   }
1419 
1420   typedef struct {
1421     Elf32_Half    code;         // Actual value as defined in elf.h
1422     Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
1423     unsigned char elf_class;    // 32 or 64 bit
1424     unsigned char endianess;    // MSB or LSB
1425     char*         name;         // String representation
1426   } arch_t;
1427 




1428   static const arch_t arch_array[]={
1429     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1430     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1431     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1432     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1433     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1434     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1435     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1436     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1437     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
1438     {EM_ARM,         EM_ARM,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;ARM&quot;},
1439     // we only support 64 bit z architecture
1440     {EM_S390,        EM_S390,    ELFCLASS64, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},
1441     {EM_AARCH64,     EM_AARCH64, ELFCLASS64, ELFDATA2LSB, (char*)&quot;AARCH64&quot;}
1442   };
1443 
1444 #if  (defined IA32)
1445   static  Elf32_Half running_arch_code=EM_386;
1446 #elif   (defined AMD64)
1447   static  Elf32_Half running_arch_code=EM_X86_64;
</pre>
</td>
</tr>
</table>
<center><a href="../linux/os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/classfile/classLoaderData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
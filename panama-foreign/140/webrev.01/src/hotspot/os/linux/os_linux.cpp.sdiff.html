<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/ppc/vm_version_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../solaris/os_solaris.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
  98 # include &lt;sys/socket.h&gt;
  99 # include &lt;sys/wait.h&gt;
 100 # include &lt;pwd.h&gt;
 101 # include &lt;poll.h&gt;
 102 # include &lt;fcntl.h&gt;
 103 # include &lt;string.h&gt;
 104 # include &lt;syscall.h&gt;
 105 # include &lt;sys/sysinfo.h&gt;
 106 # include &lt;gnu/libc-version.h&gt;
 107 # include &lt;sys/ipc.h&gt;
 108 # include &lt;sys/shm.h&gt;
 109 # include &lt;link.h&gt;
 110 # include &lt;stdint.h&gt;
 111 # include &lt;inttypes.h&gt;
 112 # include &lt;sys/ioctl.h&gt;

 113 
 114 #ifndef _GNU_SOURCE
 115   #define _GNU_SOURCE
 116   #include &lt;sched.h&gt;
 117   #undef _GNU_SOURCE
 118 #else
 119   #include &lt;sched.h&gt;
 120 #endif
 121 
 122 // if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
 123 // getrusage() is prepared to handle the associated failure.
 124 #ifndef RUSAGE_THREAD
 125   #define RUSAGE_THREAD   (1)               /* only the calling thread */
 126 #endif
 127 
 128 #define MAX_PATH    (2 * K)
 129 
 130 #define MAX_SECS 100000000
 131 
 132 // for timer info max values which include all bits
</pre>
<hr />
<pre>
1828       return NULL;
1829     }
1830 
1831 #if defined(VM_LITTLE_ENDIAN)
1832     // VM is LE, shared object BE
1833     elf_head.e_machine = be16toh(elf_head.e_machine);
1834 #else
1835     // VM is BE, shared object LE
1836     elf_head.e_machine = le16toh(elf_head.e_machine);
1837 #endif
1838   }
1839 
1840   typedef struct {
1841     Elf32_Half    code;         // Actual value as defined in elf.h
1842     Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
1843     unsigned char elf_class;    // 32 or 64 bit
1844     unsigned char endianness;   // MSB or LSB
1845     char*         name;         // String representation
1846   } arch_t;
1847 
<span class="line-removed">1848 #ifndef EM_486</span>
<span class="line-removed">1849   #define EM_486          6               /* Intel 80486 */</span>
<span class="line-removed">1850 #endif</span>
1851 #ifndef EM_AARCH64
1852   #define EM_AARCH64    183               /* ARM AARCH64 */
1853 #endif
1854 #ifndef EM_RISCV
1855   #define EM_RISCV      243               /* RISC-V */
1856 #endif
1857 
1858   static const arch_t arch_array[]={
1859     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1860     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1861     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1862     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1863     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1864     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1865     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1866     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1867 #if defined(VM_LITTLE_ENDIAN)
1868     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Power PC 64 LE&quot;},
1869     {EM_SH,          EM_SH,      ELFCLASS32, ELFDATA2LSB, (char*)&quot;SuperH&quot;},
1870 #else
</pre>
<hr />
<pre>
2044   if (fd == -1) {
2045     return false;
2046   }
2047 
2048   if (hdr != NULL) {
2049     st-&gt;print_cr(&quot;%s&quot;, hdr);
2050   }
2051 
2052   char buf[33];
2053   int bytes;
2054   buf[32] = &#39;\0&#39;;
2055   while ((bytes = ::read(fd, buf, sizeof(buf)-1)) &gt; 0) {
2056     st-&gt;print_raw(buf, bytes);
2057   }
2058 
2059   ::close(fd);
2060 
2061   return true;
2062 }
2063 







2064 void os::print_dll_info(outputStream *st) {
2065   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
2066 
2067   char fname[32];
2068   pid_t pid = os::Linux::gettid();
2069 
2070   jio_snprintf(fname, sizeof(fname), &quot;/proc/%d/maps&quot;, pid);
2071 
2072   if (!_print_ascii_file(fname, st)) {
2073     st-&gt;print(&quot;Can not get library information for pid = %d\n&quot;, pid);
2074   }
2075 }
2076 
2077 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
2078   FILE *procmapsFile = NULL;
2079 
2080   // Open the procfs maps file for the current process
2081   if ((procmapsFile = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;)) != NULL) {
2082     // Allocate PATH_MAX for file name plus a reasonable size for other fields.
2083     char line[PATH_MAX + 100];
</pre>
<hr />
<pre>
2486           } else {
2487             // model name printed but not flags?  Odd, just return
2488             fclose(fp);
2489             return true;
2490           }
2491         }
2492         // print the flags line too
2493         if (strstr(buf, &quot;flags&quot;) != NULL) {
2494           st-&gt;print_raw(buf);
2495           fclose(fp);
2496           return true;
2497         }
2498       }
2499     }
2500     fclose(fp);
2501   }
2502 #endif // x86 platforms
2503   return false;
2504 }
2505 
















































2506 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
2507   // Only print the model name if the platform provides this as a summary
2508   if (!print_model_name_and_flags(st, buf, buflen)) {
2509     st-&gt;print(&quot;\n/proc/cpuinfo:\n&quot;);
2510     if (!_print_ascii_file(&quot;/proc/cpuinfo&quot;, st)) {
2511       st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);
2512     }
2513   }

2514 }
2515 
2516 #if defined(AMD64) || defined(IA32) || defined(X32)
2517 const char* search_string = &quot;model name&quot;;
2518 #elif defined(M68K)
2519 const char* search_string = &quot;CPU&quot;;
2520 #elif defined(PPC64)
2521 const char* search_string = &quot;cpu&quot;;
2522 #elif defined(S390)
2523 const char* search_string = &quot;machine =&quot;;
2524 #elif defined(SPARC)
2525 const char* search_string = &quot;cpu&quot;;
2526 #else
2527 const char* search_string = &quot;Processor&quot;;
2528 #endif
2529 
2530 // Parses the cpuinfo file for string representing the model name.
2531 void os::get_summary_cpu_info(char* cpuinfo, size_t length) {
2532   FILE* fp = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);
2533   if (fp != NULL) {
</pre>
</td>
<td>
<hr />
<pre>
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
  98 # include &lt;sys/socket.h&gt;
  99 # include &lt;sys/wait.h&gt;
 100 # include &lt;pwd.h&gt;
 101 # include &lt;poll.h&gt;
 102 # include &lt;fcntl.h&gt;
 103 # include &lt;string.h&gt;
 104 # include &lt;syscall.h&gt;
 105 # include &lt;sys/sysinfo.h&gt;
 106 # include &lt;gnu/libc-version.h&gt;
 107 # include &lt;sys/ipc.h&gt;
 108 # include &lt;sys/shm.h&gt;
 109 # include &lt;link.h&gt;
 110 # include &lt;stdint.h&gt;
 111 # include &lt;inttypes.h&gt;
 112 # include &lt;sys/ioctl.h&gt;
<span class="line-added"> 113 # include &lt;linux/elf-em.h&gt;</span>
 114 
 115 #ifndef _GNU_SOURCE
 116   #define _GNU_SOURCE
 117   #include &lt;sched.h&gt;
 118   #undef _GNU_SOURCE
 119 #else
 120   #include &lt;sched.h&gt;
 121 #endif
 122 
 123 // if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
 124 // getrusage() is prepared to handle the associated failure.
 125 #ifndef RUSAGE_THREAD
 126   #define RUSAGE_THREAD   (1)               /* only the calling thread */
 127 #endif
 128 
 129 #define MAX_PATH    (2 * K)
 130 
 131 #define MAX_SECS 100000000
 132 
 133 // for timer info max values which include all bits
</pre>
<hr />
<pre>
1829       return NULL;
1830     }
1831 
1832 #if defined(VM_LITTLE_ENDIAN)
1833     // VM is LE, shared object BE
1834     elf_head.e_machine = be16toh(elf_head.e_machine);
1835 #else
1836     // VM is BE, shared object LE
1837     elf_head.e_machine = le16toh(elf_head.e_machine);
1838 #endif
1839   }
1840 
1841   typedef struct {
1842     Elf32_Half    code;         // Actual value as defined in elf.h
1843     Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
1844     unsigned char elf_class;    // 32 or 64 bit
1845     unsigned char endianness;   // MSB or LSB
1846     char*         name;         // String representation
1847   } arch_t;
1848 



1849 #ifndef EM_AARCH64
1850   #define EM_AARCH64    183               /* ARM AARCH64 */
1851 #endif
1852 #ifndef EM_RISCV
1853   #define EM_RISCV      243               /* RISC-V */
1854 #endif
1855 
1856   static const arch_t arch_array[]={
1857     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1858     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1859     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1860     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1861     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1862     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1863     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1864     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1865 #if defined(VM_LITTLE_ENDIAN)
1866     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Power PC 64 LE&quot;},
1867     {EM_SH,          EM_SH,      ELFCLASS32, ELFDATA2LSB, (char*)&quot;SuperH&quot;},
1868 #else
</pre>
<hr />
<pre>
2042   if (fd == -1) {
2043     return false;
2044   }
2045 
2046   if (hdr != NULL) {
2047     st-&gt;print_cr(&quot;%s&quot;, hdr);
2048   }
2049 
2050   char buf[33];
2051   int bytes;
2052   buf[32] = &#39;\0&#39;;
2053   while ((bytes = ::read(fd, buf, sizeof(buf)-1)) &gt; 0) {
2054     st-&gt;print_raw(buf, bytes);
2055   }
2056 
2057   ::close(fd);
2058 
2059   return true;
2060 }
2061 
<span class="line-added">2062 static void _print_ascii_file_h(const char* header, const char* filename, outputStream* st) {</span>
<span class="line-added">2063   st-&gt;print(&quot;%s&quot;, header);</span>
<span class="line-added">2064   if (!_print_ascii_file(filename, st)) {</span>
<span class="line-added">2065     st-&gt;print_cr(&quot;&lt;Not Available&gt;&quot;);</span>
<span class="line-added">2066   }</span>
<span class="line-added">2067 }</span>
<span class="line-added">2068 </span>
2069 void os::print_dll_info(outputStream *st) {
2070   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
2071 
2072   char fname[32];
2073   pid_t pid = os::Linux::gettid();
2074 
2075   jio_snprintf(fname, sizeof(fname), &quot;/proc/%d/maps&quot;, pid);
2076 
2077   if (!_print_ascii_file(fname, st)) {
2078     st-&gt;print(&quot;Can not get library information for pid = %d\n&quot;, pid);
2079   }
2080 }
2081 
2082 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
2083   FILE *procmapsFile = NULL;
2084 
2085   // Open the procfs maps file for the current process
2086   if ((procmapsFile = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;)) != NULL) {
2087     // Allocate PATH_MAX for file name plus a reasonable size for other fields.
2088     char line[PATH_MAX + 100];
</pre>
<hr />
<pre>
2491           } else {
2492             // model name printed but not flags?  Odd, just return
2493             fclose(fp);
2494             return true;
2495           }
2496         }
2497         // print the flags line too
2498         if (strstr(buf, &quot;flags&quot;) != NULL) {
2499           st-&gt;print_raw(buf);
2500           fclose(fp);
2501           return true;
2502         }
2503       }
2504     }
2505     fclose(fp);
2506   }
2507 #endif // x86 platforms
2508   return false;
2509 }
2510 
<span class="line-added">2511 // additional information about CPU e.g. available frequency ranges</span>
<span class="line-added">2512 static void print_sys_devices_cpu_info(outputStream* st, char* buf, size_t buflen) {</span>
<span class="line-added">2513   _print_ascii_file_h(&quot;Online cpus:&quot;, &quot;/sys/devices/system/cpu/online&quot;, st);</span>
<span class="line-added">2514   _print_ascii_file_h(&quot;Offline cpus:&quot;, &quot;/sys/devices/system/cpu/offline&quot;, st);</span>
<span class="line-added">2515 </span>
<span class="line-added">2516   if (ExtensiveErrorReports) {</span>
<span class="line-added">2517     // cache related info (cpu 0, should be similar for other CPUs)</span>
<span class="line-added">2518     for (unsigned int i=0; i &lt; 10; i++) { // handle max. 10 cache entries</span>
<span class="line-added">2519       char hbuf_level[60];</span>
<span class="line-added">2520       char hbuf_type[60];</span>
<span class="line-added">2521       char hbuf_size[60];</span>
<span class="line-added">2522       char hbuf_coherency_line_size[80];</span>
<span class="line-added">2523       snprintf(hbuf_level, 60, &quot;/sys/devices/system/cpu/cpu0/cache/index%u/level&quot;, i);</span>
<span class="line-added">2524       snprintf(hbuf_type, 60, &quot;/sys/devices/system/cpu/cpu0/cache/index%u/type&quot;, i);</span>
<span class="line-added">2525       snprintf(hbuf_size, 60, &quot;/sys/devices/system/cpu/cpu0/cache/index%u/size&quot;, i);</span>
<span class="line-added">2526       snprintf(hbuf_coherency_line_size, 80, &quot;/sys/devices/system/cpu/cpu0/cache/index%u/coherency_line_size&quot;, i);</span>
<span class="line-added">2527       if (file_exists(hbuf_level)) {</span>
<span class="line-added">2528         _print_ascii_file_h(&quot;cache level:&quot;, hbuf_level, st);</span>
<span class="line-added">2529         _print_ascii_file_h(&quot;cache type:&quot;, hbuf_type, st);</span>
<span class="line-added">2530         _print_ascii_file_h(&quot;cache size:&quot;, hbuf_size, st);</span>
<span class="line-added">2531         _print_ascii_file_h(&quot;cache coherency line size:&quot;, hbuf_coherency_line_size, st);</span>
<span class="line-added">2532       }</span>
<span class="line-added">2533     }</span>
<span class="line-added">2534   }</span>
<span class="line-added">2535 </span>
<span class="line-added">2536   // we miss the cpufreq entries on Power and s390x</span>
<span class="line-added">2537 #if defined(IA32) || defined(AMD64)</span>
<span class="line-added">2538   _print_ascii_file_h(&quot;BIOS frequency limitation:&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/bios_limit&quot;, st);</span>
<span class="line-added">2539   _print_ascii_file_h(&quot;Frequency switch latency (ns):&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_transition_latency&quot;, st);</span>
<span class="line-added">2540   _print_ascii_file_h(&quot;Available cpu frequencies:&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies&quot;, st);</span>
<span class="line-added">2541   // min and max should be in the Available range but still print them (not all info might be available for all kernels)</span>
<span class="line-added">2542   if (ExtensiveErrorReports) {</span>
<span class="line-added">2543     _print_ascii_file_h(&quot;Maximum cpu frequency:&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq&quot;, st);</span>
<span class="line-added">2544     _print_ascii_file_h(&quot;Minimum cpu frequency:&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq&quot;, st);</span>
<span class="line-added">2545     _print_ascii_file_h(&quot;Current cpu frequency:&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq&quot;, st);</span>
<span class="line-added">2546   }</span>
<span class="line-added">2547   // governors are power schemes, see https://wiki.archlinux.org/index.php/CPU_frequency_scaling</span>
<span class="line-added">2548   if (ExtensiveErrorReports) {</span>
<span class="line-added">2549     _print_ascii_file_h(&quot;Available governors:&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors&quot;, st);</span>
<span class="line-added">2550   }</span>
<span class="line-added">2551   _print_ascii_file_h(&quot;Current governor:&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&quot;, st);</span>
<span class="line-added">2552   // Core performance boost, see https://www.kernel.org/doc/Documentation/cpu-freq/boost.txt</span>
<span class="line-added">2553   // Raise operating frequency of some cores in a multi-core package if certain conditions apply, e.g.</span>
<span class="line-added">2554   // whole chip is not fully utilized</span>
<span class="line-added">2555   _print_ascii_file_h(&quot;Core performance/turbo boost:&quot;, &quot;/sys/devices/system/cpu/cpufreq/boost&quot;, st);</span>
<span class="line-added">2556 #endif</span>
<span class="line-added">2557 }</span>
<span class="line-added">2558 </span>
2559 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
2560   // Only print the model name if the platform provides this as a summary
2561   if (!print_model_name_and_flags(st, buf, buflen)) {
2562     st-&gt;print(&quot;\n/proc/cpuinfo:\n&quot;);
2563     if (!_print_ascii_file(&quot;/proc/cpuinfo&quot;, st)) {
2564       st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);
2565     }
2566   }
<span class="line-added">2567   print_sys_devices_cpu_info(st, buf, buflen);</span>
2568 }
2569 
2570 #if defined(AMD64) || defined(IA32) || defined(X32)
2571 const char* search_string = &quot;model name&quot;;
2572 #elif defined(M68K)
2573 const char* search_string = &quot;CPU&quot;;
2574 #elif defined(PPC64)
2575 const char* search_string = &quot;cpu&quot;;
2576 #elif defined(S390)
2577 const char* search_string = &quot;machine =&quot;;
2578 #elif defined(SPARC)
2579 const char* search_string = &quot;cpu&quot;;
2580 #else
2581 const char* search_string = &quot;Processor&quot;;
2582 #endif
2583 
2584 // Parses the cpuinfo file for string representing the model name.
2585 void os::get_summary_cpu_info(char* cpuinfo, size_t length) {
2586   FILE* fp = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);
2587   if (fp != NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/ppc/vm_version_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../solaris/os_solaris.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
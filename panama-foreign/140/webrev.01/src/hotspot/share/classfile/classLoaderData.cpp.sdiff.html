<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../os/solaris/os_solaris.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderHierarchyDCmd.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
623 
624   return alive;
625 }
626 
627 class ReleaseKlassClosure: public KlassClosure {
628 private:
629   size_t  _instance_class_released;
630   size_t  _array_class_released;
631 public:
632   ReleaseKlassClosure() : _instance_class_released(0), _array_class_released(0) { }
633 
634   size_t instance_class_released() const { return _instance_class_released; }
635   size_t array_class_released()    const { return _array_class_released;    }
636 
637   void do_klass(Klass* k) {
638     if (k-&gt;is_array_klass()) {
639       _array_class_released ++;
640     } else {
641       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
642       _instance_class_released ++;
<span class="line-removed">643       InstanceKlass::release_C_heap_structures(InstanceKlass::cast(k));</span>
644     }

645   }
646 };
647 
648 ClassLoaderData::~ClassLoaderData() {
649   // Release C heap structures for all the classes.
650   ReleaseKlassClosure cl;
651   classes_do(&amp;cl);
652 
653   ClassLoaderDataGraph::dec_array_classes(cl.array_class_released());
654   ClassLoaderDataGraph::dec_instance_classes(cl.instance_class_released());
655 
656   // Release the WeakHandle
657   _holder.release();
658 
659   // Release C heap allocated hashtable for all the packages.
660   if (_packages != NULL) {
661     // Destroy the table itself
662     delete _packages;
663     _packages = NULL;
664   }
</pre>
<hr />
<pre>
852 // This is distinct from free_deallocate_list.  For class loader data that are
853 // unloading, this frees the C heap memory for items on the list, and unlinks
854 // scratch or error classes so that unloading events aren&#39;t triggered for these
855 // classes. The metadata is removed with the unloading metaspace.
856 // There isn&#39;t C heap memory allocated for methods, so nothing is done for them.
857 void ClassLoaderData::free_deallocate_list_C_heap_structures() {
858   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
859   assert(is_unloading(), &quot;only called for ClassLoaderData that are unloading&quot;);
860   if (_deallocate_list == NULL) {
861     return;
862   }
863   // Go backwards because this removes entries that are freed.
864   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
865     Metadata* m = _deallocate_list-&gt;at(i);
866     _deallocate_list-&gt;remove_at(i);
867     if (m-&gt;is_constantPool()) {
868       ((ConstantPool*)m)-&gt;release_C_heap_structures();
869     } else if (m-&gt;is_klass()) {
870       InstanceKlass* ik = (InstanceKlass*)m;
871       // also releases ik-&gt;constants() C heap memory
<span class="line-modified">872       InstanceKlass::release_C_heap_structures(ik);</span>
873       // Remove the class so unloading events aren&#39;t triggered for
874       // this class (scratch or error class) in do_unloading().
875       remove_class(ik);
876     }
877   }
878 }
879 
880 // These CLDs are to contain non-strong hidden classes or unsafe anonymous classes used for JSR292
881 ClassLoaderData* ClassLoaderData::has_class_mirror_holder_cld(Handle loader) {
882   // Add a new class loader data to the graph.
883   return ClassLoaderDataGraph::add(loader, true);
884 }
885 
886 // Caller needs ResourceMark
887 // If the class loader&#39;s _name has not been explicitly set, the class loader&#39;s
888 // qualified class name is returned.
889 const char* ClassLoaderData::loader_name() const {
890    if (_class_loader_klass == NULL) {
891      return BOOTSTRAP_LOADER_NAME;
892    } else if (_name != NULL) {
</pre>
</td>
<td>
<hr />
<pre>
623 
624   return alive;
625 }
626 
627 class ReleaseKlassClosure: public KlassClosure {
628 private:
629   size_t  _instance_class_released;
630   size_t  _array_class_released;
631 public:
632   ReleaseKlassClosure() : _instance_class_released(0), _array_class_released(0) { }
633 
634   size_t instance_class_released() const { return _instance_class_released; }
635   size_t array_class_released()    const { return _array_class_released;    }
636 
637   void do_klass(Klass* k) {
638     if (k-&gt;is_array_klass()) {
639       _array_class_released ++;
640     } else {
641       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
642       _instance_class_released ++;

643     }
<span class="line-added">644     k-&gt;release_C_heap_structures();</span>
645   }
646 };
647 
648 ClassLoaderData::~ClassLoaderData() {
649   // Release C heap structures for all the classes.
650   ReleaseKlassClosure cl;
651   classes_do(&amp;cl);
652 
653   ClassLoaderDataGraph::dec_array_classes(cl.array_class_released());
654   ClassLoaderDataGraph::dec_instance_classes(cl.instance_class_released());
655 
656   // Release the WeakHandle
657   _holder.release();
658 
659   // Release C heap allocated hashtable for all the packages.
660   if (_packages != NULL) {
661     // Destroy the table itself
662     delete _packages;
663     _packages = NULL;
664   }
</pre>
<hr />
<pre>
852 // This is distinct from free_deallocate_list.  For class loader data that are
853 // unloading, this frees the C heap memory for items on the list, and unlinks
854 // scratch or error classes so that unloading events aren&#39;t triggered for these
855 // classes. The metadata is removed with the unloading metaspace.
856 // There isn&#39;t C heap memory allocated for methods, so nothing is done for them.
857 void ClassLoaderData::free_deallocate_list_C_heap_structures() {
858   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
859   assert(is_unloading(), &quot;only called for ClassLoaderData that are unloading&quot;);
860   if (_deallocate_list == NULL) {
861     return;
862   }
863   // Go backwards because this removes entries that are freed.
864   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
865     Metadata* m = _deallocate_list-&gt;at(i);
866     _deallocate_list-&gt;remove_at(i);
867     if (m-&gt;is_constantPool()) {
868       ((ConstantPool*)m)-&gt;release_C_heap_structures();
869     } else if (m-&gt;is_klass()) {
870       InstanceKlass* ik = (InstanceKlass*)m;
871       // also releases ik-&gt;constants() C heap memory
<span class="line-modified">872       ik-&gt;release_C_heap_structures();</span>
873       // Remove the class so unloading events aren&#39;t triggered for
874       // this class (scratch or error class) in do_unloading().
875       remove_class(ik);
876     }
877   }
878 }
879 
880 // These CLDs are to contain non-strong hidden classes or unsafe anonymous classes used for JSR292
881 ClassLoaderData* ClassLoaderData::has_class_mirror_holder_cld(Handle loader) {
882   // Add a new class loader data to the graph.
883   return ClassLoaderDataGraph::add(loader, true);
884 }
885 
886 // Caller needs ResourceMark
887 // If the class loader&#39;s _name has not been explicitly set, the class loader&#39;s
888 // qualified class name is returned.
889 const char* ClassLoaderData::loader_name() const {
890    if (_class_loader_klass == NULL) {
891      return BOOTSTRAP_LOADER_NAME;
892    } else if (_name != NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="../../os/solaris/os_solaris.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderHierarchyDCmd.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
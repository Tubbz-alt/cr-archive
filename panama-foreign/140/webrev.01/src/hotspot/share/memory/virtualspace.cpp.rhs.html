<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/virtualspace.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;logging/log.hpp&quot;
  27 #include &quot;memory/resourceArea.hpp&quot;
  28 #include &quot;memory/virtualspace.hpp&quot;
  29 #include &quot;oops/compressedOops.hpp&quot;
  30 #include &quot;oops/markWord.hpp&quot;
  31 #include &quot;oops/oop.inline.hpp&quot;
  32 #include &quot;runtime/os.inline.hpp&quot;
  33 #include &quot;services/memTracker.hpp&quot;
  34 #include &quot;utilities/align.hpp&quot;
  35 #include &quot;utilities/powerOfTwo.hpp&quot;
  36 
  37 // ReservedSpace
  38 
  39 // Dummy constructor
  40 ReservedSpace::ReservedSpace() : _base(NULL), _size(0), _noaccess_prefix(0),
  41     _alignment(0), _special(false), _fd_for_heap(-1), _executable(false) {
  42 }
  43 
  44 ReservedSpace::ReservedSpace(size_t size, size_t preferred_page_size) : _fd_for_heap(-1) {
  45   bool has_preferred_page_size = preferred_page_size != 0;
  46   // Want to use large pages where possible and pad with small pages.
  47   size_t page_size = has_preferred_page_size ? preferred_page_size : os::page_size_for_region_unaligned(size, 1);
  48   bool large_pages = page_size != (size_t)os::vm_page_size();
  49   size_t alignment;
  50   if (large_pages &amp;&amp; has_preferred_page_size) {
  51     alignment = MAX2(page_size, (size_t)os::vm_allocation_granularity());
  52     // ReservedSpace initialization requires size to be aligned to the given
  53     // alignment. Align the size up.
  54     size = align_up(size, alignment);
  55   } else {
  56     // Don&#39;t force the alignment to be large page aligned,
  57     // since that will waste memory.
  58     alignment = os::vm_allocation_granularity();
  59   }
  60   initialize(size, alignment, large_pages, NULL, false);
  61 }
  62 
  63 ReservedSpace::ReservedSpace(size_t size, size_t alignment,
  64                              bool large,
  65                              char* requested_address) : _fd_for_heap(-1) {
  66   initialize(size, alignment, large, requested_address, false);
  67 }
  68 
<a name="2" id="anc2"></a>





  69 ReservedSpace::ReservedSpace(char* base, size_t size, size_t alignment,
  70                              bool special, bool executable) : _fd_for_heap(-1) {
  71   assert((size % os::vm_allocation_granularity()) == 0,
  72          &quot;size not allocation aligned&quot;);
  73   _base = base;
  74   _size = size;
  75   _alignment = alignment;
  76   _noaccess_prefix = 0;
  77   _special = special;
  78   _executable = executable;
  79 }
  80 
  81 // Helper method
  82 static void unmap_or_release_memory(char* base, size_t size, bool is_file_mapped) {
  83   if (is_file_mapped) {
  84     if (!os::unmap_memory(base, size)) {
  85       fatal(&quot;os::unmap_memory failed&quot;);
  86     }
  87   } else if (!os::release_memory(base, size)) {
  88     fatal(&quot;os::release_memory failed&quot;);
  89   }
  90 }
  91 
  92 // Helper method.
  93 static bool failed_to_reserve_as_requested(char* base, char* requested_address,
  94                                            const size_t size, bool special, bool is_file_mapped = false)
  95 {
  96   if (base == requested_address || requested_address == NULL)
  97     return false; // did not fail
  98 
  99   if (base != NULL) {
 100     // Different reserve address may be acceptable in other cases
 101     // but for compressed oops heap should be at requested address.
 102     assert(UseCompressedOops, &quot;currently requested address used only for compressed oops&quot;);
 103     log_debug(gc, heap, coops)(&quot;Reserved memory not at requested address: &quot; PTR_FORMAT &quot; vs &quot; PTR_FORMAT, p2i(base), p2i(requested_address));
 104     // OS ignored requested address. Try different address.
 105     if (special) {
 106       if (!os::release_memory_special(base, size)) {
 107         fatal(&quot;os::release_memory_special failed&quot;);
 108       }
 109     } else {
 110       unmap_or_release_memory(base, size, is_file_mapped);
 111     }
 112   }
 113   return true;
 114 }
 115 
 116 void ReservedSpace::initialize(size_t size, size_t alignment, bool large,
 117                                char* requested_address,
 118                                bool executable) {
 119   const size_t granularity = os::vm_allocation_granularity();
 120   assert((size &amp; (granularity - 1)) == 0,
 121          &quot;size not aligned to os::vm_allocation_granularity()&quot;);
 122   assert((alignment &amp; (granularity - 1)) == 0,
 123          &quot;alignment not aligned to os::vm_allocation_granularity()&quot;);
 124   assert(alignment == 0 || is_power_of_2((intptr_t)alignment),
 125          &quot;not a power of 2&quot;);
 126 
 127   alignment = MAX2(alignment, (size_t)os::vm_page_size());
 128 
 129   _base = NULL;
 130   _size = 0;
 131   _special = false;
 132   _executable = executable;
 133   _alignment = 0;
 134   _noaccess_prefix = 0;
 135   if (size == 0) {
 136     return;
 137   }
 138 
 139   // If OS doesn&#39;t support demand paging for large page memory, we need
 140   // to use reserve_memory_special() to reserve and pin the entire region.
 141   // If there is a backing file directory for this space then whether
 142   // large pages are allocated is up to the filesystem of the backing file.
 143   // So we ignore the UseLargePages flag in this case.
 144   bool special = large &amp;&amp; !os::can_commit_large_page_memory();
 145   if (special &amp;&amp; _fd_for_heap != -1) {
 146     special = false;
 147     if (UseLargePages &amp;&amp; (!FLAG_IS_DEFAULT(UseLargePages) ||
 148       !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {
 149       log_debug(gc, heap)(&quot;Ignoring UseLargePages since large page support is up to the file system of the backing file for Java heap&quot;);
 150     }
 151   }
 152 
 153   char* base = NULL;
 154 
 155   if (special) {
 156 
 157     base = os::reserve_memory_special(size, alignment, requested_address, executable);
 158 
 159     if (base != NULL) {
 160       if (failed_to_reserve_as_requested(base, requested_address, size, true)) {
 161         // OS ignored requested address. Try different address.
 162         return;
 163       }
 164       // Check alignment constraints.
 165       assert((uintptr_t) base % alignment == 0,
 166              &quot;Large pages returned a non-aligned address, base: &quot;
 167              PTR_FORMAT &quot; alignment: &quot; SIZE_FORMAT_HEX,
 168              p2i(base), alignment);
 169       _special = true;
 170     } else {
 171       // failed; try to reserve regular memory below
 172       if (UseLargePages &amp;&amp; (!FLAG_IS_DEFAULT(UseLargePages) ||
 173                             !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {
 174         log_debug(gc, heap, coops)(&quot;Reserve regular memory without large pages&quot;);
 175       }
 176     }
 177   }
 178 
 179   if (base == NULL) {
 180     // Optimistically assume that the OSes returns an aligned base pointer.
 181     // When reserving a large address range, most OSes seem to align to at
 182     // least 64K.
 183 
 184     // If the memory was requested at a particular address, use
 185     // os::attempt_reserve_memory_at() to avoid over mapping something
 186     // important.  If available space is not detected, return NULL.
 187 
 188     if (requested_address != 0) {
 189       base = os::attempt_reserve_memory_at(size, requested_address, _fd_for_heap);
 190       if (failed_to_reserve_as_requested(base, requested_address, size, false, _fd_for_heap != -1)) {
 191         // OS ignored requested address. Try different address.
 192         base = NULL;
 193       }
 194     } else {
 195       base = os::reserve_memory(size, NULL, alignment, _fd_for_heap);
 196     }
 197 
 198     if (base == NULL) return;
 199 
 200     // Check alignment constraints
 201     if ((((size_t)base) &amp; (alignment - 1)) != 0) {
 202       // Base not aligned, retry
 203       unmap_or_release_memory(base, size, _fd_for_heap != -1 /*is_file_mapped*/);
 204 
 205       // Make sure that size is aligned
 206       size = align_up(size, alignment);
 207       base = os::reserve_memory_aligned(size, alignment, _fd_for_heap);
 208 
 209       if (requested_address != 0 &amp;&amp;
 210           failed_to_reserve_as_requested(base, requested_address, size, false, _fd_for_heap != -1)) {
 211         // As a result of the alignment constraints, the allocated base differs
 212         // from the requested address. Return back to the caller who can
 213         // take remedial action (like try again without a requested address).
 214         assert(_base == NULL, &quot;should be&quot;);
 215         return;
 216       }
 217     }
 218   }
 219   // Done
 220   _base = base;
 221   _size = size;
 222   _alignment = alignment;
 223   // If heap is reserved with a backing file, the entire space has been committed. So set the _special flag to true
 224   if (_fd_for_heap != -1) {
 225     _special = true;
 226   }
 227 }
 228 
 229 ReservedSpace ReservedSpace::first_part(size_t partition_size, size_t alignment,
 230                                         bool split, bool realloc) {
 231   assert(partition_size &lt;= size(), &quot;partition failed&quot;);
 232   if (split) {
 233     os::split_reserved_memory(base(), size(), partition_size, realloc);
 234   }
 235   ReservedSpace result(base(), partition_size, alignment, special(),
 236                        executable());
 237   return result;
 238 }
 239 
 240 
 241 ReservedSpace
 242 ReservedSpace::last_part(size_t partition_size, size_t alignment) {
 243   assert(partition_size &lt;= size(), &quot;partition failed&quot;);
 244   ReservedSpace result(base() + partition_size, size() - partition_size,
 245                        alignment, special(), executable());
 246   return result;
 247 }
 248 
 249 
 250 size_t ReservedSpace::page_align_size_up(size_t size) {
 251   return align_up(size, os::vm_page_size());
 252 }
 253 
 254 
 255 size_t ReservedSpace::page_align_size_down(size_t size) {
 256   return align_down(size, os::vm_page_size());
 257 }
 258 
 259 
 260 size_t ReservedSpace::allocation_align_size_up(size_t size) {
 261   return align_up(size, os::vm_allocation_granularity());
 262 }
 263 
 264 
 265 void ReservedSpace::release() {
 266   if (is_reserved()) {
 267     char *real_base = _base - _noaccess_prefix;
 268     const size_t real_size = _size + _noaccess_prefix;
 269     if (special()) {
 270       if (_fd_for_heap != -1) {
 271         os::unmap_memory(real_base, real_size);
 272       } else {
 273         os::release_memory_special(real_base, real_size);
 274       }
 275     } else{
 276       os::release_memory(real_base, real_size);
 277     }
 278     _base = NULL;
 279     _size = 0;
 280     _noaccess_prefix = 0;
 281     _alignment = 0;
 282     _special = false;
 283     _executable = false;
 284   }
 285 }
 286 
 287 static size_t noaccess_prefix_size(size_t alignment) {
 288   return lcm(os::vm_page_size(), alignment);
 289 }
 290 
 291 void ReservedHeapSpace::establish_noaccess_prefix() {
 292   assert(_alignment &gt;= (size_t)os::vm_page_size(), &quot;must be at least page size big&quot;);
 293   _noaccess_prefix = noaccess_prefix_size(_alignment);
 294 
 295   if (base() &amp;&amp; base() + _size &gt; (char *)OopEncodingHeapMax) {
 296     if (true
 297         WIN64_ONLY(&amp;&amp; !UseLargePages)
 298         AIX_ONLY(&amp;&amp; os::vm_page_size() != 64*K)) {
 299       // Protect memory at the base of the allocated region.
 300       // If special, the page was committed (only matters on windows)
 301       if (!os::protect_memory(_base, _noaccess_prefix, os::MEM_PROT_NONE, _special)) {
 302         fatal(&quot;cannot protect protection page&quot;);
 303       }
 304       log_debug(gc, heap, coops)(&quot;Protected page at the reserved heap base: &quot;
 305                                  PTR_FORMAT &quot; / &quot; INTX_FORMAT &quot; bytes&quot;,
 306                                  p2i(_base),
 307                                  _noaccess_prefix);
 308       assert(CompressedOops::use_implicit_null_checks() == true, &quot;not initialized?&quot;);
 309     } else {
 310       CompressedOops::set_use_implicit_null_checks(false);
 311     }
 312   }
 313 
 314   _base += _noaccess_prefix;
 315   _size -= _noaccess_prefix;
 316   assert(((uintptr_t)_base % _alignment == 0), &quot;must be exactly of required alignment&quot;);
 317 }
 318 
 319 // Tries to allocate memory of size &#39;size&#39; at address requested_address with alignment &#39;alignment&#39;.
 320 // Does not check whether the reserved memory actually is at requested_address, as the memory returned
 321 // might still fulfill the wishes of the caller.
 322 // Assures the memory is aligned to &#39;alignment&#39;.
 323 // NOTE: If ReservedHeapSpace already points to some reserved memory this is freed, first.
 324 void ReservedHeapSpace::try_reserve_heap(size_t size,
 325                                          size_t alignment,
 326                                          bool large,
 327                                          char* requested_address) {
 328   if (_base != NULL) {
 329     // We tried before, but we didn&#39;t like the address delivered.
 330     release();
 331   }
 332 
 333   // If OS doesn&#39;t support demand paging for large page memory, we need
 334   // to use reserve_memory_special() to reserve and pin the entire region.
 335   // If there is a backing file directory for this space then whether
 336   // large pages are allocated is up to the filesystem of the backing file.
 337   // So we ignore the UseLargePages flag in this case.
 338   bool special = large &amp;&amp; !os::can_commit_large_page_memory();
 339   if (special &amp;&amp; _fd_for_heap != -1) {
 340     special = false;
 341     if (UseLargePages &amp;&amp; (!FLAG_IS_DEFAULT(UseLargePages) ||
 342                           !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {
 343       log_debug(gc, heap)(&quot;Cannot allocate large pages for Java Heap when AllocateHeapAt option is set.&quot;);
 344     }
 345   }
 346   char* base = NULL;
 347 
 348   log_trace(gc, heap, coops)(&quot;Trying to allocate at address &quot; PTR_FORMAT
 349                              &quot; heap of size &quot; SIZE_FORMAT_HEX,
 350                              p2i(requested_address),
 351                              size);
 352 
 353   if (special) {
 354     base = os::reserve_memory_special(size, alignment, requested_address, false);
 355 
 356     if (base != NULL) {
 357       // Check alignment constraints.
 358       assert((uintptr_t) base % alignment == 0,
 359              &quot;Large pages returned a non-aligned address, base: &quot;
 360              PTR_FORMAT &quot; alignment: &quot; SIZE_FORMAT_HEX,
 361              p2i(base), alignment);
 362       _special = true;
 363     }
 364   }
 365 
 366   if (base == NULL) {
 367     // Failed; try to reserve regular memory below
 368     if (UseLargePages &amp;&amp; (!FLAG_IS_DEFAULT(UseLargePages) ||
 369                           !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {
 370       log_debug(gc, heap, coops)(&quot;Reserve regular memory without large pages&quot;);
 371     }
 372 
 373     // Optimistically assume that the OSes returns an aligned base pointer.
 374     // When reserving a large address range, most OSes seem to align to at
 375     // least 64K.
 376 
 377     // If the memory was requested at a particular address, use
 378     // os::attempt_reserve_memory_at() to avoid over mapping something
 379     // important.  If available space is not detected, return NULL.
 380 
 381     if (requested_address != 0) {
 382       base = os::attempt_reserve_memory_at(size, requested_address, _fd_for_heap);
 383     } else {
 384       base = os::reserve_memory(size, NULL, alignment, _fd_for_heap);
 385     }
 386   }
 387   if (base == NULL) { return; }
 388 
 389   // Done
 390   _base = base;
 391   _size = size;
 392   _alignment = alignment;
 393 
 394   // If heap is reserved with a backing file, the entire space has been committed. So set the _special flag to true
 395   if (_fd_for_heap != -1) {
 396     _special = true;
 397   }
 398 
 399   // Check alignment constraints
 400   if ((((size_t)base) &amp; (alignment - 1)) != 0) {
 401     // Base not aligned, retry.
 402     release();
 403   }
 404 }
 405 
 406 void ReservedHeapSpace::try_reserve_range(char *highest_start,
 407                                           char *lowest_start,
 408                                           size_t attach_point_alignment,
 409                                           char *aligned_heap_base_min_address,
 410                                           char *upper_bound,
 411                                           size_t size,
 412                                           size_t alignment,
 413                                           bool large) {
 414   const size_t attach_range = highest_start - lowest_start;
 415   // Cap num_attempts at possible number.
 416   // At least one is possible even for 0 sized attach range.
 417   const uint64_t num_attempts_possible = (attach_range / attach_point_alignment) + 1;
 418   const uint64_t num_attempts_to_try   = MIN2((uint64_t)HeapSearchSteps, num_attempts_possible);
 419 
 420   const size_t stepsize = (attach_range == 0) ? // Only one try.
 421     (size_t) highest_start : align_up(attach_range / num_attempts_to_try, attach_point_alignment);
 422 
 423   // Try attach points from top to bottom.
 424   char* attach_point = highest_start;
 425   while (attach_point &gt;= lowest_start  &amp;&amp;
 426          attach_point &lt;= highest_start &amp;&amp;  // Avoid wrap around.
 427          ((_base == NULL) ||
 428           (_base &lt; aligned_heap_base_min_address || _base + size &gt; upper_bound))) {
 429     try_reserve_heap(size, alignment, large, attach_point);
 430     attach_point -= stepsize;
 431   }
 432 }
 433 
 434 #define SIZE_64K  ((uint64_t) UCONST64(      0x10000))
 435 #define SIZE_256M ((uint64_t) UCONST64(   0x10000000))
 436 #define SIZE_32G  ((uint64_t) UCONST64(  0x800000000))
 437 
 438 // Helper for heap allocation. Returns an array with addresses
 439 // (OS-specific) which are suited for disjoint base mode. Array is
 440 // NULL terminated.
 441 static char** get_attach_addresses_for_disjoint_mode() {
 442   static uint64_t addresses[] = {
 443      2 * SIZE_32G,
 444      3 * SIZE_32G,
 445      4 * SIZE_32G,
 446      8 * SIZE_32G,
 447     10 * SIZE_32G,
 448      1 * SIZE_64K * SIZE_32G,
 449      2 * SIZE_64K * SIZE_32G,
 450      3 * SIZE_64K * SIZE_32G,
 451      4 * SIZE_64K * SIZE_32G,
 452     16 * SIZE_64K * SIZE_32G,
 453     32 * SIZE_64K * SIZE_32G,
 454     34 * SIZE_64K * SIZE_32G,
 455     0
 456   };
 457 
 458   // Sort out addresses smaller than HeapBaseMinAddress. This assumes
 459   // the array is sorted.
 460   uint i = 0;
 461   while (addresses[i] != 0 &amp;&amp;
 462          (addresses[i] &lt; OopEncodingHeapMax || addresses[i] &lt; HeapBaseMinAddress)) {
 463     i++;
 464   }
 465   uint start = i;
 466 
 467   // Avoid more steps than requested.
 468   i = 0;
 469   while (addresses[start+i] != 0) {
 470     if (i == HeapSearchSteps) {
 471       addresses[start+i] = 0;
 472       break;
 473     }
 474     i++;
 475   }
 476 
 477   return (char**) &amp;addresses[start];
 478 }
 479 
 480 void ReservedHeapSpace::initialize_compressed_heap(const size_t size, size_t alignment, bool large) {
 481   guarantee(size + noaccess_prefix_size(alignment) &lt;= OopEncodingHeapMax,
 482             &quot;can not allocate compressed oop heap for this size&quot;);
 483   guarantee(alignment == MAX2(alignment, (size_t)os::vm_page_size()), &quot;alignment too small&quot;);
 484 
 485   const size_t granularity = os::vm_allocation_granularity();
 486   assert((size &amp; (granularity - 1)) == 0,
 487          &quot;size not aligned to os::vm_allocation_granularity()&quot;);
 488   assert((alignment &amp; (granularity - 1)) == 0,
 489          &quot;alignment not aligned to os::vm_allocation_granularity()&quot;);
 490   assert(alignment == 0 || is_power_of_2((intptr_t)alignment),
 491          &quot;not a power of 2&quot;);
 492 
 493   // The necessary attach point alignment for generated wish addresses.
 494   // This is needed to increase the chance of attaching for mmap and shmat.
 495   const size_t os_attach_point_alignment =
 496     AIX_ONLY(SIZE_256M)  // Known shm boundary alignment.
 497     NOT_AIX(os::vm_allocation_granularity());
 498   const size_t attach_point_alignment = lcm(alignment, os_attach_point_alignment);
 499 
 500   char *aligned_heap_base_min_address = (char *)align_up((void *)HeapBaseMinAddress, alignment);
 501   size_t noaccess_prefix = ((aligned_heap_base_min_address + size) &gt; (char*)OopEncodingHeapMax) ?
 502     noaccess_prefix_size(alignment) : 0;
 503 
 504   // Attempt to alloc at user-given address.
 505   if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
 506     try_reserve_heap(size + noaccess_prefix, alignment, large, aligned_heap_base_min_address);
 507     if (_base != aligned_heap_base_min_address) { // Enforce this exact address.
 508       release();
 509     }
 510   }
 511 
 512   // Keep heap at HeapBaseMinAddress.
 513   if (_base == NULL) {
 514 
 515     // Try to allocate the heap at addresses that allow efficient oop compression.
 516     // Different schemes are tried, in order of decreasing optimization potential.
 517     //
 518     // For this, try_reserve_heap() is called with the desired heap base addresses.
 519     // A call into the os layer to allocate at a given address can return memory
 520     // at a different address than requested.  Still, this might be memory at a useful
 521     // address. try_reserve_heap() always returns this allocated memory, as only here
 522     // the criteria for a good heap are checked.
 523 
 524     // Attempt to allocate so that we can run without base and scale (32-Bit unscaled compressed oops).
 525     // Give it several tries from top of range to bottom.
 526     if (aligned_heap_base_min_address + size &lt;= (char *)UnscaledOopHeapMax) {
 527 
 528       // Calc address range within we try to attach (range of possible start addresses).
 529       char* const highest_start = align_down((char *)UnscaledOopHeapMax - size, attach_point_alignment);
 530       char* const lowest_start  = align_up(aligned_heap_base_min_address, attach_point_alignment);
 531       try_reserve_range(highest_start, lowest_start, attach_point_alignment,
 532                         aligned_heap_base_min_address, (char *)UnscaledOopHeapMax, size, alignment, large);
 533     }
 534 
 535     // zerobased: Attempt to allocate in the lower 32G.
 536     // But leave room for the compressed class pointers, which is allocated above
 537     // the heap.
 538     char *zerobased_max = (char *)OopEncodingHeapMax;
 539     const size_t class_space = align_up(CompressedClassSpaceSize, alignment);
 540     // For small heaps, save some space for compressed class pointer
 541     // space so it can be decoded with no base.
 542     if (UseCompressedClassPointers &amp;&amp; !UseSharedSpaces &amp;&amp;
 543         OopEncodingHeapMax &lt;= KlassEncodingMetaspaceMax &amp;&amp;
 544         (uint64_t)(aligned_heap_base_min_address + size + class_space) &lt;= KlassEncodingMetaspaceMax) {
 545       zerobased_max = (char *)OopEncodingHeapMax - class_space;
 546     }
 547 
 548     // Give it several tries from top of range to bottom.
 549     if (aligned_heap_base_min_address + size &lt;= zerobased_max &amp;&amp;    // Zerobased theoretical possible.
 550         ((_base == NULL) ||                        // No previous try succeeded.
 551          (_base + size &gt; zerobased_max))) {        // Unscaled delivered an arbitrary address.
 552 
 553       // Calc address range within we try to attach (range of possible start addresses).
 554       char *const highest_start = align_down(zerobased_max - size, attach_point_alignment);
 555       // Need to be careful about size being guaranteed to be less
 556       // than UnscaledOopHeapMax due to type constraints.
 557       char *lowest_start = aligned_heap_base_min_address;
 558       uint64_t unscaled_end = UnscaledOopHeapMax - size;
 559       if (unscaled_end &lt; UnscaledOopHeapMax) { // unscaled_end wrapped if size is large
 560         lowest_start = MAX2(lowest_start, (char*)unscaled_end);
 561       }
 562       lowest_start = align_up(lowest_start, attach_point_alignment);
 563       try_reserve_range(highest_start, lowest_start, attach_point_alignment,
 564                         aligned_heap_base_min_address, zerobased_max, size, alignment, large);
 565     }
 566 
 567     // Now we go for heaps with base != 0.  We need a noaccess prefix to efficiently
 568     // implement null checks.
 569     noaccess_prefix = noaccess_prefix_size(alignment);
 570 
 571     // Try to attach at addresses that are aligned to OopEncodingHeapMax. Disjointbase mode.
 572     char** addresses = get_attach_addresses_for_disjoint_mode();
 573     int i = 0;
 574     while (addresses[i] &amp;&amp;                                 // End of array not yet reached.
 575            ((_base == NULL) ||                             // No previous try succeeded.
 576             (_base + size &gt;  (char *)OopEncodingHeapMax &amp;&amp; // Not zerobased or unscaled address.
 577              !CompressedOops::is_disjoint_heap_base_address((address)_base)))) {  // Not disjoint address.
 578       char* const attach_point = addresses[i];
 579       assert(attach_point &gt;= aligned_heap_base_min_address, &quot;Flag support broken&quot;);
 580       try_reserve_heap(size + noaccess_prefix, alignment, large, attach_point);
 581       i++;
 582     }
 583 
 584     // Last, desperate try without any placement.
 585     if (_base == NULL) {
 586       log_trace(gc, heap, coops)(&quot;Trying to allocate at address NULL heap of size &quot; SIZE_FORMAT_HEX, size + noaccess_prefix);
 587       initialize(size + noaccess_prefix, alignment, large, NULL, false);
 588     }
 589   }
 590 }
 591 
 592 ReservedHeapSpace::ReservedHeapSpace(size_t size, size_t alignment, bool large, const char* heap_allocation_directory) : ReservedSpace() {
 593 
 594   if (size == 0) {
 595     return;
 596   }
 597 
 598   if (heap_allocation_directory != NULL) {
 599     _fd_for_heap = os::create_file_for_heap(heap_allocation_directory);
 600     if (_fd_for_heap == -1) {
 601       vm_exit_during_initialization(
 602         err_msg(&quot;Could not create file for Heap at location %s&quot;, heap_allocation_directory));
 603     }
 604   }
 605 
 606   // Heap size should be aligned to alignment, too.
 607   guarantee(is_aligned(size, alignment), &quot;set by caller&quot;);
 608 
 609   if (UseCompressedOops) {
 610     initialize_compressed_heap(size, alignment, large);
 611     if (_size &gt; size) {
 612       // We allocated heap with noaccess prefix.
 613       // It can happen we get a zerobased/unscaled heap with noaccess prefix,
 614       // if we had to try at arbitrary address.
 615       establish_noaccess_prefix();
 616     }
 617   } else {
 618     initialize(size, alignment, large, NULL, false);
 619   }
 620 
 621   assert(markWord::encode_pointer_as_mark(_base).decode_pointer() == _base,
 622          &quot;area must be distinguishable from marks for mark-sweep&quot;);
 623   assert(markWord::encode_pointer_as_mark(&amp;_base[size]).decode_pointer() == &amp;_base[size],
 624          &quot;area must be distinguishable from marks for mark-sweep&quot;);
 625 
 626   if (base() != NULL) {
 627     MemTracker::record_virtual_memory_type((address)base(), mtJavaHeap);
 628   }
 629 
 630   if (_fd_for_heap != -1) {
 631     os::close(_fd_for_heap);
 632   }
 633 }
 634 
 635 MemRegion ReservedHeapSpace::region() const {
 636   return MemRegion((HeapWord*)base(), (HeapWord*)end());
 637 }
 638 
 639 // Reserve space for code segment.  Same as Java heap only we mark this as
 640 // executable.
 641 ReservedCodeSpace::ReservedCodeSpace(size_t r_size,
 642                                      size_t rs_align,
<a name="3" id="anc3"></a><span class="line-modified"> 643                                      bool large) : ReservedSpace() {</span>
<span class="line-modified"> 644   initialize(r_size, rs_align, large, /*requested address*/ NULL, /*executable*/ true);</span>
 645   MemTracker::record_virtual_memory_type((address)base(), mtCode);
 646 }
 647 
 648 // VirtualSpace
 649 
 650 VirtualSpace::VirtualSpace() {
 651   _low_boundary           = NULL;
 652   _high_boundary          = NULL;
 653   _low                    = NULL;
 654   _high                   = NULL;
 655   _lower_high             = NULL;
 656   _middle_high            = NULL;
 657   _upper_high             = NULL;
 658   _lower_high_boundary    = NULL;
 659   _middle_high_boundary   = NULL;
 660   _upper_high_boundary    = NULL;
 661   _lower_alignment        = 0;
 662   _middle_alignment       = 0;
 663   _upper_alignment        = 0;
 664   _special                = false;
 665   _executable             = false;
 666 }
 667 
 668 
 669 bool VirtualSpace::initialize(ReservedSpace rs, size_t committed_size) {
 670   const size_t max_commit_granularity = os::page_size_for_region_unaligned(rs.size(), 1);
 671   return initialize_with_granularity(rs, committed_size, max_commit_granularity);
 672 }
 673 
 674 bool VirtualSpace::initialize_with_granularity(ReservedSpace rs, size_t committed_size, size_t max_commit_granularity) {
 675   if(!rs.is_reserved()) return false;  // allocation failed.
 676   assert(_low_boundary == NULL, &quot;VirtualSpace already initialized&quot;);
 677   assert(max_commit_granularity &gt; 0, &quot;Granularity must be non-zero.&quot;);
 678 
 679   _low_boundary  = rs.base();
 680   _high_boundary = low_boundary() + rs.size();
 681 
 682   _low = low_boundary();
 683   _high = low();
 684 
 685   _special = rs.special();
 686   _executable = rs.executable();
 687 
 688   // When a VirtualSpace begins life at a large size, make all future expansion
 689   // and shrinking occur aligned to a granularity of large pages.  This avoids
 690   // fragmentation of physical addresses that inhibits the use of large pages
 691   // by the OS virtual memory system.  Empirically,  we see that with a 4MB
 692   // page size, the only spaces that get handled this way are codecache and
 693   // the heap itself, both of which provide a substantial performance
 694   // boost in many benchmarks when covered by large pages.
 695   //
 696   // No attempt is made to force large page alignment at the very top and
 697   // bottom of the space if they are not aligned so already.
 698   _lower_alignment  = os::vm_page_size();
 699   _middle_alignment = max_commit_granularity;
 700   _upper_alignment  = os::vm_page_size();
 701 
 702   // End of each region
 703   _lower_high_boundary = align_up(low_boundary(), middle_alignment());
 704   _middle_high_boundary = align_down(high_boundary(), middle_alignment());
 705   _upper_high_boundary = high_boundary();
 706 
 707   // High address of each region
 708   _lower_high = low_boundary();
 709   _middle_high = lower_high_boundary();
 710   _upper_high = middle_high_boundary();
 711 
 712   // commit to initial size
 713   if (committed_size &gt; 0) {
 714     if (!expand_by(committed_size)) {
 715       return false;
 716     }
 717   }
 718   return true;
 719 }
 720 
 721 
 722 VirtualSpace::~VirtualSpace() {
 723   release();
 724 }
 725 
 726 
 727 void VirtualSpace::release() {
 728   // This does not release memory it reserved.
 729   // Caller must release via rs.release();
 730   _low_boundary           = NULL;
 731   _high_boundary          = NULL;
 732   _low                    = NULL;
 733   _high                   = NULL;
 734   _lower_high             = NULL;
 735   _middle_high            = NULL;
 736   _upper_high             = NULL;
 737   _lower_high_boundary    = NULL;
 738   _middle_high_boundary   = NULL;
 739   _upper_high_boundary    = NULL;
 740   _lower_alignment        = 0;
 741   _middle_alignment       = 0;
 742   _upper_alignment        = 0;
 743   _special                = false;
 744   _executable             = false;
 745 }
 746 
 747 
 748 size_t VirtualSpace::committed_size() const {
 749   return pointer_delta(high(), low(), sizeof(char));
 750 }
 751 
 752 
 753 size_t VirtualSpace::reserved_size() const {
 754   return pointer_delta(high_boundary(), low_boundary(), sizeof(char));
 755 }
 756 
 757 
 758 size_t VirtualSpace::uncommitted_size()  const {
 759   return reserved_size() - committed_size();
 760 }
 761 
 762 size_t VirtualSpace::actual_committed_size() const {
 763   // Special VirtualSpaces commit all reserved space up front.
 764   if (special()) {
 765     return reserved_size();
 766   }
 767 
 768   size_t committed_low    = pointer_delta(_lower_high,  _low_boundary,         sizeof(char));
 769   size_t committed_middle = pointer_delta(_middle_high, _lower_high_boundary,  sizeof(char));
 770   size_t committed_high   = pointer_delta(_upper_high,  _middle_high_boundary, sizeof(char));
 771 
 772 #ifdef ASSERT
 773   size_t lower  = pointer_delta(_lower_high_boundary,  _low_boundary,         sizeof(char));
 774   size_t middle = pointer_delta(_middle_high_boundary, _lower_high_boundary,  sizeof(char));
 775   size_t upper  = pointer_delta(_upper_high_boundary,  _middle_high_boundary, sizeof(char));
 776 
 777   if (committed_high &gt; 0) {
 778     assert(committed_low == lower, &quot;Must be&quot;);
 779     assert(committed_middle == middle, &quot;Must be&quot;);
 780   }
 781 
 782   if (committed_middle &gt; 0) {
 783     assert(committed_low == lower, &quot;Must be&quot;);
 784   }
 785   if (committed_middle &lt; middle) {
 786     assert(committed_high == 0, &quot;Must be&quot;);
 787   }
 788 
 789   if (committed_low &lt; lower) {
 790     assert(committed_high == 0, &quot;Must be&quot;);
 791     assert(committed_middle == 0, &quot;Must be&quot;);
 792   }
 793 #endif
 794 
 795   return committed_low + committed_middle + committed_high;
 796 }
 797 
 798 
 799 bool VirtualSpace::contains(const void* p) const {
 800   return low() &lt;= (const char*) p &amp;&amp; (const char*) p &lt; high();
 801 }
 802 
 803 static void pretouch_expanded_memory(void* start, void* end) {
 804   assert(is_aligned(start, os::vm_page_size()), &quot;Unexpected alignment&quot;);
 805   assert(is_aligned(end,   os::vm_page_size()), &quot;Unexpected alignment&quot;);
 806 
 807   os::pretouch_memory(start, end);
 808 }
 809 
 810 static bool commit_expanded(char* start, size_t size, size_t alignment, bool pre_touch, bool executable) {
 811   if (os::commit_memory(start, size, alignment, executable)) {
 812     if (pre_touch || AlwaysPreTouch) {
 813       pretouch_expanded_memory(start, start + size);
 814     }
 815     return true;
 816   }
 817 
 818   debug_only(warning(
 819       &quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT
 820       &quot; size=&quot; SIZE_FORMAT &quot;, executable=%d) failed&quot;,
 821       p2i(start), p2i(start + size), size, executable);)
 822 
 823   return false;
 824 }
 825 
 826 /*
 827    First we need to determine if a particular virtual space is using large
 828    pages.  This is done at the initialize function and only virtual spaces
 829    that are larger than LargePageSizeInBytes use large pages.  Once we
 830    have determined this, all expand_by and shrink_by calls must grow and
 831    shrink by large page size chunks.  If a particular request
 832    is within the current large page, the call to commit and uncommit memory
 833    can be ignored.  In the case that the low and high boundaries of this
 834    space is not large page aligned, the pages leading to the first large
 835    page address and the pages after the last large page address must be
 836    allocated with default pages.
 837 */
 838 bool VirtualSpace::expand_by(size_t bytes, bool pre_touch) {
 839   if (uncommitted_size() &lt; bytes) {
 840     return false;
 841   }
 842 
 843   if (special()) {
 844     // don&#39;t commit memory if the entire space is pinned in memory
 845     _high += bytes;
 846     return true;
 847   }
 848 
 849   char* previous_high = high();
 850   char* unaligned_new_high = high() + bytes;
 851   assert(unaligned_new_high &lt;= high_boundary(), &quot;cannot expand by more than upper boundary&quot;);
 852 
 853   // Calculate where the new high for each of the regions should be.  If
 854   // the low_boundary() and high_boundary() are LargePageSizeInBytes aligned
 855   // then the unaligned lower and upper new highs would be the
 856   // lower_high() and upper_high() respectively.
 857   char* unaligned_lower_new_high =  MIN2(unaligned_new_high, lower_high_boundary());
 858   char* unaligned_middle_new_high = MIN2(unaligned_new_high, middle_high_boundary());
 859   char* unaligned_upper_new_high =  MIN2(unaligned_new_high, upper_high_boundary());
 860 
 861   // Align the new highs based on the regions alignment.  lower and upper
 862   // alignment will always be default page size.  middle alignment will be
 863   // LargePageSizeInBytes if the actual size of the virtual space is in
 864   // fact larger than LargePageSizeInBytes.
 865   char* aligned_lower_new_high =  align_up(unaligned_lower_new_high, lower_alignment());
 866   char* aligned_middle_new_high = align_up(unaligned_middle_new_high, middle_alignment());
 867   char* aligned_upper_new_high =  align_up(unaligned_upper_new_high, upper_alignment());
 868 
 869   // Determine which regions need to grow in this expand_by call.
 870   // If you are growing in the lower region, high() must be in that
 871   // region so calculate the size based on high().  For the middle and
 872   // upper regions, determine the starting point of growth based on the
 873   // location of high().  By getting the MAX of the region&#39;s low address
 874   // (or the previous region&#39;s high address) and high(), we can tell if it
 875   // is an intra or inter region growth.
 876   size_t lower_needs = 0;
 877   if (aligned_lower_new_high &gt; lower_high()) {
 878     lower_needs = pointer_delta(aligned_lower_new_high, lower_high(), sizeof(char));
 879   }
 880   size_t middle_needs = 0;
 881   if (aligned_middle_new_high &gt; middle_high()) {
 882     middle_needs = pointer_delta(aligned_middle_new_high, middle_high(), sizeof(char));
 883   }
 884   size_t upper_needs = 0;
 885   if (aligned_upper_new_high &gt; upper_high()) {
 886     upper_needs = pointer_delta(aligned_upper_new_high, upper_high(), sizeof(char));
 887   }
 888 
 889   // Check contiguity.
 890   assert(low_boundary() &lt;= lower_high() &amp;&amp; lower_high() &lt;= lower_high_boundary(),
 891          &quot;high address must be contained within the region&quot;);
 892   assert(lower_high_boundary() &lt;= middle_high() &amp;&amp; middle_high() &lt;= middle_high_boundary(),
 893          &quot;high address must be contained within the region&quot;);
 894   assert(middle_high_boundary() &lt;= upper_high() &amp;&amp; upper_high() &lt;= upper_high_boundary(),
 895          &quot;high address must be contained within the region&quot;);
 896 
 897   // Commit regions
 898   if (lower_needs &gt; 0) {
 899     assert(lower_high() + lower_needs &lt;= lower_high_boundary(), &quot;must not expand beyond region&quot;);
 900     if (!commit_expanded(lower_high(), lower_needs, _lower_alignment, pre_touch, _executable)) {
 901       return false;
 902     }
 903     _lower_high += lower_needs;
 904   }
 905 
 906   if (middle_needs &gt; 0) {
 907     assert(middle_high() + middle_needs &lt;= middle_high_boundary(), &quot;must not expand beyond region&quot;);
 908     if (!commit_expanded(middle_high(), middle_needs, _middle_alignment, pre_touch, _executable)) {
 909       return false;
 910     }
 911     _middle_high += middle_needs;
 912   }
 913 
 914   if (upper_needs &gt; 0) {
 915     assert(upper_high() + upper_needs &lt;= upper_high_boundary(), &quot;must not expand beyond region&quot;);
 916     if (!commit_expanded(upper_high(), upper_needs, _upper_alignment, pre_touch, _executable)) {
 917       return false;
 918     }
 919     _upper_high += upper_needs;
 920   }
 921 
 922   _high += bytes;
 923   return true;
 924 }
 925 
 926 // A page is uncommitted if the contents of the entire page is deemed unusable.
 927 // Continue to decrement the high() pointer until it reaches a page boundary
 928 // in which case that particular page can now be uncommitted.
 929 void VirtualSpace::shrink_by(size_t size) {
 930   if (committed_size() &lt; size)
 931     fatal(&quot;Cannot shrink virtual space to negative size&quot;);
 932 
 933   if (special()) {
 934     // don&#39;t uncommit if the entire space is pinned in memory
 935     _high -= size;
 936     return;
 937   }
 938 
 939   char* unaligned_new_high = high() - size;
 940   assert(unaligned_new_high &gt;= low_boundary(), &quot;cannot shrink past lower boundary&quot;);
 941 
 942   // Calculate new unaligned address
 943   char* unaligned_upper_new_high =
 944     MAX2(unaligned_new_high, middle_high_boundary());
 945   char* unaligned_middle_new_high =
 946     MAX2(unaligned_new_high, lower_high_boundary());
 947   char* unaligned_lower_new_high =
 948     MAX2(unaligned_new_high, low_boundary());
 949 
 950   // Align address to region&#39;s alignment
 951   char* aligned_upper_new_high =  align_up(unaligned_upper_new_high, upper_alignment());
 952   char* aligned_middle_new_high = align_up(unaligned_middle_new_high, middle_alignment());
 953   char* aligned_lower_new_high =  align_up(unaligned_lower_new_high, lower_alignment());
 954 
 955   // Determine which regions need to shrink
 956   size_t upper_needs = 0;
 957   if (aligned_upper_new_high &lt; upper_high()) {
 958     upper_needs =
 959       pointer_delta(upper_high(), aligned_upper_new_high, sizeof(char));
 960   }
 961   size_t middle_needs = 0;
 962   if (aligned_middle_new_high &lt; middle_high()) {
 963     middle_needs =
 964       pointer_delta(middle_high(), aligned_middle_new_high, sizeof(char));
 965   }
 966   size_t lower_needs = 0;
 967   if (aligned_lower_new_high &lt; lower_high()) {
 968     lower_needs =
 969       pointer_delta(lower_high(), aligned_lower_new_high, sizeof(char));
 970   }
 971 
 972   // Check contiguity.
 973   assert(middle_high_boundary() &lt;= upper_high() &amp;&amp;
 974          upper_high() &lt;= upper_high_boundary(),
 975          &quot;high address must be contained within the region&quot;);
 976   assert(lower_high_boundary() &lt;= middle_high() &amp;&amp;
 977          middle_high() &lt;= middle_high_boundary(),
 978          &quot;high address must be contained within the region&quot;);
 979   assert(low_boundary() &lt;= lower_high() &amp;&amp;
 980          lower_high() &lt;= lower_high_boundary(),
 981          &quot;high address must be contained within the region&quot;);
 982 
 983   // Uncommit
 984   if (upper_needs &gt; 0) {
 985     assert(middle_high_boundary() &lt;= aligned_upper_new_high &amp;&amp;
 986            aligned_upper_new_high + upper_needs &lt;= upper_high_boundary(),
 987            &quot;must not shrink beyond region&quot;);
 988     if (!os::uncommit_memory(aligned_upper_new_high, upper_needs)) {
 989       debug_only(warning(&quot;os::uncommit_memory failed&quot;));
 990       return;
 991     } else {
 992       _upper_high -= upper_needs;
 993     }
 994   }
 995   if (middle_needs &gt; 0) {
 996     assert(lower_high_boundary() &lt;= aligned_middle_new_high &amp;&amp;
 997            aligned_middle_new_high + middle_needs &lt;= middle_high_boundary(),
 998            &quot;must not shrink beyond region&quot;);
 999     if (!os::uncommit_memory(aligned_middle_new_high, middle_needs)) {
1000       debug_only(warning(&quot;os::uncommit_memory failed&quot;));
1001       return;
1002     } else {
1003       _middle_high -= middle_needs;
1004     }
1005   }
1006   if (lower_needs &gt; 0) {
1007     assert(low_boundary() &lt;= aligned_lower_new_high &amp;&amp;
1008            aligned_lower_new_high + lower_needs &lt;= lower_high_boundary(),
1009            &quot;must not shrink beyond region&quot;);
1010     if (!os::uncommit_memory(aligned_lower_new_high, lower_needs)) {
1011       debug_only(warning(&quot;os::uncommit_memory failed&quot;));
1012       return;
1013     } else {
1014       _lower_high -= lower_needs;
1015     }
1016   }
1017 
1018   _high -= size;
1019 }
1020 
1021 #ifndef PRODUCT
1022 void VirtualSpace::check_for_contiguity() {
1023   // Check contiguity.
1024   assert(low_boundary() &lt;= lower_high() &amp;&amp;
1025          lower_high() &lt;= lower_high_boundary(),
1026          &quot;high address must be contained within the region&quot;);
1027   assert(lower_high_boundary() &lt;= middle_high() &amp;&amp;
1028          middle_high() &lt;= middle_high_boundary(),
1029          &quot;high address must be contained within the region&quot;);
1030   assert(middle_high_boundary() &lt;= upper_high() &amp;&amp;
1031          upper_high() &lt;= upper_high_boundary(),
1032          &quot;high address must be contained within the region&quot;);
1033   assert(low() &gt;= low_boundary(), &quot;low&quot;);
1034   assert(low_boundary() &lt;= lower_high_boundary(), &quot;lower high boundary&quot;);
1035   assert(upper_high_boundary() &lt;= high_boundary(), &quot;upper high boundary&quot;);
1036   assert(high() &lt;= upper_high(), &quot;upper high&quot;);
1037 }
1038 
1039 void VirtualSpace::print_on(outputStream* out) {
1040   out-&gt;print   (&quot;Virtual space:&quot;);
1041   if (special()) out-&gt;print(&quot; (pinned in memory)&quot;);
1042   out-&gt;cr();
1043   out-&gt;print_cr(&quot; - committed: &quot; SIZE_FORMAT, committed_size());
1044   out-&gt;print_cr(&quot; - reserved:  &quot; SIZE_FORMAT, reserved_size());
1045   out-&gt;print_cr(&quot; - [low, high]:     [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;]&quot;,  p2i(low()), p2i(high()));
1046   out-&gt;print_cr(&quot; - [low_b, high_b]: [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;]&quot;,  p2i(low_boundary()), p2i(high_boundary()));
1047 }
1048 
1049 void VirtualSpace::print() {
1050   print_on(tty);
1051 }
1052 
1053 /////////////// Unit tests ///////////////
1054 
1055 #ifndef PRODUCT
1056 
1057 class TestReservedSpace : AllStatic {
1058  public:
1059   static void small_page_write(void* addr, size_t size) {
1060     size_t page_size = os::vm_page_size();
1061 
1062     char* end = (char*)addr + size;
1063     for (char* p = (char*)addr; p &lt; end; p += page_size) {
1064       *p = 1;
1065     }
1066   }
1067 
1068   static void release_memory_for_test(ReservedSpace rs) {
1069     if (rs.special()) {
1070       guarantee(os::release_memory_special(rs.base(), rs.size()), &quot;Shouldn&#39;t fail&quot;);
1071     } else {
1072       guarantee(os::release_memory(rs.base(), rs.size()), &quot;Shouldn&#39;t fail&quot;);
1073     }
1074   }
1075 
1076   static void test_reserved_space1(size_t size, size_t alignment) {
1077     assert(is_aligned(size, alignment), &quot;Incorrect input parameters&quot;);
1078 
1079     ReservedSpace rs(size,          // size
1080                      alignment,     // alignment
1081                      UseLargePages, // large
1082                      (char *)NULL); // requested_address
1083 
1084     assert(rs.base() != NULL, &quot;Must be&quot;);
1085     assert(rs.size() == size, &quot;Must be&quot;);
1086 
1087     assert(is_aligned(rs.base(), alignment), &quot;aligned sizes should always give aligned addresses&quot;);
1088     assert(is_aligned(rs.size(), alignment), &quot;aligned sizes should always give aligned addresses&quot;);
1089 
1090     if (rs.special()) {
1091       small_page_write(rs.base(), size);
1092     }
1093 
1094     release_memory_for_test(rs);
1095   }
1096 
1097   static void test_reserved_space2(size_t size) {
1098     assert(is_aligned(size, os::vm_allocation_granularity()), &quot;Must be at least AG aligned&quot;);
1099 
1100     ReservedSpace rs(size);
1101 
1102     assert(rs.base() != NULL, &quot;Must be&quot;);
1103     assert(rs.size() == size, &quot;Must be&quot;);
1104 
1105     if (rs.special()) {
1106       small_page_write(rs.base(), size);
1107     }
1108 
1109     release_memory_for_test(rs);
1110   }
1111 
1112   static void test_reserved_space3(size_t size, size_t alignment, bool maybe_large) {
1113     if (size &lt; alignment) {
1114       // Tests might set -XX:LargePageSizeInBytes=&lt;small pages&gt; and cause unexpected input arguments for this test.
1115       assert((size_t)os::vm_page_size() == os::large_page_size(), &quot;Test needs further refinement&quot;);
1116       return;
1117     }
1118 
1119     assert(is_aligned(size, os::vm_allocation_granularity()), &quot;Must be at least AG aligned&quot;);
1120     assert(is_aligned(size, alignment), &quot;Must be at least aligned against alignment&quot;);
1121 
1122     bool large = maybe_large &amp;&amp; UseLargePages &amp;&amp; size &gt;= os::large_page_size();
1123 
<a name="4" id="anc4"></a><span class="line-modified">1124     ReservedSpace rs(size, alignment, large);</span>
1125 
1126     assert(rs.base() != NULL, &quot;Must be&quot;);
1127     assert(rs.size() == size, &quot;Must be&quot;);
1128 
1129     if (rs.special()) {
1130       small_page_write(rs.base(), size);
1131     }
1132 
1133     release_memory_for_test(rs);
1134   }
1135 
1136 
1137   static void test_reserved_space1() {
1138     size_t size = 2 * 1024 * 1024;
1139     size_t ag   = os::vm_allocation_granularity();
1140 
1141     test_reserved_space1(size,      ag);
1142     test_reserved_space1(size * 2,  ag);
1143     test_reserved_space1(size * 10, ag);
1144   }
1145 
1146   static void test_reserved_space2() {
1147     size_t size = 2 * 1024 * 1024;
1148     size_t ag = os::vm_allocation_granularity();
1149 
1150     test_reserved_space2(size * 1);
1151     test_reserved_space2(size * 2);
1152     test_reserved_space2(size * 10);
1153     test_reserved_space2(ag);
1154     test_reserved_space2(size - ag);
1155     test_reserved_space2(size);
1156     test_reserved_space2(size + ag);
1157     test_reserved_space2(size * 2);
1158     test_reserved_space2(size * 2 - ag);
1159     test_reserved_space2(size * 2 + ag);
1160     test_reserved_space2(size * 3);
1161     test_reserved_space2(size * 3 - ag);
1162     test_reserved_space2(size * 3 + ag);
1163     test_reserved_space2(size * 10);
1164     test_reserved_space2(size * 10 + size / 2);
1165   }
1166 
1167   static void test_reserved_space3() {
1168     size_t ag = os::vm_allocation_granularity();
1169 
1170     test_reserved_space3(ag,      ag    , false);
1171     test_reserved_space3(ag * 2,  ag    , false);
1172     test_reserved_space3(ag * 3,  ag    , false);
1173     test_reserved_space3(ag * 2,  ag * 2, false);
1174     test_reserved_space3(ag * 4,  ag * 2, false);
1175     test_reserved_space3(ag * 8,  ag * 2, false);
1176     test_reserved_space3(ag * 4,  ag * 4, false);
1177     test_reserved_space3(ag * 8,  ag * 4, false);
1178     test_reserved_space3(ag * 16, ag * 4, false);
1179 
1180     if (UseLargePages) {
1181       size_t lp = os::large_page_size();
1182 
1183       // Without large pages
1184       test_reserved_space3(lp,     ag * 4, false);
1185       test_reserved_space3(lp * 2, ag * 4, false);
1186       test_reserved_space3(lp * 4, ag * 4, false);
1187       test_reserved_space3(lp,     lp    , false);
1188       test_reserved_space3(lp * 2, lp    , false);
1189       test_reserved_space3(lp * 3, lp    , false);
1190       test_reserved_space3(lp * 2, lp * 2, false);
1191       test_reserved_space3(lp * 4, lp * 2, false);
1192       test_reserved_space3(lp * 8, lp * 2, false);
1193 
1194       // With large pages
1195       test_reserved_space3(lp, ag * 4    , true);
1196       test_reserved_space3(lp * 2, ag * 4, true);
1197       test_reserved_space3(lp * 4, ag * 4, true);
1198       test_reserved_space3(lp, lp        , true);
1199       test_reserved_space3(lp * 2, lp    , true);
1200       test_reserved_space3(lp * 3, lp    , true);
1201       test_reserved_space3(lp * 2, lp * 2, true);
1202       test_reserved_space3(lp * 4, lp * 2, true);
1203       test_reserved_space3(lp * 8, lp * 2, true);
1204     }
1205   }
1206 
1207   static void test_reserved_space() {
1208     test_reserved_space1();
1209     test_reserved_space2();
1210     test_reserved_space3();
1211   }
1212 };
1213 
1214 void TestReservedSpace_test() {
1215   TestReservedSpace::test_reserved_space();
1216 }
1217 
1218 #define assert_equals(actual, expected)  \
1219   assert(actual == expected,             \
1220          &quot;Got &quot; SIZE_FORMAT &quot; expected &quot; \
1221          SIZE_FORMAT, actual, expected);
1222 
1223 #define assert_ge(value1, value2)                  \
1224   assert(value1 &gt;= value2,                         \
1225          &quot;&#39;&quot; #value1 &quot;&#39;: &quot; SIZE_FORMAT &quot; &#39;&quot;        \
1226          #value2 &quot;&#39;: &quot; SIZE_FORMAT, value1, value2);
1227 
1228 #define assert_lt(value1, value2)                  \
1229   assert(value1 &lt; value2,                          \
1230          &quot;&#39;&quot; #value1 &quot;&#39;: &quot; SIZE_FORMAT &quot; &#39;&quot;        \
1231          #value2 &quot;&#39;: &quot; SIZE_FORMAT, value1, value2);
1232 
1233 
1234 class TestVirtualSpace : AllStatic {
1235   enum TestLargePages {
1236     Default,
1237     Disable,
1238     Reserve,
1239     Commit
1240   };
1241 
1242   static ReservedSpace reserve_memory(size_t reserve_size_aligned, TestLargePages mode) {
1243     switch(mode) {
1244     default:
1245     case Default:
1246     case Reserve:
1247       return ReservedSpace(reserve_size_aligned);
1248     case Disable:
1249     case Commit:
1250       return ReservedSpace(reserve_size_aligned,
1251                            os::vm_allocation_granularity(),
<a name="5" id="anc5"></a><span class="line-modified">1252                            /* large */ false);</span>
1253     }
1254   }
1255 
1256   static bool initialize_virtual_space(VirtualSpace&amp; vs, ReservedSpace rs, TestLargePages mode) {
1257     switch(mode) {
1258     default:
1259     case Default:
1260     case Reserve:
1261       return vs.initialize(rs, 0);
1262     case Disable:
1263       return vs.initialize_with_granularity(rs, 0, os::vm_page_size());
1264     case Commit:
1265       return vs.initialize_with_granularity(rs, 0, os::page_size_for_region_unaligned(rs.size(), 1));
1266     }
1267   }
1268 
1269  public:
1270   static void test_virtual_space_actual_committed_space(size_t reserve_size, size_t commit_size,
1271                                                         TestLargePages mode = Default) {
1272     size_t granularity = os::vm_allocation_granularity();
1273     size_t reserve_size_aligned = align_up(reserve_size, granularity);
1274 
1275     ReservedSpace reserved = reserve_memory(reserve_size_aligned, mode);
1276 
1277     assert(reserved.is_reserved(), &quot;Must be&quot;);
1278 
1279     VirtualSpace vs;
1280     bool initialized = initialize_virtual_space(vs, reserved, mode);
1281     assert(initialized, &quot;Failed to initialize VirtualSpace&quot;);
1282 
1283     vs.expand_by(commit_size, false);
1284 
1285     if (vs.special()) {
1286       assert_equals(vs.actual_committed_size(), reserve_size_aligned);
1287     } else {
1288       assert_ge(vs.actual_committed_size(), commit_size);
1289       // Approximate the commit granularity.
1290       // Make sure that we don&#39;t commit using large pages
1291       // if large pages has been disabled for this VirtualSpace.
1292       size_t commit_granularity = (mode == Disable || !UseLargePages) ?
1293                                    os::vm_page_size() : os::large_page_size();
1294       assert_lt(vs.actual_committed_size(), commit_size + commit_granularity);
1295     }
1296 
1297     reserved.release();
1298   }
1299 
1300   static void test_virtual_space_actual_committed_space_one_large_page() {
1301     if (!UseLargePages) {
1302       return;
1303     }
1304 
1305     size_t large_page_size = os::large_page_size();
1306 
<a name="6" id="anc6"></a><span class="line-modified">1307     ReservedSpace reserved(large_page_size, large_page_size, true);</span>
1308 
1309     assert(reserved.is_reserved(), &quot;Must be&quot;);
1310 
1311     VirtualSpace vs;
1312     bool initialized = vs.initialize(reserved, 0);
1313     assert(initialized, &quot;Failed to initialize VirtualSpace&quot;);
1314 
1315     vs.expand_by(large_page_size, false);
1316 
1317     assert_equals(vs.actual_committed_size(), large_page_size);
1318 
1319     reserved.release();
1320   }
1321 
1322   static void test_virtual_space_actual_committed_space() {
1323     test_virtual_space_actual_committed_space(4 * K, 0);
1324     test_virtual_space_actual_committed_space(4 * K, 4 * K);
1325     test_virtual_space_actual_committed_space(8 * K, 0);
1326     test_virtual_space_actual_committed_space(8 * K, 4 * K);
1327     test_virtual_space_actual_committed_space(8 * K, 8 * K);
1328     test_virtual_space_actual_committed_space(12 * K, 0);
1329     test_virtual_space_actual_committed_space(12 * K, 4 * K);
1330     test_virtual_space_actual_committed_space(12 * K, 8 * K);
1331     test_virtual_space_actual_committed_space(12 * K, 12 * K);
1332     test_virtual_space_actual_committed_space(64 * K, 0);
1333     test_virtual_space_actual_committed_space(64 * K, 32 * K);
1334     test_virtual_space_actual_committed_space(64 * K, 64 * K);
1335     test_virtual_space_actual_committed_space(2 * M, 0);
1336     test_virtual_space_actual_committed_space(2 * M, 4 * K);
1337     test_virtual_space_actual_committed_space(2 * M, 64 * K);
1338     test_virtual_space_actual_committed_space(2 * M, 1 * M);
1339     test_virtual_space_actual_committed_space(2 * M, 2 * M);
1340     test_virtual_space_actual_committed_space(10 * M, 0);
1341     test_virtual_space_actual_committed_space(10 * M, 4 * K);
1342     test_virtual_space_actual_committed_space(10 * M, 8 * K);
1343     test_virtual_space_actual_committed_space(10 * M, 1 * M);
1344     test_virtual_space_actual_committed_space(10 * M, 2 * M);
1345     test_virtual_space_actual_committed_space(10 * M, 5 * M);
1346     test_virtual_space_actual_committed_space(10 * M, 10 * M);
1347   }
1348 
1349   static void test_virtual_space_disable_large_pages() {
1350     if (!UseLargePages) {
1351       return;
1352     }
1353     // These test cases verify that if we force VirtualSpace to disable large pages
1354     test_virtual_space_actual_committed_space(10 * M, 0, Disable);
1355     test_virtual_space_actual_committed_space(10 * M, 4 * K, Disable);
1356     test_virtual_space_actual_committed_space(10 * M, 8 * K, Disable);
1357     test_virtual_space_actual_committed_space(10 * M, 1 * M, Disable);
1358     test_virtual_space_actual_committed_space(10 * M, 2 * M, Disable);
1359     test_virtual_space_actual_committed_space(10 * M, 5 * M, Disable);
1360     test_virtual_space_actual_committed_space(10 * M, 10 * M, Disable);
1361 
1362     test_virtual_space_actual_committed_space(10 * M, 0, Reserve);
1363     test_virtual_space_actual_committed_space(10 * M, 4 * K, Reserve);
1364     test_virtual_space_actual_committed_space(10 * M, 8 * K, Reserve);
1365     test_virtual_space_actual_committed_space(10 * M, 1 * M, Reserve);
1366     test_virtual_space_actual_committed_space(10 * M, 2 * M, Reserve);
1367     test_virtual_space_actual_committed_space(10 * M, 5 * M, Reserve);
1368     test_virtual_space_actual_committed_space(10 * M, 10 * M, Reserve);
1369 
1370     test_virtual_space_actual_committed_space(10 * M, 0, Commit);
1371     test_virtual_space_actual_committed_space(10 * M, 4 * K, Commit);
1372     test_virtual_space_actual_committed_space(10 * M, 8 * K, Commit);
1373     test_virtual_space_actual_committed_space(10 * M, 1 * M, Commit);
1374     test_virtual_space_actual_committed_space(10 * M, 2 * M, Commit);
1375     test_virtual_space_actual_committed_space(10 * M, 5 * M, Commit);
1376     test_virtual_space_actual_committed_space(10 * M, 10 * M, Commit);
1377   }
1378 
1379   static void test_virtual_space() {
1380     test_virtual_space_actual_committed_space();
1381     test_virtual_space_actual_committed_space_one_large_page();
1382     test_virtual_space_disable_large_pages();
1383   }
1384 };
1385 
1386 void TestVirtualSpace_test() {
1387   TestVirtualSpace::test_virtual_space();
1388 }
1389 
1390 #endif // PRODUCT
1391 
1392 #endif
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
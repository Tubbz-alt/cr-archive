<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/periodic/jfrThreadCPULoadEvent.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jfrPeriodic.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../recorder/storage/jfrVirtualMemory.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/periodic/jfrThreadCPULoadEvent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 70   jlong prev_user_time = tl-&gt;get_user_time();
 71 
 72   jlong cur_system_time = cur_cpu_time - cur_user_time;
 73   jlong prev_system_time = prev_cpu_time - prev_user_time;
 74 
 75   // The user and total cpu usage clocks can have different resolutions, which can
 76   // make us see decreasing system time. Ensure time doesn&#39;t go backwards.
 77   if (prev_system_time &gt; cur_system_time) {
 78     cur_cpu_time += prev_system_time - cur_system_time;
 79     cur_system_time = prev_system_time;
 80   }
 81 
 82   jlong user_time = cur_user_time - prev_user_time;
 83   jlong system_time = cur_system_time - prev_system_time;
 84   jlong wallclock_time = cur_wallclock_time - prev_wallclock_time;
 85   jlong total_available_time = wallclock_time * processor_count;
 86 
 87   // Avoid reporting percentages above the theoretical max
 88   if (user_time + system_time &gt; wallclock_time) {
 89     jlong excess = user_time + system_time - wallclock_time;

 90     if (user_time &gt; excess) {
 91       user_time -= excess;
 92       cur_user_time -= excess;
<span class="line-removed"> 93       cur_cpu_time -= excess;</span>
 94     } else {
<span class="line-removed"> 95       cur_cpu_time -= excess;</span>
 96       excess -= user_time;

 97       user_time = 0;
<span class="line-removed"> 98       cur_user_time = 0;</span>
 99       system_time -= excess;
100     }
101   }
102   event.set_user(total_available_time &gt; 0 ? (double)user_time / total_available_time : 0);
103   event.set_system(total_available_time &gt; 0 ? (double)system_time / total_available_time : 0);
104   tl-&gt;set_user_time(cur_user_time);
105   tl-&gt;set_cpu_time(cur_cpu_time);
106   return true;
107 }
108 
109 void JfrThreadCPULoadEvent::send_events() {
110   Thread* periodic_thread = Thread::current();
111   JfrThreadLocal* const periodic_thread_tl = periodic_thread-&gt;jfr_thread_local();
112   traceid periodic_thread_id = periodic_thread_tl-&gt;thread_id();
113   const int processor_count = JfrThreadCPULoadEvent::get_processor_count();
114   JfrTicks event_time = JfrTicks::now();
115   jlong cur_wallclock_time = JfrThreadCPULoadEvent::get_wallclock_time();
116 
117   JfrJavaThreadIterator iter;
118   int number_of_threads = 0;
</pre>
</td>
<td>
<hr />
<pre>
 70   jlong prev_user_time = tl-&gt;get_user_time();
 71 
 72   jlong cur_system_time = cur_cpu_time - cur_user_time;
 73   jlong prev_system_time = prev_cpu_time - prev_user_time;
 74 
 75   // The user and total cpu usage clocks can have different resolutions, which can
 76   // make us see decreasing system time. Ensure time doesn&#39;t go backwards.
 77   if (prev_system_time &gt; cur_system_time) {
 78     cur_cpu_time += prev_system_time - cur_system_time;
 79     cur_system_time = prev_system_time;
 80   }
 81 
 82   jlong user_time = cur_user_time - prev_user_time;
 83   jlong system_time = cur_system_time - prev_system_time;
 84   jlong wallclock_time = cur_wallclock_time - prev_wallclock_time;
 85   jlong total_available_time = wallclock_time * processor_count;
 86 
 87   // Avoid reporting percentages above the theoretical max
 88   if (user_time + system_time &gt; wallclock_time) {
 89     jlong excess = user_time + system_time - wallclock_time;
<span class="line-added"> 90     cur_cpu_time -= excess;</span>
 91     if (user_time &gt; excess) {
 92       user_time -= excess;
 93       cur_user_time -= excess;

 94     } else {

 95       excess -= user_time;
<span class="line-added"> 96       cur_user_time -= user_time;</span>
 97       user_time = 0;

 98       system_time -= excess;
 99     }
100   }
101   event.set_user(total_available_time &gt; 0 ? (double)user_time / total_available_time : 0);
102   event.set_system(total_available_time &gt; 0 ? (double)system_time / total_available_time : 0);
103   tl-&gt;set_user_time(cur_user_time);
104   tl-&gt;set_cpu_time(cur_cpu_time);
105   return true;
106 }
107 
108 void JfrThreadCPULoadEvent::send_events() {
109   Thread* periodic_thread = Thread::current();
110   JfrThreadLocal* const periodic_thread_tl = periodic_thread-&gt;jfr_thread_local();
111   traceid periodic_thread_id = periodic_thread_tl-&gt;thread_id();
112   const int processor_count = JfrThreadCPULoadEvent::get_processor_count();
113   JfrTicks event_time = JfrTicks::now();
114   jlong cur_wallclock_time = JfrThreadCPULoadEvent::get_wallclock_time();
115 
116   JfrJavaThreadIterator iter;
117   int number_of_threads = 0;
</pre>
</td>
</tr>
</table>
<center><a href="jfrPeriodic.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../recorder/storage/jfrVirtualMemory.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/recorder/storage/jfrVirtualMemory.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/storage/jfrVirtualMemory.hpp&quot;
 27 #include &quot;memory/virtualspace.hpp&quot;
 28 #include &quot;runtime/globals.hpp&quot;
 29 #include &quot;runtime/os.hpp&quot;
 30 #include &quot;services/memTracker.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 
 33 /*
 34  * A memory segment represents a virtual memory reservation.
 35  * It provides ways to commit and decommit physical storage
 36  * onto its virtual memory reservation.
 37  */
 38 
 39 class JfrVirtualMemorySegment : public JfrCHeapObj {
 40   friend class JfrVirtualMemoryManager;
 41  private:
 42   JfrVirtualMemorySegment* _next;
 43   char* _top;
 44   ReservedSpace _rs;
 45   VirtualSpace  _virtual_memory;
 46 
 47   // Convenience functions to access the underlying virtual space metadata
 48   const u1* committed_low()  const { return (const u1*)_virtual_memory.low(); }
 49   const u1* committed_high() const { return (const u1*)_virtual_memory.high(); }
 50   const u1* reserved_low() const { return (const u1*)_virtual_memory.low_boundary(); }
 51   const u1* reserved_high() const { return (const u1*)_virtual_memory.high_boundary(); }
 52   size_t reserved_words() const  { return _virtual_memory.reserved_size() / BytesPerWord; }
 53   size_t committed_words() const { return _virtual_memory.actual_committed_size() / BytesPerWord; }
 54   bool is_pre_committed() const { return _virtual_memory.special(); }
 55   VirtualSpace&amp; virtual_space() { return _virtual_memory; }
 56 
 57   JfrVirtualMemorySegment();
 58   ~JfrVirtualMemorySegment();
 59 
 60   JfrVirtualMemorySegment* next() const { return _next; }
 61   void set_next(JfrVirtualMemorySegment* v) { _next = v; }
 62 
 63   // Returns true if requested size is available in the committed area
 64   bool is_available(size_t block_size_request_words) {
 65     return block_size_request_words &lt;= pointer_delta(committed_high(), _top, sizeof(char*));
 66   }
 67 
 68   // allocation pointer committed memory
 69   char* top() const { return _top; }
 70   void inc_top(size_t size_in_words) {
 71     assert(is_available(size_in_words), &quot;invariant&quot;);
 72     _top += size_in_words * BytesPerWord;
 73     assert(_top &lt;= _virtual_memory.high(), &quot;invariant&quot;);
 74   }
 75 
 76   // initialization is the virtual memory reservation
 77   bool initialize(size_t reservation_size_request_bytes);
 78   void* take_from_committed(size_t block_size_request_words);
 79 
 80   // Returns committed memory
 81   void* commit(size_t block_size_request_words) {
 82     return take_from_committed(block_size_request_words);
 83   }
 84 
 85   // Commit more memory in a reservation
 86   bool expand_by(size_t block_size_request_words);
 87 
 88   // Decommits all committed memory in this reservation segment.
 89   void decommit();
 90 };
 91 
 92 JfrVirtualMemorySegment::JfrVirtualMemorySegment() :
 93   _next(NULL),
 94   _top(NULL),
 95   _rs(),
 96   _virtual_memory() {}
 97 
 98 JfrVirtualMemorySegment::~JfrVirtualMemorySegment() {
 99   decommit();
100   _rs.release();
101 }
102 
103 bool JfrVirtualMemorySegment::initialize(size_t reservation_size_request_bytes) {
104   assert(is_aligned(reservation_size_request_bytes, os::vm_allocation_granularity()), &quot;invariant&quot;);
105   _rs = ReservedSpace(reservation_size_request_bytes,
106                       os::vm_allocation_granularity(),
107                       UseLargePages &amp;&amp; os::can_commit_large_page_memory());
108   if (!_rs.is_reserved()) {
109     return false;
110   }
111   assert(_rs.base() != NULL, &quot;invariant&quot;);
112   assert(_rs.size() != 0, &quot;invariant&quot;);
113   assert(is_aligned(_rs.base(), os::vm_allocation_granularity()), &quot;invariant&quot;);
114   assert(is_aligned(_rs.size(), os::vm_allocation_granularity()), &quot;invariant&quot;);
115   os::trace_page_sizes(&quot;Jfr&quot;, reservation_size_request_bytes,
116                               reservation_size_request_bytes,
117                               os::vm_page_size(),
118                               _rs.base(),
119                               _rs.size());
120   MemTracker::record_virtual_memory_type((address)_rs.base(), mtTracing);
121   assert(is_aligned(_rs.base(), os::vm_page_size()), &quot;invariant&quot;);
122   assert(is_aligned(_rs.size(), os::vm_page_size()), &quot;invariant&quot;);
123 
124   // ReservedSpaces marked as special will have the entire memory
125   // pre-committed. Setting a committed size will make sure that
126   // committed_size and actual_committed_size agrees.
127   const size_t pre_committed_size = _rs.special() ? _rs.size() : 0;
128   const bool result = virtual_space().initialize_with_granularity(_rs, pre_committed_size, os::vm_page_size());
129 
130   if (result) {
131     assert(virtual_space().committed_size() == virtual_space().actual_committed_size(),
132       &quot;Checking that the pre-committed memory was registered by the VirtualSpace&quot;);
133     _top = virtual_space().low();
134   }
135   return result;
136 }
137 
138 bool JfrVirtualMemorySegment::expand_by(size_t block_size_request_words) {
139   size_t block_size_request_bytes = block_size_request_words * BytesPerWord;
140   const size_t uncommitted = virtual_space().reserved_size() - virtual_space().actual_committed_size();
141   if (uncommitted &lt; block_size_request_bytes) {
142     // commit whatever is left in the reservation
143     block_size_request_bytes = uncommitted;
144   }
145   assert(is_aligned(block_size_request_bytes, os::vm_allocation_granularity()), &quot;invariant&quot;);
146   // commit block in reserved memory
147   bool result = virtual_space().expand_by(block_size_request_bytes, false);
148   assert(result, &quot;Failed to commit memory&quot;);
149   return result;
150 }
151 
152 void JfrVirtualMemorySegment::decommit() {
153   assert(_virtual_memory.committed_size() == _virtual_memory.actual_committed_size(),
154     &quot;The committed memory doesn&#39;t match the expanded memory.&quot;);
155 
156   const size_t committed_size = virtual_space().actual_committed_size();
157   if (committed_size &gt; 0) {
158     virtual_space().shrink_by(committed_size);
159   }
160 
161   assert(_virtual_memory.actual_committed_size() == 0, &quot;invariant&quot;);
162 }
163 
164 // Attempt to get a committed block
165 void* JfrVirtualMemorySegment::take_from_committed(size_t block_size_request_words) {
166   // The virtual spaces are always expanded by the
167   // commit granularity to enforce the following condition.
168   // Without this the is_available check will not work correctly.
169   assert(_virtual_memory.committed_size() == _virtual_memory.actual_committed_size(),
170     &quot;The committed memory doesn&#39;t match the expanded memory.&quot;);
171   if (!is_available(block_size_request_words)) {
172     return NULL;
173   }
174   void* const block = top();
175   assert(block != NULL, &quot;invariant&quot;);
176   inc_top(block_size_request_words);
177   return block;
178 }
179 
180 class JfrVirtualMemoryManager : public JfrCHeapObj {
181  typedef JfrVirtualMemorySegment Segment;
182  private:
183   Segment* _segments;
184   Segment* _current_segment;
185   size_t _reservation_size_request_words;
186   size_t _reservation_size_request_limit_words; // total reservation limit
187 
188   // Sum of reserved and committed memory in the segments
189   size_t _current_reserved_words;
190   size_t _current_committed_words;
191 
192   void link(Segment* segment);
193   Segment* current();
194 
195   void inc_reserved_words(size_t words);
196   void inc_committed_words(size_t words);
197 
198   bool new_segment(size_t reservation_size_request_words);
199 
200   bool expand_segment_by(Segment* segment, size_t block_size_request_words);
201 
202   bool expand_by(size_t block_size_request_words, size_t reservation_size_request_words);
203   bool can_reserve() const;
204 
205  public:
206   JfrVirtualMemoryManager();
207   ~JfrVirtualMemoryManager();
208 
209   bool initialize(size_t reservation_size_request_words, size_t segment_count = 1);
210   void* commit(size_t requested_block_size_words);
211 
212   bool is_full() const {
213     return reserved_high() == committed_high();
214   }
215 
216   const u1* committed_low() const { return _current_segment-&gt;committed_low(); }
217   const u1* committed_high() const { return _current_segment-&gt;committed_high(); }
218   const u1* reserved_low() const { return _current_segment-&gt;reserved_low(); }
219   const u1* reserved_high() const { return _current_segment-&gt;reserved_high(); }
220 };
221 
222 JfrVirtualMemoryManager::JfrVirtualMemoryManager() :
223   _segments(NULL),
224   _current_segment(NULL),
225   _reservation_size_request_words(0),
226   _reservation_size_request_limit_words(0),
227   _current_reserved_words(0),
228   _current_committed_words(0) {}
229 
230 JfrVirtualMemoryManager::~JfrVirtualMemoryManager() {
231   JfrVirtualMemorySegment* segment = _segments;
232   while (segment != NULL) {
233     JfrVirtualMemorySegment* next_segment = segment-&gt;next();
234     delete segment;
235     segment = next_segment;
236   }
237 }
238 
239 // for now only allow a singleton segment per virtual memory client
240 bool JfrVirtualMemoryManager::initialize(size_t reservation_size_request_words, size_t segment_count /* 1 */) {
241   assert(is_aligned(reservation_size_request_words * BytesPerWord, os::vm_allocation_granularity()), &quot;invariant&quot;);
242   _reservation_size_request_words = reservation_size_request_words;
243   assert(segment_count &gt; 0, &quot;invariant&quot;);
244   _reservation_size_request_limit_words = reservation_size_request_words * segment_count;
245   assert(is_aligned(_reservation_size_request_limit_words * BytesPerWord, os::vm_allocation_granularity()), &quot;invariant&quot;);
246   return new_segment(_reservation_size_request_words);
247 }
248 
249 bool JfrVirtualMemoryManager::can_reserve() const  {
250   return _reservation_size_request_limit_words == 0 ? true : _current_reserved_words &lt; _reservation_size_request_limit_words;
251 }
252 
253 // Allocate another segment and add it to the list.
254 bool JfrVirtualMemoryManager::new_segment(size_t reservation_size_request_words) {
255   assert(reservation_size_request_words &gt; 0, &quot;invariant&quot;);
256   assert(is_aligned(reservation_size_request_words * BytesPerWord, os::vm_allocation_granularity()), &quot;invariant&quot;);
257   Segment* segment = new Segment();
258   if (NULL == segment) {
259     return false;
260   }
261   if (!segment-&gt;initialize(reservation_size_request_words * BytesPerWord)) {
262     delete segment;
263     return false;
264   }
265   assert(segment-&gt;reserved_words() == reservation_size_request_words,
266     &quot;Actual reserved memory size differs from requested reservation memory size&quot;);
267   link(segment);
268   return true;
269 }
270 
271 bool JfrVirtualMemoryManager::expand_segment_by(JfrVirtualMemorySegment* segment, size_t block_size_request_words) {
272   assert(segment != NULL, &quot;invariant&quot;);
273   const size_t before = segment-&gt;committed_words();
274   const bool result = segment-&gt;expand_by(block_size_request_words);
275   const size_t after = segment-&gt;committed_words();
276   // after and before can be the same if the memory was pre-committed.
277   assert(after &gt;= before, &quot;Inconsistency&quot;);
278   inc_committed_words(after - before);
279   return result;
280 }
281 
282 void JfrVirtualMemoryManager::inc_reserved_words(size_t words) {
283   _current_reserved_words += words;
284 }
285 
286 JfrVirtualMemorySegment* JfrVirtualMemoryManager::current() {
287   return _current_segment;
288 }
289 
290 void JfrVirtualMemoryManager::inc_committed_words(size_t words) {
291   _current_committed_words += words;
292 }
293 
294 bool JfrVirtualMemoryManager::expand_by(size_t block_size_request_words, size_t reservation_size_request_words) {
295   assert(is_aligned(block_size_request_words * BytesPerWord, os::vm_page_size()), &quot;invariant&quot;);
296   assert(is_aligned(block_size_request_words * BytesPerWord, os::vm_allocation_granularity()), &quot;invariant&quot;);
297   assert(is_aligned(reservation_size_request_words * BytesPerWord, os::vm_page_size()), &quot;invariant&quot;);
298   assert(is_aligned(reservation_size_request_words * BytesPerWord, os::vm_allocation_granularity()), &quot;invariant&quot;);
299   assert(block_size_request_words &lt;= reservation_size_request_words, &quot;invariant&quot;);
300   // Attempt to commit more memory from the the current virtual space reservation.
301   if (expand_segment_by(current(), block_size_request_words)) {
302     return true;
303   }
304 
305   // reached limit of what is allowed to be reserved?
306   if (!can_reserve()) {
307     return false;
308   }
309 
310   // Get another segment.
311   if (!new_segment(reservation_size_request_words)) {
312     return false;
313   }
314 
315   if (current()-&gt;is_pre_committed()) {
316     // The memory was pre-committed, so we are done here.
317     assert(block_size_request_words &lt;= current()-&gt;committed_words(),
318            &quot;The new VirtualSpace was pre-committed, so it&quot;
319            &quot;should be large enough to fit the alloc request.&quot;);
320     return true;
321   }
322   return expand_segment_by(current(), block_size_request_words);
323 }
324 
325 void JfrVirtualMemoryManager::link(JfrVirtualMemorySegment* segment) {
326   assert(segment != NULL, &quot;invariant&quot;);
327   if (_segments == NULL) {
328     _segments = segment;
329   } else {
330     assert(_current_segment != NULL, &quot;invariant&quot;);
331     assert(_segments == _current_segment, &quot;invariant&quot;);
332     _current_segment-&gt;set_next(segment);
333   }
334   _current_segment = segment;
335   inc_reserved_words(segment-&gt;reserved_words());
336   inc_committed_words(segment-&gt;committed_words());
337 }
338 
339 void* JfrVirtualMemoryManager::commit(size_t block_size_request_words) {
340   assert(is_aligned(block_size_request_words * BytesPerWord, os::vm_allocation_granularity()), &quot;invariant&quot;);
341   void* block = current()-&gt;commit(block_size_request_words);
342   if (block != NULL) {
343     return block;
344   }
345   assert(block == NULL, &quot;invariant&quot;);
346   if (is_full()) {
347     return NULL;
348   }
349   assert(block_size_request_words &lt;= _reservation_size_request_words, &quot;invariant&quot;);
350   if (expand_by(block_size_request_words, _reservation_size_request_words)) {
351     block = current()-&gt;commit(block_size_request_words);
352     assert(block != NULL, &quot;The allocation was expected to succeed after the expansion&quot;);
353   }
354   return block;
355 }
356 
357 JfrVirtualMemory::JfrVirtualMemory() :
358   _vmm(NULL),
359   _reserved_low(),
360   _reserved_high(),
361   _top(NULL),
362   _commit_point(NULL),
363   _physical_commit_size_request_words(0),
364   _aligned_datum_size_bytes(0) {}
365 
366 JfrVirtualMemory::~JfrVirtualMemory() {
367   assert(_vmm != NULL, &quot;invariant&quot;);
368   delete _vmm;
369 }
370 
371 size_t JfrVirtualMemory::aligned_datum_size_bytes() const {
372   return _aligned_datum_size_bytes;
373 }
374 
375 static void adjust_allocation_ratio(size_t* const reservation_size_bytes, size_t* const commit_size_bytes) {
376   assert(reservation_size_bytes != NULL, &quot;invariant&quot;);
377   assert(*reservation_size_bytes &gt; 0, &quot;invariant&quot;);
378   assert(commit_size_bytes != NULL, &quot;invariant&quot;);
379   assert(*commit_size_bytes &gt; 0, &quot;invariant&quot;);
380   assert(*reservation_size_bytes &gt;= *commit_size_bytes, &quot;invariant&quot;);
381   assert(is_aligned(*reservation_size_bytes, os::vm_allocation_granularity()), &quot;invariant&quot;);
382   assert(is_aligned(*commit_size_bytes, os::vm_allocation_granularity()), &quot;invariant&quot;);
383 
384   size_t reservation_size_units = *reservation_size_bytes / os::vm_allocation_granularity();
385   size_t commit_size_units = *commit_size_bytes / os::vm_allocation_granularity();
386   assert(reservation_size_units &gt; 0, &quot;invariant&quot;);
387   assert(commit_size_units &gt; 0, &quot;invariant&quot;);
388 
389   size_t original_ratio_units = reservation_size_units / commit_size_units;
390   size_t rem = reservation_size_units % commit_size_units;
391   assert(original_ratio_units &gt; 0, &quot;invariant&quot;);
392 
393   if (rem &gt; 0) {
394     reservation_size_units -= rem % original_ratio_units;
395     commit_size_units += rem / original_ratio_units;
396   }
397 
398   assert(commit_size_units &gt; 0, &quot;invariant&quot;);
399   assert(reservation_size_units % original_ratio_units == 0, &quot;invariant&quot;);
400   assert(original_ratio_units * commit_size_units == reservation_size_units , &quot;invariant&quot;);
401   assert(original_ratio_units == reservation_size_units / commit_size_units, &quot;invariant&quot;);
402   *reservation_size_bytes = reservation_size_units * os::vm_allocation_granularity();
403   *commit_size_bytes = commit_size_units * os::vm_allocation_granularity();
404   assert((*reservation_size_bytes % *commit_size_bytes) == 0, &quot;invariant&quot;);
405 }
406 
407 
408 void* JfrVirtualMemory::initialize(size_t reservation_size_request_bytes,
409                                    size_t block_size_request_bytes,
410                                    size_t datum_size_bytes /* 1 */) {
411   assert(_vmm == NULL, &quot;invariant&quot;);
412   _vmm = new JfrVirtualMemoryManager();
413 
414   if (_vmm == NULL) {
415     return NULL;
416   }
417 
418   assert(reservation_size_request_bytes &gt; 0, &quot;invariant&quot;);
419   _aligned_datum_size_bytes = align_up(datum_size_bytes, BytesPerWord);
420   assert(is_aligned(_aligned_datum_size_bytes, BytesPerWord), &quot;invariant&quot;);
421 
422   reservation_size_request_bytes = ReservedSpace::allocation_align_size_up(reservation_size_request_bytes);
423   assert(is_aligned(reservation_size_request_bytes, os::vm_allocation_granularity()), &quot;invariant&quot;);
424   assert(is_aligned(reservation_size_request_bytes, _aligned_datum_size_bytes), &quot;invariant&quot;);
425   block_size_request_bytes = MAX2(block_size_request_bytes, (size_t)os::vm_allocation_granularity());
426   block_size_request_bytes = ReservedSpace::allocation_align_size_up(block_size_request_bytes);
427   assert(is_aligned(block_size_request_bytes, os::vm_allocation_granularity()), &quot;invariant&quot;);
428   assert(is_aligned(block_size_request_bytes, _aligned_datum_size_bytes), &quot;invariant&quot;);
429   // adjustment to valid ratio in units of vm_allocation_granularity
430   adjust_allocation_ratio(&amp;reservation_size_request_bytes, &amp;block_size_request_bytes);
431   assert(is_aligned(reservation_size_request_bytes, os::vm_allocation_granularity()), &quot;invariant&quot;);
432   assert(is_aligned(reservation_size_request_bytes, _aligned_datum_size_bytes), &quot;invariant&quot;);
433   assert(is_aligned(block_size_request_bytes, os::vm_allocation_granularity()), &quot;invariant&quot;);
434   assert(is_aligned(block_size_request_bytes, _aligned_datum_size_bytes), &quot;invariant&quot;);
435   assert((reservation_size_request_bytes % block_size_request_bytes) == 0, &quot;invariant&quot;);
436   const size_t reservation_size_request_words = reservation_size_request_bytes / BytesPerWord;
437   _physical_commit_size_request_words = block_size_request_bytes / BytesPerWord;
438   // virtual memory reservation
439   if (!_vmm-&gt;initialize(reservation_size_request_words)) {
440     // is implicitly &quot;full&quot; if reservation fails
441     assert(is_full(), &quot;invariant&quot;);
442     return NULL;
443   }
444   _reserved_low = (const u1*)_vmm-&gt;reserved_low();
445   _reserved_high = (const u1*)_vmm-&gt;reserved_high();
446   // reservation complete
447   _top = (u1*)_vmm-&gt;committed_high();
448   _commit_point = _top;
449   assert(_reserved_low == _top, &quot;invariant&quot;); // initial empty state
450   assert((size_t)(_reserved_high - _reserved_low) == reservation_size_request_bytes, &quot;invariant&quot;);
451   // initial commit
452   commit_memory_block();
453   return _top;
454 }
455 
456 void* JfrVirtualMemory::commit(size_t block_size_request_words) {
457   assert(_vmm != NULL, &quot;invariant&quot;);
458   assert(is_aligned(block_size_request_words * BytesPerWord, os::vm_allocation_granularity()), &quot;invariant&quot;);
459   return _vmm-&gt;commit(block_size_request_words);
460 }
461 
462 bool JfrVirtualMemory::is_full() const {
463   return _top == _reserved_high;
464 }
465 
466 bool JfrVirtualMemory::is_empty() const {
467   return _top == _reserved_low;
468 }
469 
470 bool JfrVirtualMemory::commit_memory_block() {
471   assert(_vmm != NULL, &quot;invariant&quot;);
472   assert(!is_full(), &quot;invariant&quot;);
473   assert(_top == _commit_point, &quot;invariant&quot;);
474 
475   void* const block = _vmm-&gt;commit(_physical_commit_size_request_words);
476   if (block != NULL) {
477     _commit_point = _vmm-&gt;committed_high();
478     return true;
479   }
480   // all reserved virtual memory is committed
481   assert(block == NULL, &quot;invariant&quot;);
482   assert(_vmm-&gt;reserved_high() == _vmm-&gt;committed_high(), &quot;invariant&quot;);
483   return false;
484 }
485 
486 void* JfrVirtualMemory::new_datum() {
487   assert(_vmm != NULL, &quot;invariant&quot;);
488   assert(!is_full(), &quot;invariant&quot;);
489   if (_top == _commit_point) {
490     if (!commit_memory_block()) {
491       assert(is_full(), &quot;invariant&quot;);
492       return NULL;
493     }
494   }
495   assert(_top + _aligned_datum_size_bytes &lt;= _commit_point, &quot;invariant&quot;);
496   u1* allocation = _top;
497   _top += _aligned_datum_size_bytes;
498   assert(is_aligned(allocation, _aligned_datum_size_bytes), &quot;invariant&quot;);
499   return allocation;
500 }
501 
502 void* JfrVirtualMemory::index_ptr(size_t index) {
503   assert((index * _aligned_datum_size_bytes) + _reserved_low &lt; _commit_point, &quot;invariant&quot;);
504   return (void*)((index * _aligned_datum_size_bytes) + _reserved_low);
505 }
506 
507 void* JfrVirtualMemory::get(size_t index) {
508   return index_ptr(index);
509 }
510 
511 size_t JfrVirtualMemory::count() const {
512   return (_top - _reserved_low) / _aligned_datum_size_bytes;
513 }
514 
515 size_t JfrVirtualMemory::live_set() const {
516   return _top - _reserved_low;
517 }
518 
519 size_t JfrVirtualMemory::reserved_size() const {
520   return _reserved_high - _reserved_low;
521 }
522 
523 bool JfrVirtualMemory::compact(size_t index) {
524   assert(index &gt; 0, &quot;invariant&quot;);
525   assert(index &lt;= reserved_size(), &quot;invariant&quot;);
526   const u1* low = static_cast&lt;u1*&gt;(index_ptr(index));
527   const size_t block_size = _top - low;
528   memcpy(const_cast&lt;u1*&gt;(_reserved_low), low, block_size);
529   _top = const_cast&lt;u1*&gt;(_reserved_low) + block_size;
530   assert(live_set() == block_size, &quot;invariant&quot;);
531   return true;
532 }
    </pre>
  </body>
</html>
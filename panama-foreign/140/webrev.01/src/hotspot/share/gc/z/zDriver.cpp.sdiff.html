<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zDriver.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../shenandoah/shenandoahUtils.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zServiceability.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zDriver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
147     // Boost
148     return true;
149   }
150 
151   // Don&#39;t boost
152   return false;
153 }
154 
155 class VM_ZMarkStart : public VM_ZOperation {
156 public:
157   virtual VMOp_Type type() const {
158     return VMOp_ZMarkStart;
159   }
160 
161   virtual bool needs_inactive_gc_locker() const {
162     return true;
163   }
164 
165   virtual bool do_operation() {
166     ZStatTimer timer(ZPhasePauseMarkStart);
<span class="line-modified">167     ZServiceabilityMarkStartTracer tracer;</span>
168 
169     // Set up soft reference policy
170     const bool clear = should_clear_soft_references();
171     ZHeap::heap()-&gt;set_soft_reference_policy(clear);
172 
173     // Set up boost mode
174     const bool boost = should_boost_worker_threads();
175     ZHeap::heap()-&gt;set_boost_worker_threads(boost);
176 
177     ZCollectedHeap::heap()-&gt;increment_total_collections(true /* full */);
178 
179     ZHeap::heap()-&gt;mark_start();
180     return true;
181   }
182 };
183 
184 class VM_ZMarkEnd : public VM_ZOperation {
185 public:
186   virtual VMOp_Type type() const {
187     return VMOp_ZMarkEnd;
188   }
189 
190   virtual bool do_operation() {
191     ZStatTimer timer(ZPhasePauseMarkEnd);
<span class="line-modified">192     ZServiceabilityMarkEndTracer tracer;</span>
193     return ZHeap::heap()-&gt;mark_end();
194   }
195 };
196 
197 class VM_ZRelocateStart : public VM_ZOperation {
198 public:
199   virtual VMOp_Type type() const {
200     return VMOp_ZRelocateStart;
201   }
202 
203   virtual bool needs_inactive_gc_locker() const {
204     return true;
205   }
206 
207   virtual bool do_operation() {
208     ZStatTimer timer(ZPhasePauseRelocateStart);
<span class="line-modified">209     ZServiceabilityRelocateStartTracer tracer;</span>
210     ZHeap::heap()-&gt;relocate_start();
211     return true;
212   }
213 };
214 
215 class VM_ZVerify : public VM_Operation {
216 public:
217   virtual VMOp_Type type() const {
218     return VMOp_ZVerify;
219   }
220 
221   virtual void doit() {
222     ZVerify::after_weak_processing();
223   }
224 };
225 
226 ZDriver::ZDriver() :
227     _gc_cycle_port(),
228     _gc_locker_port() {
229   set_name(&quot;ZDriver&quot;);
</pre>
<hr />
<pre>
337 void ZDriver::concurrent_select_relocation_set() {
338   ZStatTimer timer(ZPhaseConcurrentSelectRelocationSet);
339   ZHeap::heap()-&gt;select_relocation_set();
340 }
341 
342 void ZDriver::pause_relocate_start() {
343   pause&lt;VM_ZRelocateStart&gt;();
344 }
345 
346 void ZDriver::concurrent_relocate() {
347   ZStatTimer timer(ZPhaseConcurrentRelocated);
348   ZHeap::heap()-&gt;relocate();
349 }
350 
351 void ZDriver::check_out_of_memory() {
352   ZHeap::heap()-&gt;check_out_of_memory();
353 }
354 
355 class ZDriverGCScope : public StackObj {
356 private:
<span class="line-modified">357   GCIdMark       _gc_id;</span>
<span class="line-modified">358   GCCause::Cause _gc_cause;</span>
<span class="line-modified">359   GCCauseSetter  _gc_cause_setter;</span>
<span class="line-modified">360   ZStatTimer     _timer;</span>

361 
362 public:
363   ZDriverGCScope(GCCause::Cause cause) :
364       _gc_id(),
365       _gc_cause(cause),
366       _gc_cause_setter(ZCollectedHeap::heap(), cause),
<span class="line-modified">367       _timer(ZPhaseCycle) {</span>

368     // Update statistics
369     ZStatCycle::at_start();
370   }
371 
372   ~ZDriverGCScope() {
373     // Calculate boost factor
374     const double boost_factor = (double)ZHeap::heap()-&gt;nconcurrent_worker_threads() /
375                                 (double)ZHeap::heap()-&gt;nconcurrent_no_boost_worker_threads();
376 
377     // Update statistics
378     ZStatCycle::at_end(_gc_cause, boost_factor);
379 
380     // Update data used by soft reference policy
381     Universe::update_heap_info_at_gc();
382   }
383 };
384 
385 void ZDriver::gc(GCCause::Cause cause) {
386   ZDriverGCScope scope(cause);
387 
</pre>
</td>
<td>
<hr />
<pre>
147     // Boost
148     return true;
149   }
150 
151   // Don&#39;t boost
152   return false;
153 }
154 
155 class VM_ZMarkStart : public VM_ZOperation {
156 public:
157   virtual VMOp_Type type() const {
158     return VMOp_ZMarkStart;
159   }
160 
161   virtual bool needs_inactive_gc_locker() const {
162     return true;
163   }
164 
165   virtual bool do_operation() {
166     ZStatTimer timer(ZPhasePauseMarkStart);
<span class="line-modified">167     ZServiceabilityPauseTracer tracer;</span>
168 
169     // Set up soft reference policy
170     const bool clear = should_clear_soft_references();
171     ZHeap::heap()-&gt;set_soft_reference_policy(clear);
172 
173     // Set up boost mode
174     const bool boost = should_boost_worker_threads();
175     ZHeap::heap()-&gt;set_boost_worker_threads(boost);
176 
177     ZCollectedHeap::heap()-&gt;increment_total_collections(true /* full */);
178 
179     ZHeap::heap()-&gt;mark_start();
180     return true;
181   }
182 };
183 
184 class VM_ZMarkEnd : public VM_ZOperation {
185 public:
186   virtual VMOp_Type type() const {
187     return VMOp_ZMarkEnd;
188   }
189 
190   virtual bool do_operation() {
191     ZStatTimer timer(ZPhasePauseMarkEnd);
<span class="line-modified">192     ZServiceabilityPauseTracer tracer;</span>
193     return ZHeap::heap()-&gt;mark_end();
194   }
195 };
196 
197 class VM_ZRelocateStart : public VM_ZOperation {
198 public:
199   virtual VMOp_Type type() const {
200     return VMOp_ZRelocateStart;
201   }
202 
203   virtual bool needs_inactive_gc_locker() const {
204     return true;
205   }
206 
207   virtual bool do_operation() {
208     ZStatTimer timer(ZPhasePauseRelocateStart);
<span class="line-modified">209     ZServiceabilityPauseTracer tracer;</span>
210     ZHeap::heap()-&gt;relocate_start();
211     return true;
212   }
213 };
214 
215 class VM_ZVerify : public VM_Operation {
216 public:
217   virtual VMOp_Type type() const {
218     return VMOp_ZVerify;
219   }
220 
221   virtual void doit() {
222     ZVerify::after_weak_processing();
223   }
224 };
225 
226 ZDriver::ZDriver() :
227     _gc_cycle_port(),
228     _gc_locker_port() {
229   set_name(&quot;ZDriver&quot;);
</pre>
<hr />
<pre>
337 void ZDriver::concurrent_select_relocation_set() {
338   ZStatTimer timer(ZPhaseConcurrentSelectRelocationSet);
339   ZHeap::heap()-&gt;select_relocation_set();
340 }
341 
342 void ZDriver::pause_relocate_start() {
343   pause&lt;VM_ZRelocateStart&gt;();
344 }
345 
346 void ZDriver::concurrent_relocate() {
347   ZStatTimer timer(ZPhaseConcurrentRelocated);
348   ZHeap::heap()-&gt;relocate();
349 }
350 
351 void ZDriver::check_out_of_memory() {
352   ZHeap::heap()-&gt;check_out_of_memory();
353 }
354 
355 class ZDriverGCScope : public StackObj {
356 private:
<span class="line-modified">357   GCIdMark                   _gc_id;</span>
<span class="line-modified">358   GCCause::Cause             _gc_cause;</span>
<span class="line-modified">359   GCCauseSetter              _gc_cause_setter;</span>
<span class="line-modified">360   ZStatTimer                 _timer;</span>
<span class="line-added">361   ZServiceabilityCycleTracer _tracer;</span>
362 
363 public:
364   ZDriverGCScope(GCCause::Cause cause) :
365       _gc_id(),
366       _gc_cause(cause),
367       _gc_cause_setter(ZCollectedHeap::heap(), cause),
<span class="line-modified">368       _timer(ZPhaseCycle),</span>
<span class="line-added">369       _tracer() {</span>
370     // Update statistics
371     ZStatCycle::at_start();
372   }
373 
374   ~ZDriverGCScope() {
375     // Calculate boost factor
376     const double boost_factor = (double)ZHeap::heap()-&gt;nconcurrent_worker_threads() /
377                                 (double)ZHeap::heap()-&gt;nconcurrent_no_boost_worker_threads();
378 
379     // Update statistics
380     ZStatCycle::at_end(_gc_cause, boost_factor);
381 
382     // Update data used by soft reference policy
383     Universe::update_heap_info_at_gc();
384   }
385 };
386 
387 void ZDriver::gc(GCCause::Cause cause) {
388   ZDriverGCScope scope(cause);
389 
</pre>
</td>
</tr>
</table>
<center><a href="../shenandoah/shenandoahUtils.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zServiceability.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shared/taskqueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="barrierSetNMethod.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="taskqueue.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/taskqueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,10 +26,12 @@</span>
  #define SHARE_GC_SHARED_TASKQUEUE_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/padded.hpp&quot;
  #include &quot;oops/oopsHierarchy.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;utilities/debug.hpp&quot;</span>
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
  #include &quot;utilities/stack.hpp&quot;
  
  // Simple TaskQueue stats that are collected by default in debug builds.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105,35 +107,27 @@</span>
  template &lt;unsigned int N, MEMFLAGS F&gt;
  class TaskQueueSuper: public CHeapObj&lt;F&gt; {
  protected:
    // Internal type for indexing the queue; also used for the tag.
    typedef NOT_LP64(uint16_t) LP64_ONLY(uint32_t) idx_t;
<span class="udiff-line-added">+   STATIC_ASSERT(N == idx_t(N)); // Ensure N fits in an idx_t.</span>
  
<span class="udiff-line-modified-removed">-   // The first free element after the last one pushed (mod N).</span>
<span class="udiff-line-modified-removed">-   volatile uint _bottom;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   enum { MOD_N_MASK = N - 1 };</span>
<span class="udiff-line-modified-added">+   // N must be a power of 2 for computing modulo via masking.</span>
<span class="udiff-line-modified-added">+   // N must be &gt;= 2 for the algorithm to work at all, though larger is better.</span>
<span class="udiff-line-modified-added">+   // C++11: is_power_of_2 is not (yet) constexpr.</span>
<span class="udiff-line-modified-added">+   STATIC_ASSERT((N &gt;= 2) &amp;&amp; ((N &amp; (N - 1)) == 0));</span>
<span class="udiff-line-added">+   static const uint MOD_N_MASK = N - 1;</span>
  
    class Age {
<span class="udiff-line-modified-removed">-   public:</span>
<span class="udiff-line-removed">-     Age(size_t data = 0)         { _data = data; }</span>
<span class="udiff-line-removed">-     Age(const Age&amp; age)          { _data = age._data; }</span>
<span class="udiff-line-removed">-     Age(idx_t top, idx_t tag)    { _fields._top = top; _fields._tag = tag; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Age   get()        const volatile { return _data; }</span>
<span class="udiff-line-removed">-     void  set(Age age) volatile       { _data = age._data; }</span>
<span class="udiff-line-modified-added">+     friend class TaskQueueSuper;</span>
  
<span class="udiff-line-modified-removed">-     idx_t top()        const volatile { return _fields._top; }</span>
<span class="udiff-line-modified-removed">-     idx_t tag()        const volatile { return _fields._tag; }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     // Increment top; if it wraps, increment tag also.</span>
<span class="udiff-line-removed">-     void increment() {</span>
<span class="udiff-line-removed">-       _fields._top = increment_index(_fields._top);</span>
<span class="udiff-line-removed">-       if (_fields._top == 0) ++_fields._tag;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   public:</span>
<span class="udiff-line-modified-added">+     explicit Age(size_t data = 0) : _data(data) {}</span>
<span class="udiff-line-modified-added">+     Age(idx_t top, idx_t tag) { _fields._top = top; _fields._tag = tag; }</span>
  
<span class="udiff-line-modified-removed">-     Age cmpxchg(const Age new_age, const Age old_age) volatile;</span>
<span class="udiff-line-modified-added">+     idx_t top() const { return _fields._top; }</span>
<span class="udiff-line-added">+     idx_t tag() const { return _fields._tag; }</span>
  
      bool operator ==(const Age&amp; other) const { return _data == other._data; }
  
    private:
      struct fields {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -142,13 +136,45 @@</span>
      };
      union {
        size_t _data;
        fields _fields;
      };
<span class="udiff-line-added">+     STATIC_ASSERT(sizeof(size_t) &gt;= sizeof(fields));</span>
    };
  
<span class="udiff-line-modified-removed">-   volatile Age _age;</span>
<span class="udiff-line-modified-added">+   uint bottom_relaxed() const {</span>
<span class="udiff-line-added">+     return Atomic::load(&amp;_bottom);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint bottom_acquire() const {</span>
<span class="udiff-line-added">+     return Atomic::load_acquire(&amp;_bottom);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void set_bottom_relaxed(uint new_bottom) {</span>
<span class="udiff-line-added">+     Atomic::store(&amp;_bottom, new_bottom);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void release_set_bottom(uint new_bottom) {</span>
<span class="udiff-line-added">+     Atomic::release_store(&amp;_bottom, new_bottom);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Age age_relaxed() const {</span>
<span class="udiff-line-added">+     return Age(Atomic::load(&amp;_age._data));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void set_age_relaxed(Age new_age) {</span>
<span class="udiff-line-added">+     Atomic::store(&amp;_age._data, new_age._data);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Age cmpxchg_age(Age old_age, Age new_age) {</span>
<span class="udiff-line-added">+     return Age(Atomic::cmpxchg(&amp;_age._data, old_age._data, new_age._data));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   idx_t age_top_relaxed() const {</span>
<span class="udiff-line-added">+     // Atomically accessing a subfield of an &quot;atomic&quot; member.</span>
<span class="udiff-line-added">+     return Atomic::load(&amp;_age._fields._top);</span>
<span class="udiff-line-added">+   }</span>
  
    // These both operate mod N.
    static uint increment_index(uint ind) {
      return (ind + 1) &amp; MOD_N_MASK;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161,11 +187,11 @@</span>
    uint dirty_size(uint bot, uint top) const {
      return (bot - top) &amp; MOD_N_MASK;
    }
  
    // Returns the size corresponding to the given &quot;bot&quot; and &quot;top&quot;.
<span class="udiff-line-modified-removed">-   uint size(uint bot, uint top) const {</span>
<span class="udiff-line-modified-added">+   uint clean_size(uint bot, uint top) const {</span>
      uint sz = dirty_size(bot, top);
      // Has the queue &quot;wrapped&quot;, so that bottom is less than top?  There&#39;s a
      // complicated special case here.  A pair of threads could perform pop_local
      // and pop_global operations concurrently, starting from a state in which
      // _bottom == _top+1.  The pop_local could succeed in decrementing _bottom,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -180,42 +206,58 @@</span>
      // modified by concurrent queues, so the owner thread can reset the state to
      // _bottom == top so subsequent pushes will be performed normally.
      return (sz == N - 1) ? 0 : sz;
    }
  
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Index of the first free element after the last one pushed (mod N).</span>
<span class="udiff-line-added">+   volatile uint _bottom;</span>
<span class="udiff-line-added">+   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(uint));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // top() is the index of the oldest pushed element (mod N), and tag()</span>
<span class="udiff-line-added">+   // is the associated epoch, to distinguish different modifications of</span>
<span class="udiff-line-added">+   // the age.  There is no available element if top() == _bottom or</span>
<span class="udiff-line-added">+   // (_bottom - top()) mod N == N-1; the latter indicates underflow</span>
<span class="udiff-line-added">+   // during concurrent pop_local/pop_global.</span>
<span class="udiff-line-added">+   volatile Age _age;</span>
<span class="udiff-line-added">+   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(Age));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   NONCOPYABLE(TaskQueueSuper);</span>
<span class="udiff-line-added">+ </span>
  public:
    TaskQueueSuper() : _bottom(0), _age() {}
  
<span class="udiff-line-modified-removed">-   // Return true if the TaskQueue contains/does not contain any tasks.</span>
<span class="udiff-line-modified-removed">-   bool peek()     const { return _bottom != _age.top(); }</span>
<span class="udiff-line-modified-removed">-   bool is_empty() const { return size() == 0; }</span>
<span class="udiff-line-modified-added">+   // Return true if the TaskQueue contains any tasks.</span>
<span class="udiff-line-modified-added">+   // Unreliable if there are concurrent pushes or pops.</span>
<span class="udiff-line-modified-added">+   bool peek() const {</span>
<span class="udiff-line-added">+     return bottom_relaxed() != age_top_relaxed();</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   // Return an estimate of the number of elements in the queue.</span>
<span class="udiff-line-modified-removed">-   // The &quot;careful&quot; version admits the possibility of pop_local/pop_global</span>
<span class="udiff-line-removed">-   // races.</span>
<span class="udiff-line-removed">-   uint size() const {</span>
<span class="udiff-line-removed">-     return size(_bottom, _age.top());</span>
<span class="udiff-line-modified-added">+   bool is_empty() const {</span>
<span class="udiff-line-modified-added">+     return size() == 0;</span>
    }
  
<span class="udiff-line-modified-removed">-   uint dirty_size() const {</span>
<span class="udiff-line-modified-removed">-     return dirty_size(_bottom, _age.top());</span>
<span class="udiff-line-modified-added">+   // Return an estimate of the number of elements in the queue.</span>
<span class="udiff-line-modified-added">+   // Treats pop_local/pop_global race that underflows as empty.</span>
<span class="udiff-line-added">+   uint size() const {</span>
<span class="udiff-line-added">+     return clean_size(bottom_relaxed(), age_top_relaxed());</span>
    }
  
<span class="udiff-line-added">+   // Discard the contents of the queue.</span>
    void set_empty() {
<span class="udiff-line-modified-removed">-     _bottom = 0;</span>
<span class="udiff-line-modified-removed">-     _age.set(0);</span>
<span class="udiff-line-modified-added">+     set_bottom_relaxed(0);</span>
<span class="udiff-line-modified-added">+     set_age_relaxed(Age());</span>
    }
  
    // Maximum number of elements allowed in the queue.  This is two less
    // than the actual queue size, so that a full queue can be distinguished
    // from underflow involving pop_local and concurrent pop_global operations
    // in GenericTaskQueue.
    uint max_elems() const { return N - 2; }
  
<span class="udiff-line-removed">-   // Total size of queue.</span>
<span class="udiff-line-removed">-   static const uint total_size() { return N; }</span>
<span class="udiff-line-removed">- </span>
    TASKQUEUE_STATS_ONLY(TaskQueueStats stats;)
  };
  
  //
  // GenericTaskQueue implements an ABP, Aurora-Blumofe-Plaxton, double-
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -252,15 +294,27 @@</span>
  class GenericTaskQueue: public TaskQueueSuper&lt;N, F&gt; {
  protected:
    typedef typename TaskQueueSuper&lt;N, F&gt;::Age Age;
    typedef typename TaskQueueSuper&lt;N, F&gt;::idx_t idx_t;
  
<span class="udiff-line-modified-removed">-   using TaskQueueSuper&lt;N, F&gt;::_bottom;</span>
<span class="udiff-line-modified-removed">-   using TaskQueueSuper&lt;N, F&gt;::_age;</span>
<span class="udiff-line-modified-added">+   using TaskQueueSuper&lt;N, F&gt;::MOD_N_MASK;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   using TaskQueueSuper&lt;N, F&gt;::bottom_relaxed;</span>
<span class="udiff-line-added">+   using TaskQueueSuper&lt;N, F&gt;::bottom_acquire;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   using TaskQueueSuper&lt;N, F&gt;::set_bottom_relaxed;</span>
<span class="udiff-line-added">+   using TaskQueueSuper&lt;N, F&gt;::release_set_bottom;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   using TaskQueueSuper&lt;N, F&gt;::age_relaxed;</span>
<span class="udiff-line-added">+   using TaskQueueSuper&lt;N, F&gt;::set_age_relaxed;</span>
<span class="udiff-line-added">+   using TaskQueueSuper&lt;N, F&gt;::cmpxchg_age;</span>
<span class="udiff-line-added">+   using TaskQueueSuper&lt;N, F&gt;::age_top_relaxed;</span>
<span class="udiff-line-added">+ </span>
    using TaskQueueSuper&lt;N, F&gt;::increment_index;
    using TaskQueueSuper&lt;N, F&gt;::decrement_index;
    using TaskQueueSuper&lt;N, F&gt;::dirty_size;
<span class="udiff-line-added">+   using TaskQueueSuper&lt;N, F&gt;::clean_size;</span>
  
  public:
    using TaskQueueSuper&lt;N, F&gt;::max_elems;
    using TaskQueueSuper&lt;N, F&gt;::size;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -283,29 +337,31 @@</span>
    // Push the task &quot;t&quot; on the queue.  Returns &quot;false&quot; iff the queue is full.
    inline bool push(E t);
  
    // Attempts to claim a task from the &quot;local&quot; end of the queue (the most
    // recently pushed) as long as the number of entries exceeds the threshold.
<span class="udiff-line-modified-removed">-   // If successful, returns true and sets t to the task; otherwise, returns false</span>
<span class="udiff-line-modified-removed">-   // (the queue is empty or the number of elements below the threshold).</span>
<span class="udiff-line-modified-removed">-   inline bool pop_local(volatile E&amp; t, uint threshold = 0);</span>
<span class="udiff-line-modified-added">+   // If successfully claims a task, returns true and sets t to the task;</span>
<span class="udiff-line-modified-added">+   // otherwise, returns false and t is unspecified.  May fail and return</span>
<span class="udiff-line-modified-added">+   // false because of a successful steal by pop_global.</span>
<span class="udiff-line-added">+   inline bool pop_local(E&amp; t, uint threshold = 0);</span>
  
    // Like pop_local(), but uses the &quot;global&quot; end of the queue (the least
    // recently pushed).
<span class="udiff-line-modified-removed">-   bool pop_global(volatile E&amp; t);</span>
<span class="udiff-line-modified-added">+   bool pop_global(E&amp; t);</span>
  
    // Delete any resource associated with the queue.
    ~GenericTaskQueue();
  
    // Apply fn to each element in the task queue.  The queue must not
    // be modified while iterating.
    template&lt;typename Fn&gt; void iterate(Fn fn);
  
  private:
<span class="udiff-line-modified-removed">-   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);</span>
<span class="udiff-line-modified-added">+   // Base class has trailing padding.</span>
<span class="udiff-line-added">+ </span>
    // Element array.
<span class="udiff-line-modified-removed">-   volatile E* _elems;</span>
<span class="udiff-line-modified-added">+   E* _elems;</span>
  
    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(E*));
    // Queue owner local variables. Not to be accessed by other threads.
  
    static const uint InvalidQueueId = uint(-1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -442,16 +498,10 @@</span>
  class TerminatorTerminator: public CHeapObj&lt;mtInternal&gt; {
  public:
    virtual bool should_exit_termination() = 0;
  };
  
<span class="udiff-line-removed">- #ifdef _MSC_VER</span>
<span class="udiff-line-removed">- #pragma warning(push)</span>
<span class="udiff-line-removed">- // warning C4522: multiple assignment operators specified</span>
<span class="udiff-line-removed">- #pragma warning(disable:4522)</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  // This is a container class for either an oop* or a narrowOop*.
  // Both are pushed onto a task queue and the consumer will test is_narrow()
  // to determine which should be processed.
  class StarTask {
    void*  _holder;        // either union oop* or narrowOop*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -466,24 +516,17 @@</span>
    StarTask(oop* p)       {
      assert(((uintptr_t)p &amp; COMPRESSED_OOP_MASK) == 0, &quot;Information loss!&quot;);
      _holder = (void*)p;
    }
    StarTask()             { _holder = NULL; }
<span class="udiff-line-added">+   // Trivially copyable, for use in GenericTaskQueue.</span>
<span class="udiff-line-added">+ </span>
    operator oop*()        { return (oop*)_holder; }
    operator narrowOop*()  {
      return (narrowOop*)((uintptr_t)_holder &amp; ~COMPRESSED_OOP_MASK);
    }
  
<span class="udiff-line-removed">-   StarTask&amp; operator=(const StarTask&amp; t) {</span>
<span class="udiff-line-removed">-     _holder = t._holder;</span>
<span class="udiff-line-removed">-     return *this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   volatile StarTask&amp; operator=(const volatile StarTask&amp; t) volatile {</span>
<span class="udiff-line-removed">-     _holder = t._holder;</span>
<span class="udiff-line-removed">-     return *this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    bool is_narrow() const {
      return (((uintptr_t)_holder &amp; COMPRESSED_OOP_MASK) != 0);
    }
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -492,23 +535,11 @@</span>
  public:
    ObjArrayTask(oop o = NULL, int idx = 0): _obj(o), _index(idx) { }
    ObjArrayTask(oop o, size_t idx): _obj(o), _index(int(idx)) {
      assert(idx &lt;= size_t(max_jint), &quot;too big&quot;);
    }
<span class="udiff-line-modified-removed">-   ObjArrayTask(const ObjArrayTask&amp; t): _obj(t._obj), _index(t._index) { }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ObjArrayTask&amp; operator =(const ObjArrayTask&amp; t) {</span>
<span class="udiff-line-removed">-     _obj = t._obj;</span>
<span class="udiff-line-removed">-     _index = t._index;</span>
<span class="udiff-line-removed">-     return *this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   volatile ObjArrayTask&amp;</span>
<span class="udiff-line-removed">-   operator =(const volatile ObjArrayTask&amp; t) volatile {</span>
<span class="udiff-line-removed">-     (void)const_cast&lt;oop&amp;&gt;(_obj = t._obj);</span>
<span class="udiff-line-removed">-     _index = t._index;</span>
<span class="udiff-line-removed">-     return *this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   // Trivially copyable, for use in GenericTaskQueue.</span>
  
    inline oop obj()   const { return _obj; }
    inline int index() const { return _index; }
  
    DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -516,10 +547,6 @@</span>
  private:
    oop _obj;
    int _index;
  };
  
<span class="udiff-line-removed">- #ifdef _MSC_VER</span>
<span class="udiff-line-removed">- #pragma warning(pop)</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  #endif // SHARE_GC_SHARED_TASKQUEUE_HPP
</pre>
<center><a href="barrierSetNMethod.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="taskqueue.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
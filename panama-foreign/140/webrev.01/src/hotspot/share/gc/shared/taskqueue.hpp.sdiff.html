<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/taskqueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="barrierSetNMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="taskqueue.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/taskqueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_TASKQUEUE_HPP
 26 #define SHARE_GC_SHARED_TASKQUEUE_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/padded.hpp&quot;
 30 #include &quot;oops/oopsHierarchy.hpp&quot;


 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 #include &quot;utilities/stack.hpp&quot;
 34 
 35 // Simple TaskQueue stats that are collected by default in debug builds.
 36 
 37 #if !defined(TASKQUEUE_STATS) &amp;&amp; defined(ASSERT)
 38 #define TASKQUEUE_STATS 1
 39 #elif !defined(TASKQUEUE_STATS)
 40 #define TASKQUEUE_STATS 0
 41 #endif
 42 
 43 #if TASKQUEUE_STATS
 44 #define TASKQUEUE_STATS_ONLY(code) code
 45 #else
 46 #define TASKQUEUE_STATS_ONLY(code)
 47 #endif // TASKQUEUE_STATS
 48 
 49 #if TASKQUEUE_STATS
 50 class TaskQueueStats {
</pre>
<hr />
<pre>
 90   static const char * const _names[last_stat_id];
 91 };
 92 
 93 void TaskQueueStats::record_overflow(size_t new_len) {
 94   ++_stats[overflow];
 95   if (new_len &gt; _stats[overflow_max_len]) _stats[overflow_max_len] = new_len;
 96 }
 97 
 98 void TaskQueueStats::reset() {
 99   memset(_stats, 0, sizeof(_stats));
100 }
101 #endif // TASKQUEUE_STATS
102 
103 // TaskQueueSuper collects functionality common to all GenericTaskQueue instances.
104 
105 template &lt;unsigned int N, MEMFLAGS F&gt;
106 class TaskQueueSuper: public CHeapObj&lt;F&gt; {
107 protected:
108   // Internal type for indexing the queue; also used for the tag.
109   typedef NOT_LP64(uint16_t) LP64_ONLY(uint32_t) idx_t;

110 
<span class="line-modified">111   // The first free element after the last one pushed (mod N).</span>
<span class="line-modified">112   volatile uint _bottom;</span>
<span class="line-modified">113 </span>
<span class="line-modified">114   enum { MOD_N_MASK = N - 1 };</span>

115 
116   class Age {
<span class="line-modified">117   public:</span>
<span class="line-removed">118     Age(size_t data = 0)         { _data = data; }</span>
<span class="line-removed">119     Age(const Age&amp; age)          { _data = age._data; }</span>
<span class="line-removed">120     Age(idx_t top, idx_t tag)    { _fields._top = top; _fields._tag = tag; }</span>
<span class="line-removed">121 </span>
<span class="line-removed">122     Age   get()        const volatile { return _data; }</span>
<span class="line-removed">123     void  set(Age age) volatile       { _data = age._data; }</span>
124 
<span class="line-modified">125     idx_t top()        const volatile { return _fields._top; }</span>
<span class="line-modified">126     idx_t tag()        const volatile { return _fields._tag; }</span>
<span class="line-modified">127 </span>
<span class="line-removed">128     // Increment top; if it wraps, increment tag also.</span>
<span class="line-removed">129     void increment() {</span>
<span class="line-removed">130       _fields._top = increment_index(_fields._top);</span>
<span class="line-removed">131       if (_fields._top == 0) ++_fields._tag;</span>
<span class="line-removed">132     }</span>
133 
<span class="line-modified">134     Age cmpxchg(const Age new_age, const Age old_age) volatile;</span>

135 
136     bool operator ==(const Age&amp; other) const { return _data == other._data; }
137 
138   private:
139     struct fields {
140       idx_t _top;
141       idx_t _tag;
142     };
143     union {
144       size_t _data;
145       fields _fields;
146     };

147   };
148 
<span class="line-modified">149   volatile Age _age;</span>































150 
151   // These both operate mod N.
152   static uint increment_index(uint ind) {
153     return (ind + 1) &amp; MOD_N_MASK;
154   }
155   static uint decrement_index(uint ind) {
156     return (ind - 1) &amp; MOD_N_MASK;
157   }
158 
159   // Returns a number in the range [0..N).  If the result is &quot;N-1&quot;, it should be
160   // interpreted as 0.
161   uint dirty_size(uint bot, uint top) const {
162     return (bot - top) &amp; MOD_N_MASK;
163   }
164 
165   // Returns the size corresponding to the given &quot;bot&quot; and &quot;top&quot;.
<span class="line-modified">166   uint size(uint bot, uint top) const {</span>
167     uint sz = dirty_size(bot, top);
168     // Has the queue &quot;wrapped&quot;, so that bottom is less than top?  There&#39;s a
169     // complicated special case here.  A pair of threads could perform pop_local
170     // and pop_global operations concurrently, starting from a state in which
171     // _bottom == _top+1.  The pop_local could succeed in decrementing _bottom,
172     // and the pop_global in incrementing _top (in which case the pop_global
173     // will be awarded the contested queue element.)  The resulting state must
174     // be interpreted as an empty queue.  (We only need to worry about one such
175     // event: only the queue owner performs pop_local&#39;s, and several concurrent
176     // threads attempting to perform the pop_global will all perform the same
177     // CAS, and only one can succeed.)  Any stealing thread that reads after
178     // either the increment or decrement will see an empty queue, and will not
179     // join the competitors.  The &quot;sz == -1 || sz == N-1&quot; state will not be
180     // modified by concurrent queues, so the owner thread can reset the state to
181     // _bottom == top so subsequent pushes will be performed normally.
182     return (sz == N - 1) ? 0 : sz;
183   }
184 

















185 public:
186   TaskQueueSuper() : _bottom(0), _age() {}
187 
<span class="line-modified">188   // Return true if the TaskQueue contains/does not contain any tasks.</span>
<span class="line-modified">189   bool peek()     const { return _bottom != _age.top(); }</span>
<span class="line-modified">190   bool is_empty() const { return size() == 0; }</span>


191 
<span class="line-modified">192   // Return an estimate of the number of elements in the queue.</span>
<span class="line-modified">193   // The &quot;careful&quot; version admits the possibility of pop_local/pop_global</span>
<span class="line-removed">194   // races.</span>
<span class="line-removed">195   uint size() const {</span>
<span class="line-removed">196     return size(_bottom, _age.top());</span>
197   }
198 
<span class="line-modified">199   uint dirty_size() const {</span>
<span class="line-modified">200     return dirty_size(_bottom, _age.top());</span>


201   }
202 

203   void set_empty() {
<span class="line-modified">204     _bottom = 0;</span>
<span class="line-modified">205     _age.set(0);</span>
206   }
207 
208   // Maximum number of elements allowed in the queue.  This is two less
209   // than the actual queue size, so that a full queue can be distinguished
210   // from underflow involving pop_local and concurrent pop_global operations
211   // in GenericTaskQueue.
212   uint max_elems() const { return N - 2; }
213 
<span class="line-removed">214   // Total size of queue.</span>
<span class="line-removed">215   static const uint total_size() { return N; }</span>
<span class="line-removed">216 </span>
217   TASKQUEUE_STATS_ONLY(TaskQueueStats stats;)
218 };
219 
220 //
221 // GenericTaskQueue implements an ABP, Aurora-Blumofe-Plaxton, double-
222 // ended-queue (deque), intended for use in work stealing. Queue operations
223 // are non-blocking.
224 //
225 // A queue owner thread performs push() and pop_local() operations on one end
226 // of the queue, while other threads may steal work using the pop_global()
227 // method.
228 //
229 // The main difference to the original algorithm is that this
230 // implementation allows wrap-around at the end of its allocated
231 // storage, which is an array.
232 //
233 // The original paper is:
234 //
235 // Arora, N. S., Blumofe, R. D., and Plaxton, C. G.
236 // Thread scheduling for multiprogrammed multiprocessors.
237 // Theory of Computing Systems 34, 2 (2001), 115-144.
238 //
239 // The following paper provides an correctness proof and an
240 // implementation for weakly ordered memory models including (pseudo-)
241 // code containing memory barriers for a Chase-Lev deque. Chase-Lev is
242 // similar to ABP, with the main difference that it allows resizing of the
243 // underlying storage:
244 //
245 // Le, N. M., Pop, A., Cohen A., and Nardell, F. Z.
246 // Correct and efficient work-stealing for weak memory models
247 // Proceedings of the 18th ACM SIGPLAN symposium on Principles and
248 // practice of parallel programming (PPoPP 2013), 69-80
249 //
250 
251 template &lt;class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE&gt;
252 class GenericTaskQueue: public TaskQueueSuper&lt;N, F&gt; {
253 protected:
254   typedef typename TaskQueueSuper&lt;N, F&gt;::Age Age;
255   typedef typename TaskQueueSuper&lt;N, F&gt;::idx_t idx_t;
256 
<span class="line-modified">257   using TaskQueueSuper&lt;N, F&gt;::_bottom;</span>
<span class="line-modified">258   using TaskQueueSuper&lt;N, F&gt;::_age;</span>











259   using TaskQueueSuper&lt;N, F&gt;::increment_index;
260   using TaskQueueSuper&lt;N, F&gt;::decrement_index;
261   using TaskQueueSuper&lt;N, F&gt;::dirty_size;

262 
263 public:
264   using TaskQueueSuper&lt;N, F&gt;::max_elems;
265   using TaskQueueSuper&lt;N, F&gt;::size;
266 
267 #if  TASKQUEUE_STATS
268   using TaskQueueSuper&lt;N, F&gt;::stats;
269 #endif
270 
271 private:
272   // Slow path for pop_local, dealing with possible conflict with pop_global.
273   bool pop_local_slow(uint localBot, Age oldAge);
274 
275 public:
276   typedef E element_type;
277 
278   // Initializes the queue to empty.
279   GenericTaskQueue();
280 
281   void initialize();
282 
283   // Push the task &quot;t&quot; on the queue.  Returns &quot;false&quot; iff the queue is full.
284   inline bool push(E t);
285 
286   // Attempts to claim a task from the &quot;local&quot; end of the queue (the most
287   // recently pushed) as long as the number of entries exceeds the threshold.
<span class="line-modified">288   // If successful, returns true and sets t to the task; otherwise, returns false</span>
<span class="line-modified">289   // (the queue is empty or the number of elements below the threshold).</span>
<span class="line-modified">290   inline bool pop_local(volatile E&amp; t, uint threshold = 0);</span>

291 
292   // Like pop_local(), but uses the &quot;global&quot; end of the queue (the least
293   // recently pushed).
<span class="line-modified">294   bool pop_global(volatile E&amp; t);</span>
295 
296   // Delete any resource associated with the queue.
297   ~GenericTaskQueue();
298 
299   // Apply fn to each element in the task queue.  The queue must not
300   // be modified while iterating.
301   template&lt;typename Fn&gt; void iterate(Fn fn);
302 
303 private:
<span class="line-modified">304   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);</span>

305   // Element array.
<span class="line-modified">306   volatile E* _elems;</span>
307 
308   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(E*));
309   // Queue owner local variables. Not to be accessed by other threads.
310 
311   static const uint InvalidQueueId = uint(-1);
312   uint _last_stolen_queue_id; // The id of the queue we last stole from
313 
314   int _seed; // Current random seed used for selecting a random queue during stealing.
315 
316   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(uint) + sizeof(int));
317 public:
318   int next_random_queue_id();
319 
320   void set_last_stolen_queue_id(uint id)     { _last_stolen_queue_id = id; }
321   uint last_stolen_queue_id() const          { return _last_stolen_queue_id; }
322   bool is_last_stolen_queue_id_valid() const { return _last_stolen_queue_id != InvalidQueueId; }
323   void invalidate_last_stolen_queue_id()     { _last_stolen_queue_id = InvalidQueueId; }
324 };
325 
326 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
</pre>
<hr />
<pre>
427       return true;
428   }
429   return false;
430 }
431 
432 template&lt;class T, MEMFLAGS F&gt;
433 uint GenericTaskQueueSet&lt;T, F&gt;::tasks() const {
434   uint n = 0;
435   for (uint j = 0; j &lt; _n; j++) {
436     n += _queues[j]-&gt;size();
437   }
438   return n;
439 }
440 
441 // When to terminate from the termination protocol.
442 class TerminatorTerminator: public CHeapObj&lt;mtInternal&gt; {
443 public:
444   virtual bool should_exit_termination() = 0;
445 };
446 
<span class="line-removed">447 #ifdef _MSC_VER</span>
<span class="line-removed">448 #pragma warning(push)</span>
<span class="line-removed">449 // warning C4522: multiple assignment operators specified</span>
<span class="line-removed">450 #pragma warning(disable:4522)</span>
<span class="line-removed">451 #endif</span>
<span class="line-removed">452 </span>
453 // This is a container class for either an oop* or a narrowOop*.
454 // Both are pushed onto a task queue and the consumer will test is_narrow()
455 // to determine which should be processed.
456 class StarTask {
457   void*  _holder;        // either union oop* or narrowOop*
458 
459   enum { COMPRESSED_OOP_MASK = 1 };
460 
461  public:
462   StarTask(narrowOop* p) {
463     assert(((uintptr_t)p &amp; COMPRESSED_OOP_MASK) == 0, &quot;Information loss!&quot;);
464     _holder = (void *)((uintptr_t)p | COMPRESSED_OOP_MASK);
465   }
466   StarTask(oop* p)       {
467     assert(((uintptr_t)p &amp; COMPRESSED_OOP_MASK) == 0, &quot;Information loss!&quot;);
468     _holder = (void*)p;
469   }
470   StarTask()             { _holder = NULL; }


471   operator oop*()        { return (oop*)_holder; }
472   operator narrowOop*()  {
473     return (narrowOop*)((uintptr_t)_holder &amp; ~COMPRESSED_OOP_MASK);
474   }
475 
<span class="line-removed">476   StarTask&amp; operator=(const StarTask&amp; t) {</span>
<span class="line-removed">477     _holder = t._holder;</span>
<span class="line-removed">478     return *this;</span>
<span class="line-removed">479   }</span>
<span class="line-removed">480   volatile StarTask&amp; operator=(const volatile StarTask&amp; t) volatile {</span>
<span class="line-removed">481     _holder = t._holder;</span>
<span class="line-removed">482     return *this;</span>
<span class="line-removed">483   }</span>
<span class="line-removed">484 </span>
485   bool is_narrow() const {
486     return (((uintptr_t)_holder &amp; COMPRESSED_OOP_MASK) != 0);
487   }
488 };
489 
490 class ObjArrayTask
491 {
492 public:
493   ObjArrayTask(oop o = NULL, int idx = 0): _obj(o), _index(idx) { }
494   ObjArrayTask(oop o, size_t idx): _obj(o), _index(int(idx)) {
495     assert(idx &lt;= size_t(max_jint), &quot;too big&quot;);
496   }
<span class="line-modified">497   ObjArrayTask(const ObjArrayTask&amp; t): _obj(t._obj), _index(t._index) { }</span>
<span class="line-removed">498 </span>
<span class="line-removed">499   ObjArrayTask&amp; operator =(const ObjArrayTask&amp; t) {</span>
<span class="line-removed">500     _obj = t._obj;</span>
<span class="line-removed">501     _index = t._index;</span>
<span class="line-removed">502     return *this;</span>
<span class="line-removed">503   }</span>
<span class="line-removed">504   volatile ObjArrayTask&amp;</span>
<span class="line-removed">505   operator =(const volatile ObjArrayTask&amp; t) volatile {</span>
<span class="line-removed">506     (void)const_cast&lt;oop&amp;&gt;(_obj = t._obj);</span>
<span class="line-removed">507     _index = t._index;</span>
<span class="line-removed">508     return *this;</span>
<span class="line-removed">509   }</span>
510 
511   inline oop obj()   const { return _obj; }
512   inline int index() const { return _index; }
513 
514   DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
515 
516 private:
517   oop _obj;
518   int _index;
519 };
520 
<span class="line-removed">521 #ifdef _MSC_VER</span>
<span class="line-removed">522 #pragma warning(pop)</span>
<span class="line-removed">523 #endif</span>
<span class="line-removed">524 </span>
525 #endif // SHARE_GC_SHARED_TASKQUEUE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_TASKQUEUE_HPP
 26 #define SHARE_GC_SHARED_TASKQUEUE_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/padded.hpp&quot;
 30 #include &quot;oops/oopsHierarchy.hpp&quot;
<span class="line-added"> 31 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;utilities/debug.hpp&quot;</span>
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 #include &quot;utilities/stack.hpp&quot;
 36 
 37 // Simple TaskQueue stats that are collected by default in debug builds.
 38 
 39 #if !defined(TASKQUEUE_STATS) &amp;&amp; defined(ASSERT)
 40 #define TASKQUEUE_STATS 1
 41 #elif !defined(TASKQUEUE_STATS)
 42 #define TASKQUEUE_STATS 0
 43 #endif
 44 
 45 #if TASKQUEUE_STATS
 46 #define TASKQUEUE_STATS_ONLY(code) code
 47 #else
 48 #define TASKQUEUE_STATS_ONLY(code)
 49 #endif // TASKQUEUE_STATS
 50 
 51 #if TASKQUEUE_STATS
 52 class TaskQueueStats {
</pre>
<hr />
<pre>
 92   static const char * const _names[last_stat_id];
 93 };
 94 
 95 void TaskQueueStats::record_overflow(size_t new_len) {
 96   ++_stats[overflow];
 97   if (new_len &gt; _stats[overflow_max_len]) _stats[overflow_max_len] = new_len;
 98 }
 99 
100 void TaskQueueStats::reset() {
101   memset(_stats, 0, sizeof(_stats));
102 }
103 #endif // TASKQUEUE_STATS
104 
105 // TaskQueueSuper collects functionality common to all GenericTaskQueue instances.
106 
107 template &lt;unsigned int N, MEMFLAGS F&gt;
108 class TaskQueueSuper: public CHeapObj&lt;F&gt; {
109 protected:
110   // Internal type for indexing the queue; also used for the tag.
111   typedef NOT_LP64(uint16_t) LP64_ONLY(uint32_t) idx_t;
<span class="line-added">112   STATIC_ASSERT(N == idx_t(N)); // Ensure N fits in an idx_t.</span>
113 
<span class="line-modified">114   // N must be a power of 2 for computing modulo via masking.</span>
<span class="line-modified">115   // N must be &gt;= 2 for the algorithm to work at all, though larger is better.</span>
<span class="line-modified">116   // C++11: is_power_of_2 is not (yet) constexpr.</span>
<span class="line-modified">117   STATIC_ASSERT((N &gt;= 2) &amp;&amp; ((N &amp; (N - 1)) == 0));</span>
<span class="line-added">118   static const uint MOD_N_MASK = N - 1;</span>
119 
120   class Age {
<span class="line-modified">121     friend class TaskQueueSuper;</span>






122 
<span class="line-modified">123   public:</span>
<span class="line-modified">124     explicit Age(size_t data = 0) : _data(data) {}</span>
<span class="line-modified">125     Age(idx_t top, idx_t tag) { _fields._top = top; _fields._tag = tag; }</span>





126 
<span class="line-modified">127     idx_t top() const { return _fields._top; }</span>
<span class="line-added">128     idx_t tag() const { return _fields._tag; }</span>
129 
130     bool operator ==(const Age&amp; other) const { return _data == other._data; }
131 
132   private:
133     struct fields {
134       idx_t _top;
135       idx_t _tag;
136     };
137     union {
138       size_t _data;
139       fields _fields;
140     };
<span class="line-added">141     STATIC_ASSERT(sizeof(size_t) &gt;= sizeof(fields));</span>
142   };
143 
<span class="line-modified">144   uint bottom_relaxed() const {</span>
<span class="line-added">145     return Atomic::load(&amp;_bottom);</span>
<span class="line-added">146   }</span>
<span class="line-added">147 </span>
<span class="line-added">148   uint bottom_acquire() const {</span>
<span class="line-added">149     return Atomic::load_acquire(&amp;_bottom);</span>
<span class="line-added">150   }</span>
<span class="line-added">151 </span>
<span class="line-added">152   void set_bottom_relaxed(uint new_bottom) {</span>
<span class="line-added">153     Atomic::store(&amp;_bottom, new_bottom);</span>
<span class="line-added">154   }</span>
<span class="line-added">155 </span>
<span class="line-added">156   void release_set_bottom(uint new_bottom) {</span>
<span class="line-added">157     Atomic::release_store(&amp;_bottom, new_bottom);</span>
<span class="line-added">158   }</span>
<span class="line-added">159 </span>
<span class="line-added">160   Age age_relaxed() const {</span>
<span class="line-added">161     return Age(Atomic::load(&amp;_age._data));</span>
<span class="line-added">162   }</span>
<span class="line-added">163 </span>
<span class="line-added">164   void set_age_relaxed(Age new_age) {</span>
<span class="line-added">165     Atomic::store(&amp;_age._data, new_age._data);</span>
<span class="line-added">166   }</span>
<span class="line-added">167 </span>
<span class="line-added">168   Age cmpxchg_age(Age old_age, Age new_age) {</span>
<span class="line-added">169     return Age(Atomic::cmpxchg(&amp;_age._data, old_age._data, new_age._data));</span>
<span class="line-added">170   }</span>
<span class="line-added">171 </span>
<span class="line-added">172   idx_t age_top_relaxed() const {</span>
<span class="line-added">173     // Atomically accessing a subfield of an &quot;atomic&quot; member.</span>
<span class="line-added">174     return Atomic::load(&amp;_age._fields._top);</span>
<span class="line-added">175   }</span>
176 
177   // These both operate mod N.
178   static uint increment_index(uint ind) {
179     return (ind + 1) &amp; MOD_N_MASK;
180   }
181   static uint decrement_index(uint ind) {
182     return (ind - 1) &amp; MOD_N_MASK;
183   }
184 
185   // Returns a number in the range [0..N).  If the result is &quot;N-1&quot;, it should be
186   // interpreted as 0.
187   uint dirty_size(uint bot, uint top) const {
188     return (bot - top) &amp; MOD_N_MASK;
189   }
190 
191   // Returns the size corresponding to the given &quot;bot&quot; and &quot;top&quot;.
<span class="line-modified">192   uint clean_size(uint bot, uint top) const {</span>
193     uint sz = dirty_size(bot, top);
194     // Has the queue &quot;wrapped&quot;, so that bottom is less than top?  There&#39;s a
195     // complicated special case here.  A pair of threads could perform pop_local
196     // and pop_global operations concurrently, starting from a state in which
197     // _bottom == _top+1.  The pop_local could succeed in decrementing _bottom,
198     // and the pop_global in incrementing _top (in which case the pop_global
199     // will be awarded the contested queue element.)  The resulting state must
200     // be interpreted as an empty queue.  (We only need to worry about one such
201     // event: only the queue owner performs pop_local&#39;s, and several concurrent
202     // threads attempting to perform the pop_global will all perform the same
203     // CAS, and only one can succeed.)  Any stealing thread that reads after
204     // either the increment or decrement will see an empty queue, and will not
205     // join the competitors.  The &quot;sz == -1 || sz == N-1&quot; state will not be
206     // modified by concurrent queues, so the owner thread can reset the state to
207     // _bottom == top so subsequent pushes will be performed normally.
208     return (sz == N - 1) ? 0 : sz;
209   }
210 
<span class="line-added">211 private:</span>
<span class="line-added">212   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);</span>
<span class="line-added">213 </span>
<span class="line-added">214   // Index of the first free element after the last one pushed (mod N).</span>
<span class="line-added">215   volatile uint _bottom;</span>
<span class="line-added">216   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(uint));</span>
<span class="line-added">217 </span>
<span class="line-added">218   // top() is the index of the oldest pushed element (mod N), and tag()</span>
<span class="line-added">219   // is the associated epoch, to distinguish different modifications of</span>
<span class="line-added">220   // the age.  There is no available element if top() == _bottom or</span>
<span class="line-added">221   // (_bottom - top()) mod N == N-1; the latter indicates underflow</span>
<span class="line-added">222   // during concurrent pop_local/pop_global.</span>
<span class="line-added">223   volatile Age _age;</span>
<span class="line-added">224   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(Age));</span>
<span class="line-added">225 </span>
<span class="line-added">226   NONCOPYABLE(TaskQueueSuper);</span>
<span class="line-added">227 </span>
228 public:
229   TaskQueueSuper() : _bottom(0), _age() {}
230 
<span class="line-modified">231   // Return true if the TaskQueue contains any tasks.</span>
<span class="line-modified">232   // Unreliable if there are concurrent pushes or pops.</span>
<span class="line-modified">233   bool peek() const {</span>
<span class="line-added">234     return bottom_relaxed() != age_top_relaxed();</span>
<span class="line-added">235   }</span>
236 
<span class="line-modified">237   bool is_empty() const {</span>
<span class="line-modified">238     return size() == 0;</span>



239   }
240 
<span class="line-modified">241   // Return an estimate of the number of elements in the queue.</span>
<span class="line-modified">242   // Treats pop_local/pop_global race that underflows as empty.</span>
<span class="line-added">243   uint size() const {</span>
<span class="line-added">244     return clean_size(bottom_relaxed(), age_top_relaxed());</span>
245   }
246 
<span class="line-added">247   // Discard the contents of the queue.</span>
248   void set_empty() {
<span class="line-modified">249     set_bottom_relaxed(0);</span>
<span class="line-modified">250     set_age_relaxed(Age());</span>
251   }
252 
253   // Maximum number of elements allowed in the queue.  This is two less
254   // than the actual queue size, so that a full queue can be distinguished
255   // from underflow involving pop_local and concurrent pop_global operations
256   // in GenericTaskQueue.
257   uint max_elems() const { return N - 2; }
258 



259   TASKQUEUE_STATS_ONLY(TaskQueueStats stats;)
260 };
261 
262 //
263 // GenericTaskQueue implements an ABP, Aurora-Blumofe-Plaxton, double-
264 // ended-queue (deque), intended for use in work stealing. Queue operations
265 // are non-blocking.
266 //
267 // A queue owner thread performs push() and pop_local() operations on one end
268 // of the queue, while other threads may steal work using the pop_global()
269 // method.
270 //
271 // The main difference to the original algorithm is that this
272 // implementation allows wrap-around at the end of its allocated
273 // storage, which is an array.
274 //
275 // The original paper is:
276 //
277 // Arora, N. S., Blumofe, R. D., and Plaxton, C. G.
278 // Thread scheduling for multiprogrammed multiprocessors.
279 // Theory of Computing Systems 34, 2 (2001), 115-144.
280 //
281 // The following paper provides an correctness proof and an
282 // implementation for weakly ordered memory models including (pseudo-)
283 // code containing memory barriers for a Chase-Lev deque. Chase-Lev is
284 // similar to ABP, with the main difference that it allows resizing of the
285 // underlying storage:
286 //
287 // Le, N. M., Pop, A., Cohen A., and Nardell, F. Z.
288 // Correct and efficient work-stealing for weak memory models
289 // Proceedings of the 18th ACM SIGPLAN symposium on Principles and
290 // practice of parallel programming (PPoPP 2013), 69-80
291 //
292 
293 template &lt;class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE&gt;
294 class GenericTaskQueue: public TaskQueueSuper&lt;N, F&gt; {
295 protected:
296   typedef typename TaskQueueSuper&lt;N, F&gt;::Age Age;
297   typedef typename TaskQueueSuper&lt;N, F&gt;::idx_t idx_t;
298 
<span class="line-modified">299   using TaskQueueSuper&lt;N, F&gt;::MOD_N_MASK;</span>
<span class="line-modified">300 </span>
<span class="line-added">301   using TaskQueueSuper&lt;N, F&gt;::bottom_relaxed;</span>
<span class="line-added">302   using TaskQueueSuper&lt;N, F&gt;::bottom_acquire;</span>
<span class="line-added">303 </span>
<span class="line-added">304   using TaskQueueSuper&lt;N, F&gt;::set_bottom_relaxed;</span>
<span class="line-added">305   using TaskQueueSuper&lt;N, F&gt;::release_set_bottom;</span>
<span class="line-added">306 </span>
<span class="line-added">307   using TaskQueueSuper&lt;N, F&gt;::age_relaxed;</span>
<span class="line-added">308   using TaskQueueSuper&lt;N, F&gt;::set_age_relaxed;</span>
<span class="line-added">309   using TaskQueueSuper&lt;N, F&gt;::cmpxchg_age;</span>
<span class="line-added">310   using TaskQueueSuper&lt;N, F&gt;::age_top_relaxed;</span>
<span class="line-added">311 </span>
312   using TaskQueueSuper&lt;N, F&gt;::increment_index;
313   using TaskQueueSuper&lt;N, F&gt;::decrement_index;
314   using TaskQueueSuper&lt;N, F&gt;::dirty_size;
<span class="line-added">315   using TaskQueueSuper&lt;N, F&gt;::clean_size;</span>
316 
317 public:
318   using TaskQueueSuper&lt;N, F&gt;::max_elems;
319   using TaskQueueSuper&lt;N, F&gt;::size;
320 
321 #if  TASKQUEUE_STATS
322   using TaskQueueSuper&lt;N, F&gt;::stats;
323 #endif
324 
325 private:
326   // Slow path for pop_local, dealing with possible conflict with pop_global.
327   bool pop_local_slow(uint localBot, Age oldAge);
328 
329 public:
330   typedef E element_type;
331 
332   // Initializes the queue to empty.
333   GenericTaskQueue();
334 
335   void initialize();
336 
337   // Push the task &quot;t&quot; on the queue.  Returns &quot;false&quot; iff the queue is full.
338   inline bool push(E t);
339 
340   // Attempts to claim a task from the &quot;local&quot; end of the queue (the most
341   // recently pushed) as long as the number of entries exceeds the threshold.
<span class="line-modified">342   // If successfully claims a task, returns true and sets t to the task;</span>
<span class="line-modified">343   // otherwise, returns false and t is unspecified.  May fail and return</span>
<span class="line-modified">344   // false because of a successful steal by pop_global.</span>
<span class="line-added">345   inline bool pop_local(E&amp; t, uint threshold = 0);</span>
346 
347   // Like pop_local(), but uses the &quot;global&quot; end of the queue (the least
348   // recently pushed).
<span class="line-modified">349   bool pop_global(E&amp; t);</span>
350 
351   // Delete any resource associated with the queue.
352   ~GenericTaskQueue();
353 
354   // Apply fn to each element in the task queue.  The queue must not
355   // be modified while iterating.
356   template&lt;typename Fn&gt; void iterate(Fn fn);
357 
358 private:
<span class="line-modified">359   // Base class has trailing padding.</span>
<span class="line-added">360 </span>
361   // Element array.
<span class="line-modified">362   E* _elems;</span>
363 
364   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(E*));
365   // Queue owner local variables. Not to be accessed by other threads.
366 
367   static const uint InvalidQueueId = uint(-1);
368   uint _last_stolen_queue_id; // The id of the queue we last stole from
369 
370   int _seed; // Current random seed used for selecting a random queue during stealing.
371 
372   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(uint) + sizeof(int));
373 public:
374   int next_random_queue_id();
375 
376   void set_last_stolen_queue_id(uint id)     { _last_stolen_queue_id = id; }
377   uint last_stolen_queue_id() const          { return _last_stolen_queue_id; }
378   bool is_last_stolen_queue_id_valid() const { return _last_stolen_queue_id != InvalidQueueId; }
379   void invalidate_last_stolen_queue_id()     { _last_stolen_queue_id = InvalidQueueId; }
380 };
381 
382 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
</pre>
<hr />
<pre>
483       return true;
484   }
485   return false;
486 }
487 
488 template&lt;class T, MEMFLAGS F&gt;
489 uint GenericTaskQueueSet&lt;T, F&gt;::tasks() const {
490   uint n = 0;
491   for (uint j = 0; j &lt; _n; j++) {
492     n += _queues[j]-&gt;size();
493   }
494   return n;
495 }
496 
497 // When to terminate from the termination protocol.
498 class TerminatorTerminator: public CHeapObj&lt;mtInternal&gt; {
499 public:
500   virtual bool should_exit_termination() = 0;
501 };
502 






503 // This is a container class for either an oop* or a narrowOop*.
504 // Both are pushed onto a task queue and the consumer will test is_narrow()
505 // to determine which should be processed.
506 class StarTask {
507   void*  _holder;        // either union oop* or narrowOop*
508 
509   enum { COMPRESSED_OOP_MASK = 1 };
510 
511  public:
512   StarTask(narrowOop* p) {
513     assert(((uintptr_t)p &amp; COMPRESSED_OOP_MASK) == 0, &quot;Information loss!&quot;);
514     _holder = (void *)((uintptr_t)p | COMPRESSED_OOP_MASK);
515   }
516   StarTask(oop* p)       {
517     assert(((uintptr_t)p &amp; COMPRESSED_OOP_MASK) == 0, &quot;Information loss!&quot;);
518     _holder = (void*)p;
519   }
520   StarTask()             { _holder = NULL; }
<span class="line-added">521   // Trivially copyable, for use in GenericTaskQueue.</span>
<span class="line-added">522 </span>
523   operator oop*()        { return (oop*)_holder; }
524   operator narrowOop*()  {
525     return (narrowOop*)((uintptr_t)_holder &amp; ~COMPRESSED_OOP_MASK);
526   }
527 









528   bool is_narrow() const {
529     return (((uintptr_t)_holder &amp; COMPRESSED_OOP_MASK) != 0);
530   }
531 };
532 
533 class ObjArrayTask
534 {
535 public:
536   ObjArrayTask(oop o = NULL, int idx = 0): _obj(o), _index(idx) { }
537   ObjArrayTask(oop o, size_t idx): _obj(o), _index(int(idx)) {
538     assert(idx &lt;= size_t(max_jint), &quot;too big&quot;);
539   }
<span class="line-modified">540   // Trivially copyable, for use in GenericTaskQueue.</span>












541 
542   inline oop obj()   const { return _obj; }
543   inline int index() const { return _index; }
544 
545   DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
546 
547 private:
548   oop _obj;
549   int _index;
550 };
551 




552 #endif // SHARE_GC_SHARED_TASKQUEUE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="barrierSetNMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="taskqueue.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
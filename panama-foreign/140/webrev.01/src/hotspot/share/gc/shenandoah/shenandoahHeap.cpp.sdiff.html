<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahConcurrentRoots.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahParallelCleaning.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 355 
 356   //
 357   // Initialize the rest of GC subsystems
 358   //
 359 
 360   _liveness_cache = NEW_C_HEAP_ARRAY(ShenandoahLiveData*, _max_workers, mtGC);
 361   for (uint worker = 0; worker &lt; _max_workers; worker++) {
 362     _liveness_cache[worker] = NEW_C_HEAP_ARRAY(ShenandoahLiveData, _num_regions, mtGC);
 363     Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(ShenandoahLiveData));
 364   }
 365 
 366   // There should probably be Shenandoah-specific options for these,
 367   // just as there are G1-specific options.
 368   {
 369     ShenandoahSATBMarkQueueSet&amp; satbqs = ShenandoahBarrierSet::satb_mark_queue_set();
 370     satbqs.set_process_completed_buffers_threshold(20); // G1SATBProcessCompletedThreshold
 371     satbqs.set_buffer_enqueue_threshold_percentage(60); // G1SATBBufferEnqueueingThresholdPercent
 372   }
 373 
 374   _monitoring_support = new ShenandoahMonitoringSupport(this);
<span class="line-modified"> 375   _phase_timings = new ShenandoahPhaseTimings();</span>
 376   ShenandoahStringDedup::initialize();
 377   ShenandoahCodeRoots::initialize();
 378 
 379   if (ShenandoahPacing) {
 380     _pacer = new ShenandoahPacer(this);
 381     _pacer-&gt;setup_for_idle();
 382   } else {
 383     _pacer = NULL;
 384   }
 385 
 386   _control_thread = new ShenandoahControlThread();
 387 
 388   log_info(gc, init)(&quot;Initialize Shenandoah heap: &quot; SIZE_FORMAT &quot;%s initial, &quot; SIZE_FORMAT &quot;%s min, &quot; SIZE_FORMAT &quot;%s max&quot;,
 389                      byte_size_in_proper_unit(_initial_size),  proper_unit_for_byte_size(_initial_size),
 390                      byte_size_in_proper_unit(_minimum_size),  proper_unit_for_byte_size(_minimum_size),
 391                      byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity())
 392   );
 393 
 394   log_info(gc, init)(&quot;Safepointing mechanism: thread-local poll&quot;);
 395 
</pre>
<hr />
<pre>
1628 
1629 void ShenandoahHeap::op_updaterefs() {
1630   update_heap_references(true);
1631 }
1632 
1633 void ShenandoahHeap::op_cleanup_early() {
1634   free_set()-&gt;recycle_trash();
1635 }
1636 
1637 void ShenandoahHeap::op_cleanup_complete() {
1638   free_set()-&gt;recycle_trash();
1639 }
1640 
1641 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
1642 private:
1643   ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;
1644   ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;
1645   ShenandoahConcurrentStringDedupRoots          _dedup_roots;
1646 
1647 public:
<span class="line-modified">1648   ShenandoahConcurrentRootsEvacUpdateTask() :</span>
<span class="line-modified">1649     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Strong Roots Task&quot;) {</span>
<span class="line-modified">1650   }</span>

1651 
1652   void work(uint worker_id) {
1653     ShenandoahEvacOOMScope oom;
1654     {
1655       // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration
1656       // may race against OopStorage::release() calls.
1657       ShenandoahEvacUpdateOopStorageRootsClosure cl;
1658       _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl, worker_id);
1659     }
1660 
1661     {
1662       ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1663       CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);
1664       _cld_roots.cld_do(&amp;clds, worker_id);
1665     }
1666 
1667     {
1668       ShenandoahForwardedIsAliveClosure is_alive;
1669       ShenandoahEvacuateUpdateRootsClosure&lt;MO_RELEASE&gt; keep_alive;
1670       _dedup_roots.oops_do(&amp;is_alive, &amp;keep_alive, worker_id);
</pre>
<hr />
<pre>
1744     n-&gt;is_unloading();
1745   }
1746 };
1747 
1748 // This task not only evacuates/updates marked weak roots, but also &quot;NULL&quot;
1749 // dead weak roots.
1750 class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {
1751 private:
1752   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _jni_roots;
1753   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _string_table_roots;
1754   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _resolved_method_table_roots;
1755   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _vm_roots;
1756 
1757   // Roots related to concurrent class unloading
1758   ShenandoahClassLoaderDataRoots&lt;true /* concurrent */, false /* single thread*/&gt;
1759                                            _cld_roots;
1760   ShenandoahConcurrentNMethodIterator      _nmethod_itr;
1761   bool                                     _concurrent_class_unloading;
1762 
1763 public:
<span class="line-modified">1764   ShenandoahConcurrentWeakRootsEvacUpdateTask() :</span>
1765     AbstractGangTask(&quot;Shenandoah Concurrent Weak Root Task&quot;),
<span class="line-modified">1766     _jni_roots(OopStorageSet::jni_weak(), ShenandoahPhaseTimings::JNIWeakRoots),</span>
<span class="line-modified">1767     _string_table_roots(OopStorageSet::string_table_weak(), ShenandoahPhaseTimings::StringTableRoots),</span>
<span class="line-modified">1768     _resolved_method_table_roots(OopStorageSet::resolved_method_table_weak(), ShenandoahPhaseTimings::ResolvedMethodTableRoots),</span>
<span class="line-modified">1769     _vm_roots(OopStorageSet::vm_weak(), ShenandoahPhaseTimings::VMWeakRoots),</span>

1770     _nmethod_itr(ShenandoahCodeRoots::table()),
1771     _concurrent_class_unloading(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1772     StringTable::reset_dead_counter();
1773     ResolvedMethodTable::reset_dead_counter();
1774     if (_concurrent_class_unloading) {
1775       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1776       _nmethod_itr.nmethods_do_begin();
1777     }
1778   }
1779 
1780   ~ShenandoahConcurrentWeakRootsEvacUpdateTask() {
1781     StringTable::finish_dead_counter();
1782     ResolvedMethodTable::finish_dead_counter();
1783     if (_concurrent_class_unloading) {
1784       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1785       _nmethod_itr.nmethods_do_end();
1786     }
1787   }
1788 
1789   void work(uint worker_id) {
</pre>
<hr />
<pre>
1809     // can cleanup immediate garbage sooner.
1810     if (_concurrent_class_unloading) {
1811       // Applies ShenandoahIsCLDAlive closure to CLDs, native barrier will either NULL the
1812       // CLD&#39;s holder or evacuate it.
1813       ShenandoahIsCLDAliveClosure is_cld_alive;
1814       _cld_roots.cld_do(&amp;is_cld_alive, worker_id);
1815 
1816       // Applies ShenandoahIsNMethodAliveClosure to registered nmethods.
1817       // The closure calls nmethod-&gt;is_unloading(). The is_unloading
1818       // state is cached, therefore, during concurrent class unloading phase,
1819       // we will not touch the metadata of unloading nmethods
1820       ShenandoahIsNMethodAliveClosure is_nmethod_alive;
1821       _nmethod_itr.nmethods_do(&amp;is_nmethod_alive);
1822     }
1823   }
1824 };
1825 
1826 void ShenandoahHeap::op_weak_roots() {
1827   if (is_concurrent_weak_root_in_progress()) {
1828     // Concurrent weak root processing
<span class="line-modified">1829     ShenandoahConcurrentWeakRootsEvacUpdateTask task;</span>
1830     workers()-&gt;run_task(&amp;task);
1831     if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1832       set_concurrent_weak_root_in_progress(false);
1833     }
1834   }
1835 }
1836 
1837 void ShenandoahHeap::op_class_unloading() {
1838   assert (is_concurrent_weak_root_in_progress() &amp;&amp;
1839           ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),
1840           &quot;Checked by caller&quot;);
1841   _unloader.unload();
1842   set_concurrent_weak_root_in_progress(false);
1843 }
1844 
1845 void ShenandoahHeap::op_strong_roots() {
1846   assert(is_concurrent_strong_root_in_progress(), &quot;Checked by caller&quot;);
<span class="line-modified">1847   ShenandoahConcurrentRootsEvacUpdateTask task;</span>
1848   workers()-&gt;run_task(&amp;task);
1849   set_concurrent_strong_root_in_progress(false);
1850 }
1851 
1852 class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
1853 private:
1854   ShenandoahMarkingContext* const _ctx;
1855 public:
1856   ShenandoahResetUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
1857 
1858   void heap_region_do(ShenandoahHeapRegion* r) {
1859     if (r-&gt;is_active()) {
1860       // Reset live data and set TAMS optimistically. We would recheck these under the pause
1861       // anyway to capture any updates that happened since now.
1862       r-&gt;clear_live_data();
1863       _ctx-&gt;capture_top_at_mark_start(r);
1864     }
1865   }
1866 
1867   bool is_thread_safe() { return true; }
</pre>
<hr />
<pre>
2226 // Weak roots are either pre-evacuated (final mark) or updated (final updaterefs),
2227 // so they should not have forwarded oops.
2228 // However, we do need to &quot;null&quot; dead oops in the roots, if can not be done
2229 // in concurrent cycles.
2230 void ShenandoahHeap::stw_process_weak_roots(bool full_gc) {
2231   ShenandoahGCSubPhase root_phase(full_gc ?
2232                                   ShenandoahPhaseTimings::full_gc_purge :
2233                                   ShenandoahPhaseTimings::purge);
2234   uint num_workers = _workers-&gt;active_workers();
2235   ShenandoahPhaseTimings::Phase timing_phase = full_gc ?
2236                                                ShenandoahPhaseTimings::full_gc_purge_weak_par :
2237                                                ShenandoahPhaseTimings::purge_weak_par;
2238   ShenandoahGCSubPhase phase(timing_phase);
2239   ShenandoahGCWorkerPhase worker_phase(timing_phase);
2240 
2241   // Cleanup weak roots
2242   if (has_forwarded_objects()) {
2243     ShenandoahForwardedIsAliveClosure is_alive;
2244     ShenandoahUpdateRefsClosure keep_alive;
2245     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;
<span class="line-modified">2246       cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
2247     _workers-&gt;run_task(&amp;cleaning_task);
2248   } else {
2249     ShenandoahIsAliveClosure is_alive;
2250 #ifdef ASSERT
2251     ShenandoahAssertNotForwardedClosure verify_cl;
2252     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, ShenandoahAssertNotForwardedClosure&gt;
<span class="line-modified">2253       cleaning_task(&amp;is_alive, &amp;verify_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
2254 #else
2255     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, DoNothingClosure&gt;
<span class="line-modified">2256       cleaning_task(&amp;is_alive, &amp;do_nothing_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
2257 #endif
2258     _workers-&gt;run_task(&amp;cleaning_task);
2259   }
2260 }
2261 
2262 void ShenandoahHeap::parallel_cleaning(bool full_gc) {
2263   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2264   stw_process_weak_roots(full_gc);
2265   if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2266     stw_unload_classes(full_gc);
2267   }
2268 }
2269 
2270 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
2271   set_gc_state_mask(HAS_FORWARDED, cond);
2272 }
2273 
2274 void ShenandoahHeap::set_process_references(bool pr) {
2275   _process_references.set_cond(pr);
2276 }
</pre>
<hr />
<pre>
2863   static const char* msg = &quot;Concurrent update references&quot;;
2864   ShenandoahConcurrentPhase gc_phase(msg);
2865   EventMark em(&quot;%s&quot;, msg);
2866 
2867   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_update_refs);
2868 
2869   ShenandoahWorkerScope scope(workers(),
2870                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2871                               &quot;concurrent reference update&quot;);
2872 
2873   try_inject_alloc_failure();
2874   op_updaterefs();
2875 }
2876 
2877 void ShenandoahHeap::entry_weak_roots() {
2878   static const char* msg = &quot;Concurrent weak roots&quot;;
2879   ShenandoahConcurrentPhase gc_phase(msg);
2880   EventMark em(&quot;%s&quot;, msg);
2881 
2882   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_weak_roots);

2883 
2884   ShenandoahWorkerScope scope(workers(),
2885                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2886                               &quot;concurrent weak root&quot;);
2887 
2888   try_inject_alloc_failure();
2889   op_weak_roots();
2890 }
2891 
2892 void ShenandoahHeap::entry_class_unloading() {
2893   static const char* msg = &quot;Concurrent class unloading&quot;;
2894   ShenandoahConcurrentPhase gc_phase(msg);
2895   EventMark em(&quot;%s&quot;, msg);
2896 
2897   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_class_unloading);
2898 
2899   ShenandoahWorkerScope scope(workers(),
2900                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2901                               &quot;concurrent class unloading&quot;);
2902 
2903   try_inject_alloc_failure();
2904   op_class_unloading();
2905 }
2906 
2907 void ShenandoahHeap::entry_strong_roots() {
2908   static const char* msg = &quot;Concurrent strong roots&quot;;
2909   ShenandoahConcurrentPhase gc_phase(msg);
2910   EventMark em(&quot;%s&quot;, msg);
2911 
2912   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_strong_roots);

2913 
2914   ShenandoahWorkerScope scope(workers(),
2915                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2916                               &quot;concurrent strong root&quot;);
2917 
2918   try_inject_alloc_failure();
2919   op_strong_roots();
2920 }
2921 
2922 void ShenandoahHeap::entry_cleanup_early() {
2923   static const char* msg = &quot;Concurrent cleanup&quot;;
2924   ShenandoahConcurrentPhase gc_phase(msg,  true /* log_heap_usage */);
2925   EventMark em(&quot;%s&quot;, msg);
2926 
2927   ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::conc_cleanup_early);
2928 
2929   // This phase does not use workers, no need for setup
2930 
2931   try_inject_alloc_failure();
2932   op_cleanup_early();
</pre>
</td>
<td>
<hr />
<pre>
 355 
 356   //
 357   // Initialize the rest of GC subsystems
 358   //
 359 
 360   _liveness_cache = NEW_C_HEAP_ARRAY(ShenandoahLiveData*, _max_workers, mtGC);
 361   for (uint worker = 0; worker &lt; _max_workers; worker++) {
 362     _liveness_cache[worker] = NEW_C_HEAP_ARRAY(ShenandoahLiveData, _num_regions, mtGC);
 363     Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(ShenandoahLiveData));
 364   }
 365 
 366   // There should probably be Shenandoah-specific options for these,
 367   // just as there are G1-specific options.
 368   {
 369     ShenandoahSATBMarkQueueSet&amp; satbqs = ShenandoahBarrierSet::satb_mark_queue_set();
 370     satbqs.set_process_completed_buffers_threshold(20); // G1SATBProcessCompletedThreshold
 371     satbqs.set_buffer_enqueue_threshold_percentage(60); // G1SATBBufferEnqueueingThresholdPercent
 372   }
 373 
 374   _monitoring_support = new ShenandoahMonitoringSupport(this);
<span class="line-modified"> 375   _phase_timings = new ShenandoahPhaseTimings(max_workers());</span>
 376   ShenandoahStringDedup::initialize();
 377   ShenandoahCodeRoots::initialize();
 378 
 379   if (ShenandoahPacing) {
 380     _pacer = new ShenandoahPacer(this);
 381     _pacer-&gt;setup_for_idle();
 382   } else {
 383     _pacer = NULL;
 384   }
 385 
 386   _control_thread = new ShenandoahControlThread();
 387 
 388   log_info(gc, init)(&quot;Initialize Shenandoah heap: &quot; SIZE_FORMAT &quot;%s initial, &quot; SIZE_FORMAT &quot;%s min, &quot; SIZE_FORMAT &quot;%s max&quot;,
 389                      byte_size_in_proper_unit(_initial_size),  proper_unit_for_byte_size(_initial_size),
 390                      byte_size_in_proper_unit(_minimum_size),  proper_unit_for_byte_size(_minimum_size),
 391                      byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity())
 392   );
 393 
 394   log_info(gc, init)(&quot;Safepointing mechanism: thread-local poll&quot;);
 395 
</pre>
<hr />
<pre>
1628 
1629 void ShenandoahHeap::op_updaterefs() {
1630   update_heap_references(true);
1631 }
1632 
1633 void ShenandoahHeap::op_cleanup_early() {
1634   free_set()-&gt;recycle_trash();
1635 }
1636 
1637 void ShenandoahHeap::op_cleanup_complete() {
1638   free_set()-&gt;recycle_trash();
1639 }
1640 
1641 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
1642 private:
1643   ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;
1644   ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;
1645   ShenandoahConcurrentStringDedupRoots          _dedup_roots;
1646 
1647 public:
<span class="line-modified">1648   ShenandoahConcurrentRootsEvacUpdateTask(ShenandoahPhaseTimings::Phase phase) :</span>
<span class="line-modified">1649     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Strong Roots Task&quot;),</span>
<span class="line-modified">1650     _vm_roots(phase),</span>
<span class="line-added">1651     _cld_roots(phase) {}</span>
1652 
1653   void work(uint worker_id) {
1654     ShenandoahEvacOOMScope oom;
1655     {
1656       // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration
1657       // may race against OopStorage::release() calls.
1658       ShenandoahEvacUpdateOopStorageRootsClosure cl;
1659       _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl, worker_id);
1660     }
1661 
1662     {
1663       ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1664       CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);
1665       _cld_roots.cld_do(&amp;clds, worker_id);
1666     }
1667 
1668     {
1669       ShenandoahForwardedIsAliveClosure is_alive;
1670       ShenandoahEvacuateUpdateRootsClosure&lt;MO_RELEASE&gt; keep_alive;
1671       _dedup_roots.oops_do(&amp;is_alive, &amp;keep_alive, worker_id);
</pre>
<hr />
<pre>
1745     n-&gt;is_unloading();
1746   }
1747 };
1748 
1749 // This task not only evacuates/updates marked weak roots, but also &quot;NULL&quot;
1750 // dead weak roots.
1751 class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {
1752 private:
1753   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _jni_roots;
1754   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _string_table_roots;
1755   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _resolved_method_table_roots;
1756   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _vm_roots;
1757 
1758   // Roots related to concurrent class unloading
1759   ShenandoahClassLoaderDataRoots&lt;true /* concurrent */, false /* single thread*/&gt;
1760                                            _cld_roots;
1761   ShenandoahConcurrentNMethodIterator      _nmethod_itr;
1762   bool                                     _concurrent_class_unloading;
1763 
1764 public:
<span class="line-modified">1765   ShenandoahConcurrentWeakRootsEvacUpdateTask(ShenandoahPhaseTimings::Phase phase) :</span>
1766     AbstractGangTask(&quot;Shenandoah Concurrent Weak Root Task&quot;),
<span class="line-modified">1767     _jni_roots(OopStorageSet::jni_weak(), phase, ShenandoahPhaseTimings::JNIWeakRoots),</span>
<span class="line-modified">1768     _string_table_roots(OopStorageSet::string_table_weak(), phase, ShenandoahPhaseTimings::StringTableRoots),</span>
<span class="line-modified">1769     _resolved_method_table_roots(OopStorageSet::resolved_method_table_weak(), phase, ShenandoahPhaseTimings::ResolvedMethodTableRoots),</span>
<span class="line-modified">1770     _vm_roots(OopStorageSet::vm_weak(), phase, ShenandoahPhaseTimings::VMWeakRoots),</span>
<span class="line-added">1771     _cld_roots(phase),</span>
1772     _nmethod_itr(ShenandoahCodeRoots::table()),
1773     _concurrent_class_unloading(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1774     StringTable::reset_dead_counter();
1775     ResolvedMethodTable::reset_dead_counter();
1776     if (_concurrent_class_unloading) {
1777       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1778       _nmethod_itr.nmethods_do_begin();
1779     }
1780   }
1781 
1782   ~ShenandoahConcurrentWeakRootsEvacUpdateTask() {
1783     StringTable::finish_dead_counter();
1784     ResolvedMethodTable::finish_dead_counter();
1785     if (_concurrent_class_unloading) {
1786       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1787       _nmethod_itr.nmethods_do_end();
1788     }
1789   }
1790 
1791   void work(uint worker_id) {
</pre>
<hr />
<pre>
1811     // can cleanup immediate garbage sooner.
1812     if (_concurrent_class_unloading) {
1813       // Applies ShenandoahIsCLDAlive closure to CLDs, native barrier will either NULL the
1814       // CLD&#39;s holder or evacuate it.
1815       ShenandoahIsCLDAliveClosure is_cld_alive;
1816       _cld_roots.cld_do(&amp;is_cld_alive, worker_id);
1817 
1818       // Applies ShenandoahIsNMethodAliveClosure to registered nmethods.
1819       // The closure calls nmethod-&gt;is_unloading(). The is_unloading
1820       // state is cached, therefore, during concurrent class unloading phase,
1821       // we will not touch the metadata of unloading nmethods
1822       ShenandoahIsNMethodAliveClosure is_nmethod_alive;
1823       _nmethod_itr.nmethods_do(&amp;is_nmethod_alive);
1824     }
1825   }
1826 };
1827 
1828 void ShenandoahHeap::op_weak_roots() {
1829   if (is_concurrent_weak_root_in_progress()) {
1830     // Concurrent weak root processing
<span class="line-modified">1831     ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots);</span>
1832     workers()-&gt;run_task(&amp;task);
1833     if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1834       set_concurrent_weak_root_in_progress(false);
1835     }
1836   }
1837 }
1838 
1839 void ShenandoahHeap::op_class_unloading() {
1840   assert (is_concurrent_weak_root_in_progress() &amp;&amp;
1841           ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),
1842           &quot;Checked by caller&quot;);
1843   _unloader.unload();
1844   set_concurrent_weak_root_in_progress(false);
1845 }
1846 
1847 void ShenandoahHeap::op_strong_roots() {
1848   assert(is_concurrent_strong_root_in_progress(), &quot;Checked by caller&quot;);
<span class="line-modified">1849   ShenandoahConcurrentRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_strong_roots);</span>
1850   workers()-&gt;run_task(&amp;task);
1851   set_concurrent_strong_root_in_progress(false);
1852 }
1853 
1854 class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
1855 private:
1856   ShenandoahMarkingContext* const _ctx;
1857 public:
1858   ShenandoahResetUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
1859 
1860   void heap_region_do(ShenandoahHeapRegion* r) {
1861     if (r-&gt;is_active()) {
1862       // Reset live data and set TAMS optimistically. We would recheck these under the pause
1863       // anyway to capture any updates that happened since now.
1864       r-&gt;clear_live_data();
1865       _ctx-&gt;capture_top_at_mark_start(r);
1866     }
1867   }
1868 
1869   bool is_thread_safe() { return true; }
</pre>
<hr />
<pre>
2228 // Weak roots are either pre-evacuated (final mark) or updated (final updaterefs),
2229 // so they should not have forwarded oops.
2230 // However, we do need to &quot;null&quot; dead oops in the roots, if can not be done
2231 // in concurrent cycles.
2232 void ShenandoahHeap::stw_process_weak_roots(bool full_gc) {
2233   ShenandoahGCSubPhase root_phase(full_gc ?
2234                                   ShenandoahPhaseTimings::full_gc_purge :
2235                                   ShenandoahPhaseTimings::purge);
2236   uint num_workers = _workers-&gt;active_workers();
2237   ShenandoahPhaseTimings::Phase timing_phase = full_gc ?
2238                                                ShenandoahPhaseTimings::full_gc_purge_weak_par :
2239                                                ShenandoahPhaseTimings::purge_weak_par;
2240   ShenandoahGCSubPhase phase(timing_phase);
2241   ShenandoahGCWorkerPhase worker_phase(timing_phase);
2242 
2243   // Cleanup weak roots
2244   if (has_forwarded_objects()) {
2245     ShenandoahForwardedIsAliveClosure is_alive;
2246     ShenandoahUpdateRefsClosure keep_alive;
2247     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;
<span class="line-modified">2248       cleaning_task(timing_phase, &amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
2249     _workers-&gt;run_task(&amp;cleaning_task);
2250   } else {
2251     ShenandoahIsAliveClosure is_alive;
2252 #ifdef ASSERT
2253     ShenandoahAssertNotForwardedClosure verify_cl;
2254     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, ShenandoahAssertNotForwardedClosure&gt;
<span class="line-modified">2255       cleaning_task(timing_phase, &amp;is_alive, &amp;verify_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
2256 #else
2257     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, DoNothingClosure&gt;
<span class="line-modified">2258       cleaning_task(timing_phase, &amp;is_alive, &amp;do_nothing_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
2259 #endif
2260     _workers-&gt;run_task(&amp;cleaning_task);
2261   }
2262 }
2263 
2264 void ShenandoahHeap::parallel_cleaning(bool full_gc) {
2265   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2266   stw_process_weak_roots(full_gc);
2267   if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2268     stw_unload_classes(full_gc);
2269   }
2270 }
2271 
2272 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
2273   set_gc_state_mask(HAS_FORWARDED, cond);
2274 }
2275 
2276 void ShenandoahHeap::set_process_references(bool pr) {
2277   _process_references.set_cond(pr);
2278 }
</pre>
<hr />
<pre>
2865   static const char* msg = &quot;Concurrent update references&quot;;
2866   ShenandoahConcurrentPhase gc_phase(msg);
2867   EventMark em(&quot;%s&quot;, msg);
2868 
2869   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_update_refs);
2870 
2871   ShenandoahWorkerScope scope(workers(),
2872                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2873                               &quot;concurrent reference update&quot;);
2874 
2875   try_inject_alloc_failure();
2876   op_updaterefs();
2877 }
2878 
2879 void ShenandoahHeap::entry_weak_roots() {
2880   static const char* msg = &quot;Concurrent weak roots&quot;;
2881   ShenandoahConcurrentPhase gc_phase(msg);
2882   EventMark em(&quot;%s&quot;, msg);
2883 
2884   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_weak_roots);
<span class="line-added">2885   ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_weak_roots);</span>
2886 
2887   ShenandoahWorkerScope scope(workers(),
2888                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2889                               &quot;concurrent weak root&quot;);
2890 
2891   try_inject_alloc_failure();
2892   op_weak_roots();
2893 }
2894 
2895 void ShenandoahHeap::entry_class_unloading() {
2896   static const char* msg = &quot;Concurrent class unloading&quot;;
2897   ShenandoahConcurrentPhase gc_phase(msg);
2898   EventMark em(&quot;%s&quot;, msg);
2899 
2900   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_class_unloading);
2901 
2902   ShenandoahWorkerScope scope(workers(),
2903                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2904                               &quot;concurrent class unloading&quot;);
2905 
2906   try_inject_alloc_failure();
2907   op_class_unloading();
2908 }
2909 
2910 void ShenandoahHeap::entry_strong_roots() {
2911   static const char* msg = &quot;Concurrent strong roots&quot;;
2912   ShenandoahConcurrentPhase gc_phase(msg);
2913   EventMark em(&quot;%s&quot;, msg);
2914 
2915   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_strong_roots);
<span class="line-added">2916   ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_strong_roots);</span>
2917 
2918   ShenandoahWorkerScope scope(workers(),
2919                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2920                               &quot;concurrent strong root&quot;);
2921 
2922   try_inject_alloc_failure();
2923   op_strong_roots();
2924 }
2925 
2926 void ShenandoahHeap::entry_cleanup_early() {
2927   static const char* msg = &quot;Concurrent cleanup&quot;;
2928   ShenandoahConcurrentPhase gc_phase(msg,  true /* log_heap_usage */);
2929   EventMark em(&quot;%s&quot;, msg);
2930 
2931   ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::conc_cleanup_early);
2932 
2933   // This phase does not use workers, no need for setup
2934 
2935   try_inject_alloc_failure();
2936   op_cleanup_early();
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahConcurrentRoots.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahParallelCleaning.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
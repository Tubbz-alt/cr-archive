<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/objArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/objArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 37 #include &quot;oops/arrayKlass.inline.hpp&quot;
 38 #include &quot;oops/instanceKlass.hpp&quot;
 39 #include &quot;oops/klass.inline.hpp&quot;
 40 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 41 #include &quot;oops/objArrayOop.inline.hpp&quot;
 42 #include &quot;oops/oop.inline.hpp&quot;
 43 #include &quot;oops/symbol.hpp&quot;
 44 #include &quot;runtime/handles.inline.hpp&quot;
 45 #include &quot;runtime/mutexLocker.hpp&quot;
 46 #include &quot;utilities/macros.hpp&quot;
 47 
 48 ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {
 49   assert(ObjArrayKlass::header_size() &lt;= InstanceKlass::header_size(),
 50       &quot;array klasses must be same size as InstanceKlass&quot;);
 51 
 52   int size = ArrayKlass::static_size(ObjArrayKlass::header_size());
 53 
 54   return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name);
 55 }
 56 
<span class="line-modified"> 57 Klass* ObjArrayKlass::allocate_objArray_klass(ClassLoaderData* loader_data,</span>
<span class="line-modified"> 58                                                 int n, Klass* element_klass, TRAPS) {</span>
 59 
 60   // Eagerly allocate the direct array supertype.
 61   Klass* super_klass = NULL;
 62   if (!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()) {
 63     Klass* element_super = element_klass-&gt;super();
 64     if (element_super != NULL) {
 65       // The element type has a direct super.  E.g., String[] has direct super of Object[].
 66       super_klass = element_super-&gt;array_klass_or_null();
 67       bool supers_exist = super_klass != NULL;
 68       // Also, see if the element has secondary supertypes.
 69       // We need an array type for each.
 70       const Array&lt;Klass*&gt;* element_supers = element_klass-&gt;secondary_supers();
 71       for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 72         Klass* elem_super = element_supers-&gt;at(i);
 73         if (elem_super-&gt;array_klass_or_null() == NULL) {
 74           supers_exist = false;
 75           break;
 76         }
 77       }
 78       if (!supers_exist) {
 79         // Oops.  Not allocated yet.  Back out, allocate it, and retry.
 80         Klass* ek = NULL;
 81         {
 82           MutexUnlocker mu(MultiArray_lock);
 83           super_klass = element_super-&gt;array_klass(CHECK_NULL);
 84           for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 85             Klass* elem_super = element_supers-&gt;at(i);
 86             elem_super-&gt;array_klass(CHECK_NULL);
 87           }
 88           // Now retry from the beginning
 89           ek = element_klass-&gt;array_klass(n, CHECK_NULL);
 90         }  // re-lock
<span class="line-modified"> 91         return ek;</span>
 92       }
 93     } else {
 94       // The element type is already Object.  Object[] has direct super of Object.
 95       super_klass = SystemDictionary::Object_klass();
 96     }
 97   }
 98 
 99   // Create type name for klass.
100   Symbol* name = NULL;
<span class="line-modified">101   if (!element_klass-&gt;is_instance_klass() ||</span>
<span class="line-removed">102       (name = InstanceKlass::cast(element_klass)-&gt;array_name()) == NULL) {</span>
<span class="line-removed">103 </span>
104     ResourceMark rm(THREAD);
105     char *name_str = element_klass-&gt;name()-&gt;as_C_string();
106     int len = element_klass-&gt;name()-&gt;utf8_length();
107     char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
108     int idx = 0;
109     new_str[idx++] = JVM_SIGNATURE_ARRAY;
110     if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type
111       new_str[idx++] = JVM_SIGNATURE_CLASS;
112     }
113     memcpy(&amp;new_str[idx], name_str, len * sizeof(char));
114     idx += len;
115     if (element_klass-&gt;is_instance_klass()) {
116       new_str[idx++] = JVM_SIGNATURE_ENDCLASS;
117     }
118     new_str[idx++] = &#39;\0&#39;;
<span class="line-modified">119     name = SymbolTable::new_permanent_symbol(new_str);</span>
<span class="line-removed">120     if (element_klass-&gt;is_instance_klass()) {</span>
<span class="line-removed">121       InstanceKlass* ik = InstanceKlass::cast(element_klass);</span>
<span class="line-removed">122       ik-&gt;set_array_name(name);</span>
<span class="line-removed">123     }</span>
124   }
125 
126   // Initialize instance variables
127   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);
128 
129   ModuleEntry* module = oak-&gt;module();
130   assert(module != NULL, &quot;No module entry for array&quot;);
131 
132   // Call complete_create_array_klass after all instance variables has been initialized.
133   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_NULL);
134 
135   // Add all classes to our internal class loader list here,
136   // including classes in the bootstrap (NULL) class loader.
137   // Do this step after creating the mirror so that if the
138   // mirror creation fails, loaded_classes_do() doesn&#39;t find
139   // an array class without a mirror.
140   loader_data-&gt;add_class(oak);
141 
142   return oak;
143 }
144 
145 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
<span class="line-modified">146   this-&gt;set_dimension(n);</span>
<span class="line-modified">147   this-&gt;set_element_klass(element_klass);</span>
<span class="line-removed">148   // decrement refcount because object arrays are not explicitly freed.  The</span>
<span class="line-removed">149   // InstanceKlass array_name() keeps the name counted while the klass is</span>
<span class="line-removed">150   // loaded.</span>
<span class="line-removed">151   name-&gt;decrement_refcount();</span>
152 
153   Klass* bk;
154   if (element_klass-&gt;is_objArray_klass()) {
155     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
156   } else {
157     bk = element_klass;
158   }
159   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
<span class="line-modified">160   this-&gt;set_bottom_klass(bk);</span>
<span class="line-modified">161   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());</span>
162 
<span class="line-modified">163   this-&gt;set_layout_helper(array_layout_helper(T_OBJECT));</span>
<span class="line-modified">164   assert(this-&gt;is_array_klass(), &quot;sanity&quot;);</span>
<span class="line-modified">165   assert(this-&gt;is_objArray_klass(), &quot;sanity&quot;);</span>
166 }
167 
168 int ObjArrayKlass::oop_size(oop obj) const {
169   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
170   return objArrayOop(obj)-&gt;object_size();
171 }
172 
173 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
174   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
175   int size = objArrayOopDesc::object_size(length);
176   return (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
177                                                        /* do_zero */ true, THREAD);
178 }
179 
180 static int multi_alloc_counter = 0;
181 
182 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
183   int length = *sizes;
184   // Call to lower_dimension uses this pointer, so most be called before a
185   // possible GC
</pre>
</td>
<td>
<hr />
<pre>
 37 #include &quot;oops/arrayKlass.inline.hpp&quot;
 38 #include &quot;oops/instanceKlass.hpp&quot;
 39 #include &quot;oops/klass.inline.hpp&quot;
 40 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 41 #include &quot;oops/objArrayOop.inline.hpp&quot;
 42 #include &quot;oops/oop.inline.hpp&quot;
 43 #include &quot;oops/symbol.hpp&quot;
 44 #include &quot;runtime/handles.inline.hpp&quot;
 45 #include &quot;runtime/mutexLocker.hpp&quot;
 46 #include &quot;utilities/macros.hpp&quot;
 47 
 48 ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {
 49   assert(ObjArrayKlass::header_size() &lt;= InstanceKlass::header_size(),
 50       &quot;array klasses must be same size as InstanceKlass&quot;);
 51 
 52   int size = ArrayKlass::static_size(ObjArrayKlass::header_size());
 53 
 54   return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name);
 55 }
 56 
<span class="line-modified"> 57 ObjArrayKlass* ObjArrayKlass::allocate_objArray_klass(ClassLoaderData* loader_data,</span>
<span class="line-modified"> 58                                                       int n, Klass* element_klass, TRAPS) {</span>
 59 
 60   // Eagerly allocate the direct array supertype.
 61   Klass* super_klass = NULL;
 62   if (!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()) {
 63     Klass* element_super = element_klass-&gt;super();
 64     if (element_super != NULL) {
 65       // The element type has a direct super.  E.g., String[] has direct super of Object[].
 66       super_klass = element_super-&gt;array_klass_or_null();
 67       bool supers_exist = super_klass != NULL;
 68       // Also, see if the element has secondary supertypes.
 69       // We need an array type for each.
 70       const Array&lt;Klass*&gt;* element_supers = element_klass-&gt;secondary_supers();
 71       for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 72         Klass* elem_super = element_supers-&gt;at(i);
 73         if (elem_super-&gt;array_klass_or_null() == NULL) {
 74           supers_exist = false;
 75           break;
 76         }
 77       }
 78       if (!supers_exist) {
 79         // Oops.  Not allocated yet.  Back out, allocate it, and retry.
 80         Klass* ek = NULL;
 81         {
 82           MutexUnlocker mu(MultiArray_lock);
 83           super_klass = element_super-&gt;array_klass(CHECK_NULL);
 84           for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 85             Klass* elem_super = element_supers-&gt;at(i);
 86             elem_super-&gt;array_klass(CHECK_NULL);
 87           }
 88           // Now retry from the beginning
 89           ek = element_klass-&gt;array_klass(n, CHECK_NULL);
 90         }  // re-lock
<span class="line-modified"> 91         return ObjArrayKlass::cast(ek);</span>
 92       }
 93     } else {
 94       // The element type is already Object.  Object[] has direct super of Object.
 95       super_klass = SystemDictionary::Object_klass();
 96     }
 97   }
 98 
 99   // Create type name for klass.
100   Symbol* name = NULL;
<span class="line-modified">101   {</span>


102     ResourceMark rm(THREAD);
103     char *name_str = element_klass-&gt;name()-&gt;as_C_string();
104     int len = element_klass-&gt;name()-&gt;utf8_length();
105     char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
106     int idx = 0;
107     new_str[idx++] = JVM_SIGNATURE_ARRAY;
108     if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type
109       new_str[idx++] = JVM_SIGNATURE_CLASS;
110     }
111     memcpy(&amp;new_str[idx], name_str, len * sizeof(char));
112     idx += len;
113     if (element_klass-&gt;is_instance_klass()) {
114       new_str[idx++] = JVM_SIGNATURE_ENDCLASS;
115     }
116     new_str[idx++] = &#39;\0&#39;;
<span class="line-modified">117     name = SymbolTable::new_symbol(new_str);</span>




118   }
119 
120   // Initialize instance variables
121   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);
122 
123   ModuleEntry* module = oak-&gt;module();
124   assert(module != NULL, &quot;No module entry for array&quot;);
125 
126   // Call complete_create_array_klass after all instance variables has been initialized.
127   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_NULL);
128 
129   // Add all classes to our internal class loader list here,
130   // including classes in the bootstrap (NULL) class loader.
131   // Do this step after creating the mirror so that if the
132   // mirror creation fails, loaded_classes_do() doesn&#39;t find
133   // an array class without a mirror.
134   loader_data-&gt;add_class(oak);
135 
136   return oak;
137 }
138 
139 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
<span class="line-modified">140   set_dimension(n);</span>
<span class="line-modified">141   set_element_klass(element_klass);</span>




142 
143   Klass* bk;
144   if (element_klass-&gt;is_objArray_klass()) {
145     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
146   } else {
147     bk = element_klass;
148   }
149   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
<span class="line-modified">150   set_bottom_klass(bk);</span>
<span class="line-modified">151   set_class_loader_data(bk-&gt;class_loader_data());</span>
152 
<span class="line-modified">153   set_layout_helper(array_layout_helper(T_OBJECT));</span>
<span class="line-modified">154   assert(is_array_klass(), &quot;sanity&quot;);</span>
<span class="line-modified">155   assert(is_objArray_klass(), &quot;sanity&quot;);</span>
156 }
157 
158 int ObjArrayKlass::oop_size(oop obj) const {
159   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
160   return objArrayOop(obj)-&gt;object_size();
161 }
162 
163 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
164   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
165   int size = objArrayOopDesc::object_size(length);
166   return (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
167                                                        /* do_zero */ true, THREAD);
168 }
169 
170 static int multi_alloc_counter = 0;
171 
172 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
173   int length = *sizes;
174   // Call to lower_dimension uses this pointer, so most be called before a
175   // possible GC
</pre>
</td>
</tr>
</table>
<center><a href="klass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
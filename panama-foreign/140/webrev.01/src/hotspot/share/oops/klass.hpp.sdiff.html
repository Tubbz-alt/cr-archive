<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/klass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
657   // unloading, and hence during concurrent class unloading.
658   bool is_loader_alive() const { return class_loader_data()-&gt;is_alive(); }
659 
660   void clean_subklass();
661 
662   static void clean_weak_klass_links(bool unloading_occurred, bool clean_alive_klasses = true);
663   static void clean_subklass_tree() {
664     clean_weak_klass_links(/*unloading_occurred*/ true , /* clean_alive_klasses */ false);
665   }
666 
667   virtual void array_klasses_do(void f(Klass* k)) {}
668 
669   // Return self, except for abstract classes with exactly 1
670   // implementor.  Then return the 1 concrete implementation.
671   Klass *up_cast_abstract();
672 
673   // klass name
674   Symbol* name() const                   { return _name; }
675   void set_name(Symbol* n);
676 


677  public:
678   // jvm support
679   virtual jint compute_modifier_flags(TRAPS) const;
680 
681   // JVMTI support
682   virtual jint jvmti_class_status() const;
683 
684   // Printing
685   virtual void print_on(outputStream* st) const;
686 
687   virtual void oop_print_value_on(oop obj, outputStream* st);
688   virtual void oop_print_on      (oop obj, outputStream* st);
689 
690   virtual const char* internal_name() const = 0;
691 
692   // Verification
693   virtual void verify_on(outputStream* st);
694   void verify() { verify_on(tty); }
695 
696 #ifndef PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
657   // unloading, and hence during concurrent class unloading.
658   bool is_loader_alive() const { return class_loader_data()-&gt;is_alive(); }
659 
660   void clean_subklass();
661 
662   static void clean_weak_klass_links(bool unloading_occurred, bool clean_alive_klasses = true);
663   static void clean_subklass_tree() {
664     clean_weak_klass_links(/*unloading_occurred*/ true , /* clean_alive_klasses */ false);
665   }
666 
667   virtual void array_klasses_do(void f(Klass* k)) {}
668 
669   // Return self, except for abstract classes with exactly 1
670   // implementor.  Then return the 1 concrete implementation.
671   Klass *up_cast_abstract();
672 
673   // klass name
674   Symbol* name() const                   { return _name; }
675   void set_name(Symbol* n);
676 
<span class="line-added">677   virtual void release_C_heap_structures();</span>
<span class="line-added">678 </span>
679  public:
680   // jvm support
681   virtual jint compute_modifier_flags(TRAPS) const;
682 
683   // JVMTI support
684   virtual jint jvmti_class_status() const;
685 
686   // Printing
687   virtual void print_on(outputStream* st) const;
688 
689   virtual void oop_print_value_on(oop obj, outputStream* st);
690   virtual void oop_print_on      (oop obj, outputStream* st);
691 
692   virtual const char* internal_name() const = 0;
693 
694   // Verification
695   virtual void verify_on(outputStream* st);
696   void verify() { verify_on(tty); }
697 
698 #ifndef PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="klass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import java.lang.reflect.Field;
 28 import java.lang.reflect.Modifier;
 29 import java.util.List;
 30 
 31 import org.graalvm.compiler.core.common.CompressEncoding;
 32 import org.graalvm.compiler.hotspot.nodes.GraalHotSpotVMConfigNode;
 33 
 34 import jdk.vm.ci.common.JVMCIError;
 35 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 36 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
 37 import jdk.vm.ci.meta.ResolvedJavaMethod;
 38 
 39 /**
 40  * Used to access native configuration details.
 41  */
 42 public class GraalHotSpotVMConfig extends GraalHotSpotVMConfigBase {
 43 
 44     GraalHotSpotVMConfig(HotSpotVMConfigStore store) {
 45         super(store);
 46 
 47         assert narrowKlassShift &lt;= logKlassAlignment;
 48         assert narrowOopShift &lt;= logMinObjAlignment();
 49         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift);
 50         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift);
 51 
 52         assert check();
 53     }
 54 
 55     private final CompressEncoding oopEncoding;
 56     private final CompressEncoding klassEncoding;
 57     private final String markWord = versioned.markWordFieldType;
 58 
 59     public CompressEncoding getOopEncoding() {
 60         return oopEncoding;
 61     }
 62 
 63     public CompressEncoding getKlassEncoding() {
 64         return klassEncoding;
 65     }
 66 
 67     public final boolean cAssertions = getConstant(&quot;ASSERT&quot;, Boolean.class);
 68 
 69     public final int codeEntryAlignment = getFlag(&quot;CodeEntryAlignment&quot;, Integer.class);
 70     public final boolean enableContended = getFlag(&quot;EnableContended&quot;, Boolean.class);
 71     public final boolean restrictContended = getFlag(&quot;RestrictContended&quot;, Boolean.class);
 72     public final int contendedPaddingWidth = getFlag(&quot;ContendedPaddingWidth&quot;, Integer.class);
 73     public final int fieldsAllocationStyle = versioned.fieldsAllocationStyle;
 74     public final boolean compactFields = versioned.compactFields;
 75     public final boolean verifyOops = getFlag(&quot;VerifyOops&quot;, Boolean.class);
 76     public final boolean ciTime = getFlag(&quot;CITime&quot;, Boolean.class);
 77     public final boolean ciTimeEach = getFlag(&quot;CITimeEach&quot;, Boolean.class);
 78     public final boolean dontCompileHugeMethods = getFlag(&quot;DontCompileHugeMethods&quot;, Boolean.class);
 79     public final int hugeMethodLimit = getFlag(&quot;HugeMethodLimit&quot;, Integer.class);
 80     public final boolean printInlining = getFlag(&quot;PrintInlining&quot;, Boolean.class);
 81     public final boolean inline = getFlag(&quot;Inline&quot;, Boolean.class);
 82     public final boolean inlineNotify = versioned.inlineNotify;
 83     public final boolean useFastLocking = getFlag(&quot;JVMCIUseFastLocking&quot;, Boolean.class);
 84     public final boolean forceUnreachable = getFlag(&quot;ForceUnreachable&quot;, Boolean.class);
 85     public final int codeSegmentSize = getFlag(&quot;CodeCacheSegmentSize&quot;, Integer.class);
 86     public final boolean foldStableValues = getFlag(&quot;FoldStableValues&quot;, Boolean.class);
 87     public final int maxVectorSize = getFlag(&quot;MaxVectorSize&quot;, Integer.class);
 88 
 89     public final boolean verifyBeforeGC = getFlag(&quot;VerifyBeforeGC&quot;, Boolean.class);
 90     public final boolean verifyAfterGC = getFlag(&quot;VerifyAfterGC&quot;, Boolean.class);
 91 
 92     public final boolean useTLAB = getFlag(&quot;UseTLAB&quot;, Boolean.class);
 93     public final boolean useBiasedLocking = getFlag(&quot;UseBiasedLocking&quot;, Boolean.class);
 94     public final boolean usePopCountInstruction = getFlag(&quot;UsePopCountInstruction&quot;, Boolean.class);
 95     public final boolean useAESIntrinsics = getFlag(&quot;UseAESIntrinsics&quot;, Boolean.class);
 96     public final boolean useAESCTRIntrinsics = getFlag(&quot;UseAESCTRIntrinsics&quot;, Boolean.class, false);
 97     public final boolean useCRC32Intrinsics = getFlag(&quot;UseCRC32Intrinsics&quot;, Boolean.class);
 98     public final boolean useCRC32CIntrinsics = versioned.useCRC32CIntrinsics;
 99     public final boolean threadLocalHandshakes = versioned.threadLocalHandshakes;
100 
101     private final boolean useMultiplyToLenIntrinsic = getFlag(&quot;UseMultiplyToLenIntrinsic&quot;, Boolean.class);
102     private final boolean useSHA1Intrinsics = getFlag(&quot;UseSHA1Intrinsics&quot;, Boolean.class);
103     private final boolean useSHA256Intrinsics = getFlag(&quot;UseSHA256Intrinsics&quot;, Boolean.class);
104     private final boolean useSHA512Intrinsics = getFlag(&quot;UseSHA512Intrinsics&quot;, Boolean.class);
105     private final boolean useGHASHIntrinsics = getFlag(&quot;UseGHASHIntrinsics&quot;, Boolean.class, false);
106     private final boolean useBase64Intrinsics = getFlag(&quot;UseBASE64Intrinsics&quot;, Boolean.class, false);
107     private final boolean useMontgomeryMultiplyIntrinsic = getFlag(&quot;UseMontgomeryMultiplyIntrinsic&quot;, Boolean.class, false);
108     private final boolean useMontgomerySquareIntrinsic = getFlag(&quot;UseMontgomerySquareIntrinsic&quot;, Boolean.class, false);
109     private final boolean useMulAddIntrinsic = getFlag(&quot;UseMulAddIntrinsic&quot;, Boolean.class, false);
110     private final boolean useSquareToLenIntrinsic = getFlag(&quot;UseSquareToLenIntrinsic&quot;, Boolean.class, false);
111     public final boolean useVectorizedMismatchIntrinsic = getFlag(&quot;UseVectorizedMismatchIntrinsic&quot;, Boolean.class, false);
112     public final boolean useFMAIntrinsics = getFlag(&quot;UseFMA&quot;, Boolean.class, false);
113     public final int useAVX3Threshold = getFlag(&quot;AVX3Threshold&quot;, Integer.class, 4096);
114 
115     public final boolean preserveFramePointer = getFlag(&quot;PreserveFramePointer&quot;, Boolean.class, false);
116 
117     /*
118      * These are methods because in some JDKs the flags are visible but the stubs themselves haven&#39;t
119      * been exported so we have to check both if the flag is on and if we have the stub.
120      */
121     public boolean useMultiplyToLenIntrinsic() {
122         return useMultiplyToLenIntrinsic &amp;&amp; multiplyToLen != 0;
123     }
124 
125     public boolean useSHA1Intrinsics() {
126         return useSHA1Intrinsics &amp;&amp; sha1ImplCompress != 0 &amp;&amp; sha1ImplCompressMultiBlock != 0;
127     }
128 
129     public boolean useSHA256Intrinsics() {
130         return useSHA256Intrinsics &amp;&amp; sha256ImplCompress != 0 &amp;&amp; sha256ImplCompressMultiBlock != 0;
131     }
132 
133     public boolean useSHA512Intrinsics() {
134         return useSHA512Intrinsics &amp;&amp; sha512ImplCompress != 0 &amp;&amp; sha512ImplCompressMultiBlock != 0;
135     }
136 
137     public boolean useGHASHIntrinsics() {
138         return useGHASHIntrinsics &amp;&amp; ghashProcessBlocks != 0;
139     }
140 
141     public boolean useBase64Intrinsics() {
142         return useBase64Intrinsics &amp;&amp; base64EncodeBlock != 0;
143     }
144 
145     public boolean useMontgomeryMultiplyIntrinsic() {
146         return useMontgomeryMultiplyIntrinsic &amp;&amp; montgomeryMultiply != 0;
147     }
148 
149     public boolean useMontgomerySquareIntrinsic() {
150         return useMontgomerySquareIntrinsic &amp;&amp; montgomerySquare != 0;
151     }
152 
153     public boolean useMulAddIntrinsic() {
154         return useMulAddIntrinsic &amp;&amp; mulAdd != 0;
155     }
156 
157     public boolean useSquareToLenIntrinsic() {
158         return useSquareToLenIntrinsic &amp;&amp; squareToLen != 0;
159     }
160 
161     public boolean inlineNotify() {
162         return inlineNotify &amp;&amp; notifyAddress != 0;
163     }
164 
165     public boolean inlineNotifyAll() {
166         return inlineNotify &amp;&amp; notifyAllAddress != 0;
167     }
168 
169     public final boolean useG1GC = getFlag(&quot;UseG1GC&quot;, Boolean.class);
170     public final boolean useCMSGC = getFlag(&quot;UseConcMarkSweepGC&quot;, Boolean.class, false);
171 
172     public final int allocatePrefetchStyle = getFlag(&quot;AllocatePrefetchStyle&quot;, Integer.class);
173     public final int allocatePrefetchInstr = getFlag(&quot;AllocatePrefetchInstr&quot;, Integer.class);
174     public final int allocatePrefetchLines = getFlag(&quot;AllocatePrefetchLines&quot;, Integer.class);
175     public final int allocateInstancePrefetchLines = getFlag(&quot;AllocateInstancePrefetchLines&quot;, Integer.class);
176     public final int allocatePrefetchStepSize = getFlag(&quot;AllocatePrefetchStepSize&quot;, Integer.class);
177     public final int allocatePrefetchDistance = getFlag(&quot;AllocatePrefetchDistance&quot;, Integer.class);
178 
179     private final long universeCollectedHeap = getFieldValue(&quot;CompilerToVM::Data::Universe_collectedHeap&quot;, Long.class, &quot;CollectedHeap*&quot;);
180     private final int collectedHeapTotalCollectionsOffset = getFieldOffset(&quot;CollectedHeap::_total_collections&quot;, Integer.class, &quot;unsigned int&quot;);
181 
182     public long gcTotalCollectionsAddress() {
183         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
184     }
185 
186     public final boolean useDeferredInitBarriers = getFlag(&quot;ReduceInitialCardMarks&quot;, Boolean.class);
187 
188     // Compressed Oops related values.
189     public final boolean useCompressedOops = getFlag(&quot;UseCompressedOops&quot;, Boolean.class);
190     public final boolean useCompressedClassPointers = getFlag(&quot;UseCompressedClassPointers&quot;, Boolean.class);
191 
192     public final long narrowOopBase = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_oop_base&quot;, Long.class, &quot;address&quot;);
193     public final int narrowOopShift = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_oop_shift&quot;, Integer.class, &quot;int&quot;);
194     public final int objectAlignment = getFlag(&quot;ObjectAlignmentInBytes&quot;, Integer.class);
195 
196     public final int minObjAlignment() {
197         return objectAlignment / heapWordSize;
198     }
199 
200     public final int logMinObjAlignment() {
201         return (int) (Math.log(objectAlignment) / Math.log(2));
202     }
203 
204     public final int narrowKlassSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_narrowKlass&quot;, Integer.class, &quot;int&quot;);
205     public final long narrowKlassBase = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_klass_base&quot;, Long.class, &quot;address&quot;);
206     public final int narrowKlassShift = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_klass_shift&quot;, Integer.class, &quot;int&quot;);
207     public final int logKlassAlignment = getConstant(&quot;LogKlassAlignmentInBytes&quot;, Integer.class);
208 
209     public final int stackShadowPages = getFlag(&quot;StackShadowPages&quot;, Integer.class);
210     public final int stackReservedPages = getFlag(&quot;StackReservedPages&quot;, Integer.class, 0);
211     public final boolean useStackBanging = getFlag(&quot;UseStackBanging&quot;, Boolean.class);
212     public final int stackBias = getConstant(&quot;STACK_BIAS&quot;, Integer.class);
213     public final int vmPageSize = getFieldValue(&quot;CompilerToVM::Data::vm_page_size&quot;, Integer.class, &quot;int&quot;);
214 
215     public final int markOffset = getFieldOffset(&quot;oopDesc::_mark&quot;, Integer.class, markWord);
216     public final int hubOffset = getFieldOffset(&quot;oopDesc::_metadata._klass&quot;, Integer.class, &quot;Klass*&quot;);
217 
218     public final int prototypeMarkWordOffset = getFieldOffset(&quot;Klass::_prototype_header&quot;, Integer.class, markWord);
219     public final int subklassOffset = getFieldOffset(&quot;Klass::_subklass&quot;, Integer.class, &quot;Klass*&quot;);
220     public final int nextSiblingOffset = getFieldOffset(&quot;Klass::_next_sibling&quot;, Integer.class, &quot;Klass*&quot;);
221     public final int superCheckOffsetOffset = getFieldOffset(&quot;Klass::_super_check_offset&quot;, Integer.class, &quot;juint&quot;);
222     public final int secondarySuperCacheOffset = getFieldOffset(&quot;Klass::_secondary_super_cache&quot;, Integer.class, &quot;Klass*&quot;);
223     public final int secondarySupersOffset = getFieldOffset(&quot;Klass::_secondary_supers&quot;, Integer.class, &quot;Array&lt;Klass*&gt;*&quot;);
224 
225     public final boolean classMirrorIsHandle = versioned.classMirrorIsHandle;
226     public final int classMirrorOffset = versioned.classMirrorOffset;
227 
228     public final int klassSuperKlassOffset = getFieldOffset(&quot;Klass::_super&quot;, Integer.class, &quot;Klass*&quot;);
229     public final int klassModifierFlagsOffset = getFieldOffset(&quot;Klass::_modifier_flags&quot;, Integer.class, &quot;jint&quot;);
230     public final int klassAccessFlagsOffset = getFieldOffset(&quot;Klass::_access_flags&quot;, Integer.class, &quot;AccessFlags&quot;);
231     public final int klassLayoutHelperOffset = getFieldOffset(&quot;Klass::_layout_helper&quot;, Integer.class, &quot;jint&quot;);
232 
233     public final int klassLayoutHelperNeutralValue = getConstant(&quot;Klass::_lh_neutral_value&quot;, Integer.class);
234     public final int layoutHelperLog2ElementSizeShift = getConstant(&quot;Klass::_lh_log2_element_size_shift&quot;, Integer.class);
235     public final int layoutHelperLog2ElementSizeMask = getConstant(&quot;Klass::_lh_log2_element_size_mask&quot;, Integer.class);
236     public final int layoutHelperElementTypeShift = getConstant(&quot;Klass::_lh_element_type_shift&quot;, Integer.class);
237     public final int layoutHelperElementTypeMask = getConstant(&quot;Klass::_lh_element_type_mask&quot;, Integer.class);
238     public final int layoutHelperHeaderSizeShift = getConstant(&quot;Klass::_lh_header_size_shift&quot;, Integer.class);
239     public final int layoutHelperHeaderSizeMask = getConstant(&quot;Klass::_lh_header_size_mask&quot;, Integer.class);
240     public final int layoutHelperArrayTagShift = getConstant(&quot;Klass::_lh_array_tag_shift&quot;, Integer.class);
241     public final int layoutHelperArrayTagTypeValue = getConstant(&quot;Klass::_lh_array_tag_type_value&quot;, Integer.class);
242     public final int layoutHelperArrayTagObjectValue = getConstant(&quot;Klass::_lh_array_tag_obj_value&quot;, Integer.class);
243 
244     /**
245      * This filters out the bit that differentiates a type array from an object array.
246      */
247     public int layoutHelperElementTypePrimitiveInPlace() {
248         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
249     }
250 
251     public final int vtableEntrySize = getFieldValue(&quot;CompilerToVM::Data::sizeof_vtableEntry&quot;, Integer.class, &quot;int&quot;);
252     public final int vtableEntryMethodOffset = getFieldOffset(&quot;vtableEntry::_method&quot;, Integer.class, &quot;Method*&quot;);
253 
254     public final int instanceKlassInitStateOffset = getFieldOffset(&quot;InstanceKlass::_init_state&quot;, Integer.class, &quot;u1&quot;);
255     public final int instanceKlassInitThreadOffset = getFieldOffset(&quot;InstanceKlass::_init_thread&quot;, Integer.class, &quot;Thread*&quot;, -1);
256     public final int instanceKlassConstantsOffset = getFieldOffset(&quot;InstanceKlass::_constants&quot;, Integer.class, &quot;ConstantPool*&quot;);
257     public final int instanceKlassFieldsOffset = getFieldOffset(&quot;InstanceKlass::_fields&quot;, Integer.class, &quot;Array&lt;u2&gt;*&quot;);
258     public final int klassVtableStartOffset = getFieldValue(&quot;CompilerToVM::Data::Klass_vtable_start_offset&quot;, Integer.class, &quot;int&quot;);
259     public final int klassVtableLengthOffset = getFieldValue(&quot;CompilerToVM::Data::Klass_vtable_length_offset&quot;, Integer.class, &quot;int&quot;);
260 
261     public final int instanceKlassStateLinked = getConstant(&quot;InstanceKlass::linked&quot;, Integer.class);
262     public final int instanceKlassStateBeingInitialized = getConstant(&quot;InstanceKlass::being_initialized&quot;, Integer.class, -1);
263     public final int instanceKlassStateFullyInitialized = getConstant(&quot;InstanceKlass::fully_initialized&quot;, Integer.class);
264 
265     public final int arrayOopDescSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_arrayOopDesc&quot;, Integer.class, &quot;int&quot;);
266 
267     /**
268      * The offset of the array length word in an array object&#39;s header.
269      *
270      * See {@code arrayOopDesc::length_offset_in_bytes()}.
271      */
272     public final int arrayOopDescLengthOffset() {
273         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
274     }
275 
276     public final int arrayU1LengthOffset = getFieldOffset(&quot;Array&lt;int&gt;::_length&quot;, Integer.class, &quot;int&quot;);
277     public final int arrayU1DataOffset = getFieldOffset(&quot;Array&lt;u1&gt;::_data&quot;, Integer.class);
278     public final int arrayU2DataOffset = getFieldOffset(&quot;Array&lt;u2&gt;::_data&quot;, Integer.class);
279     public final int metaspaceArrayLengthOffset = getFieldOffset(&quot;Array&lt;Klass*&gt;::_length&quot;, Integer.class, &quot;int&quot;);
280     public final int metaspaceArrayBaseOffset = getFieldOffset(&quot;Array&lt;Klass*&gt;::_data[0]&quot;, Integer.class, &quot;Klass*&quot;);
281 
282     public final int arrayClassElementOffset = getFieldOffset(&quot;ObjArrayKlass::_element_klass&quot;, Integer.class, &quot;Klass*&quot;);
283 
284     public final int fieldInfoAccessFlagsOffset = getConstant(&quot;FieldInfo::access_flags_offset&quot;, Integer.class);
285     public final int fieldInfoNameIndexOffset = getConstant(&quot;FieldInfo::name_index_offset&quot;, Integer.class);
286     public final int fieldInfoSignatureIndexOffset = getConstant(&quot;FieldInfo::signature_index_offset&quot;, Integer.class);
287     public final int fieldInfoInitvalIndexOffset = getConstant(&quot;FieldInfo::initval_index_offset&quot;, Integer.class);
288     public final int fieldInfoLowPackedOffset = getConstant(&quot;FieldInfo::low_packed_offset&quot;, Integer.class);
289     public final int fieldInfoHighPackedOffset = getConstant(&quot;FieldInfo::high_packed_offset&quot;, Integer.class);
290     public final int fieldInfoFieldSlots = getConstant(&quot;FieldInfo::field_slots&quot;, Integer.class);
291 
292     public final int fieldInfoTagSize = getConstant(&quot;FIELDINFO_TAG_SIZE&quot;, Integer.class);
293 
294     public final int jvmAccMonitorMatch = getConstant(&quot;JVM_ACC_MONITOR_MATCH&quot;, Integer.class);
295     public final int jvmAccHasMonitorBytecodes = getConstant(&quot;JVM_ACC_HAS_MONITOR_BYTECODES&quot;, Integer.class);
296     public final int jvmAccHasFinalizer = getConstant(&quot;JVM_ACC_HAS_FINALIZER&quot;, Integer.class);
297     public final int jvmAccFieldInternal = getConstant(&quot;JVM_ACC_FIELD_INTERNAL&quot;, Integer.class);
298     public final int jvmAccFieldStable = getConstant(&quot;JVM_ACC_FIELD_STABLE&quot;, Integer.class);
299     public final int jvmAccFieldHasGenericSignature = getConstant(&quot;JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE&quot;, Integer.class);
300     public final int jvmAccWrittenFlags = getConstant(&quot;JVM_ACC_WRITTEN_FLAGS&quot;, Integer.class);
301     public final int jvmAccSynthetic = getConstant(&quot;JVM_ACC_SYNTHETIC&quot;, Integer.class);
302     public final int jvmAccIsHiddenClass = getConstant(&quot;JVM_ACC_IS_HIDDEN_CLASS&quot;, Integer.class);
303 
304     public final int jvmciCompileStateCanPostOnExceptionsOffset = getJvmciJvmtiCapabilityOffset(&quot;_jvmti_can_post_on_exceptions&quot;);
305     public final int jvmciCompileStateCanPopFrameOffset = getJvmciJvmtiCapabilityOffset(&quot;_jvmti_can_pop_frame&quot;);
306     public final int jvmciCompileStateCanAccessLocalVariablesOffset = getJvmciJvmtiCapabilityOffset(&quot;_jvmti_can_access_local_variables&quot;);
307 
308     // Integer.MIN_VALUE if not available
309     private int getJvmciJvmtiCapabilityOffset(String name) {
310         int offset = getFieldOffset(&quot;JVMCICompileState::&quot; + name, Integer.class, &quot;jbyte&quot;, Integer.MIN_VALUE);
311         if (offset == Integer.MIN_VALUE) {
312             // JDK 12
313             offset = getFieldOffset(&quot;JVMCIEnv::&quot; + name, Integer.class, &quot;jbyte&quot;, Integer.MIN_VALUE);
314         }
315         return offset;
316     }
317 
318     public final int threadTlabOffset = getFieldOffset(&quot;Thread::_tlab&quot;, Integer.class, &quot;ThreadLocalAllocBuffer&quot;);
319     public final int javaThreadAnchorOffset = getFieldOffset(&quot;JavaThread::_anchor&quot;, Integer.class, &quot;JavaFrameAnchor&quot;);
320     public final int javaThreadShouldPostOnExceptionsFlagOffset = getFieldOffset(&quot;JavaThread::_should_post_on_exceptions_flag&quot;, Integer.class, &quot;int&quot;, Integer.MIN_VALUE);
321     public final int threadObjectOffset = getFieldOffset(&quot;JavaThread::_threadObj&quot;, Integer.class, &quot;oop&quot;);
322     public final int osThreadOffset = getFieldOffset(&quot;JavaThread::_osthread&quot;, Integer.class, &quot;OSThread*&quot;, Integer.MAX_VALUE);
323     public final int threadIsMethodHandleReturnOffset = getFieldOffset(&quot;JavaThread::_is_method_handle_return&quot;, Integer.class, &quot;int&quot;);
324     public final int threadObjectResultOffset = getFieldOffset(&quot;JavaThread::_vm_result&quot;, Integer.class, &quot;oop&quot;);
325     public final int jvmciCountersThreadOffset = getFieldOffset(&quot;JavaThread::_jvmci_counters&quot;, Integer.class, &quot;jlong*&quot;);
326     public final int doingUnsafeAccessOffset = getFieldOffset(&quot;JavaThread::_doing_unsafe_access&quot;, Integer.class, &quot;bool&quot;, Integer.MAX_VALUE);
327     public final int javaThreadReservedStackActivationOffset = versioned.javaThreadReservedStackActivationOffset;
328     public final int jniEnvironmentOffset = getFieldOffset(&quot;JavaThread::_jni_environment&quot;, Integer.class, &quot;JNIEnv&quot;, Integer.MIN_VALUE);
329 
330     public boolean requiresReservedStackCheck(List&lt;ResolvedJavaMethod&gt; methods) {
331         if (enableStackReservedZoneAddress != 0 &amp;&amp; methods != null) {
332             for (ResolvedJavaMethod method : methods) {
333                 if (((HotSpotResolvedJavaMethod) method).hasReservedStackAccess()) {
334                     return true;
335                 }
336             }
337         }
338         return false;
339     }
340 
341     /**
342      * An invalid value for {@link #rtldDefault}.
343      */
344     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
345 
346     /**
347      * Address of the library lookup routine. The C signature of this routine is:
348      *
349      * &lt;pre&gt;
350      *     void* (const char *filename, char *ebuf, int ebuflen)
351      * &lt;/pre&gt;
352      */
353     public final long dllLoad = getAddress(&quot;os::dll_load&quot;);
354 
355     /**
356      * Address of the library lookup routine. The C signature of this routine is:
357      *
358      * &lt;pre&gt;
359      *     void* (void* handle, const char* name)
360      * &lt;/pre&gt;
361      */
362     public final long dllLookup = getAddress(&quot;os::dll_lookup&quot;);
363 
364     /**
365      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
366      * return the first occurrence of the desired symbol using the default library search order. If
367      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
368      * the current platform.
369      */
370     public final long rtldDefault = getAddress(&quot;RTLD_DEFAULT&quot;, osName.equals(&quot;bsd&quot;) || osName.equals(&quot;linux&quot;) ? null : INVALID_RTLD_DEFAULT_HANDLE);
371 
372     /**
373      * This field is used to pass exception objects into and out of the runtime system during
374      * exception handling for compiled code.
375      */
376     public final int threadExceptionOopOffset = getFieldOffset(&quot;JavaThread::_exception_oop&quot;, Integer.class, &quot;oop&quot;);
377     public final int threadExceptionPcOffset = getFieldOffset(&quot;JavaThread::_exception_pc&quot;, Integer.class, &quot;address&quot;);
378     public final int pendingExceptionOffset = getFieldOffset(&quot;ThreadShadow::_pending_exception&quot;, Integer.class, &quot;oop&quot;);
379 
380     public final int pendingDeoptimizationOffset = getFieldOffset(&quot;JavaThread::_pending_deoptimization&quot;, Integer.class, &quot;int&quot;);
381     public final int pendingTransferToInterpreterOffset = getFieldOffset(&quot;JavaThread::_pending_transfer_to_interpreter&quot;, Integer.class, &quot;bool&quot;);
382 
383     private final int javaFrameAnchorLastJavaSpOffset = getFieldOffset(&quot;JavaFrameAnchor::_last_Java_sp&quot;, Integer.class, &quot;intptr_t*&quot;);
384     private final int javaFrameAnchorLastJavaPcOffset = getFieldOffset(&quot;JavaFrameAnchor::_last_Java_pc&quot;, Integer.class, &quot;address&quot;);
385 
386     public final int pendingFailedSpeculationOffset;
387     {
388         String name = &quot;JavaThread::_pending_failed_speculation&quot;;
389         int offset = -1;
390         try {
391             offset = getFieldOffset(name, Integer.class, &quot;jlong&quot;);
392         } catch (JVMCIError e) {
393             try {
394                 offset = getFieldOffset(name, Integer.class, &quot;long&quot;);
395             } catch (JVMCIError e2) {
396             }
397         }
398         if (offset == -1) {
399             throw new JVMCIError(&quot;cannot get offset of field &quot; + name + &quot; with type long or jlong&quot;);
400         }
401         pendingFailedSpeculationOffset = offset;
402     }
403 
404     public int threadLastJavaSpOffset() {
405         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
406     }
407 
408     public int threadLastJavaPcOffset() {
409         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
410     }
411 
412     public int threadLastJavaFpOffset() {
413         assert osArch.equals(&quot;aarch64&quot;) || osArch.equals(&quot;amd64&quot;);
414         return javaThreadAnchorOffset + getFieldOffset(&quot;JavaFrameAnchor::_last_Java_fp&quot;, Integer.class, &quot;intptr_t*&quot;);
415     }
416 
417     public int threadJavaFrameAnchorFlagsOffset() {
418         assert osArch.equals(&quot;sparc&quot;);
419         return javaThreadAnchorOffset + getFieldOffset(&quot;JavaFrameAnchor::_flags&quot;, Integer.class, &quot;int&quot;);
420     }
421 
422     public final int runtimeCallStackSize = getConstant(&quot;frame::arg_reg_save_area_bytes&quot;, Integer.class, intRequiredOnAMD64);
423     public final int frameInterpreterFrameSenderSpOffset = getConstant(&quot;frame::interpreter_frame_sender_sp_offset&quot;, Integer.class, intRequiredOnAMD64);
424     public final int frameInterpreterFrameLastSpOffset = getConstant(&quot;frame::interpreter_frame_last_sp_offset&quot;, Integer.class, intRequiredOnAMD64);
425 
426     public final int osThreadInterruptedOffset = getFieldOffset(&quot;OSThread::_interrupted&quot;, Integer.class, &quot;jint&quot;, Integer.MAX_VALUE);
427 
428     public final long markWordHashShift = getConstant(markWordField(&quot;hash_shift&quot;), Long.class);
429 
430     public final int biasedLockMaskInPlace = getConstant(markWordField(&quot;biased_lock_mask_in_place&quot;), Integer.class);
431     public final int ageMaskInPlace = getConstant(markWordField(&quot;age_mask_in_place&quot;), Integer.class);
432     public final int epochMaskInPlace = getConstant(markWordField(&quot;epoch_mask_in_place&quot;), Integer.class);
433     public final long markWordHashMask = getConstant(markWordField(&quot;hash_mask&quot;), Long.class);
434     public final long markWordHashMaskInPlace = getConstant(markWordField(&quot;hash_mask_in_place&quot;), Long.class);
435 
436     public final int unlockedMask = getConstant(markWordField(&quot;unlocked_value&quot;), Integer.class);
437     public final int monitorMask = getConstant(markWordField(&quot;monitor_value&quot;), Integer.class, -1);
438     public final int biasedLockPattern = getConstant(markWordField(&quot;biased_lock_pattern&quot;), Integer.class);
439 
440     // This field has no type in vmStructs.cpp
441     public final int objectMonitorOwner = getFieldOffset(&quot;ObjectMonitor::_owner&quot;, Integer.class, null, -1);
442     public final int objectMonitorRecursions = getFieldOffset(&quot;ObjectMonitor::_recursions&quot;, Integer.class, &quot;intptr_t&quot;, -1);
443     public final int objectMonitorCxq = getFieldOffset(&quot;ObjectMonitor::_cxq&quot;, Integer.class, &quot;ObjectWaiter*&quot;, -1);
444     public final int objectMonitorEntryList = getFieldOffset(&quot;ObjectMonitor::_EntryList&quot;, Integer.class, &quot;ObjectWaiter*&quot;, -1);
445     public final int objectMonitorSucc = getFieldOffset(&quot;ObjectMonitor::_succ&quot;, Integer.class, &quot;Thread*&quot;, -1);
446 
447     public final int markWordNoHashInPlace = getConstant(markWordField(&quot;no_hash_in_place&quot;), Integer.class);
448     public final int markWordNoLockInPlace = getConstant(markWordField(&quot;no_lock_in_place&quot;), Integer.class);
449 
450     /**
451      * See {@code markOopDesc::prototype()}/{@code markWord::prototype()}.
452      */
453     public long arrayPrototypeMarkWord() {
454         return markWordNoHashInPlace | markWordNoLockInPlace;
455     }
456 
457     /**
458      * See {@code markOopDesc::copy_set_hash()}/{@code markWord::copy_set_hash()}.
459      */
460     public long tlabIntArrayMarkWord() {
461         long tmp = arrayPrototypeMarkWord() &amp; (~markWordHashMaskInPlace);
462         tmp |= ((0x2 &amp; markWordHashMask) &lt;&lt; markWordHashShift);
463         return tmp;
464     }
465 
466     private String markWordField(String simpleName) {
467         return versioned.markWordClassName + &quot;::&quot; + simpleName;
468     }
469 
470     /**
471      * Mark word right shift to get identity hash code.
472      */
473     public final int identityHashCodeShift = getConstant(markWordField(&quot;hash_shift&quot;), Integer.class);
474 
475     /**
476      * Identity hash code value when uninitialized.
477      */
478     public final int uninitializedIdentityHashCodeValue = getConstant(markWordField(&quot;no_hash&quot;), Integer.class);
479 
480     public final int methodAccessFlagsOffset = getFieldOffset(&quot;Method::_access_flags&quot;, Integer.class, &quot;AccessFlags&quot;);
481     public final int methodConstMethodOffset = getFieldOffset(&quot;Method::_constMethod&quot;, Integer.class, &quot;ConstMethod*&quot;);
482     public final int methodIntrinsicIdOffset = versioned.methodIntrinsicIdOffset;
483     public final int methodFlagsOffset = versioned.methodFlagsOffset;
484     public final int methodVtableIndexOffset = getFieldOffset(&quot;Method::_vtable_index&quot;, Integer.class, &quot;int&quot;);
485 
486     public final int methodCountersOffset = getFieldOffset(&quot;Method::_method_counters&quot;, Integer.class, &quot;MethodCounters*&quot;);
487     public final int methodDataOffset = getFieldOffset(&quot;Method::_method_data&quot;, Integer.class, &quot;MethodData*&quot;);
488     public final int methodCompiledEntryOffset = getFieldOffset(&quot;Method::_from_compiled_entry&quot;, Integer.class, &quot;address&quot;);
489     public final int methodCodeOffset = versioned.methodCodeOffset;
490 
491     public final int methodFlagsCallerSensitive = getConstant(&quot;Method::_caller_sensitive&quot;, Integer.class);
492     public final int methodFlagsForceInline = getConstant(&quot;Method::_force_inline&quot;, Integer.class);
493     public final int methodFlagsDontInline = getConstant(&quot;Method::_dont_inline&quot;, Integer.class);
494     public final int methodFlagsHidden = getConstant(&quot;Method::_hidden&quot;, Integer.class);
495     public final int nonvirtualVtableIndex = getConstant(&quot;Method::nonvirtual_vtable_index&quot;, Integer.class);
496     public final int invalidVtableIndex = getConstant(&quot;Method::invalid_vtable_index&quot;, Integer.class);
497 
498     public final int invocationCounterOffset = getFieldOffset(&quot;MethodCounters::_invocation_counter&quot;, Integer.class, &quot;InvocationCounter&quot;);
499     public final int backedgeCounterOffset = getFieldOffset(&quot;MethodCounters::_backedge_counter&quot;, Integer.class, &quot;InvocationCounter&quot;);
500     public final int invocationCounterIncrement = versioned.invocationCounterIncrement;
501     public final int invocationCounterShift = versioned.invocationCounterShift;
502 
503     public final int nmethodEntryOffset = getFieldOffset(&quot;nmethod::_verified_entry_point&quot;,
504                     Integer.class, &quot;address&quot;);
505     public final int compilationLevelFullOptimization = getConstant(&quot;CompLevel_full_optimization&quot;,
506                     Integer.class);
507 
508     public final int constantPoolSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_ConstantPool&quot;, Integer.class, &quot;int&quot;);
509     public final int constantPoolLengthOffset = getFieldOffset(&quot;ConstantPool::_length&quot;,
510                     Integer.class, &quot;int&quot;);
511 
512     public final int heapWordSize = getConstant(&quot;HeapWordSize&quot;, Integer.class);
513 
514     /**
515      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
516      * are allowed to look like (respectively) the high or low bits of a real oop.
517      */
518     public final long nonOopBits = getFieldValue(&quot;CompilerToVM::Data::Universe_non_oop_bits&quot;, Long.class, &quot;void*&quot;);
519 
520     public final long verifyOopCounterAddress = getFieldAddress(&quot;StubRoutines::_verify_oop_count&quot;, &quot;jint&quot;);
521     public final long verifyOopMask = getFieldValue(&quot;CompilerToVM::Data::Universe_verify_oop_mask&quot;, Long.class, &quot;uintptr_t&quot;);
522     public final long verifyOopBits = getFieldValue(&quot;CompilerToVM::Data::Universe_verify_oop_bits&quot;, Long.class, &quot;uintptr_t&quot;);
523 
524     public final int logOfHRGrainBytes = getFieldValue(&quot;HeapRegion::LogOfHRGrainBytes&quot;, Integer.class, &quot;int&quot;);
525 
526     public final long cardtableStartAddress = getFieldValue(&quot;CompilerToVM::Data::cardtable_start_address&quot;, Long.class, &quot;CardTable::CardValue*&quot;);
527     public final int cardtableShift = getFieldValue(&quot;CompilerToVM::Data::cardtable_shift&quot;, Integer.class, &quot;int&quot;);
528 
529     /**
530      * This is the largest stack offset encodeable in an OopMapValue. Offsets larger than this will
531      * throw an exception during code installation.
532      */
533     public final int maxOopMapStackOffset = getFieldValue(&quot;CompilerToVM::Data::_max_oop_map_stack_offset&quot;, Integer.class, &quot;int&quot;);
534 
535     public final long safepointPollingAddress = getFieldValue(&quot;os::_polling_page&quot;, Long.class, &quot;address&quot;);
536 
537     // G1 Collector Related Values.
538 
539     public final byte dirtyCardValue = versioned.dirtyCardValue;
540     public final byte g1YoungCardValue = versioned.g1YoungCardValue;
541 
542     public final int g1SATBQueueMarkingOffset = versioned.g1SATBQueueMarkingOffset;
543     public final int g1SATBQueueIndexOffset = versioned.g1SATBQueueIndexOffset;
544     public final int g1SATBQueueBufferOffset = versioned.g1SATBQueueBufferOffset;
545     public final int g1CardQueueIndexOffset = versioned.g1CardQueueIndexOffset;
546     public final int g1CardQueueBufferOffset = versioned.g1CardQueueBufferOffset;
547 
548     public final int klassOffset = getFieldValue(&quot;java_lang_Class::_klass_offset&quot;, Integer.class, &quot;int&quot;);
549     public final int arrayKlassOffset = getFieldValue(&quot;java_lang_Class::_array_klass_offset&quot;, Integer.class, &quot;int&quot;);
550 
551     public final int basicLockSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_BasicLock&quot;, Integer.class, &quot;int&quot;);
552     public final int basicLockDisplacedHeaderOffset = getFieldOffset(&quot;BasicLock::_displaced_header&quot;, Integer.class, markWord);
553 
554     public final int threadPollingPageOffset = getFieldOffset(&quot;Thread::_polling_page&quot;, Integer.class, &quot;volatile void*&quot;, -1);
555     public final int threadAllocatedBytesOffset = getFieldOffset(&quot;Thread::_allocated_bytes&quot;, Integer.class, &quot;jlong&quot;);
556 
557     public final int tlabRefillWasteIncrement = getFlag(&quot;TLABWasteIncrement&quot;, Integer.class);
558 
559     private final int threadLocalAllocBufferStartOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_start&quot;, Integer.class, &quot;HeapWord*&quot;);
560     private final int threadLocalAllocBufferEndOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_end&quot;, Integer.class, &quot;HeapWord*&quot;);
561     private final int threadLocalAllocBufferTopOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_top&quot;, Integer.class, &quot;HeapWord*&quot;);
562     private final int threadLocalAllocBufferPfTopOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_pf_top&quot;, Integer.class, &quot;HeapWord*&quot;);
563     private final int threadLocalAllocBufferSlowAllocationsOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_slow_allocations&quot;, Integer.class, &quot;unsigned&quot;);
564     private final int threadLocalAllocBufferFastRefillWasteOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_fast_refill_waste&quot;, Integer.class, &quot;unsigned&quot;);
565     private final int threadLocalAllocBufferNumberOfRefillsOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_number_of_refills&quot;, Integer.class, &quot;unsigned&quot;);
566     private final int threadLocalAllocBufferRefillWasteLimitOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_refill_waste_limit&quot;, Integer.class, &quot;size_t&quot;);
567     private final int threadLocalAllocBufferDesiredSizeOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_desired_size&quot;, Integer.class, &quot;size_t&quot;);
568 
569     public int tlabSlowAllocationsOffset() {
570         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
571     }
572 
573     public int tlabFastRefillWasteOffset() {
574         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
575     }
576 
577     public int tlabNumberOfRefillsOffset() {
578         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
579     }
580 
581     public int tlabRefillWasteLimitOffset() {
582         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
583     }
584 
585     public int threadTlabSizeOffset() {
586         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
587     }
588 
589     public int threadTlabStartOffset() {
590         return threadTlabOffset + threadLocalAllocBufferStartOffset;
591     }
592 
593     public int threadTlabEndOffset() {
594         return threadTlabOffset + threadLocalAllocBufferEndOffset;
595     }
596 
597     public int threadTlabTopOffset() {
598         return threadTlabOffset + threadLocalAllocBufferTopOffset;
599     }
600 
601     public int threadTlabPfTopOffset() {
602         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
603     }
604 
605     public final int tlabAlignmentReserve = getFieldValue(&quot;CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve&quot;, Integer.class, &quot;size_t&quot;);
606 
607     public final boolean tlabStats = getFlag(&quot;TLABStats&quot;, Boolean.class);
608 
609     // We set 0x10 as default value to disable DC ZVA if this field is not present in HotSpot.
610     // ARMv8-A architecture reference manual D12.2.35 Data Cache Zero ID register says:
611     // * BS, bits [3:0] indicate log2 of the DC ZVA block size in (4-byte) words.
612     // * DZP, bit [4] of indicates whether use of DC ZVA instruction is prohibited.
613     public final int psrInfoDczidValue = getFieldValue(&quot;VM_Version::_psr_info.dczid_el0&quot;, Integer.class, &quot;uint32_t&quot;, 0x10);
614 
615     // FIXME This is only temporary until the GC code is changed.
616     public final boolean inlineContiguousAllocationSupported = getFieldValue(&quot;CompilerToVM::Data::_supports_inline_contig_alloc&quot;, Boolean.class);
617     public final long heapEndAddress = getFieldValue(&quot;CompilerToVM::Data::_heap_end_addr&quot;, Long.class, &quot;HeapWord**&quot;);
618     public final long heapTopAddress = versioned.heapTopAddress;
619 
620     public final boolean cmsIncrementalMode = getFlag(&quot;CMSIncrementalMode&quot;, Boolean.class, false);
621 
622     public final long inlineCacheMissStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_ic_miss_stub&quot;, Long.class, &quot;address&quot;);
623     public final long handleWrongMethodStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub&quot;, Long.class, &quot;address&quot;);
624 
625     public final long deoptBlobUnpack = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack&quot;, Long.class, &quot;address&quot;);
626     public final long deoptBlobUnpackWithExceptionInTLS = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack_with_exception_in_tls&quot;, Long.class, &quot;address&quot;, 0L);
627     public final long deoptBlobUncommonTrap = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap&quot;, Long.class, &quot;address&quot;);
628 
629     public final long codeCacheLowBound = versioned.codeCacheLowBound;
630     public final long codeCacheHighBound = versioned.codeCacheHighBound;
631 
632     public final long aescryptEncryptBlockStub = getFieldValue(&quot;StubRoutines::_aescrypt_encryptBlock&quot;, Long.class, &quot;address&quot;);
633     public final long aescryptDecryptBlockStub = getFieldValue(&quot;StubRoutines::_aescrypt_decryptBlock&quot;, Long.class, &quot;address&quot;);
634     public final long cipherBlockChainingEncryptAESCryptStub = getFieldValue(&quot;StubRoutines::_cipherBlockChaining_encryptAESCrypt&quot;, Long.class, &quot;address&quot;);
635     public final long cipherBlockChainingDecryptAESCryptStub = getFieldValue(&quot;StubRoutines::_cipherBlockChaining_decryptAESCrypt&quot;, Long.class, &quot;address&quot;);
636     public final long updateBytesCRC32Stub = getFieldValue(&quot;StubRoutines::_updateBytesCRC32&quot;, Long.class, &quot;address&quot;);
637     public final long crcTableAddress = getFieldValue(&quot;StubRoutines::_crc_table_adr&quot;, Long.class, &quot;address&quot;);
638 
639     public final long sha1ImplCompress = getFieldValue(&quot;StubRoutines::_sha1_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
640     public final long sha1ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha1_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
641     public final long sha256ImplCompress = getFieldValue(&quot;StubRoutines::_sha256_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
642     public final long sha256ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha256_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
643     public final long sha512ImplCompress = getFieldValue(&quot;StubRoutines::_sha512_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
644     public final long sha512ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha512_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
645     public final long multiplyToLen = getFieldValue(&quot;StubRoutines::_multiplyToLen&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
646 
647     public final long counterModeAESCrypt = getFieldValue(&quot;StubRoutines::_counterMode_AESCrypt&quot;, Long.class, &quot;address&quot;, 0L);
648     public final long ghashProcessBlocks = getFieldValue(&quot;StubRoutines::_ghash_processBlocks&quot;, Long.class, &quot;address&quot;, 0L);
649     public final long base64EncodeBlock = getFieldValue(&quot;StubRoutines::_base64_encodeBlock&quot;, Long.class, &quot;address&quot;, 0L);
650     public final long crc32cTableTddr = getFieldValue(&quot;StubRoutines::_crc32c_table_addr&quot;, Long.class, &quot;address&quot;, 0L);
651     public final long updateBytesCRC32C = getFieldValue(&quot;StubRoutines::_updateBytesCRC32C&quot;, Long.class, &quot;address&quot;, 0L);
652     public final long updateBytesAdler32 = getFieldValue(&quot;StubRoutines::_updateBytesAdler32&quot;, Long.class, &quot;address&quot;, 0L);
653     public final long squareToLen = getFieldValue(&quot;StubRoutines::_squareToLen&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
654     public final long mulAdd = getFieldValue(&quot;StubRoutines::_mulAdd&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
655     public final long montgomeryMultiply = getFieldValue(&quot;StubRoutines::_montgomeryMultiply&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
656     public final long montgomerySquare = getFieldValue(&quot;StubRoutines::_montgomerySquare&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
657     public final long vectorizedMismatch = getFieldValue(&quot;StubRoutines::_vectorizedMismatch&quot;, Long.class, &quot;address&quot;, 0L);
658 
659     public final long throwDelayedStackOverflowErrorEntry = versioned.throwDelayedStackOverflowErrorEntry;
660 
661     public final long jbyteArraycopy = getFieldValue(&quot;StubRoutines::_jbyte_arraycopy&quot;, Long.class, &quot;address&quot;);
662     public final long jshortArraycopy = getFieldValue(&quot;StubRoutines::_jshort_arraycopy&quot;, Long.class, &quot;address&quot;);
663     public final long jintArraycopy = getFieldValue(&quot;StubRoutines::_jint_arraycopy&quot;, Long.class, &quot;address&quot;);
664     public final long jlongArraycopy = getFieldValue(&quot;StubRoutines::_jlong_arraycopy&quot;, Long.class, &quot;address&quot;);
665     public final long oopArraycopy = getFieldValue(&quot;StubRoutines::_oop_arraycopy&quot;, Long.class, &quot;address&quot;);
666     public final long oopArraycopyUninit = getFieldValue(&quot;StubRoutines::_oop_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
667     public final long jbyteDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jbyte_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
668     public final long jshortDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jshort_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
669     public final long jintDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jint_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
670     public final long jlongDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jlong_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
671     public final long oopDisjointArraycopy = getFieldValue(&quot;StubRoutines::_oop_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
672     public final long oopDisjointArraycopyUninit = getFieldValue(&quot;StubRoutines::_oop_disjoint_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
673     public final long jbyteAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jbyte_arraycopy&quot;, Long.class, &quot;address&quot;);
674     public final long jshortAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jshort_arraycopy&quot;, Long.class, &quot;address&quot;);
675     public final long jintAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jint_arraycopy&quot;, Long.class, &quot;address&quot;);
676     public final long jlongAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jlong_arraycopy&quot;, Long.class, &quot;address&quot;);
677     public final long oopAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_oop_arraycopy&quot;, Long.class, &quot;address&quot;);
678     public final long oopAlignedArraycopyUninit = getFieldValue(&quot;StubRoutines::_arrayof_oop_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
679     public final long jbyteAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jbyte_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
680     public final long jshortAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jshort_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
681     public final long jintAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jint_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
682     public final long jlongAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jlong_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
683     public final long oopAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
684     public final long oopAlignedDisjointArraycopyUninit = getFieldValue(&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
685     public final long checkcastArraycopy = getFieldValue(&quot;StubRoutines::_checkcast_arraycopy&quot;, Long.class, &quot;address&quot;);
686     public final long checkcastArraycopyUninit = getFieldValue(&quot;StubRoutines::_checkcast_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
687     public final long unsafeArraycopy = getFieldValue(&quot;StubRoutines::_unsafe_arraycopy&quot;, Long.class, &quot;address&quot;);
688     public final long genericArraycopy = getFieldValue(&quot;StubRoutines::_generic_arraycopy&quot;, Long.class, &quot;address&quot;);
689 
690     // Allocation stubs that throw an exception when allocation fails
691     public final long newInstanceAddress = getAddress(&quot;JVMCIRuntime::new_instance&quot;);
692     public final long newArrayAddress = getAddress(&quot;JVMCIRuntime::new_array&quot;);
693     public final long newMultiArrayAddress = getAddress(&quot;JVMCIRuntime::new_multi_array&quot;);
694     public final long dynamicNewInstanceAddress = getAddress(&quot;JVMCIRuntime::dynamic_new_instance&quot;);
695 
696     // Allocation stubs that return null when allocation fails
697     public final long newInstanceOrNullAddress = getAddress(&quot;JVMCIRuntime::new_instance_or_null&quot;, 0L);
698     public final long newArrayOrNullAddress = getAddress(&quot;JVMCIRuntime::new_array_or_null&quot;, 0L);
699     public final long newMultiArrayOrNullAddress = getAddress(&quot;JVMCIRuntime::new_multi_array_or_null&quot;, 0L);
700     public final long dynamicNewInstanceOrNullAddress = getAddress(&quot;JVMCIRuntime::dynamic_new_instance_or_null&quot;, 0L);
701 
702     public boolean areNullAllocationStubsAvailable() {
703         return newInstanceOrNullAddress != 0L;
704     }
705 
706     /**
707      * Checks that HotSpot implements all or none of the allocate-or-null stubs.
708      */
709     private boolean checkNullAllocationStubs() {
710         if (newInstanceOrNullAddress == 0L) {
711             assert newArrayOrNullAddress == 0L;
712             assert newMultiArrayOrNullAddress == 0L;
713             assert dynamicNewInstanceOrNullAddress == 0L;
714         } else {
715             assert newArrayOrNullAddress != 0L;
716             assert newMultiArrayOrNullAddress != 0L;
717             assert dynamicNewInstanceOrNullAddress != 0L;
718         }
719         return true;
720     }
721 
722     public final long vmMessageAddress = getAddress(&quot;JVMCIRuntime::vm_message&quot;);
723     public final long identityHashCodeAddress = getAddress(&quot;JVMCIRuntime::identity_hash_code&quot;);
724     public final long exceptionHandlerForPcAddress = getAddress(&quot;JVMCIRuntime::exception_handler_for_pc&quot;);
725     public final long monitorenterAddress = getAddress(&quot;JVMCIRuntime::monitorenter&quot;);
726     public final long monitorexitAddress = getAddress(&quot;JVMCIRuntime::monitorexit&quot;);
727     public final long notifyAddress = getAddress(&quot;JVMCIRuntime::object_notify&quot;, 0L);
728     public final long notifyAllAddress = getAddress(&quot;JVMCIRuntime::object_notifyAll&quot;, 0L);
729     public final long throwAndPostJvmtiExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_and_post_jvmti_exception&quot;);
730     public final long throwKlassExternalNameExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_klass_external_name_exception&quot;);
731     public final long throwClassCastExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_class_cast_exception&quot;);
732     public final long logPrimitiveAddress = getAddress(&quot;JVMCIRuntime::log_primitive&quot;);
733     public final long logObjectAddress = getAddress(&quot;JVMCIRuntime::log_object&quot;);
734     public final long logPrintfAddress = getAddress(&quot;JVMCIRuntime::log_printf&quot;);
735     public final long vmErrorAddress = getAddress(&quot;JVMCIRuntime::vm_error&quot;);
736     public final long loadAndClearExceptionAddress = getAddress(&quot;JVMCIRuntime::load_and_clear_exception&quot;);
737     public final long writeBarrierPreAddress = getAddress(&quot;JVMCIRuntime::write_barrier_pre&quot;);
738     public final long writeBarrierPostAddress = getAddress(&quot;JVMCIRuntime::write_barrier_post&quot;);
739     public final long validateObject = getAddress(&quot;JVMCIRuntime::validate_object&quot;);
740 
741     public final long testDeoptimizeCallInt = getAddress(&quot;JVMCIRuntime::test_deoptimize_call_int&quot;);
742 
743     public final long registerFinalizerAddress = getAddress(&quot;SharedRuntime::register_finalizer&quot;);
744     public final long exceptionHandlerForReturnAddressAddress = getAddress(&quot;SharedRuntime::exception_handler_for_return_address&quot;);
745     public final long osrMigrationEndAddress = getAddress(&quot;SharedRuntime::OSR_migration_end&quot;);
746     public final long enableStackReservedZoneAddress = versioned.enableStackReservedZoneAddress;
747 
748     public final long javaTimeMillisAddress = getAddress(&quot;os::javaTimeMillis&quot;);
749     public final long javaTimeNanosAddress = getAddress(&quot;os::javaTimeNanos&quot;);
750     public final long arithmeticSinAddress = getFieldValue(&quot;CompilerToVM::Data::dsin&quot;, Long.class, &quot;address&quot;);
751     public final long arithmeticCosAddress = getFieldValue(&quot;CompilerToVM::Data::dcos&quot;, Long.class, &quot;address&quot;);
752     public final long arithmeticTanAddress = getFieldValue(&quot;CompilerToVM::Data::dtan&quot;, Long.class, &quot;address&quot;);
753     public final long arithmeticExpAddress = getFieldValue(&quot;CompilerToVM::Data::dexp&quot;, Long.class, &quot;address&quot;);
754     public final long arithmeticLogAddress = getFieldValue(&quot;CompilerToVM::Data::dlog&quot;, Long.class, &quot;address&quot;);
755     public final long arithmeticLog10Address = getFieldValue(&quot;CompilerToVM::Data::dlog10&quot;, Long.class, &quot;address&quot;);
756     public final long arithmeticPowAddress = getFieldValue(&quot;CompilerToVM::Data::dpow&quot;, Long.class, &quot;address&quot;);
757 
758     public final long fremAddress = getAddress(&quot;SharedRuntime::frem&quot;);
759     public final long dremAddress = getAddress(&quot;SharedRuntime::drem&quot;);
760 
761     public final int jvmciCountersSize = getFlag(&quot;JVMCICounterSize&quot;, Integer.class);
762 
763     public final long deoptimizationFetchUnrollInfo = getAddress(&quot;Deoptimization::fetch_unroll_info&quot;);
764     public final long deoptimizationUncommonTrap = getAddress(&quot;Deoptimization::uncommon_trap&quot;);
765     public final long deoptimizationUnpackFrames = getAddress(&quot;Deoptimization::unpack_frames&quot;);
766 
767     public final int deoptimizationUnpackDeopt = getConstant(&quot;Deoptimization::Unpack_deopt&quot;, Integer.class);
768     public final int deoptimizationUnpackException = getConstant(&quot;Deoptimization::Unpack_exception&quot;, Integer.class);
769     public final int deoptimizationUnpackUncommonTrap = getConstant(&quot;Deoptimization::Unpack_uncommon_trap&quot;, Integer.class);
770     public final int deoptimizationUnpackReexecute = getConstant(&quot;Deoptimization::Unpack_reexecute&quot;, Integer.class);
771 
772     public final int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_size_of_deoptimized_frame&quot;, Integer.class, &quot;int&quot;);
773     public final int deoptimizationUnrollBlockCallerAdjustmentOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_caller_adjustment&quot;, Integer.class, &quot;int&quot;);
774     public final int deoptimizationUnrollBlockNumberOfFramesOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_number_of_frames&quot;, Integer.class, &quot;int&quot;);
775     public final int deoptimizationUnrollBlockTotalFrameSizesOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_total_frame_sizes&quot;, Integer.class, &quot;int&quot;);
776     public final int deoptimizationUnrollBlockUnpackKindOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_unpack_kind&quot;, Integer.class, &quot;int&quot;);
777     public final int deoptimizationUnrollBlockFrameSizesOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_frame_sizes&quot;, Integer.class, &quot;intptr_t*&quot;);
778     public final int deoptimizationUnrollBlockFramePcsOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_frame_pcs&quot;, Integer.class, &quot;address*&quot;);
779     public final int deoptimizationUnrollBlockInitialInfoOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_initial_info&quot;, Integer.class, &quot;intptr_t&quot;);
780 
781     public final boolean deoptimizationSupportLargeAccessByteArrayVirtualization = getConstant(&quot;Deoptimization::_support_large_access_byte_array_virtualization&quot;, Boolean.class, false);
782 
783     // Checkstyle: stop
784     public final int MARKID_VERIFIED_ENTRY = getConstant(&quot;CodeInstaller::VERIFIED_ENTRY&quot;, Integer.class);
785     public final int MARKID_UNVERIFIED_ENTRY = getConstant(&quot;CodeInstaller::UNVERIFIED_ENTRY&quot;, Integer.class);
786     public final int MARKID_OSR_ENTRY = getConstant(&quot;CodeInstaller::OSR_ENTRY&quot;, Integer.class);
787     public final int MARKID_EXCEPTION_HANDLER_ENTRY = getConstant(&quot;CodeInstaller::EXCEPTION_HANDLER_ENTRY&quot;, Integer.class);
788     public final int MARKID_DEOPT_HANDLER_ENTRY = getConstant(&quot;CodeInstaller::DEOPT_HANDLER_ENTRY&quot;, Integer.class);
789     public final int MARKID_INVOKEINTERFACE = getConstant(&quot;CodeInstaller::INVOKEINTERFACE&quot;, Integer.class);
790     public final int MARKID_INVOKEVIRTUAL = getConstant(&quot;CodeInstaller::INVOKEVIRTUAL&quot;, Integer.class);
791     public final int MARKID_INVOKESTATIC = getConstant(&quot;CodeInstaller::INVOKESTATIC&quot;, Integer.class);
792     public final int MARKID_INVOKESPECIAL = getConstant(&quot;CodeInstaller::INVOKESPECIAL&quot;, Integer.class);
793     public final int MARKID_INLINE_INVOKE = getConstant(&quot;CodeInstaller::INLINE_INVOKE&quot;, Integer.class);
794     public final int MARKID_POLL_NEAR = getConstant(&quot;CodeInstaller::POLL_NEAR&quot;, Integer.class);
795     public final int MARKID_POLL_RETURN_NEAR = getConstant(&quot;CodeInstaller::POLL_RETURN_NEAR&quot;, Integer.class);
796     public final int MARKID_POLL_FAR = getConstant(&quot;CodeInstaller::POLL_FAR&quot;, Integer.class);
797     public final int MARKID_POLL_RETURN_FAR = getConstant(&quot;CodeInstaller::POLL_RETURN_FAR&quot;, Integer.class);
798     public final int MARKID_CARD_TABLE_SHIFT = getConstant(&quot;CodeInstaller::CARD_TABLE_SHIFT&quot;, Integer.class);
799     public final int MARKID_CARD_TABLE_ADDRESS = getConstant(&quot;CodeInstaller::CARD_TABLE_ADDRESS&quot;, Integer.class);
800     public final int MARKID_INVOKE_INVALID = getConstant(&quot;CodeInstaller::INVOKE_INVALID&quot;, Integer.class);
801 
802     /**
803      * The following constants are given default values here since they are missing in the native
804      * JVMCI-8 code but are still required for {@link GraalHotSpotVMConfigNode#canonical} to work in
805      * a JDK8 environment.
806      */
807     public final int MARKID_HEAP_TOP_ADDRESS = getConstant(&quot;CodeInstaller::HEAP_TOP_ADDRESS&quot;, Integer.class, 17);
808     public final int MARKID_HEAP_END_ADDRESS = getConstant(&quot;CodeInstaller::HEAP_END_ADDRESS&quot;, Integer.class, 18);
809     public final int MARKID_NARROW_KLASS_BASE_ADDRESS = getConstant(&quot;CodeInstaller::NARROW_KLASS_BASE_ADDRESS&quot;, Integer.class, 19);
810     public final int MARKID_NARROW_OOP_BASE_ADDRESS = getConstant(&quot;CodeInstaller::NARROW_OOP_BASE_ADDRESS&quot;, Integer.class, 20);
811     public final int MARKID_CRC_TABLE_ADDRESS = getConstant(&quot;CodeInstaller::CRC_TABLE_ADDRESS&quot;, Integer.class, 21);
812     public final int MARKID_LOG_OF_HEAP_REGION_GRAIN_BYTES = getConstant(&quot;CodeInstaller::LOG_OF_HEAP_REGION_GRAIN_BYTES&quot;, Integer.class, 22);
813     public final int MARKID_INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED = getConstant(&quot;CodeInstaller::INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED&quot;, Integer.class, 23);
814 
815     // Checkstyle: resume
816 
817     protected boolean check() {
818         for (Field f : getClass().getDeclaredFields()) {
819             int modifiers = f.getModifiers();
820             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
821                 assert Modifier.isFinal(modifiers) : &quot;field should be final: &quot; + f;
822             }
823         }
824 
825         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
826         assert checkNullAllocationStubs();
827         return true;
828     }
829 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/HotSpotReplacementsUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.replacements;
 26 
 27 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_METAACCESS;
 28 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_VMCONFIG;
 29 import static org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProviderImpl.VERIFY_OOP;
 30 
 31 import java.lang.ref.Reference;
 32 
 33 import org.graalvm.compiler.api.replacements.Fold;
 34 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
 35 import org.graalvm.compiler.core.common.SuppressFBWarnings;
 36 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 37 import org.graalvm.compiler.core.common.type.ObjectStamp;
 38 import org.graalvm.compiler.core.common.type.TypeReference;
 39 import org.graalvm.compiler.debug.GraalError;
 40 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
 41 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 42 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 43 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 44 import org.graalvm.compiler.hotspot.word.KlassPointer;
 45 import org.graalvm.compiler.nodes.CanonicalizableLocation;
 46 import org.graalvm.compiler.nodes.CompressionNode;
 47 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 48 import org.graalvm.compiler.nodes.ConstantNode;
 49 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 50 import org.graalvm.compiler.nodes.NodeView;
 51 import org.graalvm.compiler.nodes.ValueNode;
 52 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 53 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 54 import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;
 55 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 56 import org.graalvm.compiler.nodes.extended.StoreHubNode;
 57 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 58 import org.graalvm.compiler.nodes.memory.AddressableMemoryAccess;
 59 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 60 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 61 import org.graalvm.compiler.nodes.type.StampTool;
 62 import org.graalvm.compiler.replacements.ReplacementsUtil;
 63 import org.graalvm.compiler.replacements.nodes.ReadRegisterNode;
 64 import org.graalvm.compiler.replacements.nodes.WriteRegisterNode;
 65 import org.graalvm.compiler.word.Word;
 66 import jdk.internal.vm.compiler.word.LocationIdentity;
 67 import jdk.internal.vm.compiler.word.WordFactory;
 68 
 69 import jdk.vm.ci.code.Register;
 70 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 71 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 72 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 73 import jdk.vm.ci.meta.Assumptions;
 74 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 75 import jdk.vm.ci.meta.JavaKind;
 76 import jdk.vm.ci.meta.MetaAccessProvider;
 77 import jdk.vm.ci.meta.ResolvedJavaField;
 78 import jdk.vm.ci.meta.ResolvedJavaType;
 79 import jdk.vm.ci.meta.UnresolvedJavaType;
 80 
 81 //JaCoCo Exclude
 82 
 83 /**
 84  * A collection of methods used in HotSpot snippets, substitutions and stubs.
 85  */
 86 public class HotSpotReplacementsUtil {
 87 
 88     abstract static class HotSpotOptimizingLocationIdentity extends NamedLocationIdentity implements CanonicalizableLocation {
 89 
 90         HotSpotOptimizingLocationIdentity(String name) {
 91             super(name, true);
 92         }
 93 
 94         @Override
 95         public abstract ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool);
 96 
 97         protected ValueNode findReadHub(ValueNode object) {
 98             ValueNode base = object;
 99             if (base instanceof CompressionNode) {
100                 base = ((CompressionNode) base).getValue();
101             }
102             if (base instanceof AddressableMemoryAccess) {
103                 AddressableMemoryAccess access = (AddressableMemoryAccess) base;
104                 if (access.getLocationIdentity().equals(HUB_LOCATION) || access.getLocationIdentity().equals(COMPRESSED_HUB_LOCATION)) {
105                     AddressNode address = access.getAddress();
106                     if (address instanceof OffsetAddressNode) {
107                         OffsetAddressNode offset = (OffsetAddressNode) address;
108                         return offset.getBase();
109                     }
110                 }
111             } else if (base instanceof LoadHubNode) {
112                 LoadHubNode loadhub = (LoadHubNode) base;
113                 return loadhub.getValue();
114             }
115             return null;
116         }
117 
118         /**
119          * Fold reads that convert from Class -&gt; Hub -&gt; Class or vice versa.
120          *
121          * @param read
122          * @param object
123          * @param otherLocation
124          * @return an earlier read or the original {@code read}
125          */
126         protected static ValueNode foldIndirection(ValueNode read, ValueNode object, LocationIdentity otherLocation) {
127             if (object instanceof AddressableMemoryAccess) {
128                 AddressableMemoryAccess access = (AddressableMemoryAccess) object;
129                 if (access.getLocationIdentity().equals(otherLocation)) {
130                     AddressNode address = access.getAddress();
131                     if (address instanceof OffsetAddressNode) {
132                         OffsetAddressNode offset = (OffsetAddressNode) address;
133                         assert offset.getBase().stamp(NodeView.DEFAULT).isCompatible(read.stamp(NodeView.DEFAULT));
134                         return offset.getBase();
135                     }
136                 }
137             }
138             return read;
139         }
140     }
141 
142     @Fold
143     public static ResolvedJavaType methodHolderClass(@InjectedParameter IntrinsicContext context) {
144         return context.getOriginalMethod().getDeclaringClass();
145     }
146 
147     @Fold
148     static ResolvedJavaType getType(@Fold.InjectedParameter IntrinsicContext context, String typeName) {
149         try {
150             UnresolvedJavaType unresolved = UnresolvedJavaType.create(typeName);
151             return unresolved.resolve(methodHolderClass(context));
152         } catch (LinkageError e) {
153             throw new GraalError(e);
154         }
155     }
156 
157     @Fold
158     public static int getFieldOffset(ResolvedJavaType type, String fieldName) {
159         return getField(type, fieldName).getOffset();
160     }
161 
162     private static ResolvedJavaField getField(ResolvedJavaType type, String fieldName) {
163         for (ResolvedJavaField field : type.getInstanceFields(true)) {
164             if (field.getName().equals(fieldName)) {
165                 return field;
166             }
167         }
168         throw new GraalError(&quot;missing field &quot; + fieldName + &quot; in type &quot; + type);
169     }
170 
171     public static HotSpotJVMCIRuntime runtime() {
172         return HotSpotJVMCIRuntime.runtime();
173     }
174 
175     @Fold
176     public static int getHeapWordSize(@InjectedParameter GraalHotSpotVMConfig injectedVMConfig) {
177         return injectedVMConfig.heapWordSize;
178     }
179 
180     @Fold
181     public static int klassLayoutHelperNeutralValue(@InjectedParameter GraalHotSpotVMConfig config) {
182         return config.klassLayoutHelperNeutralValue;
183     }
184 
185     @Fold
186     public static boolean useTLAB(@InjectedParameter GraalHotSpotVMConfig config) {
187         return config.useTLAB;
188     }
189 
190     @Fold
191     public static boolean useG1GC(@InjectedParameter GraalHotSpotVMConfig config) {
192         return config.useG1GC;
193     }
194 
195     @Fold
196     public static boolean verifyOops(@InjectedParameter GraalHotSpotVMConfig config) {
197         return config.verifyOops;
198     }
199 
200     /**
201      * @see GraalHotSpotVMConfig#doingUnsafeAccessOffset
202      */
203     @Fold
204     public static int doingUnsafeAccessOffset(@InjectedParameter GraalHotSpotVMConfig config) {
205         return config.doingUnsafeAccessOffset;
206     }
207 
208     public static final LocationIdentity EXCEPTION_OOP_LOCATION = NamedLocationIdentity.mutable(&quot;ExceptionOop&quot;);
209 
210     /**
211      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
212      */
213     @Fold
214     public static int threadExceptionOopOffset(@InjectedParameter GraalHotSpotVMConfig config) {
215         return config.threadExceptionOopOffset;
216     }
217 
218     public static final LocationIdentity EXCEPTION_PC_LOCATION = NamedLocationIdentity.mutable(&quot;ExceptionPc&quot;);
219 
220     @Fold
221     public static int threadExceptionPcOffset(@InjectedParameter GraalHotSpotVMConfig config) {
222         return config.threadExceptionPcOffset;
223     }
224 
225     public static final LocationIdentity TLAB_TOP_LOCATION = NamedLocationIdentity.mutable(&quot;TlabTop&quot;);
226 
227     @Fold
228     public static int threadTlabTopOffset(@InjectedParameter GraalHotSpotVMConfig config) {
229         return config.threadTlabTopOffset();
230     }
231 
232     public static final LocationIdentity TLAB_END_LOCATION = NamedLocationIdentity.mutable(&quot;TlabEnd&quot;);
233 
234     @Fold
235     static int threadTlabEndOffset(@InjectedParameter GraalHotSpotVMConfig config) {
236         return config.threadTlabEndOffset();
237     }
238 
239     public static final LocationIdentity PENDING_EXCEPTION_LOCATION = NamedLocationIdentity.mutable(&quot;PendingException&quot;);
240 
241     /**
242      * @see GraalHotSpotVMConfig#pendingExceptionOffset
243      */
244     @Fold
245     static int threadPendingExceptionOffset(@InjectedParameter GraalHotSpotVMConfig config) {
246         return config.pendingExceptionOffset;
247     }
248 
249     /**
250      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
251      */
252     public static Object readExceptionOop(Word thread) {
253         return thread.readObject(threadExceptionOopOffset(INJECTED_VMCONFIG), EXCEPTION_OOP_LOCATION);
254     }
255 
256     public static Word readExceptionPc(Word thread) {
257         return thread.readWord(threadExceptionPcOffset(INJECTED_VMCONFIG), EXCEPTION_PC_LOCATION);
258     }
259 
260     /**
261      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
262      */
263     public static void writeExceptionOop(Word thread, Object value) {
264         thread.writeObject(threadExceptionOopOffset(INJECTED_VMCONFIG), value, EXCEPTION_OOP_LOCATION);
265     }
266 
267     public static void writeExceptionPc(Word thread, Word value) {
268         thread.writeWord(threadExceptionPcOffset(INJECTED_VMCONFIG), value, EXCEPTION_PC_LOCATION);
269     }
270 
271     public static Word readTlabTop(Word thread) {
272         return thread.readWord(threadTlabTopOffset(INJECTED_VMCONFIG), TLAB_TOP_LOCATION);
273     }
274 
275     public static Word readTlabEnd(Word thread) {
276         return thread.readWord(threadTlabEndOffset(INJECTED_VMCONFIG), TLAB_END_LOCATION);
277     }
278 
279     public static void writeTlabTop(Word thread, Word top) {
280         thread.writeWord(threadTlabTopOffset(INJECTED_VMCONFIG), top, TLAB_TOP_LOCATION);
281     }
282 
283     /**
284      * Clears the pending exception for the given thread.
285      *
286      * @return the pending exception, or null if there was none
287      */
288     @SuppressFBWarnings(value = &quot;NP_NULL_PARAM_DEREF_NONVIRTUAL&quot;, justification = &quot;foldable method parameters are injected&quot;)
289     public static Object clearPendingException(Word thread) {
290         Object result = thread.readObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), PENDING_EXCEPTION_LOCATION);
291         thread.writeObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), null, PENDING_EXCEPTION_LOCATION);
292         return result;
293     }
294 
295     /**
296      * Gets the pending exception for the given thread.
297      *
298      * @return the pending exception, or null if there was none
299      */
300     @SuppressFBWarnings(value = &quot;NP_NULL_PARAM_DEREF_NONVIRTUAL&quot;, justification = &quot;foldable method parameters are injected&quot;)
301     public static Object getPendingException(Word thread) {
302         return thread.readObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), PENDING_EXCEPTION_LOCATION);
303     }
304 
305     /*
306      * As far as Java code is concerned this can be considered immutable: it is set just after the
307      * JavaThread is created, before it is published. After that, it is never changed.
308      */
309     public static final LocationIdentity JAVA_THREAD_THREAD_OBJECT_LOCATION = NamedLocationIdentity.immutable(&quot;JavaThread::_threadObj&quot;);
310 
311     @Fold
312     public static int threadObjectOffset(@InjectedParameter GraalHotSpotVMConfig config) {
313         return config.threadObjectOffset;
314     }
315 
316     public static final LocationIdentity JAVA_THREAD_OSTHREAD_LOCATION = NamedLocationIdentity.mutable(&quot;JavaThread::_osthread&quot;);
317 
318     @Fold
319     public static int osThreadOffset(@InjectedParameter GraalHotSpotVMConfig config) {
320         assert config.osThreadOffset != Integer.MAX_VALUE;
321         return config.osThreadOffset;
322     }
323 
324     @Fold
325     public static int osThreadInterruptedOffset(@InjectedParameter GraalHotSpotVMConfig config) {
326         assert config.osThreadInterruptedOffset != Integer.MAX_VALUE;
327         return config.osThreadInterruptedOffset;
328     }
329 
330     @Fold
331     public static JavaKind getWordKind() {
332         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
333     }
334 
335     @Fold
336     public static int wordSize() {
337         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordSize;
338     }
339 
340     @Fold
341     public static int pageSize(@InjectedParameter GraalHotSpotVMConfig config) {
342         return config.vmPageSize;
343     }
344 
345     public static final LocationIdentity PROTOTYPE_MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;PrototypeMarkWord&quot;);
346 
347     @Fold
348     public static int prototypeMarkWordOffset(@InjectedParameter GraalHotSpotVMConfig config) {
349         return config.prototypeMarkWordOffset;
350     }
351 
352     public static final LocationIdentity KLASS_ACCESS_FLAGS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_access_flags&quot;);
353 
354     @Fold
355     public static int klassAccessFlagsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
356         return config.klassAccessFlagsOffset;
357     }
358 
359     @Fold
360     public static int jvmAccWrittenFlags(@InjectedParameter GraalHotSpotVMConfig config) {
361         return config.jvmAccWrittenFlags;
362     }
363 
<a name="1" id="anc1"></a><span class="line-added">364     @Fold</span>
<span class="line-added">365     public static int jvmAccIsHiddenClass(@InjectedParameter GraalHotSpotVMConfig config) {</span>
<span class="line-added">366         return config.jvmAccIsHiddenClass;</span>
<span class="line-added">367     }</span>
<span class="line-added">368 </span>
369     public static final LocationIdentity KLASS_LAYOUT_HELPER_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Klass::_layout_helper&quot;) {
370         @Override
371         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
372             ValueNode javaObject = findReadHub(object);
373             if (javaObject != null) {
374                 if (javaObject.stamp(NodeView.DEFAULT) instanceof ObjectStamp) {
375                     ObjectStamp stamp = (ObjectStamp) javaObject.stamp(NodeView.DEFAULT);
376                     HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) stamp.javaType(tool.getMetaAccess());
377                     if (type.isArray() &amp;&amp; !type.getComponentType().isPrimitive()) {
378                         int layout = type.layoutHelper();
379                         return ConstantNode.forInt(layout);
380                     }
381                 }
382             }
383             return read;
384         }
385     };
386 
387     @Fold
388     public static int allocatePrefetchStyle(@InjectedParameter GraalHotSpotVMConfig config) {
389         return config.allocatePrefetchStyle;
390     }
391 
392     @Fold
393     public static int allocatePrefetchLines(@InjectedParameter GraalHotSpotVMConfig config) {
394         return config.allocatePrefetchLines;
395     }
396 
397     @Fold
398     public static int allocatePrefetchDistance(@InjectedParameter GraalHotSpotVMConfig config) {
399         return config.allocatePrefetchDistance;
400     }
401 
402     @Fold
403     public static int allocateInstancePrefetchLines(@InjectedParameter GraalHotSpotVMConfig config) {
404         return config.allocateInstancePrefetchLines;
405     }
406 
407     @Fold
408     public static int allocatePrefetchStepSize(@InjectedParameter GraalHotSpotVMConfig config) {
409         return config.allocatePrefetchStepSize;
410     }
411 
412     @Fold
413     public static int invocationCounterIncrement(@InjectedParameter GraalHotSpotVMConfig config) {
414         return config.invocationCounterIncrement;
415     }
416 
417     @Fold
418     public static int invocationCounterOffset(@InjectedParameter GraalHotSpotVMConfig config) {
419         return config.invocationCounterOffset;
420     }
421 
422     @Fold
423     public static int backedgeCounterOffset(@InjectedParameter GraalHotSpotVMConfig config) {
424         return config.backedgeCounterOffset;
425     }
426 
427     @Fold
428     public static int invocationCounterShift(@InjectedParameter GraalHotSpotVMConfig config) {
429         return config.invocationCounterShift;
430     }
431 
432     @Fold
433     public static int stackBias(@InjectedParameter GraalHotSpotVMConfig config) {
434         return config.stackBias;
435     }
436 
437     @NodeIntrinsic(value = KlassLayoutHelperNode.class)
438     public static native int readLayoutHelper(KlassPointer object);
439 
440     /**
441      * Checks if class {@code klass} is an array.
442      *
443      * See: Klass::layout_helper_is_array
444      *
445      * @param klassNonNull the class to be checked
446      * @return true if klassNonNull is an array, false otherwise
447      */
448     public static boolean klassIsArray(KlassPointer klassNonNull) {
449         /*
450          * The less-than check only works if both values are ints. We use local variables to make
451          * sure these are still ints and haven&#39;t changed.
452          */
453         final int layoutHelper = readLayoutHelper(klassNonNull);
454         final int layoutHelperNeutralValue = klassLayoutHelperNeutralValue(INJECTED_VMCONFIG);
455         return (layoutHelper &lt; layoutHelperNeutralValue);
456     }
457 
458     public static final LocationIdentity ARRAY_KLASS_COMPONENT_MIRROR = NamedLocationIdentity.immutable(&quot;ArrayKlass::_component_mirror&quot;);
459 
460     @Fold
461     public static int arrayKlassComponentMirrorOffset(@InjectedParameter GraalHotSpotVMConfig config) {
462         return config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;);
463     }
464 
465     public static final LocationIdentity KLASS_SUPER_KLASS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_super&quot;);
466 
467     @Fold
468     public static int klassSuperKlassOffset(@InjectedParameter GraalHotSpotVMConfig config) {
469         return config.klassSuperKlassOffset;
470     }
471 
472     public static final LocationIdentity MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;MarkWord&quot;);
473 
474     @Fold
475     public static int markOffset(@InjectedParameter GraalHotSpotVMConfig config) {
476         return config.markOffset;
477     }
478 
479     public static final LocationIdentity HUB_WRITE_LOCATION = NamedLocationIdentity.mutable(&quot;Hub:write&quot;);
480 
481     public static final LocationIdentity HUB_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Hub&quot;) {
482         @Override
483         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
484             TypeReference constantType = StampTool.typeReferenceOrNull(object);
485             if (constantType != null &amp;&amp; constantType.isExact()) {
486                 return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), tool.getConstantReflection().asObjectHub(constantType.getType()), tool.getMetaAccess());
487             }
488             return read;
489         }
490     };
491 
492     public static final LocationIdentity COMPRESSED_HUB_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;CompressedHub&quot;) {
493         @Override
494         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
495             TypeReference constantType = StampTool.typeReferenceOrNull(object);
496             if (constantType != null &amp;&amp; constantType.isExact()) {
497                 return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), ((HotSpotMetaspaceConstant) tool.getConstantReflection().asObjectHub(constantType.getType())).compress(),
498                                 tool.getMetaAccess());
499             }
500             return read;
501         }
502     };
503 
504     @Fold
505     static int hubOffset(@InjectedParameter GraalHotSpotVMConfig config) {
506         return config.hubOffset;
507     }
508 
509     public static void initializeObjectHeader(Word memory, Word markWord, KlassPointer hub) {
510         memory.writeWord(markOffset(INJECTED_VMCONFIG), markWord, MARK_WORD_LOCATION);
511         StoreHubNode.write(memory, hub);
512     }
513 
514     @Fold
515     public static int unlockedMask(@InjectedParameter GraalHotSpotVMConfig config) {
516         return config.unlockedMask;
517     }
518 
519     @Fold
520     public static int monitorMask(@InjectedParameter GraalHotSpotVMConfig config) {
521         return config.monitorMask;
522     }
523 
524     @Fold
525     public static int objectMonitorOwnerOffset(@InjectedParameter GraalHotSpotVMConfig config) {
526         return config.objectMonitorOwner;
527     }
528 
529     @Fold
530     public static int objectMonitorRecursionsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
531         return config.objectMonitorRecursions;
532     }
533 
534     @Fold
535     public static int objectMonitorCxqOffset(@InjectedParameter GraalHotSpotVMConfig config) {
536         return config.objectMonitorCxq;
537     }
538 
539     @Fold
540     public static int objectMonitorEntryListOffset(@InjectedParameter GraalHotSpotVMConfig config) {
541         return config.objectMonitorEntryList;
542     }
543 
544     @Fold
545     public static int objectMonitorSuccOffset(@InjectedParameter GraalHotSpotVMConfig config) {
546         return config.objectMonitorSucc;
547     }
548 
549     /**
550      * Mask for a biasable, locked or unlocked mark word.
551      *
552      * &lt;pre&gt;
553      * +----------------------------------+-+-+
554      * |                                 1|1|1|
555      * +----------------------------------+-+-+
556      * &lt;/pre&gt;
557      *
558      */
559     @Fold
560     public static int biasedLockMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
561         return config.biasedLockMaskInPlace;
562     }
563 
564     @Fold
565     public static int epochMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
566         return config.epochMaskInPlace;
567     }
568 
569     /**
570      * Pattern for a biasable, unlocked mark word.
571      *
572      * &lt;pre&gt;
573      * +----------------------------------+-+-+
574      * |                                 1|0|1|
575      * +----------------------------------+-+-+
576      * &lt;/pre&gt;
577      *
578      */
579     @Fold
580     public static int biasedLockPattern(@InjectedParameter GraalHotSpotVMConfig config) {
581         return config.biasedLockPattern;
582     }
583 
584     @Fold
585     public static int ageMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
586         return config.ageMaskInPlace;
587     }
588 
589     @Fold
590     public static int metaspaceArrayLengthOffset(@InjectedParameter GraalHotSpotVMConfig config) {
591         return config.metaspaceArrayLengthOffset;
592     }
593 
594     @Fold
595     public static int metaspaceArrayBaseOffset(@InjectedParameter GraalHotSpotVMConfig config) {
596         return config.metaspaceArrayBaseOffset;
597     }
598 
599     @Fold
600     public static int arrayLengthOffset(@InjectedParameter GraalHotSpotVMConfig config) {
601         return config.arrayOopDescLengthOffset();
602     }
603 
604     public static Word arrayStart(int[] a) {
605         return WordFactory.unsigned(ComputeObjectAddressNode.get(a, ReplacementsUtil.getArrayBaseOffset(INJECTED_METAACCESS, JavaKind.Int)));
606     }
607 
608     /**
609      * Idiom for making {@link GraalHotSpotVMConfig} a constant.
610      */
611     @Fold
612     public static int objectAlignment(@InjectedParameter GraalHotSpotVMConfig config) {
613         return config.objectAlignment;
614     }
615 
616     @Fold
617     public static int instanceHeaderSize(@InjectedParameter GraalHotSpotVMConfig config) {
618         return config.useCompressedClassPointers ? (2 * wordSize()) - 4 : 2 * wordSize();
619     }
620 
621     @Fold
622     public static byte dirtyCardValue(@InjectedParameter GraalHotSpotVMConfig config) {
623         return config.dirtyCardValue;
624     }
625 
626     @Fold
627     public static byte g1YoungCardValue(@InjectedParameter GraalHotSpotVMConfig config) {
628         return config.g1YoungCardValue;
629     }
630 
631     @Fold
632     public static int cardTableShift(@InjectedParameter GraalHotSpotVMConfig config) {
633         return config.cardtableShift;
634     }
635 
636     @Fold
637     public static int g1CardQueueIndexOffset(@InjectedParameter GraalHotSpotVMConfig config) {
638         return config.g1CardQueueIndexOffset;
639     }
640 
641     @Fold
642     public static int g1CardQueueBufferOffset(@InjectedParameter GraalHotSpotVMConfig config) {
643         return config.g1CardQueueBufferOffset;
644     }
645 
646     @Fold
647     public static int g1SATBQueueMarkingOffset(@InjectedParameter GraalHotSpotVMConfig config) {
648         return config.g1SATBQueueMarkingOffset;
649     }
650 
651     @Fold
652     public static int g1SATBQueueIndexOffset(@InjectedParameter GraalHotSpotVMConfig config) {
653         return config.g1SATBQueueIndexOffset;
654     }
655 
656     @Fold
657     public static int g1SATBQueueBufferOffset(@InjectedParameter GraalHotSpotVMConfig config) {
658         return config.g1SATBQueueBufferOffset;
659     }
660 
661     public static final LocationIdentity KLASS_SUPER_CHECK_OFFSET_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_super_check_offset&quot;);
662 
663     @Fold
664     public static int superCheckOffsetOffset(@InjectedParameter GraalHotSpotVMConfig config) {
665         return config.superCheckOffsetOffset;
666     }
667 
668     public static final LocationIdentity SECONDARY_SUPER_CACHE_LOCATION = NamedLocationIdentity.mutable(&quot;SecondarySuperCache&quot;);
669 
670     @Fold
671     public static int secondarySuperCacheOffset(@InjectedParameter GraalHotSpotVMConfig config) {
672         return config.secondarySuperCacheOffset;
673     }
674 
675     public static final LocationIdentity SECONDARY_SUPERS_LOCATION = NamedLocationIdentity.immutable(&quot;SecondarySupers&quot;);
676 
677     @Fold
678     public static int secondarySupersOffset(@InjectedParameter GraalHotSpotVMConfig config) {
679         return config.secondarySupersOffset;
680     }
681 
682     public static final LocationIdentity DISPLACED_MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;DisplacedMarkWord&quot;);
683 
684     public static final LocationIdentity OBJECT_MONITOR_OWNER_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_owner&quot;);
685 
686     public static final LocationIdentity OBJECT_MONITOR_RECURSION_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_recursions&quot;);
687 
688     public static final LocationIdentity OBJECT_MONITOR_CXQ_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_cxq&quot;);
689 
690     public static final LocationIdentity OBJECT_MONITOR_ENTRY_LIST_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_EntryList&quot;);
691 
692     public static final LocationIdentity OBJECT_MONITOR_SUCC_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_succ&quot;);
693 
694     @Fold
695     public static int lockDisplacedMarkOffset(@InjectedParameter GraalHotSpotVMConfig config) {
696         return config.basicLockDisplacedHeaderOffset;
697     }
698 
699     @Fold
700     public static boolean useBiasedLocking(@InjectedParameter GraalHotSpotVMConfig config) {
701         return config.useBiasedLocking;
702     }
703 
704     @Fold
705     static int uninitializedIdentityHashCodeValue(@InjectedParameter GraalHotSpotVMConfig config) {
706         return config.uninitializedIdentityHashCodeValue;
707     }
708 
709     @Fold
710     static int identityHashCodeShift(@InjectedParameter GraalHotSpotVMConfig config) {
711         return config.identityHashCodeShift;
712     }
713 
714     /**
715      * Loads the hub of an object (without null checking it first).
716      */
717     public static KlassPointer loadHub(Object object) {
718         return loadHubIntrinsic(object);
719     }
720 
721     public static Object verifyOop(Object object) {
722         if (verifyOops(INJECTED_VMCONFIG)) {
723             verifyOopStub(VERIFY_OOP, object);
724         }
725         return object;
726     }
727 
728     @NodeIntrinsic(ForeignCallNode.class)
729     private static native Object verifyOopStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
730 
731     public static Word loadWordFromObject(Object object, int offset) {
732         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadWordFromObject&quot;);
733         return loadWordFromObjectIntrinsic(object, offset, LocationIdentity.any(), getWordKind());
734     }
735 
736     public static Word loadWordFromObject(Object object, int offset, LocationIdentity identity) {
737         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadWordFromObject&quot;);
738         return loadWordFromObjectIntrinsic(object, offset, identity, getWordKind());
739     }
740 
741     public static KlassPointer loadKlassFromObject(Object object, int offset, LocationIdentity identity) {
742         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadKlassFromObject&quot;);
743         return loadKlassFromObjectIntrinsic(object, offset, identity, getWordKind());
744     }
745 
746     /**
747      * Reads the value of a given register.
748      *
749      * @param register a register which must not be available to the register allocator
750      * @return the value of {@code register} as a word
751      */
752     public static Word registerAsWord(@ConstantNodeParameter Register register) {
753         return registerAsWord(register, true, false);
754     }
755 
756     @NodeIntrinsic(value = ReadRegisterNode.class)
757     public static native Word registerAsWord(@ConstantNodeParameter Register register, @ConstantNodeParameter boolean directUse, @ConstantNodeParameter boolean incoming);
758 
759     @NodeIntrinsic(value = WriteRegisterNode.class)
760     public static native void writeRegisterAsWord(@ConstantNodeParameter Register register, Word value);
761 
762     @NodeIntrinsic(value = RawLoadNode.class)
763     private static native Word loadWordFromObjectIntrinsic(Object object, long offset, @ConstantNodeParameter LocationIdentity locationIdentity, @ConstantNodeParameter JavaKind wordKind);
764 
765     @NodeIntrinsic(value = RawLoadNode.class)
766     private static native KlassPointer loadKlassFromObjectIntrinsic(Object object, long offset, @ConstantNodeParameter LocationIdentity locationIdentity, @ConstantNodeParameter JavaKind wordKind);
767 
768     @NodeIntrinsic(value = LoadHubNode.class)
769     public static native KlassPointer loadHubIntrinsic(Object object);
770 
771     @NodeIntrinsic(value = LoadHubOrNullNode.class)
772     public static native KlassPointer loadHubOrNullIntrinsic(Object object);
773 
774     static final LocationIdentity CLASS_INIT_STATE_LOCATION = NamedLocationIdentity.mutable(&quot;ClassInitState&quot;);
775 
776     static final LocationIdentity CLASS_INIT_THREAD_LOCATION = NamedLocationIdentity.mutable(&quot;ClassInitThread&quot;);
777 
778     @Fold
779     static int instanceKlassInitStateOffset(@InjectedParameter GraalHotSpotVMConfig config) {
780         return config.instanceKlassInitStateOffset;
781     }
782 
783     @Fold
784     static int instanceKlassInitThreadOffset(@InjectedParameter GraalHotSpotVMConfig config) {
785         assert config.instanceKlassInitThreadOffset != -1;
786         return config.instanceKlassInitThreadOffset;
787     }
788 
789     @Fold
790     public static int instanceKlassStateFullyInitialized(@InjectedParameter GraalHotSpotVMConfig config) {
791         return config.instanceKlassStateFullyInitialized;
792     }
793 
794     @Fold
795     public static int instanceKlassStateBeingInitialized(@InjectedParameter GraalHotSpotVMConfig config) {
796         assert config.instanceKlassStateBeingInitialized != -1;
797         return config.instanceKlassStateBeingInitialized;
798     }
799 
800     /**
801      *
802      * @param hub the hub of an InstanceKlass
803      * @return true is the InstanceKlass represented by hub is fully initialized
804      */
805     public static boolean isInstanceKlassFullyInitialized(KlassPointer hub) {
806         return readInstanceKlassInitState(hub) == instanceKlassStateFullyInitialized(INJECTED_VMCONFIG);
807     }
808 
809     static byte readInstanceKlassInitState(KlassPointer hub) {
810         return hub.readByte(instanceKlassInitStateOffset(INJECTED_VMCONFIG), CLASS_INIT_STATE_LOCATION);
811     }
812 
813     static Word readInstanceKlassInitThread(KlassPointer hub) {
814         return hub.readWord(instanceKlassInitThreadOffset(INJECTED_VMCONFIG), CLASS_INIT_THREAD_LOCATION);
815     }
816 
817     public static final LocationIdentity KLASS_MODIFIER_FLAGS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_modifier_flags&quot;);
818 
819     @Fold
820     public static int klassModifierFlagsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
821         return config.klassModifierFlagsOffset;
822     }
823 
824     public static final LocationIdentity CLASS_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Class._klass&quot;) {
825         @Override
826         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
827             return foldIndirection(read, object, CLASS_MIRROR_LOCATION);
828         }
829     };
830 
831     public static final LocationIdentity CLASS_ARRAY_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Class._array_klass&quot;) {
832         @Override
833         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
834             return foldIndirection(read, object, ARRAY_KLASS_COMPONENT_MIRROR);
835         }
836     };
837 
838     @Fold
839     public static int arrayKlassOffset(@InjectedParameter GraalHotSpotVMConfig config) {
840         return config.arrayKlassOffset;
841     }
842 
843     public static final LocationIdentity CLASS_MIRROR_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_java_mirror&quot;);
844 
845     public static final LocationIdentity CLASS_MIRROR_HANDLE_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_java_mirror handle&quot;);
846 
847     @Fold
848     public static int layoutHelperHeaderSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
849         return config.layoutHelperHeaderSizeShift;
850     }
851 
852     @Fold
853     public static int layoutHelperHeaderSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
854         return config.layoutHelperHeaderSizeMask;
855     }
856 
857     @Fold
858     public static int layoutHelperLog2ElementSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
859         return config.layoutHelperLog2ElementSizeShift;
860     }
861 
862     @Fold
863     public static int layoutHelperLog2ElementSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
864         return config.layoutHelperLog2ElementSizeMask;
865     }
866 
867     @NodeIntrinsic(ForeignCallNode.class)
868     public static native int identityHashCode(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
869 
870     @Fold
871     public static long gcTotalCollectionsAddress(@InjectedParameter GraalHotSpotVMConfig config) {
872         return config.gcTotalCollectionsAddress();
873     }
874 
875     @Fold
876     public static long referentOffset(@InjectedParameter MetaAccessProvider metaAccessProvider) {
877         return referentField(metaAccessProvider).getOffset();
878     }
879 
880     @Fold
881     public static ResolvedJavaField referentField(@InjectedParameter MetaAccessProvider metaAccessProvider) {
882         return getField(metaAccessProvider.lookupJavaType(Reference.class), &quot;referent&quot;);
883     }
884 
885     @Fold
886     public static ResolvedJavaType referenceType(@InjectedParameter MetaAccessProvider metaAccessProvider) {
887         return metaAccessProvider.lookupJavaType(Reference.class);
888     }
889 
890     public static final LocationIdentity OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;ObjArrayKlass::_element_klass&quot;) {
891         @Override
892         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
893             ValueNode javaObject = findReadHub(object);
894             if (javaObject != null) {
895                 ResolvedJavaType type = StampTool.typeOrNull(javaObject);
896                 if (type != null &amp;&amp; type.isArray()) {
897                     ResolvedJavaType element = type.getComponentType();
898                     if (element != null &amp;&amp; !element.isPrimitive() &amp;&amp; !element.getElementalType().isInterface()) {
899                         Assumptions assumptions = object.graph().getAssumptions();
900                         AssumptionResult&lt;ResolvedJavaType&gt; leafType = element.findLeafConcreteSubtype();
901                         if (leafType != null &amp;&amp; leafType.canRecordTo(assumptions)) {
902                             leafType.recordTo(assumptions);
903                             return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), tool.getConstantReflection().asObjectHub(leafType.getResult()), tool.getMetaAccess());
904                         }
905                     }
906                 }
907             }
908             return read;
909         }
910     };
911 
912     @Fold
913     public static int arrayClassElementOffset(@InjectedParameter GraalHotSpotVMConfig config) {
914         return config.arrayClassElementOffset;
915     }
916 
917     public static final LocationIdentity PRIMARY_SUPERS_LOCATION = NamedLocationIdentity.immutable(&quot;PrimarySupers&quot;);
918 
919     public static final LocationIdentity METASPACE_ARRAY_LENGTH_LOCATION = NamedLocationIdentity.immutable(&quot;MetaspaceArrayLength&quot;);
920 
921     public static final LocationIdentity SECONDARY_SUPERS_ELEMENT_LOCATION = NamedLocationIdentity.immutable(&quot;SecondarySupersElement&quot;);
922 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/HotSpotReplacementsUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.replacements;
 26 
 27 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_METAACCESS;
 28 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_VMCONFIG;
 29 import static org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProviderImpl.VERIFY_OOP;
 30 
 31 import java.lang.ref.Reference;
 32 
 33 import org.graalvm.compiler.api.replacements.Fold;
 34 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
 35 import org.graalvm.compiler.core.common.SuppressFBWarnings;
 36 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 37 import org.graalvm.compiler.core.common.type.ObjectStamp;
 38 import org.graalvm.compiler.core.common.type.TypeReference;
 39 import org.graalvm.compiler.debug.GraalError;
 40 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
 41 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 42 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 43 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 44 import org.graalvm.compiler.hotspot.word.KlassPointer;
 45 import org.graalvm.compiler.nodes.CanonicalizableLocation;
 46 import org.graalvm.compiler.nodes.CompressionNode;
 47 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 48 import org.graalvm.compiler.nodes.ConstantNode;
 49 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 50 import org.graalvm.compiler.nodes.NodeView;
 51 import org.graalvm.compiler.nodes.ValueNode;
 52 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 53 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 54 import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;
 55 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 56 import org.graalvm.compiler.nodes.extended.StoreHubNode;
 57 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 58 import org.graalvm.compiler.nodes.memory.AddressableMemoryAccess;
 59 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 60 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 61 import org.graalvm.compiler.nodes.type.StampTool;
 62 import org.graalvm.compiler.replacements.ReplacementsUtil;
 63 import org.graalvm.compiler.replacements.nodes.ReadRegisterNode;
 64 import org.graalvm.compiler.replacements.nodes.WriteRegisterNode;
 65 import org.graalvm.compiler.word.Word;
 66 import jdk.internal.vm.compiler.word.LocationIdentity;
 67 import jdk.internal.vm.compiler.word.WordFactory;
 68 
 69 import jdk.vm.ci.code.Register;
 70 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 71 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 72 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 73 import jdk.vm.ci.meta.Assumptions;
 74 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 75 import jdk.vm.ci.meta.JavaKind;
 76 import jdk.vm.ci.meta.MetaAccessProvider;
 77 import jdk.vm.ci.meta.ResolvedJavaField;
 78 import jdk.vm.ci.meta.ResolvedJavaType;
 79 import jdk.vm.ci.meta.UnresolvedJavaType;
 80 
 81 //JaCoCo Exclude
 82 
 83 /**
 84  * A collection of methods used in HotSpot snippets, substitutions and stubs.
 85  */
 86 public class HotSpotReplacementsUtil {
 87 
 88     abstract static class HotSpotOptimizingLocationIdentity extends NamedLocationIdentity implements CanonicalizableLocation {
 89 
 90         HotSpotOptimizingLocationIdentity(String name) {
 91             super(name, true);
 92         }
 93 
 94         @Override
 95         public abstract ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool);
 96 
 97         protected ValueNode findReadHub(ValueNode object) {
 98             ValueNode base = object;
 99             if (base instanceof CompressionNode) {
100                 base = ((CompressionNode) base).getValue();
101             }
102             if (base instanceof AddressableMemoryAccess) {
103                 AddressableMemoryAccess access = (AddressableMemoryAccess) base;
104                 if (access.getLocationIdentity().equals(HUB_LOCATION) || access.getLocationIdentity().equals(COMPRESSED_HUB_LOCATION)) {
105                     AddressNode address = access.getAddress();
106                     if (address instanceof OffsetAddressNode) {
107                         OffsetAddressNode offset = (OffsetAddressNode) address;
108                         return offset.getBase();
109                     }
110                 }
111             } else if (base instanceof LoadHubNode) {
112                 LoadHubNode loadhub = (LoadHubNode) base;
113                 return loadhub.getValue();
114             }
115             return null;
116         }
117 
118         /**
119          * Fold reads that convert from Class -&gt; Hub -&gt; Class or vice versa.
120          *
121          * @param read
122          * @param object
123          * @param otherLocation
124          * @return an earlier read or the original {@code read}
125          */
126         protected static ValueNode foldIndirection(ValueNode read, ValueNode object, LocationIdentity otherLocation) {
127             if (object instanceof AddressableMemoryAccess) {
128                 AddressableMemoryAccess access = (AddressableMemoryAccess) object;
129                 if (access.getLocationIdentity().equals(otherLocation)) {
130                     AddressNode address = access.getAddress();
131                     if (address instanceof OffsetAddressNode) {
132                         OffsetAddressNode offset = (OffsetAddressNode) address;
133                         assert offset.getBase().stamp(NodeView.DEFAULT).isCompatible(read.stamp(NodeView.DEFAULT));
134                         return offset.getBase();
135                     }
136                 }
137             }
138             return read;
139         }
140     }
141 
142     @Fold
143     public static ResolvedJavaType methodHolderClass(@InjectedParameter IntrinsicContext context) {
144         return context.getOriginalMethod().getDeclaringClass();
145     }
146 
147     @Fold
148     static ResolvedJavaType getType(@Fold.InjectedParameter IntrinsicContext context, String typeName) {
149         try {
150             UnresolvedJavaType unresolved = UnresolvedJavaType.create(typeName);
151             return unresolved.resolve(methodHolderClass(context));
152         } catch (LinkageError e) {
153             throw new GraalError(e);
154         }
155     }
156 
157     @Fold
158     public static int getFieldOffset(ResolvedJavaType type, String fieldName) {
159         return getField(type, fieldName).getOffset();
160     }
161 
162     private static ResolvedJavaField getField(ResolvedJavaType type, String fieldName) {
163         for (ResolvedJavaField field : type.getInstanceFields(true)) {
164             if (field.getName().equals(fieldName)) {
165                 return field;
166             }
167         }
168         throw new GraalError(&quot;missing field &quot; + fieldName + &quot; in type &quot; + type);
169     }
170 
171     public static HotSpotJVMCIRuntime runtime() {
172         return HotSpotJVMCIRuntime.runtime();
173     }
174 
175     @Fold
176     public static int getHeapWordSize(@InjectedParameter GraalHotSpotVMConfig injectedVMConfig) {
177         return injectedVMConfig.heapWordSize;
178     }
179 
180     @Fold
181     public static int klassLayoutHelperNeutralValue(@InjectedParameter GraalHotSpotVMConfig config) {
182         return config.klassLayoutHelperNeutralValue;
183     }
184 
185     @Fold
186     public static boolean useTLAB(@InjectedParameter GraalHotSpotVMConfig config) {
187         return config.useTLAB;
188     }
189 
190     @Fold
191     public static boolean useG1GC(@InjectedParameter GraalHotSpotVMConfig config) {
192         return config.useG1GC;
193     }
194 
195     @Fold
196     public static boolean verifyOops(@InjectedParameter GraalHotSpotVMConfig config) {
197         return config.verifyOops;
198     }
199 
200     /**
201      * @see GraalHotSpotVMConfig#doingUnsafeAccessOffset
202      */
203     @Fold
204     public static int doingUnsafeAccessOffset(@InjectedParameter GraalHotSpotVMConfig config) {
205         return config.doingUnsafeAccessOffset;
206     }
207 
208     public static final LocationIdentity EXCEPTION_OOP_LOCATION = NamedLocationIdentity.mutable(&quot;ExceptionOop&quot;);
209 
210     /**
211      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
212      */
213     @Fold
214     public static int threadExceptionOopOffset(@InjectedParameter GraalHotSpotVMConfig config) {
215         return config.threadExceptionOopOffset;
216     }
217 
218     public static final LocationIdentity EXCEPTION_PC_LOCATION = NamedLocationIdentity.mutable(&quot;ExceptionPc&quot;);
219 
220     @Fold
221     public static int threadExceptionPcOffset(@InjectedParameter GraalHotSpotVMConfig config) {
222         return config.threadExceptionPcOffset;
223     }
224 
225     public static final LocationIdentity TLAB_TOP_LOCATION = NamedLocationIdentity.mutable(&quot;TlabTop&quot;);
226 
227     @Fold
228     public static int threadTlabTopOffset(@InjectedParameter GraalHotSpotVMConfig config) {
229         return config.threadTlabTopOffset();
230     }
231 
232     public static final LocationIdentity TLAB_END_LOCATION = NamedLocationIdentity.mutable(&quot;TlabEnd&quot;);
233 
234     @Fold
235     static int threadTlabEndOffset(@InjectedParameter GraalHotSpotVMConfig config) {
236         return config.threadTlabEndOffset();
237     }
238 
239     public static final LocationIdentity PENDING_EXCEPTION_LOCATION = NamedLocationIdentity.mutable(&quot;PendingException&quot;);
240 
241     /**
242      * @see GraalHotSpotVMConfig#pendingExceptionOffset
243      */
244     @Fold
245     static int threadPendingExceptionOffset(@InjectedParameter GraalHotSpotVMConfig config) {
246         return config.pendingExceptionOffset;
247     }
248 
249     /**
250      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
251      */
252     public static Object readExceptionOop(Word thread) {
253         return thread.readObject(threadExceptionOopOffset(INJECTED_VMCONFIG), EXCEPTION_OOP_LOCATION);
254     }
255 
256     public static Word readExceptionPc(Word thread) {
257         return thread.readWord(threadExceptionPcOffset(INJECTED_VMCONFIG), EXCEPTION_PC_LOCATION);
258     }
259 
260     /**
261      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
262      */
263     public static void writeExceptionOop(Word thread, Object value) {
264         thread.writeObject(threadExceptionOopOffset(INJECTED_VMCONFIG), value, EXCEPTION_OOP_LOCATION);
265     }
266 
267     public static void writeExceptionPc(Word thread, Word value) {
268         thread.writeWord(threadExceptionPcOffset(INJECTED_VMCONFIG), value, EXCEPTION_PC_LOCATION);
269     }
270 
271     public static Word readTlabTop(Word thread) {
272         return thread.readWord(threadTlabTopOffset(INJECTED_VMCONFIG), TLAB_TOP_LOCATION);
273     }
274 
275     public static Word readTlabEnd(Word thread) {
276         return thread.readWord(threadTlabEndOffset(INJECTED_VMCONFIG), TLAB_END_LOCATION);
277     }
278 
279     public static void writeTlabTop(Word thread, Word top) {
280         thread.writeWord(threadTlabTopOffset(INJECTED_VMCONFIG), top, TLAB_TOP_LOCATION);
281     }
282 
283     /**
284      * Clears the pending exception for the given thread.
285      *
286      * @return the pending exception, or null if there was none
287      */
288     @SuppressFBWarnings(value = &quot;NP_NULL_PARAM_DEREF_NONVIRTUAL&quot;, justification = &quot;foldable method parameters are injected&quot;)
289     public static Object clearPendingException(Word thread) {
290         Object result = thread.readObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), PENDING_EXCEPTION_LOCATION);
291         thread.writeObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), null, PENDING_EXCEPTION_LOCATION);
292         return result;
293     }
294 
295     /**
296      * Gets the pending exception for the given thread.
297      *
298      * @return the pending exception, or null if there was none
299      */
300     @SuppressFBWarnings(value = &quot;NP_NULL_PARAM_DEREF_NONVIRTUAL&quot;, justification = &quot;foldable method parameters are injected&quot;)
301     public static Object getPendingException(Word thread) {
302         return thread.readObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), PENDING_EXCEPTION_LOCATION);
303     }
304 
305     /*
306      * As far as Java code is concerned this can be considered immutable: it is set just after the
307      * JavaThread is created, before it is published. After that, it is never changed.
308      */
309     public static final LocationIdentity JAVA_THREAD_THREAD_OBJECT_LOCATION = NamedLocationIdentity.immutable(&quot;JavaThread::_threadObj&quot;);
310 
311     @Fold
312     public static int threadObjectOffset(@InjectedParameter GraalHotSpotVMConfig config) {
313         return config.threadObjectOffset;
314     }
315 
316     public static final LocationIdentity JAVA_THREAD_OSTHREAD_LOCATION = NamedLocationIdentity.mutable(&quot;JavaThread::_osthread&quot;);
317 
318     @Fold
319     public static int osThreadOffset(@InjectedParameter GraalHotSpotVMConfig config) {
320         assert config.osThreadOffset != Integer.MAX_VALUE;
321         return config.osThreadOffset;
322     }
323 
324     @Fold
325     public static int osThreadInterruptedOffset(@InjectedParameter GraalHotSpotVMConfig config) {
326         assert config.osThreadInterruptedOffset != Integer.MAX_VALUE;
327         return config.osThreadInterruptedOffset;
328     }
329 
330     @Fold
331     public static JavaKind getWordKind() {
332         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
333     }
334 
335     @Fold
336     public static int wordSize() {
337         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordSize;
338     }
339 
340     @Fold
341     public static int pageSize(@InjectedParameter GraalHotSpotVMConfig config) {
342         return config.vmPageSize;
343     }
344 
345     public static final LocationIdentity PROTOTYPE_MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;PrototypeMarkWord&quot;);
346 
347     @Fold
348     public static int prototypeMarkWordOffset(@InjectedParameter GraalHotSpotVMConfig config) {
349         return config.prototypeMarkWordOffset;
350     }
351 
352     public static final LocationIdentity KLASS_ACCESS_FLAGS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_access_flags&quot;);
353 
354     @Fold
355     public static int klassAccessFlagsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
356         return config.klassAccessFlagsOffset;
357     }
358 
359     @Fold
360     public static int jvmAccWrittenFlags(@InjectedParameter GraalHotSpotVMConfig config) {
361         return config.jvmAccWrittenFlags;
362     }
363 
364     public static final LocationIdentity KLASS_LAYOUT_HELPER_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Klass::_layout_helper&quot;) {
365         @Override
366         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
367             ValueNode javaObject = findReadHub(object);
368             if (javaObject != null) {
369                 if (javaObject.stamp(NodeView.DEFAULT) instanceof ObjectStamp) {
370                     ObjectStamp stamp = (ObjectStamp) javaObject.stamp(NodeView.DEFAULT);
371                     HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) stamp.javaType(tool.getMetaAccess());
372                     if (type.isArray() &amp;&amp; !type.getComponentType().isPrimitive()) {
373                         int layout = type.layoutHelper();
374                         return ConstantNode.forInt(layout);
375                     }
376                 }
377             }
378             return read;
379         }
380     };
381 
382     @Fold
383     public static int allocatePrefetchStyle(@InjectedParameter GraalHotSpotVMConfig config) {
384         return config.allocatePrefetchStyle;
385     }
386 
387     @Fold
388     public static int allocatePrefetchLines(@InjectedParameter GraalHotSpotVMConfig config) {
389         return config.allocatePrefetchLines;
390     }
391 
392     @Fold
393     public static int allocatePrefetchDistance(@InjectedParameter GraalHotSpotVMConfig config) {
394         return config.allocatePrefetchDistance;
395     }
396 
397     @Fold
398     public static int allocateInstancePrefetchLines(@InjectedParameter GraalHotSpotVMConfig config) {
399         return config.allocateInstancePrefetchLines;
400     }
401 
402     @Fold
403     public static int allocatePrefetchStepSize(@InjectedParameter GraalHotSpotVMConfig config) {
404         return config.allocatePrefetchStepSize;
405     }
406 
407     @Fold
408     public static int invocationCounterIncrement(@InjectedParameter GraalHotSpotVMConfig config) {
409         return config.invocationCounterIncrement;
410     }
411 
412     @Fold
413     public static int invocationCounterOffset(@InjectedParameter GraalHotSpotVMConfig config) {
414         return config.invocationCounterOffset;
415     }
416 
417     @Fold
418     public static int backedgeCounterOffset(@InjectedParameter GraalHotSpotVMConfig config) {
419         return config.backedgeCounterOffset;
420     }
421 
422     @Fold
423     public static int invocationCounterShift(@InjectedParameter GraalHotSpotVMConfig config) {
424         return config.invocationCounterShift;
425     }
426 
427     @Fold
428     public static int stackBias(@InjectedParameter GraalHotSpotVMConfig config) {
429         return config.stackBias;
430     }
431 
432     @NodeIntrinsic(value = KlassLayoutHelperNode.class)
433     public static native int readLayoutHelper(KlassPointer object);
434 
435     /**
436      * Checks if class {@code klass} is an array.
437      *
438      * See: Klass::layout_helper_is_array
439      *
440      * @param klassNonNull the class to be checked
441      * @return true if klassNonNull is an array, false otherwise
442      */
443     public static boolean klassIsArray(KlassPointer klassNonNull) {
444         /*
445          * The less-than check only works if both values are ints. We use local variables to make
446          * sure these are still ints and haven&#39;t changed.
447          */
448         final int layoutHelper = readLayoutHelper(klassNonNull);
449         final int layoutHelperNeutralValue = klassLayoutHelperNeutralValue(INJECTED_VMCONFIG);
450         return (layoutHelper &lt; layoutHelperNeutralValue);
451     }
452 
453     public static final LocationIdentity ARRAY_KLASS_COMPONENT_MIRROR = NamedLocationIdentity.immutable(&quot;ArrayKlass::_component_mirror&quot;);
454 
455     @Fold
456     public static int arrayKlassComponentMirrorOffset(@InjectedParameter GraalHotSpotVMConfig config) {
457         return config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;);
458     }
459 
460     public static final LocationIdentity KLASS_SUPER_KLASS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_super&quot;);
461 
462     @Fold
463     public static int klassSuperKlassOffset(@InjectedParameter GraalHotSpotVMConfig config) {
464         return config.klassSuperKlassOffset;
465     }
466 
467     public static final LocationIdentity MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;MarkWord&quot;);
468 
469     @Fold
470     public static int markOffset(@InjectedParameter GraalHotSpotVMConfig config) {
471         return config.markOffset;
472     }
473 
474     public static final LocationIdentity HUB_WRITE_LOCATION = NamedLocationIdentity.mutable(&quot;Hub:write&quot;);
475 
476     public static final LocationIdentity HUB_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Hub&quot;) {
477         @Override
478         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
479             TypeReference constantType = StampTool.typeReferenceOrNull(object);
480             if (constantType != null &amp;&amp; constantType.isExact()) {
481                 return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), tool.getConstantReflection().asObjectHub(constantType.getType()), tool.getMetaAccess());
482             }
483             return read;
484         }
485     };
486 
487     public static final LocationIdentity COMPRESSED_HUB_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;CompressedHub&quot;) {
488         @Override
489         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
490             TypeReference constantType = StampTool.typeReferenceOrNull(object);
491             if (constantType != null &amp;&amp; constantType.isExact()) {
492                 return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), ((HotSpotMetaspaceConstant) tool.getConstantReflection().asObjectHub(constantType.getType())).compress(),
493                                 tool.getMetaAccess());
494             }
495             return read;
496         }
497     };
498 
499     @Fold
500     static int hubOffset(@InjectedParameter GraalHotSpotVMConfig config) {
501         return config.hubOffset;
502     }
503 
504     public static void initializeObjectHeader(Word memory, Word markWord, KlassPointer hub) {
505         memory.writeWord(markOffset(INJECTED_VMCONFIG), markWord, MARK_WORD_LOCATION);
506         StoreHubNode.write(memory, hub);
507     }
508 
509     @Fold
510     public static int unlockedMask(@InjectedParameter GraalHotSpotVMConfig config) {
511         return config.unlockedMask;
512     }
513 
514     @Fold
515     public static int monitorMask(@InjectedParameter GraalHotSpotVMConfig config) {
516         return config.monitorMask;
517     }
518 
519     @Fold
520     public static int objectMonitorOwnerOffset(@InjectedParameter GraalHotSpotVMConfig config) {
521         return config.objectMonitorOwner;
522     }
523 
524     @Fold
525     public static int objectMonitorRecursionsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
526         return config.objectMonitorRecursions;
527     }
528 
529     @Fold
530     public static int objectMonitorCxqOffset(@InjectedParameter GraalHotSpotVMConfig config) {
531         return config.objectMonitorCxq;
532     }
533 
534     @Fold
535     public static int objectMonitorEntryListOffset(@InjectedParameter GraalHotSpotVMConfig config) {
536         return config.objectMonitorEntryList;
537     }
538 
539     @Fold
540     public static int objectMonitorSuccOffset(@InjectedParameter GraalHotSpotVMConfig config) {
541         return config.objectMonitorSucc;
542     }
543 
544     /**
545      * Mask for a biasable, locked or unlocked mark word.
546      *
547      * &lt;pre&gt;
548      * +----------------------------------+-+-+
549      * |                                 1|1|1|
550      * +----------------------------------+-+-+
551      * &lt;/pre&gt;
552      *
553      */
554     @Fold
555     public static int biasedLockMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
556         return config.biasedLockMaskInPlace;
557     }
558 
559     @Fold
560     public static int epochMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
561         return config.epochMaskInPlace;
562     }
563 
564     /**
565      * Pattern for a biasable, unlocked mark word.
566      *
567      * &lt;pre&gt;
568      * +----------------------------------+-+-+
569      * |                                 1|0|1|
570      * +----------------------------------+-+-+
571      * &lt;/pre&gt;
572      *
573      */
574     @Fold
575     public static int biasedLockPattern(@InjectedParameter GraalHotSpotVMConfig config) {
576         return config.biasedLockPattern;
577     }
578 
579     @Fold
580     public static int ageMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
581         return config.ageMaskInPlace;
582     }
583 
584     @Fold
585     public static int metaspaceArrayLengthOffset(@InjectedParameter GraalHotSpotVMConfig config) {
586         return config.metaspaceArrayLengthOffset;
587     }
588 
589     @Fold
590     public static int metaspaceArrayBaseOffset(@InjectedParameter GraalHotSpotVMConfig config) {
591         return config.metaspaceArrayBaseOffset;
592     }
593 
594     @Fold
595     public static int arrayLengthOffset(@InjectedParameter GraalHotSpotVMConfig config) {
596         return config.arrayOopDescLengthOffset();
597     }
598 
599     public static Word arrayStart(int[] a) {
600         return WordFactory.unsigned(ComputeObjectAddressNode.get(a, ReplacementsUtil.getArrayBaseOffset(INJECTED_METAACCESS, JavaKind.Int)));
601     }
602 
603     /**
604      * Idiom for making {@link GraalHotSpotVMConfig} a constant.
605      */
606     @Fold
607     public static int objectAlignment(@InjectedParameter GraalHotSpotVMConfig config) {
608         return config.objectAlignment;
609     }
610 
611     @Fold
612     public static int instanceHeaderSize(@InjectedParameter GraalHotSpotVMConfig config) {
613         return config.useCompressedClassPointers ? (2 * wordSize()) - 4 : 2 * wordSize();
614     }
615 
616     @Fold
617     public static byte dirtyCardValue(@InjectedParameter GraalHotSpotVMConfig config) {
618         return config.dirtyCardValue;
619     }
620 
621     @Fold
622     public static byte g1YoungCardValue(@InjectedParameter GraalHotSpotVMConfig config) {
623         return config.g1YoungCardValue;
624     }
625 
626     @Fold
627     public static int cardTableShift(@InjectedParameter GraalHotSpotVMConfig config) {
628         return config.cardtableShift;
629     }
630 
631     @Fold
632     public static int g1CardQueueIndexOffset(@InjectedParameter GraalHotSpotVMConfig config) {
633         return config.g1CardQueueIndexOffset;
634     }
635 
636     @Fold
637     public static int g1CardQueueBufferOffset(@InjectedParameter GraalHotSpotVMConfig config) {
638         return config.g1CardQueueBufferOffset;
639     }
640 
641     @Fold
642     public static int g1SATBQueueMarkingOffset(@InjectedParameter GraalHotSpotVMConfig config) {
643         return config.g1SATBQueueMarkingOffset;
644     }
645 
646     @Fold
647     public static int g1SATBQueueIndexOffset(@InjectedParameter GraalHotSpotVMConfig config) {
648         return config.g1SATBQueueIndexOffset;
649     }
650 
651     @Fold
652     public static int g1SATBQueueBufferOffset(@InjectedParameter GraalHotSpotVMConfig config) {
653         return config.g1SATBQueueBufferOffset;
654     }
655 
656     public static final LocationIdentity KLASS_SUPER_CHECK_OFFSET_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_super_check_offset&quot;);
657 
658     @Fold
659     public static int superCheckOffsetOffset(@InjectedParameter GraalHotSpotVMConfig config) {
660         return config.superCheckOffsetOffset;
661     }
662 
663     public static final LocationIdentity SECONDARY_SUPER_CACHE_LOCATION = NamedLocationIdentity.mutable(&quot;SecondarySuperCache&quot;);
664 
665     @Fold
666     public static int secondarySuperCacheOffset(@InjectedParameter GraalHotSpotVMConfig config) {
667         return config.secondarySuperCacheOffset;
668     }
669 
670     public static final LocationIdentity SECONDARY_SUPERS_LOCATION = NamedLocationIdentity.immutable(&quot;SecondarySupers&quot;);
671 
672     @Fold
673     public static int secondarySupersOffset(@InjectedParameter GraalHotSpotVMConfig config) {
674         return config.secondarySupersOffset;
675     }
676 
677     public static final LocationIdentity DISPLACED_MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;DisplacedMarkWord&quot;);
678 
679     public static final LocationIdentity OBJECT_MONITOR_OWNER_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_owner&quot;);
680 
681     public static final LocationIdentity OBJECT_MONITOR_RECURSION_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_recursions&quot;);
682 
683     public static final LocationIdentity OBJECT_MONITOR_CXQ_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_cxq&quot;);
684 
685     public static final LocationIdentity OBJECT_MONITOR_ENTRY_LIST_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_EntryList&quot;);
686 
687     public static final LocationIdentity OBJECT_MONITOR_SUCC_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_succ&quot;);
688 
689     @Fold
690     public static int lockDisplacedMarkOffset(@InjectedParameter GraalHotSpotVMConfig config) {
691         return config.basicLockDisplacedHeaderOffset;
692     }
693 
694     @Fold
695     public static boolean useBiasedLocking(@InjectedParameter GraalHotSpotVMConfig config) {
696         return config.useBiasedLocking;
697     }
698 
699     @Fold
700     static int uninitializedIdentityHashCodeValue(@InjectedParameter GraalHotSpotVMConfig config) {
701         return config.uninitializedIdentityHashCodeValue;
702     }
703 
704     @Fold
705     static int identityHashCodeShift(@InjectedParameter GraalHotSpotVMConfig config) {
706         return config.identityHashCodeShift;
707     }
708 
709     /**
710      * Loads the hub of an object (without null checking it first).
711      */
712     public static KlassPointer loadHub(Object object) {
713         return loadHubIntrinsic(object);
714     }
715 
716     public static Object verifyOop(Object object) {
717         if (verifyOops(INJECTED_VMCONFIG)) {
718             verifyOopStub(VERIFY_OOP, object);
719         }
720         return object;
721     }
722 
723     @NodeIntrinsic(ForeignCallNode.class)
724     private static native Object verifyOopStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
725 
726     public static Word loadWordFromObject(Object object, int offset) {
727         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadWordFromObject&quot;);
728         return loadWordFromObjectIntrinsic(object, offset, LocationIdentity.any(), getWordKind());
729     }
730 
731     public static Word loadWordFromObject(Object object, int offset, LocationIdentity identity) {
732         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadWordFromObject&quot;);
733         return loadWordFromObjectIntrinsic(object, offset, identity, getWordKind());
734     }
735 
736     public static KlassPointer loadKlassFromObject(Object object, int offset, LocationIdentity identity) {
737         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadKlassFromObject&quot;);
738         return loadKlassFromObjectIntrinsic(object, offset, identity, getWordKind());
739     }
740 
741     /**
742      * Reads the value of a given register.
743      *
744      * @param register a register which must not be available to the register allocator
745      * @return the value of {@code register} as a word
746      */
747     public static Word registerAsWord(@ConstantNodeParameter Register register) {
748         return registerAsWord(register, true, false);
749     }
750 
751     @NodeIntrinsic(value = ReadRegisterNode.class)
752     public static native Word registerAsWord(@ConstantNodeParameter Register register, @ConstantNodeParameter boolean directUse, @ConstantNodeParameter boolean incoming);
753 
754     @NodeIntrinsic(value = WriteRegisterNode.class)
755     public static native void writeRegisterAsWord(@ConstantNodeParameter Register register, Word value);
756 
757     @NodeIntrinsic(value = RawLoadNode.class)
758     private static native Word loadWordFromObjectIntrinsic(Object object, long offset, @ConstantNodeParameter LocationIdentity locationIdentity, @ConstantNodeParameter JavaKind wordKind);
759 
760     @NodeIntrinsic(value = RawLoadNode.class)
761     private static native KlassPointer loadKlassFromObjectIntrinsic(Object object, long offset, @ConstantNodeParameter LocationIdentity locationIdentity, @ConstantNodeParameter JavaKind wordKind);
762 
763     @NodeIntrinsic(value = LoadHubNode.class)
764     public static native KlassPointer loadHubIntrinsic(Object object);
765 
766     @NodeIntrinsic(value = LoadHubOrNullNode.class)
767     public static native KlassPointer loadHubOrNullIntrinsic(Object object);
768 
769     static final LocationIdentity CLASS_INIT_STATE_LOCATION = NamedLocationIdentity.mutable(&quot;ClassInitState&quot;);
770 
771     static final LocationIdentity CLASS_INIT_THREAD_LOCATION = NamedLocationIdentity.mutable(&quot;ClassInitThread&quot;);
772 
773     @Fold
774     static int instanceKlassInitStateOffset(@InjectedParameter GraalHotSpotVMConfig config) {
775         return config.instanceKlassInitStateOffset;
776     }
777 
778     @Fold
779     static int instanceKlassInitThreadOffset(@InjectedParameter GraalHotSpotVMConfig config) {
780         assert config.instanceKlassInitThreadOffset != -1;
781         return config.instanceKlassInitThreadOffset;
782     }
783 
784     @Fold
785     public static int instanceKlassStateFullyInitialized(@InjectedParameter GraalHotSpotVMConfig config) {
786         return config.instanceKlassStateFullyInitialized;
787     }
788 
789     @Fold
790     public static int instanceKlassStateBeingInitialized(@InjectedParameter GraalHotSpotVMConfig config) {
791         assert config.instanceKlassStateBeingInitialized != -1;
792         return config.instanceKlassStateBeingInitialized;
793     }
794 
795     /**
796      *
797      * @param hub the hub of an InstanceKlass
798      * @return true is the InstanceKlass represented by hub is fully initialized
799      */
800     public static boolean isInstanceKlassFullyInitialized(KlassPointer hub) {
801         return readInstanceKlassInitState(hub) == instanceKlassStateFullyInitialized(INJECTED_VMCONFIG);
802     }
803 
804     static byte readInstanceKlassInitState(KlassPointer hub) {
805         return hub.readByte(instanceKlassInitStateOffset(INJECTED_VMCONFIG), CLASS_INIT_STATE_LOCATION);
806     }
807 
808     static Word readInstanceKlassInitThread(KlassPointer hub) {
809         return hub.readWord(instanceKlassInitThreadOffset(INJECTED_VMCONFIG), CLASS_INIT_THREAD_LOCATION);
810     }
811 
812     public static final LocationIdentity KLASS_MODIFIER_FLAGS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_modifier_flags&quot;);
813 
814     @Fold
815     public static int klassModifierFlagsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
816         return config.klassModifierFlagsOffset;
817     }
818 
819     public static final LocationIdentity CLASS_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Class._klass&quot;) {
820         @Override
821         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
822             return foldIndirection(read, object, CLASS_MIRROR_LOCATION);
823         }
824     };
825 
826     public static final LocationIdentity CLASS_ARRAY_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Class._array_klass&quot;) {
827         @Override
828         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
829             return foldIndirection(read, object, ARRAY_KLASS_COMPONENT_MIRROR);
830         }
831     };
832 
833     @Fold
834     public static int arrayKlassOffset(@InjectedParameter GraalHotSpotVMConfig config) {
835         return config.arrayKlassOffset;
836     }
837 
838     public static final LocationIdentity CLASS_MIRROR_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_java_mirror&quot;);
839 
840     public static final LocationIdentity CLASS_MIRROR_HANDLE_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_java_mirror handle&quot;);
841 
842     @Fold
843     public static int layoutHelperHeaderSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
844         return config.layoutHelperHeaderSizeShift;
845     }
846 
847     @Fold
848     public static int layoutHelperHeaderSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
849         return config.layoutHelperHeaderSizeMask;
850     }
851 
852     @Fold
853     public static int layoutHelperLog2ElementSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
854         return config.layoutHelperLog2ElementSizeShift;
855     }
856 
857     @Fold
858     public static int layoutHelperLog2ElementSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
859         return config.layoutHelperLog2ElementSizeMask;
860     }
861 
862     @NodeIntrinsic(ForeignCallNode.class)
863     public static native int identityHashCode(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
864 
865     @Fold
866     public static long gcTotalCollectionsAddress(@InjectedParameter GraalHotSpotVMConfig config) {
867         return config.gcTotalCollectionsAddress();
868     }
869 
870     @Fold
871     public static long referentOffset(@InjectedParameter MetaAccessProvider metaAccessProvider) {
872         return referentField(metaAccessProvider).getOffset();
873     }
874 
875     @Fold
876     public static ResolvedJavaField referentField(@InjectedParameter MetaAccessProvider metaAccessProvider) {
877         return getField(metaAccessProvider.lookupJavaType(Reference.class), &quot;referent&quot;);
878     }
879 
880     @Fold
881     public static ResolvedJavaType referenceType(@InjectedParameter MetaAccessProvider metaAccessProvider) {
882         return metaAccessProvider.lookupJavaType(Reference.class);
883     }
884 
885     public static final LocationIdentity OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;ObjArrayKlass::_element_klass&quot;) {
886         @Override
887         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
888             ValueNode javaObject = findReadHub(object);
889             if (javaObject != null) {
890                 ResolvedJavaType type = StampTool.typeOrNull(javaObject);
891                 if (type != null &amp;&amp; type.isArray()) {
892                     ResolvedJavaType element = type.getComponentType();
893                     if (element != null &amp;&amp; !element.isPrimitive() &amp;&amp; !element.getElementalType().isInterface()) {
894                         Assumptions assumptions = object.graph().getAssumptions();
895                         AssumptionResult&lt;ResolvedJavaType&gt; leafType = element.findLeafConcreteSubtype();
896                         if (leafType != null &amp;&amp; leafType.canRecordTo(assumptions)) {
897                             leafType.recordTo(assumptions);
898                             return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), tool.getConstantReflection().asObjectHub(leafType.getResult()), tool.getMetaAccess());
899                         }
900                     }
901                 }
902             }
903             return read;
904         }
905     };
906 
907     @Fold
908     public static int arrayClassElementOffset(@InjectedParameter GraalHotSpotVMConfig config) {
909         return config.arrayClassElementOffset;
910     }
911 
912     public static final LocationIdentity PRIMARY_SUPERS_LOCATION = NamedLocationIdentity.immutable(&quot;PrimarySupers&quot;);
913 
914     public static final LocationIdentity METASPACE_ARRAY_LENGTH_LOCATION = NamedLocationIdentity.immutable(&quot;MetaspaceArrayLength&quot;);
915 
916     public static final LocationIdentity SECONDARY_SUPERS_ELEMENT_LOCATION = NamedLocationIdentity.immutable(&quot;SecondarySupersElement&quot;);
917 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ConstMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../java.net.http/share/classes/jdk/internal/net/http/Stream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../runtime/ThreadStackTrace.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ConstMethod.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
177   }
178 
179   public long getSizeOfParameters() {
180     return sizeOfParameters.getValue(this);
181   }
182 
183   public Symbol getName() {
184     return getMethod().getName();
185   }
186 
187   public Symbol getSignature() {
188     return getMethod().getSignature();
189   }
190 
191   public Symbol getGenericSignature() {
192     return getMethod().getGenericSignature();
193   }
194 
195   // bytecode accessors
196 











197   /** Get a bytecode or breakpoint at the given bci */
198   public int getBytecodeOrBPAt(int bci) {
199     return getAddress().getJByteAt(bytecodeOffset + bci) &amp; 0xFF;
200   }
201 
202   public byte getBytecodeByteArg(int bci) {
203     return (byte) getBytecodeOrBPAt(bci);
204   }
205 
206   /** Fetches a 16-bit big-endian (&quot;Java ordered&quot;) value from the
207       bytecode stream */
208   public short getBytecodeShortArg(int bci) {
209     int hi = getBytecodeOrBPAt(bci);
210     int lo = getBytecodeOrBPAt(bci + 1);
211     return (short) ((hi &lt;&lt; 8) | lo);
212   }
213 
214   /** Fetches a 16-bit native ordered value from the
215       bytecode stream */
216   public short getNativeShortArg(int bci) {
</pre>
<hr />
<pre>
279       visitor.doCInt(maxLocals, true);
280       visitor.doCInt(sizeOfParameters, true);
281     }
282 
283   // Accessors
284 
285   public boolean hasLineNumberTable() {
286     return (getFlags() &amp; HAS_LINENUMBER_TABLE) != 0;
287   }
288 
289   public int getLineNumberFromBCI(int bci) {
290     if (!VM.getVM().isCore()) {
291       if (bci == DebugInformationRecorder.SYNCHRONIZATION_ENTRY_BCI) bci = 0;
292     }
293 
294     if (isNative()) {
295       return -1;
296     }
297 
298     if (Assert.ASSERTS_ENABLED) {
<span class="line-modified">299       Assert.that(bci == 0 || 0 &lt;= bci &amp;&amp; bci &lt; getCodeSize(), &quot;illegal bci&quot;);</span>

300     }
301     int bestBCI  =  0;
302     int bestLine = -1;
303     if (hasLineNumberTable()) {
304       // The line numbers are a short array of 2-tuples [start_pc, line_number].
305       // Not necessarily sorted and not necessarily one-to-one.
306       CompressedLineNumberReadStream stream =
307         new CompressedLineNumberReadStream(getAddress(), (int) offsetOfCompressedLineNumberTable());
308       while (stream.readPair()) {
309         if (stream.bci() == bci) {
310           // perfect match
311           return stream.line();
312         } else {
313           // update best_bci/line
314           if (stream.bci() &lt; bci &amp;&amp; stream.bci() &gt;= bestBCI) {
315             bestBCI  = stream.bci();
316             bestLine = stream.line();
317           }
318         }
319       }
</pre>
</td>
<td>
<hr />
<pre>
177   }
178 
179   public long getSizeOfParameters() {
180     return sizeOfParameters.getValue(this);
181   }
182 
183   public Symbol getName() {
184     return getMethod().getName();
185   }
186 
187   public Symbol getSignature() {
188     return getMethod().getSignature();
189   }
190 
191   public Symbol getGenericSignature() {
192     return getMethod().getGenericSignature();
193   }
194 
195   // bytecode accessors
196 
<span class="line-added">197   /** See if address is in the Method&#39;s bytecodes */</span>
<span class="line-added">198   public boolean isAddressInMethod(Address bcp) {</span>
<span class="line-added">199     Address bytecodeStart = getAddress().addOffsetTo(bytecodeOffset);</span>
<span class="line-added">200     Address bytecodeEnd = bytecodeStart.addOffsetTo(getCodeSize() - 1);</span>
<span class="line-added">201     if (bcp.greaterThanOrEqual(bytecodeStart) &amp;&amp; bcp.lessThanOrEqual(bytecodeEnd)) {</span>
<span class="line-added">202       return true;</span>
<span class="line-added">203     } else {</span>
<span class="line-added">204       return false;</span>
<span class="line-added">205     }</span>
<span class="line-added">206   }</span>
<span class="line-added">207 </span>
208   /** Get a bytecode or breakpoint at the given bci */
209   public int getBytecodeOrBPAt(int bci) {
210     return getAddress().getJByteAt(bytecodeOffset + bci) &amp; 0xFF;
211   }
212 
213   public byte getBytecodeByteArg(int bci) {
214     return (byte) getBytecodeOrBPAt(bci);
215   }
216 
217   /** Fetches a 16-bit big-endian (&quot;Java ordered&quot;) value from the
218       bytecode stream */
219   public short getBytecodeShortArg(int bci) {
220     int hi = getBytecodeOrBPAt(bci);
221     int lo = getBytecodeOrBPAt(bci + 1);
222     return (short) ((hi &lt;&lt; 8) | lo);
223   }
224 
225   /** Fetches a 16-bit native ordered value from the
226       bytecode stream */
227   public short getNativeShortArg(int bci) {
</pre>
<hr />
<pre>
290       visitor.doCInt(maxLocals, true);
291       visitor.doCInt(sizeOfParameters, true);
292     }
293 
294   // Accessors
295 
296   public boolean hasLineNumberTable() {
297     return (getFlags() &amp; HAS_LINENUMBER_TABLE) != 0;
298   }
299 
300   public int getLineNumberFromBCI(int bci) {
301     if (!VM.getVM().isCore()) {
302       if (bci == DebugInformationRecorder.SYNCHRONIZATION_ENTRY_BCI) bci = 0;
303     }
304 
305     if (isNative()) {
306       return -1;
307     }
308 
309     if (Assert.ASSERTS_ENABLED) {
<span class="line-modified">310         Assert.that(0 &lt;= bci &amp;&amp; bci &lt; getCodeSize(),</span>
<span class="line-added">311                     &quot;illegal bci(&quot; + bci + &quot;) codeSize(&quot; + getCodeSize() + &quot;)&quot;);</span>
312     }
313     int bestBCI  =  0;
314     int bestLine = -1;
315     if (hasLineNumberTable()) {
316       // The line numbers are a short array of 2-tuples [start_pc, line_number].
317       // Not necessarily sorted and not necessarily one-to-one.
318       CompressedLineNumberReadStream stream =
319         new CompressedLineNumberReadStream(getAddress(), (int) offsetOfCompressedLineNumberTable());
320       while (stream.readPair()) {
321         if (stream.bci() == bci) {
322           // perfect match
323           return stream.line();
324         } else {
325           // update best_bci/line
326           if (stream.bci() &lt; bci &amp;&amp; stream.bci() &gt;= bestBCI) {
327             bestBCI  = stream.bci();
328             bestLine = stream.line();
329           }
330         }
331       }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../java.net.http/share/classes/jdk/internal/net/http/Stream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../runtime/ThreadStackTrace.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
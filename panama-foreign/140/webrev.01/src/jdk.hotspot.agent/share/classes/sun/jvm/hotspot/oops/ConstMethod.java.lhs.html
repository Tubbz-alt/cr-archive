<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ConstMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.oops;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.code.*;
 30 import sun.jvm.hotspot.debugger.*;
 31 import sun.jvm.hotspot.interpreter.*;
 32 import sun.jvm.hotspot.memory.*;
 33 import sun.jvm.hotspot.runtime.*;
 34 import sun.jvm.hotspot.types.*;
 35 import sun.jvm.hotspot.utilities.*;
 36 import sun.jvm.hotspot.utilities.Observable;
 37 import sun.jvm.hotspot.utilities.Observer;
 38 
 39 public class ConstMethod extends Metadata {
 40   static {
 41     VM.registerVMInitializedObserver(new Observer() {
 42         public void update(Observable o, Object data) {
 43           initialize(VM.getVM().getTypeDataBase());
 44         }
 45       });
 46   }
 47 
 48   // anon-enum constants for _flags.
 49   private static int HAS_LINENUMBER_TABLE;
 50   private static int HAS_CHECKED_EXCEPTIONS;
 51   private static int HAS_LOCALVARIABLE_TABLE;
 52   private static int HAS_EXCEPTION_TABLE;
 53   private static int HAS_GENERIC_SIGNATURE;
 54   private static int HAS_METHOD_ANNOTATIONS;
 55   private static int HAS_PARAMETER_ANNOTATIONS;
 56   private static int HAS_METHOD_PARAMETERS;
 57   private static int HAS_DEFAULT_ANNOTATIONS;
 58   private static int HAS_TYPE_ANNOTATIONS;
 59 
 60   private static final int sizeofShort = 2;
 61 
 62   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 63     Type type                  = db.lookupType(&quot;ConstMethod&quot;);
 64     constants                  = new MetadataField(type.getAddressField(&quot;_constants&quot;), 0);
 65     constMethodSize            = new CIntField(type.getCIntegerField(&quot;_constMethod_size&quot;), 0);
 66     flags                      = new CIntField(type.getCIntegerField(&quot;_flags&quot;), 0);
 67 
 68     // enum constants for flags
 69     HAS_LINENUMBER_TABLE      = db.lookupIntConstant(&quot;ConstMethod::_has_linenumber_table&quot;).intValue();
 70     HAS_CHECKED_EXCEPTIONS     = db.lookupIntConstant(&quot;ConstMethod::_has_checked_exceptions&quot;).intValue();
 71     HAS_LOCALVARIABLE_TABLE   = db.lookupIntConstant(&quot;ConstMethod::_has_localvariable_table&quot;).intValue();
 72     HAS_EXCEPTION_TABLE       = db.lookupIntConstant(&quot;ConstMethod::_has_exception_table&quot;).intValue();
 73     HAS_GENERIC_SIGNATURE     = db.lookupIntConstant(&quot;ConstMethod::_has_generic_signature&quot;).intValue();
 74     HAS_METHOD_ANNOTATIONS    = db.lookupIntConstant(&quot;ConstMethod::_has_method_annotations&quot;).intValue();
 75     HAS_PARAMETER_ANNOTATIONS = db.lookupIntConstant(&quot;ConstMethod::_has_parameter_annotations&quot;).intValue();
 76     HAS_METHOD_PARAMETERS = db.lookupIntConstant(&quot;ConstMethod::_has_method_parameters&quot;).intValue();
 77     HAS_DEFAULT_ANNOTATIONS   = db.lookupIntConstant(&quot;ConstMethod::_has_default_annotations&quot;).intValue();
 78     HAS_TYPE_ANNOTATIONS      = db.lookupIntConstant(&quot;ConstMethod::_has_type_annotations&quot;).intValue();
 79 
 80     // Size of Java bytecodes allocated immediately after ConstMethod*.
 81     codeSize                   = new CIntField(type.getCIntegerField(&quot;_code_size&quot;), 0);
 82     nameIndex                  = new CIntField(type.getCIntegerField(&quot;_name_index&quot;), 0);
 83     signatureIndex             = new CIntField(type.getCIntegerField(&quot;_signature_index&quot;), 0);
 84     idnum                      = new CIntField(type.getCIntegerField(&quot;_method_idnum&quot;), 0);
 85     maxStack                   = new CIntField(type.getCIntegerField(&quot;_max_stack&quot;), 0);
 86     maxLocals                  = new CIntField(type.getCIntegerField(&quot;_max_locals&quot;), 0);
 87     sizeOfParameters           = new CIntField(type.getCIntegerField(&quot;_size_of_parameters&quot;), 0);
 88 
 89     // start of byte code
 90     bytecodeOffset = type.getSize();
 91 
 92     type                       = db.lookupType(&quot;MethodParametersElement&quot;);
 93     methodParametersElementSize = type.getSize();
 94 
 95     type                       = db.lookupType(&quot;CheckedExceptionElement&quot;);
 96     checkedExceptionElementSize = type.getSize();
 97 
 98     type                       = db.lookupType(&quot;LocalVariableTableElement&quot;);
 99     localVariableTableElementSize = type.getSize();
100 
101     type                       = db.lookupType(&quot;ExceptionTableElement&quot;);
102     exceptionTableElementSize = type.getSize();
103   }
104 
105   public ConstMethod(Address addr) {
106     super(addr);
107   }
108 
109   // Fields
110   private static MetadataField constants;
111   private static CIntField constMethodSize;
112   private static CIntField flags;
113   private static CIntField codeSize;
114   private static CIntField nameIndex;
115   private static CIntField signatureIndex;
116   private static CIntField idnum;
117   private static CIntField maxStack;
118   private static CIntField maxLocals;
119   private static CIntField sizeOfParameters;
120 
121   // start of bytecode
122   private static long bytecodeOffset;
123   private static long methodParametersElementSize;
124   private static long checkedExceptionElementSize;
125   private static long localVariableTableElementSize;
126   private static long exceptionTableElementSize;
127 
128   public Method getMethod() {
129     InstanceKlass ik = (InstanceKlass)getConstants().getPoolHolder();
130     MethodArray methods = ik.getMethods();
131     return methods.at((int)getIdNum());
132   }
133 
134   // Accessors for declared fields
135   public ConstantPool getConstants() {
136     return (ConstantPool) constants.getValue(this);
137   }
138 
139   public long getConstMethodSize() {
140     return constMethodSize.getValue(this);
141   }
142 
143   public long getFlags() {
144     return flags.getValue(this);
145   }
146 
147   public long getCodeSize() {
148     return codeSize.getValue(this);
149   }
150 
151   public long getNameIndex() {
152     return nameIndex.getValue(this);
153   }
154 
155   public long getSignatureIndex() {
156     return signatureIndex.getValue(this);
157   }
158 
159   public long getGenericSignatureIndex() {
160     if (hasGenericSignature()) {
161       return getAddress().getCIntegerAt(offsetOfGenericSignatureIndex(), 2, true);
162     } else {
163       return 0;
164     }
165   }
166 
167   public long getIdNum() {
168     return idnum.getValue(this);
169   }
170 
171   public long getMaxStack() {
172     return maxStack.getValue(this);
173   }
174 
175   public long getMaxLocals() {
176     return maxLocals.getValue(this);
177   }
178 
179   public long getSizeOfParameters() {
180     return sizeOfParameters.getValue(this);
181   }
182 
183   public Symbol getName() {
184     return getMethod().getName();
185   }
186 
187   public Symbol getSignature() {
188     return getMethod().getSignature();
189   }
190 
191   public Symbol getGenericSignature() {
192     return getMethod().getGenericSignature();
193   }
194 
195   // bytecode accessors
196 
<a name="1" id="anc1"></a>










197   /** Get a bytecode or breakpoint at the given bci */
198   public int getBytecodeOrBPAt(int bci) {
199     return getAddress().getJByteAt(bytecodeOffset + bci) &amp; 0xFF;
200   }
201 
202   public byte getBytecodeByteArg(int bci) {
203     return (byte) getBytecodeOrBPAt(bci);
204   }
205 
206   /** Fetches a 16-bit big-endian (&quot;Java ordered&quot;) value from the
207       bytecode stream */
208   public short getBytecodeShortArg(int bci) {
209     int hi = getBytecodeOrBPAt(bci);
210     int lo = getBytecodeOrBPAt(bci + 1);
211     return (short) ((hi &lt;&lt; 8) | lo);
212   }
213 
214   /** Fetches a 16-bit native ordered value from the
215       bytecode stream */
216   public short getNativeShortArg(int bci) {
217     int hi = getBytecodeOrBPAt(bci);
218     int lo = getBytecodeOrBPAt(bci + 1);
219     if (VM.getVM().isBigEndian()) {
220         return (short) ((hi &lt;&lt; 8) | lo);
221     } else {
222         return (short) ((lo &lt;&lt; 8) | hi);
223     }
224   }
225 
226   /** Fetches a 32-bit big-endian (&quot;Java ordered&quot;) value from the
227       bytecode stream */
228   public int getBytecodeIntArg(int bci) {
229     int b4 = getBytecodeOrBPAt(bci);
230     int b3 = getBytecodeOrBPAt(bci + 1);
231     int b2 = getBytecodeOrBPAt(bci + 2);
232     int b1 = getBytecodeOrBPAt(bci + 3);
233 
234     return (b4 &lt;&lt; 24) | (b3 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b1;
235   }
236 
237   /** Fetches a 32-bit native ordered value from the
238       bytecode stream */
239   public int getNativeIntArg(int bci) {
240     int b4 = getBytecodeOrBPAt(bci);
241     int b3 = getBytecodeOrBPAt(bci + 1);
242     int b2 = getBytecodeOrBPAt(bci + 2);
243     int b1 = getBytecodeOrBPAt(bci + 3);
244 
245     if (VM.getVM().isBigEndian()) {
246         return (b4 &lt;&lt; 24) | (b3 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b1;
247     } else {
248         return (b1 &lt;&lt; 24) | (b2 &lt;&lt; 16) | (b3 &lt;&lt; 8) | b4;
249     }
250   }
251 
252   public byte[] getByteCode() {
253      byte[] bc = new byte[ (int) getCodeSize() ];
254      for( int i=0; i &lt; bc.length; i++ )
255      {
256         long offs = bytecodeOffset + i;
257         bc[i] = getAddress().getJByteAt( offs );
258      }
259      return bc;
260   }
261 
262   public long getSize() {
263     return getConstMethodSize();
264   }
265 
266   public void printValueOn(PrintStream tty) {
267     tty.print(&quot;ConstMethod &quot; + getName().asString() + getSignature().asString() + &quot;@&quot; + getAddress());
268   }
269 
270   public void iterateFields(MetadataVisitor visitor) {
271     visitor.doMetadata(constants, true);
272       visitor.doCInt(constMethodSize, true);
273       visitor.doCInt(flags, true);
274       visitor.doCInt(codeSize, true);
275       visitor.doCInt(nameIndex, true);
276       visitor.doCInt(signatureIndex, true);
277       visitor.doCInt(codeSize, true);
278       visitor.doCInt(maxStack, true);
279       visitor.doCInt(maxLocals, true);
280       visitor.doCInt(sizeOfParameters, true);
281     }
282 
283   // Accessors
284 
285   public boolean hasLineNumberTable() {
286     return (getFlags() &amp; HAS_LINENUMBER_TABLE) != 0;
287   }
288 
289   public int getLineNumberFromBCI(int bci) {
290     if (!VM.getVM().isCore()) {
291       if (bci == DebugInformationRecorder.SYNCHRONIZATION_ENTRY_BCI) bci = 0;
292     }
293 
294     if (isNative()) {
295       return -1;
296     }
297 
298     if (Assert.ASSERTS_ENABLED) {
<a name="2" id="anc2"></a><span class="line-modified">299       Assert.that(bci == 0 || 0 &lt;= bci &amp;&amp; bci &lt; getCodeSize(), &quot;illegal bci&quot;);</span>

300     }
301     int bestBCI  =  0;
302     int bestLine = -1;
303     if (hasLineNumberTable()) {
304       // The line numbers are a short array of 2-tuples [start_pc, line_number].
305       // Not necessarily sorted and not necessarily one-to-one.
306       CompressedLineNumberReadStream stream =
307         new CompressedLineNumberReadStream(getAddress(), (int) offsetOfCompressedLineNumberTable());
308       while (stream.readPair()) {
309         if (stream.bci() == bci) {
310           // perfect match
311           return stream.line();
312         } else {
313           // update best_bci/line
314           if (stream.bci() &lt; bci &amp;&amp; stream.bci() &gt;= bestBCI) {
315             bestBCI  = stream.bci();
316             bestLine = stream.line();
317           }
318         }
319       }
320     }
321     return bestLine;
322   }
323 
324   public LineNumberTableElement[] getLineNumberTable() {
325     if (Assert.ASSERTS_ENABLED) {
326       Assert.that(hasLineNumberTable(),
327                   &quot;should only be called if table is present&quot;);
328     }
329     int len = getLineNumberTableLength();
330     CompressedLineNumberReadStream stream =
331       new CompressedLineNumberReadStream(getAddress(), (int) offsetOfCompressedLineNumberTable());
332     LineNumberTableElement[] ret = new LineNumberTableElement[len];
333 
334     for (int idx = 0; idx &lt; len; idx++) {
335       stream.readPair();
336       ret[idx] = new LineNumberTableElement(stream.bci(), stream.line());
337     }
338     return ret;
339   }
340 
341   public boolean hasLocalVariableTable() {
342     return (getFlags() &amp; HAS_LOCALVARIABLE_TABLE) != 0;
343   }
344 
345   public Symbol getLocalVariableName(int bci, int slot) {
346     return getMethod().getLocalVariableName(bci, slot);
347   }
348 
349   /** Should only be called if table is present */
350   public LocalVariableTableElement[] getLocalVariableTable() {
351     if (Assert.ASSERTS_ENABLED) {
352       Assert.that(hasLocalVariableTable(), &quot;should only be called if table is present&quot;);
353     }
354     LocalVariableTableElement[] ret = new LocalVariableTableElement[getLocalVariableTableLength()];
355     long offset = offsetOfLocalVariableTable();
356     for (int i = 0; i &lt; ret.length; i++) {
357       ret[i] = new LocalVariableTableElement(getAddress(), offset);
358       offset += localVariableTableElementSize;
359     }
360     return ret;
361   }
362 
363   public boolean hasExceptionTable() {
364     return (getFlags() &amp; HAS_EXCEPTION_TABLE) != 0;
365   }
366 
367   public ExceptionTableElement[] getExceptionTable() {
368     if (Assert.ASSERTS_ENABLED) {
369       Assert.that(hasExceptionTable(), &quot;should only be called if table is present&quot;);
370     }
371     ExceptionTableElement[] ret = new ExceptionTableElement[getExceptionTableLength()];
372     long offset = offsetOfExceptionTable();
373     for (int i = 0; i &lt; ret.length; i++) {
374       ret[i] = new ExceptionTableElement(getAddress(), offset);
375       offset += exceptionTableElementSize;
376     }
377     return ret;
378   }
379 
380   public boolean hasCheckedExceptions() {
381     return (getFlags() &amp; HAS_CHECKED_EXCEPTIONS) != 0;
382   }
383 
384   public CheckedExceptionElement[] getCheckedExceptions() {
385     if (Assert.ASSERTS_ENABLED) {
386       Assert.that(hasCheckedExceptions(), &quot;should only be called if table is present&quot;);
387     }
388     CheckedExceptionElement[] ret = new CheckedExceptionElement[getCheckedExceptionsLength()];
389     long offset = offsetOfCheckedExceptions();
390     for (int i = 0; i &lt; ret.length; i++) {
391       ret[i] = new CheckedExceptionElement(getAddress(), offset);
392       offset += checkedExceptionElementSize;
393     }
394     return ret;
395   }
396 
397   private boolean hasMethodParameters() {
398     return (getFlags() &amp; HAS_METHOD_PARAMETERS) != 0;
399   }
400 
401   private boolean hasGenericSignature() {
402     return (getFlags() &amp; HAS_GENERIC_SIGNATURE) != 0;
403   }
404 
405   private boolean hasMethodAnnotations() {
406     return (getFlags() &amp; HAS_METHOD_ANNOTATIONS) != 0;
407   }
408 
409   private boolean hasParameterAnnotations() {
410     return (getFlags() &amp; HAS_PARAMETER_ANNOTATIONS) != 0;
411   }
412 
413   private boolean hasDefaultAnnotations() {
414     return (getFlags() &amp; HAS_DEFAULT_ANNOTATIONS) != 0;
415   }
416 
417   private boolean hasTypeAnnotations() {
418     return (getFlags() &amp; HAS_TYPE_ANNOTATIONS) != 0;
419   }
420 
421 
422   //---------------------------------------------------------------------------
423   // Internals only below this point
424   //
425 
426   private boolean isNative() {
427     return getMethod().isNative();
428   }
429 
430   // Offset of end of code
431   private long offsetOfCodeEnd() {
432     return bytecodeOffset + getCodeSize();
433   }
434 
435   // Offset of start of compressed line number table (see method.hpp)
436   private long offsetOfCompressedLineNumberTable() {
437     return offsetOfCodeEnd() + (isNative() ? 2 * VM.getVM().getAddressSize() : 0);
438   }
439 
440   // Offset of last short in Method* before annotations, if present
441   private long offsetOfLastU2Element() {
442     int offset = 0;
443     if (hasMethodAnnotations()) offset++;
444     if (hasParameterAnnotations()) offset++;
445     if (hasTypeAnnotations()) offset++;
446     if (hasDefaultAnnotations()) offset++;
447     long wordSize = VM.getVM().getObjectHeap().getOopSize();
448     return (getSize() * wordSize) - (offset * wordSize) - sizeofShort;
449   }
450 
451   // Offset of the generic signature index
452   private long offsetOfGenericSignatureIndex() {
453     return offsetOfLastU2Element();
454   }
455 
456   private long offsetOfMethodParametersLength() {
457     if (Assert.ASSERTS_ENABLED) {
458       Assert.that(hasMethodParameters(), &quot;should only be called if table is present&quot;);
459     }
460     return hasGenericSignature() ? offsetOfLastU2Element() - sizeofShort :
461                                    offsetOfLastU2Element();
462   }
463 
464   private int getMethodParametersLength() {
465       if (hasMethodParameters())
466           return (int) getAddress().getCIntegerAt(offsetOfMethodParametersLength(), 2, true);
467       else
468           return 0;
469   }
470 
471   // Offset of start of checked exceptions
472   private long offsetOfMethodParameters() {
473     long offset = offsetOfMethodParametersLength();
474     long length = getMethodParametersLength();
475     if (Assert.ASSERTS_ENABLED) {
476       Assert.that(length &gt; 0, &quot;should only be called if method parameter information is present&quot;);
477     }
478     offset -= length * methodParametersElementSize;
479     return offset;
480   }
481 
482   private long offsetOfCheckedExceptionsLength() {
483     if (hasMethodParameters())
484       return offsetOfMethodParameters() - sizeofShort;
485     else {
486       return hasGenericSignature() ? offsetOfLastU2Element() - sizeofShort :
487                                      offsetOfLastU2Element();
488     }
489   }
490 
491   private int getCheckedExceptionsLength() {
492     if (hasCheckedExceptions()) {
493       return (int) getAddress().getCIntegerAt(offsetOfCheckedExceptionsLength(), 2, true);
494     } else {
495       return 0;
496     }
497   }
498 
499   // Offset of start of checked exceptions
500   private long offsetOfCheckedExceptions() {
501     long offset = offsetOfCheckedExceptionsLength();
502     long length = getCheckedExceptionsLength();
503     if (Assert.ASSERTS_ENABLED) {
504       Assert.that(length &gt; 0, &quot;should only be called if table is present&quot;);
505     }
506     offset -= length * checkedExceptionElementSize;
507     return offset;
508   }
509 
510   private int getLineNumberTableLength() {
511     int len = 0;
512     if (hasLineNumberTable()) {
513       CompressedLineNumberReadStream stream =
514         new CompressedLineNumberReadStream(getAddress(), (int) offsetOfCompressedLineNumberTable());
515       while (stream.readPair()) {
516         len += 1;
517       }
518     }
519     return len;
520   }
521 
522   private int getLocalVariableTableLength() {
523     if (hasLocalVariableTable()) {
524       return (int) getAddress().getCIntegerAt(offsetOfLocalVariableTableLength(), 2, true);
525     } else {
526       return 0;
527     }
528   }
529 
530   // Offset of local variable table length
531   private long offsetOfLocalVariableTableLength() {
532     if (Assert.ASSERTS_ENABLED) {
533       Assert.that(hasLocalVariableTable(), &quot;should only be called if table is present&quot;);
534     }
535 
536     if (hasExceptionTable()) {
537       return offsetOfExceptionTable() - sizeofShort;
538     } else if (hasCheckedExceptions()) {
539       return offsetOfCheckedExceptions() - sizeofShort;
540     } else if (hasMethodParameters()) {
541       return offsetOfMethodParameters() - sizeofShort;
542     } else {
543       return hasGenericSignature() ? offsetOfLastU2Element() - sizeofShort :
544                                      offsetOfLastU2Element();
545     }
546   }
547 
548   private long offsetOfLocalVariableTable() {
549     long offset = offsetOfLocalVariableTableLength();
550     long length = getLocalVariableTableLength();
551     if (Assert.ASSERTS_ENABLED) {
552       Assert.that(length &gt; 0, &quot;should only be called if table is present&quot;);
553     }
554     offset -= length * localVariableTableElementSize;
555     return offset;
556   }
557 
558   private int getExceptionTableLength() {
559     if (hasExceptionTable()) {
560       return (int) getAddress().getCIntegerAt(offsetOfExceptionTableLength(), 2, true);
561     } else {
562       return 0;
563     }
564   }
565 
566   private long offsetOfExceptionTableLength() {
567     if (Assert.ASSERTS_ENABLED) {
568       Assert.that(hasExceptionTable(), &quot;should only be called if table is present&quot;);
569     }
570     if (hasCheckedExceptions()) {
571       return offsetOfCheckedExceptions() - sizeofShort;
572     } else if (hasMethodParameters()) {
573       return offsetOfMethodParameters() - sizeofShort;
574     } else {
575       return hasGenericSignature() ? offsetOfLastU2Element() - sizeofShort :
576                                      offsetOfLastU2Element();
577     }
578   }
579 
580   private long offsetOfExceptionTable() {
581     long offset = offsetOfExceptionTableLength();
582     long length = getExceptionTableLength();
583     if (Assert.ASSERTS_ENABLED) {
584       Assert.that(length &gt; 0, &quot;should only be called if table is present&quot;);
585     }
586     offset -= length * exceptionTableElementSize;
587     return offset;
588   }
589 
590 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ConstMethod.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ConstMethod.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ConstMethod.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ConstMethod.java
@@ -192,10 +192,21 @@
     return getMethod().getGenericSignature();
   }
 
   // bytecode accessors
 
+  /** See if address is in the Method's bytecodes */
+  public boolean isAddressInMethod(Address bcp) {
+    Address bytecodeStart = getAddress().addOffsetTo(bytecodeOffset);
+    Address bytecodeEnd = bytecodeStart.addOffsetTo(getCodeSize() - 1);
+    if (bcp.greaterThanOrEqual(bytecodeStart) && bcp.lessThanOrEqual(bytecodeEnd)) {
+      return true;
+    } else {
+      return false;
+    }
+  }
+
   /** Get a bytecode or breakpoint at the given bci */
   public int getBytecodeOrBPAt(int bci) {
     return getAddress().getJByteAt(bytecodeOffset + bci) & 0xFF;
   }
 
@@ -294,11 +305,12 @@
     if (isNative()) {
       return -1;
     }
 
     if (Assert.ASSERTS_ENABLED) {
-      Assert.that(bci == 0 || 0 <= bci && bci < getCodeSize(), "illegal bci");
+        Assert.that(0 <= bci && bci < getCodeSize(),
+                    "illegal bci(" + bci + ") codeSize(" + getCodeSize() + ")");
     }
     int bestBCI  =  0;
     int bestLine = -1;
     if (hasLineNumberTable()) {
       // The line numbers are a short array of 2-tuples [start_pc, line_number].

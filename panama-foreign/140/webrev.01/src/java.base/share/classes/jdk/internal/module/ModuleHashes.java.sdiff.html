<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/module/ModuleHashes.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../loader/ClassLoaders.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ModuleHashesBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/module/ModuleHashes.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.module;
 27 
 28 import java.io.IOException;

 29 import java.io.UncheckedIOException;
<span class="line-modified"> 30 import java.nio.ByteBuffer;</span>
<span class="line-modified"> 31 import java.nio.channels.FileChannel;</span>
<span class="line-modified"> 32 import java.nio.file.Path;</span>
 33 import java.security.MessageDigest;
 34 import java.security.NoSuchAlgorithmException;

 35 import java.util.Collections;
 36 import java.util.HashMap;
<span class="line-removed"> 37 import java.util.TreeMap;</span>
 38 import java.util.Map;
 39 import java.util.Objects;
 40 import java.util.Set;


 41 
 42 /**
 43  * The result of hashing the contents of a number of module artifacts.
 44  */
 45 
 46 public final class ModuleHashes {
 47 
 48     /**
 49      * A supplier of a message digest.
 50      */
 51     public static interface HashSupplier {
 52         byte[] generate(String algorithm);
 53     }
 54 
 55     private final String algorithm;
 56     private final Map&lt;String, byte[]&gt; nameToHash;
 57 
 58     /**
 59      * Creates a {@code ModuleHashes}.
 60      *
 61      * @param algorithm   the algorithm used to create the hashes
 62      * @param nameToHash  the map of module name to hash value
 63      */
<span class="line-modified"> 64     public ModuleHashes(String algorithm, Map&lt;String, byte[]&gt; nameToHash) {</span>
<span class="line-modified"> 65         this.algorithm = algorithm;</span>
 66         this.nameToHash = Collections.unmodifiableMap(nameToHash);
 67     }
 68 
 69     /**
 70      * Returns the algorithm used to hash the modules (&quot;SHA-256&quot; for example).
 71      */
 72     public String algorithm() {
 73         return algorithm;
 74     }
 75 
 76     /**
 77      * Returns the set of module names for which hashes are recorded.
 78      */
 79     public Set&lt;String&gt; names() {
 80         return nameToHash.keySet();
 81     }
 82 
 83     /**
 84      * Returns the hash for the given module name, {@code null}
 85      * if there is no hash recorded for the module.
 86      */
 87     public byte[] hashFor(String mn) {
 88         return nameToHash.get(mn);
 89     }
 90 
 91     /**
 92      * Returns unmodifiable map of module name to hash
 93      */
 94     public Map&lt;String, byte[]&gt; hashes() {
 95         return nameToHash;
 96     }
 97 
 98     /**
<span class="line-modified"> 99      * Computes the hash for the given file with the given message digest</span>
<span class="line-removed">100      * algorithm.</span>
101      *




102      * @throws UncheckedIOException if an I/O error occurs
<span class="line-removed">103      * @throws RuntimeException if the algorithm is not available</span>
104      */
<span class="line-modified">105     public static byte[] computeHash(Path file, String algorithm) {</span>

106         try {
<span class="line-modified">107             MessageDigest md = MessageDigest.getInstance(algorithm);</span>
<span class="line-modified">108 </span>
<span class="line-modified">109             // Ideally we would just mmap the file but this consumes too much</span>
<span class="line-modified">110             // memory when jlink is running concurrently on very large jmods</span>
<span class="line-modified">111             try (FileChannel fc = FileChannel.open(file)) {</span>
<span class="line-modified">112                 ByteBuffer bb = ByteBuffer.allocate(32*1024);</span>
<span class="line-modified">113                 while (fc.read(bb) &gt; 0) {</span>
<span class="line-modified">114                     bb.flip();</span>
<span class="line-modified">115                     md.update(bb);</span>
<span class="line-modified">116                     assert bb.remaining() == 0;</span>
<span class="line-modified">117                     bb.clear();</span>




118                 }
<span class="line-modified">119             }</span>





120 
<span class="line-modified">121             return md.digest();</span>
<span class="line-modified">122         } catch (NoSuchAlgorithmException e) {</span>
<span class="line-modified">123             throw new RuntimeException(e);</span>









124         } catch (IOException ioe) {
125             throw new UncheckedIOException(ioe);
126         }
127     }
128 
129     /**
<span class="line-modified">130      * Computes the hash for every entry in the given map, returning a</span>
<span class="line-modified">131      * {@code ModuleHashes} to encapsulate the result. The map key is</span>
<span class="line-removed">132      * the entry name, typically the module name. The map value is the file</span>
<span class="line-removed">133      * path to the entry (module artifact).</span>
134      *


135      * @return ModuleHashes that encapsulates the hashes


136      */
<span class="line-modified">137     public static ModuleHashes generate(Map&lt;String, Path&gt; map, String algorithm) {</span>
138         Map&lt;String, byte[]&gt; nameToHash = new TreeMap&lt;&gt;();
<span class="line-modified">139         for (Map.Entry&lt;String, Path&gt; entry: map.entrySet()) {</span>
<span class="line-modified">140             String name = entry.getKey();</span>
<span class="line-modified">141             Path path = entry.getValue();</span>
<span class="line-modified">142             nameToHash.put(name, computeHash(path, algorithm));</span>



143         }
144         return new ModuleHashes(algorithm, nameToHash);
145     }
146 













































147     /**
148      * This is used by jdk.internal.module.SystemModules class
149      * generated at link time.
150      */
151     public static class Builder {
152         final String algorithm;
153         final Map&lt;String, byte[]&gt; nameToHash;
154 
155         Builder(String algorithm, int initialCapacity) {
156             this.nameToHash = new HashMap&lt;&gt;(initialCapacity);
157             this.algorithm =  Objects.requireNonNull(algorithm);
158         }
159 
160         /**
161          * Sets the module hash for the given module name
162          */
163         public Builder hashForModule(String mn, byte[] hash) {
164             nameToHash.put(mn, hash);
165             return this;
166         }
</pre>
</td>
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.module;
 27 
 28 import java.io.IOException;
<span class="line-added"> 29 import java.io.InputStream;</span>
 30 import java.io.UncheckedIOException;
<span class="line-modified"> 31 import java.lang.module.ModuleReader;</span>
<span class="line-modified"> 32 import java.lang.module.ModuleReference;</span>
<span class="line-modified"> 33 import java.nio.charset.StandardCharsets;</span>
 34 import java.security.MessageDigest;
 35 import java.security.NoSuchAlgorithmException;
<span class="line-added"> 36 import java.util.Arrays;</span>
 37 import java.util.Collections;
 38 import java.util.HashMap;

 39 import java.util.Map;
 40 import java.util.Objects;
 41 import java.util.Set;
<span class="line-added"> 42 import java.util.TreeMap;</span>
<span class="line-added"> 43 import java.util.function.Supplier;</span>
 44 
 45 /**
 46  * The result of hashing the contents of a number of module artifacts.
 47  */
 48 
 49 public final class ModuleHashes {
 50 
 51     /**
 52      * A supplier of a message digest.
 53      */
 54     public static interface HashSupplier {
 55         byte[] generate(String algorithm);
 56     }
 57 
 58     private final String algorithm;
 59     private final Map&lt;String, byte[]&gt; nameToHash;
 60 
 61     /**
 62      * Creates a {@code ModuleHashes}.
 63      *
 64      * @param algorithm   the algorithm used to create the hashes
 65      * @param nameToHash  the map of module name to hash value
 66      */
<span class="line-modified"> 67     ModuleHashes(String algorithm, Map&lt;String, byte[]&gt; nameToHash) {</span>
<span class="line-modified"> 68         this.algorithm = Objects.requireNonNull(algorithm);</span>
 69         this.nameToHash = Collections.unmodifiableMap(nameToHash);
 70     }
 71 
 72     /**
 73      * Returns the algorithm used to hash the modules (&quot;SHA-256&quot; for example).
 74      */
 75     public String algorithm() {
 76         return algorithm;
 77     }
 78 
 79     /**
 80      * Returns the set of module names for which hashes are recorded.
 81      */
 82     public Set&lt;String&gt; names() {
 83         return nameToHash.keySet();
 84     }
 85 
 86     /**
 87      * Returns the hash for the given module name, {@code null}
 88      * if there is no hash recorded for the module.
 89      */
 90     public byte[] hashFor(String mn) {
 91         return nameToHash.get(mn);
 92     }
 93 
 94     /**
 95      * Returns unmodifiable map of module name to hash
 96      */
 97     public Map&lt;String, byte[]&gt; hashes() {
 98         return nameToHash;
 99     }
100 
101     /**
<span class="line-modified">102      * Computes a hash from the names and content of a module.</span>

103      *
<span class="line-added">104      * @param reader the module reader to access the module content</span>
<span class="line-added">105      * @param algorithm the name of the message digest algorithm to use</span>
<span class="line-added">106      * @return the hash</span>
<span class="line-added">107      * @throws IllegalArgumentException if digest algorithm is not supported</span>
108      * @throws UncheckedIOException if an I/O error occurs

109      */
<span class="line-modified">110     private static byte[] computeHash(ModuleReader reader, String algorithm) {</span>
<span class="line-added">111         MessageDigest md;</span>
112         try {
<span class="line-modified">113             md = MessageDigest.getInstance(algorithm);</span>
<span class="line-modified">114         } catch (NoSuchAlgorithmException e) {</span>
<span class="line-modified">115             throw new IllegalArgumentException(e);</span>
<span class="line-modified">116         }</span>
<span class="line-modified">117         try {</span>
<span class="line-modified">118             byte[] buf = new byte[32*1024];</span>
<span class="line-modified">119             reader.list().sorted().forEach(rn -&gt; {</span>
<span class="line-modified">120                 md.update(rn.getBytes(StandardCharsets.UTF_8));</span>
<span class="line-modified">121                 try (InputStream in = reader.open(rn).orElseThrow()) {</span>
<span class="line-modified">122                     int n;</span>
<span class="line-modified">123                     while ((n = in.read(buf)) &gt; 0) {</span>
<span class="line-added">124                         md.update(buf, 0, n);</span>
<span class="line-added">125                     }</span>
<span class="line-added">126                 } catch (IOException ioe) {</span>
<span class="line-added">127                     throw new UncheckedIOException(ioe);</span>
128                 }
<span class="line-modified">129             });</span>
<span class="line-added">130         } catch (IOException ioe) {</span>
<span class="line-added">131             throw new UncheckedIOException(ioe);</span>
<span class="line-added">132         }</span>
<span class="line-added">133         return md.digest();</span>
<span class="line-added">134     }</span>
135 
<span class="line-modified">136     /**</span>
<span class="line-modified">137      * Computes a hash from the names and content of a module.</span>
<span class="line-modified">138      *</span>
<span class="line-added">139      * @param supplier supplies the module reader to access the module content</span>
<span class="line-added">140      * @param algorithm the name of the message digest algorithm to use</span>
<span class="line-added">141      * @return the hash</span>
<span class="line-added">142      * @throws IllegalArgumentException if digest algorithm is not supported</span>
<span class="line-added">143      * @throws UncheckedIOException if an I/O error occurs</span>
<span class="line-added">144      */</span>
<span class="line-added">145     static byte[] computeHash(Supplier&lt;ModuleReader&gt; supplier, String algorithm) {</span>
<span class="line-added">146         try (ModuleReader reader = supplier.get()) {</span>
<span class="line-added">147             return computeHash(reader, algorithm);</span>
148         } catch (IOException ioe) {
149             throw new UncheckedIOException(ioe);
150         }
151     }
152 
153     /**
<span class="line-modified">154      * Computes the hash from the names and content of a set of modules. Returns</span>
<span class="line-modified">155      * a {@code ModuleHashes} to encapsulate the result.</span>


156      *
<span class="line-added">157      * @param mrefs the set of modules</span>
<span class="line-added">158      * @param algorithm the name of the message digest algorithm to use</span>
159      * @return ModuleHashes that encapsulates the hashes
<span class="line-added">160      * @throws IllegalArgumentException if digest algorithm is not supported</span>
<span class="line-added">161      * @throws UncheckedIOException if an I/O error occurs</span>
162      */
<span class="line-modified">163     static ModuleHashes generate(Set&lt;ModuleReference&gt; mrefs, String algorithm) {</span>
164         Map&lt;String, byte[]&gt; nameToHash = new TreeMap&lt;&gt;();
<span class="line-modified">165         for (ModuleReference mref : mrefs) {</span>
<span class="line-modified">166             try (ModuleReader reader = mref.open()) {</span>
<span class="line-modified">167                 byte[] hash = computeHash(reader, algorithm);</span>
<span class="line-modified">168                 nameToHash.put(mref.descriptor().name(), hash);</span>
<span class="line-added">169             } catch (IOException ioe) {</span>
<span class="line-added">170                 throw new UncheckedIOException(ioe);</span>
<span class="line-added">171             }</span>
172         }
173         return new ModuleHashes(algorithm, nameToHash);
174     }
175 
<span class="line-added">176     @Override</span>
<span class="line-added">177     public int hashCode() {</span>
<span class="line-added">178         int h = algorithm.hashCode();</span>
<span class="line-added">179         for (Map.Entry&lt;String, byte[]&gt; e : nameToHash.entrySet()) {</span>
<span class="line-added">180             h = h * 31 + e.getKey().hashCode();</span>
<span class="line-added">181             h = h * 31 + Arrays.hashCode(e.getValue());</span>
<span class="line-added">182         }</span>
<span class="line-added">183         return h;</span>
<span class="line-added">184     }</span>
<span class="line-added">185 </span>
<span class="line-added">186     @Override</span>
<span class="line-added">187     public boolean equals(Object obj) {</span>
<span class="line-added">188         if (!(obj instanceof ModuleHashes))</span>
<span class="line-added">189             return false;</span>
<span class="line-added">190         ModuleHashes other = (ModuleHashes) obj;</span>
<span class="line-added">191         if (!algorithm.equals(other.algorithm)</span>
<span class="line-added">192                 || nameToHash.size() != other.nameToHash.size())</span>
<span class="line-added">193             return false;</span>
<span class="line-added">194         for (Map.Entry&lt;String, byte[]&gt; e : nameToHash.entrySet()) {</span>
<span class="line-added">195             String name = e.getKey();</span>
<span class="line-added">196             byte[] hash = e.getValue();</span>
<span class="line-added">197             if (!Arrays.equals(hash, other.nameToHash.get(name)))</span>
<span class="line-added">198                 return false;</span>
<span class="line-added">199         }</span>
<span class="line-added">200         return true;</span>
<span class="line-added">201     }</span>
<span class="line-added">202 </span>
<span class="line-added">203     @Override</span>
<span class="line-added">204     public String toString() {</span>
<span class="line-added">205         StringBuilder sb = new StringBuilder(algorithm);</span>
<span class="line-added">206         sb.append(&quot; &quot;);</span>
<span class="line-added">207         nameToHash.entrySet()</span>
<span class="line-added">208                 .stream()</span>
<span class="line-added">209                 .sorted(Map.Entry.comparingByKey())</span>
<span class="line-added">210                 .forEach(e -&gt; {</span>
<span class="line-added">211                     sb.append(e.getKey());</span>
<span class="line-added">212                     sb.append(&quot;=&quot;);</span>
<span class="line-added">213                     byte[] ba = e.getValue();</span>
<span class="line-added">214                     for (byte b : ba) {</span>
<span class="line-added">215                         sb.append(String.format(&quot;%02x&quot;, b &amp; 0xff));</span>
<span class="line-added">216                     }</span>
<span class="line-added">217                 });</span>
<span class="line-added">218         return sb.toString();</span>
<span class="line-added">219     }</span>
<span class="line-added">220 </span>
221     /**
222      * This is used by jdk.internal.module.SystemModules class
223      * generated at link time.
224      */
225     public static class Builder {
226         final String algorithm;
227         final Map&lt;String, byte[]&gt; nameToHash;
228 
229         Builder(String algorithm, int initialCapacity) {
230             this.nameToHash = new HashMap&lt;&gt;(initialCapacity);
231             this.algorithm =  Objects.requireNonNull(algorithm);
232         }
233 
234         /**
235          * Sets the module hash for the given module name
236          */
237         public Builder hashForModule(String mn, byte[] hash) {
238             nameToHash.put(mn, hash);
239             return this;
240         }
</pre>
</td>
</tr>
</table>
<center><a href="../loader/ClassLoaders.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ModuleHashesBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
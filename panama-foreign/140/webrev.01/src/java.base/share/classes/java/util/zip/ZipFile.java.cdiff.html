<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipCoder.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/loader/ClassLoaders.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 90,11 ***</span>
   */
  public class ZipFile implements ZipConstants, Closeable {
  
      private final String name;     // zip file name
      private volatile boolean closeRequested;
<span class="line-removed">-     private final @Stable ZipCoder zc;</span>
  
      // The &quot;resource&quot; used by this zip file that needs to be
      // cleaned after use.
      // a) the input streams that need to be closed
      // b) the list of cached Inflater objects
<span class="line-new-header">--- 90,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,15 ***</span>
                  sm.checkDelete(name);
              }
          }
          Objects.requireNonNull(charset, &quot;charset&quot;);
  
<span class="line-removed">-         this.zc = ZipCoder.get(charset);</span>
          this.name = name;
          long t0 = System.nanoTime();
  
<span class="line-modified">!         this.res = new CleanableResource(this, file, mode);</span>
  
          PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
          PerfCounter.getZipFileCount().increment();
      }
  
<span class="line-new-header">--- 229,14 ---</span>
                  sm.checkDelete(name);
              }
          }
          Objects.requireNonNull(charset, &quot;charset&quot;);
  
          this.name = name;
          long t0 = System.nanoTime();
  
<span class="line-modified">!         this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);</span>
  
          PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
          PerfCounter.getZipFileCount().increment();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,11 ***</span>
          synchronized (this) {
              ensureOpen();
              if (res.zsrc.comment == null) {
                  return null;
              }
<span class="line-modified">!             return zc.toString(res.zsrc.comment);</span>
          }
      }
  
      /**
       * Returns the zip file entry for the specified name, or null
<span class="line-new-header">--- 303,11 ---</span>
          synchronized (this) {
              ensureOpen();
              if (res.zsrc.comment == null) {
                  return null;
              }
<span class="line-modified">!             return res.zsrc.zc.toString(res.zsrc.comment);</span>
          }
      }
  
      /**
       * Returns the zip file entry for the specified name, or null
</pre>
<hr />
<pre>
<span class="line-old-header">*** 336,22 ***</span>
      private ZipEntry getEntry(String name, Function&lt;String, ? extends ZipEntry&gt; func) {
          Objects.requireNonNull(name, &quot;name&quot;);
          ZipEntry entry = null;
          synchronized (this) {
              ensureOpen();
<span class="line-modified">!             byte[] bname = zc.getBytes(name);</span>
<span class="line-removed">-             int pos = res.zsrc.getEntryPos(bname, true);</span>
              if (pos != -1) {
<span class="line-modified">!                 entry = getZipEntry(name, bname, pos, func);</span>
<span class="line-removed">-             } else if (!zc.isUTF8() &amp;&amp; !name.isEmpty() &amp;&amp; !name.endsWith(&quot;/&quot;)) {</span>
<span class="line-removed">-                 // non-UTF-8 charsets need to lookup again with added slash</span>
<span class="line-removed">-                 name = name + &#39;/&#39;;</span>
<span class="line-removed">-                 bname = zc.getBytes(name);</span>
<span class="line-removed">-                 pos = res.zsrc.getEntryPos(bname, false);</span>
<span class="line-removed">-                 if (pos != -1) {</span>
<span class="line-removed">-                     entry = getZipEntry(name, bname, pos, func);</span>
<span class="line-removed">-                 }</span>
              }
          }
          return entry;
      }
  
<span class="line-new-header">--- 334,13 ---</span>
      private ZipEntry getEntry(String name, Function&lt;String, ? extends ZipEntry&gt; func) {
          Objects.requireNonNull(name, &quot;name&quot;);
          ZipEntry entry = null;
          synchronized (this) {
              ensureOpen();
<span class="line-modified">!             int pos = res.zsrc.getEntryPos(name, true);</span>
              if (pos != -1) {
<span class="line-modified">!                 entry = getZipEntry(name, pos, func);</span>
              }
          }
          return entry;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 369,22 ***</span>
       * @throws IOException if an I/O error has occurred
       * @throws IllegalStateException if the zip file has been closed
       */
      public InputStream getInputStream(ZipEntry entry) throws IOException {
          Objects.requireNonNull(entry, &quot;entry&quot;);
<span class="line-modified">!         int pos = -1;</span>
          ZipFileInputStream in;
          Source zsrc = res.zsrc;
          Set&lt;InputStream&gt; istreams = res.istreams;
          synchronized (this) {
              ensureOpen();
              if (Objects.equals(lastEntryName, entry.name)) {
                  pos = lastEntryPos;
<span class="line-removed">-             } else if (!zc.isUTF8() &amp;&amp; (entry.flag &amp; USE_UTF8) != 0) {</span>
<span class="line-removed">-                 pos = zsrc.getEntryPos(zc.getBytesUTF8(entry.name), false);</span>
              } else {
<span class="line-modified">!                 pos = zsrc.getEntryPos(zc.getBytes(entry.name), false);</span>
              }
              if (pos == -1) {
                  return null;
              }
              in = new ZipFileInputStream(zsrc.cen, pos);
<span class="line-new-header">--- 358,20 ---</span>
       * @throws IOException if an I/O error has occurred
       * @throws IllegalStateException if the zip file has been closed
       */
      public InputStream getInputStream(ZipEntry entry) throws IOException {
          Objects.requireNonNull(entry, &quot;entry&quot;);
<span class="line-modified">!         int pos;</span>
          ZipFileInputStream in;
          Source zsrc = res.zsrc;
          Set&lt;InputStream&gt; istreams = res.istreams;
          synchronized (this) {
              ensureOpen();
              if (Objects.equals(lastEntryName, entry.name)) {
                  pos = lastEntryPos;
              } else {
<span class="line-modified">!                 pos = zsrc.getEntryPos(entry.name, false);</span>
              }
              if (pos == -1) {
                  return null;
              }
              in = new ZipFileInputStream(zsrc.cen, pos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 526,11 ***</span>
                  ensureOpen();
                  if (!hasNext()) {
                      throw new NoSuchElementException();
                  }
                  // each &quot;entry&quot; has 3 ints in table entries
<span class="line-modified">!                 return (T)getZipEntry(null, null, res.zsrc.getEntryPos(i++ * 3), gen);</span>
              }
          }
  
          @Override
          public Iterator&lt;T&gt; asIterator() {
<span class="line-new-header">--- 513,11 ---</span>
                  ensureOpen();
                  if (!hasNext()) {
                      throw new NoSuchElementException();
                  }
                  // each &quot;entry&quot; has 3 ints in table entries
<span class="line-modified">!                 return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3), gen);</span>
              }
          }
  
          @Override
          public Iterator&lt;T&gt; asIterator() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 598,22 ***</span>
       */
      public Stream&lt;? extends ZipEntry&gt; stream() {
          synchronized (this) {
              ensureOpen();
              return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified">!                 pos -&gt; getZipEntry(null, null, pos, ZipEntry::new)), false);</span>
         }
      }
  
      private String getEntryName(int pos) {
          byte[] cen = res.zsrc.cen;
          int nlen = CENNAM(cen, pos);
<span class="line-modified">!         if (!zc.isUTF8() &amp;&amp; (CENFLG(cen, pos) &amp; USE_UTF8) != 0) {</span>
<span class="line-modified">!             return zc.toStringUTF8(cen, pos + CENHDR, nlen);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             return zc.toString(cen, pos + CENHDR, nlen);</span>
<span class="line-removed">-         }</span>
      }
  
      /*
       * Returns an ordered {@code Stream} over the zip file entry names.
       *
<span class="line-new-header">--- 585,19 ---</span>
       */
      public Stream&lt;? extends ZipEntry&gt; stream() {
          synchronized (this) {
              ensureOpen();
              return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified">!                 pos -&gt; getZipEntry(null, pos, ZipEntry::new)), false);</span>
         }
      }
  
      private String getEntryName(int pos) {
          byte[] cen = res.zsrc.cen;
          int nlen = CENNAM(cen, pos);
<span class="line-modified">!         ZipCoder zc = res.zsrc.zipCoderForPos(pos);</span>
<span class="line-modified">!         return zc.toString(cen, pos + CENHDR, nlen);</span>
      }
  
      /*
       * Returns an ordered {@code Stream} over the zip file entry names.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 645,38 ***</span>
       */
      private Stream&lt;JarEntry&gt; stream(Function&lt;String, JarEntry&gt; func) {
          synchronized (this) {
              ensureOpen();
              return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified">!                 pos -&gt; (JarEntry)getZipEntry(null, null, pos, func)), false);</span>
          }
      }
  
      private String lastEntryName;
      private int lastEntryPos;
  
<span class="line-modified">!     /* Checks ensureOpen() before invoke this method */</span>
<span class="line-modified">!     private ZipEntry getZipEntry(String name, byte[] bname, int pos,</span>
                                   Function&lt;String, ? extends ZipEntry&gt; func) {
          byte[] cen = res.zsrc.cen;
          int nlen = CENNAM(cen, pos);
          int elen = CENEXT(cen, pos);
          int clen = CENCOM(cen, pos);
<span class="line-modified">!         int flag = CENFLG(cen, pos);</span>
<span class="line-modified">!         if (name == null || bname.length != nlen) {</span>
<span class="line-modified">!             // to use the entry name stored in cen, if the passed in name is</span>
<span class="line-modified">!             // (1) null, invoked from iterator, or</span>
<span class="line-modified">!             // (2) not equal to the name stored, a slash is appended during</span>
<span class="line-modified">!             // getEntryPos() search.</span>
<span class="line-modified">!             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {</span>
<span class="line-modified">!                 name = zc.toStringUTF8(cen, pos + CENHDR, nlen);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 name = zc.toString(cen, pos + CENHDR, nlen);</span>
              }
          }
          ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
<span class="line-modified">!         e.flag = flag;</span>
          e.xdostime = CENTIM(cen, pos);
          e.crc = CENCRC(cen, pos);
          e.size = CENLEN(cen, pos);
          e.csize = CENSIZ(cen, pos);
          e.method = CENHOW(cen, pos);
<span class="line-new-header">--- 629,41 ---</span>
       */
      private Stream&lt;JarEntry&gt; stream(Function&lt;String, JarEntry&gt; func) {
          synchronized (this) {
              ensureOpen();
              return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified">!                 pos -&gt; (JarEntry)getZipEntry(null, pos, func)), false);</span>
          }
      }
  
      private String lastEntryName;
      private int lastEntryPos;
  
<span class="line-modified">!     /* Check ensureOpen() before invoking this method */</span>
<span class="line-modified">!     private ZipEntry getZipEntry(String name, int pos,</span>
                                   Function&lt;String, ? extends ZipEntry&gt; func) {
          byte[] cen = res.zsrc.cen;
          int nlen = CENNAM(cen, pos);
          int elen = CENEXT(cen, pos);
          int clen = CENCOM(cen, pos);
<span class="line-modified">! </span>
<span class="line-modified">!         ZipCoder zc = res.zsrc.zipCoderForPos(pos);</span>
<span class="line-modified">!         if (name != null) {</span>
<span class="line-modified">!             // only need to check for mismatch of trailing slash</span>
<span class="line-modified">!             if (nlen &gt; 0 &amp;&amp;</span>
<span class="line-modified">!                 !name.isEmpty() &amp;&amp;</span>
<span class="line-modified">!                 zc.hasTrailingSlash(cen, pos + CENHDR + nlen) &amp;&amp;</span>
<span class="line-modified">!                 !name.endsWith(&quot;/&quot;))</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 name += &#39;/&#39;;</span>
              }
<span class="line-added">+         } else {</span>
<span class="line-added">+             // invoked from iterator, use the entry name stored in cen</span>
<span class="line-added">+             name = zc.toString(cen, pos + CENHDR, nlen);</span>
          }
          ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
<span class="line-modified">!         e.flag = CENFLG(cen, pos);</span>
          e.xdostime = CENTIM(cen, pos);
          e.crc = CENCRC(cen, pos);
          e.size = CENLEN(cen, pos);
          e.csize = CENSIZ(cen, pos);
          e.method = CENHOW(cen, pos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 684,15 ***</span>
              int start = pos + CENHDR + nlen;
              e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
          }
          if (clen != 0) {
              int start = pos + CENHDR + nlen + elen;
<span class="line-modified">!             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {</span>
<span class="line-removed">-                 e.comment = zc.toStringUTF8(cen, start, clen);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 e.comment = zc.toString(cen, start, clen);</span>
<span class="line-removed">-             }</span>
          }
          lastEntryName = e.name;
          lastEntryPos = pos;
          return e;
      }
<span class="line-new-header">--- 671,11 ---</span>
              int start = pos + CENHDR + nlen;
              e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
          }
          if (clen != 0) {
              int start = pos + CENHDR + nlen + elen;
<span class="line-modified">!             e.comment = zc.toString(cen, start, clen);</span>
          }
          lastEntryName = e.name;
          lastEntryPos = pos;
          return e;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 719,15 ***</span>
  
          final Cleanable cleanable;
  
          Source zsrc;
  
<span class="line-modified">!         CleanableResource(ZipFile zf, File file, int mode) throws IOException {</span>
              this.cleanable = CleanerFactory.cleaner().register(zf, this);
              this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
              this.inflaterCache = new ArrayDeque&lt;&gt;();
<span class="line-modified">!             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0, zf.zc);</span>
          }
  
          void clean() {
              cleanable.clean();
          }
<span class="line-new-header">--- 702,15 ---</span>
  
          final Cleanable cleanable;
  
          Source zsrc;
  
<span class="line-modified">!         CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {</span>
              this.cleanable = CleanerFactory.cleaner().register(zf, this);
              this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
              this.inflaterCache = new ArrayDeque&lt;&gt;();
<span class="line-modified">!             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0, zc);</span>
          }
  
          void clean() {
              cleanable.clean();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1111,11 ***</span>
          // &quot;META-INF/&quot;.length()
          private static final int META_INF_LENGTH = 9;
          private static final int[] EMPTY_META_VERSIONS = new int[0];
  
          private final Key key;               // the key in files
<span class="line-modified">!         private final ZipCoder zc;           // zip coder used to decode/encode</span>
  
          private int refs = 1;
  
          private RandomAccessFile zfile;      // zfile of the underlying zip file
          private byte[] cen;                  // CEN &amp; ENDHDR
<span class="line-new-header">--- 1094,11 ---</span>
          // &quot;META-INF/&quot;.length()
          private static final int META_INF_LENGTH = 9;
          private static final int[] EMPTY_META_VERSIONS = new int[0];
  
          private final Key key;               // the key in files
<span class="line-modified">!         private final @Stable ZipCoder zc;   // zip coder used to decode/encode</span>
  
          private int refs = 1;
  
          private RandomAccessFile zfile;      // zfile of the underlying zip file
          private byte[] cen;                  // CEN &amp; ENDHDR
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1410,12 ***</span>
  
          // Reads zip file central directory.
          private void initCEN(int knownTotal) throws IOException {
              // Prefer locals for better performance during startup
              byte[] cen;
<span class="line-removed">-             ZipCoder zc = this.zc;</span>
<span class="line-removed">- </span>
              if (knownTotal == -1) {
                  End end = findEND();
                  if (end.endpos == 0) {
                      locpos = 0;
                      total = 0;
<span class="line-new-header">--- 1393,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1486,11 ***</span>
                  if (method != STORED &amp;&amp; method != DEFLATED)
                      zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
                  if (entryPos + nlen &gt; limit)
                      zerror(&quot;invalid CEN header (bad header size)&quot;);
                  // Record the CEN offset and the name hash in our hash cell.
<span class="line-modified">!                 hash = zc.hashN(cen, entryPos, nlen);</span>
                  hsh = (hash &amp; 0x7fffffff) % tablelen;
                  next = table[hsh];
                  table[hsh] = idx;
                  idx = addEntry(idx, hash, next, pos);
                  // Adds name to metanames.
<span class="line-new-header">--- 1467,11 ---</span>
                  if (method != STORED &amp;&amp; method != DEFLATED)
                      zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
                  if (entryPos + nlen &gt; limit)
                      zerror(&quot;invalid CEN header (bad header size)&quot;);
                  // Record the CEN offset and the name hash in our hash cell.
<span class="line-modified">!                 hash = zipCoderForPos(pos).normalizedHash(cen, entryPos, nlen);</span>
                  hsh = (hash &amp; 0x7fffffff) % tablelen;
                  next = table[hsh];
                  table[hsh] = idx;
                  idx = addEntry(idx, hash, next, pos);
                  // Adds name to metanames.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1542,55 ***</span>
  
          /*
           * Returns the {@code pos} of the zip cen entry corresponding to the
           * specified entry name, or -1 if not found.
           */
<span class="line-modified">!         private int getEntryPos(byte[] name, boolean addSlash) {</span>
              if (total == 0) {
                  return -1;
              }
<span class="line-modified">!             int hsh = zc.hashN(name, 0, name.length);</span>
              int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
  
              // Search down the target hash chain for a entry whose
              // 32 bit hash matches the hashed name.
              while (idx != ZIP_ENDCHAIN) {
                  if (getEntryHash(idx) == hsh) {
                      // The CEN name must match the specfied one
                      int pos = getEntryPos(idx);
<span class="line-modified">!                     byte[] cen = this.cen;</span>
<span class="line-modified">!                     final int nlen = CENNAM(cen, pos);</span>
<span class="line-modified">!                     int nameoff = pos + CENHDR;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // If addSlash is true and we&#39;re using the UTF-8 zip coder,</span>
<span class="line-modified">!                     // we&#39;ll directly test for name+/ in addition to name,</span>
<span class="line-modified">!                     // unless name is the empty string or already ends with a</span>
<span class="line-modified">!                     // slash</span>
<span class="line-modified">!                     if (name.length == nlen ||</span>
<span class="line-modified">!                            (addSlash &amp;&amp;</span>
<span class="line-modified">!                             zc.isUTF8() &amp;&amp;</span>
<span class="line-modified">!                             name.length &gt; 0 &amp;&amp;</span>
<span class="line-modified">!                             name.length + 1 == nlen &amp;&amp;</span>
<span class="line-modified">!                             cen[nameoff + nlen - 1] == &#39;/&#39; &amp;&amp;</span>
<span class="line-modified">!                             name[name.length - 1] != &#39;/&#39;)) {</span>
<span class="line-modified">!                         boolean matched = true;</span>
<span class="line-removed">-                         for (int i = 0; i &lt; name.length; i++) {</span>
<span class="line-removed">-                             if (name[i] != cen[nameoff++]) {</span>
<span class="line-removed">-                                 matched = false;</span>
<span class="line-removed">-                                 break;</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         if (matched) {</span>
<span class="line-removed">-                            return pos;</span>
                          }
                      }
                  }
                  idx = getEntryNext(idx);
              }
              return -1;
          }
  
          /**
           * Returns true if the bytes represent a non-directory name
           * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
           */
          private static boolean isMetaName(byte[] name, int off, int len) {
<span class="line-new-header">--- 1523,60 ---</span>
  
          /*
           * Returns the {@code pos} of the zip cen entry corresponding to the
           * specified entry name, or -1 if not found.
           */
<span class="line-modified">!         private int getEntryPos(String name, boolean addSlash) {</span>
              if (total == 0) {
                  return -1;
              }
<span class="line-modified">! </span>
<span class="line-added">+             int hsh = ZipCoder.normalizedHash(name);</span>
              int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
  
              // Search down the target hash chain for a entry whose
              // 32 bit hash matches the hashed name.
              while (idx != ZIP_ENDCHAIN) {
                  if (getEntryHash(idx) == hsh) {
                      // The CEN name must match the specfied one
                      int pos = getEntryPos(idx);
<span class="line-modified">! </span>
<span class="line-modified">!                     try {</span>
<span class="line-modified">!                         ZipCoder zc = zipCoderForPos(pos);</span>
<span class="line-modified">!                         String entry = zc.toString(cen, pos + CENHDR, CENNAM(cen, pos));</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         // If addSlash is true we&#39;ll test for name+/ in addition to</span>
<span class="line-modified">!                         // name, unless name is the empty string or already ends with a</span>
<span class="line-modified">!                         // slash</span>
<span class="line-modified">!                         int entryLen = entry.length();</span>
<span class="line-modified">!                         int nameLen = name.length();</span>
<span class="line-modified">!                         if ((entryLen == nameLen &amp;&amp; entry.equals(name)) ||</span>
<span class="line-modified">!                                 (addSlash &amp;&amp;</span>
<span class="line-modified">!                                 nameLen + 1 == entryLen &amp;&amp;</span>
<span class="line-modified">!                                 entry.startsWith(name) &amp;&amp;</span>
<span class="line-modified">!                                 entry.charAt(entryLen - 1) == &#39;/&#39;)) {</span>
<span class="line-modified">!                             return pos;</span>
                          }
<span class="line-added">+                     } catch (IllegalArgumentException iae) {</span>
<span class="line-added">+                         // Ignore</span>
                      }
                  }
                  idx = getEntryNext(idx);
              }
              return -1;
          }
  
<span class="line-added">+         private ZipCoder zipCoderForPos(int pos) {</span>
<span class="line-added">+             if (zc.isUTF8()) {</span>
<span class="line-added">+                 return zc;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if ((CENFLG(cen, pos) &amp; USE_UTF8) != 0) {</span>
<span class="line-added">+                 return ZipCoder.UTF8;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return zc;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          /**
           * Returns true if the bytes represent a non-directory name
           * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
           */
          private static boolean isMetaName(byte[] name, int off, int len) {
</pre>
<center><a href="ZipCoder.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/loader/ClassLoaders.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.zip;
  27 
  28 import java.io.Closeable;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.EOFException;
  32 import java.io.File;
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;
  37 import java.nio.file.InvalidPathException;
  38 import java.nio.file.attribute.BasicFileAttributes;
  39 import java.nio.file.Files;
  40 import java.util.ArrayDeque;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
  48 import java.util.Objects;
  49 import java.util.NoSuchElementException;
  50 import java.util.Set;
  51 import java.util.Spliterator;
  52 import java.util.Spliterators;
  53 import java.util.TreeSet;
  54 import java.util.WeakHashMap;
  55 import java.util.function.Consumer;
  56 import java.util.function.Function;
  57 import java.util.function.IntFunction;
  58 import java.util.jar.JarEntry;
  59 import java.util.jar.JarFile;
  60 import java.util.stream.Stream;
  61 import java.util.stream.StreamSupport;
  62 import jdk.internal.access.JavaUtilZipFileAccess;
  63 import jdk.internal.access.SharedSecrets;
  64 import jdk.internal.misc.VM;
  65 import jdk.internal.perf.PerfCounter;
  66 import jdk.internal.ref.CleanerFactory;
  67 import jdk.internal.vm.annotation.Stable;
  68 import sun.nio.cs.UTF_8;
  69 
  70 import static java.util.zip.ZipConstants64.*;
  71 import static java.util.zip.ZipUtils.*;
  72 
  73 /**
  74  * This class is used to read entries from a zip file.
  75  *
  76  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  77  * or method in this class will cause a {@link NullPointerException} to be
  78  * thrown.
  79  *
  80  * @apiNote
  81  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  82  * should be called explicitly or by try-with-resources. Subclasses are responsible
  83  * for the cleanup of resources acquired by the subclass. Subclasses that override
  84  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  85  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  86  * {@code finalize} method.
  87  *
  88  * @author      David Connelly
  89  * @since 1.1
  90  */
  91 public class ZipFile implements ZipConstants, Closeable {
  92 
  93     private final String name;     // zip file name
  94     private volatile boolean closeRequested;
<a name="1" id="anc1"></a><span class="line-removed">  95     private final @Stable ZipCoder zc;</span>
  96 
  97     // The &quot;resource&quot; used by this zip file that needs to be
  98     // cleaned after use.
  99     // a) the input streams that need to be closed
 100     // b) the list of cached Inflater objects
 101     // c) the &quot;native&quot; source of this zip file.
 102     private final @Stable CleanableResource res;
 103 
 104     private static final int STORED = ZipEntry.STORED;
 105     private static final int DEFLATED = ZipEntry.DEFLATED;
 106 
 107     /**
 108      * Mode flag to open a zip file for reading.
 109      */
 110     public static final int OPEN_READ = 0x1;
 111 
 112     /**
 113      * Mode flag to open a zip file and mark it for deletion.  The file will be
 114      * deleted some time between the moment that it is opened and the moment
 115      * that it is closed, but its contents will remain accessible via the
 116      * {@code ZipFile} object until either the close method is invoked or the
 117      * virtual machine exits.
 118      */
 119     public static final int OPEN_DELETE = 0x4;
 120 
 121     /**
 122      * Opens a zip file for reading.
 123      *
 124      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 125      * method is called with the {@code name} argument as its argument
 126      * to ensure the read is allowed.
 127      *
 128      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 129      * decode the entry names and comments.
 130      *
 131      * @param name the name of the zip file
 132      * @throws ZipException if a ZIP format error has occurred
 133      * @throws IOException if an I/O error has occurred
 134      * @throws SecurityException if a security manager exists and its
 135      *         {@code checkRead} method doesn&#39;t allow read access to the file.
 136      *
 137      * @see SecurityManager#checkRead(java.lang.String)
 138      */
 139     public ZipFile(String name) throws IOException {
 140         this(new File(name), OPEN_READ);
 141     }
 142 
 143     /**
 144      * Opens a new {@code ZipFile} to read from the specified
 145      * {@code File} object in the specified mode.  The mode argument
 146      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 147      *
 148      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 149      * method is called with the {@code name} argument as its argument to
 150      * ensure the read is allowed.
 151      *
 152      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 153      * decode the entry names and comments
 154      *
 155      * @param file the ZIP file to be opened for reading
 156      * @param mode the mode in which the file is to be opened
 157      * @throws ZipException if a ZIP format error has occurred
 158      * @throws IOException if an I/O error has occurred
 159      * @throws SecurityException if a security manager exists and
 160      *         its {@code checkRead} method
 161      *         doesn&#39;t allow read access to the file,
 162      *         or its {@code checkDelete} method doesn&#39;t allow deleting
 163      *         the file when the {@code OPEN_DELETE} flag is set.
 164      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 165      * @see SecurityManager#checkRead(java.lang.String)
 166      * @since 1.3
 167      */
 168     public ZipFile(File file, int mode) throws IOException {
 169         this(file, mode, UTF_8.INSTANCE);
 170     }
 171 
 172     /**
 173      * Opens a ZIP file for reading given the specified File object.
 174      *
 175      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 176      * decode the entry names and comments.
 177      *
 178      * @param file the ZIP file to be opened for reading
 179      * @throws ZipException if a ZIP format error has occurred
 180      * @throws IOException if an I/O error has occurred
 181      */
 182     public ZipFile(File file) throws ZipException, IOException {
 183         this(file, OPEN_READ);
 184     }
 185 
 186     /**
 187      * Opens a new {@code ZipFile} to read from the specified
 188      * {@code File} object in the specified mode.  The mode argument
 189      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 190      *
 191      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 192      * method is called with the {@code name} argument as its argument to
 193      * ensure the read is allowed.
 194      *
 195      * @param file the ZIP file to be opened for reading
 196      * @param mode the mode in which the file is to be opened
 197      * @param charset
 198      *        the {@linkplain java.nio.charset.Charset charset} to
 199      *        be used to decode the ZIP entry name and comment that are not
 200      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 201      *        purpose flag).
 202      *
 203      * @throws ZipException if a ZIP format error has occurred
 204      * @throws IOException if an I/O error has occurred
 205      *
 206      * @throws SecurityException
 207      *         if a security manager exists and its {@code checkRead}
 208      *         method doesn&#39;t allow read access to the file,or its
 209      *         {@code checkDelete} method doesn&#39;t allow deleting the
 210      *         file when the {@code OPEN_DELETE} flag is set
 211      *
 212      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 213      *
 214      * @see SecurityManager#checkRead(java.lang.String)
 215      *
 216      * @since 1.7
 217      */
 218     public ZipFile(File file, int mode, Charset charset) throws IOException
 219     {
 220         if (((mode &amp; OPEN_READ) == 0) ||
 221             ((mode &amp; ~(OPEN_READ | OPEN_DELETE)) != 0)) {
 222             throw new IllegalArgumentException(&quot;Illegal mode: 0x&quot;+
 223                                                Integer.toHexString(mode));
 224         }
 225         String name = file.getPath();
 226         SecurityManager sm = System.getSecurityManager();
 227         if (sm != null) {
 228             sm.checkRead(name);
 229             if ((mode &amp; OPEN_DELETE) != 0) {
 230                 sm.checkDelete(name);
 231             }
 232         }
 233         Objects.requireNonNull(charset, &quot;charset&quot;);
 234 
<a name="2" id="anc2"></a><span class="line-removed"> 235         this.zc = ZipCoder.get(charset);</span>
 236         this.name = name;
 237         long t0 = System.nanoTime();
 238 
<a name="3" id="anc3"></a><span class="line-modified"> 239         this.res = new CleanableResource(this, file, mode);</span>
 240 
 241         PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
 242         PerfCounter.getZipFileCount().increment();
 243     }
 244 
 245     /**
 246      * Opens a zip file for reading.
 247      *
 248      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 249      * method is called with the {@code name} argument as its argument
 250      * to ensure the read is allowed.
 251      *
 252      * @param name the name of the zip file
 253      * @param charset
 254      *        the {@linkplain java.nio.charset.Charset charset} to
 255      *        be used to decode the ZIP entry name and comment that are not
 256      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 257      *        purpose flag).
 258      *
 259      * @throws ZipException if a ZIP format error has occurred
 260      * @throws IOException if an I/O error has occurred
 261      * @throws SecurityException
 262      *         if a security manager exists and its {@code checkRead}
 263      *         method doesn&#39;t allow read access to the file
 264      *
 265      * @see SecurityManager#checkRead(java.lang.String)
 266      *
 267      * @since 1.7
 268      */
 269     public ZipFile(String name, Charset charset) throws IOException
 270     {
 271         this(new File(name), OPEN_READ, charset);
 272     }
 273 
 274     /**
 275      * Opens a ZIP file for reading given the specified File object.
 276      *
 277      * @param file the ZIP file to be opened for reading
 278      * @param charset
 279      *        The {@linkplain java.nio.charset.Charset charset} to be
 280      *        used to decode the ZIP entry name and comment (ignored if
 281      *        the &lt;a href=&quot;package-summary.html#lang_encoding&quot;&gt; language
 282      *        encoding bit&lt;/a&gt; of the ZIP entry&#39;s general purpose bit
 283      *        flag is set).
 284      *
 285      * @throws ZipException if a ZIP format error has occurred
 286      * @throws IOException if an I/O error has occurred
 287      *
 288      * @since 1.7
 289      */
 290     public ZipFile(File file, Charset charset) throws IOException
 291     {
 292         this(file, OPEN_READ, charset);
 293     }
 294 
 295     /**
 296      * Returns the zip file comment, or null if none.
 297      *
 298      * @return the comment string for the zip file, or null if none
 299      *
 300      * @throws IllegalStateException if the zip file has been closed
 301      *
 302      * @since 1.7
 303      */
 304     public String getComment() {
 305         synchronized (this) {
 306             ensureOpen();
 307             if (res.zsrc.comment == null) {
 308                 return null;
 309             }
<a name="4" id="anc4"></a><span class="line-modified"> 310             return zc.toString(res.zsrc.comment);</span>
 311         }
 312     }
 313 
 314     /**
 315      * Returns the zip file entry for the specified name, or null
 316      * if not found.
 317      *
 318      * @param name the name of the entry
 319      * @return the zip file entry, or null if not found
 320      * @throws IllegalStateException if the zip file has been closed
 321      */
 322     public ZipEntry getEntry(String name) {
 323         return getEntry(name, ZipEntry::new);
 324     }
 325 
 326     /*
 327      * Returns the zip file entry for the specified name, or null
 328      * if not found.
 329      *
 330      * @param name the name of the entry
 331      * @param func the function that creates the returned entry
 332      *
 333      * @return the zip file entry, or null if not found
 334      * @throws IllegalStateException if the zip file has been closed
 335      */
 336     private ZipEntry getEntry(String name, Function&lt;String, ? extends ZipEntry&gt; func) {
 337         Objects.requireNonNull(name, &quot;name&quot;);
 338         ZipEntry entry = null;
 339         synchronized (this) {
 340             ensureOpen();
<a name="5" id="anc5"></a><span class="line-modified"> 341             byte[] bname = zc.getBytes(name);</span>
<span class="line-removed"> 342             int pos = res.zsrc.getEntryPos(bname, true);</span>
 343             if (pos != -1) {
<a name="6" id="anc6"></a><span class="line-modified"> 344                 entry = getZipEntry(name, bname, pos, func);</span>
<span class="line-removed"> 345             } else if (!zc.isUTF8() &amp;&amp; !name.isEmpty() &amp;&amp; !name.endsWith(&quot;/&quot;)) {</span>
<span class="line-removed"> 346                 // non-UTF-8 charsets need to lookup again with added slash</span>
<span class="line-removed"> 347                 name = name + &#39;/&#39;;</span>
<span class="line-removed"> 348                 bname = zc.getBytes(name);</span>
<span class="line-removed"> 349                 pos = res.zsrc.getEntryPos(bname, false);</span>
<span class="line-removed"> 350                 if (pos != -1) {</span>
<span class="line-removed"> 351                     entry = getZipEntry(name, bname, pos, func);</span>
<span class="line-removed"> 352                 }</span>
 353             }
 354         }
 355         return entry;
 356     }
 357 
 358     /**
 359      * Returns an input stream for reading the contents of the specified
 360      * zip file entry.
 361      * &lt;p&gt;
 362      * Closing this ZIP file will, in turn, close all input streams that
 363      * have been returned by invocations of this method.
 364      *
 365      * @param entry the zip file entry
 366      * @return the input stream for reading the contents of the specified
 367      * zip file entry.
 368      * @throws ZipException if a ZIP format error has occurred
 369      * @throws IOException if an I/O error has occurred
 370      * @throws IllegalStateException if the zip file has been closed
 371      */
 372     public InputStream getInputStream(ZipEntry entry) throws IOException {
 373         Objects.requireNonNull(entry, &quot;entry&quot;);
<a name="7" id="anc7"></a><span class="line-modified"> 374         int pos = -1;</span>
 375         ZipFileInputStream in;
 376         Source zsrc = res.zsrc;
 377         Set&lt;InputStream&gt; istreams = res.istreams;
 378         synchronized (this) {
 379             ensureOpen();
 380             if (Objects.equals(lastEntryName, entry.name)) {
 381                 pos = lastEntryPos;
<a name="8" id="anc8"></a><span class="line-removed"> 382             } else if (!zc.isUTF8() &amp;&amp; (entry.flag &amp; USE_UTF8) != 0) {</span>
<span class="line-removed"> 383                 pos = zsrc.getEntryPos(zc.getBytesUTF8(entry.name), false);</span>
 384             } else {
<a name="9" id="anc9"></a><span class="line-modified"> 385                 pos = zsrc.getEntryPos(zc.getBytes(entry.name), false);</span>
 386             }
 387             if (pos == -1) {
 388                 return null;
 389             }
 390             in = new ZipFileInputStream(zsrc.cen, pos);
 391             switch (CENHOW(zsrc.cen, pos)) {
 392             case STORED:
 393                 synchronized (istreams) {
 394                     istreams.add(in);
 395                 }
 396                 return in;
 397             case DEFLATED:
 398                 // Inflater likes a bit of slack
 399                 // MORE: Compute good size for inflater stream:
 400                 long size = CENLEN(zsrc.cen, pos) + 2;
 401                 if (size &gt; 65536) {
 402                     size = 8192;
 403                 }
 404                 if (size &lt;= 0) {
 405                     size = 4096;
 406                 }
 407                 InputStream is = new ZipFileInflaterInputStream(in, res, (int)size);
 408                 synchronized (istreams) {
 409                     istreams.add(is);
 410                 }
 411                 return is;
 412             default:
 413                 throw new ZipException(&quot;invalid compression method&quot;);
 414             }
 415         }
 416     }
 417 
 418     private static class InflaterCleanupAction implements Runnable {
 419         private final Inflater inf;
 420         private final CleanableResource res;
 421 
 422         InflaterCleanupAction(Inflater inf, CleanableResource res) {
 423             this.inf = inf;
 424             this.res = res;
 425         }
 426 
 427         @Override
 428         public void run() {
 429             res.releaseInflater(inf);
 430         }
 431     }
 432 
 433     private class ZipFileInflaterInputStream extends InflaterInputStream {
 434         private volatile boolean closeRequested;
 435         private boolean eof = false;
 436         private final Cleanable cleanable;
 437 
 438         ZipFileInflaterInputStream(ZipFileInputStream zfin,
 439                                    CleanableResource res, int size) {
 440             this(zfin, res, res.getInflater(), size);
 441         }
 442 
 443         private ZipFileInflaterInputStream(ZipFileInputStream zfin,
 444                                            CleanableResource res,
 445                                            Inflater inf, int size) {
 446             super(zfin, inf, size);
 447             this.cleanable = CleanerFactory.cleaner().register(this,
 448                     new InflaterCleanupAction(inf, res));
 449         }
 450 
 451         public void close() throws IOException {
 452             if (closeRequested)
 453                 return;
 454             closeRequested = true;
 455             super.close();
 456             synchronized (res.istreams) {
 457                 res.istreams.remove(this);
 458             }
 459             cleanable.clean();
 460         }
 461 
 462         // Override fill() method to provide an extra &quot;dummy&quot; byte
 463         // at the end of the input stream. This is required when
 464         // using the &quot;nowrap&quot; Inflater option.
 465         protected void fill() throws IOException {
 466             if (eof) {
 467                 throw new EOFException(&quot;Unexpected end of ZLIB input stream&quot;);
 468             }
 469             len = in.read(buf, 0, buf.length);
 470             if (len == -1) {
 471                 buf[0] = 0;
 472                 len = 1;
 473                 eof = true;
 474             }
 475             inf.setInput(buf, 0, len);
 476         }
 477 
 478         public int available() throws IOException {
 479             if (closeRequested)
 480                 return 0;
 481             long avail = ((ZipFileInputStream)in).size() - inf.getBytesWritten();
 482             return (avail &gt; (long) Integer.MAX_VALUE ?
 483                     Integer.MAX_VALUE : (int) avail);
 484         }
 485     }
 486 
 487     /**
 488      * Returns the path name of the ZIP file.
 489      * @return the path name of the ZIP file
 490      */
 491     public String getName() {
 492         return name;
 493     }
 494 
 495     private class ZipEntryIterator&lt;T extends ZipEntry&gt;
 496             implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
 497 
 498         private int i = 0;
 499         private final int entryCount;
 500         private final Function&lt;String, T&gt; gen;
 501 
 502         public ZipEntryIterator(int entryCount, Function&lt;String, T&gt; gen) {
 503             this.entryCount = entryCount;
 504             this.gen = gen;
 505         }
 506 
 507         @Override
 508         public boolean hasMoreElements() {
 509             return hasNext();
 510         }
 511 
 512         @Override
 513         public boolean hasNext() {
 514             return i &lt; entryCount;
 515         }
 516 
 517         @Override
 518         public T nextElement() {
 519             return next();
 520         }
 521 
 522         @Override
 523         @SuppressWarnings(&quot;unchecked&quot;)
 524         public T next() {
 525             synchronized (ZipFile.this) {
 526                 ensureOpen();
 527                 if (!hasNext()) {
 528                     throw new NoSuchElementException();
 529                 }
 530                 // each &quot;entry&quot; has 3 ints in table entries
<a name="10" id="anc10"></a><span class="line-modified"> 531                 return (T)getZipEntry(null, null, res.zsrc.getEntryPos(i++ * 3), gen);</span>
 532             }
 533         }
 534 
 535         @Override
 536         public Iterator&lt;T&gt; asIterator() {
 537             return this;
 538         }
 539     }
 540 
 541     /**
 542      * Returns an enumeration of the ZIP file entries.
 543      * @return an enumeration of the ZIP file entries
 544      * @throws IllegalStateException if the zip file has been closed
 545      */
 546     public Enumeration&lt;? extends ZipEntry&gt; entries() {
 547         synchronized (this) {
 548             ensureOpen();
 549             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total, ZipEntry::new);
 550         }
 551     }
 552 
 553     private Enumeration&lt;JarEntry&gt; entries(Function&lt;String, JarEntry&gt; func) {
 554         synchronized (this) {
 555             ensureOpen();
 556             return new ZipEntryIterator&lt;JarEntry&gt;(res.zsrc.total, func);
 557         }
 558     }
 559 
 560     private class EntrySpliterator&lt;T&gt; extends Spliterators.AbstractSpliterator&lt;T&gt; {
 561         private int index;
 562         private final int fence;
 563         private final IntFunction&lt;T&gt; gen;
 564 
 565         EntrySpliterator(int index, int fence, IntFunction&lt;T&gt; gen) {
 566             super((long)fence,
 567                   Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE |
 568                   Spliterator.NONNULL);
 569             this.index = index;
 570             this.fence = fence;
 571             this.gen = gen;
 572         }
 573 
 574         @Override
 575         public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
 576             if (action == null)
 577                 throw new NullPointerException();
 578             if (index &gt;= 0 &amp;&amp; index &lt; fence) {
 579                 synchronized (ZipFile.this) {
 580                     ensureOpen();
 581                     action.accept(gen.apply(res.zsrc.getEntryPos(index++ * 3)));
 582                 }
 583                 return true;
 584             }
 585             return false;
 586         }
 587     }
 588 
 589     /**
 590      * Returns an ordered {@code Stream} over the ZIP file entries.
 591      *
 592      * Entries appear in the {@code Stream} in the order they appear in
 593      * the central directory of the ZIP file.
 594      *
 595      * @return an ordered {@code Stream} of entries in this ZIP file
 596      * @throws IllegalStateException if the zip file has been closed
 597      * @since 1.8
 598      */
 599     public Stream&lt;? extends ZipEntry&gt; stream() {
 600         synchronized (this) {
 601             ensureOpen();
 602             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<a name="11" id="anc11"></a><span class="line-modified"> 603                 pos -&gt; getZipEntry(null, null, pos, ZipEntry::new)), false);</span>
 604        }
 605     }
 606 
 607     private String getEntryName(int pos) {
 608         byte[] cen = res.zsrc.cen;
 609         int nlen = CENNAM(cen, pos);
<a name="12" id="anc12"></a><span class="line-modified"> 610         if (!zc.isUTF8() &amp;&amp; (CENFLG(cen, pos) &amp; USE_UTF8) != 0) {</span>
<span class="line-modified"> 611             return zc.toStringUTF8(cen, pos + CENHDR, nlen);</span>
<span class="line-removed"> 612         } else {</span>
<span class="line-removed"> 613             return zc.toString(cen, pos + CENHDR, nlen);</span>
<span class="line-removed"> 614         }</span>
 615     }
 616 
 617     /*
 618      * Returns an ordered {@code Stream} over the zip file entry names.
 619      *
 620      * Entry names appear in the {@code Stream} in the order they appear in
 621      * the central directory of the ZIP file.
 622      *
 623      * @return an ordered {@code Stream} of entry names in this zip file
 624      * @throws IllegalStateException if the zip file has been closed
 625      * @since 10
 626      */
 627     private Stream&lt;String&gt; entryNameStream() {
 628         synchronized (this) {
 629             ensureOpen();
 630             return StreamSupport.stream(
 631                 new EntrySpliterator&lt;&gt;(0, res.zsrc.total, this::getEntryName), false);
 632         }
 633     }
 634 
 635     /*
 636      * Returns an ordered {@code Stream} over the zip file entries.
 637      *
 638      * Entries appear in the {@code Stream} in the order they appear in
 639      * the central directory of the jar file.
 640      *
 641      * @param func the function that creates the returned entry
 642      * @return an ordered {@code Stream} of entries in this zip file
 643      * @throws IllegalStateException if the zip file has been closed
 644      * @since 10
 645      */
 646     private Stream&lt;JarEntry&gt; stream(Function&lt;String, JarEntry&gt; func) {
 647         synchronized (this) {
 648             ensureOpen();
 649             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<a name="13" id="anc13"></a><span class="line-modified"> 650                 pos -&gt; (JarEntry)getZipEntry(null, null, pos, func)), false);</span>
 651         }
 652     }
 653 
 654     private String lastEntryName;
 655     private int lastEntryPos;
 656 
<a name="14" id="anc14"></a><span class="line-modified"> 657     /* Checks ensureOpen() before invoke this method */</span>
<span class="line-modified"> 658     private ZipEntry getZipEntry(String name, byte[] bname, int pos,</span>
 659                                  Function&lt;String, ? extends ZipEntry&gt; func) {
 660         byte[] cen = res.zsrc.cen;
 661         int nlen = CENNAM(cen, pos);
 662         int elen = CENEXT(cen, pos);
 663         int clen = CENCOM(cen, pos);
<a name="15" id="anc15"></a><span class="line-modified"> 664         int flag = CENFLG(cen, pos);</span>
<span class="line-modified"> 665         if (name == null || bname.length != nlen) {</span>
<span class="line-modified"> 666             // to use the entry name stored in cen, if the passed in name is</span>
<span class="line-modified"> 667             // (1) null, invoked from iterator, or</span>
<span class="line-modified"> 668             // (2) not equal to the name stored, a slash is appended during</span>
<span class="line-modified"> 669             // getEntryPos() search.</span>
<span class="line-modified"> 670             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {</span>
<span class="line-modified"> 671                 name = zc.toStringUTF8(cen, pos + CENHDR, nlen);</span>
<span class="line-modified"> 672             } else {</span>
<span class="line-modified"> 673                 name = zc.toString(cen, pos + CENHDR, nlen);</span>
 674             }
<a name="16" id="anc16"></a>


 675         }
 676         ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
<a name="17" id="anc17"></a><span class="line-modified"> 677         e.flag = flag;</span>
 678         e.xdostime = CENTIM(cen, pos);
 679         e.crc = CENCRC(cen, pos);
 680         e.size = CENLEN(cen, pos);
 681         e.csize = CENSIZ(cen, pos);
 682         e.method = CENHOW(cen, pos);
 683         if (elen != 0) {
 684             int start = pos + CENHDR + nlen;
 685             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
 686         }
 687         if (clen != 0) {
 688             int start = pos + CENHDR + nlen + elen;
<a name="18" id="anc18"></a><span class="line-modified"> 689             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {</span>
<span class="line-removed"> 690                 e.comment = zc.toStringUTF8(cen, start, clen);</span>
<span class="line-removed"> 691             } else {</span>
<span class="line-removed"> 692                 e.comment = zc.toString(cen, start, clen);</span>
<span class="line-removed"> 693             }</span>
 694         }
 695         lastEntryName = e.name;
 696         lastEntryPos = pos;
 697         return e;
 698     }
 699 
 700     /**
 701      * Returns the number of entries in the ZIP file.
 702      *
 703      * @return the number of entries in the ZIP file
 704      * @throws IllegalStateException if the zip file has been closed
 705      */
 706     public int size() {
 707         synchronized (this) {
 708             ensureOpen();
 709             return res.zsrc.total;
 710         }
 711     }
 712 
 713     private static class CleanableResource implements Runnable {
 714         // The outstanding inputstreams that need to be closed
 715         final Set&lt;InputStream&gt; istreams;
 716 
 717         // List of cached Inflater objects for decompression
 718         Deque&lt;Inflater&gt; inflaterCache;
 719 
 720         final Cleanable cleanable;
 721 
 722         Source zsrc;
 723 
<a name="19" id="anc19"></a><span class="line-modified"> 724         CleanableResource(ZipFile zf, File file, int mode) throws IOException {</span>
 725             this.cleanable = CleanerFactory.cleaner().register(zf, this);
 726             this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
 727             this.inflaterCache = new ArrayDeque&lt;&gt;();
<a name="20" id="anc20"></a><span class="line-modified"> 728             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0, zf.zc);</span>
 729         }
 730 
 731         void clean() {
 732             cleanable.clean();
 733         }
 734 
 735         /*
 736          * Gets an inflater from the list of available inflaters or allocates
 737          * a new one.
 738          */
 739         Inflater getInflater() {
 740             Inflater inf;
 741             synchronized (inflaterCache) {
 742                 if ((inf = inflaterCache.poll()) != null) {
 743                     return inf;
 744                 }
 745             }
 746             return new Inflater(true);
 747         }
 748 
 749         /*
 750          * Releases the specified inflater to the list of available inflaters.
 751          */
 752         void releaseInflater(Inflater inf) {
 753             Deque&lt;Inflater&gt; inflaters = this.inflaterCache;
 754             if (inflaters != null) {
 755                 synchronized (inflaters) {
 756                     // double checked!
 757                     if (inflaters == this.inflaterCache) {
 758                         inf.reset();
 759                         inflaters.add(inf);
 760                         return;
 761                     }
 762                 }
 763             }
 764             // inflaters cache already closed - just end it.
 765             inf.end();
 766         }
 767 
 768         public void run() {
 769             IOException ioe = null;
 770 
 771             // Release cached inflaters and close the cache first
 772             Deque&lt;Inflater&gt; inflaters = this.inflaterCache;
 773             if (inflaters != null) {
 774                 synchronized (inflaters) {
 775                     // no need to double-check as only one thread gets a
 776                     // chance to execute run() (Cleaner guarantee)...
 777                     Inflater inf;
 778                     while ((inf = inflaters.poll()) != null) {
 779                         inf.end();
 780                     }
 781                     // close inflaters cache
 782                     this.inflaterCache = null;
 783                 }
 784             }
 785 
 786             // Close streams, release their inflaters
 787             if (istreams != null) {
 788                 synchronized (istreams) {
 789                     if (!istreams.isEmpty()) {
 790                         InputStream[] copy = istreams.toArray(new InputStream[0]);
 791                         istreams.clear();
 792                         for (InputStream is : copy) {
 793                             try {
 794                                 is.close();
 795                             } catch (IOException e) {
 796                                 if (ioe == null) ioe = e;
 797                                 else ioe.addSuppressed(e);
 798                             }
 799                         }
 800                     }
 801                 }
 802             }
 803 
 804             // Release zip src
 805             if (zsrc != null) {
 806                 synchronized (zsrc) {
 807                     try {
 808                         Source.release(zsrc);
 809                         zsrc = null;
 810                     } catch (IOException e) {
 811                         if (ioe == null) ioe = e;
 812                         else ioe.addSuppressed(e);
 813                     }
 814                 }
 815             }
 816             if (ioe != null) {
 817                 throw new UncheckedIOException(ioe);
 818             }
 819         }
 820 
 821     }
 822 
 823     /**
 824      * Closes the ZIP file.
 825      *
 826      * &lt;p&gt; Closing this ZIP file will close all of the input streams
 827      * previously returned by invocations of the {@link #getInputStream
 828      * getInputStream} method.
 829      *
 830      * @throws IOException if an I/O error has occurred
 831      */
 832     public void close() throws IOException {
 833         if (closeRequested) {
 834             return;
 835         }
 836         closeRequested = true;
 837 
 838         synchronized (this) {
 839             // Close streams, release their inflaters, release cached inflaters
 840             // and release zip source
 841             try {
 842                 res.clean();
 843             } catch (UncheckedIOException ioe) {
 844                 throw ioe.getCause();
 845             }
 846         }
 847     }
 848 
 849     private void ensureOpen() {
 850         if (closeRequested) {
 851             throw new IllegalStateException(&quot;zip file closed&quot;);
 852         }
 853         if (res.zsrc == null) {
 854             throw new IllegalStateException(&quot;The object is not initialized.&quot;);
 855         }
 856     }
 857 
 858     private void ensureOpenOrZipException() throws IOException {
 859         if (closeRequested) {
 860             throw new ZipException(&quot;ZipFile closed&quot;);
 861         }
 862     }
 863 
 864     /*
 865      * Inner class implementing the input stream used to read a
 866      * (possibly compressed) zip file entry.
 867      */
 868     private class ZipFileInputStream extends InputStream {
 869         private volatile boolean closeRequested;
 870         private   long pos;     // current position within entry data
 871         private   long startingPos; // Start position for the entry data
 872         protected long rem;     // number of remaining bytes within entry
 873         protected long size;    // uncompressed size of this entry
 874 
 875         ZipFileInputStream(byte[] cen, int cenpos) {
 876             rem = CENSIZ(cen, cenpos);
 877             size = CENLEN(cen, cenpos);
 878             pos = CENOFF(cen, cenpos);
 879             // zip64
 880             if (rem == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||
 881                 pos == ZIP64_MAGICVAL) {
 882                 checkZIP64(cen, cenpos);
 883             }
 884             // negative for lazy initialization, see getDataOffset();
 885             pos = - (pos + ZipFile.this.res.zsrc.locpos);
 886         }
 887 
 888         private void checkZIP64(byte[] cen, int cenpos) {
 889             int off = cenpos + CENHDR + CENNAM(cen, cenpos);
 890             int end = off + CENEXT(cen, cenpos);
 891             while (off + 4 &lt; end) {
 892                 int tag = get16(cen, off);
 893                 int sz = get16(cen, off + 2);
 894                 off += 4;
 895                 if (off + sz &gt; end)         // invalid data
 896                     break;
 897                 if (tag == EXTID_ZIP64) {
 898                     if (size == ZIP64_MAGICVAL) {
 899                         if (sz &lt; 8 || (off + 8) &gt; end)
 900                             break;
 901                         size = get64(cen, off);
 902                         sz -= 8;
 903                         off += 8;
 904                     }
 905                     if (rem == ZIP64_MAGICVAL) {
 906                         if (sz &lt; 8 || (off + 8) &gt; end)
 907                             break;
 908                         rem = get64(cen, off);
 909                         sz -= 8;
 910                         off += 8;
 911                     }
 912                     if (pos == ZIP64_MAGICVAL) {
 913                         if (sz &lt; 8 || (off + 8) &gt; end)
 914                             break;
 915                         pos = get64(cen, off);
 916                         sz -= 8;
 917                         off += 8;
 918                     }
 919                     break;
 920                 }
 921                 off += sz;
 922             }
 923         }
 924 
 925         /*
 926          * The Zip file spec explicitly allows the LOC extra data size to
 927          * be different from the CEN extra data size. Since we cannot trust
 928          * the CEN extra data size, we need to read the LOC to determine
 929          * the entry data offset.
 930          */
 931         private long initDataOffset() throws IOException {
 932             if (pos &lt;= 0) {
 933                 byte[] loc = new byte[LOCHDR];
 934                 pos = -pos;
 935                 int len = ZipFile.this.res.zsrc.readFullyAt(loc, 0, loc.length, pos);
 936                 if (len != LOCHDR) {
 937                     throw new ZipException(&quot;ZipFile error reading zip file&quot;);
 938                 }
 939                 if (LOCSIG(loc) != LOCSIG) {
 940                     throw new ZipException(&quot;ZipFile invalid LOC header (bad signature)&quot;);
 941                 }
 942                 pos += LOCHDR + LOCNAM(loc) + LOCEXT(loc);
 943                 startingPos = pos; // Save starting position for the entry
 944             }
 945             return pos;
 946         }
 947 
 948         public int read(byte b[], int off, int len) throws IOException {
 949             synchronized (ZipFile.this) {
 950                 ensureOpenOrZipException();
 951                 initDataOffset();
 952                 if (rem == 0) {
 953                     return -1;
 954                 }
 955                 if (len &gt; rem) {
 956                     len = (int) rem;
 957                 }
 958                 if (len &lt;= 0) {
 959                     return 0;
 960                 }
 961                 len = ZipFile.this.res.zsrc.readAt(b, off, len, pos);
 962                 if (len &gt; 0) {
 963                     pos += len;
 964                     rem -= len;
 965                 }
 966             }
 967             if (rem == 0) {
 968                 close();
 969             }
 970             return len;
 971         }
 972 
 973         public int read() throws IOException {
 974             byte[] b = new byte[1];
 975             if (read(b, 0, 1) == 1) {
 976                 return b[0] &amp; 0xff;
 977             } else {
 978                 return -1;
 979             }
 980         }
 981 
 982         public long skip(long n) throws IOException {
 983             synchronized (ZipFile.this) {
 984                 initDataOffset();
 985                 long newPos = pos + n;
 986                 if (n &gt; 0) {
 987                     // If we overflowed adding the skip value or are moving
 988                     // past EOF, set the skip value to number of bytes remaining
 989                     // to reach EOF
 990                     if (newPos &lt; 0 || n &gt; rem) {
 991                         n = rem;
 992                     }
 993                 } else if (newPos &lt; startingPos) {
 994                     // Tried to position before BOF so set position to the
 995                     // BOF and return the number of bytes we moved backwards
 996                     // to reach BOF
 997                     n = startingPos - pos;
 998                 }
 999                 pos += n;
1000                 rem -= n;
1001             }
1002             if (rem == 0) {
1003                 close();
1004             }
1005             return n;
1006         }
1007 
1008         public int available() {
1009             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
1010         }
1011 
1012         public long size() {
1013             return size;
1014         }
1015 
1016         public void close() {
1017             if (closeRequested) {
1018                 return;
1019             }
1020             closeRequested = true;
1021             rem = 0;
1022             synchronized (res.istreams) {
1023                 res.istreams.remove(this);
1024             }
1025         }
1026 
1027     }
1028 
1029     /**
1030      * Returns the names of all non-directory entries that begin with
1031      * &quot;META-INF/&quot; (case ignored). This method is used in JarFile, via
1032      * SharedSecrets, as an optimization when looking up manifest and
1033      * signature file entries. Returns null if no entries were found.
1034      */
1035     private String[] getMetaInfEntryNames() {
1036         synchronized (this) {
1037             ensureOpen();
1038             Source zsrc = res.zsrc;
1039             if (zsrc.metanames == null) {
1040                 return null;
1041             }
1042             String[] names = new String[zsrc.metanames.length];
1043             byte[] cen = zsrc.cen;
1044             for (int i = 0; i &lt; names.length; i++) {
1045                 int pos = zsrc.metanames[i];
1046                 // This will only be invoked on JarFile, which is guaranteed
1047                 // to use (or be compatible with) UTF-8 encoding.
1048                 names[i] = new String(cen, pos + CENHDR, CENNAM(cen, pos),
1049                                       UTF_8.INSTANCE);
1050             }
1051             return names;
1052         }
1053     }
1054 
1055     /**
1056      * Returns the versions for which there exists a non-directory
1057      * entry that begin with &quot;META-INF/versions/&quot; (case ignored).
1058      * This method is used in JarFile, via SharedSecrets, as an
1059      * optimization when looking up potentially versioned entries.
1060      * Returns an empty array if no versioned entries exist.
1061      */
1062     private int[] getMetaInfVersions() {
1063         synchronized (this) {
1064             ensureOpen();
1065             return res.zsrc.metaVersions;
1066         }
1067     }
1068 
1069     private static boolean isWindows;
1070 
1071     static {
1072         SharedSecrets.setJavaUtilZipFileAccess(
1073             new JavaUtilZipFileAccess() {
1074                 @Override
1075                 public boolean startsWithLocHeader(ZipFile zip) {
1076                     return zip.res.zsrc.startsWithLoc;
1077                 }
1078                 @Override
1079                 public String[] getMetaInfEntryNames(JarFile jar) {
1080                     return ((ZipFile)jar).getMetaInfEntryNames();
1081                 }
1082                 @Override
1083                 public int[] getMetaInfVersions(JarFile jar) {
1084                     return ((ZipFile)jar).getMetaInfVersions();
1085                 }
1086                 @Override
1087                 public JarEntry getEntry(ZipFile zip, String name,
1088                     Function&lt;String, JarEntry&gt; func) {
1089                     return (JarEntry)zip.getEntry(name, func);
1090                 }
1091                 @Override
1092                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip,
1093                     Function&lt;String, JarEntry&gt; func) {
1094                     return zip.entries(func);
1095                 }
1096                 @Override
1097                 public Stream&lt;JarEntry&gt; stream(ZipFile zip,
1098                     Function&lt;String, JarEntry&gt; func) {
1099                     return zip.stream(func);
1100                 }
1101                 @Override
1102                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1103                     return zip.entryNameStream();
1104                 }
1105              }
1106         );
1107         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1108     }
1109 
1110     private static class Source {
1111         // &quot;META-INF/&quot;.length()
1112         private static final int META_INF_LENGTH = 9;
1113         private static final int[] EMPTY_META_VERSIONS = new int[0];
1114 
1115         private final Key key;               // the key in files
<a name="21" id="anc21"></a><span class="line-modified">1116         private final ZipCoder zc;           // zip coder used to decode/encode</span>
1117 
1118         private int refs = 1;
1119 
1120         private RandomAccessFile zfile;      // zfile of the underlying zip file
1121         private byte[] cen;                  // CEN &amp; ENDHDR
1122         private long locpos;                 // position of first LOC header (usually 0)
1123         private byte[] comment;              // zip file comment
1124                                              // list of meta entries in META-INF dir
1125         private int[] metanames;
1126         private int[] metaVersions;          // list of unique versions found in META-INF/versions/
1127         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1128 
1129         // A Hashmap for all entries.
1130         //
1131         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1132         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1133         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1134         // entry name and its offset {@code pos} in the central directory hdeader.
1135         //
1136         // private static class Entry {
1137         //     int hash;       // 32 bit hashcode on name
1138         //     int next;       // hash chain: index into entries
1139         //     int pos;        // Offset of central directory file header
1140         // }
1141         // private Entry[] entries;             // array of hashed cen entry
1142         //
1143         // To reduce the total size of entries further, we use a int[] here to store 3 &quot;int&quot;
1144         // {@code hash}, {@code next and {@code &quot;pos for each entry. The entry can then be
1145         // referred by their index of their positions in the {@code entries}.
1146         //
1147         private int[] entries;                  // array of hashed cen entry
1148         private int addEntry(int index, int hash, int next, int pos) {
1149             entries[index++] = hash;
1150             entries[index++] = next;
1151             entries[index++] = pos;
1152             return index;
1153         }
1154         private int getEntryHash(int index) { return entries[index]; }
1155         private int getEntryNext(int index) { return entries[index + 1]; }
1156         private int getEntryPos(int index)  { return entries[index + 2]; }
1157         private static final int ZIP_ENDCHAIN  = -1;
1158         private int total;                   // total number of entries
1159         private int[] table;                 // Hash chain heads: indexes into entries
1160         private int tablelen;                // number of hash heads
1161 
1162         private static class Key {
1163             final BasicFileAttributes attrs;
1164             File file;
1165             final boolean utf8;
1166 
1167             public Key(File file, BasicFileAttributes attrs, ZipCoder zc) {
1168                 this.attrs = attrs;
1169                 this.file = file;
1170                 this.utf8 = zc.isUTF8();
1171             }
1172 
1173             public int hashCode() {
1174                 long t = utf8 ? 0 : Long.MAX_VALUE;
1175                 t += attrs.lastModifiedTime().toMillis();
1176                 return ((int)(t ^ (t &gt;&gt;&gt; 32))) + file.hashCode();
1177             }
1178 
1179             public boolean equals(Object obj) {
1180                 if (obj instanceof Key) {
1181                     Key key = (Key)obj;
1182                     if (key.utf8 != utf8) {
1183                         return false;
1184                     }
1185                     if (!attrs.lastModifiedTime().equals(key.attrs.lastModifiedTime())) {
1186                         return false;
1187                     }
1188                     Object fk = attrs.fileKey();
1189                     if (fk != null) {
1190                         return fk.equals(key.attrs.fileKey());
1191                     } else {
1192                         return file.equals(key.file);
1193                     }
1194                 }
1195                 return false;
1196             }
1197         }
1198         private static final HashMap&lt;Key, Source&gt; files = new HashMap&lt;&gt;();
1199 
1200 
1201         static Source get(File file, boolean toDelete, ZipCoder zc) throws IOException {
1202             final Key key;
1203             try {
1204                 key = new Key(file,
1205                         Files.readAttributes(file.toPath(), BasicFileAttributes.class),
1206                         zc);
1207             } catch (InvalidPathException ipe) {
1208                 throw new IOException(ipe);
1209             }
1210             Source src;
1211             synchronized (files) {
1212                 src = files.get(key);
1213                 if (src != null) {
1214                     src.refs++;
1215                     return src;
1216                 }
1217             }
1218             src = new Source(key, toDelete, zc);
1219 
1220             synchronized (files) {
1221                 if (files.containsKey(key)) {    // someone else put in first
1222                     src.close();                 // close the newly created one
1223                     src = files.get(key);
1224                     src.refs++;
1225                     return src;
1226                 }
1227                 files.put(key, src);
1228                 return src;
1229             }
1230         }
1231 
1232         static void release(Source src) throws IOException {
1233             synchronized (files) {
1234                 if (src != null &amp;&amp; --src.refs == 0) {
1235                     files.remove(src.key);
1236                     src.close();
1237                 }
1238             }
1239         }
1240 
1241         private Source(Key key, boolean toDelete, ZipCoder zc) throws IOException {
1242             this.zc = zc;
1243             this.key = key;
1244             if (toDelete) {
1245                 if (isWindows) {
1246                     this.zfile = SharedSecrets.getJavaIORandomAccessFileAccess()
1247                                               .openAndDelete(key.file, &quot;r&quot;);
1248                 } else {
1249                     this.zfile = new RandomAccessFile(key.file, &quot;r&quot;);
1250                     key.file.delete();
1251                 }
1252             } else {
1253                 this.zfile = new RandomAccessFile(key.file, &quot;r&quot;);
1254             }
1255             try {
1256                 initCEN(-1);
1257                 byte[] buf = new byte[4];
1258                 readFullyAt(buf, 0, 4, 0);
1259                 this.startsWithLoc = (LOCSIG(buf) == LOCSIG);
1260             } catch (IOException x) {
1261                 try {
1262                     this.zfile.close();
1263                 } catch (IOException xx) {}
1264                 throw x;
1265             }
1266         }
1267 
1268         private void close() throws IOException {
1269             zfile.close();
1270             zfile = null;
1271             cen = null;
1272             entries = null;
1273             table = null;
1274             metanames = null;
1275             metaVersions = EMPTY_META_VERSIONS;
1276         }
1277 
1278         private static final int BUF_SIZE = 8192;
1279         private final int readFullyAt(byte[] buf, int off, int len, long pos)
1280             throws IOException
1281         {
1282             synchronized (zfile) {
1283                 zfile.seek(pos);
1284                 int N = len;
1285                 while (N &gt; 0) {
1286                     int n = Math.min(BUF_SIZE, N);
1287                     zfile.readFully(buf, off, n);
1288                     off += n;
1289                     N -= n;
1290                 }
1291                 return len;
1292             }
1293         }
1294 
1295         private final int readAt(byte[] buf, int off, int len, long pos)
1296             throws IOException
1297         {
1298             synchronized (zfile) {
1299                 zfile.seek(pos);
1300                 return zfile.read(buf, off, len);
1301             }
1302         }
1303 
1304         private static class End {
1305             int  centot;     // 4 bytes
1306             long cenlen;     // 4 bytes
1307             long cenoff;     // 4 bytes
1308             long endpos;     // 4 bytes
1309         }
1310 
1311         /*
1312          * Searches for end of central directory (END) header. The contents of
1313          * the END header will be read and placed in endbuf. Returns the file
1314          * position of the END header, otherwise returns -1 if the END header
1315          * was not found or an error occurred.
1316          */
1317         private End findEND() throws IOException {
1318             long ziplen = zfile.length();
1319             if (ziplen &lt;= 0)
1320                 zerror(&quot;zip file is empty&quot;);
1321             End end = new End();
1322             byte[] buf = new byte[READBLOCKSZ];
1323             long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
1324             long minPos = minHDR - (buf.length - ENDHDR);
1325             for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR)) {
1326                 int off = 0;
1327                 if (pos &lt; 0) {
1328                     // Pretend there are some NUL bytes before start of file
1329                     off = (int)-pos;
1330                     Arrays.fill(buf, 0, off, (byte)0);
1331                 }
1332                 int len = buf.length - off;
1333                 if (readFullyAt(buf, off, len, pos + off) != len ) {
1334                     zerror(&quot;zip END header not found&quot;);
1335                 }
1336                 // Now scan the block backwards for END header signature
1337                 for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
1338                     if (buf[i+0] == (byte)&#39;P&#39;    &amp;&amp;
1339                         buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
1340                         buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
1341                         buf[i+3] == (byte)&#39;\006&#39;) {
1342                         // Found ENDSIG header
1343                         byte[] endbuf = Arrays.copyOfRange(buf, i, i + ENDHDR);
1344                         end.centot = ENDTOT(endbuf);
1345                         end.cenlen = ENDSIZ(endbuf);
1346                         end.cenoff = ENDOFF(endbuf);
1347                         end.endpos = pos + i;
1348                         int comlen = ENDCOM(endbuf);
1349                         if (end.endpos + ENDHDR + comlen != ziplen) {
1350                             // ENDSIG matched, however the size of file comment in it does
1351                             // not match the real size. One &quot;common&quot; cause for this problem
1352                             // is some &quot;extra&quot; bytes are padded at the end of the zipfile.
1353                             // Let&#39;s do some extra verification, we don&#39;t care about the
1354                             // performance in this situation.
1355                             byte[] sbuf = new byte[4];
1356                             long cenpos = end.endpos - end.cenlen;
1357                             long locpos = cenpos - end.cenoff;
1358                             if  (cenpos &lt; 0 ||
1359                                  locpos &lt; 0 ||
1360                                  readFullyAt(sbuf, 0, sbuf.length, cenpos) != 4 ||
1361                                  GETSIG(sbuf) != CENSIG ||
1362                                  readFullyAt(sbuf, 0, sbuf.length, locpos) != 4 ||
1363                                  GETSIG(sbuf) != LOCSIG) {
1364                                 continue;
1365                             }
1366                         }
1367                         if (comlen &gt; 0) {    // this zip file has comlen
1368                             comment = new byte[comlen];
1369                             if (readFullyAt(comment, 0, comlen, end.endpos + ENDHDR) != comlen) {
1370                                 zerror(&quot;zip comment read failed&quot;);
1371                             }
1372                         }
1373                         // must check for a zip64 end record; it is always permitted to be present
1374                         try {
1375                             byte[] loc64 = new byte[ZIP64_LOCHDR];
1376                             if (end.endpos &lt; ZIP64_LOCHDR ||
1377                                 readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
1378                                 != loc64.length || GETSIG(loc64) != ZIP64_LOCSIG) {
1379                                 return end;
1380                             }
1381                             long end64pos = ZIP64_LOCOFF(loc64);
1382                             byte[] end64buf = new byte[ZIP64_ENDHDR];
1383                             if (readFullyAt(end64buf, 0, end64buf.length, end64pos)
1384                                 != end64buf.length || GETSIG(end64buf) != ZIP64_ENDSIG) {
1385                                 return end;
1386                             }
1387                             // end64 candidate found,
1388                             long cenlen64 = ZIP64_ENDSIZ(end64buf);
1389                             long cenoff64 = ZIP64_ENDOFF(end64buf);
1390                             long centot64 = ZIP64_ENDTOT(end64buf);
1391                             // double-check
1392                             if (cenlen64 != end.cenlen &amp;&amp; end.cenlen != ZIP64_MAGICVAL ||
1393                                 cenoff64 != end.cenoff &amp;&amp; end.cenoff != ZIP64_MAGICVAL ||
1394                                 centot64 != end.centot &amp;&amp; end.centot != ZIP64_MAGICCOUNT) {
1395                                 return end;
1396                             }
1397                             // to use the end64 values
1398                             end.cenlen = cenlen64;
1399                             end.cenoff = cenoff64;
1400                             end.centot = (int)centot64; // assume total &lt; 2g
1401                             end.endpos = end64pos;
1402                         } catch (IOException x) {}    // no zip64 loc/end
1403                         return end;
1404                     }
1405                 }
1406             }
1407             zerror(&quot;zip END header not found&quot;);
1408             return null; //make compiler happy
1409         }
1410 
1411         // Reads zip file central directory.
1412         private void initCEN(int knownTotal) throws IOException {
1413             // Prefer locals for better performance during startup
1414             byte[] cen;
<a name="22" id="anc22"></a><span class="line-removed">1415             ZipCoder zc = this.zc;</span>
<span class="line-removed">1416 </span>
1417             if (knownTotal == -1) {
1418                 End end = findEND();
1419                 if (end.endpos == 0) {
1420                     locpos = 0;
1421                     total = 0;
1422                     entries = new int[0];
1423                     this.cen = null;
1424                     return;         // only END header present
1425                 }
1426                 if (end.cenlen &gt; end.endpos)
1427                     zerror(&quot;invalid END header (bad central directory size)&quot;);
1428                 long cenpos = end.endpos - end.cenlen;     // position of CEN table
1429                 // Get position of first local file (LOC) header, taking into
1430                 // account that there may be a stub prefixed to the zip file.
1431                 locpos = cenpos - end.cenoff;
1432                 if (locpos &lt; 0) {
1433                     zerror(&quot;invalid END header (bad central directory offset)&quot;);
1434                 }
1435                 // read in the CEN and END
1436                 cen = this.cen = new byte[(int)(end.cenlen + ENDHDR)];
1437                 if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
1438                     zerror(&quot;read CEN tables failed&quot;);
1439                 }
1440                 total = end.centot;
1441             } else {
1442                 cen = this.cen;
1443                 total = knownTotal;
1444             }
1445             // hash table for entries
1446             entries  = new int[total * 3];
1447 
1448             this.tablelen = ((total/2) | 1); // Odd -&gt; fewer collisions
1449             int tablelen = this.tablelen;
1450 
1451             this.table = new int[tablelen];
1452             int[] table = this.table;
1453 
1454             Arrays.fill(table, ZIP_ENDCHAIN);
1455             int idx = 0;
1456             int hash;
1457             int next;
1458 
1459             // list for all meta entries
1460             ArrayList&lt;Integer&gt; metanamesList = null;
1461             // Set of all version numbers seen in META-INF/versions/
1462             Set&lt;Integer&gt; metaVersionsSet = null;
1463 
1464             // Iterate through the entries in the central directory
1465             int i = 0;
1466             int hsh;
1467             int pos = 0;
1468             int entryPos = CENHDR;
1469             int limit = cen.length - ENDHDR;
1470             while (entryPos &lt;= limit) {
1471                 if (i &gt;= total) {
1472                     // This will only happen if the zip file has an incorrect
1473                     // ENDTOT field, which usually means it contains more than
1474                     // 65535 entries.
1475                     initCEN(countCENHeaders(cen, limit));
1476                     return;
1477                 }
1478                 if (CENSIG(cen, pos) != CENSIG)
1479                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1480                 int method = CENHOW(cen, pos);
1481                 int nlen   = CENNAM(cen, pos);
1482                 int elen   = CENEXT(cen, pos);
1483                 int clen   = CENCOM(cen, pos);
1484                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1485                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1486                 if (method != STORED &amp;&amp; method != DEFLATED)
1487                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1488                 if (entryPos + nlen &gt; limit)
1489                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1490                 // Record the CEN offset and the name hash in our hash cell.
<a name="23" id="anc23"></a><span class="line-modified">1491                 hash = zc.hashN(cen, entryPos, nlen);</span>
1492                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1493                 next = table[hsh];
1494                 table[hsh] = idx;
1495                 idx = addEntry(idx, hash, next, pos);
1496                 // Adds name to metanames.
1497                 if (isMetaName(cen, entryPos, nlen)) {
1498                     if (metanamesList == null)
1499                         metanamesList = new ArrayList&lt;&gt;(4);
1500                     metanamesList.add(pos);
1501 
1502                     // If this is a versioned entry, parse the version
1503                     // and store it for later. This optimizes lookup
1504                     // performance in multi-release jar files
1505                     int version = getMetaVersion(cen,
1506                         entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);
1507                     if (version &gt; 0) {
1508                         if (metaVersionsSet == null)
1509                             metaVersionsSet = new TreeSet&lt;&gt;();
1510                         metaVersionsSet.add(version);
1511                     }
1512                 }
1513                 // skip ext and comment
1514                 pos = entryPos + nlen + elen + clen;
1515                 entryPos = pos + CENHDR;
1516                 i++;
1517             }
1518             total = i;
1519             if (metanamesList != null) {
1520                 metanames = new int[metanamesList.size()];
1521                 for (int j = 0, len = metanames.length; j &lt; len; j++) {
1522                     metanames[j] = metanamesList.get(j);
1523                 }
1524             }
1525             if (metaVersionsSet != null) {
1526                 metaVersions = new int[metaVersionsSet.size()];
1527                 int c = 0;
1528                 for (Integer version : metaVersionsSet) {
1529                     metaVersions[c++] = version;
1530                 }
1531             } else {
1532                 metaVersions = EMPTY_META_VERSIONS;
1533             }
1534             if (pos + ENDHDR != cen.length) {
1535                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1536             }
1537         }
1538 
1539         private static void zerror(String msg) throws ZipException {
1540             throw new ZipException(msg);
1541         }
1542 
1543         /*
1544          * Returns the {@code pos} of the zip cen entry corresponding to the
1545          * specified entry name, or -1 if not found.
1546          */
<a name="24" id="anc24"></a><span class="line-modified">1547         private int getEntryPos(byte[] name, boolean addSlash) {</span>
1548             if (total == 0) {
1549                 return -1;
1550             }
<a name="25" id="anc25"></a><span class="line-modified">1551             int hsh = zc.hashN(name, 0, name.length);</span>

1552             int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1553 
1554             // Search down the target hash chain for a entry whose
1555             // 32 bit hash matches the hashed name.
1556             while (idx != ZIP_ENDCHAIN) {
1557                 if (getEntryHash(idx) == hsh) {
1558                     // The CEN name must match the specfied one
1559                     int pos = getEntryPos(idx);
<a name="26" id="anc26"></a><span class="line-modified">1560                     byte[] cen = this.cen;</span>
<span class="line-modified">1561                     final int nlen = CENNAM(cen, pos);</span>
<span class="line-modified">1562                     int nameoff = pos + CENHDR;</span>
<span class="line-modified">1563 </span>
<span class="line-modified">1564                     // If addSlash is true and we&#39;re using the UTF-8 zip coder,</span>
<span class="line-modified">1565                     // we&#39;ll directly test for name+/ in addition to name,</span>
<span class="line-modified">1566                     // unless name is the empty string or already ends with a</span>
<span class="line-modified">1567                     // slash</span>
<span class="line-modified">1568                     if (name.length == nlen ||</span>
<span class="line-modified">1569                            (addSlash &amp;&amp;</span>
<span class="line-modified">1570                             zc.isUTF8() &amp;&amp;</span>
<span class="line-modified">1571                             name.length &gt; 0 &amp;&amp;</span>
<span class="line-modified">1572                             name.length + 1 == nlen &amp;&amp;</span>
<span class="line-modified">1573                             cen[nameoff + nlen - 1] == &#39;/&#39; &amp;&amp;</span>
<span class="line-modified">1574                             name[name.length - 1] != &#39;/&#39;)) {</span>
<span class="line-modified">1575                         boolean matched = true;</span>
<span class="line-removed">1576                         for (int i = 0; i &lt; name.length; i++) {</span>
<span class="line-removed">1577                             if (name[i] != cen[nameoff++]) {</span>
<span class="line-removed">1578                                 matched = false;</span>
<span class="line-removed">1579                                 break;</span>
<span class="line-removed">1580                             }</span>
<span class="line-removed">1581                         }</span>
<span class="line-removed">1582                         if (matched) {</span>
<span class="line-removed">1583                            return pos;</span>
1584                         }
<a name="27" id="anc27"></a>

1585                     }
1586                 }
1587                 idx = getEntryNext(idx);
1588             }
1589             return -1;
1590         }
1591 
<a name="28" id="anc28"></a>









1592         /**
1593          * Returns true if the bytes represent a non-directory name
1594          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1595          */
1596         private static boolean isMetaName(byte[] name, int off, int len) {
1597             // Use the &quot;oldest ASCII trick in the book&quot;
1598             return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()
1599                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1600                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1601                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1602                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1603                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1604                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1605                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1606                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1607                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1608                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1609         }
1610 
1611         /*
1612          * If the bytes represents a non-directory name beginning
1613          * with &quot;versions/&quot;, continuing with a positive integer,
1614          * followed by a &#39;/&#39;, then return that integer value.
1615          * Otherwise, return 0
1616          */
1617         private static int getMetaVersion(byte[] name, int off, int len) {
1618             int nend = off + len;
1619             if (!(len &gt; 10                         // &quot;versions//&quot;.length()
1620                     &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1621                     &amp;&amp; (name[off++] | 0x20) == &#39;v&#39;
1622                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1623                     &amp;&amp; (name[off++] | 0x20) == &#39;r&#39;
1624                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1625                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1626                     &amp;&amp; (name[off++] | 0x20) == &#39;o&#39;
1627                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1628                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1629                     &amp;&amp; (name[off++]       ) == &#39;/&#39;)) {
1630                 return 0;
1631             }
1632             int version = 0;
1633             while (off &lt; nend) {
1634                 final byte c = name[off++];
1635                 if (c == &#39;/&#39;) {
1636                     return version;
1637                 }
1638                 if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {
1639                     return 0;
1640                 }
1641                 version = version * 10 + c - &#39;0&#39;;
1642                 // Check for overflow and leading zeros
1643                 if (version &lt;= 0) {
1644                     return 0;
1645                 }
1646             }
1647             return 0;
1648         }
1649 
1650         /**
1651          * Returns the number of CEN headers in a central directory.
1652          * Will not throw, even if the zip file is corrupt.
1653          *
1654          * @param cen copy of the bytes in a zip file&#39;s central directory
1655          * @param size number of bytes in central directory
1656          */
1657         private static int countCENHeaders(byte[] cen, int size) {
1658             int count = 0;
1659             for (int p = 0;
1660                  p + CENHDR &lt;= size;
1661                  p += CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p))
1662                 count++;
1663             return count;
1664         }
1665     }
1666 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipCoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/loader/ClassLoaders.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  75  *
  76  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  77  * or method in this class will cause a {@link NullPointerException} to be
  78  * thrown.
  79  *
  80  * @apiNote
  81  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  82  * should be called explicitly or by try-with-resources. Subclasses are responsible
  83  * for the cleanup of resources acquired by the subclass. Subclasses that override
  84  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  85  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  86  * {@code finalize} method.
  87  *
  88  * @author      David Connelly
  89  * @since 1.1
  90  */
  91 public class ZipFile implements ZipConstants, Closeable {
  92 
  93     private final String name;     // zip file name
  94     private volatile boolean closeRequested;
<span class="line-removed">  95     private final @Stable ZipCoder zc;</span>
  96 
  97     // The &quot;resource&quot; used by this zip file that needs to be
  98     // cleaned after use.
  99     // a) the input streams that need to be closed
 100     // b) the list of cached Inflater objects
 101     // c) the &quot;native&quot; source of this zip file.
 102     private final @Stable CleanableResource res;
 103 
 104     private static final int STORED = ZipEntry.STORED;
 105     private static final int DEFLATED = ZipEntry.DEFLATED;
 106 
 107     /**
 108      * Mode flag to open a zip file for reading.
 109      */
 110     public static final int OPEN_READ = 0x1;
 111 
 112     /**
 113      * Mode flag to open a zip file and mark it for deletion.  The file will be
 114      * deleted some time between the moment that it is opened and the moment
 115      * that it is closed, but its contents will remain accessible via the
</pre>
<hr />
<pre>
 215      *
 216      * @since 1.7
 217      */
 218     public ZipFile(File file, int mode, Charset charset) throws IOException
 219     {
 220         if (((mode &amp; OPEN_READ) == 0) ||
 221             ((mode &amp; ~(OPEN_READ | OPEN_DELETE)) != 0)) {
 222             throw new IllegalArgumentException(&quot;Illegal mode: 0x&quot;+
 223                                                Integer.toHexString(mode));
 224         }
 225         String name = file.getPath();
 226         SecurityManager sm = System.getSecurityManager();
 227         if (sm != null) {
 228             sm.checkRead(name);
 229             if ((mode &amp; OPEN_DELETE) != 0) {
 230                 sm.checkDelete(name);
 231             }
 232         }
 233         Objects.requireNonNull(charset, &quot;charset&quot;);
 234 
<span class="line-removed"> 235         this.zc = ZipCoder.get(charset);</span>
 236         this.name = name;
 237         long t0 = System.nanoTime();
 238 
<span class="line-modified"> 239         this.res = new CleanableResource(this, file, mode);</span>
 240 
 241         PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
 242         PerfCounter.getZipFileCount().increment();
 243     }
 244 
 245     /**
 246      * Opens a zip file for reading.
 247      *
 248      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 249      * method is called with the {@code name} argument as its argument
 250      * to ensure the read is allowed.
 251      *
 252      * @param name the name of the zip file
 253      * @param charset
 254      *        the {@linkplain java.nio.charset.Charset charset} to
 255      *        be used to decode the ZIP entry name and comment that are not
 256      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 257      *        purpose flag).
 258      *
 259      * @throws ZipException if a ZIP format error has occurred
</pre>
<hr />
<pre>
 290     public ZipFile(File file, Charset charset) throws IOException
 291     {
 292         this(file, OPEN_READ, charset);
 293     }
 294 
 295     /**
 296      * Returns the zip file comment, or null if none.
 297      *
 298      * @return the comment string for the zip file, or null if none
 299      *
 300      * @throws IllegalStateException if the zip file has been closed
 301      *
 302      * @since 1.7
 303      */
 304     public String getComment() {
 305         synchronized (this) {
 306             ensureOpen();
 307             if (res.zsrc.comment == null) {
 308                 return null;
 309             }
<span class="line-modified"> 310             return zc.toString(res.zsrc.comment);</span>
 311         }
 312     }
 313 
 314     /**
 315      * Returns the zip file entry for the specified name, or null
 316      * if not found.
 317      *
 318      * @param name the name of the entry
 319      * @return the zip file entry, or null if not found
 320      * @throws IllegalStateException if the zip file has been closed
 321      */
 322     public ZipEntry getEntry(String name) {
 323         return getEntry(name, ZipEntry::new);
 324     }
 325 
 326     /*
 327      * Returns the zip file entry for the specified name, or null
 328      * if not found.
 329      *
 330      * @param name the name of the entry
 331      * @param func the function that creates the returned entry
 332      *
 333      * @return the zip file entry, or null if not found
 334      * @throws IllegalStateException if the zip file has been closed
 335      */
 336     private ZipEntry getEntry(String name, Function&lt;String, ? extends ZipEntry&gt; func) {
 337         Objects.requireNonNull(name, &quot;name&quot;);
 338         ZipEntry entry = null;
 339         synchronized (this) {
 340             ensureOpen();
<span class="line-modified"> 341             byte[] bname = zc.getBytes(name);</span>
<span class="line-removed"> 342             int pos = res.zsrc.getEntryPos(bname, true);</span>
 343             if (pos != -1) {
<span class="line-modified"> 344                 entry = getZipEntry(name, bname, pos, func);</span>
<span class="line-removed"> 345             } else if (!zc.isUTF8() &amp;&amp; !name.isEmpty() &amp;&amp; !name.endsWith(&quot;/&quot;)) {</span>
<span class="line-removed"> 346                 // non-UTF-8 charsets need to lookup again with added slash</span>
<span class="line-removed"> 347                 name = name + &#39;/&#39;;</span>
<span class="line-removed"> 348                 bname = zc.getBytes(name);</span>
<span class="line-removed"> 349                 pos = res.zsrc.getEntryPos(bname, false);</span>
<span class="line-removed"> 350                 if (pos != -1) {</span>
<span class="line-removed"> 351                     entry = getZipEntry(name, bname, pos, func);</span>
<span class="line-removed"> 352                 }</span>
 353             }
 354         }
 355         return entry;
 356     }
 357 
 358     /**
 359      * Returns an input stream for reading the contents of the specified
 360      * zip file entry.
 361      * &lt;p&gt;
 362      * Closing this ZIP file will, in turn, close all input streams that
 363      * have been returned by invocations of this method.
 364      *
 365      * @param entry the zip file entry
 366      * @return the input stream for reading the contents of the specified
 367      * zip file entry.
 368      * @throws ZipException if a ZIP format error has occurred
 369      * @throws IOException if an I/O error has occurred
 370      * @throws IllegalStateException if the zip file has been closed
 371      */
 372     public InputStream getInputStream(ZipEntry entry) throws IOException {
 373         Objects.requireNonNull(entry, &quot;entry&quot;);
<span class="line-modified"> 374         int pos = -1;</span>
 375         ZipFileInputStream in;
 376         Source zsrc = res.zsrc;
 377         Set&lt;InputStream&gt; istreams = res.istreams;
 378         synchronized (this) {
 379             ensureOpen();
 380             if (Objects.equals(lastEntryName, entry.name)) {
 381                 pos = lastEntryPos;
<span class="line-removed"> 382             } else if (!zc.isUTF8() &amp;&amp; (entry.flag &amp; USE_UTF8) != 0) {</span>
<span class="line-removed"> 383                 pos = zsrc.getEntryPos(zc.getBytesUTF8(entry.name), false);</span>
 384             } else {
<span class="line-modified"> 385                 pos = zsrc.getEntryPos(zc.getBytes(entry.name), false);</span>
 386             }
 387             if (pos == -1) {
 388                 return null;
 389             }
 390             in = new ZipFileInputStream(zsrc.cen, pos);
 391             switch (CENHOW(zsrc.cen, pos)) {
 392             case STORED:
 393                 synchronized (istreams) {
 394                     istreams.add(in);
 395                 }
 396                 return in;
 397             case DEFLATED:
 398                 // Inflater likes a bit of slack
 399                 // MORE: Compute good size for inflater stream:
 400                 long size = CENLEN(zsrc.cen, pos) + 2;
 401                 if (size &gt; 65536) {
 402                     size = 8192;
 403                 }
 404                 if (size &lt;= 0) {
 405                     size = 4096;
</pre>
<hr />
<pre>
 511 
 512         @Override
 513         public boolean hasNext() {
 514             return i &lt; entryCount;
 515         }
 516 
 517         @Override
 518         public T nextElement() {
 519             return next();
 520         }
 521 
 522         @Override
 523         @SuppressWarnings(&quot;unchecked&quot;)
 524         public T next() {
 525             synchronized (ZipFile.this) {
 526                 ensureOpen();
 527                 if (!hasNext()) {
 528                     throw new NoSuchElementException();
 529                 }
 530                 // each &quot;entry&quot; has 3 ints in table entries
<span class="line-modified"> 531                 return (T)getZipEntry(null, null, res.zsrc.getEntryPos(i++ * 3), gen);</span>
 532             }
 533         }
 534 
 535         @Override
 536         public Iterator&lt;T&gt; asIterator() {
 537             return this;
 538         }
 539     }
 540 
 541     /**
 542      * Returns an enumeration of the ZIP file entries.
 543      * @return an enumeration of the ZIP file entries
 544      * @throws IllegalStateException if the zip file has been closed
 545      */
 546     public Enumeration&lt;? extends ZipEntry&gt; entries() {
 547         synchronized (this) {
 548             ensureOpen();
 549             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total, ZipEntry::new);
 550         }
 551     }
</pre>
<hr />
<pre>
 583                 return true;
 584             }
 585             return false;
 586         }
 587     }
 588 
 589     /**
 590      * Returns an ordered {@code Stream} over the ZIP file entries.
 591      *
 592      * Entries appear in the {@code Stream} in the order they appear in
 593      * the central directory of the ZIP file.
 594      *
 595      * @return an ordered {@code Stream} of entries in this ZIP file
 596      * @throws IllegalStateException if the zip file has been closed
 597      * @since 1.8
 598      */
 599     public Stream&lt;? extends ZipEntry&gt; stream() {
 600         synchronized (this) {
 601             ensureOpen();
 602             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified"> 603                 pos -&gt; getZipEntry(null, null, pos, ZipEntry::new)), false);</span>
 604        }
 605     }
 606 
 607     private String getEntryName(int pos) {
 608         byte[] cen = res.zsrc.cen;
 609         int nlen = CENNAM(cen, pos);
<span class="line-modified"> 610         if (!zc.isUTF8() &amp;&amp; (CENFLG(cen, pos) &amp; USE_UTF8) != 0) {</span>
<span class="line-modified"> 611             return zc.toStringUTF8(cen, pos + CENHDR, nlen);</span>
<span class="line-removed"> 612         } else {</span>
<span class="line-removed"> 613             return zc.toString(cen, pos + CENHDR, nlen);</span>
<span class="line-removed"> 614         }</span>
 615     }
 616 
 617     /*
 618      * Returns an ordered {@code Stream} over the zip file entry names.
 619      *
 620      * Entry names appear in the {@code Stream} in the order they appear in
 621      * the central directory of the ZIP file.
 622      *
 623      * @return an ordered {@code Stream} of entry names in this zip file
 624      * @throws IllegalStateException if the zip file has been closed
 625      * @since 10
 626      */
 627     private Stream&lt;String&gt; entryNameStream() {
 628         synchronized (this) {
 629             ensureOpen();
 630             return StreamSupport.stream(
 631                 new EntrySpliterator&lt;&gt;(0, res.zsrc.total, this::getEntryName), false);
 632         }
 633     }
 634 
 635     /*
 636      * Returns an ordered {@code Stream} over the zip file entries.
 637      *
 638      * Entries appear in the {@code Stream} in the order they appear in
 639      * the central directory of the jar file.
 640      *
 641      * @param func the function that creates the returned entry
 642      * @return an ordered {@code Stream} of entries in this zip file
 643      * @throws IllegalStateException if the zip file has been closed
 644      * @since 10
 645      */
 646     private Stream&lt;JarEntry&gt; stream(Function&lt;String, JarEntry&gt; func) {
 647         synchronized (this) {
 648             ensureOpen();
 649             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified"> 650                 pos -&gt; (JarEntry)getZipEntry(null, null, pos, func)), false);</span>
 651         }
 652     }
 653 
 654     private String lastEntryName;
 655     private int lastEntryPos;
 656 
<span class="line-modified"> 657     /* Checks ensureOpen() before invoke this method */</span>
<span class="line-modified"> 658     private ZipEntry getZipEntry(String name, byte[] bname, int pos,</span>
 659                                  Function&lt;String, ? extends ZipEntry&gt; func) {
 660         byte[] cen = res.zsrc.cen;
 661         int nlen = CENNAM(cen, pos);
 662         int elen = CENEXT(cen, pos);
 663         int clen = CENCOM(cen, pos);
<span class="line-modified"> 664         int flag = CENFLG(cen, pos);</span>
<span class="line-modified"> 665         if (name == null || bname.length != nlen) {</span>
<span class="line-modified"> 666             // to use the entry name stored in cen, if the passed in name is</span>
<span class="line-modified"> 667             // (1) null, invoked from iterator, or</span>
<span class="line-modified"> 668             // (2) not equal to the name stored, a slash is appended during</span>
<span class="line-modified"> 669             // getEntryPos() search.</span>
<span class="line-modified"> 670             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {</span>
<span class="line-modified"> 671                 name = zc.toStringUTF8(cen, pos + CENHDR, nlen);</span>
<span class="line-modified"> 672             } else {</span>
<span class="line-modified"> 673                 name = zc.toString(cen, pos + CENHDR, nlen);</span>
 674             }



 675         }
 676         ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
<span class="line-modified"> 677         e.flag = flag;</span>
 678         e.xdostime = CENTIM(cen, pos);
 679         e.crc = CENCRC(cen, pos);
 680         e.size = CENLEN(cen, pos);
 681         e.csize = CENSIZ(cen, pos);
 682         e.method = CENHOW(cen, pos);
 683         if (elen != 0) {
 684             int start = pos + CENHDR + nlen;
 685             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
 686         }
 687         if (clen != 0) {
 688             int start = pos + CENHDR + nlen + elen;
<span class="line-modified"> 689             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {</span>
<span class="line-removed"> 690                 e.comment = zc.toStringUTF8(cen, start, clen);</span>
<span class="line-removed"> 691             } else {</span>
<span class="line-removed"> 692                 e.comment = zc.toString(cen, start, clen);</span>
<span class="line-removed"> 693             }</span>
 694         }
 695         lastEntryName = e.name;
 696         lastEntryPos = pos;
 697         return e;
 698     }
 699 
 700     /**
 701      * Returns the number of entries in the ZIP file.
 702      *
 703      * @return the number of entries in the ZIP file
 704      * @throws IllegalStateException if the zip file has been closed
 705      */
 706     public int size() {
 707         synchronized (this) {
 708             ensureOpen();
 709             return res.zsrc.total;
 710         }
 711     }
 712 
 713     private static class CleanableResource implements Runnable {
 714         // The outstanding inputstreams that need to be closed
 715         final Set&lt;InputStream&gt; istreams;
 716 
 717         // List of cached Inflater objects for decompression
 718         Deque&lt;Inflater&gt; inflaterCache;
 719 
 720         final Cleanable cleanable;
 721 
 722         Source zsrc;
 723 
<span class="line-modified"> 724         CleanableResource(ZipFile zf, File file, int mode) throws IOException {</span>
 725             this.cleanable = CleanerFactory.cleaner().register(zf, this);
 726             this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
 727             this.inflaterCache = new ArrayDeque&lt;&gt;();
<span class="line-modified"> 728             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0, zf.zc);</span>
 729         }
 730 
 731         void clean() {
 732             cleanable.clean();
 733         }
 734 
 735         /*
 736          * Gets an inflater from the list of available inflaters or allocates
 737          * a new one.
 738          */
 739         Inflater getInflater() {
 740             Inflater inf;
 741             synchronized (inflaterCache) {
 742                 if ((inf = inflaterCache.poll()) != null) {
 743                     return inf;
 744                 }
 745             }
 746             return new Inflater(true);
 747         }
 748 
</pre>
<hr />
<pre>
1096                 @Override
1097                 public Stream&lt;JarEntry&gt; stream(ZipFile zip,
1098                     Function&lt;String, JarEntry&gt; func) {
1099                     return zip.stream(func);
1100                 }
1101                 @Override
1102                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1103                     return zip.entryNameStream();
1104                 }
1105              }
1106         );
1107         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1108     }
1109 
1110     private static class Source {
1111         // &quot;META-INF/&quot;.length()
1112         private static final int META_INF_LENGTH = 9;
1113         private static final int[] EMPTY_META_VERSIONS = new int[0];
1114 
1115         private final Key key;               // the key in files
<span class="line-modified">1116         private final ZipCoder zc;           // zip coder used to decode/encode</span>
1117 
1118         private int refs = 1;
1119 
1120         private RandomAccessFile zfile;      // zfile of the underlying zip file
1121         private byte[] cen;                  // CEN &amp; ENDHDR
1122         private long locpos;                 // position of first LOC header (usually 0)
1123         private byte[] comment;              // zip file comment
1124                                              // list of meta entries in META-INF dir
1125         private int[] metanames;
1126         private int[] metaVersions;          // list of unique versions found in META-INF/versions/
1127         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1128 
1129         // A Hashmap for all entries.
1130         //
1131         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1132         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1133         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1134         // entry name and its offset {@code pos} in the central directory hdeader.
1135         //
1136         // private static class Entry {
</pre>
<hr />
<pre>
1395                                 return end;
1396                             }
1397                             // to use the end64 values
1398                             end.cenlen = cenlen64;
1399                             end.cenoff = cenoff64;
1400                             end.centot = (int)centot64; // assume total &lt; 2g
1401                             end.endpos = end64pos;
1402                         } catch (IOException x) {}    // no zip64 loc/end
1403                         return end;
1404                     }
1405                 }
1406             }
1407             zerror(&quot;zip END header not found&quot;);
1408             return null; //make compiler happy
1409         }
1410 
1411         // Reads zip file central directory.
1412         private void initCEN(int knownTotal) throws IOException {
1413             // Prefer locals for better performance during startup
1414             byte[] cen;
<span class="line-removed">1415             ZipCoder zc = this.zc;</span>
<span class="line-removed">1416 </span>
1417             if (knownTotal == -1) {
1418                 End end = findEND();
1419                 if (end.endpos == 0) {
1420                     locpos = 0;
1421                     total = 0;
1422                     entries = new int[0];
1423                     this.cen = null;
1424                     return;         // only END header present
1425                 }
1426                 if (end.cenlen &gt; end.endpos)
1427                     zerror(&quot;invalid END header (bad central directory size)&quot;);
1428                 long cenpos = end.endpos - end.cenlen;     // position of CEN table
1429                 // Get position of first local file (LOC) header, taking into
1430                 // account that there may be a stub prefixed to the zip file.
1431                 locpos = cenpos - end.cenoff;
1432                 if (locpos &lt; 0) {
1433                     zerror(&quot;invalid END header (bad central directory offset)&quot;);
1434                 }
1435                 // read in the CEN and END
1436                 cen = this.cen = new byte[(int)(end.cenlen + ENDHDR)];
</pre>
<hr />
<pre>
1471                 if (i &gt;= total) {
1472                     // This will only happen if the zip file has an incorrect
1473                     // ENDTOT field, which usually means it contains more than
1474                     // 65535 entries.
1475                     initCEN(countCENHeaders(cen, limit));
1476                     return;
1477                 }
1478                 if (CENSIG(cen, pos) != CENSIG)
1479                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1480                 int method = CENHOW(cen, pos);
1481                 int nlen   = CENNAM(cen, pos);
1482                 int elen   = CENEXT(cen, pos);
1483                 int clen   = CENCOM(cen, pos);
1484                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1485                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1486                 if (method != STORED &amp;&amp; method != DEFLATED)
1487                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1488                 if (entryPos + nlen &gt; limit)
1489                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1490                 // Record the CEN offset and the name hash in our hash cell.
<span class="line-modified">1491                 hash = zc.hashN(cen, entryPos, nlen);</span>
1492                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1493                 next = table[hsh];
1494                 table[hsh] = idx;
1495                 idx = addEntry(idx, hash, next, pos);
1496                 // Adds name to metanames.
1497                 if (isMetaName(cen, entryPos, nlen)) {
1498                     if (metanamesList == null)
1499                         metanamesList = new ArrayList&lt;&gt;(4);
1500                     metanamesList.add(pos);
1501 
1502                     // If this is a versioned entry, parse the version
1503                     // and store it for later. This optimizes lookup
1504                     // performance in multi-release jar files
1505                     int version = getMetaVersion(cen,
1506                         entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);
1507                     if (version &gt; 0) {
1508                         if (metaVersionsSet == null)
1509                             metaVersionsSet = new TreeSet&lt;&gt;();
1510                         metaVersionsSet.add(version);
1511                     }
</pre>
<hr />
<pre>
1527                 int c = 0;
1528                 for (Integer version : metaVersionsSet) {
1529                     metaVersions[c++] = version;
1530                 }
1531             } else {
1532                 metaVersions = EMPTY_META_VERSIONS;
1533             }
1534             if (pos + ENDHDR != cen.length) {
1535                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1536             }
1537         }
1538 
1539         private static void zerror(String msg) throws ZipException {
1540             throw new ZipException(msg);
1541         }
1542 
1543         /*
1544          * Returns the {@code pos} of the zip cen entry corresponding to the
1545          * specified entry name, or -1 if not found.
1546          */
<span class="line-modified">1547         private int getEntryPos(byte[] name, boolean addSlash) {</span>
1548             if (total == 0) {
1549                 return -1;
1550             }
<span class="line-modified">1551             int hsh = zc.hashN(name, 0, name.length);</span>

1552             int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1553 
1554             // Search down the target hash chain for a entry whose
1555             // 32 bit hash matches the hashed name.
1556             while (idx != ZIP_ENDCHAIN) {
1557                 if (getEntryHash(idx) == hsh) {
1558                     // The CEN name must match the specfied one
1559                     int pos = getEntryPos(idx);
<span class="line-modified">1560                     byte[] cen = this.cen;</span>
<span class="line-modified">1561                     final int nlen = CENNAM(cen, pos);</span>
<span class="line-modified">1562                     int nameoff = pos + CENHDR;</span>
<span class="line-modified">1563 </span>
<span class="line-modified">1564                     // If addSlash is true and we&#39;re using the UTF-8 zip coder,</span>
<span class="line-modified">1565                     // we&#39;ll directly test for name+/ in addition to name,</span>
<span class="line-modified">1566                     // unless name is the empty string or already ends with a</span>
<span class="line-modified">1567                     // slash</span>
<span class="line-modified">1568                     if (name.length == nlen ||</span>
<span class="line-modified">1569                            (addSlash &amp;&amp;</span>
<span class="line-modified">1570                             zc.isUTF8() &amp;&amp;</span>
<span class="line-modified">1571                             name.length &gt; 0 &amp;&amp;</span>
<span class="line-modified">1572                             name.length + 1 == nlen &amp;&amp;</span>
<span class="line-modified">1573                             cen[nameoff + nlen - 1] == &#39;/&#39; &amp;&amp;</span>
<span class="line-modified">1574                             name[name.length - 1] != &#39;/&#39;)) {</span>
<span class="line-modified">1575                         boolean matched = true;</span>
<span class="line-removed">1576                         for (int i = 0; i &lt; name.length; i++) {</span>
<span class="line-removed">1577                             if (name[i] != cen[nameoff++]) {</span>
<span class="line-removed">1578                                 matched = false;</span>
<span class="line-removed">1579                                 break;</span>
<span class="line-removed">1580                             }</span>
<span class="line-removed">1581                         }</span>
<span class="line-removed">1582                         if (matched) {</span>
<span class="line-removed">1583                            return pos;</span>
1584                         }


1585                     }
1586                 }
1587                 idx = getEntryNext(idx);
1588             }
1589             return -1;
1590         }
1591 










1592         /**
1593          * Returns true if the bytes represent a non-directory name
1594          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1595          */
1596         private static boolean isMetaName(byte[] name, int off, int len) {
1597             // Use the &quot;oldest ASCII trick in the book&quot;
1598             return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()
1599                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1600                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1601                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1602                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1603                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1604                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1605                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1606                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1607                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1608                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1609         }
1610 
1611         /*
</pre>
</td>
<td>
<hr />
<pre>
  75  *
  76  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  77  * or method in this class will cause a {@link NullPointerException} to be
  78  * thrown.
  79  *
  80  * @apiNote
  81  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  82  * should be called explicitly or by try-with-resources. Subclasses are responsible
  83  * for the cleanup of resources acquired by the subclass. Subclasses that override
  84  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  85  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  86  * {@code finalize} method.
  87  *
  88  * @author      David Connelly
  89  * @since 1.1
  90  */
  91 public class ZipFile implements ZipConstants, Closeable {
  92 
  93     private final String name;     // zip file name
  94     private volatile boolean closeRequested;

  95 
  96     // The &quot;resource&quot; used by this zip file that needs to be
  97     // cleaned after use.
  98     // a) the input streams that need to be closed
  99     // b) the list of cached Inflater objects
 100     // c) the &quot;native&quot; source of this zip file.
 101     private final @Stable CleanableResource res;
 102 
 103     private static final int STORED = ZipEntry.STORED;
 104     private static final int DEFLATED = ZipEntry.DEFLATED;
 105 
 106     /**
 107      * Mode flag to open a zip file for reading.
 108      */
 109     public static final int OPEN_READ = 0x1;
 110 
 111     /**
 112      * Mode flag to open a zip file and mark it for deletion.  The file will be
 113      * deleted some time between the moment that it is opened and the moment
 114      * that it is closed, but its contents will remain accessible via the
</pre>
<hr />
<pre>
 214      *
 215      * @since 1.7
 216      */
 217     public ZipFile(File file, int mode, Charset charset) throws IOException
 218     {
 219         if (((mode &amp; OPEN_READ) == 0) ||
 220             ((mode &amp; ~(OPEN_READ | OPEN_DELETE)) != 0)) {
 221             throw new IllegalArgumentException(&quot;Illegal mode: 0x&quot;+
 222                                                Integer.toHexString(mode));
 223         }
 224         String name = file.getPath();
 225         SecurityManager sm = System.getSecurityManager();
 226         if (sm != null) {
 227             sm.checkRead(name);
 228             if ((mode &amp; OPEN_DELETE) != 0) {
 229                 sm.checkDelete(name);
 230             }
 231         }
 232         Objects.requireNonNull(charset, &quot;charset&quot;);
 233 

 234         this.name = name;
 235         long t0 = System.nanoTime();
 236 
<span class="line-modified"> 237         this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);</span>
 238 
 239         PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
 240         PerfCounter.getZipFileCount().increment();
 241     }
 242 
 243     /**
 244      * Opens a zip file for reading.
 245      *
 246      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 247      * method is called with the {@code name} argument as its argument
 248      * to ensure the read is allowed.
 249      *
 250      * @param name the name of the zip file
 251      * @param charset
 252      *        the {@linkplain java.nio.charset.Charset charset} to
 253      *        be used to decode the ZIP entry name and comment that are not
 254      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 255      *        purpose flag).
 256      *
 257      * @throws ZipException if a ZIP format error has occurred
</pre>
<hr />
<pre>
 288     public ZipFile(File file, Charset charset) throws IOException
 289     {
 290         this(file, OPEN_READ, charset);
 291     }
 292 
 293     /**
 294      * Returns the zip file comment, or null if none.
 295      *
 296      * @return the comment string for the zip file, or null if none
 297      *
 298      * @throws IllegalStateException if the zip file has been closed
 299      *
 300      * @since 1.7
 301      */
 302     public String getComment() {
 303         synchronized (this) {
 304             ensureOpen();
 305             if (res.zsrc.comment == null) {
 306                 return null;
 307             }
<span class="line-modified"> 308             return res.zsrc.zc.toString(res.zsrc.comment);</span>
 309         }
 310     }
 311 
 312     /**
 313      * Returns the zip file entry for the specified name, or null
 314      * if not found.
 315      *
 316      * @param name the name of the entry
 317      * @return the zip file entry, or null if not found
 318      * @throws IllegalStateException if the zip file has been closed
 319      */
 320     public ZipEntry getEntry(String name) {
 321         return getEntry(name, ZipEntry::new);
 322     }
 323 
 324     /*
 325      * Returns the zip file entry for the specified name, or null
 326      * if not found.
 327      *
 328      * @param name the name of the entry
 329      * @param func the function that creates the returned entry
 330      *
 331      * @return the zip file entry, or null if not found
 332      * @throws IllegalStateException if the zip file has been closed
 333      */
 334     private ZipEntry getEntry(String name, Function&lt;String, ? extends ZipEntry&gt; func) {
 335         Objects.requireNonNull(name, &quot;name&quot;);
 336         ZipEntry entry = null;
 337         synchronized (this) {
 338             ensureOpen();
<span class="line-modified"> 339             int pos = res.zsrc.getEntryPos(name, true);</span>

 340             if (pos != -1) {
<span class="line-modified"> 341                 entry = getZipEntry(name, pos, func);</span>








 342             }
 343         }
 344         return entry;
 345     }
 346 
 347     /**
 348      * Returns an input stream for reading the contents of the specified
 349      * zip file entry.
 350      * &lt;p&gt;
 351      * Closing this ZIP file will, in turn, close all input streams that
 352      * have been returned by invocations of this method.
 353      *
 354      * @param entry the zip file entry
 355      * @return the input stream for reading the contents of the specified
 356      * zip file entry.
 357      * @throws ZipException if a ZIP format error has occurred
 358      * @throws IOException if an I/O error has occurred
 359      * @throws IllegalStateException if the zip file has been closed
 360      */
 361     public InputStream getInputStream(ZipEntry entry) throws IOException {
 362         Objects.requireNonNull(entry, &quot;entry&quot;);
<span class="line-modified"> 363         int pos;</span>
 364         ZipFileInputStream in;
 365         Source zsrc = res.zsrc;
 366         Set&lt;InputStream&gt; istreams = res.istreams;
 367         synchronized (this) {
 368             ensureOpen();
 369             if (Objects.equals(lastEntryName, entry.name)) {
 370                 pos = lastEntryPos;


 371             } else {
<span class="line-modified"> 372                 pos = zsrc.getEntryPos(entry.name, false);</span>
 373             }
 374             if (pos == -1) {
 375                 return null;
 376             }
 377             in = new ZipFileInputStream(zsrc.cen, pos);
 378             switch (CENHOW(zsrc.cen, pos)) {
 379             case STORED:
 380                 synchronized (istreams) {
 381                     istreams.add(in);
 382                 }
 383                 return in;
 384             case DEFLATED:
 385                 // Inflater likes a bit of slack
 386                 // MORE: Compute good size for inflater stream:
 387                 long size = CENLEN(zsrc.cen, pos) + 2;
 388                 if (size &gt; 65536) {
 389                     size = 8192;
 390                 }
 391                 if (size &lt;= 0) {
 392                     size = 4096;
</pre>
<hr />
<pre>
 498 
 499         @Override
 500         public boolean hasNext() {
 501             return i &lt; entryCount;
 502         }
 503 
 504         @Override
 505         public T nextElement() {
 506             return next();
 507         }
 508 
 509         @Override
 510         @SuppressWarnings(&quot;unchecked&quot;)
 511         public T next() {
 512             synchronized (ZipFile.this) {
 513                 ensureOpen();
 514                 if (!hasNext()) {
 515                     throw new NoSuchElementException();
 516                 }
 517                 // each &quot;entry&quot; has 3 ints in table entries
<span class="line-modified"> 518                 return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3), gen);</span>
 519             }
 520         }
 521 
 522         @Override
 523         public Iterator&lt;T&gt; asIterator() {
 524             return this;
 525         }
 526     }
 527 
 528     /**
 529      * Returns an enumeration of the ZIP file entries.
 530      * @return an enumeration of the ZIP file entries
 531      * @throws IllegalStateException if the zip file has been closed
 532      */
 533     public Enumeration&lt;? extends ZipEntry&gt; entries() {
 534         synchronized (this) {
 535             ensureOpen();
 536             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total, ZipEntry::new);
 537         }
 538     }
</pre>
<hr />
<pre>
 570                 return true;
 571             }
 572             return false;
 573         }
 574     }
 575 
 576     /**
 577      * Returns an ordered {@code Stream} over the ZIP file entries.
 578      *
 579      * Entries appear in the {@code Stream} in the order they appear in
 580      * the central directory of the ZIP file.
 581      *
 582      * @return an ordered {@code Stream} of entries in this ZIP file
 583      * @throws IllegalStateException if the zip file has been closed
 584      * @since 1.8
 585      */
 586     public Stream&lt;? extends ZipEntry&gt; stream() {
 587         synchronized (this) {
 588             ensureOpen();
 589             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified"> 590                 pos -&gt; getZipEntry(null, pos, ZipEntry::new)), false);</span>
 591        }
 592     }
 593 
 594     private String getEntryName(int pos) {
 595         byte[] cen = res.zsrc.cen;
 596         int nlen = CENNAM(cen, pos);
<span class="line-modified"> 597         ZipCoder zc = res.zsrc.zipCoderForPos(pos);</span>
<span class="line-modified"> 598         return zc.toString(cen, pos + CENHDR, nlen);</span>



 599     }
 600 
 601     /*
 602      * Returns an ordered {@code Stream} over the zip file entry names.
 603      *
 604      * Entry names appear in the {@code Stream} in the order they appear in
 605      * the central directory of the ZIP file.
 606      *
 607      * @return an ordered {@code Stream} of entry names in this zip file
 608      * @throws IllegalStateException if the zip file has been closed
 609      * @since 10
 610      */
 611     private Stream&lt;String&gt; entryNameStream() {
 612         synchronized (this) {
 613             ensureOpen();
 614             return StreamSupport.stream(
 615                 new EntrySpliterator&lt;&gt;(0, res.zsrc.total, this::getEntryName), false);
 616         }
 617     }
 618 
 619     /*
 620      * Returns an ordered {@code Stream} over the zip file entries.
 621      *
 622      * Entries appear in the {@code Stream} in the order they appear in
 623      * the central directory of the jar file.
 624      *
 625      * @param func the function that creates the returned entry
 626      * @return an ordered {@code Stream} of entries in this zip file
 627      * @throws IllegalStateException if the zip file has been closed
 628      * @since 10
 629      */
 630     private Stream&lt;JarEntry&gt; stream(Function&lt;String, JarEntry&gt; func) {
 631         synchronized (this) {
 632             ensureOpen();
 633             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified"> 634                 pos -&gt; (JarEntry)getZipEntry(null, pos, func)), false);</span>
 635         }
 636     }
 637 
 638     private String lastEntryName;
 639     private int lastEntryPos;
 640 
<span class="line-modified"> 641     /* Check ensureOpen() before invoking this method */</span>
<span class="line-modified"> 642     private ZipEntry getZipEntry(String name, int pos,</span>
 643                                  Function&lt;String, ? extends ZipEntry&gt; func) {
 644         byte[] cen = res.zsrc.cen;
 645         int nlen = CENNAM(cen, pos);
 646         int elen = CENEXT(cen, pos);
 647         int clen = CENCOM(cen, pos);
<span class="line-modified"> 648 </span>
<span class="line-modified"> 649         ZipCoder zc = res.zsrc.zipCoderForPos(pos);</span>
<span class="line-modified"> 650         if (name != null) {</span>
<span class="line-modified"> 651             // only need to check for mismatch of trailing slash</span>
<span class="line-modified"> 652             if (nlen &gt; 0 &amp;&amp;</span>
<span class="line-modified"> 653                 !name.isEmpty() &amp;&amp;</span>
<span class="line-modified"> 654                 zc.hasTrailingSlash(cen, pos + CENHDR + nlen) &amp;&amp;</span>
<span class="line-modified"> 655                 !name.endsWith(&quot;/&quot;))</span>
<span class="line-modified"> 656             {</span>
<span class="line-modified"> 657                 name += &#39;/&#39;;</span>
 658             }
<span class="line-added"> 659         } else {</span>
<span class="line-added"> 660             // invoked from iterator, use the entry name stored in cen</span>
<span class="line-added"> 661             name = zc.toString(cen, pos + CENHDR, nlen);</span>
 662         }
 663         ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
<span class="line-modified"> 664         e.flag = CENFLG(cen, pos);</span>
 665         e.xdostime = CENTIM(cen, pos);
 666         e.crc = CENCRC(cen, pos);
 667         e.size = CENLEN(cen, pos);
 668         e.csize = CENSIZ(cen, pos);
 669         e.method = CENHOW(cen, pos);
 670         if (elen != 0) {
 671             int start = pos + CENHDR + nlen;
 672             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
 673         }
 674         if (clen != 0) {
 675             int start = pos + CENHDR + nlen + elen;
<span class="line-modified"> 676             e.comment = zc.toString(cen, start, clen);</span>




 677         }
 678         lastEntryName = e.name;
 679         lastEntryPos = pos;
 680         return e;
 681     }
 682 
 683     /**
 684      * Returns the number of entries in the ZIP file.
 685      *
 686      * @return the number of entries in the ZIP file
 687      * @throws IllegalStateException if the zip file has been closed
 688      */
 689     public int size() {
 690         synchronized (this) {
 691             ensureOpen();
 692             return res.zsrc.total;
 693         }
 694     }
 695 
 696     private static class CleanableResource implements Runnable {
 697         // The outstanding inputstreams that need to be closed
 698         final Set&lt;InputStream&gt; istreams;
 699 
 700         // List of cached Inflater objects for decompression
 701         Deque&lt;Inflater&gt; inflaterCache;
 702 
 703         final Cleanable cleanable;
 704 
 705         Source zsrc;
 706 
<span class="line-modified"> 707         CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {</span>
 708             this.cleanable = CleanerFactory.cleaner().register(zf, this);
 709             this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
 710             this.inflaterCache = new ArrayDeque&lt;&gt;();
<span class="line-modified"> 711             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0, zc);</span>
 712         }
 713 
 714         void clean() {
 715             cleanable.clean();
 716         }
 717 
 718         /*
 719          * Gets an inflater from the list of available inflaters or allocates
 720          * a new one.
 721          */
 722         Inflater getInflater() {
 723             Inflater inf;
 724             synchronized (inflaterCache) {
 725                 if ((inf = inflaterCache.poll()) != null) {
 726                     return inf;
 727                 }
 728             }
 729             return new Inflater(true);
 730         }
 731 
</pre>
<hr />
<pre>
1079                 @Override
1080                 public Stream&lt;JarEntry&gt; stream(ZipFile zip,
1081                     Function&lt;String, JarEntry&gt; func) {
1082                     return zip.stream(func);
1083                 }
1084                 @Override
1085                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1086                     return zip.entryNameStream();
1087                 }
1088              }
1089         );
1090         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1091     }
1092 
1093     private static class Source {
1094         // &quot;META-INF/&quot;.length()
1095         private static final int META_INF_LENGTH = 9;
1096         private static final int[] EMPTY_META_VERSIONS = new int[0];
1097 
1098         private final Key key;               // the key in files
<span class="line-modified">1099         private final @Stable ZipCoder zc;   // zip coder used to decode/encode</span>
1100 
1101         private int refs = 1;
1102 
1103         private RandomAccessFile zfile;      // zfile of the underlying zip file
1104         private byte[] cen;                  // CEN &amp; ENDHDR
1105         private long locpos;                 // position of first LOC header (usually 0)
1106         private byte[] comment;              // zip file comment
1107                                              // list of meta entries in META-INF dir
1108         private int[] metanames;
1109         private int[] metaVersions;          // list of unique versions found in META-INF/versions/
1110         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1111 
1112         // A Hashmap for all entries.
1113         //
1114         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1115         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1116         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1117         // entry name and its offset {@code pos} in the central directory hdeader.
1118         //
1119         // private static class Entry {
</pre>
<hr />
<pre>
1378                                 return end;
1379                             }
1380                             // to use the end64 values
1381                             end.cenlen = cenlen64;
1382                             end.cenoff = cenoff64;
1383                             end.centot = (int)centot64; // assume total &lt; 2g
1384                             end.endpos = end64pos;
1385                         } catch (IOException x) {}    // no zip64 loc/end
1386                         return end;
1387                     }
1388                 }
1389             }
1390             zerror(&quot;zip END header not found&quot;);
1391             return null; //make compiler happy
1392         }
1393 
1394         // Reads zip file central directory.
1395         private void initCEN(int knownTotal) throws IOException {
1396             // Prefer locals for better performance during startup
1397             byte[] cen;


1398             if (knownTotal == -1) {
1399                 End end = findEND();
1400                 if (end.endpos == 0) {
1401                     locpos = 0;
1402                     total = 0;
1403                     entries = new int[0];
1404                     this.cen = null;
1405                     return;         // only END header present
1406                 }
1407                 if (end.cenlen &gt; end.endpos)
1408                     zerror(&quot;invalid END header (bad central directory size)&quot;);
1409                 long cenpos = end.endpos - end.cenlen;     // position of CEN table
1410                 // Get position of first local file (LOC) header, taking into
1411                 // account that there may be a stub prefixed to the zip file.
1412                 locpos = cenpos - end.cenoff;
1413                 if (locpos &lt; 0) {
1414                     zerror(&quot;invalid END header (bad central directory offset)&quot;);
1415                 }
1416                 // read in the CEN and END
1417                 cen = this.cen = new byte[(int)(end.cenlen + ENDHDR)];
</pre>
<hr />
<pre>
1452                 if (i &gt;= total) {
1453                     // This will only happen if the zip file has an incorrect
1454                     // ENDTOT field, which usually means it contains more than
1455                     // 65535 entries.
1456                     initCEN(countCENHeaders(cen, limit));
1457                     return;
1458                 }
1459                 if (CENSIG(cen, pos) != CENSIG)
1460                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1461                 int method = CENHOW(cen, pos);
1462                 int nlen   = CENNAM(cen, pos);
1463                 int elen   = CENEXT(cen, pos);
1464                 int clen   = CENCOM(cen, pos);
1465                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1466                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1467                 if (method != STORED &amp;&amp; method != DEFLATED)
1468                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1469                 if (entryPos + nlen &gt; limit)
1470                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1471                 // Record the CEN offset and the name hash in our hash cell.
<span class="line-modified">1472                 hash = zipCoderForPos(pos).normalizedHash(cen, entryPos, nlen);</span>
1473                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1474                 next = table[hsh];
1475                 table[hsh] = idx;
1476                 idx = addEntry(idx, hash, next, pos);
1477                 // Adds name to metanames.
1478                 if (isMetaName(cen, entryPos, nlen)) {
1479                     if (metanamesList == null)
1480                         metanamesList = new ArrayList&lt;&gt;(4);
1481                     metanamesList.add(pos);
1482 
1483                     // If this is a versioned entry, parse the version
1484                     // and store it for later. This optimizes lookup
1485                     // performance in multi-release jar files
1486                     int version = getMetaVersion(cen,
1487                         entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);
1488                     if (version &gt; 0) {
1489                         if (metaVersionsSet == null)
1490                             metaVersionsSet = new TreeSet&lt;&gt;();
1491                         metaVersionsSet.add(version);
1492                     }
</pre>
<hr />
<pre>
1508                 int c = 0;
1509                 for (Integer version : metaVersionsSet) {
1510                     metaVersions[c++] = version;
1511                 }
1512             } else {
1513                 metaVersions = EMPTY_META_VERSIONS;
1514             }
1515             if (pos + ENDHDR != cen.length) {
1516                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1517             }
1518         }
1519 
1520         private static void zerror(String msg) throws ZipException {
1521             throw new ZipException(msg);
1522         }
1523 
1524         /*
1525          * Returns the {@code pos} of the zip cen entry corresponding to the
1526          * specified entry name, or -1 if not found.
1527          */
<span class="line-modified">1528         private int getEntryPos(String name, boolean addSlash) {</span>
1529             if (total == 0) {
1530                 return -1;
1531             }
<span class="line-modified">1532 </span>
<span class="line-added">1533             int hsh = ZipCoder.normalizedHash(name);</span>
1534             int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1535 
1536             // Search down the target hash chain for a entry whose
1537             // 32 bit hash matches the hashed name.
1538             while (idx != ZIP_ENDCHAIN) {
1539                 if (getEntryHash(idx) == hsh) {
1540                     // The CEN name must match the specfied one
1541                     int pos = getEntryPos(idx);
<span class="line-modified">1542 </span>
<span class="line-modified">1543                     try {</span>
<span class="line-modified">1544                         ZipCoder zc = zipCoderForPos(pos);</span>
<span class="line-modified">1545                         String entry = zc.toString(cen, pos + CENHDR, CENNAM(cen, pos));</span>
<span class="line-modified">1546 </span>
<span class="line-modified">1547                         // If addSlash is true we&#39;ll test for name+/ in addition to</span>
<span class="line-modified">1548                         // name, unless name is the empty string or already ends with a</span>
<span class="line-modified">1549                         // slash</span>
<span class="line-modified">1550                         int entryLen = entry.length();</span>
<span class="line-modified">1551                         int nameLen = name.length();</span>
<span class="line-modified">1552                         if ((entryLen == nameLen &amp;&amp; entry.equals(name)) ||</span>
<span class="line-modified">1553                                 (addSlash &amp;&amp;</span>
<span class="line-modified">1554                                 nameLen + 1 == entryLen &amp;&amp;</span>
<span class="line-modified">1555                                 entry.startsWith(name) &amp;&amp;</span>
<span class="line-modified">1556                                 entry.charAt(entryLen - 1) == &#39;/&#39;)) {</span>
<span class="line-modified">1557                             return pos;</span>








1558                         }
<span class="line-added">1559                     } catch (IllegalArgumentException iae) {</span>
<span class="line-added">1560                         // Ignore</span>
1561                     }
1562                 }
1563                 idx = getEntryNext(idx);
1564             }
1565             return -1;
1566         }
1567 
<span class="line-added">1568         private ZipCoder zipCoderForPos(int pos) {</span>
<span class="line-added">1569             if (zc.isUTF8()) {</span>
<span class="line-added">1570                 return zc;</span>
<span class="line-added">1571             }</span>
<span class="line-added">1572             if ((CENFLG(cen, pos) &amp; USE_UTF8) != 0) {</span>
<span class="line-added">1573                 return ZipCoder.UTF8;</span>
<span class="line-added">1574             }</span>
<span class="line-added">1575             return zc;</span>
<span class="line-added">1576         }</span>
<span class="line-added">1577 </span>
1578         /**
1579          * Returns true if the bytes represent a non-directory name
1580          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1581          */
1582         private static boolean isMetaName(byte[] name, int off, int len) {
1583             // Use the &quot;oldest ASCII trick in the book&quot;
1584             return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()
1585                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1586                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1587                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1588                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1589                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1590                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1591                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1592                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1593                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1594                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1595         }
1596 
1597         /*
</pre>
</td>
</tr>
</table>
<center><a href="ZipCoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/loader/ClassLoaders.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipCoder.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/loader/ClassLoaders.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -90,11 +90,10 @@</span>
   */
  public class ZipFile implements ZipConstants, Closeable {
  
      private final String name;     // zip file name
      private volatile boolean closeRequested;
<span class="udiff-line-removed">-     private final @Stable ZipCoder zc;</span>
  
      // The &quot;resource&quot; used by this zip file that needs to be
      // cleaned after use.
      // a) the input streams that need to be closed
      // b) the list of cached Inflater objects
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -230,15 +229,14 @@</span>
                  sm.checkDelete(name);
              }
          }
          Objects.requireNonNull(charset, &quot;charset&quot;);
  
<span class="udiff-line-removed">-         this.zc = ZipCoder.get(charset);</span>
          this.name = name;
          long t0 = System.nanoTime();
  
<span class="udiff-line-modified-removed">-         this.res = new CleanableResource(this, file, mode);</span>
<span class="udiff-line-modified-added">+         this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);</span>
  
          PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
          PerfCounter.getZipFileCount().increment();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -305,11 +303,11 @@</span>
          synchronized (this) {
              ensureOpen();
              if (res.zsrc.comment == null) {
                  return null;
              }
<span class="udiff-line-modified-removed">-             return zc.toString(res.zsrc.comment);</span>
<span class="udiff-line-modified-added">+             return res.zsrc.zc.toString(res.zsrc.comment);</span>
          }
      }
  
      /**
       * Returns the zip file entry for the specified name, or null
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -336,22 +334,13 @@</span>
      private ZipEntry getEntry(String name, Function&lt;String, ? extends ZipEntry&gt; func) {
          Objects.requireNonNull(name, &quot;name&quot;);
          ZipEntry entry = null;
          synchronized (this) {
              ensureOpen();
<span class="udiff-line-modified-removed">-             byte[] bname = zc.getBytes(name);</span>
<span class="udiff-line-removed">-             int pos = res.zsrc.getEntryPos(bname, true);</span>
<span class="udiff-line-modified-added">+             int pos = res.zsrc.getEntryPos(name, true);</span>
              if (pos != -1) {
<span class="udiff-line-modified-removed">-                 entry = getZipEntry(name, bname, pos, func);</span>
<span class="udiff-line-removed">-             } else if (!zc.isUTF8() &amp;&amp; !name.isEmpty() &amp;&amp; !name.endsWith(&quot;/&quot;)) {</span>
<span class="udiff-line-removed">-                 // non-UTF-8 charsets need to lookup again with added slash</span>
<span class="udiff-line-removed">-                 name = name + &#39;/&#39;;</span>
<span class="udiff-line-removed">-                 bname = zc.getBytes(name);</span>
<span class="udiff-line-removed">-                 pos = res.zsrc.getEntryPos(bname, false);</span>
<span class="udiff-line-removed">-                 if (pos != -1) {</span>
<span class="udiff-line-removed">-                     entry = getZipEntry(name, bname, pos, func);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 entry = getZipEntry(name, pos, func);</span>
              }
          }
          return entry;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -369,22 +358,20 @@</span>
       * @throws IOException if an I/O error has occurred
       * @throws IllegalStateException if the zip file has been closed
       */
      public InputStream getInputStream(ZipEntry entry) throws IOException {
          Objects.requireNonNull(entry, &quot;entry&quot;);
<span class="udiff-line-modified-removed">-         int pos = -1;</span>
<span class="udiff-line-modified-added">+         int pos;</span>
          ZipFileInputStream in;
          Source zsrc = res.zsrc;
          Set&lt;InputStream&gt; istreams = res.istreams;
          synchronized (this) {
              ensureOpen();
              if (Objects.equals(lastEntryName, entry.name)) {
                  pos = lastEntryPos;
<span class="udiff-line-removed">-             } else if (!zc.isUTF8() &amp;&amp; (entry.flag &amp; USE_UTF8) != 0) {</span>
<span class="udiff-line-removed">-                 pos = zsrc.getEntryPos(zc.getBytesUTF8(entry.name), false);</span>
              } else {
<span class="udiff-line-modified-removed">-                 pos = zsrc.getEntryPos(zc.getBytes(entry.name), false);</span>
<span class="udiff-line-modified-added">+                 pos = zsrc.getEntryPos(entry.name, false);</span>
              }
              if (pos == -1) {
                  return null;
              }
              in = new ZipFileInputStream(zsrc.cen, pos);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -526,11 +513,11 @@</span>
                  ensureOpen();
                  if (!hasNext()) {
                      throw new NoSuchElementException();
                  }
                  // each &quot;entry&quot; has 3 ints in table entries
<span class="udiff-line-modified-removed">-                 return (T)getZipEntry(null, null, res.zsrc.getEntryPos(i++ * 3), gen);</span>
<span class="udiff-line-modified-added">+                 return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3), gen);</span>
              }
          }
  
          @Override
          public Iterator&lt;T&gt; asIterator() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -598,22 +585,19 @@</span>
       */
      public Stream&lt;? extends ZipEntry&gt; stream() {
          synchronized (this) {
              ensureOpen();
              return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="udiff-line-modified-removed">-                 pos -&gt; getZipEntry(null, null, pos, ZipEntry::new)), false);</span>
<span class="udiff-line-modified-added">+                 pos -&gt; getZipEntry(null, pos, ZipEntry::new)), false);</span>
         }
      }
  
      private String getEntryName(int pos) {
          byte[] cen = res.zsrc.cen;
          int nlen = CENNAM(cen, pos);
<span class="udiff-line-modified-removed">-         if (!zc.isUTF8() &amp;&amp; (CENFLG(cen, pos) &amp; USE_UTF8) != 0) {</span>
<span class="udiff-line-modified-removed">-             return zc.toStringUTF8(cen, pos + CENHDR, nlen);</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             return zc.toString(cen, pos + CENHDR, nlen);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         ZipCoder zc = res.zsrc.zipCoderForPos(pos);</span>
<span class="udiff-line-modified-added">+         return zc.toString(cen, pos + CENHDR, nlen);</span>
      }
  
      /*
       * Returns an ordered {@code Stream} over the zip file entry names.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -645,38 +629,41 @@</span>
       */
      private Stream&lt;JarEntry&gt; stream(Function&lt;String, JarEntry&gt; func) {
          synchronized (this) {
              ensureOpen();
              return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="udiff-line-modified-removed">-                 pos -&gt; (JarEntry)getZipEntry(null, null, pos, func)), false);</span>
<span class="udiff-line-modified-added">+                 pos -&gt; (JarEntry)getZipEntry(null, pos, func)), false);</span>
          }
      }
  
      private String lastEntryName;
      private int lastEntryPos;
  
<span class="udiff-line-modified-removed">-     /* Checks ensureOpen() before invoke this method */</span>
<span class="udiff-line-modified-removed">-     private ZipEntry getZipEntry(String name, byte[] bname, int pos,</span>
<span class="udiff-line-modified-added">+     /* Check ensureOpen() before invoking this method */</span>
<span class="udiff-line-modified-added">+     private ZipEntry getZipEntry(String name, int pos,</span>
                                   Function&lt;String, ? extends ZipEntry&gt; func) {
          byte[] cen = res.zsrc.cen;
          int nlen = CENNAM(cen, pos);
          int elen = CENEXT(cen, pos);
          int clen = CENCOM(cen, pos);
<span class="udiff-line-modified-removed">-         int flag = CENFLG(cen, pos);</span>
<span class="udiff-line-modified-removed">-         if (name == null || bname.length != nlen) {</span>
<span class="udiff-line-modified-removed">-             // to use the entry name stored in cen, if the passed in name is</span>
<span class="udiff-line-modified-removed">-             // (1) null, invoked from iterator, or</span>
<span class="udiff-line-modified-removed">-             // (2) not equal to the name stored, a slash is appended during</span>
<span class="udiff-line-modified-removed">-             // getEntryPos() search.</span>
<span class="udiff-line-modified-removed">-             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {</span>
<span class="udiff-line-modified-removed">-                 name = zc.toStringUTF8(cen, pos + CENHDR, nlen);</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 name = zc.toString(cen, pos + CENHDR, nlen);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         ZipCoder zc = res.zsrc.zipCoderForPos(pos);</span>
<span class="udiff-line-modified-added">+         if (name != null) {</span>
<span class="udiff-line-modified-added">+             // only need to check for mismatch of trailing slash</span>
<span class="udiff-line-modified-added">+             if (nlen &gt; 0 &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 !name.isEmpty() &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 zc.hasTrailingSlash(cen, pos + CENHDR + nlen) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 !name.endsWith(&quot;/&quot;))</span>
<span class="udiff-line-modified-added">+             {</span>
<span class="udiff-line-modified-added">+                 name += &#39;/&#39;;</span>
              }
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             // invoked from iterator, use the entry name stored in cen</span>
<span class="udiff-line-added">+             name = zc.toString(cen, pos + CENHDR, nlen);</span>
          }
          ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
<span class="udiff-line-modified-removed">-         e.flag = flag;</span>
<span class="udiff-line-modified-added">+         e.flag = CENFLG(cen, pos);</span>
          e.xdostime = CENTIM(cen, pos);
          e.crc = CENCRC(cen, pos);
          e.size = CENLEN(cen, pos);
          e.csize = CENSIZ(cen, pos);
          e.method = CENHOW(cen, pos);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -684,15 +671,11 @@</span>
              int start = pos + CENHDR + nlen;
              e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
          }
          if (clen != 0) {
              int start = pos + CENHDR + nlen + elen;
<span class="udiff-line-modified-removed">-             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {</span>
<span class="udiff-line-removed">-                 e.comment = zc.toStringUTF8(cen, start, clen);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 e.comment = zc.toString(cen, start, clen);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+             e.comment = zc.toString(cen, start, clen);</span>
          }
          lastEntryName = e.name;
          lastEntryPos = pos;
          return e;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -719,15 +702,15 @@</span>
  
          final Cleanable cleanable;
  
          Source zsrc;
  
<span class="udiff-line-modified-removed">-         CleanableResource(ZipFile zf, File file, int mode) throws IOException {</span>
<span class="udiff-line-modified-added">+         CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {</span>
              this.cleanable = CleanerFactory.cleaner().register(zf, this);
              this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
              this.inflaterCache = new ArrayDeque&lt;&gt;();
<span class="udiff-line-modified-removed">-             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0, zf.zc);</span>
<span class="udiff-line-modified-added">+             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0, zc);</span>
          }
  
          void clean() {
              cleanable.clean();
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1111,11 +1094,11 @@</span>
          // &quot;META-INF/&quot;.length()
          private static final int META_INF_LENGTH = 9;
          private static final int[] EMPTY_META_VERSIONS = new int[0];
  
          private final Key key;               // the key in files
<span class="udiff-line-modified-removed">-         private final ZipCoder zc;           // zip coder used to decode/encode</span>
<span class="udiff-line-modified-added">+         private final @Stable ZipCoder zc;   // zip coder used to decode/encode</span>
  
          private int refs = 1;
  
          private RandomAccessFile zfile;      // zfile of the underlying zip file
          private byte[] cen;                  // CEN &amp; ENDHDR
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1410,12 +1393,10 @@</span>
  
          // Reads zip file central directory.
          private void initCEN(int knownTotal) throws IOException {
              // Prefer locals for better performance during startup
              byte[] cen;
<span class="udiff-line-removed">-             ZipCoder zc = this.zc;</span>
<span class="udiff-line-removed">- </span>
              if (knownTotal == -1) {
                  End end = findEND();
                  if (end.endpos == 0) {
                      locpos = 0;
                      total = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1486,11 +1467,11 @@</span>
                  if (method != STORED &amp;&amp; method != DEFLATED)
                      zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
                  if (entryPos + nlen &gt; limit)
                      zerror(&quot;invalid CEN header (bad header size)&quot;);
                  // Record the CEN offset and the name hash in our hash cell.
<span class="udiff-line-modified-removed">-                 hash = zc.hashN(cen, entryPos, nlen);</span>
<span class="udiff-line-modified-added">+                 hash = zipCoderForPos(pos).normalizedHash(cen, entryPos, nlen);</span>
                  hsh = (hash &amp; 0x7fffffff) % tablelen;
                  next = table[hsh];
                  table[hsh] = idx;
                  idx = addEntry(idx, hash, next, pos);
                  // Adds name to metanames.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1542,55 +1523,60 @@</span>
  
          /*
           * Returns the {@code pos} of the zip cen entry corresponding to the
           * specified entry name, or -1 if not found.
           */
<span class="udiff-line-modified-removed">-         private int getEntryPos(byte[] name, boolean addSlash) {</span>
<span class="udiff-line-modified-added">+         private int getEntryPos(String name, boolean addSlash) {</span>
              if (total == 0) {
                  return -1;
              }
<span class="udiff-line-modified-removed">-             int hsh = zc.hashN(name, 0, name.length);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+             int hsh = ZipCoder.normalizedHash(name);</span>
              int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
  
              // Search down the target hash chain for a entry whose
              // 32 bit hash matches the hashed name.
              while (idx != ZIP_ENDCHAIN) {
                  if (getEntryHash(idx) == hsh) {
                      // The CEN name must match the specfied one
                      int pos = getEntryPos(idx);
<span class="udiff-line-modified-removed">-                     byte[] cen = this.cen;</span>
<span class="udiff-line-modified-removed">-                     final int nlen = CENNAM(cen, pos);</span>
<span class="udiff-line-modified-removed">-                     int nameoff = pos + CENHDR;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-                     // If addSlash is true and we&#39;re using the UTF-8 zip coder,</span>
<span class="udiff-line-modified-removed">-                     // we&#39;ll directly test for name+/ in addition to name,</span>
<span class="udiff-line-modified-removed">-                     // unless name is the empty string or already ends with a</span>
<span class="udiff-line-modified-removed">-                     // slash</span>
<span class="udiff-line-modified-removed">-                     if (name.length == nlen ||</span>
<span class="udiff-line-modified-removed">-                            (addSlash &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                             zc.isUTF8() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                             name.length &gt; 0 &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                             name.length + 1 == nlen &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                             cen[nameoff + nlen - 1] == &#39;/&#39; &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                             name[name.length - 1] != &#39;/&#39;)) {</span>
<span class="udiff-line-modified-removed">-                         boolean matched = true;</span>
<span class="udiff-line-removed">-                         for (int i = 0; i &lt; name.length; i++) {</span>
<span class="udiff-line-removed">-                             if (name[i] != cen[nameoff++]) {</span>
<span class="udiff-line-removed">-                                 matched = false;</span>
<span class="udiff-line-removed">-                                 break;</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         if (matched) {</span>
<span class="udiff-line-removed">-                            return pos;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                     try {</span>
<span class="udiff-line-modified-added">+                         ZipCoder zc = zipCoderForPos(pos);</span>
<span class="udiff-line-modified-added">+                         String entry = zc.toString(cen, pos + CENHDR, CENNAM(cen, pos));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                         // If addSlash is true we&#39;ll test for name+/ in addition to</span>
<span class="udiff-line-modified-added">+                         // name, unless name is the empty string or already ends with a</span>
<span class="udiff-line-modified-added">+                         // slash</span>
<span class="udiff-line-modified-added">+                         int entryLen = entry.length();</span>
<span class="udiff-line-modified-added">+                         int nameLen = name.length();</span>
<span class="udiff-line-modified-added">+                         if ((entryLen == nameLen &amp;&amp; entry.equals(name)) ||</span>
<span class="udiff-line-modified-added">+                                 (addSlash &amp;&amp;</span>
<span class="udiff-line-modified-added">+                                 nameLen + 1 == entryLen &amp;&amp;</span>
<span class="udiff-line-modified-added">+                                 entry.startsWith(name) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                                 entry.charAt(entryLen - 1) == &#39;/&#39;)) {</span>
<span class="udiff-line-modified-added">+                             return pos;</span>
                          }
<span class="udiff-line-added">+                     } catch (IllegalArgumentException iae) {</span>
<span class="udiff-line-added">+                         // Ignore</span>
                      }
                  }
                  idx = getEntryNext(idx);
              }
              return -1;
          }
  
<span class="udiff-line-added">+         private ZipCoder zipCoderForPos(int pos) {</span>
<span class="udiff-line-added">+             if (zc.isUTF8()) {</span>
<span class="udiff-line-added">+                 return zc;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if ((CENFLG(cen, pos) &amp; USE_UTF8) != 0) {</span>
<span class="udiff-line-added">+                 return ZipCoder.UTF8;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return zc;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          /**
           * Returns true if the bytes represent a non-directory name
           * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
           */
          private static boolean isMetaName(byte[] name, int off, int len) {
</pre>
<center><a href="ZipCoder.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/loader/ClassLoaders.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
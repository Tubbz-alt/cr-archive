diff a/src/java.base/share/classes/java/util/zip/ZipFile.java b/src/java.base/share/classes/java/util/zip/ZipFile.java
--- a/src/java.base/share/classes/java/util/zip/ZipFile.java
+++ b/src/java.base/share/classes/java/util/zip/ZipFile.java
@@ -90,11 +90,10 @@
  */
 public class ZipFile implements ZipConstants, Closeable {
 
     private final String name;     // zip file name
     private volatile boolean closeRequested;
-    private final @Stable ZipCoder zc;
 
     // The "resource" used by this zip file that needs to be
     // cleaned after use.
     // a) the input streams that need to be closed
     // b) the list of cached Inflater objects
@@ -230,15 +229,14 @@
                 sm.checkDelete(name);
             }
         }
         Objects.requireNonNull(charset, "charset");
 
-        this.zc = ZipCoder.get(charset);
         this.name = name;
         long t0 = System.nanoTime();
 
-        this.res = new CleanableResource(this, file, mode);
+        this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);
 
         PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
         PerfCounter.getZipFileCount().increment();
     }
 
@@ -305,11 +303,11 @@
         synchronized (this) {
             ensureOpen();
             if (res.zsrc.comment == null) {
                 return null;
             }
-            return zc.toString(res.zsrc.comment);
+            return res.zsrc.zc.toString(res.zsrc.comment);
         }
     }
 
     /**
      * Returns the zip file entry for the specified name, or null
@@ -336,22 +334,13 @@
     private ZipEntry getEntry(String name, Function<String, ? extends ZipEntry> func) {
         Objects.requireNonNull(name, "name");
         ZipEntry entry = null;
         synchronized (this) {
             ensureOpen();
-            byte[] bname = zc.getBytes(name);
-            int pos = res.zsrc.getEntryPos(bname, true);
+            int pos = res.zsrc.getEntryPos(name, true);
             if (pos != -1) {
-                entry = getZipEntry(name, bname, pos, func);
-            } else if (!zc.isUTF8() && !name.isEmpty() && !name.endsWith("/")) {
-                // non-UTF-8 charsets need to lookup again with added slash
-                name = name + '/';
-                bname = zc.getBytes(name);
-                pos = res.zsrc.getEntryPos(bname, false);
-                if (pos != -1) {
-                    entry = getZipEntry(name, bname, pos, func);
-                }
+                entry = getZipEntry(name, pos, func);
             }
         }
         return entry;
     }
 
@@ -369,22 +358,20 @@
      * @throws IOException if an I/O error has occurred
      * @throws IllegalStateException if the zip file has been closed
      */
     public InputStream getInputStream(ZipEntry entry) throws IOException {
         Objects.requireNonNull(entry, "entry");
-        int pos = -1;
+        int pos;
         ZipFileInputStream in;
         Source zsrc = res.zsrc;
         Set<InputStream> istreams = res.istreams;
         synchronized (this) {
             ensureOpen();
             if (Objects.equals(lastEntryName, entry.name)) {
                 pos = lastEntryPos;
-            } else if (!zc.isUTF8() && (entry.flag & USE_UTF8) != 0) {
-                pos = zsrc.getEntryPos(zc.getBytesUTF8(entry.name), false);
             } else {
-                pos = zsrc.getEntryPos(zc.getBytes(entry.name), false);
+                pos = zsrc.getEntryPos(entry.name, false);
             }
             if (pos == -1) {
                 return null;
             }
             in = new ZipFileInputStream(zsrc.cen, pos);
@@ -526,11 +513,11 @@
                 ensureOpen();
                 if (!hasNext()) {
                     throw new NoSuchElementException();
                 }
                 // each "entry" has 3 ints in table entries
-                return (T)getZipEntry(null, null, res.zsrc.getEntryPos(i++ * 3), gen);
+                return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3), gen);
             }
         }
 
         @Override
         public Iterator<T> asIterator() {
@@ -598,22 +585,19 @@
      */
     public Stream<? extends ZipEntry> stream() {
         synchronized (this) {
             ensureOpen();
             return StreamSupport.stream(new EntrySpliterator<>(0, res.zsrc.total,
-                pos -> getZipEntry(null, null, pos, ZipEntry::new)), false);
+                pos -> getZipEntry(null, pos, ZipEntry::new)), false);
        }
     }
 
     private String getEntryName(int pos) {
         byte[] cen = res.zsrc.cen;
         int nlen = CENNAM(cen, pos);
-        if (!zc.isUTF8() && (CENFLG(cen, pos) & USE_UTF8) != 0) {
-            return zc.toStringUTF8(cen, pos + CENHDR, nlen);
-        } else {
-            return zc.toString(cen, pos + CENHDR, nlen);
-        }
+        ZipCoder zc = res.zsrc.zipCoderForPos(pos);
+        return zc.toString(cen, pos + CENHDR, nlen);
     }
 
     /*
      * Returns an ordered {@code Stream} over the zip file entry names.
      *
@@ -645,38 +629,41 @@
      */
     private Stream<JarEntry> stream(Function<String, JarEntry> func) {
         synchronized (this) {
             ensureOpen();
             return StreamSupport.stream(new EntrySpliterator<>(0, res.zsrc.total,
-                pos -> (JarEntry)getZipEntry(null, null, pos, func)), false);
+                pos -> (JarEntry)getZipEntry(null, pos, func)), false);
         }
     }
 
     private String lastEntryName;
     private int lastEntryPos;
 
-    /* Checks ensureOpen() before invoke this method */
-    private ZipEntry getZipEntry(String name, byte[] bname, int pos,
+    /* Check ensureOpen() before invoking this method */
+    private ZipEntry getZipEntry(String name, int pos,
                                  Function<String, ? extends ZipEntry> func) {
         byte[] cen = res.zsrc.cen;
         int nlen = CENNAM(cen, pos);
         int elen = CENEXT(cen, pos);
         int clen = CENCOM(cen, pos);
-        int flag = CENFLG(cen, pos);
-        if (name == null || bname.length != nlen) {
-            // to use the entry name stored in cen, if the passed in name is
-            // (1) null, invoked from iterator, or
-            // (2) not equal to the name stored, a slash is appended during
-            // getEntryPos() search.
-            if (!zc.isUTF8() && (flag & USE_UTF8) != 0) {
-                name = zc.toStringUTF8(cen, pos + CENHDR, nlen);
-            } else {
-                name = zc.toString(cen, pos + CENHDR, nlen);
+
+        ZipCoder zc = res.zsrc.zipCoderForPos(pos);
+        if (name != null) {
+            // only need to check for mismatch of trailing slash
+            if (nlen > 0 &&
+                !name.isEmpty() &&
+                zc.hasTrailingSlash(cen, pos + CENHDR + nlen) &&
+                !name.endsWith("/"))
+            {
+                name += '/';
             }
+        } else {
+            // invoked from iterator, use the entry name stored in cen
+            name = zc.toString(cen, pos + CENHDR, nlen);
         }
         ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
-        e.flag = flag;
+        e.flag = CENFLG(cen, pos);
         e.xdostime = CENTIM(cen, pos);
         e.crc = CENCRC(cen, pos);
         e.size = CENLEN(cen, pos);
         e.csize = CENSIZ(cen, pos);
         e.method = CENHOW(cen, pos);
@@ -684,15 +671,11 @@
             int start = pos + CENHDR + nlen;
             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
         }
         if (clen != 0) {
             int start = pos + CENHDR + nlen + elen;
-            if (!zc.isUTF8() && (flag & USE_UTF8) != 0) {
-                e.comment = zc.toStringUTF8(cen, start, clen);
-            } else {
-                e.comment = zc.toString(cen, start, clen);
-            }
+            e.comment = zc.toString(cen, start, clen);
         }
         lastEntryName = e.name;
         lastEntryPos = pos;
         return e;
     }
@@ -719,15 +702,15 @@
 
         final Cleanable cleanable;
 
         Source zsrc;
 
-        CleanableResource(ZipFile zf, File file, int mode) throws IOException {
+        CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {
             this.cleanable = CleanerFactory.cleaner().register(zf, this);
             this.istreams = Collections.newSetFromMap(new WeakHashMap<>());
             this.inflaterCache = new ArrayDeque<>();
-            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zf.zc);
+            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zc);
         }
 
         void clean() {
             cleanable.clean();
         }
@@ -1111,11 +1094,11 @@
         // "META-INF/".length()
         private static final int META_INF_LENGTH = 9;
         private static final int[] EMPTY_META_VERSIONS = new int[0];
 
         private final Key key;               // the key in files
-        private final ZipCoder zc;           // zip coder used to decode/encode
+        private final @Stable ZipCoder zc;   // zip coder used to decode/encode
 
         private int refs = 1;
 
         private RandomAccessFile zfile;      // zfile of the underlying zip file
         private byte[] cen;                  // CEN & ENDHDR
@@ -1410,12 +1393,10 @@
 
         // Reads zip file central directory.
         private void initCEN(int knownTotal) throws IOException {
             // Prefer locals for better performance during startup
             byte[] cen;
-            ZipCoder zc = this.zc;
-
             if (knownTotal == -1) {
                 End end = findEND();
                 if (end.endpos == 0) {
                     locpos = 0;
                     total = 0;
@@ -1486,11 +1467,11 @@
                 if (method != STORED && method != DEFLATED)
                     zerror("invalid CEN header (bad compression method: " + method + ")");
                 if (entryPos + nlen > limit)
                     zerror("invalid CEN header (bad header size)");
                 // Record the CEN offset and the name hash in our hash cell.
-                hash = zc.hashN(cen, entryPos, nlen);
+                hash = zipCoderForPos(pos).normalizedHash(cen, entryPos, nlen);
                 hsh = (hash & 0x7fffffff) % tablelen;
                 next = table[hsh];
                 table[hsh] = idx;
                 idx = addEntry(idx, hash, next, pos);
                 // Adds name to metanames.
@@ -1542,55 +1523,60 @@
 
         /*
          * Returns the {@code pos} of the zip cen entry corresponding to the
          * specified entry name, or -1 if not found.
          */
-        private int getEntryPos(byte[] name, boolean addSlash) {
+        private int getEntryPos(String name, boolean addSlash) {
             if (total == 0) {
                 return -1;
             }
-            int hsh = zc.hashN(name, 0, name.length);
+
+            int hsh = ZipCoder.normalizedHash(name);
             int idx = table[(hsh & 0x7fffffff) % tablelen];
 
             // Search down the target hash chain for a entry whose
             // 32 bit hash matches the hashed name.
             while (idx != ZIP_ENDCHAIN) {
                 if (getEntryHash(idx) == hsh) {
                     // The CEN name must match the specfied one
                     int pos = getEntryPos(idx);
-                    byte[] cen = this.cen;
-                    final int nlen = CENNAM(cen, pos);
-                    int nameoff = pos + CENHDR;
-
-                    // If addSlash is true and we're using the UTF-8 zip coder,
-                    // we'll directly test for name+/ in addition to name,
-                    // unless name is the empty string or already ends with a
-                    // slash
-                    if (name.length == nlen ||
-                           (addSlash &&
-                            zc.isUTF8() &&
-                            name.length > 0 &&
-                            name.length + 1 == nlen &&
-                            cen[nameoff + nlen - 1] == '/' &&
-                            name[name.length - 1] != '/')) {
-                        boolean matched = true;
-                        for (int i = 0; i < name.length; i++) {
-                            if (name[i] != cen[nameoff++]) {
-                                matched = false;
-                                break;
-                            }
-                        }
-                        if (matched) {
-                           return pos;
+
+                    try {
+                        ZipCoder zc = zipCoderForPos(pos);
+                        String entry = zc.toString(cen, pos + CENHDR, CENNAM(cen, pos));
+
+                        // If addSlash is true we'll test for name+/ in addition to
+                        // name, unless name is the empty string or already ends with a
+                        // slash
+                        int entryLen = entry.length();
+                        int nameLen = name.length();
+                        if ((entryLen == nameLen && entry.equals(name)) ||
+                                (addSlash &&
+                                nameLen + 1 == entryLen &&
+                                entry.startsWith(name) &&
+                                entry.charAt(entryLen - 1) == '/')) {
+                            return pos;
                         }
+                    } catch (IllegalArgumentException iae) {
+                        // Ignore
                     }
                 }
                 idx = getEntryNext(idx);
             }
             return -1;
         }
 
+        private ZipCoder zipCoderForPos(int pos) {
+            if (zc.isUTF8()) {
+                return zc;
+            }
+            if ((CENFLG(cen, pos) & USE_UTF8) != 0) {
+                return ZipCoder.UTF8;
+            }
+            return zc;
+        }
+
         /**
          * Returns true if the bytes represent a non-directory name
          * beginning with "META-INF/", disregarding ASCII case.
          */
         private static boolean isMetaName(byte[] name, int off, int len) {

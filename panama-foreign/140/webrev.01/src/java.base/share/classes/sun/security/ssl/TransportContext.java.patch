diff a/src/java.base/share/classes/sun/security/ssl/TransportContext.java b/src/java.base/share/classes/sun/security/ssl/TransportContext.java
--- a/src/java.base/share/classes/sun/security/ssl/TransportContext.java
+++ b/src/java.base/share/classes/sun/security/ssl/TransportContext.java
@@ -236,11 +236,11 @@
     boolean isPostHandshakeContext() {
         return handshakeContext != null &&
                 (handshakeContext instanceof PostHandshakeContext);
     }
 
-    // Note: close_notify is delivered as a warning alert.
+    // Note: Don't use this method for close_nofity, use closeNotify() instead.
     void warning(Alert alert) {
         // For initial handshaking, don't send a warning alert message to peer
         // if handshaker has not started.
         if (isNegotiated || handshakeContext != null) {
             try {
@@ -252,10 +252,37 @@
                 }
             }
         }
     }
 
+    // Note: close_notify is delivered as a warning alert.
+    void closeNotify(boolean isUserCanceled) throws IOException {
+        // Socket transport is special because of the SO_LINGER impact.
+        if (transport instanceof SSLSocketImpl) {
+            ((SSLSocketImpl)transport).closeNotify(isUserCanceled);
+        } else {
+            // Need a lock here so that the user_canceled alert and the
+            // close_notify alert can be delivered together.
+            outputRecord.recordLock.lock();
+            try {
+                try {
+                    // send a user_canceled alert if needed.
+                    if (isUserCanceled) {
+                        warning(Alert.USER_CANCELED);
+                    }
+
+                    // send a close_notify alert
+                    warning(Alert.CLOSE_NOTIFY);
+                } finally {
+                    outputRecord.close();
+                }
+            } finally {
+                outputRecord.recordLock.unlock();
+            }
+        }
+    }
+
     SSLException fatal(Alert alert,
             String diagnostic) throws SSLException {
         return fatal(alert, diagnostic, null);
     }
 
@@ -499,21 +526,11 @@
                     }
                 }
             }
 
             if (needCloseNotify) {
-                outputRecord.recordLock.lock();
-                try {
-                    try {
-                        // send a close_notify alert
-                        warning(Alert.CLOSE_NOTIFY);
-                    } finally {
-                        outputRecord.close();
-                    }
-                } finally {
-                    outputRecord.recordLock.unlock();
-                }
+                closeNotify(false);
             }
         }
     }
 
     // Initiate a inbound close when the handshake is not started.
@@ -545,28 +562,11 @@
         if (!isNegotiated && (handshakeContext != null) && !peerUserCanceled) {
             // initial handshake
             useUserCanceled = true;
         }
 
-        // Need a lock here so that the user_canceled alert and the
-        // close_notify alert can be delivered together.
-        outputRecord.recordLock.lock();
-        try {
-            try {
-                // send a user_canceled alert if needed.
-                if (useUserCanceled) {
-                    warning(Alert.USER_CANCELED);
-                }
-
-                // send a close_notify alert
-                warning(Alert.CLOSE_NOTIFY);
-            } finally {
-                outputRecord.close();
-            }
-        } finally {
-            outputRecord.recordLock.unlock();
-        }
+        closeNotify(useUserCanceled);
     }
 
     // Note; HandshakeStatus.FINISHED status is retrieved in other places.
     HandshakeStatus getHandshakeStatus() {
         if (!outputRecord.isEmpty()) {

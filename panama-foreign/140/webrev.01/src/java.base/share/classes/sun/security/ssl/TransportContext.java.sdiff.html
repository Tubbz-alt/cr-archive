<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/TransportContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/cldr/CLDRLocaleProviderAdapter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/TransportContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
221                         new ClientHandshakeContext(sslContext, this) :
222                         new ServerHandshakeContext(sslContext, this);
223                 outputRecord.initHandshaker();
224             }
225         }
226 
227         // kickstart the handshake if needed
228         //
229         // Need no kickstart message on server side unless the connection
230         // has been established.
231         if(isNegotiated || sslConfig.isClientMode) {
232            handshakeContext.kickstart();
233         }
234     }
235 
236     boolean isPostHandshakeContext() {
237         return handshakeContext != null &amp;&amp;
238                 (handshakeContext instanceof PostHandshakeContext);
239     }
240 
<span class="line-modified">241     // Note: close_notify is delivered as a warning alert.</span>
242     void warning(Alert alert) {
243         // For initial handshaking, don&#39;t send a warning alert message to peer
244         // if handshaker has not started.
245         if (isNegotiated || handshakeContext != null) {
246             try {
247                 outputRecord.encodeAlert(Alert.Level.WARNING.level, alert.id);
248             } catch (IOException ioe) {
249                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
250                     SSLLogger.warning(
251                         &quot;Warning: failed to send warning alert &quot; + alert, ioe);
252                 }
253             }
254         }
255     }
256 



























257     SSLException fatal(Alert alert,
258             String diagnostic) throws SSLException {
259         return fatal(alert, diagnostic, null);
260     }
261 
262     SSLException fatal(Alert alert, Throwable cause) throws SSLException {
263         return fatal(alert, null, cause);
264     }
265 
266     SSLException fatal(Alert alert,
267             String diagnostic, Throwable cause) throws SSLException {
268         return fatal(alert, diagnostic, false, cause);
269     }
270 
271     // Note: close_notify is not delivered via fatal() methods.
272     SSLException fatal(Alert alert, String diagnostic,
273             boolean recvFatalAlert, Throwable cause) throws SSLException {
274         // If we&#39;ve already shutdown because of an error, there is nothing we
275         // can do except rethrow the exception.
276         //
</pre>
<hr />
<pre>
484 
485         // For TLS 1.2 and prior version, it is required to respond with
486         // a close_notify alert of its own and close down the connection
487         // immediately, discarding any pending writes.
488         if (!isOutboundClosed()) {
489             boolean needCloseNotify = SSLConfiguration.acknowledgeCloseNotify;
490             if (!needCloseNotify) {
491                 if (isNegotiated) {
492                     if (!protocolVersion.useTLS13PlusSpec()) {
493                         needCloseNotify = true;
494                     }
495                 } else if (handshakeContext != null) {  // initial handshake
496                     ProtocolVersion pv = handshakeContext.negotiatedProtocol;
497                     if (pv == null || (!pv.useTLS13PlusSpec())) {
498                         needCloseNotify = true;
499                     }
500                 }
501             }
502 
503             if (needCloseNotify) {
<span class="line-modified">504                 outputRecord.recordLock.lock();</span>
<span class="line-removed">505                 try {</span>
<span class="line-removed">506                     try {</span>
<span class="line-removed">507                         // send a close_notify alert</span>
<span class="line-removed">508                         warning(Alert.CLOSE_NOTIFY);</span>
<span class="line-removed">509                     } finally {</span>
<span class="line-removed">510                         outputRecord.close();</span>
<span class="line-removed">511                     }</span>
<span class="line-removed">512                 } finally {</span>
<span class="line-removed">513                     outputRecord.recordLock.unlock();</span>
<span class="line-removed">514                 }</span>
515             }
516         }
517     }
518 
519     // Initiate a inbound close when the handshake is not started.
520     private void initiateInboundClose() throws IOException {
521         if (!isInboundClosed()) {
522             inputRecord.close();
523         }
524     }
525 
526     // Close outbound, no more data should be received from the underlying
527     // transportation connection.
528     void closeOutbound() {
529         if (isOutboundClosed()) {
530             return;
531         }
532 
533         try {
534              initiateOutboundClose();
535         } catch (IOException ioe) {
536             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
537                 SSLLogger.warning(&quot;outbound closure failed&quot;, ioe);
538             }
539         }
540     }
541 
542     // Initiate a close by sending a close_notify alert.
543     private void initiateOutboundClose() throws IOException {
544         boolean useUserCanceled = false;
545         if (!isNegotiated &amp;&amp; (handshakeContext != null) &amp;&amp; !peerUserCanceled) {
546             // initial handshake
547             useUserCanceled = true;
548         }
549 
<span class="line-modified">550         // Need a lock here so that the user_canceled alert and the</span>
<span class="line-removed">551         // close_notify alert can be delivered together.</span>
<span class="line-removed">552         outputRecord.recordLock.lock();</span>
<span class="line-removed">553         try {</span>
<span class="line-removed">554             try {</span>
<span class="line-removed">555                 // send a user_canceled alert if needed.</span>
<span class="line-removed">556                 if (useUserCanceled) {</span>
<span class="line-removed">557                     warning(Alert.USER_CANCELED);</span>
<span class="line-removed">558                 }</span>
<span class="line-removed">559 </span>
<span class="line-removed">560                 // send a close_notify alert</span>
<span class="line-removed">561                 warning(Alert.CLOSE_NOTIFY);</span>
<span class="line-removed">562             } finally {</span>
<span class="line-removed">563                 outputRecord.close();</span>
<span class="line-removed">564             }</span>
<span class="line-removed">565         } finally {</span>
<span class="line-removed">566             outputRecord.recordLock.unlock();</span>
<span class="line-removed">567         }</span>
568     }
569 
570     // Note; HandshakeStatus.FINISHED status is retrieved in other places.
571     HandshakeStatus getHandshakeStatus() {
572         if (!outputRecord.isEmpty()) {
573             // If no handshaking, special case to wrap alters or
574             // post-handshake messages.
575             return HandshakeStatus.NEED_WRAP;
576         } else if (isOutboundClosed() &amp;&amp; isInboundClosed()) {
577             return HandshakeStatus.NOT_HANDSHAKING;
578         } else if (handshakeContext != null) {
579             if (!handshakeContext.delegatedActions.isEmpty()) {
580                 return HandshakeStatus.NEED_TASK;
581             } else if (!isInboundClosed()) {
582                 if (sslContext.isDTLS() &amp;&amp;
583                         !inputRecord.isEmpty()) {
584                     return HandshakeStatus.NEED_UNWRAP_AGAIN;
585                 } else {
586                     return HandshakeStatus.NEED_UNWRAP;
587                 }
</pre>
</td>
<td>
<hr />
<pre>
221                         new ClientHandshakeContext(sslContext, this) :
222                         new ServerHandshakeContext(sslContext, this);
223                 outputRecord.initHandshaker();
224             }
225         }
226 
227         // kickstart the handshake if needed
228         //
229         // Need no kickstart message on server side unless the connection
230         // has been established.
231         if(isNegotiated || sslConfig.isClientMode) {
232            handshakeContext.kickstart();
233         }
234     }
235 
236     boolean isPostHandshakeContext() {
237         return handshakeContext != null &amp;&amp;
238                 (handshakeContext instanceof PostHandshakeContext);
239     }
240 
<span class="line-modified">241     // Note: Don&#39;t use this method for close_nofity, use closeNotify() instead.</span>
242     void warning(Alert alert) {
243         // For initial handshaking, don&#39;t send a warning alert message to peer
244         // if handshaker has not started.
245         if (isNegotiated || handshakeContext != null) {
246             try {
247                 outputRecord.encodeAlert(Alert.Level.WARNING.level, alert.id);
248             } catch (IOException ioe) {
249                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
250                     SSLLogger.warning(
251                         &quot;Warning: failed to send warning alert &quot; + alert, ioe);
252                 }
253             }
254         }
255     }
256 
<span class="line-added">257     // Note: close_notify is delivered as a warning alert.</span>
<span class="line-added">258     void closeNotify(boolean isUserCanceled) throws IOException {</span>
<span class="line-added">259         // Socket transport is special because of the SO_LINGER impact.</span>
<span class="line-added">260         if (transport instanceof SSLSocketImpl) {</span>
<span class="line-added">261             ((SSLSocketImpl)transport).closeNotify(isUserCanceled);</span>
<span class="line-added">262         } else {</span>
<span class="line-added">263             // Need a lock here so that the user_canceled alert and the</span>
<span class="line-added">264             // close_notify alert can be delivered together.</span>
<span class="line-added">265             outputRecord.recordLock.lock();</span>
<span class="line-added">266             try {</span>
<span class="line-added">267                 try {</span>
<span class="line-added">268                     // send a user_canceled alert if needed.</span>
<span class="line-added">269                     if (isUserCanceled) {</span>
<span class="line-added">270                         warning(Alert.USER_CANCELED);</span>
<span class="line-added">271                     }</span>
<span class="line-added">272 </span>
<span class="line-added">273                     // send a close_notify alert</span>
<span class="line-added">274                     warning(Alert.CLOSE_NOTIFY);</span>
<span class="line-added">275                 } finally {</span>
<span class="line-added">276                     outputRecord.close();</span>
<span class="line-added">277                 }</span>
<span class="line-added">278             } finally {</span>
<span class="line-added">279                 outputRecord.recordLock.unlock();</span>
<span class="line-added">280             }</span>
<span class="line-added">281         }</span>
<span class="line-added">282     }</span>
<span class="line-added">283 </span>
284     SSLException fatal(Alert alert,
285             String diagnostic) throws SSLException {
286         return fatal(alert, diagnostic, null);
287     }
288 
289     SSLException fatal(Alert alert, Throwable cause) throws SSLException {
290         return fatal(alert, null, cause);
291     }
292 
293     SSLException fatal(Alert alert,
294             String diagnostic, Throwable cause) throws SSLException {
295         return fatal(alert, diagnostic, false, cause);
296     }
297 
298     // Note: close_notify is not delivered via fatal() methods.
299     SSLException fatal(Alert alert, String diagnostic,
300             boolean recvFatalAlert, Throwable cause) throws SSLException {
301         // If we&#39;ve already shutdown because of an error, there is nothing we
302         // can do except rethrow the exception.
303         //
</pre>
<hr />
<pre>
511 
512         // For TLS 1.2 and prior version, it is required to respond with
513         // a close_notify alert of its own and close down the connection
514         // immediately, discarding any pending writes.
515         if (!isOutboundClosed()) {
516             boolean needCloseNotify = SSLConfiguration.acknowledgeCloseNotify;
517             if (!needCloseNotify) {
518                 if (isNegotiated) {
519                     if (!protocolVersion.useTLS13PlusSpec()) {
520                         needCloseNotify = true;
521                     }
522                 } else if (handshakeContext != null) {  // initial handshake
523                     ProtocolVersion pv = handshakeContext.negotiatedProtocol;
524                     if (pv == null || (!pv.useTLS13PlusSpec())) {
525                         needCloseNotify = true;
526                     }
527                 }
528             }
529 
530             if (needCloseNotify) {
<span class="line-modified">531                 closeNotify(false);</span>










532             }
533         }
534     }
535 
536     // Initiate a inbound close when the handshake is not started.
537     private void initiateInboundClose() throws IOException {
538         if (!isInboundClosed()) {
539             inputRecord.close();
540         }
541     }
542 
543     // Close outbound, no more data should be received from the underlying
544     // transportation connection.
545     void closeOutbound() {
546         if (isOutboundClosed()) {
547             return;
548         }
549 
550         try {
551              initiateOutboundClose();
552         } catch (IOException ioe) {
553             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
554                 SSLLogger.warning(&quot;outbound closure failed&quot;, ioe);
555             }
556         }
557     }
558 
559     // Initiate a close by sending a close_notify alert.
560     private void initiateOutboundClose() throws IOException {
561         boolean useUserCanceled = false;
562         if (!isNegotiated &amp;&amp; (handshakeContext != null) &amp;&amp; !peerUserCanceled) {
563             // initial handshake
564             useUserCanceled = true;
565         }
566 
<span class="line-modified">567         closeNotify(useUserCanceled);</span>

















568     }
569 
570     // Note; HandshakeStatus.FINISHED status is retrieved in other places.
571     HandshakeStatus getHandshakeStatus() {
572         if (!outputRecord.isEmpty()) {
573             // If no handshaking, special case to wrap alters or
574             // post-handshake messages.
575             return HandshakeStatus.NEED_WRAP;
576         } else if (isOutboundClosed() &amp;&amp; isInboundClosed()) {
577             return HandshakeStatus.NOT_HANDSHAKING;
578         } else if (handshakeContext != null) {
579             if (!handshakeContext.delegatedActions.isEmpty()) {
580                 return HandshakeStatus.NEED_TASK;
581             } else if (!isInboundClosed()) {
582                 if (sslContext.isDTLS() &amp;&amp;
583                         !inputRecord.isEmpty()) {
584                     return HandshakeStatus.NEED_UNWRAP_AGAIN;
585                 } else {
586                     return HandshakeStatus.NEED_UNWRAP;
587                 }
</pre>
</td>
</tr>
</table>
<center><a href="SSLSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/cldr/CLDRLocaleProviderAdapter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
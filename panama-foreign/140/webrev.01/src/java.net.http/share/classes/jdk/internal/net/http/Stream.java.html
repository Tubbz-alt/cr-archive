<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.net.http/share/classes/jdk/internal/net/http/Stream.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.net.http;
  27 
  28 import java.io.EOFException;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.net.URI;
  32 import java.nio.ByteBuffer;
  33 import java.util.ArrayList;
  34 import java.util.Collections;
  35 import java.util.List;
  36 import java.util.concurrent.CompletableFuture;
  37 import java.util.concurrent.ConcurrentLinkedDeque;
  38 import java.util.concurrent.ConcurrentLinkedQueue;
  39 import java.util.concurrent.Executor;
  40 import java.util.concurrent.Flow;
  41 import java.util.concurrent.Flow.Subscription;
  42 import java.util.concurrent.atomic.AtomicBoolean;
  43 import java.util.concurrent.atomic.AtomicReference;
  44 import java.util.function.BiPredicate;
  45 import java.net.http.HttpClient;
  46 import java.net.http.HttpHeaders;
  47 import java.net.http.HttpRequest;
  48 import java.net.http.HttpResponse;
  49 import java.net.http.HttpResponse.BodySubscriber;
  50 import jdk.internal.net.http.common.*;
  51 import jdk.internal.net.http.frame.*;
  52 import jdk.internal.net.http.hpack.DecodingCallback;
  53 
  54 /**
  55  * Http/2 Stream handling.
  56  *
  57  * REQUESTS
  58  *
  59  * sendHeadersOnly() -- assembles HEADERS frame and puts on connection outbound Q
  60  *
  61  * sendRequest() -- sendHeadersOnly() + sendBody()
  62  *
  63  * sendBodyAsync() -- calls sendBody() in an executor thread.
  64  *
  65  * sendHeadersAsync() -- calls sendHeadersOnly() which does not block
  66  *
  67  * sendRequestAsync() -- calls sendRequest() in an executor thread
  68  *
  69  * RESPONSES
  70  *
  71  * Multiple responses can be received per request. Responses are queued up on
  72  * a LinkedList of CF&lt;HttpResponse&gt; and the first one on the list is completed
  73  * with the next response
  74  *
  75  * getResponseAsync() -- queries list of response CFs and returns first one
  76  *               if one exists. Otherwise, creates one and adds it to list
  77  *               and returns it. Completion is achieved through the
  78  *               incoming() upcall from connection reader thread.
  79  *
  80  * getResponse() -- calls getResponseAsync() and waits for CF to complete
  81  *
  82  * responseBodyAsync() -- calls responseBody() in an executor thread.
  83  *
  84  * incoming() -- entry point called from connection reader thread. Frames are
  85  *               either handled immediately without blocking or for data frames
  86  *               placed on the stream&#39;s inputQ which is consumed by the stream&#39;s
  87  *               reader thread.
  88  *
  89  * PushedStream sub class
  90  * ======================
  91  * Sending side methods are not used because the request comes from a PUSH_PROMISE
  92  * frame sent by the server. When a PUSH_PROMISE is received the PushedStream
  93  * is created. PushedStream does not use responseCF list as there can be only
  94  * one response. The CF is created when the object created and when the response
  95  * HEADERS frame is received the object is completed.
  96  */
  97 class Stream&lt;T&gt; extends ExchangeImpl&lt;T&gt; {
  98 
  99     final Logger debug = Utils.getDebugLogger(this::dbgString, Utils.DEBUG);
 100 
 101     final ConcurrentLinkedQueue&lt;Http2Frame&gt; inputQ = new ConcurrentLinkedQueue&lt;&gt;();
 102     final SequentialScheduler sched =
 103             SequentialScheduler.synchronizedScheduler(this::schedule);
 104     final SubscriptionBase userSubscription =
 105             new SubscriptionBase(sched, this::cancel, this::onSubscriptionError);
 106 
 107     /**
 108      * This stream&#39;s identifier. Assigned lazily by the HTTP2Connection before
 109      * the stream&#39;s first frame is sent.
 110      */
 111     protected volatile int streamid;
 112 
 113     long requestContentLen;
 114 
 115     final Http2Connection connection;
 116     final HttpRequestImpl request;
 117     final HeadersConsumer rspHeadersConsumer;
 118     final HttpHeadersBuilder responseHeadersBuilder;
 119     final HttpHeaders requestPseudoHeaders;
 120     volatile HttpResponse.BodySubscriber&lt;T&gt; responseSubscriber;
 121     final HttpRequest.BodyPublisher requestPublisher;
 122     volatile RequestSubscriber requestSubscriber;
 123     volatile int responseCode;
 124     volatile Response response;
 125     // The exception with which this stream was canceled.
 126     private final AtomicReference&lt;Throwable&gt; errorRef = new AtomicReference&lt;&gt;();
 127     final CompletableFuture&lt;Void&gt; requestBodyCF = new MinimalFuture&lt;&gt;();
 128     volatile CompletableFuture&lt;T&gt; responseBodyCF;
 129     volatile HttpResponse.BodySubscriber&lt;T&gt; pendingResponseSubscriber;
 130     volatile boolean stopRequested;
 131 
 132     /** True if END_STREAM has been seen in a frame received on this stream. */
 133     private volatile boolean remotelyClosed;
 134     private volatile boolean closed;
 135     private volatile boolean endStreamSent;
 136 
 137     final AtomicBoolean deRegistered = new AtomicBoolean(false);
 138 
 139     // state flags
 140     private boolean requestSent, responseReceived;
 141 
 142     /**
 143      * A reference to this Stream&#39;s connection Send Window controller. The
 144      * stream MUST acquire the appropriate amount of Send Window before
 145      * sending any data. Will be null for PushStreams, as they cannot send data.
 146      */
 147     private final WindowController windowController;
 148     private final WindowUpdateSender windowUpdater;
 149 
 150     @Override
 151     HttpConnection connection() {
 152         return connection.connection;
 153     }
 154 
 155     /**
 156      * Invoked either from incoming() -&gt; {receiveDataFrame() or receiveResetFrame() }
 157      * of after user subscription window has re-opened, from SubscriptionBase.request()
 158      */
 159     private void schedule() {
 160         boolean onCompleteCalled = false;
 161         HttpResponse.BodySubscriber&lt;T&gt; subscriber = responseSubscriber;
 162         try {
 163             if (subscriber == null) {
 164                 subscriber = responseSubscriber = pendingResponseSubscriber;
 165                 if (subscriber == null) {
 166                     // can&#39;t process anything yet
 167                     return;
 168                 } else {
 169                     if (debug.on()) debug.log(&quot;subscribing user subscriber&quot;);
 170                     subscriber.onSubscribe(userSubscription);
 171                 }
 172             }
 173             while (!inputQ.isEmpty()) {
 174                 Http2Frame frame = inputQ.peek();
 175                 if (frame instanceof ResetFrame) {
 176                     inputQ.remove();
 177                     handleReset((ResetFrame)frame, subscriber);
 178                     return;
 179                 }
 180                 DataFrame df = (DataFrame)frame;
 181                 boolean finished = df.getFlag(DataFrame.END_STREAM);
 182 
 183                 List&lt;ByteBuffer&gt; buffers = df.getData();
 184                 List&lt;ByteBuffer&gt; dsts = Collections.unmodifiableList(buffers);
 185                 int size = Utils.remaining(dsts, Integer.MAX_VALUE);
 186                 if (size == 0 &amp;&amp; finished) {
 187                     inputQ.remove();
 188                     connection.ensureWindowUpdated(df); // must update connection window
 189                     Log.logTrace(&quot;responseSubscriber.onComplete&quot;);
 190                     if (debug.on()) debug.log(&quot;incoming: onComplete&quot;);
 191                     sched.stop();
 192                     connection.decrementStreamsCount(streamid);
 193                     subscriber.onComplete();
 194                     onCompleteCalled = true;
 195                     setEndStreamReceived();
 196                     return;
 197                 } else if (userSubscription.tryDecrement()) {
 198                     inputQ.remove();
 199                     Log.logTrace(&quot;responseSubscriber.onNext {0}&quot;, size);
 200                     if (debug.on()) debug.log(&quot;incoming: onNext(%d)&quot;, size);
 201                     try {
 202                         subscriber.onNext(dsts);
 203                     } catch (Throwable t) {
 204                         connection.dropDataFrame(df); // must update connection window
 205                         throw t;
 206                     }
 207                     if (consumed(df)) {
 208                         Log.logTrace(&quot;responseSubscriber.onComplete&quot;);
 209                         if (debug.on()) debug.log(&quot;incoming: onComplete&quot;);
 210                         sched.stop();
 211                         connection.decrementStreamsCount(streamid);
 212                         subscriber.onComplete();
 213                         onCompleteCalled = true;
 214                         setEndStreamReceived();
 215                         return;
 216                     }
 217                 } else {
 218                     if (stopRequested) break;
 219                     return;
 220                 }
 221             }
 222         } catch (Throwable throwable) {
 223             errorRef.compareAndSet(null, throwable);
 224         } finally {
 225             if (sched.isStopped()) drainInputQueue();
 226         }
 227 
 228         Throwable t = errorRef.get();
 229         if (t != null) {
 230             sched.stop();
 231             try {
 232                 if (!onCompleteCalled) {
 233                     if (debug.on())
 234                         debug.log(&quot;calling subscriber.onError: %s&quot;, (Object) t);
 235                     subscriber.onError(t);
 236                 } else {
 237                     if (debug.on())
 238                         debug.log(&quot;already completed: dropping error %s&quot;, (Object) t);
 239                 }
 240             } catch (Throwable x) {
 241                 Log.logError(&quot;Subscriber::onError threw exception: {0}&quot;, (Object) t);
 242             } finally {
 243                 cancelImpl(t);
 244                 drainInputQueue();
 245             }
 246         }
 247     }
 248 
 249     // must only be called from the scheduler schedule() loop.
 250     // ensure that all received data frames are accounted for
 251     // in the connection window flow control if the scheduler
 252     // is stopped before all the data is consumed.
 253     private void drainInputQueue() {
 254         Http2Frame frame;
 255         while ((frame = inputQ.poll()) != null) {
 256             if (frame instanceof DataFrame) {
 257                 connection.dropDataFrame((DataFrame)frame);
 258             }
 259         }
 260     }
 261 
 262     @Override
 263     void nullBody(HttpResponse&lt;T&gt; resp, Throwable t) {
 264         if (debug.on()) debug.log(&quot;nullBody: streamid=%d&quot;, streamid);
 265         // We should have an END_STREAM data frame waiting in the inputQ.
 266         // We need a subscriber to force the scheduler to process it.
 267         pendingResponseSubscriber = HttpResponse.BodySubscribers.replacing(null);
 268         sched.runOrSchedule();
 269     }
 270 
 271     // Callback invoked after the Response BodySubscriber has consumed the
 272     // buffers contained in a DataFrame.
 273     // Returns true if END_STREAM is reached, false otherwise.
 274     private boolean consumed(DataFrame df) {
 275         // RFC 7540 6.1:
 276         // The entire DATA frame payload is included in flow control,
 277         // including the Pad Length and Padding fields if present
 278         int len = df.payloadLength();
 279         boolean endStream = df.getFlag(DataFrame.END_STREAM);
 280         if (len == 0) return endStream;
 281 
 282         connection.windowUpdater.update(len);
 283 
 284         if (!endStream) {
 285             // Don&#39;t send window update on a stream which is
 286             // closed or half closed.
 287             windowUpdater.update(len);
 288         }
 289 
 290         // true: end of stream; false: more data coming
 291         return endStream;
 292     }
 293 
 294     boolean deRegister() {
 295         return deRegistered.compareAndSet(false, true);
 296     }
 297 
 298     @Override
 299     CompletableFuture&lt;T&gt; readBodyAsync(HttpResponse.BodyHandler&lt;T&gt; handler,
 300                                        boolean returnConnectionToPool,
 301                                        Executor executor)
 302     {
 303         try {
 304             Log.logTrace(&quot;Reading body on stream {0}&quot;, streamid);
 305             debug.log(&quot;Getting BodySubscriber for: &quot; + response);
 306             BodySubscriber&lt;T&gt; bodySubscriber = handler.apply(new ResponseInfoImpl(response));
 307             CompletableFuture&lt;T&gt; cf = receiveData(bodySubscriber, executor);
 308 
 309             PushGroup&lt;?&gt; pg = exchange.getPushGroup();
 310             if (pg != null) {
 311                 // if an error occurs make sure it is recorded in the PushGroup
 312                 cf = cf.whenComplete((t, e) -&gt; pg.pushError(e));
 313             }
 314             return cf;
 315         } catch (Throwable t) {
 316             // may be thrown by handler.apply
 317             cancelImpl(t);
 318             return MinimalFuture.failedFuture(t);
 319         }
 320     }
 321 
 322     @Override
 323     public String toString() {
 324         StringBuilder sb = new StringBuilder();
 325         sb.append(&quot;streamid: &quot;)
 326                 .append(streamid);
 327         return sb.toString();
 328     }
 329 
 330     private void receiveDataFrame(DataFrame df) {
 331         inputQ.add(df);
 332         sched.runOrSchedule();
 333     }
 334 
 335     /** Handles a RESET frame. RESET is always handled inline in the queue. */
 336     private void receiveResetFrame(ResetFrame frame) {
 337         inputQ.add(frame);
 338         sched.runOrSchedule();
 339     }
 340 
 341     // pushes entire response body into response subscriber
 342     // blocking when required by local or remote flow control
 343     CompletableFuture&lt;T&gt; receiveData(BodySubscriber&lt;T&gt; bodySubscriber, Executor executor) {
 344         // We want to allow the subscriber&#39;s getBody() method to block so it
 345         // can work with InputStreams. So, we offload execution.
 346         responseBodyCF = ResponseSubscribers.getBodyAsync(executor, bodySubscriber,
 347                 new MinimalFuture&lt;&gt;(), this::cancelImpl);
 348 
 349         if (isCanceled()) {
 350             Throwable t = getCancelCause();
 351             responseBodyCF.completeExceptionally(t);
 352         } else {
 353             pendingResponseSubscriber = bodySubscriber;
 354             sched.runOrSchedule(); // in case data waiting already to be processed
 355         }
 356         return responseBodyCF;
 357     }
 358 
 359     @Override
 360     CompletableFuture&lt;ExchangeImpl&lt;T&gt;&gt; sendBodyAsync() {
 361         return sendBodyImpl().thenApply( v -&gt; this);
 362     }
 363 
 364     @SuppressWarnings(&quot;unchecked&quot;)
 365     Stream(Http2Connection connection,
 366            Exchange&lt;T&gt; e,
 367            WindowController windowController)
 368     {
 369         super(e);
 370         this.connection = connection;
 371         this.windowController = windowController;
 372         this.request = e.request();
 373         this.requestPublisher = request.requestPublisher;  // may be null
 374         this.responseHeadersBuilder = new HttpHeadersBuilder();
 375         this.rspHeadersConsumer = new HeadersConsumer();
 376         this.requestPseudoHeaders = createPseudoHeaders(request);
 377         this.windowUpdater = new StreamWindowUpdateSender(connection);
 378     }
 379 
 380     /**
 381      * Entry point from Http2Connection reader thread.
 382      *
 383      * Data frames will be removed by response body thread.
 384      */
 385     void incoming(Http2Frame frame) throws IOException {
 386         if (debug.on()) debug.log(&quot;incoming: %s&quot;, frame);
 387         if ((frame instanceof HeaderFrame)) {
 388             HeaderFrame hframe = (HeaderFrame)frame;
 389             if (hframe.endHeaders()) {
 390                 Log.logTrace(&quot;handling response (streamid={0})&quot;, streamid);
 391                 handleResponse();
 392             }
 393             if (hframe.getFlag(HeaderFrame.END_STREAM)) {
 394                 if (debug.on()) debug.log(&quot;handling END_STREAM: %d&quot;, streamid);
 395                 receiveDataFrame(new DataFrame(streamid, DataFrame.END_STREAM, List.of()));
 396             }
 397         } else if (frame instanceof DataFrame) {
 398             receiveDataFrame((DataFrame)frame);
 399         } else {
 400             otherFrame(frame);
 401         }
 402     }
 403 
 404     void otherFrame(Http2Frame frame) throws IOException {
 405         switch (frame.type()) {
 406             case WindowUpdateFrame.TYPE:
 407                 incoming_windowUpdate((WindowUpdateFrame) frame);
 408                 break;
 409             case ResetFrame.TYPE:
 410                 incoming_reset((ResetFrame) frame);
 411                 break;
 412             case PriorityFrame.TYPE:
 413                 incoming_priority((PriorityFrame) frame);
 414                 break;
 415             default:
 416                 String msg = &quot;Unexpected frame: &quot; + frame.toString();
 417                 throw new IOException(msg);
 418         }
 419     }
 420 
 421     // The Hpack decoder decodes into one of these consumers of name,value pairs
 422 
 423     DecodingCallback rspHeadersConsumer() {
 424         return rspHeadersConsumer;
 425     }
 426 
 427     protected void handleResponse() throws IOException {
 428         HttpHeaders responseHeaders = responseHeadersBuilder.build();
 429         responseCode = (int)responseHeaders
 430                 .firstValueAsLong(&quot;:status&quot;)
 431                 .orElseThrow(() -&gt; new IOException(&quot;no statuscode in response&quot;));
 432 
 433         response = new Response(
 434                 request, exchange, responseHeaders, connection(),
 435                 responseCode, HttpClient.Version.HTTP_2);
 436 
 437         /* TODO: review if needs to be removed
 438            the value is not used, but in case `content-length` doesn&#39;t parse as
 439            long, there will be NumberFormatException. If left as is, make sure
 440            code up the stack handles NFE correctly. */
 441         responseHeaders.firstValueAsLong(&quot;content-length&quot;);
 442 
 443         if (Log.headers()) {
 444             StringBuilder sb = new StringBuilder(&quot;RESPONSE HEADERS:\n&quot;);
 445             Log.dumpHeaders(sb, &quot;    &quot;, responseHeaders);
 446             Log.logHeaders(sb.toString());
 447         }
 448 
 449         // this will clear the response headers
 450         rspHeadersConsumer.reset();
 451 
 452         completeResponse(response);
 453     }
 454 
 455     void incoming_reset(ResetFrame frame) {
 456         Log.logTrace(&quot;Received RST_STREAM on stream {0}&quot;, streamid);
 457         if (endStreamReceived()) {
 458             Log.logTrace(&quot;Ignoring RST_STREAM frame received on remotely closed stream {0}&quot;, streamid);
 459         } else if (closed) {
 460             Log.logTrace(&quot;Ignoring RST_STREAM frame received on closed stream {0}&quot;, streamid);
 461         } else {
 462             Flow.Subscriber&lt;?&gt; subscriber =
 463                     responseSubscriber == null ? pendingResponseSubscriber : responseSubscriber;
 464             if (response == null &amp;&amp; subscriber == null) {
 465                 // we haven&#39;t receive the headers yet, and won&#39;t receive any!
 466                 // handle reset now.
 467                 handleReset(frame, subscriber);
 468             } else {
 469                 // put it in the input queue in order to read all
 470                 // pending data frames first. Indeed, a server may send
 471                 // RST_STREAM after sending END_STREAM, in which case we should
 472                 // ignore it. However, we won&#39;t know if we have received END_STREAM
 473                 // or not until all pending data frames are read.
 474                 receiveResetFrame(frame);
 475                 // RST_STREAM was pushed to the queue. It will be handled by
 476                 // asyncReceive after all pending data frames have been
 477                 // processed.
 478                 Log.logTrace(&quot;RST_STREAM pushed in queue for stream {0}&quot;, streamid);
 479             }
 480         }
 481     }
 482 
 483     void handleReset(ResetFrame frame, Flow.Subscriber&lt;?&gt; subscriber) {
 484         Log.logTrace(&quot;Handling RST_STREAM on stream {0}&quot;, streamid);
 485         if (!closed) {
 486             synchronized (this) {
 487                 if (closed) {
 488                     if (debug.on()) debug.log(&quot;Stream already closed: ignoring RESET&quot;);
 489                     return;
 490                 }
 491                 closed = true;
 492             }
 493             try {
 494                 int error = frame.getErrorCode();
 495                 IOException e = new IOException(&quot;Received RST_STREAM: &quot;
 496                         + ErrorFrame.stringForCode(error));
 497                 if (errorRef.compareAndSet(null, e)) {
 498                     if (subscriber != null) {
 499                         subscriber.onError(e);
 500                     }
 501                 }
 502                 completeResponseExceptionally(e);
 503                 if (!requestBodyCF.isDone()) {
 504                     requestBodyCF.completeExceptionally(errorRef.get()); // we may be sending the body..
 505                 }
 506                 if (responseBodyCF != null) {
 507                     responseBodyCF.completeExceptionally(errorRef.get());
 508                 }
 509             } finally {
 510                 connection.decrementStreamsCount(streamid);
 511                 connection.closeStream(streamid);
 512             }
 513         } else {
 514             Log.logTrace(&quot;Ignoring RST_STREAM frame received on closed stream {0}&quot;, streamid);
 515         }
 516     }
 517 
 518     void incoming_priority(PriorityFrame frame) {
 519         // TODO: implement priority
 520         throw new UnsupportedOperationException(&quot;Not implemented&quot;);
 521     }
 522 
 523     private void incoming_windowUpdate(WindowUpdateFrame frame)
 524         throws IOException
 525     {
 526         int amount = frame.getUpdate();
 527         if (amount &lt;= 0) {
 528             Log.logTrace(&quot;Resetting stream: {0}, Window Update amount: {1}&quot;,
 529                          streamid, amount);
 530             connection.resetStream(streamid, ResetFrame.FLOW_CONTROL_ERROR);
 531         } else {
 532             assert streamid != 0;
 533             boolean success = windowController.increaseStreamWindow(amount, streamid);
 534             if (!success) {  // overflow
 535                 connection.resetStream(streamid, ResetFrame.FLOW_CONTROL_ERROR);
 536             }
 537         }
 538     }
 539 
 540     void incoming_pushPromise(HttpRequestImpl pushRequest,
 541                               PushedStream&lt;T&gt; pushStream)
 542         throws IOException
 543     {
 544         if (Log.requests()) {
 545             Log.logRequest(&quot;PUSH_PROMISE: &quot; + pushRequest.toString());
 546         }
 547         PushGroup&lt;T&gt; pushGroup = exchange.getPushGroup();
 548         if (pushGroup == null) {
 549             Log.logTrace(&quot;Rejecting push promise stream &quot; + streamid);
 550             connection.resetStream(pushStream.streamid, ResetFrame.REFUSED_STREAM);
 551             pushStream.close();
 552             return;
 553         }
 554 
 555         PushGroup.Acceptor&lt;T&gt; acceptor = null;
 556         boolean accepted = false;
 557         try {
 558             acceptor = pushGroup.acceptPushRequest(pushRequest);
 559             accepted = acceptor.accepted();
 560         } catch (Throwable t) {
 561             if (debug.on())
 562                 debug.log(&quot;PushPromiseHandler::applyPushPromise threw exception %s&quot;,
 563                           (Object)t);
 564         }
 565         if (!accepted) {
 566             // cancel / reject
 567             IOException ex = new IOException(&quot;Stream &quot; + streamid + &quot; cancelled by users handler&quot;);
 568             if (Log.trace()) {
 569                 Log.logTrace(&quot;No body subscriber for {0}: {1}&quot;, pushRequest,
 570                         ex.getMessage());
 571             }
 572             pushStream.cancelImpl(ex);
 573             return;
 574         }
 575 
 576         assert accepted &amp;&amp; acceptor != null;
 577         CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; pushResponseCF = acceptor.cf();
 578         HttpResponse.BodyHandler&lt;T&gt; pushHandler = acceptor.bodyHandler();
 579         assert pushHandler != null;
 580 
 581         pushStream.requestSent();
 582         pushStream.setPushHandler(pushHandler);  // TODO: could wrap the handler to throw on acceptPushPromise ?
 583         // setup housekeeping for when the push is received
 584         // TODO: deal with ignoring of CF anti-pattern
 585         CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; cf = pushStream.responseCF();
 586         cf.whenComplete((HttpResponse&lt;T&gt; resp, Throwable t) -&gt; {
 587             t = Utils.getCompletionCause(t);
 588             if (Log.trace()) {
 589                 Log.logTrace(&quot;Push completed on stream {0} for {1}{2}&quot;,
 590                              pushStream.streamid, resp,
 591                              ((t==null) ? &quot;&quot;: &quot; with exception &quot; + t));
 592             }
 593             if (t != null) {
 594                 pushGroup.pushError(t);
 595                 pushResponseCF.completeExceptionally(t);
 596             } else {
 597                 pushResponseCF.complete(resp);
 598             }
 599             pushGroup.pushCompleted();
 600         });
 601 
 602     }
 603 
 604     private OutgoingHeaders&lt;Stream&lt;T&gt;&gt; headerFrame(long contentLength) {
 605         HttpHeadersBuilder h = request.getSystemHeadersBuilder();
 606         if (contentLength &gt; 0) {
 607             h.setHeader(&quot;content-length&quot;, Long.toString(contentLength));
 608         }
 609         HttpHeaders sysh = filterHeaders(h.build());
 610         HttpHeaders userh = filterHeaders(request.getUserHeaders());
 611         // Filter context restricted from userHeaders
 612         userh = HttpHeaders.of(userh.map(), Utils.CONTEXT_RESTRICTED(client()));
 613 
 614         final HttpHeaders uh = userh;
 615 
 616         // Filter any headers from systemHeaders that are set in userHeaders
 617         sysh = HttpHeaders.of(sysh.map(), (k,v) -&gt; uh.firstValue(k).isEmpty());
 618 
 619         OutgoingHeaders&lt;Stream&lt;T&gt;&gt; f = new OutgoingHeaders&lt;&gt;(sysh, userh, this);
 620         if (contentLength == 0) {
 621             f.setFlag(HeadersFrame.END_STREAM);
 622             endStreamSent = true;
 623         }
 624         return f;
 625     }
 626 
 627     private boolean hasProxyAuthorization(HttpHeaders headers) {
 628         return headers.firstValue(&quot;proxy-authorization&quot;)
 629                       .isPresent();
 630     }
 631 
 632     // Determines whether we need to build a new HttpHeader object.
 633     //
 634     // Ideally we should pass the filter to OutgoingHeaders refactor the
 635     // code that creates the HeaderFrame to honor the filter.
 636     // We&#39;re not there yet - so depending on the filter we need to
 637     // apply and the content of the header we will try to determine
 638     //  whether anything might need to be filtered.
 639     // If nothing needs filtering then we can just use the
 640     // original headers.
 641     private boolean needsFiltering(HttpHeaders headers,
 642                                    BiPredicate&lt;String, String&gt; filter) {
 643         if (filter == Utils.PROXY_TUNNEL_FILTER || filter == Utils.PROXY_FILTER) {
 644             // we&#39;re either connecting or proxying
 645             // slight optimization: we only need to filter out
 646             // disabled schemes, so if there are none just
 647             // pass through.
 648             return Utils.proxyHasDisabledSchemes(filter == Utils.PROXY_TUNNEL_FILTER)
 649                     &amp;&amp; hasProxyAuthorization(headers);
 650         } else {
 651             // we&#39;re talking to a server, either directly or through
 652             // a tunnel.
 653             // Slight optimization: we only need to filter out
 654             // proxy authorization headers, so if there are none just
 655             // pass through.
 656             return hasProxyAuthorization(headers);
 657         }
 658     }
 659 
 660     private HttpHeaders filterHeaders(HttpHeaders headers) {
 661         HttpConnection conn = connection();
 662         BiPredicate&lt;String, String&gt; filter = conn.headerFilter(request);
 663         if (needsFiltering(headers, filter)) {
 664             return HttpHeaders.of(headers.map(), filter);
 665         }
 666         return headers;
 667     }
 668 
 669     private static HttpHeaders createPseudoHeaders(HttpRequest request) {
 670         HttpHeadersBuilder hdrs = new HttpHeadersBuilder();
 671         String method = request.method();
 672         hdrs.setHeader(&quot;:method&quot;, method);
 673         URI uri = request.uri();
 674         hdrs.setHeader(&quot;:scheme&quot;, uri.getScheme());
 675         // TODO: userinfo deprecated. Needs to be removed
 676         hdrs.setHeader(&quot;:authority&quot;, uri.getAuthority());
 677         // TODO: ensure header names beginning with : not in user headers
 678         String query = uri.getRawQuery();
 679         String path = uri.getRawPath();
 680         if (path == null || path.isEmpty()) {
 681             if (method.equalsIgnoreCase(&quot;OPTIONS&quot;)) {
 682                 path = &quot;*&quot;;
 683             } else {
 684                 path = &quot;/&quot;;
 685             }
 686         }
 687         if (query != null) {
 688             path += &quot;?&quot; + query;
 689         }
 690         hdrs.setHeader(&quot;:path&quot;, Utils.encode(path));
 691         return hdrs.build();
 692     }
 693 
 694     HttpHeaders getRequestPseudoHeaders() {
 695         return requestPseudoHeaders;
 696     }
 697 
 698     /** Sets endStreamReceived. Should be called only once. */
 699     void setEndStreamReceived() {
 700         if (debug.on()) debug.log(&quot;setEndStreamReceived: streamid=%d&quot;, streamid);
 701         assert remotelyClosed == false: &quot;Unexpected endStream already set&quot;;
 702         remotelyClosed = true;
 703         responseReceived();
 704     }
 705 
 706     /** Tells whether, or not, the END_STREAM Flag has been seen in any frame
 707      *  received on this stream. */
 708     private boolean endStreamReceived() {
 709         return remotelyClosed;
 710     }
 711 
 712     @Override
 713     CompletableFuture&lt;ExchangeImpl&lt;T&gt;&gt; sendHeadersAsync() {
 714         if (debug.on()) debug.log(&quot;sendHeadersOnly()&quot;);
 715         if (Log.requests() &amp;&amp; request != null) {
 716             Log.logRequest(request.toString());
 717         }
 718         if (requestPublisher != null) {
 719             requestContentLen = requestPublisher.contentLength();
 720         } else {
 721             requestContentLen = 0;
 722         }
 723         OutgoingHeaders&lt;Stream&lt;T&gt;&gt; f = headerFrame(requestContentLen);
 724         connection.sendFrame(f);
 725         CompletableFuture&lt;ExchangeImpl&lt;T&gt;&gt; cf = new MinimalFuture&lt;&gt;();
 726         cf.complete(this);  // #### good enough for now
 727         return cf;
 728     }
 729 
 730     @Override
 731     void released() {
 732         if (streamid &gt; 0) {
 733             if (debug.on()) debug.log(&quot;Released stream %d&quot;, streamid);
 734             // remove this stream from the Http2Connection map.
 735             connection.decrementStreamsCount(streamid);
 736             connection.closeStream(streamid);
 737         } else {
 738             if (debug.on()) debug.log(&quot;Can&#39;t release stream %d&quot;, streamid);
 739         }
 740     }
 741 
 742     @Override
 743     void completed() {
 744         // There should be nothing to do here: the stream should have
 745         // been already closed (or will be closed shortly after).
 746     }
 747 
 748     void registerStream(int id) {
 749         this.streamid = id;
 750         connection.putStream(this, streamid);
 751         if (debug.on()) debug.log(&quot;Registered stream %d&quot;, id);
 752     }
 753 
 754     void signalWindowUpdate() {
 755         RequestSubscriber subscriber = requestSubscriber;
 756         assert subscriber != null;
 757         if (debug.on()) debug.log(&quot;Signalling window update&quot;);
 758         subscriber.sendScheduler.runOrSchedule();
 759     }
 760 
 761     static final ByteBuffer COMPLETED = ByteBuffer.allocate(0);
 762     class RequestSubscriber implements Flow.Subscriber&lt;ByteBuffer&gt; {
 763         // can be &lt; 0 if the actual length is not known.
 764         private final long contentLength;
 765         private volatile long remainingContentLength;
 766         private volatile Subscription subscription;
 767 
 768         // Holds the outgoing data. There will be at most 2 outgoing ByteBuffers.
 769         //  1) The data that was published by the request body Publisher, and
 770         //  2) the COMPLETED sentinel, since onComplete can be invoked without demand.
 771         final ConcurrentLinkedDeque&lt;ByteBuffer&gt; outgoing = new ConcurrentLinkedDeque&lt;&gt;();
 772 
 773         private final AtomicReference&lt;Throwable&gt; errorRef = new AtomicReference&lt;&gt;();
 774         // A scheduler used to honor window updates. Writing must be paused
 775         // when the window is exhausted, and resumed when the window acquires
 776         // some space. The sendScheduler makes it possible to implement this
 777         // behaviour in an asynchronous non-blocking way.
 778         // See RequestSubscriber::trySend below.
 779         final SequentialScheduler sendScheduler;
 780 
 781         RequestSubscriber(long contentLen) {
 782             this.contentLength = contentLen;
 783             this.remainingContentLength = contentLen;
 784             this.sendScheduler =
 785                     SequentialScheduler.synchronizedScheduler(this::trySend);
 786         }
 787 
 788         @Override
 789         public void onSubscribe(Flow.Subscription subscription) {
 790             if (this.subscription != null) {
 791                 throw new IllegalStateException(&quot;already subscribed&quot;);
 792             }
 793             this.subscription = subscription;
 794             if (debug.on())
 795                 debug.log(&quot;RequestSubscriber: onSubscribe, request 1&quot;);
 796             subscription.request(1);
 797         }
 798 
 799         @Override
 800         public void onNext(ByteBuffer item) {
 801             if (debug.on())
 802                 debug.log(&quot;RequestSubscriber: onNext(%d)&quot;, item.remaining());
 803             int size = outgoing.size();
 804             assert size == 0 : &quot;non-zero size: &quot; + size;
 805             onNextImpl(item);
 806         }
 807 
 808         private void onNextImpl(ByteBuffer item) {
 809             // Got some more request body bytes to send.
 810             if (requestBodyCF.isDone()) {
 811                 // stream already cancelled, probably in timeout
 812                 sendScheduler.stop();
 813                 subscription.cancel();
 814                 return;
 815             }
 816             outgoing.add(item);
 817             sendScheduler.runOrSchedule();
 818         }
 819 
 820         @Override
 821         public void onError(Throwable throwable) {
 822             if (debug.on())
 823                 debug.log(() -&gt; &quot;RequestSubscriber: onError: &quot; + throwable);
 824             // ensure that errors are handled within the flow.
 825             if (errorRef.compareAndSet(null, throwable)) {
 826                 sendScheduler.runOrSchedule();
 827             }
 828         }
 829 
 830         @Override
 831         public void onComplete() {
 832             if (debug.on()) debug.log(&quot;RequestSubscriber: onComplete&quot;);
 833             int size = outgoing.size();
 834             assert size == 0 || size == 1 : &quot;non-zero or one size: &quot; + size;
 835             // last byte of request body has been obtained.
 836             // ensure that everything is completed within the flow.
 837             onNextImpl(COMPLETED);
 838         }
 839 
 840         // Attempts to send the data, if any.
 841         // Handles errors and completion state.
 842         // Pause writing if the send window is exhausted, resume it if the
 843         // send window has some bytes that can be acquired.
 844         void trySend() {
 845             try {
 846                 // handle errors raised by onError;
 847                 Throwable t = errorRef.get();
 848                 if (t != null) {
 849                     sendScheduler.stop();
 850                     if (requestBodyCF.isDone()) return;
 851                     subscription.cancel();
 852                     requestBodyCF.completeExceptionally(t);
 853                     cancelImpl(t);
 854                     return;
 855                 }
 856 
 857                 do {
 858                     // handle COMPLETED;
 859                     ByteBuffer item = outgoing.peekFirst();
 860                     if (item == null) return;
 861                     else if (item == COMPLETED) {
 862                         sendScheduler.stop();
 863                         complete();
 864                         return;
 865                     }
 866 
 867                     // handle bytes to send downstream
 868                     while (item.hasRemaining()) {
 869                         if (debug.on()) debug.log(&quot;trySend: %d&quot;, item.remaining());
 870                         assert !endStreamSent : &quot;internal error, send data after END_STREAM flag&quot;;
 871                         DataFrame df = getDataFrame(item);
 872                         if (df == null) {
 873                             if (debug.on())
 874                                 debug.log(&quot;trySend: can&#39;t send yet: %d&quot;, item.remaining());
 875                             return; // the send window is exhausted: come back later
 876                         }
 877 
 878                         if (contentLength &gt; 0) {
 879                             remainingContentLength -= df.getDataLength();
 880                             if (remainingContentLength &lt; 0) {
 881                                 String msg = connection().getConnectionFlow()
 882                                         + &quot; stream=&quot; + streamid + &quot; &quot;
 883                                         + &quot;[&quot; + Thread.currentThread().getName() + &quot;] &quot;
 884                                         + &quot;Too many bytes in request body. Expected: &quot;
 885                                         + contentLength + &quot;, got: &quot;
 886                                         + (contentLength - remainingContentLength);
 887                                 connection.resetStream(streamid, ResetFrame.PROTOCOL_ERROR);
 888                                 throw new IOException(msg);
 889                             } else if (remainingContentLength == 0) {
 890                                 df.setFlag(DataFrame.END_STREAM);
 891                                 endStreamSent = true;
 892                             }
 893                         }
 894                         if (debug.on())
 895                             debug.log(&quot;trySend: sending: %d&quot;, df.getDataLength());
 896                         connection.sendDataFrame(df);
 897                     }
 898                     assert !item.hasRemaining();
 899                     ByteBuffer b = outgoing.removeFirst();
 900                     assert b == item;
 901                 } while (outgoing.peekFirst() != null);
 902 
 903                 if (debug.on()) debug.log(&quot;trySend: request 1&quot;);
 904                 subscription.request(1);
 905             } catch (Throwable ex) {
 906                 if (debug.on()) debug.log(&quot;trySend: &quot;, ex);
 907                 sendScheduler.stop();
 908                 subscription.cancel();
 909                 requestBodyCF.completeExceptionally(ex);
 910                 // need to cancel the stream to 1. tell the server
 911                 // we don&#39;t want to receive any more data and
 912                 // 2. ensure that the operation ref count will be
 913                 // decremented on the HttpClient.
 914                 cancelImpl(ex);
 915             }
 916         }
 917 
 918         private void complete() throws IOException {
 919             long remaining = remainingContentLength;
 920             long written = contentLength - remaining;
 921             if (remaining &gt; 0) {
 922                 connection.resetStream(streamid, ResetFrame.PROTOCOL_ERROR);
 923                 // let trySend() handle the exception
 924                 throw new IOException(connection().getConnectionFlow()
 925                                      + &quot; stream=&quot; + streamid + &quot; &quot;
 926                                      + &quot;[&quot; + Thread.currentThread().getName() +&quot;] &quot;
 927                                      + &quot;Too few bytes returned by the publisher (&quot;
 928                                               + written + &quot;/&quot;
 929                                               + contentLength + &quot;)&quot;);
 930             }
 931             if (!endStreamSent) {
 932                 endStreamSent = true;
 933                 connection.sendDataFrame(getEmptyEndStreamDataFrame());
 934             }
 935             requestBodyCF.complete(null);
 936         }
 937     }
 938 
 939     /**
 940      * Send a RESET frame to tell server to stop sending data on this stream
 941      */
 942     @Override
 943     public CompletableFuture&lt;Void&gt; ignoreBody() {
 944         try {
 945             connection.resetStream(streamid, ResetFrame.STREAM_CLOSED);
 946             return MinimalFuture.completedFuture(null);
 947         } catch (Throwable e) {
 948             Log.logTrace(&quot;Error resetting stream {0}&quot;, e.toString());
 949             return MinimalFuture.failedFuture(e);
 950         }
 951     }
 952 
 953     DataFrame getDataFrame(ByteBuffer buffer) {
 954         int requestAmount = Math.min(connection.getMaxSendFrameSize(), buffer.remaining());
 955         // blocks waiting for stream send window, if exhausted
 956         int actualAmount = windowController.tryAcquire(requestAmount, streamid, this);
 957         if (actualAmount &lt;= 0) return null;
 958         ByteBuffer outBuf = Utils.sliceWithLimitedCapacity(buffer,  actualAmount);
 959         DataFrame df = new DataFrame(streamid, 0 , outBuf);
 960         return df;
 961     }
 962 
 963     private DataFrame getEmptyEndStreamDataFrame()  {
 964         return new DataFrame(streamid, DataFrame.END_STREAM, List.of());
 965     }
 966 
 967     /**
 968      * A List of responses relating to this stream. Normally there is only
 969      * one response, but intermediate responses like 100 are allowed
 970      * and must be passed up to higher level before continuing. Deals with races
 971      * such as if responses are returned before the CFs get created by
 972      * getResponseAsync()
 973      */
 974 
 975     final List&lt;CompletableFuture&lt;Response&gt;&gt; response_cfs = new ArrayList&lt;&gt;(5);
 976 
 977     @Override
 978     CompletableFuture&lt;Response&gt; getResponseAsync(Executor executor) {
 979         CompletableFuture&lt;Response&gt; cf;
 980         // The code below deals with race condition that can be caused when
 981         // completeResponse() is being called before getResponseAsync()
 982         synchronized (response_cfs) {
 983             if (!response_cfs.isEmpty()) {
 984                 // This CompletableFuture was created by completeResponse().
 985                 // it will be already completed.
 986                 cf = response_cfs.remove(0);
 987                 // if we find a cf here it should be already completed.
 988                 // finding a non completed cf should not happen. just assert it.
 989                 assert cf.isDone() : &quot;Removing uncompleted response: could cause code to hang!&quot;;
 990             } else {
 991                 // getResponseAsync() is called first. Create a CompletableFuture
 992                 // that will be completed by completeResponse() when
 993                 // completeResponse() is called.
 994                 cf = new MinimalFuture&lt;&gt;();
 995                 response_cfs.add(cf);
 996             }
 997         }
 998         if (executor != null &amp;&amp; !cf.isDone()) {
 999             // protect from executing later chain of CompletableFuture operations from SelectorManager thread
1000             cf = cf.thenApplyAsync(r -&gt; r, executor);
1001         }
1002         Log.logTrace(&quot;Response future (stream={0}) is: {1}&quot;, streamid, cf);
1003         PushGroup&lt;?&gt; pg = exchange.getPushGroup();
1004         if (pg != null) {
1005             // if an error occurs make sure it is recorded in the PushGroup
1006             cf = cf.whenComplete((t,e) -&gt; pg.pushError(Utils.getCompletionCause(e)));
1007         }
1008         return cf;
1009     }
1010 
1011     /**
1012      * Completes the first uncompleted CF on list, and removes it. If there is no
1013      * uncompleted CF then creates one (completes it) and adds to list
1014      */
1015     void completeResponse(Response resp) {
1016         synchronized (response_cfs) {
1017             CompletableFuture&lt;Response&gt; cf;
1018             int cfs_len = response_cfs.size();
1019             for (int i=0; i&lt;cfs_len; i++) {
1020                 cf = response_cfs.get(i);
1021                 if (!cf.isDone()) {
1022                     Log.logTrace(&quot;Completing response (streamid={0}): {1}&quot;,
1023                                  streamid, cf);
1024                     if (debug.on())
1025                         debug.log(&quot;Completing responseCF(%d) with response headers&quot;, i);
1026                     response_cfs.remove(cf);
1027                     cf.complete(resp);
1028                     return;
1029                 } // else we found the previous response: just leave it alone.
1030             }
1031             cf = MinimalFuture.completedFuture(resp);
1032             Log.logTrace(&quot;Created completed future (streamid={0}): {1}&quot;,
1033                          streamid, cf);
1034             if (debug.on())
1035                 debug.log(&quot;Adding completed responseCF(0) with response headers&quot;);
1036             response_cfs.add(cf);
1037         }
1038     }
1039 
1040     // methods to update state and remove stream when finished
1041 
1042     synchronized void requestSent() {
1043         requestSent = true;
1044         if (responseReceived) {
1045             if (debug.on()) debug.log(&quot;requestSent: streamid=%d&quot;, streamid);
1046             close();
1047         } else {
1048             if (debug.on()) {
1049                 debug.log(&quot;requestSent: streamid=%d but response not received&quot;, streamid);
1050             }
1051         }
1052     }
1053 
1054     synchronized void responseReceived() {
1055         responseReceived = true;
1056         if (requestSent) {
1057             if (debug.on()) debug.log(&quot;responseReceived: streamid=%d&quot;, streamid);
1058             close();
1059         } else {
1060             if (debug.on()) {
1061                 debug.log(&quot;responseReceived: streamid=%d but request not sent&quot;, streamid);
1062             }
1063         }
1064     }
1065 
1066     /**
1067      * same as above but for errors
1068      */
1069     void completeResponseExceptionally(Throwable t) {
1070         synchronized (response_cfs) {
1071             // use index to avoid ConcurrentModificationException
1072             // caused by removing the CF from within the loop.
1073             for (int i = 0; i &lt; response_cfs.size(); i++) {
1074                 CompletableFuture&lt;Response&gt; cf = response_cfs.get(i);
1075                 if (!cf.isDone()) {
1076                     response_cfs.remove(i);
1077                     cf.completeExceptionally(t);
1078                     return;
1079                 }
1080             }
1081             response_cfs.add(MinimalFuture.failedFuture(t));
1082         }
1083     }
1084 
1085     CompletableFuture&lt;Void&gt; sendBodyImpl() {
1086         requestBodyCF.whenComplete((v, t) -&gt; requestSent());
1087         try {
1088             if (requestPublisher != null) {
1089                 final RequestSubscriber subscriber = new RequestSubscriber(requestContentLen);
1090                 requestPublisher.subscribe(requestSubscriber = subscriber);
1091             } else {
1092                 // there is no request body, therefore the request is complete,
1093                 // END_STREAM has already sent with outgoing headers
1094                 requestBodyCF.complete(null);
1095             }
1096         } catch (Throwable t) {
1097             cancelImpl(t);
1098             requestBodyCF.completeExceptionally(t);
1099         }
1100         return requestBodyCF;
1101     }
1102 
1103     @Override
1104     void cancel() {
1105         cancel(new IOException(&quot;Stream &quot; + streamid + &quot; cancelled&quot;));
1106     }
1107 
1108     void onSubscriptionError(Throwable t) {
1109         errorRef.compareAndSet(null, t);
1110         if (debug.on()) debug.log(&quot;Got subscription error: %s&quot;, (Object)t);
1111         // This is the special case where the subscriber
1112         // has requested an illegal number of items.
1113         // In this case, the error doesn&#39;t come from
1114         // upstream, but from downstream, and we need to
1115         // handle the error without waiting for the inputQ
1116         // to be exhausted.
1117         stopRequested = true;
1118         sched.runOrSchedule();
1119     }
1120 
1121     @Override
1122     void cancel(IOException cause) {
1123         cancelImpl(cause);
1124     }
1125 
1126     void connectionClosing(Throwable cause) {
1127         Flow.Subscriber&lt;?&gt; subscriber =
1128                 responseSubscriber == null ? pendingResponseSubscriber : responseSubscriber;
1129         errorRef.compareAndSet(null, cause);
1130         if (subscriber != null &amp;&amp; !sched.isStopped() &amp;&amp; !inputQ.isEmpty()) {
1131             sched.runOrSchedule();
1132         } else cancelImpl(cause);
1133     }
1134 
1135     // This method sends a RST_STREAM frame
1136     void cancelImpl(Throwable e) {
1137         errorRef.compareAndSet(null, e);
1138         if (debug.on()) debug.log(&quot;cancelling stream {0}: {1}&quot;, streamid, e);
1139         if (Log.trace()) {
1140             Log.logTrace(&quot;cancelling stream {0}: {1}\n&quot;, streamid, e);
1141         }
1142         boolean closing;
1143         if (closing = !closed) { // assigning closing to !closed
1144             synchronized (this) {
1145                 if (closing = !closed) { // assigning closing to !closed
1146                     closed=true;
1147                 }
1148             }
1149         }
1150         if (closing) { // true if the stream has not been closed yet
1151             if (responseSubscriber != null || pendingResponseSubscriber != null)
1152                 sched.runOrSchedule();
1153         }
1154         completeResponseExceptionally(e);
1155         if (!requestBodyCF.isDone()) {
1156             requestBodyCF.completeExceptionally(errorRef.get()); // we may be sending the body..
1157         }
1158         if (responseBodyCF != null) {
1159             responseBodyCF.completeExceptionally(errorRef.get());
1160         }
1161         try {
1162             // will send a RST_STREAM frame
1163             if (streamid != 0) {
1164                 connection.decrementStreamsCount(streamid);
1165                 e = Utils.getCompletionCause(e);
1166                 if (e instanceof EOFException) {
1167                     // read EOF: no need to try &amp; send reset
1168                     connection.closeStream(streamid);
1169                 } else {
1170                     connection.resetStream(streamid, ResetFrame.CANCEL);
1171                 }
1172             }
1173         } catch (Throwable ex) {
1174             Log.logError(ex);
1175         }
1176     }
1177 
1178     // This method doesn&#39;t send any frame
1179     void close() {
1180         if (closed) return;
1181         synchronized(this) {
1182             if (closed) return;
1183             closed = true;
1184         }
1185         if (debug.on()) debug.log(&quot;close stream %d&quot;, streamid);
1186         Log.logTrace(&quot;Closing stream {0}&quot;, streamid);
1187         connection.closeStream(streamid);
1188         Log.logTrace(&quot;Stream {0} closed&quot;, streamid);
1189     }
1190 
1191     static class PushedStream&lt;T&gt; extends Stream&lt;T&gt; {
1192         final PushGroup&lt;T&gt; pushGroup;
1193         // push streams need the response CF allocated up front as it is
1194         // given directly to user via the multi handler callback function.
1195         final CompletableFuture&lt;Response&gt; pushCF;
1196         CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; responseCF;
1197         final HttpRequestImpl pushReq;
1198         HttpResponse.BodyHandler&lt;T&gt; pushHandler;
1199 
1200         PushedStream(PushGroup&lt;T&gt; pushGroup,
1201                      Http2Connection connection,
1202                      Exchange&lt;T&gt; pushReq) {
1203             // ## no request body possible, null window controller
1204             super(connection, pushReq, null);
1205             this.pushGroup = pushGroup;
1206             this.pushReq = pushReq.request();
1207             this.pushCF = new MinimalFuture&lt;&gt;();
1208             this.responseCF = new MinimalFuture&lt;&gt;();
1209 
1210         }
1211 
1212         CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; responseCF() {
1213             return responseCF;
1214         }
1215 
1216         synchronized void setPushHandler(HttpResponse.BodyHandler&lt;T&gt; pushHandler) {
1217             this.pushHandler = pushHandler;
1218         }
1219 
1220         synchronized HttpResponse.BodyHandler&lt;T&gt; getPushHandler() {
1221             // ignored parameters to function can be used as BodyHandler
1222             return this.pushHandler;
1223         }
1224 
1225         // Following methods call the super class but in case of
1226         // error record it in the PushGroup. The error method is called
1227         // with a null value when no error occurred (is a no-op)
1228         @Override
1229         CompletableFuture&lt;ExchangeImpl&lt;T&gt;&gt; sendBodyAsync() {
1230             return super.sendBodyAsync()
1231                         .whenComplete((ExchangeImpl&lt;T&gt; v, Throwable t)
1232                                 -&gt; pushGroup.pushError(Utils.getCompletionCause(t)));
1233         }
1234 
1235         @Override
1236         CompletableFuture&lt;ExchangeImpl&lt;T&gt;&gt; sendHeadersAsync() {
1237             return super.sendHeadersAsync()
1238                         .whenComplete((ExchangeImpl&lt;T&gt; ex, Throwable t)
1239                                 -&gt; pushGroup.pushError(Utils.getCompletionCause(t)));
1240         }
1241 
1242         @Override
1243         CompletableFuture&lt;Response&gt; getResponseAsync(Executor executor) {
1244             CompletableFuture&lt;Response&gt; cf = pushCF.whenComplete(
1245                     (v, t) -&gt; pushGroup.pushError(Utils.getCompletionCause(t)));
1246             if(executor!=null &amp;&amp; !cf.isDone()) {
1247                 cf  = cf.thenApplyAsync( r -&gt; r, executor);
1248             }
1249             return cf;
1250         }
1251 
1252         @Override
1253         CompletableFuture&lt;T&gt; readBodyAsync(
1254                 HttpResponse.BodyHandler&lt;T&gt; handler,
1255                 boolean returnConnectionToPool,
1256                 Executor executor)
1257         {
1258             return super.readBodyAsync(handler, returnConnectionToPool, executor)
1259                         .whenComplete((v, t) -&gt; pushGroup.pushError(t));
1260         }
1261 
1262         @Override
1263         void completeResponse(Response r) {
1264             Log.logResponse(r::toString);
1265             pushCF.complete(r); // not strictly required for push API
1266             // start reading the body using the obtained BodySubscriber
1267             CompletableFuture&lt;Void&gt; start = new MinimalFuture&lt;&gt;();
1268             start.thenCompose( v -&gt; readBodyAsync(getPushHandler(), false, getExchange().executor()))
1269                 .whenComplete((T body, Throwable t) -&gt; {
1270                     if (t != null) {
1271                         responseCF.completeExceptionally(t);
1272                     } else {
1273                         HttpResponseImpl&lt;T&gt; resp =
1274                                 new HttpResponseImpl&lt;&gt;(r.request, r, null, body, getExchange());
1275                         responseCF.complete(resp);
1276                     }
1277                 });
1278             start.completeAsync(() -&gt; null, getExchange().executor());
1279         }
1280 
1281         @Override
1282         void completeResponseExceptionally(Throwable t) {
1283             pushCF.completeExceptionally(t);
1284         }
1285 
1286 //        @Override
1287 //        synchronized void responseReceived() {
1288 //            super.responseReceived();
1289 //        }
1290 
1291         // create and return the PushResponseImpl
1292         @Override
1293         protected void handleResponse() {
1294             HttpHeaders responseHeaders = responseHeadersBuilder.build();
1295             responseCode = (int)responseHeaders
1296                 .firstValueAsLong(&quot;:status&quot;)
1297                 .orElse(-1);
1298 
1299             if (responseCode == -1) {
1300                 completeResponseExceptionally(new IOException(&quot;No status code&quot;));
1301             }
1302 
1303             this.response = new Response(
1304                 pushReq, exchange, responseHeaders, connection(),
1305                 responseCode, HttpClient.Version.HTTP_2);
1306 
1307             /* TODO: review if needs to be removed
1308                the value is not used, but in case `content-length` doesn&#39;t parse
1309                as long, there will be NumberFormatException. If left as is, make
1310                sure code up the stack handles NFE correctly. */
1311             responseHeaders.firstValueAsLong(&quot;content-length&quot;);
1312 
1313             if (Log.headers()) {
1314                 StringBuilder sb = new StringBuilder(&quot;RESPONSE HEADERS&quot;);
1315                 sb.append(&quot; (streamid=&quot;).append(streamid).append(&quot;):\n&quot;);
1316                 Log.dumpHeaders(sb, &quot;    &quot;, responseHeaders);
1317                 Log.logHeaders(sb.toString());
1318             }
1319 
1320             rspHeadersConsumer.reset();
1321 
1322             // different implementations for normal streams and pushed streams
1323             completeResponse(response);
1324         }
1325     }
1326 
1327     final class StreamWindowUpdateSender extends WindowUpdateSender {
1328 
1329         StreamWindowUpdateSender(Http2Connection connection) {
1330             super(connection);
1331         }
1332 
1333         @Override
1334         int getStreamId() {
1335             return streamid;
1336         }
1337 
1338         @Override
1339         String dbgString() {
1340             String dbg = dbgString;
1341             if (dbg != null) return dbg;
1342             if (streamid == 0) {
1343                 return connection.dbgString() + &quot;:WindowUpdateSender(stream: ?)&quot;;
1344             } else {
1345                 dbg = connection.dbgString() + &quot;:WindowUpdateSender(stream: &quot; + streamid + &quot;)&quot;;
1346                 return dbgString = dbg;
1347             }
1348         }
1349     }
1350 
1351     /**
1352      * Returns true if this exchange was canceled.
1353      * @return true if this exchange was canceled.
1354      */
1355     synchronized boolean isCanceled() {
1356         return errorRef.get() != null;
1357     }
1358 
1359     /**
1360      * Returns the cause for which this exchange was canceled, if available.
1361      * @return the cause for which this exchange was canceled, if available.
1362      */
1363     synchronized Throwable getCancelCause() {
1364         return errorRef.get();
1365     }
1366 
1367     final String dbgString() {
1368         return connection.dbgString() + &quot;/Stream(&quot;+streamid+&quot;)&quot;;
1369     }
1370 
1371     private class HeadersConsumer extends Http2Connection.ValidatingHeadersConsumer {
1372 
1373         void reset() {
1374             super.reset();
1375             responseHeadersBuilder.clear();
1376             debug.log(&quot;Response builder cleared, ready to receive new headers.&quot;);
1377         }
1378 
1379         @Override
1380         public void onDecoded(CharSequence name, CharSequence value)
1381             throws UncheckedIOException
1382         {
1383             String n = name.toString();
1384             String v = value.toString();
1385             super.onDecoded(n, v);
1386             responseHeadersBuilder.addHeader(n, v);
1387             if (Log.headers() &amp;&amp; Log.trace()) {
1388                 Log.logTrace(&quot;RECEIVED HEADER (streamid={0}): {1}: {2}&quot;,
1389                              streamid, n, v);
1390             }
1391         }
1392     }
1393 }
    </pre>
  </body>
</html>
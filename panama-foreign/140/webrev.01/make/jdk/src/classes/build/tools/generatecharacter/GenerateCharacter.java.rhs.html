<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/jdk/src/classes/build/tools/generatecharacter/GenerateCharacter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.generatecharacter;
  27 
  28 import java.io.IOException;
  29 import java.io.FileNotFoundException;
  30 import java.io.BufferedReader;
  31 import java.io.FileReader;
  32 import java.io.PrintWriter;
  33 import java.io.BufferedWriter;
  34 import java.io.FileWriter;
  35 import java.io.File;
  36 import java.util.List;
  37 
  38 import build.tools.generatecharacter.CharacterName;
  39 
  40 /**
  41  * This program generates the source code for the class java.lang.Character.
  42  * It also generates native C code that can perform the same operations.
  43  * It requires two external input data files:
  44  * &lt;ul&gt;
  45  * &lt;li&gt; Unicode specification file
  46  * &lt;li&gt; Character class template file
  47  * &lt;/ul&gt;
  48  * The Unicode specification file is available from the Unicode consortium.
  49  * It has character specification lines that look like this:
  50  * &lt;listing&gt;
  51  * 0041;LATIN CAPITAL LETTER A;Lu;0;L;;;;;N;;;;0061;
  52  * &lt;/listing&gt;
  53  * The Character class template file is filled in with additional
  54  * information to produce the file Character.java, which can then be
  55  * compiled by a Java compiler.  The template file contains certain
  56  * markers consisting of an alphabetic name string preceded by &quot;$$&quot;.
  57  * Such markers are replaced with generated program text.  As a special
  58  * case, the marker &quot;Lookup(xxx)&quot; is recognized, where &quot;xxx&quot; consists of
  59  * alphabetic characters constituting a variable name.  The character &quot;_&quot;
  60  * is considered alphabetic for these purposes.
  61  *
  62  * @author  Guy Steele
  63  * @author  Alan Liu
  64  * @author  John O&#39;Conner
  65  */
  66 
  67 public class GenerateCharacter {
  68 
  69     final static boolean DEBUG = false;
  70 
  71     final static String commandMarker = &quot;$$&quot;;
  72     static String ROOT                        = &quot;&quot;;
  73     static String DefaultUnicodeSpecFileName  = ROOT + &quot;UnicodeData.txt&quot;;
  74     static String DefaultSpecialCasingFileName = ROOT + &quot;SpecialCasing.txt&quot;;
  75     static String DefaultPropListFileName     = ROOT + &quot;PropList.txt&quot;;
  76     static String DefaultDerivedPropsFileName = ROOT + &quot;DerivedCoreProperties.txt&quot;;
  77     static String DefaultJavaTemplateFileName = ROOT + &quot;Character.java.template&quot;;
  78     static String DefaultJavaOutputFileName   = ROOT + &quot;Character.java&quot;;
  79     static String DefaultCTemplateFileName    = ROOT + &quot;Character.c.template&quot;;
  80     static String DefaultCOutputFileName      = ROOT + &quot;Character.c&quot;;
  81 
  82     static int plane = 0;
  83 
  84     /* The overall idea is that, in the generated Character class source code,
  85     most character property data is stored in a special multi-level table whose
  86     structure is defined by a sequence of nonnegative integers [k1, k2, ..., kn].
  87     The integers must sum to 16 (the number of bits in a character).
  88     The first table is indexed by the k1 high-order bits of the character code.
  89     The result is concatenated to the next k2 bits of the character code to index
  90     the second table, and so on.  Eventually the kn low-order bits of the character
  91     code are concatenated and used to index one of two tables A and B; A contains
  92     32-bit integer entries and B contains 16-bit short entries.  The 48 bits that
  93     can be thus obtained encode the properties for the character.
  94 
  95     The default specification is [9, 4, 3, 0].  This particular table format was
  96     designed by conducting an exhaustive search of table formats to minimize the
  97     space consumed by the tables: the first and third tables need have only byte
  98     values (the second table must have short values).  Another good choice is
  99     [10, 6, 0], which produces a larger table but allows particularly fast table
 100     lookup code.
 101 
 102     In each case, where the word &quot;concatenated&quot; is used, this may imply
 103     first a &lt;&lt; and then a | operation, or perhaps just a | operation if
 104     the values in the table can be preshifted (generally possible if the table
 105     entries are short rather than byte).
 106     */
 107 
 108     /* The character properties are currently encoded into A (32 bits)and B (16 bits)
 109        two parts.
 110 
 111     A: the low 32 bits are defined  in the following manner:
 112 
 113     1 bit Mirrored property.
 114     4 bits      Bidirectional category (see below) (unused if -nobidi switch specified)
 115     9 bits      A signed offset used for converting case .
 116     1 bit       If 1, adding the signed offset converts the character to lowercase.
 117     1 bit       If 1, subtracting the signed offset converts the character to uppercase.
 118         Note: for a titlecase character, both of the preceding bits will be 1
 119         and the signed offset will be 1.
 120     1 bit   If 1, this character has a titlecase equivalent (possibly itself);
 121         in this case, the two bits before this bit can be used to decide
 122         whether this character is in fact uppercase, lowercase, or titlecase.
 123     3 bits      This field provides a quick way to lex identifiers.
 124         The eight possible values for this field are as follows:
 125         0  May not be part of an identifier
 126         1  Ignorable control; may continue a Unicode identifier or Java identifier
 127         2  May continue a Java identifier but not a Unicode identifier (unused)
 128         3  May continue a Unicode identifier or Java identifier
 129         4  Is a Java whitespace character
 130         5  May start or continue a Java identifier;
 131            may continue but not start a Unicode identifier
 132            (this value is used for connector punctuation such as _)
 133         6  May start or continue a Java identifier;
 134            may not occur in a Unicode identifier
 135            (this value is used for currency symbols such as $)
 136         7  May start or continue a Unicode identifier or Java identifier
 137         Thus:
 138            5, 6, 7 may start a Java identifier
 139            1, 2, 3, 5, 6, 7 may continue a Java identifier
 140            7 may start a Unicode identifier
 141            1, 3, 5, 7 may continue a Unicode identifier
 142            1 is ignorable within an identifier
 143            4 is Java whitespace
 144     2 bits      This field indicates whether the character has a numeric property.
 145         The four possible values for this field are as follows:
 146         0  This character has no numeric property.
 147         1  Adding the digit offset to the character code and then
 148            masking with 0x1F will produce the desired numeric value.
 149         2  This character has a &quot;strange&quot; numeric value.
 150         3  A Java supradecimal digit: adding the digit offset to the
 151            character code, then masking with 0x1F, then adding 10
 152            will produce the desired numeric value.
 153     5 bits  The digit offset (see description of previous field)
 154     5 bits      Character type (see below)
 155 
 156     B: the high 16 bits are defined as:
 157     1 bit Other_Lowercase property
 158     1 bit Other_Uppercase property
 159     1 bit Other_Alphabetic property
 160     1 bit Other_Math property
 161     1 bit Ideographic property
 162     1 bit Noncharacter codepoint property
 163     1 bit ID_Start property
 164     1 bit ID_Continue property
 165     */
 166 
 167 
 168     // bit masks identify each component of a 32-bit property field described
 169     // above.
 170     // shift* indicates how many shifts right must happen to get the
 171     // indicated property value in the lowest bits of the 32-bit space.
 172     private static final int
 173         shiftType           = 0,        maskType            =       0x001F,
 174         shiftDigitOffset    = 5,        maskDigitOffset     =       0x03E0,
 175         shiftNumericType    = 10,       maskNumericType     =       0x0C00,
 176         shiftIdentifierInfo = 12,       maskIdentifierInfo  =       0x7000,
 177                                         maskUnicodePart     =       0x1000,
 178         shiftCaseInfo       = 15,       maskCaseInfo        =      0x38000,
 179                                         maskLowerCase       =      0x20000,
 180                                         maskUpperCase       =      0x10000,
 181                                         maskTitleCase       =      0x08000,
 182         shiftCaseOffset     = 18,       maskCaseOffset      =   0x07FC0000,
 183         shiftCaseOffsetSign = 5,
 184                                         // used only when calculating and
 185                                         // storing digit offsets from char values
 186                                         maskDigit               =   0x001F,
 187                                         // case offset are 9 bits
 188                                         maskCase                =   0x01FF,
 189         shiftBidi           = 27,       maskBidi              = 0x78000000,
 190         shiftMirrored       = 31,       //maskMirrored          = 0x80000000,
 191         shiftPlane          = 16,       maskPlane = 0xFF0000;
 192 
 193     // maskMirrored needs to be long, if up 16-bit
 194     private static final long maskMirrored          = 0x80000000L;
 195 
 196     // bit masks identify the 16-bit property field described above, in B
 197     // table
 198     private static final long
 199         maskOtherLowercase  = 0x100000000L,
 200         maskOtherUppercase  = 0x200000000L,
 201         maskOtherAlphabetic = 0x400000000L,
 202         maskOtherMath       = 0x800000000L,
 203         maskIdeographic     = 0x1000000000L,
 204         maskNoncharacterCP  = 0x2000000000L,
 205         maskIDStart         = 0x4000000000L,
 206         maskIDContinue      = 0x8000000000L;
 207 
 208     // Can compare masked values with these to determine
 209     // numeric or lexical types.
 210     public static int
 211         valueNotNumeric             = 0x0000,
 212         valueDigit                  = 0x0400,
 213         valueStrangeNumeric         = 0x0800,
 214         valueJavaSupradecimal       = 0x0C00,
 215         valueIgnorable              = 0x1000,
 216         valueJavaOnlyPart           = 0x2000,
 217         valueJavaUnicodePart        = 0x3000,
 218         valueJavaWhitespace         = 0x4000,
 219         valueJavaStartUnicodePart   = 0x5000,
 220         valueJavaOnlyStart          = 0x6000,
 221         valueJavaUnicodeStart       = 0x7000,
 222         lowJavaStart                = 0x5000,
 223         nonzeroJavaPart             = 0x3000,
 224         valueUnicodeStart           = 0x7000;
 225 
 226     // these values are used when only identifier properties are generated
 227     // for use in verifier code. Shortens the property down to a single byte.
 228     private static final int
 229         bitJavaStart            = 0x02,
 230         bitJavaPart             = 0x01,
 231         maskIsJavaIdentifierPart = bitJavaPart,
 232         maskIsJavaIdentifierStart = bitJavaStart;
 233 
 234     static int maxOffset = maskCase/2 ;
 235     static int minOffset = -maxOffset;
 236 
 237     /* The following routines provide simple, concise formatting of long integer values.
 238      The number in the name of the method indicates the desired number of characters
 239      to be produced.  If the number of digits required to represent the integer value
 240      is less than that number, then the output is padded on the left  with zeros
 241      (for hex) or with spaces (for decimal).  If the number of digits required to
 242      represent the integer value is greater than the desired number, then all the digits
 243      that are required are actually produced.
 244     */
 245 
 246     static String hex(long n) { return Long.toHexString(n).toUpperCase(); }
 247 
 248     static String hex2(long n) {
 249         String q = Long.toHexString(n &amp; 0xFF).toUpperCase();
 250         return &quot;00&quot;.substring(Math.min(2, q.length())) + q;
 251     }
 252 
 253     static String hex4(long n) {
 254         String q = Long.toHexString(n &amp; 0xFFFF).toUpperCase();
 255         return &quot;0000&quot;.substring(Math.min(4, q.length())) + q;
 256     }
 257 
 258     static String hex8(long n) {
 259         String q = Long.toHexString(n &amp; 0xFFFFFFFFL).toUpperCase();
 260         return &quot;00000000&quot;.substring(Math.min(8, q.length())) + q;
 261     }
 262 
 263     static String hex16(long n) {
 264         String q = Long.toHexString(n).toUpperCase();
 265         return &quot;0000000000000000&quot;.substring(Math.min(16, q.length())) + q;
 266     }
 267 
 268     static String dec3(long n) {
 269         String q = Long.toString(n);
 270         return &quot;   &quot;.substring(Math.min(3, q.length())) + q;
 271     }
 272 
 273     static String dec5(long n) {
 274         String q = Long.toString(n);
 275         return &quot;     &quot;.substring(Math.min(5, q.length())) + q;
 276     }
 277 
 278     /* This routine is called when some failure occurs. */
 279 
 280     static void FAIL(String s) {
 281         System.out.println(&quot;** &quot; + s);
 282     }
 283 
 284     /**
 285     * Given the data from the Unicode specification file, this routine builds a map.
 286     *
 287     * The specification file is assumed to contain its data in sorted order by
 288     * character code; as a result, the array passed as an argument to this method
 289     * has its components in the same sorted order, with one entry for each defined
 290     * Unicode character or character range.  (A range is indicated by two consecutive
 291     * entries, such that the name of the first entry begins with &quot;&lt;&quot; and ends with
 292     * &quot;First&gt;&quot; and the second entry begins with &quot;&lt;&quot; and ends with &quot;Last&gt;&quot;.)  This is
 293     * therefore a sparse representation of the character property data.
 294     *
 295     * The resulting map is dense representation of the character data.  It contains
 296     * 2^16 = 65536 entries, each of which is a long integer.  (Right now only 32 bits
 297     * of this long value are used, but type long is used rather than int to facilitate
 298     * future extensions of this source code generator that might require more than
 299     * 32 bits to encode relevant character properties.)  Entry k holds the encoded
 300     * properties for character k.
 301     *
 302     * Method buildMap manages the transformation from the sparse representation to
 303     * the dense representation.  It calls method buildOne to handle the encoding
 304     * of character property data from a single UnicodeSpec object into 32 bits.
 305     * For undefined characters, method buildOne is not called and the map entry for
 306     * that character is set to UnicodeSpec.UNASSIGNED.
 307     *
 308     * @param data       character property data from the Unicode specification file
 309     * @return   an array of length 65536 with one entry for every possible char value
 310     *
 311     * @see GenerateCharacter#buildOne
 312     */
 313 
 314     static long[] buildMap(UnicodeSpec[] data, SpecialCaseMap[] specialMaps, PropList propList)
 315     {
 316         long[] result;
 317         if (bLatin1 == true) {
 318             result = new long[256];
 319         } else {
 320             result = new long[1&lt;&lt;16];
 321         }
 322         int k=0;
 323         int codePoint = plane&lt;&lt;16;
 324         UnicodeSpec nonCharSpec = new UnicodeSpec();
 325         for (int j = 0; j &lt; data.length &amp;&amp; k &lt; result.length; j++) {
 326             if (data[j].codePoint == codePoint) {
 327                 result[k] = buildOne(codePoint, data[j], specialMaps);
 328                 ++k;
 329                 ++codePoint;
 330             }
 331             else if(data[j].codePoint &gt; codePoint) {
 332                 if (data[j].name.endsWith(&quot;Last&gt;&quot;)) {
 333                     // build map data for all chars except last in range
 334                     while (codePoint &lt; data[j].codePoint &amp;&amp; k &lt; result.length) {
 335                         result[k] = buildOne(codePoint, data[j], specialMaps);
 336                         ++k;
 337                         ++codePoint;
 338                     }
 339                 }
 340                 else {
 341                     // we have a few unassigned chars before data[j].codePoint
 342                     while (codePoint &lt; data[j].codePoint &amp;&amp; k &lt; result.length) {
 343                         result[k] = buildOne(codePoint, nonCharSpec, specialMaps);
 344                         ++k;
 345                         ++codePoint;
 346                     }
 347                 }
 348                 k = data[j].codePoint &amp; 0xFFFF;
 349                 codePoint = data[j].codePoint;
 350                 result[k] = buildOne(codePoint, data[j], specialMaps);
 351                 ++k;
 352                 ++codePoint;
 353             }
 354             else {
 355                 System.out.println(&quot;An error has occured during spec mapping.&quot;);
 356                 System.exit(0);
 357             }
 358         }
 359         // if there are still unprocessed chars, process them
 360         // as unassigned/undefined.
 361         codePoint = (plane&lt;&lt;16) | k;
 362         while (k &lt; result.length) {
 363             result[k] = buildOne(codePoint, nonCharSpec, specialMaps);
 364             ++k;
 365             ++codePoint;
 366         }
 367         // now add all extra supported properties from PropList, to the
 368         // upper 16-bit
 369         addExProp(result, propList, &quot;Other_Lowercase&quot;, maskOtherLowercase);
 370         addExProp(result, propList, &quot;Other_Uppercase&quot;, maskOtherUppercase);
 371         addExProp(result, propList, &quot;Other_Alphabetic&quot;, maskOtherAlphabetic);
 372         addExProp(result, propList, &quot;Ideographic&quot;, maskIdeographic);
 373         //addExProp(result, propList, &quot;Other_Math&quot;, maskOtherMath);
 374         //addExProp(result, propList, &quot;Noncharacter_CodePoint&quot;, maskNoncharacterCP);
 375         addExProp(result, propList, &quot;ID_Start&quot;, maskIDStart);
 376         addExProp(result, propList, &quot;ID_Continue&quot;, maskIDContinue);
 377 
 378         return result;
 379     }
 380 
 381     // The maximum and minimum offsets found while scanning the database
 382     static int maxOffsetSeen = 0;
 383     static int minOffsetSeen = 0;
 384 
 385     /**
 386      * Some Unicode separator characters are not considered Java whitespace.
 387      * @param c character to test
 388      * @return true if c in an invalid Java whitespace character, false otherwise.
 389      */
 390     static boolean isInvalidJavaWhiteSpace(int c) {
 391         int[] exceptions = {0x00A0, 0x2007, 0x202F, 0xFEFF};
 392         boolean retValue = false;
 393         for(int x=0;x&lt;exceptions.length;x++) {
 394             if(c == exceptions[x]) {
 395                 retValue = true;
 396                 break;
 397             }
 398         }
 399         return retValue;
 400 
 401     }
 402 
 403     /**
 404     * Given the character property data for one Unicode character, encode the data
 405     * of interest into a single long integer value.  (Right now only 32 bits
 406     * of this long value are used, but type long is used rather than int to facilitate
 407     * future extensions of this source code generator that might require more than
 408     * 32 bits to encode relevant character properties.)
 409     *
 410     * @param c   the character code for which to encode property data
 411     * @param us  property data record from the Unicode specification file
 412     *            (its character code might not be equal to c if it specifies data
 413     *            for a range of characters)
 414     * @return   an encoded long value that contains the properties for a single char
 415     *
 416     * @see GenerateCharacter#buildMap
 417     */
 418 
 419     static long buildOne(int c, UnicodeSpec us, SpecialCaseMap[] specialMaps) {
 420         long resultA = 0;
 421         // record the general category
 422         resultA |= us.generalCategory;
 423 
 424         // record the numeric properties
 425         NUMERIC: {
 426         STRANGE: {
 427             int val = 0;
 428             // c is A-Z
 429             if ((c &gt;= 0x0041) &amp;&amp; (c &lt;= 0x005A)) {
 430                 val = c - 0x0041;
 431                 resultA |= valueJavaSupradecimal;
 432             // c is a-z
 433             } else if ((c &gt;= 0x0061) &amp;&amp; (c &lt;= 0x007A)) {
 434                 val = c - 0x0061;
 435                 resultA |= valueJavaSupradecimal;
 436             // c is a full-width A-Z
 437             } else if ((c &gt;= 0xFF21) &amp;&amp; (c &lt;= 0xFF3A)) {
 438                 val = c - 0xFF21;
 439                 resultA |= valueJavaSupradecimal;
 440             // c is a full-width a-z
 441             } else if ((c &gt;= 0xFF41) &amp;&amp; (c &lt;= 0xFF5A)) {
 442                 val = c - 0xFF41;
 443                 resultA |= valueJavaSupradecimal;
 444             } else if (us.isDecimalValue()) {
 445                 val = us.decimalValue;
 446                 resultA |= valueDigit;
 447             } else if (us.isDigitValue()) {
 448                 val = us.digitValue;
 449                 resultA |= valueDigit;
 450             } else {
 451                 if (us.numericValue.length() == 0) {
 452                     break NUMERIC;                      // no numeric value at all
 453                 } else {
 454                     try {
 455                         val = Integer.parseInt(us.numericValue);
 456                         if (val &gt;= 32 || val &lt; 0) break STRANGE;
 457                         if (c == 0x215F) break STRANGE;
 458                     } catch(NumberFormatException e) {
 459                         break STRANGE;
 460                     }
 461                     resultA |= valueDigit;
 462                 }
 463             }
 464             if (val &gt;= 32 || val &lt; 0) break STRANGE;
 465             resultA |= ((val - c &amp; maskDigit) &lt;&lt; shiftDigitOffset);
 466             break NUMERIC;
 467         } // end STRANGE
 468         resultA |= valueStrangeNumeric;
 469         } // end NUMERIC
 470 
 471         // record case mapping
 472         int offset = 0;
 473         // might have a 1:M mapping
 474         int specialMap = SpecialCaseMap.find(c, specialCaseMaps);
 475         boolean bHasUpper = (us.hasUpperMap()) || (specialMap != -1);
 476         if (bHasUpper) {
 477             resultA |= maskUpperCase;
 478         }
 479         if (specialMap != -1) {
 480             // has mapping, but cannot record the
 481             // proper offset; can only flag it and provide special case
 482             // code in Character.java
 483             offset = -1;
 484         }
 485         else if (us.hasUpperMap())  {
 486             offset = c - us.upperMap;
 487         }
 488 
 489         if (us.hasLowerMap()) {
 490             resultA |= maskLowerCase;
 491             if (offset == 0)
 492                 offset = us.lowerMap - c;
 493             else if (offset != (us.lowerMap - c)) {
 494                 if (DEBUG) {
 495                 FAIL(&quot;Character &quot; + hex(c) +
 496                 &quot; has incompatible lowercase and uppercase mappings&quot;);
 497                 }
 498             }
 499         }
 500         if ((us.hasTitleMap() &amp;&amp; us.titleMap != us.upperMap) ||
 501             (bHasUpper &amp;&amp; us.hasLowerMap())) {
 502             resultA |= maskTitleCase;
 503         }
 504         if (bHasUpper &amp;&amp; !us.hasLowerMap() &amp;&amp; !us.hasTitleMap() &amp;&amp; verbose) {
 505             System.out.println(&quot;Warning: Character &quot; + hex4(c) + &quot; has upper but &quot; +
 506                                &quot;no title case; Java won&#39;t know this&quot;);
 507         }
 508         if (offset &lt; minOffsetSeen) minOffsetSeen = offset;
 509         if (offset &gt; maxOffsetSeen) maxOffsetSeen = offset;
 510         if (offset &gt; maxOffset || offset &lt; minOffset) {
 511             if (DEBUG) {
 512             FAIL(&quot;Case offset &quot; + offset + &quot; for character &quot; + hex4(c) + &quot; must be handled as a special case&quot;);
 513             }
 514             offset = maskCase;
 515         }
 516         resultA |= ((offset &amp; maskCase) &lt;&lt; shiftCaseOffset);
 517 
 518         // record lexical info about this character
 519         if (us.generalCategory == UnicodeSpec.LOWERCASE_LETTER
 520                 || us.generalCategory == UnicodeSpec.UPPERCASE_LETTER
 521                 || us.generalCategory == UnicodeSpec.TITLECASE_LETTER
 522                 || us.generalCategory == UnicodeSpec.MODIFIER_LETTER
 523                 || us.generalCategory == UnicodeSpec.OTHER_LETTER
 524                 || us.generalCategory == UnicodeSpec.LETTER_NUMBER) {
 525             resultA |= valueJavaUnicodeStart;
 526         }
 527         else if (us.generalCategory == UnicodeSpec.COMBINING_SPACING_MARK
 528                 || us.generalCategory == UnicodeSpec.NON_SPACING_MARK
 529                 || us.generalCategory == UnicodeSpec.DECIMAL_DIGIT_NUMBER) {
 530             resultA |= valueJavaUnicodePart;
 531         }
 532         else if (us.generalCategory == UnicodeSpec.CONNECTOR_PUNCTUATION) {
 533             resultA |= valueJavaStartUnicodePart;
 534         }
 535         else if (us.generalCategory == UnicodeSpec.CURRENCY_SYMBOL) {
 536             resultA |= valueJavaOnlyStart;
 537         }
 538         else if (((c &gt;= 0x0000) &amp;&amp; (c &lt;= 0x0008))
 539                 || ((c &gt;= 0x000E) &amp;&amp; (c &lt;= 0x001B))
 540                 || ((c &gt;= 0x007F) &amp;&amp; (c &lt;= 0x009F))
 541                 || us.generalCategory == UnicodeSpec.FORMAT) {
 542             resultA |= valueIgnorable;
 543         }
 544         else if (us.generalCategory == UnicodeSpec.SPACE_SEPARATOR
 545                 || us.generalCategory == UnicodeSpec.LINE_SEPARATOR
 546                 || us.generalCategory == UnicodeSpec.PARAGRAPH_SEPARATOR) {
 547             if (!isInvalidJavaWhiteSpace(c)) resultA |= valueJavaWhitespace;
 548         }
 549         else if (((c &gt;= 0x0009) &amp;&amp; (c &lt;= 0x000D))
 550                 || ((c &gt;= 0x001C) &amp;&amp; (c &lt;= 0x001F))) {
 551             resultA |= valueJavaWhitespace;
 552         }
 553 
 554         // record bidi category
 555         if (!nobidi) {
 556             int tmpBidi =
 557                 (us.bidiCategory &gt; UnicodeSpec.DIRECTIONALITY_OTHER_NEUTRALS ||
 558                     us.bidiCategory == -1) ? maskBidi : (us.bidiCategory &lt;&lt; shiftBidi);
 559             resultA |= tmpBidi;
 560         }
 561 
 562         // record mirrored property
 563         if (!nomirror) {
 564             resultA |= us.mirrored ? maskMirrored : 0;
 565         }
 566 
 567         if (identifiers) {
 568             long replacement = 0;
 569             if ((resultA &amp; maskIdentifierInfo) &gt;= lowJavaStart) {
 570                 replacement |= bitJavaStart;
 571             }
 572             if ( ((resultA &amp; nonzeroJavaPart) != 0)
 573                     &amp;&amp; ((resultA &amp; maskIdentifierInfo) != valueIgnorable)) {
 574                 replacement |= bitJavaPart;
 575             }
 576             resultA = replacement;
 577         }
 578         return resultA;
 579     }
 580 
 581     static void addExProp(long[] map, PropList propList, String prop, long mask) {
 582         List&lt;Integer&gt; cps = propList.codepoints(prop);
 583         if (cps != null) {
 584             for (Integer cp : cps) {
 585                 if (cp &lt; map.length)
 586                     map[cp] |= mask;
 587             }
 588         }
 589     }
 590 
 591     /**
 592     * This is the heart of the table compression strategy.  The inputs are a map
 593     * and a number of bits (size).  The map is simply an array of long integer values;
 594     * the number of bits indicates how index values for that map are to be split.
 595     * The length of the given map must be a multiple of (1 &lt;&lt; size).  The result is
 596     * a new map z and a compressed table t such that for every valid index value k
 597     * for the original map, t[(z[k&gt;&gt;size]&lt;&lt;size)|(k &amp; ((1&lt;&lt;size)-1))] == map[k].
 598     *
 599     * In other words, the index k can be split into two parts, namely the &quot;size&quot;
 600     * low-order bits and all the remaining high-order bits; the high-order bits are then
 601     * remapped by map z to produce an index into table t.  In effect, the data of the
 602     * original map m is broken up into blocks of size (1&lt;&lt;size); the compression relies
 603     * on the expectation that many of these blocks will be identical and therefore need
 604     * be represented only once in the compressed table t.
 605     *
 606     * This method is intended to be used iteratively.  The first map to be handed
 607     * to it is the one constructed by method buildMap.  After that, the first of the
 608     * two arrays returned by this method is fed back into it for further compression.
 609     * At the end of the iteration, one has a starter map and a sequence of tables.
 610     *
 611     * The algorithm used to implement this computation is straightforward and not
 612     * especially clever.  It uses brute-force linear search (the loop labeled MIDDLE)
 613     * to locate identical blocks, so overall the time complexity of the algorithm
 614     * is quadratic in the length of the input map.  Fortunately, speed is not crucial
 615     * to this application.
 616     *
 617     * @param map                a map to be compressed
 618     * @param size       the number of index bits to be split off by the compression
 619     * @return   an array of length 2 containing two arrays; the first is a new map
 620     *           and the second is a compressed data table
 621     *
 622     * @see GenerateCharacter#buildMap
 623     */
 624 
 625     static long[][] buildTable(long[] map, int size) {
 626         int n = map.length;
 627         if (((n &gt;&gt; size) &lt;&lt; size) != n) {
 628             FAIL(&quot;Length &quot; + n + &quot; is not a multiple of &quot; + (1 &lt;&lt; size));
 629         }
 630         int m = 1 &lt;&lt; size;
 631         // We know the final length of the new map up front.
 632         long[] newmap = new long[n &gt;&gt; size];
 633         // The buffer is used temporarily to hold data for the compressed table
 634         // because we don&#39;t know its final length yet.
 635         long[] buffer = new long[n];
 636         int ptr = 0;
 637 OUTER:  for (int i = 0; i &lt; n; i += m) {
 638             // For every block of size m in the original map...
 639     MIDDLE: for (int j = 0; j &lt; ptr; j += m) {
 640             // Find out whether there is already a block just like it in the buffer.
 641                 for (int k = 0; k &lt; m; k++) {
 642                     if (buffer[j+k] != map[i+k])
 643                         continue MIDDLE;
 644                 }
 645                 // There is a block just like it at position j, so just
 646                 // put its index into the new map (thereby sharing it).
 647                 newmap[i &gt;&gt; size] = (j &gt;&gt; size);
 648                 continue OUTER;
 649             } // end MIDDLE
 650             // There is no block just like it already, so add it to
 651             // the buffer and put its index into the new map.
 652             for (int k = 0; k &lt; m; k++) {
 653                 buffer[ptr+k] = map[i+k];
 654             }
 655             newmap[i &gt;&gt; size] = (ptr &gt;&gt; size);
 656             ptr += m;
 657         } // end OUTER
 658         // Now we know how long the compressed table should be,
 659         // so create a new array and copy data from the temporary buffer.
 660         long[] newdata = new long[ptr];
 661         for (int j = 0; j &lt; ptr; j++) {
 662             newdata[j] = buffer[j];
 663         }
 664         // Return the new map and the new data table.
 665         long[][] result = { newmap, newdata };
 666         return result;
 667     }
 668 
 669     /**
 670     * Once the compressed tables have been computed, this method reads in a
 671     * template file for the source code to be generated and writes out the final
 672     * source code by acting as a sort of specialized macro processor.
 673     *
 674     * The first output line is a comment saying that the file was automatically
 675     * generated; it includes a timestamp.  All other output is generated by
 676     * reading a line from the template file, performing macro replacements,
 677     * and then writing the resulting line or lines of code to the output file.
 678     *
 679     * This method handles the I/O, the timestamp comment, and the locating of
 680     * macro calls within each input line.  The method replaceCommand is called
 681     * to generate replacement text for each macro call.
 682     *
 683     * Macro calls to be replaced are indicated in the template file by
 684     * occurrences of the commandMarker &quot;$$&quot;.  The rest of the call may consist
 685     * of Java letters (including the underscore &quot;_&quot;) and also of balanced
 686     * parentheses.
 687     *
 688     * @param theTemplateFileName
 689     *           the file name for the template input file
 690     * @param theOutputFileName
 691     *           the file name for the source code output file
 692     *
 693     *     @see GenerateCharacter#replaceCommand
 694     */
 695 
 696     static void generateCharacterClass(String theTemplateFileName,
 697                                        String theOutputFileName)
 698         throws FileNotFoundException, IOException {
 699         BufferedReader in = new BufferedReader(new FileReader(theTemplateFileName));
 700         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(theOutputFileName)));
 701         out.println(commentStart +
 702             &quot; This file was generated AUTOMATICALLY from a template file &quot; +
<a name="2" id="anc2"></a><span class="line-modified"> 703             commentEnd);</span>
 704         int marklen = commandMarker.length();
 705         LOOP: while(true) {
 706             try {
 707                 String line = in.readLine();
 708                 if (line == null) break LOOP;
 709                 int pos = 0;
 710                 int depth = 0;
 711                 while ((pos = line.indexOf(commandMarker, pos)) &gt;= 0) {
 712                     int newpos = pos + marklen;
 713                     char ch = &#39;x&#39;;
 714                     SCAN: while (newpos &lt; line.length() &amp;&amp;
 715                             (Character.isJavaIdentifierStart(ch = line.charAt(newpos))
 716                             || ch == &#39;(&#39; || (ch == &#39;)&#39; &amp;&amp; depth &gt; 0))) {
 717                         ++newpos;
 718                         if (ch == &#39;(&#39;) {
 719                             ++depth;
 720                         }
 721                         else if (ch == &#39;)&#39;) {
 722                             --depth;
 723                             if (depth == 0)
 724                                 break SCAN;
 725                         }
 726                     }
 727                     String replacement = replaceCommand(line.substring(pos + marklen, newpos));
 728                     line = line.substring(0, pos) + replacement + line.substring(newpos);
 729                     pos += replacement.length();
 730                 }
 731                 out.println(line);
 732             }
 733             catch (IOException e) {
 734                 break LOOP;
 735             }
 736         }
 737         in.close();
 738         out.close();
 739     }
 740 
 741     /**
 742     * The replaceCommand method takes a command (a macro call without the
 743     * leading marker &quot;$$&quot;) and computes replacement text for it.
 744     *
 745     * Most of the commands are simply names of integer constants that are defined
 746     * in the source code of this GenerateCharacter class.  The replacement text is
 747     * simply the value of the constant as an appropriately formatted integer literal.
 748     *
 749     * Two cases are more complicated, however.  The command &quot;Tables&quot; causes the
 750     * final map and compressed tables to be emitted, with elaborate comments
 751     * describing their contents.  (This is actually handled by method genTables.)
 752     * The command &quot;Lookup(xxx)&quot;, where &quot;xxx&quot; is the name of a variable, generates
 753     * an expression that will return the character property data for the character
 754     * whose code is the value of the variable &quot;xxx&quot;.  (this is handled by method
 755     * &quot;genAccess&quot;.)
 756     *
 757     * @param x  a command from the template file to be replaced
 758     * @return   the replacement text, as a String
 759     *
 760     * @see GenerateCharacter#genTables
 761     * @see GenerateCharacter#genAccess
 762     * @see GenerateCharacter#generateCharacterClass
 763     */
 764 
 765     static String replaceCommand(String x) {
 766         if (x.equals(&quot;Tables&quot;)) return genTables();
 767         if (x.equals(&quot;Initializers&quot;)) return genInitializers();
 768         if (x.length() &gt;= 9 &amp;&amp; x.substring(0, 7).equals(&quot;Lookup(&quot;) &amp;&amp;
 769                 x.substring(x.length()-1).equals(&quot;)&quot;) )
 770             return genAccess(&quot;A&quot;, x.substring(7, x.length()-1), (identifiers ? 2 : 32));
 771         if (x.length() &gt;= 11 &amp;&amp; x.substring(0, 9).equals(&quot;LookupEx(&quot;) &amp;&amp;
 772                 x.substring(x.length()-1).equals(&quot;)&quot;) )
 773             return genAccess(&quot;B&quot;, x.substring(9, x.length()-1), 16);
 774         if (x.equals(&quot;shiftType&quot;)) return Long.toString(shiftType);
 775         if (x.equals(&quot;shiftIdentifierInfo&quot;)) return Long.toString(shiftIdentifierInfo);
 776         if (x.equals(&quot;maskIdentifierInfo&quot;)) return &quot;0x&quot; + hex8(maskIdentifierInfo);
 777         if (x.equals(&quot;maskUnicodePart&quot;)) return &quot;0x&quot; + hex8(maskUnicodePart);
 778         if (x.equals(&quot;shiftCaseOffset&quot;)) return Long.toString(shiftCaseOffset);
 779         if (x.equals(&quot;shiftCaseInfo&quot;)) return Long.toString(shiftCaseInfo);
 780         if (x.equals(&quot;shiftCaseOffsetSign&quot;)) return Long.toString(shiftCaseOffsetSign);
 781         if (x.equals(&quot;maskCase&quot;)) return &quot;0x&quot; + hex8(maskCase);
 782         if (x.equals(&quot;maskCaseOffset&quot;)) return &quot;0x&quot; + hex8(maskCaseOffset);
 783         if (x.equals(&quot;maskLowerCase&quot;)) return &quot;0x&quot; + hex8(maskLowerCase);
 784         if (x.equals(&quot;maskUpperCase&quot;)) return &quot;0x&quot; + hex8(maskUpperCase);
 785         if (x.equals(&quot;maskTitleCase&quot;)) return &quot;0x&quot; + hex8(maskTitleCase);
 786         if (x.equals(&quot;maskOtherLowercase&quot;)) return &quot;0x&quot; + hex4(maskOtherLowercase &gt;&gt; 32);
 787         if (x.equals(&quot;maskOtherUppercase&quot;)) return &quot;0x&quot; + hex4(maskOtherUppercase &gt;&gt; 32);
 788         if (x.equals(&quot;maskOtherAlphabetic&quot;)) return &quot;0x&quot; + hex4(maskOtherAlphabetic &gt;&gt; 32);
 789         if (x.equals(&quot;maskIdeographic&quot;)) return &quot;0x&quot; + hex4(maskIdeographic &gt;&gt; 32);
 790         if (x.equals(&quot;maskIDStart&quot;)) return &quot;0x&quot; + hex4(maskIDStart &gt;&gt; 32);
 791         if (x.equals(&quot;maskIDContinue&quot;)) return &quot;0x&quot; + hex4(maskIDContinue &gt;&gt; 32);
 792         if (x.equals(&quot;valueIgnorable&quot;)) return &quot;0x&quot; + hex8(valueIgnorable);
 793         if (x.equals(&quot;valueJavaUnicodeStart&quot;)) return &quot;0x&quot; + hex8(valueJavaUnicodeStart);
 794         if (x.equals(&quot;valueJavaOnlyStart&quot;)) return &quot;0x&quot; + hex8(valueJavaOnlyStart);
 795         if (x.equals(&quot;valueJavaUnicodePart&quot;)) return &quot;0x&quot; + hex8(valueJavaUnicodePart);
 796         if (x.equals(&quot;valueJavaOnlyPart&quot;)) return &quot;0x&quot; + hex8(valueJavaOnlyPart);
 797         if (x.equals(&quot;valueJavaWhitespace&quot;)) return &quot;0x&quot; + hex8(valueJavaWhitespace);
 798         if (x.equals(&quot;lowJavaStart&quot;)) return &quot;0x&quot; + hex8(lowJavaStart);
 799         if (x.equals(&quot;nonzeroJavaPart&quot;)) return &quot;0x&quot; + hex8(nonzeroJavaPart);
 800         if (x.equals(&quot;bitJavaStart&quot;)) return &quot;0x&quot; + hex8(bitJavaStart);
 801         if (x.equals(&quot;bitJavaPart&quot;)) return Long.toString(bitJavaPart);
 802         if (x.equals(&quot;valueUnicodeStart&quot;)) return &quot;0x&quot; + hex8(valueUnicodeStart);
 803         if (x.equals(&quot;maskIsJavaIdentifierStart&quot;)) return &quot;0x&quot; + hex(maskIsJavaIdentifierStart);
 804         if (x.equals(&quot;maskIsJavaIdentifierPart&quot;)) return &quot;0x&quot; + hex(maskIsJavaIdentifierPart);
 805         if (x.equals(&quot;shiftDigitOffset&quot;)) return Long.toString(shiftDigitOffset);
 806         if (x.equals(&quot;maskDigitOffset&quot;)) return &quot;0x&quot; + hex(maskDigitOffset);
 807         if (x.equals(&quot;maskDigit&quot;)) return &quot;0x&quot; + hex(maskDigit);
 808         if (x.equals(&quot;shiftNumericType&quot;)) return Long.toString(shiftNumericType);
 809         if (x.equals(&quot;maskNumericType&quot;)) return &quot;0x&quot; + hex(maskNumericType);
 810         if (x.equals(&quot;valueNotNumeric&quot;)) return &quot;0x&quot; + hex8(valueNotNumeric);
 811         if (x.equals(&quot;valueDigit&quot;)) return &quot;0x&quot; + hex8(valueDigit);
 812         if (x.equals(&quot;valueStrangeNumeric&quot;)) return &quot;0x&quot; + hex8(valueStrangeNumeric);
 813         if (x.equals(&quot;valueJavaSupradecimal&quot;)) return &quot;0x&quot; + hex8(valueJavaSupradecimal);
 814         if (x.equals(&quot;valueDigit&quot;)) return &quot;0x&quot; + hex8(valueDigit);
 815         if (x.equals(&quot;valueStrangeNumeric&quot;)) return &quot;0x&quot; + hex8(valueStrangeNumeric);
 816         if (x.equals(&quot;maskType&quot;)) return &quot;0x&quot; + hex(maskType);
 817         if (x.equals(&quot;shiftBidi&quot;)) return Long.toString(shiftBidi);
 818         if (x.equals(&quot;maskBidi&quot;)) return &quot;0x&quot; + hex(maskBidi);
 819         if (x.equals(&quot;maskMirrored&quot;)) return &quot;0x&quot; + hex8(maskMirrored);
 820         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.UNASSIGNED][UnicodeSpec.LONG]))
 821             return Integer.toString(UnicodeSpec.UNASSIGNED);
 822         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.UPPERCASE_LETTER][UnicodeSpec.LONG]))
 823             return Integer.toString(UnicodeSpec.UPPERCASE_LETTER);
 824         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.LOWERCASE_LETTER][UnicodeSpec.LONG]))
 825             return Integer.toString(UnicodeSpec.LOWERCASE_LETTER);
 826         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.TITLECASE_LETTER][UnicodeSpec.LONG]))
 827             return Integer.toString(UnicodeSpec.TITLECASE_LETTER);
 828         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.MODIFIER_LETTER][UnicodeSpec.LONG]))
 829              return Integer.toString(UnicodeSpec.MODIFIER_LETTER);
 830         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.OTHER_LETTER][UnicodeSpec.LONG]))
 831              return Integer.toString(UnicodeSpec.OTHER_LETTER);
 832         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.NON_SPACING_MARK][UnicodeSpec.LONG]))
 833              return Integer.toString(UnicodeSpec.NON_SPACING_MARK);
 834         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.ENCLOSING_MARK][UnicodeSpec.LONG]))
 835              return Integer.toString(UnicodeSpec.ENCLOSING_MARK);
 836         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.COMBINING_SPACING_MARK][UnicodeSpec.LONG]))
 837              return Integer.toString(UnicodeSpec.COMBINING_SPACING_MARK);
 838         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.DECIMAL_DIGIT_NUMBER][UnicodeSpec.LONG]))
 839              return Integer.toString(UnicodeSpec.DECIMAL_DIGIT_NUMBER);
 840         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.OTHER_NUMBER][UnicodeSpec.LONG]))
 841              return Integer.toString(UnicodeSpec.OTHER_NUMBER);
 842         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.SPACE_SEPARATOR][UnicodeSpec.LONG]))
 843              return Integer.toString(UnicodeSpec.SPACE_SEPARATOR);
 844         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.LINE_SEPARATOR][UnicodeSpec.LONG]))
 845              return Integer.toString(UnicodeSpec.LINE_SEPARATOR);
 846         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.PARAGRAPH_SEPARATOR][UnicodeSpec.LONG]))
 847              return Integer.toString(UnicodeSpec.PARAGRAPH_SEPARATOR);
 848         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.CONTROL][UnicodeSpec.LONG]))
 849             return Integer.toString(UnicodeSpec.CONTROL);
 850         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.FORMAT][UnicodeSpec.LONG]))
 851             return Integer.toString(UnicodeSpec.FORMAT);
 852         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.PRIVATE_USE][UnicodeSpec.LONG]))
 853             return Integer.toString(UnicodeSpec.PRIVATE_USE);
 854         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.SURROGATE][UnicodeSpec.LONG]))
 855             return Integer.toString(UnicodeSpec.SURROGATE);
 856         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.DASH_PUNCTUATION][UnicodeSpec.LONG]))
 857             return Integer.toString(UnicodeSpec.DASH_PUNCTUATION);
 858         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.START_PUNCTUATION][UnicodeSpec.LONG]))
 859             return Integer.toString(UnicodeSpec.START_PUNCTUATION);
 860         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.END_PUNCTUATION][UnicodeSpec.LONG]))
 861             return Integer.toString(UnicodeSpec.END_PUNCTUATION);
 862         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.INITIAL_QUOTE_PUNCTUATION][UnicodeSpec.LONG]))
 863             return Integer.toString(UnicodeSpec.INITIAL_QUOTE_PUNCTUATION);
 864         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.FINAL_QUOTE_PUNCTUATION][UnicodeSpec.LONG]))
 865             return Integer.toString(UnicodeSpec.FINAL_QUOTE_PUNCTUATION);
 866         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.CONNECTOR_PUNCTUATION][UnicodeSpec.LONG]))
 867             return Integer.toString(UnicodeSpec.CONNECTOR_PUNCTUATION);
 868         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.OTHER_PUNCTUATION][UnicodeSpec.LONG]))
 869             return Integer.toString(UnicodeSpec.OTHER_PUNCTUATION);
 870         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.LETTER_NUMBER][UnicodeSpec.LONG]))
 871             return Integer.toString(UnicodeSpec.LETTER_NUMBER);
 872         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.MATH_SYMBOL][UnicodeSpec.LONG]))
 873             return Integer.toString(UnicodeSpec.MATH_SYMBOL);
 874         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.CURRENCY_SYMBOL][UnicodeSpec.LONG]))
 875             return Integer.toString(UnicodeSpec.CURRENCY_SYMBOL);
 876         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.MODIFIER_SYMBOL][UnicodeSpec.LONG]))
 877             return Integer.toString(UnicodeSpec.MODIFIER_SYMBOL);
 878         if (x.equals(UnicodeSpec.generalCategoryList[UnicodeSpec.OTHER_SYMBOL][UnicodeSpec.LONG]))
 879             return Integer.toString(UnicodeSpec.OTHER_SYMBOL);
 880         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_LEFT_TO_RIGHT][UnicodeSpec.LONG]))
 881             return Integer.toString(UnicodeSpec.DIRECTIONALITY_LEFT_TO_RIGHT);
 882         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING][UnicodeSpec.LONG]))
 883             return Integer.toString(UnicodeSpec.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING);
 884         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE][UnicodeSpec.LONG]))
 885             return Integer.toString(UnicodeSpec.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE);
 886         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT][UnicodeSpec.LONG]))
 887             return Integer.toString(UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT);
 888         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC][UnicodeSpec.LONG]))
 889             return Integer.toString(UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC);
 890         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING][UnicodeSpec.LONG]))
 891             return Integer.toString(UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING);
 892         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE][UnicodeSpec.LONG]))
 893             return Integer.toString(UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE);
 894         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT][UnicodeSpec.LONG]))
 895             return Integer.toString(UnicodeSpec.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT);
 896         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_EUROPEAN_NUMBER][UnicodeSpec.LONG]))
 897             return Integer.toString(UnicodeSpec.DIRECTIONALITY_EUROPEAN_NUMBER);
 898         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR][UnicodeSpec.LONG]))
 899             return Integer.toString(UnicodeSpec.DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR);
 900         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR][UnicodeSpec.LONG]))
 901             return Integer.toString(UnicodeSpec.DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR);
 902         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_ARABIC_NUMBER][UnicodeSpec.LONG]))
 903             return Integer.toString(UnicodeSpec.DIRECTIONALITY_ARABIC_NUMBER);
 904         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_COMMON_NUMBER_SEPARATOR][UnicodeSpec.LONG]))
 905             return Integer.toString(UnicodeSpec.DIRECTIONALITY_COMMON_NUMBER_SEPARATOR);
 906         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_NONSPACING_MARK][UnicodeSpec.LONG]))
 907             return Integer.toString(UnicodeSpec.DIRECTIONALITY_NONSPACING_MARK);
 908          if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_BOUNDARY_NEUTRAL][UnicodeSpec.LONG]))
 909             return Integer.toString(UnicodeSpec.DIRECTIONALITY_BOUNDARY_NEUTRAL);
 910         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_PARAGRAPH_SEPARATOR][UnicodeSpec.LONG]))
 911             return Integer.toString(UnicodeSpec.DIRECTIONALITY_PARAGRAPH_SEPARATOR);
 912         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_SEGMENT_SEPARATOR][UnicodeSpec.LONG]))
 913             return Integer.toString(UnicodeSpec.DIRECTIONALITY_SEGMENT_SEPARATOR);
 914         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_WHITESPACE][UnicodeSpec.LONG]))
 915             return Integer.toString(UnicodeSpec.DIRECTIONALITY_WHITESPACE);
 916         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_OTHER_NEUTRALS][UnicodeSpec.LONG]))
 917             return Integer.toString(UnicodeSpec.DIRECTIONALITY_OTHER_NEUTRALS);
 918         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE][UnicodeSpec.LONG]))
 919             return Integer.toString(UnicodeSpec.DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE);
 920         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE][UnicodeSpec.LONG]))
 921             return Integer.toString(UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE);
 922         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_FIRST_STRONG_ISOLATE][UnicodeSpec.LONG]))
 923             return Integer.toString(UnicodeSpec.DIRECTIONALITY_FIRST_STRONG_ISOLATE);
 924         if (x.equals(UnicodeSpec.bidiCategoryList[UnicodeSpec.DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE][UnicodeSpec.LONG]))
 925             return Integer.toString(UnicodeSpec.DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE);
 926         FAIL(&quot;Unknown text substitution marker &quot; + commandMarker + x);
 927         return commandMarker + x;
 928     }
 929 
 930     /**
 931     * The genTables method generates source code for all the lookup tables
 932     * needed to represent the various Unicode character properties.
 933     * It simply calls the method genTable once for each table to be generated
 934     * and then generates a summary comment.
 935     *
 936     * @return   the replacement text for the &quot;Tables&quot; command, as a String
 937     *
 938     * @see GenerateCharacter#genTable
 939     * @see GenerateCharacter#replaceCommand
 940     */
 941     static String genTables() {
 942         int n = sizes.length;
 943         StringBuffer result = new StringBuffer();
 944         // liu : Add a comment showing the source of this table
 945         if (debug) {
 946             result.append(commentStart + &quot; The following tables and code generated using:&quot; +
 947                     commentEnd + &quot;\n  &quot;);
 948             result.append(commentStart + &#39; &#39; + commandLineDescription + commentEnd + &quot;\n  &quot;);
 949         }
 950         if (plane == 0 &amp;&amp; bLatin1 == false) {
 951             genCaseMapTableDeclaration(result);
 952             genCaseMapTable(initializers, specialCaseMaps);
 953         }
 954         int totalBytes = 0;
 955         for (int k = 0; k &lt; n - 1; k++) {
 956             genTable(result, tableNames[k], tables[k], 0, bytes[k]&lt;&lt;3, sizes[k], preshifted[k],
 957                 sizes[k+1], false, false, k==0);
 958             int s = bytes[k];
 959             if (s == 1 &amp;&amp; useCharForByte) {
 960                 s = 2;
 961             }
 962             totalBytes += tables[k].length * s;
 963         }
 964         genTable(result, &quot;A&quot;, tables[n - 1], 0, (identifiers ? 2 : 32),
 965             sizes[n - 1], false, 0, true, !(identifiers), false);
 966 
 967         // If we ever need more than 32 bits to represent the character properties,
 968         // then a table &quot;B&quot; may be needed as well.
 969         genTable(result, &quot;B&quot;, tables[n - 1], 32, 16, sizes[n - 1], false, 0, true, true, false);
 970 
 971         totalBytes += ((((tables[n - 1].length * (identifiers ? 2 : 32)) + 31) &gt;&gt; 5) &lt;&lt; 2);
 972         result.append(commentStart);
 973         result.append(&quot; In all, the character property tables require &quot;);
 974         result.append(totalBytes).append(&quot; bytes.&quot;).append(commentEnd);
 975         if (verbose) {
 976             System.out.println(&quot;The character property tables require &quot;
 977                  + totalBytes + &quot; bytes.&quot;);
 978         }
 979         return result.toString();
 980     }
 981 
 982     /**
 983      * The genInitializers method generates the body of the
 984      * ensureInitted() method, which enables lazy initialization of
 985      * the case map table and other tables.
 986      */
 987     static String genInitializers() {
 988         return initializers.toString();
 989     }
 990 
 991     /**
 992      * Return the total number of bytes needed by all tables.  This is a stripped-
 993      * down copy of genTables().
 994      */
 995     static int getTotalBytes() {
 996         int n = sizes.length;
 997         int totalBytes = 0;
 998         for (int k = 0; k &lt; n - 1; k++) {
 999             totalBytes += tables[k].length * bytes[k];
1000         }
1001         totalBytes += ((((tables[n - 1].length * (identifiers ? 2 : 32))
1002                          + 31) &gt;&gt; 5) &lt;&lt; 2);
1003         return totalBytes;
1004     }
1005 
1006     static void appendEscapedStringFragment(StringBuffer result,
1007                                             char[] line,
1008                                             int length,
1009                                             boolean lastFragment) {
1010         result.append(&quot;    \&quot;&quot;);
1011         for (int k=0; k&lt;length; ++k) {
1012             result.append(&quot;\\u&quot;);
1013             result.append(hex4(line[k]));
1014         }
1015         result.append(&quot;\&quot;&quot;);
1016         result.append(lastFragment ? &quot;;&quot; : &quot;+&quot;);
1017         result.append(&quot;\n&quot;);
1018     }
1019 
1020     static String SMALL_INITIALIZER =
1021         &quot;        { // THIS CODE WAS AUTOMATICALLY CREATED BY GenerateCharacter:\n&quot;+
1022         // &quot;            $$name = new $$type[$$size];\n&quot;+
1023         &quot;            int len = $$name_DATA.length();\n&quot;+
1024         &quot;            int j=0;\n&quot;+
1025         &quot;            for (int i=0; i&lt;len; ++i) {\n&quot;+
1026         &quot;                int c = $$name_DATA.charAt(i);\n&quot;+
1027         &quot;                for (int k=0; k&lt;$$entriesPerChar; ++k) {\n&quot;+
1028         &quot;                    $$name[j++] = ($$type)c;\n&quot;+
1029         &quot;                    c &gt;&gt;= $$bits;\n&quot;+
1030         &quot;                }\n&quot;+
1031         &quot;            }\n&quot;+
1032         &quot;            assert (j == $$size);\n&quot;+
1033         &quot;        }\n&quot;;
1034 
1035     static String SAME_SIZE_INITIALIZER =
1036         &quot;        { // THIS CODE WAS AUTOMATICALLY CREATED BY GenerateCharacter:\n&quot;+
1037         &quot;            assert ($$name_DATA.length() == $$size);\n&quot;+
1038         // &quot;            $$name = new $$type[$$size];\n&quot;+
1039         &quot;            for (int i=0; i&lt;$$size; ++i)\n&quot;+
1040         &quot;                $$name[i] = ($$type)$$name_DATA.charAt(i);\n&quot;+
1041         &quot;        }\n&quot;;
1042 
1043     static String BIG_INITIALIZER =
1044         &quot;        { // THIS CODE WAS AUTOMATICALLY CREATED BY GenerateCharacter:\n&quot;+
1045         // &quot;            $$name = new $$type[$$size];\n&quot;+
1046         &quot;            int len = $$name_DATA.length();\n&quot;+
1047         &quot;            int j=0;\n&quot;+
1048         &quot;            int charsInEntry=0;\n&quot;+
1049         &quot;            $$type entry=0;\n&quot;+
1050         &quot;            for (int i=0; i&lt;len; ++i) {\n&quot;+
1051         &quot;                entry |= $$name_DATA.charAt(i);\n&quot;+
1052         &quot;                if (++charsInEntry == $$charsPerEntry) {\n&quot;+
1053         &quot;                    $$name[j++] = entry;\n&quot;+
1054         &quot;                    entry = 0;\n&quot;+
1055         &quot;                    charsInEntry = 0;\n&quot;+
1056         &quot;                }\n&quot;+
1057         &quot;                else {\n&quot;+
1058         &quot;                    entry &lt;&lt;= 16;\n&quot;+
1059         &quot;                }\n&quot;+
1060         &quot;            }\n&quot;+
1061         &quot;            assert (j == $$size);\n&quot;+
1062         &quot;        }\n&quot;;
1063 
1064     static String INT32_INITIALIZER =
1065         &quot;        { // THIS CODE WAS AUTOMATICALLY CREATED BY GenerateCharacter:\n&quot;+
1066         &quot;            char[] data = $$name_DATA.toCharArray();\n&quot;+
1067         &quot;            assert (data.length == ($$size * 2));\n&quot;+
1068         &quot;            int i = 0, j = 0;\n&quot;+
1069         &quot;            while (i &lt; ($$size * 2)) {\n&quot;+
1070         &quot;                int entry = data[i++] &lt;&lt; 16;\n&quot;+
1071         &quot;                $$name[j++] = entry | data[i++];\n&quot;+
1072         &quot;            }\n&quot;+
1073         &quot;        }\n&quot;;
1074 
1075     static void addInitializer(String name, String type, int entriesPerChar,
1076                                int bits, int size) {
1077 
1078         String template = (entriesPerChar == 1) ? SAME_SIZE_INITIALIZER :
1079                           ((entriesPerChar &gt; 0) ? SMALL_INITIALIZER : BIG_INITIALIZER);
1080         if (entriesPerChar == -2) {
1081             template = INT32_INITIALIZER;
1082         }
1083         int marklen = commandMarker.length();
1084         int pos = 0;
1085         while ((pos = template.indexOf(commandMarker, pos)) &gt;= 0) {
1086             int newpos = pos + marklen;
1087             char ch = &#39;x&#39;;
1088             while (newpos &lt; template.length() &amp;&amp;
1089                    Character.isJavaIdentifierStart(ch = template.charAt(newpos)) &amp;&amp;
1090                    ch != &#39;_&#39;) // Don&#39;t allow this in token names
1091                 ++newpos;
1092             String token = template.substring(pos+marklen, newpos);
1093             String replacement = &quot;ERROR&quot;;
1094 
1095             if (token.equals(&quot;name&quot;)) replacement = name;
1096             else if (token.equals(&quot;type&quot;)) replacement = type;
1097             else if (token.equals(&quot;bits&quot;)) replacement = &quot;&quot;+bits;
1098             else if (token.equals(&quot;size&quot;)) replacement = &quot;&quot;+size;
1099             else if (token.equals(&quot;entriesPerChar&quot;)) replacement = &quot;&quot;+entriesPerChar;
1100             else if (token.equals(&quot;charsPerEntry&quot;)) replacement = &quot;&quot;+(-entriesPerChar);
1101             else FAIL(&quot;Unrecognized token: &quot; + token);
1102 
1103             template = template.substring(0, pos) + replacement + template.substring(newpos);
1104             pos += replacement.length();
1105         }
1106         initializers.append(template);
1107     }
1108 
1109     /**
1110     * The genTable method generates source code for one lookup table.
1111     * Most of the complexity stems from handling various options as to
1112     * the type of the array components, the precise representation of the
1113     * values, the format in which to render each value, the number of values
1114     * to emit on each line of source code, and the kinds of useful comments
1115     * to be generated.
1116     *
1117     * @param result     a StringBuffer, to which the generated source code
1118     *                   text is to be appended
1119     * @param name       the name of the table
1120     * @param table      the table data (an array of long values)
1121     * @param extract    a distance, in bits, by which each entry of the table
1122     *                   is to be right-shifted before it is processed
1123     * @param bits       the number of bits (not bytes) to be used to represent
1124     *                   each table entry
1125     * @param size       the table data is divided up into blocks of size (1&lt;&lt;size);
1126     *                   in this method, this information is used only to affect
1127     *                   how many table values are to be generated per line
1128     * @param preshifted if this flag is true, then the table entries are to be
1129     *                   emitted in a preshifted form; that is, each value should
1130     *                   be left-shifted by the amount &quot;shift&quot;, so that this work
1131     *                   is built into the table and need not be performed by an
1132     *                   explicit shift operator at run time
1133     * @param shift      this is the shift amount for preshifting of table entries
1134     * @param hexFormat  if this flag is true, table entries should be emitted as
1135     *                   hexadecimal literals; otherwise decimal literals are used
1136     * @param properties if this flag is true, the table entries are encoded
1137     *                   character properties rather than indexes into yet other tables;
1138     *                   therefore comments describing the encoded properties should
1139     *                   be generated
1140     * @param hexComment if this flag is true, each line of output is labelled with
1141     *                   a hexadecimal comment indicating the character values to
1142     *                   which that line applies; otherwise, decimal values indicating
1143     *                   table indices are generated
1144     *
1145     * @see GenerateCharacter#genTables
1146     * @see GenerateCharacter#replaceCommand
1147     */
1148 
1149     static void genTable(StringBuffer result, String name,
1150                          long[] table, int extract, int bits, int size,
1151                          boolean preshifted, int shift, boolean hexFormat,
1152                          boolean properties, boolean hexComment) {
1153 
1154         String atype = bits == 1 ? (Csyntax ? &quot;unsigned long&quot; : &quot;int&quot;) :
1155             bits == 2 ? (Csyntax ? &quot;unsigned long&quot; : &quot;int&quot;) :
1156             bits == 4 ? (Csyntax ? &quot;unsigned long&quot; : &quot;int&quot;) :
1157             bits == 8 ? (Csyntax ? &quot;unsigned char&quot; : &quot;byte&quot;) :
1158             bits == 16 ? (Csyntax ? &quot;unsigned short&quot; : &quot;char&quot;) :
1159             bits == 32 ? (Csyntax ? &quot;unsigned long&quot; : &quot;int&quot;) :
1160             (Csyntax ? &quot;int64&quot; : &quot;long&quot;);
1161         long maxPosEntry = bits == 1 ? Integer.MAX_VALUE : // liu
1162             bits == 2 ? Integer.MAX_VALUE :
1163             bits == 4 ? Integer.MAX_VALUE :
1164             bits == 8 ? Byte.MAX_VALUE :
1165             bits == 16 ? Short.MAX_VALUE :
1166             bits == 32 ? Integer.MAX_VALUE :
1167             Long.MAX_VALUE;
1168         int entriesPerChar = bits &lt;= 16 ? (16 / bits) : -(bits / 16);
1169         boolean shiftEntries = preshifted &amp;&amp; shift != 0;
1170         if (bits == 8 &amp;&amp; tableAsString &amp;&amp; useCharForByte) {
1171             atype = &quot;char&quot;;
1172             maxPosEntry = Character.MAX_VALUE;
1173             entriesPerChar = 1;
1174         }
1175         boolean noConversion = atype.equals(&quot;char&quot;);
1176 
1177         result.append(commentStart);
1178         result.append(&quot; The &quot;).append(name).append(&quot; table has &quot;).append(table.length);
1179         result.append(&quot; entries for a total of &quot;);
1180         int sizeOfTable = ((table.length * bits + 31) &gt;&gt; 5) &lt;&lt; 2;
1181         if (bits == 8 &amp;&amp; useCharForByte) {
1182             sizeOfTable *= 2;
1183         }
1184         result.append(sizeOfTable);
1185         result.append(&quot; bytes.&quot;).append(commentEnd).append(&quot;\n\n&quot;);
1186         if (Csyntax)
1187             result.append(&quot;  static &quot;);
1188         else
1189             result.append(&quot;  static final &quot;);
1190         result.append(atype);
1191         result.append(&quot; &quot;).append(name).append(&quot;[&quot;);
1192         if (Csyntax)
1193             result.append(table.length &gt;&gt; (bits == 1 ? 5 : bits == 2 ? 4 : bits == 4 ? 3 : 0));
1194         if (tableAsString) {
1195             if (noConversion) {
1196                 result.append(&quot;] = (\n&quot;);
1197             } else {
1198                 result.append(&quot;] = new &quot;).append(atype).append(&quot;[&quot;+table.length+&quot;];\n  &quot;);
1199                 result.append(&quot;static final String &quot;).append(name).append(&quot;_DATA =\n&quot;);
1200             }
1201             int CHARS_PER_LINE = 8;
1202             StringBuffer theString = new StringBuffer();
1203             int entriesInCharSoFar = 0;
1204             char ch = &#39;\u0000&#39;;
1205             int charsPerEntry = -entriesPerChar;
1206             for (int j=0; j&lt;table.length; ++j) {
1207                 //long entry = table[j] &gt;&gt; extract;
1208                 long entry;
1209                 if (&quot;A&quot;.equals(name))
1210                     entry = (table[j] &amp; 0xffffffffL) &gt;&gt; extract;
1211                 else
1212                     entry = (table[j] &gt;&gt; extract);
1213                 if (shiftEntries) entry &lt;&lt;= shift;
1214                 if (entry &gt;= (1L &lt;&lt; bits)) {
1215                     FAIL(&quot;Entry too big&quot;);
1216                 }
1217                 if (entriesPerChar &gt; 0) {
1218                     // Pack multiple entries into a character
1219                     ch = (char)(((int)ch &gt;&gt; bits) | (entry &lt;&lt; (entriesPerChar-1)*bits));
1220                     ++entriesInCharSoFar;
1221                     if (entriesInCharSoFar == entriesPerChar) {
1222                         // Character is full
1223                         theString.append(ch);
1224                         entriesInCharSoFar = 0;
1225                         ch = &#39;\u0000&#39;;
1226                     }
1227                 }
1228                 else {
1229                     // Use multiple characters per entry
1230                     for (int k=0; k&lt;charsPerEntry; ++k) {
1231                         ch = (char)(entry &gt;&gt; ((charsPerEntry-1)*16));
1232                         entry &lt;&lt;= 16;
1233                         theString.append(ch);
1234                     }
1235                 }
1236             }
1237             if (entriesInCharSoFar &gt; 0) {
1238                 while (entriesInCharSoFar &lt; entriesPerChar) {
1239                     ch = (char)((int)ch &gt;&gt; bits);
1240                     ++entriesInCharSoFar;
1241                 }
1242                 theString.append(ch);
1243                 entriesInCharSoFar = 0;
1244             }
1245             result.append(Utility.formatForSource(theString.toString(), &quot;    &quot;));
1246             if (noConversion) {
1247                 result.append(&quot;).toCharArray()&quot;);
1248             }
1249             result.append(&quot;;\n\n  &quot;);
1250 
1251             if (!noConversion) {
1252                 addInitializer(name, atype, entriesPerChar, bits, table.length);
1253             }
1254         }
1255         else {
1256             result.append(&quot;] = {&quot;);
1257             boolean castEntries = shiftEntries &amp;&amp; (bits &lt; 32);
1258             int printPerLine = hexFormat ? (bits == 1 ? 32*4 :
1259                 bits == 2 ? 16*4 :
1260                 bits == 4 ? 8*4 :
1261                 bits == 8 ? 8 :
1262                 bits == 16 ? 8 :
1263                 bits == 32 ? 4 : 2) :
1264                 (bits == 8 ? 8 :
1265                 bits == 16 ? 8 : 4);
1266             int printMask = properties ? 0 :
1267             Math.min(1 &lt;&lt; size,
1268                 printPerLine &gt;&gt; (castEntries ? (Csyntax ? 2 : 1) : 0)) - 1;
1269             int commentShift = ((1 &lt;&lt; size) == table.length) ? 0 : size;
1270             int commentMask = ((1 &lt;&lt; size) == table.length) ? printMask : (1 &lt;&lt; size) - 1;
1271             long val = 0;
1272             for (int j = 0; j &lt; table.length; j++) {
1273                 if ((j &amp; printMask) == 0) {
1274                     while (result.charAt(result.length() - 1) == &#39; &#39;)
1275                         result.setLength(result.length() - 1);
1276                     result.append(&quot;\n    &quot;);
1277                 }
1278         PRINT:  {
1279                 if (castEntries)
1280                     result.append(&quot;(&quot;).append(atype).append(&quot;)(&quot;);
1281                 long entry = table[j] &gt;&gt; extract;
1282                 int packMask = ((1 &lt;&lt; (bits == 1 ? 5 : bits == 2 ? 4 : bits == 4 ? 3 : 2)) - 1);
1283                 int k = j &amp; packMask;
1284                 if (bits &gt;= 8)
1285                     val = entry;
1286                 else if (k == 0) {
1287                     val = entry;
1288                     break PRINT;
1289                 }
1290                 else {
1291                     val |= (entry &lt;&lt; (k*bits));
1292                     if (k != packMask)
1293                         break PRINT;
1294                 }
1295                 if (val &gt; maxPosEntry &amp;&amp; !Csyntax) { // liu
1296                 // For values that are out of range, convert them to in-range negative values.
1297                 // Actually, output the &#39;-&#39; and convert them to the negative of the corresponding
1298                 // in-range negative values.  E.g., convert 130 == -126 (in 8 bits) -&gt; 126.
1299                     result.append(&#39;-&#39;);
1300                     val = maxPosEntry + maxPosEntry + 2 - val;
1301                 }
1302                 if (hexFormat) {
1303                     result.append(&quot;0x&quot;);
1304                     if (bits == 8)
1305                         result.append(hex2((byte)val));
1306                     else if (bits == 16)
1307                         result.append(hex4((short)val));
1308                     else if (bits == 32 || bits &lt; 8)
1309                         result.append(hex8((int)val));
1310                     else {
1311                         result.append(hex16(val));
1312                         if (!Csyntax)
1313                             result.append(&quot;L&quot;);
1314                     }
1315                 }
1316                 else {
1317                     if (bits == 8)
1318                         result.append(dec3(val));
1319                     else if (bits == 64) {
1320                         result.append(dec5(val));
1321                         if (!Csyntax)
1322                             result.append(&quot;L&quot;);
1323                     }
1324                     else
1325                         result.append(dec5(val));
1326                 }
1327                 if (shiftEntries)
1328                     result.append(&quot;&lt;&lt;&quot;).append(shift);
1329                 if (castEntries) result.append(&quot;)&quot;);
1330                 if (j &lt; (table.length - 1))
1331                     result.append(&quot;, &quot;);
1332                 else
1333                     result.append(&quot;  &quot;);
1334                 if ((j &amp; printMask) == printMask) {
1335                     result.append(&quot; &quot;).append(commentStart).append(&quot; &quot;);
1336                     if (hexComment)
1337                         result.append(&quot;0x&quot;).append(hex4((j &amp; ~commentMask) &lt;&lt; (16 - size)));
1338                     else
1339                         result.append(dec3((j &amp; ~commentMask) &gt;&gt; commentShift));
1340                     if (properties) propertiesComments(result, val);
1341                     result.append(commentEnd);
1342                 }
1343                 } // end PRINT
1344             }
1345             result.append(&quot;\n  };\n\n  &quot;);
1346         }
1347     }
1348 
1349     static void genCaseMapTableDeclaration(StringBuffer result) {
1350         String myTab = &quot;    &quot;;
1351         result.append(myTab + &quot;static final char[][][] charMap;\n&quot;);
1352     }
1353 
1354     static void genCaseMapTable(StringBuffer result, SpecialCaseMap[] specialCaseMaps){
1355         String myTab = &quot;    &quot;;
1356         int ch;
1357         char[] map;
1358         result.append(myTab + &quot;charMap = new char[][][] {\n&quot;);
1359         for (int x = 0; x &lt; specialCaseMaps.length; x++) {
1360             ch = specialCaseMaps[x].getCharSource();
1361             map = specialCaseMaps[x].getUpperCaseMap();
1362             result.append(myTab + myTab);
1363             result.append(&quot;{ &quot;);
1364             result.append(&quot;{\&#39;\\u&quot;+hex4(ch)+&quot;\&#39;}, {&quot;);
1365             for (int y = 0; y &lt; map.length; y++) {
1366                 result.append(&quot;\&#39;\\u&quot;+hex4(map[y])+&quot;\&#39;, &quot;);
1367             }
1368             result.append(&quot;} },\n&quot;);
1369         }
1370         result.append(myTab + &quot;};\n&quot;);
1371 
1372     }
1373 
1374     /**
1375     * The propertiesComments method generates comments describing encoded
1376     * character properties.
1377     *
1378     * @param result     a StringBuffer, to which the generated source code
1379     *                   text is to be appended
1380     * @param val                encoded character properties
1381     *
1382     * @see GenerateCharacter#genTable
1383     */
1384 
1385     static void propertiesComments(StringBuffer result, long val) {
1386         result.append(&quot;   &quot;);
1387         switch ((int)(val &amp; maskType)) {
1388             case UnicodeSpec.CONTROL:
1389                 result.append(&quot;Cc&quot;);
1390                 break;
1391             case UnicodeSpec.FORMAT:
1392                 result.append(&quot;Cf&quot;);
1393                 break;
1394             case UnicodeSpec.PRIVATE_USE:
1395                 result.append(&quot;Co&quot;);
1396                 break;
1397             case UnicodeSpec.SURROGATE:
1398                 result.append(&quot;Cs&quot;);
1399                 break;
1400             case UnicodeSpec.LOWERCASE_LETTER:
1401                 result.append(&quot;Ll&quot;);
1402                 break;
1403             case UnicodeSpec.MODIFIER_LETTER:
1404                 result.append(&quot;Lm&quot;);
1405                 break;
1406             case UnicodeSpec.OTHER_LETTER:
1407                 result.append(&quot;Lo&quot;);
1408                 break;
1409             case UnicodeSpec.TITLECASE_LETTER:
1410                 result.append(&quot;Lt&quot;);
1411                 break;
1412             case UnicodeSpec.UPPERCASE_LETTER:
1413                 result.append(&quot;Lu&quot;);
1414                 break;
1415             case UnicodeSpec.COMBINING_SPACING_MARK:
1416                 result.append(&quot;Mc&quot;);
1417                 break;
1418             case UnicodeSpec.ENCLOSING_MARK:
1419                 result.append(&quot;Me&quot;);
1420                 break;
1421             case UnicodeSpec.NON_SPACING_MARK:
1422                 result.append(&quot;Mn&quot;);
1423                 break;
1424             case UnicodeSpec.DECIMAL_DIGIT_NUMBER:
1425                 result.append(&quot;Nd&quot;);
1426                 break;
1427             case UnicodeSpec.LETTER_NUMBER:
1428                 result.append(&quot;Nl&quot;);
1429                 break;
1430             case UnicodeSpec.OTHER_NUMBER:
1431                 result.append(&quot;No&quot;);
1432                 break;
1433             case UnicodeSpec.CONNECTOR_PUNCTUATION:
1434                 result.append(&quot;Pc&quot;);
1435                 break;
1436             case UnicodeSpec.DASH_PUNCTUATION:
1437                 result.append(&quot;Pd&quot;);
1438                 break;
1439             case UnicodeSpec.END_PUNCTUATION:
1440                 result.append(&quot;Pe&quot;);
1441                 break;
1442             case UnicodeSpec.OTHER_PUNCTUATION:
1443                 result.append(&quot;Po&quot;);
1444                 break;
1445             case UnicodeSpec.START_PUNCTUATION:
1446                 result.append(&quot;Ps&quot;);
1447                 break;
1448             case UnicodeSpec.CURRENCY_SYMBOL:
1449                 result.append(&quot;Sc&quot;);
1450                 break;
1451             case UnicodeSpec.MODIFIER_SYMBOL:
1452                 result.append(&quot;Sk&quot;);
1453                 break;
1454             case UnicodeSpec.MATH_SYMBOL:
1455                 result.append(&quot;Sm&quot;);
1456                 break;
1457             case UnicodeSpec.OTHER_SYMBOL:
1458                 result.append(&quot;So&quot;);
1459                 break;
1460             case UnicodeSpec.LINE_SEPARATOR:
1461                 result.append(&quot;Zl&quot;); break;
1462             case UnicodeSpec.PARAGRAPH_SEPARATOR:
1463                 result.append(&quot;Zp&quot;);
1464                 break;
1465             case UnicodeSpec.SPACE_SEPARATOR:
1466                 result.append(&quot;Zs&quot;);
1467                 break;
1468             case UnicodeSpec.UNASSIGNED:
1469                 result.append(&quot;unassigned&quot;);
1470                 break;
1471         }
1472 
1473         switch ((int)((val &amp; maskBidi) &gt;&gt; shiftBidi)) {
1474             case UnicodeSpec.DIRECTIONALITY_LEFT_TO_RIGHT:
1475                 result.append(&quot;, L&quot;);
1476                 break;
1477             case UnicodeSpec.DIRECTIONALITY_RIGHT_TO_LEFT:
1478                 result.append(&quot;, R&quot;);
1479                 break;
1480             case UnicodeSpec.DIRECTIONALITY_EUROPEAN_NUMBER:
1481                 result.append(&quot;, EN&quot;);
1482                 break;
1483             case UnicodeSpec.DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR:
1484                 result.append(&quot;, ES&quot;);
1485                 break;
1486             case UnicodeSpec.DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR:
1487                 result.append(&quot;, ET&quot;);
1488                 break;
1489             case UnicodeSpec.DIRECTIONALITY_ARABIC_NUMBER:
1490                 result.append(&quot;, AN&quot;);
1491                 break;
1492             case UnicodeSpec.DIRECTIONALITY_COMMON_NUMBER_SEPARATOR:
1493                 result.append(&quot;, CS&quot;);
1494                 break;
1495             case UnicodeSpec.DIRECTIONALITY_PARAGRAPH_SEPARATOR:
1496                 result.append(&quot;, B&quot;);
1497                 break;
1498             case UnicodeSpec.DIRECTIONALITY_SEGMENT_SEPARATOR:
1499                 result.append(&quot;, S&quot;);
1500                 break;
1501             case UnicodeSpec.DIRECTIONALITY_WHITESPACE:
1502                 result.append(&quot;, WS&quot;);
1503                 break;
1504             case UnicodeSpec.DIRECTIONALITY_OTHER_NEUTRALS:
1505                 result.append(&quot;, ON&quot;);
1506                 break;
1507         }
1508         if ((val &amp; maskUpperCase) != 0) {
1509             result.append(&quot;, hasUpper (subtract &quot;);
1510             result.append((val &amp; maskCaseOffset) &gt;&gt; shiftCaseOffset).append(&quot;)&quot;);
1511         }
1512         if ((val &amp; maskLowerCase) != 0) {
1513             result.append(&quot;, hasLower (add &quot;);
1514             result.append((val &amp; maskCaseOffset) &gt;&gt; shiftCaseOffset).append(&quot;)&quot;);
1515         }
1516         if ((val &amp; maskTitleCase) != 0) {
1517             result.append(&quot;, hasTitle&quot;);
1518         }
1519         if ((val &amp; maskIdentifierInfo) == valueIgnorable) {
1520             result.append(&quot;, ignorable&quot;);
1521         }
1522         if ((val &amp; maskIdentifierInfo) == valueJavaUnicodePart) {
1523             result.append(&quot;, identifier part&quot;);
1524         }
1525         if ((val &amp; maskIdentifierInfo) == valueJavaStartUnicodePart) {
1526             result.append(&quot;, underscore&quot;);
1527         }
1528         if ((val &amp; maskIdentifierInfo) == valueJavaWhitespace) {
1529             result.append(&quot;, whitespace&quot;);
1530         }
1531         if ((val &amp; maskIdentifierInfo) == valueJavaOnlyStart) {
1532             result.append(&quot;, currency&quot;);
1533         }
1534         if ((val &amp; maskIdentifierInfo) == valueJavaUnicodeStart) {
1535             result.append(&quot;, identifier start&quot;);
1536         }
1537         if ((val &amp; maskNumericType) == valueDigit) {
1538             result.append(&quot;, decimal &quot;);
1539             result.append((val &amp; maskDigitOffset) &gt;&gt; shiftDigitOffset);
1540         }
1541         if ((val &amp; maskNumericType) == valueStrangeNumeric) {
1542             result.append(&quot;, strange&quot;);
1543         }
1544         if ((val &amp; maskNumericType) == valueJavaSupradecimal) {
1545             result.append(&quot;, supradecimal &quot;);
1546             result.append((val &amp; maskDigitOffset) &gt;&gt; shiftDigitOffset);
1547         }
1548     }
1549 
1550     static String[] tableNames = { &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot; };
1551 
1552     static String tableName(int j) { return tableNames[j]; }
1553 
1554     /**
1555     * The genAccess method generates source code for one table access expression.
1556     *
1557     * Most of the complexity stems from handling various options as to
1558     * table representation, such as whether it contains values so large that
1559     * they are represented as negative values and whether the table values are
1560     * preshifted.  This method also avoids such &quot;ugly&quot; expressions as shifting
1561     * by distance zero, masking when no masking is necessary, and so on.
1562     * For clarity, it generates expressions that do not rely on operator
1563     * precedence, but otherwise it avoids generating redundant parentheses.
1564     *
1565     * A generated expression might look like A[Y[(X[ch&gt;&gt;6]&lt;&lt;6)|(ch&amp;0x3F)]]
1566     * or A[Z[Y[(X[ch&gt;&gt;7]&lt;&lt;4)|((ch&gt;&gt;3)&amp;0xF)]|(ch&amp;0x7)]], for example.
1567     *
1568     * @param tbl                the name of the final table to be accessed
1569     * @param var                the variable name that appeared in parentheses in the
1570     *                           &quot;Lookup&quot; command
1571     * @param bits       the number of bits (not bytes) to be used to represent
1572     *                   the final table entry
1573     * @return   the replacement text for the &quot;Lookup(xxx)&quot; command, as a String
1574     *
1575     * @see GenerateCharacter#replaceCommand
1576     */
1577 
1578     static String genAccess(String tbl, String var, int bits) {
1579         String access = null;
1580         int bitoffset = bits == 1 ? 5 : bits == 2 ? 4 : bits == 4 ? 3 : 0;
1581         for (int k = 0; k &lt; sizes.length; k++) {
1582             int offset = ((k &lt; sizes.length - 1) ? 0 : bitoffset);
1583             int shift = shifts[k] + offset;
1584             String shifted = (shift == 0) ? var : &quot;(&quot; + var + &quot;&gt;&gt;&quot; + shift + &quot;)&quot;;
1585             int mask = (1 &lt;&lt; (sizes[k] - offset)) - 1;
1586             String masked = (k == 0) ? shifted :
1587               &quot;(&quot; + shifted + &quot;&amp;0x&quot; + hex(mask) + &quot;)&quot;;
1588             String index = (k == 0) ? masked :
1589              (mask == 0) ? access : &quot;(&quot; + access + &quot;|&quot; + masked + &quot;)&quot;;
1590             String indexNoParens = (index.charAt(0) != &#39;(&#39;) ? index :
1591                  index.substring(1, index.length() - 1);
1592             String tblname = (k == sizes.length - 1) ? tbl : tableName(k);
1593             String fetched = tblname + &quot;[&quot; + indexNoParens + &quot;]&quot;;
1594             String zeroextended = (zeroextend[k] == 0) ? fetched :
1595                 &quot;(&quot; + fetched + &quot;&amp;0x&quot; + hex(zeroextend[k]) + &quot;)&quot;;
1596             int adjustment = preshifted[k] ? 0 :
1597                sizes[k+1] - ((k == sizes.length - 2) ? bitoffset : 0);
1598             String adjusted = (preshifted[k] || adjustment == 0) ? zeroextended :
1599                 &quot;(&quot; + zeroextended + &quot;&lt;&lt;&quot; + adjustment + &quot;)&quot;;
1600             String bitshift = (bits == 1) ? &quot;(&quot; + var + &quot;&amp;0x1F)&quot; :
1601                 (bits == 2) ? &quot;((&quot; + var + &quot;&amp;0xF)&lt;&lt;1)&quot; :
1602                 (bits == 4) ? &quot;((&quot; + var + &quot;&amp;7)&lt;&lt;2)&quot; : null;
1603             String extracted = ((k &lt; sizes.length - 1) || (bits &gt;= 8)) ? adjusted :
1604                 &quot;((&quot; + adjusted + &quot;&gt;&gt;&quot; + bitshift + &quot;)&amp;&quot; +
1605                 (bits == 4 ? &quot;0xF&quot; : &quot;&quot; + ((1 &lt;&lt; bits) - 1)) + &quot;)&quot;;
1606             access = extracted;
1607         }
1608         return access;
1609     }
1610 
1611     /* The command line arguments are decoded and used to set the following
1612      global variables.
1613      */
1614 
1615     static boolean verbose = false;
1616     static boolean debug = false;
1617     static boolean nobidi = false;
1618     static boolean nomirror = false;
1619     static boolean identifiers = false;
1620     static boolean Csyntax = false;
1621     static String TemplateFileName = null;
1622     static String OutputFileName = null;
1623     static String UnicodeSpecFileName = null; // liu
1624     static String SpecialCasingFileName = null;
1625     static String PropListFileName = null;
1626     static String DerivedPropsFileName = null;
1627     static boolean useCharForByte = false;
1628     static int[] sizes;
1629     static int bins = 0; // liu; if &gt; 0, then perform search
1630     static boolean tableAsString = false;
1631     static boolean bLatin1 = false;
1632 
1633     static String commandLineDescription;
1634 
1635     /* Other global variables, equal in length to the &quot;sizes&quot; array. */
1636 
1637     static int[] shifts;
1638     static int[] zeroextend;
1639     static int[] bytes;
1640     static boolean[] preshifted;
1641     static long[][] tables;
1642 
1643 
1644     /* Other global variables */
1645     static String commentStart;
1646     static String commentEnd;
1647 
1648     static StringBuffer initializers = new StringBuffer();
1649 
1650     /* special casing rules for 1:M toUpperCase mappings */
1651     static SpecialCaseMap[] specialCaseMaps;
1652 
1653     /**
1654     * Process the command line arguments.
1655     *
1656     * The allowed flags in command line are:
1657     * &lt;dl&gt;
1658     * &lt;dt&gt; -verbose             &lt;dd&gt; Emit comments to standard output describing
1659     *                                   what&#39;s going on during the processing.
1660     * &lt;dt&gt; -nobidi              &lt;dd&gt; Do not include bidi categories in the
1661     *                                   encoded character properties.
1662     * &lt;dt&gt; -nomirror    &lt;dd&gt; Do no include mirror property in the encoded
1663     *                        character properties.
1664     * &lt;dt&gt; -identifiers         &lt;dd&gt; Generate tables for scanning identifiers only.
1665     * &lt;dt&gt; -c                   &lt;dd&gt; Output code in C syntax instead of Java syntax.
1666     * &lt;dt&gt; -o filename          &lt;dd&gt; Specify output file name.
1667     * &lt;dt&gt; -template filename   &lt;dd&gt; Specify template input file name.
1668     * &lt;dt&gt; -spec filename        &lt;dd&gt; Specify Unicode spec file name.
1669     * &lt;dt&gt; -specialcasing filename &lt;dd&gt; Specify Unicode special casing file name.
1670     * &lt;dt&gt; -search bins          &lt;dd&gt; Try different partitions into the specified
1671     *                                    number of bins.  E.g., for 2 bins, try
1672     *                                    16 0, 15 1,..., 0 16.
1673     * &lt;dt&gt; -string               &lt;dd&gt; Create table as string.  Only valid with Java
1674     *                                    syntax.
1675     * &lt;dt&gt; -latin1          &lt;dd&gt; Create a latin 1 only property table.
1676     * &lt;/dl&gt;
1677     * In addition, decimal literals may appear as command line arguments;
1678     * each one represents the number of bits of the character to be broken
1679     * off at each lookup step.  If present, they must add up to 16 (the number
1680     * of bits in a char value).  For smaller tables, the last value should
1681     * be 0; values other than the last one may not be zero.  If no such
1682     * numeric values are provided, default values are used.
1683     *
1684     * @param args       the command line arguments, as an array of String
1685     *
1686     * @see GenerateCharacter#main
1687     */
1688 
1689     static void processArgs(String[] args) {
1690         StringBuffer desc = new StringBuffer(&quot;java GenerateCharacter&quot;);
1691         for (int j=0; j&lt;args.length; ++j) {
1692             desc.append(&quot; &quot; + args[j]);
1693         }
1694         for (int j = 0; j &lt; args.length; j++) {
1695             if (args[j].equals(&quot;-verbose&quot;) || args[j].equals(&quot;-v&quot;))
1696                 verbose = true;
1697             else if (args[j].equals(&quot;-d&quot;))
1698                 debug = true;
1699             else if (args[j].equals(&quot;-nobidi&quot;))
1700                 nobidi = true;
1701             else if (args[j].equals(&quot;-nomirror&quot;))
1702                 nomirror = true;
1703             else if (args[j].equals(&quot;-identifiers&quot;))
1704                 identifiers = true;
1705             else if (args[j].equals(&quot;-c&quot;))
1706                 Csyntax = true;
1707             else if (args[j].equals(&quot;-string&quot;))
1708                 tableAsString = true;
1709             else if (args[j].equals(&quot;-o&quot;)) {
1710                 if (j == args.length - 1) {
1711                     FAIL(&quot;File name missing after -o&quot;);
1712                 }
1713                 else {
1714                     OutputFileName = args[++j];
1715                 }
1716             }
1717             else if (args[j].equals(&quot;-search&quot;)) {
1718                 if (j == args.length - 1)
1719                     FAIL(&quot;Bin count missing after -search&quot;);
1720                 else {
1721                     bins = Integer.parseInt(args[++j]);
1722                     if (bins &lt; 1 || bins &gt; 10)
1723                         FAIL(&quot;Bin count must be &gt;= 1 and &lt;= 10&quot;);
1724                 }
1725             }
1726             else if (args[j].equals(&quot;-template&quot;)) {
1727                 if (j == args.length - 1)
1728                     FAIL(&quot;File name missing after -template&quot;);
1729                 else
1730                     TemplateFileName = args[++j];
1731             }
1732             else if (args[j].equals(&quot;-spec&quot;)) { // liu
1733                 if (j == args.length - 1) {
1734                     FAIL(&quot;File name missing after -spec&quot;);
1735                 }
1736                 else {
1737                     UnicodeSpecFileName = args[++j];
1738                 }
1739             }
1740             else if (args[j].equals(&quot;-specialcasing&quot;)) {
1741                 if (j == args.length -1) {
1742                     FAIL(&quot;File name missing after -specialcasing&quot;);
1743                 }
1744                 else {
1745                     SpecialCasingFileName = args[++j];
1746                 }
1747             }
1748             else if (args[j].equals(&quot;-proplist&quot;)) {
1749                 if (j == args.length -1) {
1750                     FAIL(&quot;File name missing after -proplist&quot;);
1751                 }
1752                 else {
1753                     PropListFileName = args[++j];
1754                 }
1755             }
1756             else if (args[j].equals(&quot;-derivedprops&quot;)) {
1757                 if (j == args.length -1) {
1758                     FAIL(&quot;File name missing after -derivedprops&quot;);
1759                 }
1760                 else {
1761                     DerivedPropsFileName = args[++j];
1762                 }
1763             }
1764             else if (args[j].equals(&quot;-plane&quot;)) {
1765                 if (j == args.length -1) {
1766                     FAIL(&quot;Plane number missing after -plane&quot;);
1767                 }
1768                 else {
1769                     plane = Integer.parseInt(args[++j]);
1770                 }
1771                 if (plane &gt; 0) {
1772                     bLatin1 = false;
1773                 }
1774             }
1775             else if (&quot;-usecharforbyte&quot;.equals(args[j])) {
1776                 useCharForByte = true;
1777             }
1778             else if (args[j].equals(&quot;-latin1&quot;)) {
1779                 bLatin1 = true;
1780                 plane = 0;
1781             }
1782             else {
1783                 try {
1784                     int val = Integer.parseInt(args[j]);
1785                     if (val &lt; 0 || val &gt; 32) FAIL(&quot;Incorrect bit field width: &quot; + args[j]);
1786                     if (sizes == null)
1787                         sizes = new int[1];
1788                     else {
1789                         int[] newsizes = new int[sizes.length + 1];
1790                         System.arraycopy(sizes, 0, newsizes, 0, sizes.length);
1791                         sizes = newsizes;
1792                     }
1793                     sizes[sizes.length - 1] = val;
1794                 }
1795                 catch(NumberFormatException e) {
1796                     FAIL(&quot;Unknown switch: &quot; + args[j]);
1797                 }
1798             }
1799         }
1800         if (Csyntax &amp;&amp; tableAsString) {
1801             FAIL(&quot;Can&#39;t specify table as string with C syntax&quot;);
1802         }
1803         if (sizes == null) {
1804             desc.append(&quot; [&quot;);
1805             if (identifiers) {
1806                 int[] newsizes = { 8, 4, 4 };           // Good default values
1807                 desc.append(&quot;8 4 4]&quot;);
1808                 sizes = newsizes;
1809             }
1810             else {
1811                 int[] newsizes = { 10, 5, 1 }; // Guy&#39;s old defaults for 2.0.14: { 9, 4, 3, 0 }
1812                 desc.append(&quot;10 5 1]&quot;);
1813                 sizes = newsizes;
1814             }
1815         }
1816         if (UnicodeSpecFileName == null) { // liu
1817             UnicodeSpecFileName = DefaultUnicodeSpecFileName;
1818             desc.append(&quot; [-spec &quot; + UnicodeSpecFileName + &#39;]&#39;);
1819         }
1820         if (SpecialCasingFileName == null) {
1821             SpecialCasingFileName = DefaultSpecialCasingFileName;
1822             desc.append(&quot; [-specialcasing &quot; + SpecialCasingFileName + &#39;]&#39;);
1823         }
1824         if (PropListFileName == null) {
1825             PropListFileName = DefaultPropListFileName;
1826             desc.append(&quot; [-proplist &quot; + PropListFileName + &#39;]&#39;);
1827         }
1828         if (DerivedPropsFileName == null) {
1829             DerivedPropsFileName = DefaultDerivedPropsFileName;
1830             desc.append(&quot; [-derivedprops &quot; + DerivedPropsFileName + &#39;]&#39;);
1831         }
1832         if (TemplateFileName == null) {
1833             TemplateFileName = (Csyntax ? DefaultCTemplateFileName
1834                   : DefaultJavaTemplateFileName);
1835             desc.append(&quot; [-template &quot; + TemplateFileName + &#39;]&#39;);
1836         }
1837         if (OutputFileName == null) {
1838             OutputFileName = (Csyntax ? DefaultCOutputFileName
1839                     : DefaultJavaOutputFileName);
1840             desc.append(&quot; [-o &quot; + OutputFileName + &#39;]&#39;);
1841         }
1842         commentStart = (Csyntax ? &quot;/*&quot; : &quot;//&quot;);
1843         commentEnd = (Csyntax ? &quot; */&quot; : &quot;&quot;);
1844         commandLineDescription = desc.toString();
1845     }
1846 
1847     private static void searchBins(long[] map, int binsOccupied) throws Exception {
1848         int bitsFree = 16;
1849         for (int i=0; i&lt;binsOccupied; ++i) bitsFree -= sizes[i];
1850         if (binsOccupied == (bins-1)) {
1851             sizes[binsOccupied] = bitsFree;
1852             generateForSizes(map);
1853         }
1854         else {
1855             for (int i=1; i&lt;bitsFree; ++i) { // Don&#39;t allow bins of 0 except for last one
1856                 sizes[binsOccupied] = i;
1857                 searchBins(map, binsOccupied+1);
1858             }
1859         }
1860     }
1861 
1862     private static void generateForSizes(long[] map) throws Exception {
1863         int sum = 0;
1864         shifts = new int[sizes.length];
1865         for (int k = sizes.length - 1; k &gt;= 0; k--) {
1866             shifts[k] = sum;
1867             sum += sizes[k];
1868         }
1869         if ((1 &lt;&lt; sum) &lt; map.length || (1 &lt;&lt; (sum - 1)) &gt;= map.length) {
1870             FAIL(&quot;Bit field widths total to &quot; + sum +
1871              &quot;: wrong total for map of size &quot; + map.length);
1872         }
1873         // need a table for each set of lookup bits in char
1874         tables = new long[sizes.length][];
1875         // the last table is the map
1876         tables[sizes.length - 1] = map;
1877         for (int j = sizes.length - 1; j &gt; 0; j--) {
1878             if (verbose &amp;&amp; bins==0)
1879                 System.err.println(&quot;Building map &quot; + (j+1) + &quot; of bit width &quot; + sizes[j]);
1880             long[][] temp = buildTable(tables[j], sizes[j]);
1881             tables[j-1] = temp[0];
1882             tables[j] = temp[1];
1883         }
1884         preshifted = new boolean[sizes.length];
1885         zeroextend = new int[sizes.length];
1886         bytes = new int[sizes.length];
1887         for (int j = 0; j &lt; sizes.length - 1; j++) {
1888             int len = tables[j+1].length;
1889             int size = sizes[j+1];
1890             if (len &gt; 0x100 &amp;&amp; (len &gt;&gt; size) &lt;= 0x100) {
1891                 len &gt;&gt;= size;
1892                 preshifted[j] = false;
1893             }
1894             else if (len &gt; 0x10000 &amp;&amp; (len &gt;&gt; size) &lt;= 0x10000) {
1895                 len &gt;&gt;= size;
1896                 preshifted[j] = false;
1897             }
1898             else preshifted[j] = true;
1899             if (Csyntax)
1900                 zeroextend[j] = 0;
1901             else if (len &gt; 0x7F &amp;&amp; len &lt;= 0xFF) {
1902                 if (!useCharForByte) {
1903                     zeroextend[j] = 0xFF;
1904                 }
1905             } else if (len &gt; 0x7FFF &amp;&amp; len &lt;= 0xFFFF)
1906                 zeroextend[j] = 0xFFFF;
1907             else zeroextend[j] = 0;
1908             if (len &lt;= 0x100) bytes[j] = 1;
1909             else if (len &lt;= 0x10000) bytes[j] = 2;
1910             else bytes[j] = 4;
1911         }
1912         preshifted[sizes.length - 1] = true;
1913         zeroextend[sizes.length - 1] = 0;
1914         bytes[sizes.length - 1] = 0;
1915         if (bins &gt; 0) {
1916             int totalBytes = getTotalBytes();
1917             String access = genAccess(&quot;A&quot;, &quot;ch&quot;, (identifiers ? 2 : 32));
1918             int accessComplexity = 0;
1919             for (int j=0; j&lt;access.length(); ++j) {
1920                 char ch = access.charAt(j);
1921                 if (&quot;[&amp;|&gt;&lt;&quot;.indexOf(ch) &gt;= 0) ++accessComplexity;
1922                 if (ch == &#39;&lt;&#39; || ch == &#39;&gt;&#39;) ++j;
1923             }
1924             System.out.print(&quot;(&quot;);
1925             for (int j=0; j&lt;sizes.length; ++j) System.out.print(&quot; &quot; + sizes[j]);
1926             System.out.println(&quot; ) &quot; + totalBytes + &quot; &quot; + accessComplexity + &quot; &quot; + access);
1927             return;
1928         }
1929         if (verbose) {
1930             System.out.println(&quot;    n\t size\tlength\tshift\tzeroext\tbytes\tpreshifted&quot;);
1931             for (int j = 0; j &lt; sizes.length; j++) {
1932                 System.out.println(dec5(j) + &quot;\t&quot; +
1933                     dec5(sizes[j]) + &quot;\t&quot; +
1934                     dec5(tables[j].length) + &quot;\t&quot; +
1935                     dec5(shifts[j]) + &quot;\t&quot; +
1936                     dec5(zeroextend[j]) + &quot;\t&quot; +
1937                     dec5(bytes[j]) + &quot;\t &quot; +
1938                     preshifted[j]);
1939             }
1940         }
1941         if (verbose) {
1942             System.out.println(&quot;Generating source code for class Character&quot;);
1943             System.out.println(&quot;A table access looks like &quot; +
1944                          genAccess(&quot;A&quot;, &quot;ch&quot;, (identifiers ? 2 : 32)));
1945         }
1946         generateCharacterClass(TemplateFileName, OutputFileName);
1947     }
1948 
1949     /**
1950     * The main program for generating source code for the Character class.
1951     * The basic outline of its operation is:
1952     * &lt;ol&gt;
1953     * &lt;li&gt; Process the command line arguments.  One result of this process
1954     *           is a list of sizes (measured in bits and summing to 16).
1955     * &lt;li&gt; Get the Unicode character property data from the specification file.
1956     * &lt;li&gt; From that, build a map that has, for each character code, its
1957     *           relevant properties encoded as a long integer value.
1958     * &lt;li&gt; Repeatedly compress the map, producing a compressed table and a
1959     *           new map.  This is done once for each size value in the list.
1960     *           When this is done, we have a set of tables.
1961     * &lt;li&gt; Make some decisions about table representation; record these
1962     *           decisions in arrays named preshifted, zeroextend, and bytes.
1963     * &lt;li&gt; Generate the source code for the class Character by performing
1964     *           macro processing on a template file.
1965     * &lt;/ol&gt;
1966     *
1967     * @param args       the command line arguments, as an array of String
1968     *
1969     * @see GenerateCharacter#processArgs
1970     * @see UnicodeSpec@readSpecFile
1971     * @see GenerateCharacter#buildMap
1972     * @see GenerateCharacter#buildTable
1973     * @see GenerateCharacter#generateCharacterClass
1974     */
1975 
1976     public static void main(String[] args) {
1977         processArgs(args);
1978         try {
1979 
1980             UnicodeSpec[] data = UnicodeSpec.readSpecFile(new File(UnicodeSpecFileName), plane);
1981             specialCaseMaps = SpecialCaseMap.readSpecFile(new File(SpecialCasingFileName), plane);
1982             PropList propList = PropList.readSpecFile(new File(PropListFileName), plane);
1983             propList.putAll(PropList.readSpecFile(new File(DerivedPropsFileName), plane));
1984 
1985             if (verbose) {
1986                 System.out.println(data.length + &quot; items read from Unicode spec file &quot; + UnicodeSpecFileName); // liu
1987             }
1988             long[] map = buildMap(data, specialCaseMaps, propList);
1989             if (verbose) {
1990                 System.err.println(&quot;Completed building of initial map&quot;);
1991             }
1992 
1993             if (bins == 0) {
1994                 generateForSizes(map);
1995             }
1996             else {
1997                 while (bins &gt; 0) {
1998                     sizes = new int[bins];
1999                     searchBins(map, 0);
2000                     --bins;
2001                 }
2002             }
2003             if (verbose &amp;&amp; false) {
2004                 System.out.println(&quot;Offset range seen: -&quot; + hex8(-minOffsetSeen) + &quot;..+&quot; +
2005                              hex8(maxOffsetSeen));
2006                 System.out.println(&quot;          allowed: -&quot; + hex8(-minOffset) + &quot;..+&quot; +
2007                              hex8(maxOffset));
2008             }
2009         }
2010         catch (FileNotFoundException e) { FAIL(e.toString()); }
2011         catch (IOException e) { FAIL(e.toString()); }
2012         catch (Throwable e) {
2013             System.out.println(&quot;Unexpected exception:&quot;);
2014             e.printStackTrace();
2015             FAIL(&quot;Unexpected exception!&quot;);
2016         }
2017         if (verbose) { System.out.println(&quot;Done!&quot;);}
2018     }
2019 
2020 }   // end class
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
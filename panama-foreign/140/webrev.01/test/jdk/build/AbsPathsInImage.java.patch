diff a/test/jdk/build/AbsPathsInImage.java b/test/jdk/build/AbsPathsInImage.java
--- a/test/jdk/build/AbsPathsInImage.java
+++ b/test/jdk/build/AbsPathsInImage.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -30,10 +30,11 @@
 import java.nio.file.SimpleFileVisitor;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Properties;
+import java.util.stream.Collectors;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
 
 /*
  * @test
@@ -45,10 +46,11 @@
 public class AbsPathsInImage {
 
     // Set this property on command line to scan an alternate dir or file:
     // JTREG=JAVA_OPTIONS=-Djdk.test.build.AbsPathInImage.dir=/path/to/dir
     public static final String DIR_PROPERTY = "jdk.test.build.AbsPathsInImage.dir";
+    private static final boolean IS_WINDOWS = System.getProperty("os.name").toLowerCase().contains("windows");
 
     private boolean matchFound = false;
 
     public static void main(String[] args) throws Exception {
         String jdkPathString = System.getProperty("test.jdk");
@@ -117,11 +119,11 @@
     /**
      * Add path pattern to list of patterns to search for. Create all possible
      * variants depending on platform.
      */
     private static void expandPatterns(List<byte[]> searchPatterns, String pattern) {
-        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
+        if (IS_WINDOWS) {
             String forward = pattern.replace('\\', '/');
             String back = pattern.replace('/', '\\');
             if (pattern.charAt(1) == ':') {
                 String forwardUpper = String.valueOf(pattern.charAt(0)).toUpperCase() + forward.substring(1);
                 String forwardLower = String.valueOf(pattern.charAt(0)).toLowerCase() + forward.substring(1);
@@ -147,11 +149,11 @@
                 String fileName = file.toString();
                 if (Files.isSymbolicLink(file)) {
                     return super.visitFile(file, attrs);
                 } else if (fileName.endsWith(".debuginfo") || fileName.endsWith(".pdb")) {
                     // Do nothing
-                } else if (fileName.endsWith("jvm.dll")) {
+                } else if (fileName.endsWith("jvm.dll") || fileName.endsWith("jpackage.dll")) {
                     // On Windows, the Microsoft toolchain does not provide a way
                     // to reliably remove all absolute paths from __FILE__ usage.
                     // Until that is fixed, we simply exclude jvm.dll from this
                     // test.
                 } else if (fileName.endsWith(".zip")) {
@@ -164,11 +166,20 @@
         });
     }
 
     private void scanFile(Path file, List<byte[]> searchPatterns) throws IOException {
         List<String> matches = scanBytes(Files.readAllBytes(file), searchPatterns);
+        // For the same reason as jvm.dll above, the jdk.incubator.jpackage module
+        // contains some unavoidable header references in the launcher which is
+        // stored as a java resource inside the modules file.
+        if (IS_WINDOWS && file.toString().endsWith("modules")) {
+            matches = matches.stream()
+                .filter(f -> !f.matches(".*jdk\\.incubator\\.jpackage.*\\.h.*"))
+                .collect(Collectors.toList());
+        }
         if (matches.size() > 0) {
+            matchFound = true;
             System.out.println(file + ":");
             for (String match : matches) {
                 System.out.println(match);
             }
             System.out.println();
@@ -179,10 +190,11 @@
         try (ZipInputStream zipInputStream = new ZipInputStream(Files.newInputStream(zipFile))) {
             ZipEntry zipEntry;
             while ((zipEntry = zipInputStream.getNextEntry()) != null) {
                 List<String> matches = scanBytes(zipInputStream.readAllBytes(), searchPatterns);
                 if (matches.size() > 0) {
+                    matchFound = true;
                     System.out.println(zipFile + ", " + zipEntry.getName() + ":");
                     for (String match : matches) {
                         System.out.println(match);
                     }
                     System.out.println();
@@ -201,11 +213,10 @@
                         found = false;
                         break;
                     }
                 }
                 if (found) {
-                    matchFound = true;
                     matches.add(new String(data, charsStart(data, i), charsOffset(data, i, searchPattern.length)));
                     // No need to search the same string for multiple patterns
                     break;
                 }
             }

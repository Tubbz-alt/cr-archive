<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/tools/jmod/hashes/HashesTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /**
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8160286 8243666
 27  * @summary Test the recording and checking of module hashes
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  *          java.base/jdk.internal.module
 31  *          jdk.compiler
 32  *          jdk.jartool
 33  *          jdk.jlink
 34  * @build jdk.test.lib.compiler.ModuleInfoMaker
 35  *        jdk.test.lib.compiler.CompilerUtils
 36  * @run testng HashesTest
 37  */
 38 
 39 import java.io.File;
 40 import java.io.IOException;
 41 import java.io.InputStream;
 42 import java.io.UncheckedIOException;
 43 import java.lang.module.ModuleDescriptor;
 44 import java.lang.module.ModuleFinder;
 45 import java.lang.module.ModuleReader;
 46 import java.lang.module.ModuleReference;
 47 import java.nio.file.FileVisitResult;
 48 import java.nio.file.Files;
 49 import java.nio.file.Path;
 50 import java.nio.file.Paths;
 51 import java.nio.file.SimpleFileVisitor;
 52 import java.nio.file.attribute.BasicFileAttributes;
 53 import java.util.ArrayList;
 54 import java.util.Arrays;
 55 import java.util.Collections;
 56 import java.util.List;
 57 import java.util.Map;
 58 import java.util.Set;
 59 import java.util.spi.ToolProvider;
 60 import java.util.stream.Collectors;
 61 import java.util.stream.Stream;
 62 
 63 import jdk.internal.module.ModuleInfo;
 64 import jdk.internal.module.ModuleHashes;
 65 import jdk.internal.module.ModulePath;
 66 
 67 import jdk.test.lib.compiler.ModuleInfoMaker;
 68 
 69 import org.testng.annotations.Test;
 70 
 71 import static org.testng.Assert.*;
 72 import static java.lang.module.ModuleDescriptor.Requires.Modifier.*;
 73 
 74 public class HashesTest {
 75     static final ToolProvider JMOD_TOOL = ToolProvider.findFirst(&quot;jmod&quot;)
 76         .orElseThrow(() -&gt;
 77             new RuntimeException(&quot;jmod tool not found&quot;)
 78         );
 79     static final ToolProvider JAR_TOOL = ToolProvider.findFirst(&quot;jar&quot;)
 80         .orElseThrow(() -&gt;
 81             new RuntimeException(&quot;jar tool not found&quot;)
 82         );
 83 
 84     private final Path mods;
 85     private final Path srcDir;
 86     private final Path lib;
 87     private final ModuleInfoMaker builder;
 88 
 89     HashesTest(Path dest) throws IOException {
 90         if (Files.exists(dest)) {
 91             deleteDirectory(dest);
 92         }
 93         this.mods = dest.resolve(&quot;mods&quot;);
 94         this.srcDir = dest.resolve(&quot;src&quot;);
 95         this.lib = dest.resolve(&quot;lib&quot;);
 96         this.builder = new ModuleInfoMaker(srcDir);
 97 
 98         Files.createDirectories(lib);
 99         Files.createDirectories(mods);
100     }
101 
102     @Test
103     public static void test() throws IOException {
104         Path dest = Paths.get(&quot;test&quot;);
105         HashesTest ht = new HashesTest(dest);
106 
107         // create modules for test cases
108         ht.makeModule(&quot;m2&quot;);
109         ht.makeModule(&quot;m3&quot;);
110         ht.makeModule(&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;);
111 
112         ht.makeModule(&quot;org.bar&quot;, TRANSITIVE, &quot;m1&quot;);
113         ht.makeModule(&quot;org.foo&quot;, TRANSITIVE, &quot;org.bar&quot;);
114 
115         // create JMOD for m1, m2, m3
116         ht.makeJmod(&quot;m2&quot;);
117         ht.makeJmod(&quot;m3&quot;);
118 
119         // no hash is recorded since m1 has outgoing edges
120         ht.jmodHashModules(&quot;m1&quot;, &quot;.*&quot;);
121 
122         // no hash is recorded in m1, m2, m3
123         assertTrue(ht.hashes(&quot;m1&quot;) == null);
124         assertTrue(ht.hashes(&quot;m2&quot;) == null);
125         assertTrue(ht.hashes(&quot;m3&quot;) == null);
126 
127         // hash m1 in m2
128         ht.jmodHashModules(&quot;m2&quot;,  &quot;m1&quot;);
129         ht.checkHashes(&quot;m2&quot;, &quot;m1&quot;);
130 
131         // hash m1 in m2
132         ht.jmodHashModules(&quot;m2&quot;,  &quot;.*&quot;);
133         ht.checkHashes(&quot;m2&quot;, &quot;m1&quot;);
134 
135         // create m2.jmod with no hash
136         ht.makeJmod(&quot;m2&quot;);
137         // run jmod hash command to hash m1 in m2 and m3
138         runJmod(List.of(&quot;hash&quot;, &quot;--module-path&quot;, ht.lib.toString(),
139                         &quot;--hash-modules&quot;, &quot;.*&quot;));
140         ht.checkHashes(&quot;m2&quot;, &quot;m1&quot;);
141         ht.checkHashes(&quot;m3&quot;, &quot;m1&quot;);
142 
143         // check transitive requires
144         ht.makeJmod(&quot;org.bar&quot;);
145         ht.makeJmod(&quot;org.foo&quot;);
146 
147         ht.jmodHashModules(&quot;org.bar&quot;, &quot;org.*&quot;);
148         ht.checkHashes(&quot;org.bar&quot;, &quot;org.foo&quot;);
149 
150         ht.jmodHashModules( &quot;m3&quot;, &quot;.*&quot;);
151         ht.checkHashes(&quot;m3&quot;, &quot;org.foo&quot;, &quot;org.bar&quot;, &quot;m1&quot;);
152     }
153 
154     @Test
155     public static void multiBaseModules() throws IOException {
156         Path dest = Paths.get(&quot;test2&quot;);
157         HashesTest ht = new HashesTest(dest);
158 
159         /*
160          * y2 -----------&gt; y1
161          *    |______
162          *    |      |
163          *    V      V
164          *    z3 -&gt; z2
165          *    |      |
166          *    |      V
167          *    |---&gt; z1
168          */
169 
170         ht.makeModule(&quot;z1&quot;);
171         ht.makeModule(&quot;z2&quot;, &quot;z1&quot;);
172         ht.makeModule(&quot;z3&quot;, &quot;z1&quot;, &quot;z2&quot;);
173 
174         ht.makeModule(&quot;y1&quot;);
175         ht.makeModule(&quot;y2&quot;, &quot;y1&quot;, &quot;z2&quot;, &quot;z3&quot;);
176 
177         Set&lt;String&gt; ys = Set.of(&quot;y1&quot;, &quot;y2&quot;);
178         Set&lt;String&gt; zs = Set.of(&quot;z1&quot;, &quot;z2&quot;, &quot;z3&quot;);
179 
180         // create JMOD files
181         Stream.concat(ys.stream(), zs.stream()).forEach(ht::makeJmod);
182 
183         // run jmod hash command
184         runJmod(List.of(&quot;hash&quot;, &quot;--module-path&quot;, ht.lib.toString(),
185                         &quot;--hash-modules&quot;, &quot;.*&quot;));
186 
187         /*
188          * z1 and y1 are the modules with hashes recorded.
189          */
190         ht.checkHashes(&quot;y1&quot;, &quot;y2&quot;);
191         ht.checkHashes(&quot;z1&quot;, &quot;z2&quot;, &quot;z3&quot;, &quot;y2&quot;);
192         Stream.concat(ys.stream(), zs.stream())
193               .filter(mn -&gt; !mn.equals(&quot;y1&quot;) &amp;&amp; !mn.equals(&quot;z1&quot;))
194               .forEach(mn -&gt; assertTrue(ht.hashes(mn) == null));
195     }
196 
197     @Test
198     public static void mixJmodAndJarFile() throws IOException {
199         Path dest = Paths.get(&quot;test3&quot;);
200         HashesTest ht = new HashesTest(dest);
201 
202         /*
203          * j3 -----------&gt; j2
204          *    |______
205          *    |      |
206          *    V      V
207          *    m3 -&gt; m2
208          *    |      |
209          *    |      V
210          *    |---&gt; m1 -&gt; j1 -&gt; jdk.jlink
211          */
212 
213         ht.makeModule(&quot;j1&quot;);
214         ht.makeModule(&quot;j2&quot;);
215         ht.makeModule(&quot;m1&quot;, &quot;j1&quot;);
216         ht.makeModule(&quot;m2&quot;, &quot;m1&quot;);
217         ht.makeModule(&quot;m3&quot;, &quot;m1&quot;, &quot;m2&quot;);
218 
219         ht.makeModule(&quot;j3&quot;, &quot;j2&quot;, &quot;m2&quot;, &quot;m3&quot;);
220 
221         Set&lt;String&gt; jars = Set.of(&quot;j1&quot;, &quot;j2&quot;, &quot;j3&quot;);
222         Set&lt;String&gt; jmods = Set.of(&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;);
223 
224         // create JMOD and JAR files
225         jars.forEach(ht::makeJar);
226         jmods.forEach(ht::makeJmod);
227 
228         // run jmod hash command
229         runJmod(List.of(&quot;hash&quot;, &quot;--module-path&quot;, ht.lib.toString(),
230                         &quot;--hash-modules&quot;, &quot;^j.*|^m.*&quot;));
231 
232         /*
233          * j1 and j2 are the modules with hashes recorded.
234          */
235         ht.checkHashes(&quot;j2&quot;, &quot;j3&quot;);
236         ht.checkHashes(&quot;j1&quot;, &quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;, &quot;j3&quot;);
237         Stream.concat(jars.stream(), jmods.stream())
238               .filter(mn -&gt; !mn.equals(&quot;j1&quot;) &amp;&amp; !mn.equals(&quot;j2&quot;))
239               .forEach(mn -&gt; assertTrue(ht.hashes(mn) == null));
240     }
241 
242     @Test
243     public static void upgradeableModule() throws IOException {
244         Path mpath = Paths.get(System.getProperty(&quot;java.home&quot;), &quot;jmods&quot;);
245         if (!Files.exists(mpath)) {
246             return;
247         }
248 
249         Path dest = Paths.get(&quot;test4&quot;);
250         HashesTest ht = new HashesTest(dest);
251         ht.makeModule(&quot;m1&quot;);
252         ht.makeModule(&quot;java.compiler&quot;, &quot;m1&quot;);
253         ht.makeModule(&quot;m2&quot;, &quot;java.compiler&quot;);
254 
255         ht.makeJmod(&quot;m1&quot;);
256         ht.makeJmod(&quot;m2&quot;);
257         ht.makeJmod(&quot;java.compiler&quot;,
258                     &quot;--module-path&quot;,
259                     ht.lib.toString() + File.pathSeparator + mpath,
260                     &quot;--hash-modules&quot;, &quot;java\\.(?!se)|^m.*&quot;);
261 
262         ht.checkHashes(&quot;java.compiler&quot;,  &quot;m2&quot;);
263     }
264 
265     @Test
266     public static void testImageJmods() throws IOException {
267         Path mpath = Paths.get(System.getProperty(&quot;java.home&quot;), &quot;jmods&quot;);
268         if (!Files.exists(mpath)) {
269             return;
270         }
271 
272         Path dest = Paths.get(&quot;test5&quot;);
273         HashesTest ht = new HashesTest(dest);
274         ht.makeModule(&quot;m1&quot;, &quot;jdk.compiler&quot;, &quot;jdk.attach&quot;);
275         ht.makeModule(&quot;m2&quot;, &quot;m1&quot;);
276         ht.makeModule(&quot;m3&quot;, &quot;java.compiler&quot;);
277 
278         ht.makeJmod(&quot;m1&quot;);
279         ht.makeJmod(&quot;m2&quot;);
280 
281         runJmod(List.of(&quot;hash&quot;,
282                         &quot;--module-path&quot;,
283                         mpath.toString() + File.pathSeparator + ht.lib.toString(),
284                         &quot;--hash-modules&quot;, &quot;.*&quot;));
285 
286         validateImageJmodsTest(ht, mpath);
287     }
288 
289     @Test
290     public static void testImageJmods1() throws IOException {
291         Path mpath = Paths.get(System.getProperty(&quot;java.home&quot;), &quot;jmods&quot;);
292         if (!Files.exists(mpath)) {
293             return;
294         }
295 
296         Path dest = Paths.get(&quot;test6&quot;);
297         HashesTest ht = new HashesTest(dest);
298         ht.makeModule(&quot;m1&quot;, &quot;jdk.compiler&quot;, &quot;jdk.attach&quot;);
299         ht.makeModule(&quot;m2&quot;, &quot;m1&quot;);
300         ht.makeModule(&quot;m3&quot;, &quot;java.compiler&quot;);
301 
302         ht.makeJar(&quot;m2&quot;);
303         ht.makeJar(&quot;m1&quot;,
304                     &quot;--module-path&quot;,
305                     mpath.toString() + File.pathSeparator + ht.lib.toString(),
306                     &quot;--hash-modules&quot;, &quot;.*&quot;);
307         validateImageJmodsTest(ht, mpath);
308     }
309 
310     @Test
311     public static void testReproducibibleHash() throws Exception {
312         HashesTest ht = new HashesTest(Path.of(&quot;repro&quot;));
313         ht.makeModule(&quot;m4&quot;);
314         ht.makeModule(&quot;m3&quot;, &quot;m4&quot;);
315         ht.makeModule(&quot;m2&quot;);
316         ht.makeModule(&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;);
317 
318         // create JMOD files and run jmod hash
319         List.of(&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;, &quot;m4&quot;).forEach(ht::makeJmod);
320         Map&lt;String, ModuleHashes&gt; hashes1 = ht.runJmodHash();
321 
322         // sleep a bit to be confident that the hashes aren&#39;t dependent on timestamps
323         Thread.sleep(2000);
324 
325         // (re)create JMOD files and run jmod hash
326         List.of(&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;, &quot;m4&quot;).forEach(ht::makeJmod);
327         Map&lt;String, ModuleHashes&gt; hashes2 = ht.runJmodHash();
328 
329         // hashes should be equal
330         assertEquals(hashes1, hashes2);
331     }
332 
333     private static void validateImageJmodsTest(HashesTest ht, Path mpath)
334         throws IOException
335     {
336         // hash is recorded in m1 and not any other packaged modules on module path
337         ht.checkHashes(&quot;m1&quot;, &quot;m2&quot;);
338         assertTrue(ht.hashes(&quot;m2&quot;) == null);
339 
340         // should not override any JDK packaged modules
341         ModuleFinder finder = ModulePath.of(Runtime.version(), true, mpath);
342         assertTrue(ht.hashes(finder,&quot;jdk.compiler&quot;) == null);
343         assertTrue(ht.hashes(finder,&quot;jdk.attach&quot;) == null);
344     }
345 
346     private void checkHashes(String mn, String... hashModules) throws IOException {
347         ModuleHashes hashes = hashes(mn);
348         assertTrue(hashes.names().equals(Set.of(hashModules)));
349     }
350 
351     private ModuleHashes hashes(String name) {
352         ModuleFinder finder = ModulePath.of(Runtime.version(), true, lib);
353         return hashes(finder, name);
354     }
355 
356     private ModuleHashes hashes(ModuleFinder finder, String name) {
357         ModuleReference mref = finder.find(name).orElseThrow(RuntimeException::new);
358         try {
359             ModuleReader reader = mref.open();
360             try (InputStream in = reader.open(&quot;module-info.class&quot;).get()) {
361                 ModuleHashes hashes = ModuleInfo.read(in, null).recordedHashes();
362                 System.out.format(&quot;hashes in module %s %s%n&quot;, name,
363                     (hashes != null) ? &quot;present&quot; : &quot;absent&quot;);
364                 if (hashes != null) {
365                     hashes.names().stream().sorted().forEach(n -&gt;
366                         System.out.format(&quot;  %s %s%n&quot;, n, toHex(hashes.hashFor(n)))
367                     );
368                 }
369                 return hashes;
370             } finally {
371                 reader.close();
372             }
373         } catch (IOException e) {
374             throw new UncheckedIOException(e);
375         }
376     }
377 
378     private String toHex(byte[] ba) {
379         StringBuilder sb = new StringBuilder(ba.length);
380         for (byte b: ba) {
381             sb.append(String.format(&quot;%02x&quot;, b &amp; 0xff));
382         }
383         return sb.toString();
384     }
385 
386     private void deleteDirectory(Path dir) throws IOException {
387         Files.walkFileTree(dir, new SimpleFileVisitor&lt;Path&gt;() {
388             @Override
389             public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
390                 throws IOException
391             {
392                 Files.delete(file);
393                 return FileVisitResult.CONTINUE;
394             }
395 
396             @Override
397             public FileVisitResult postVisitDirectory(Path dir, IOException exc)
398                 throws IOException
399             {
400                 Files.delete(dir);
401                 return FileVisitResult.CONTINUE;
402             }
403         });
404     }
405 
406 
407     private void makeModule(String mn, String... deps) throws IOException {
408         makeModule(mn, null, deps);
409     }
410 
411     private void makeModule(String mn, ModuleDescriptor.Requires.Modifier mod, String... deps)
412         throws IOException
413     {
414         if (mod != null &amp;&amp; mod != TRANSITIVE &amp;&amp; mod != STATIC) {
415             throw new IllegalArgumentException(mod.toString());
416         }
417 
418         StringBuilder sb = new StringBuilder();
419         sb.append(&quot;module &quot;)
420           .append(mn)
421           .append(&quot; {&quot;)
422           .append(&quot;\n&quot;);
423         Arrays.stream(deps)
424               .forEach(req -&gt; {
425                   sb.append(&quot;    requires &quot;);
426                   if (mod != null) {
427                       sb.append(mod.toString().toLowerCase())
428                         .append(&quot; &quot;);
429                   }
430                   sb.append(req)
431                     .append(&quot;;\n&quot;);
432               });
433         sb.append(&quot;}\n&quot;);
434         builder.writeJavaFiles(mn, sb.toString());
435         builder.compile(mn, mods);
436     }
437 
438     private void jmodHashModules(String moduleName, String hashModulesPattern) {
439         makeJmod(moduleName, &quot;--module-path&quot;, lib.toString(),
440                  &quot;--hash-modules&quot;, hashModulesPattern);
441     }
442 
443     private void makeJmod(String moduleName, String... options) {
444         Path mclasses = mods.resolve(moduleName);
445         Path outfile = lib.resolve(moduleName + &quot;.jmod&quot;);
446         List&lt;String&gt; args = new ArrayList&lt;&gt;();
447         args.add(&quot;create&quot;);
448         Collections.addAll(args, options);
449         Collections.addAll(args, &quot;--class-path&quot;, mclasses.toString(),
450                            outfile.toString());
451 
452         if (Files.exists(outfile)) {
453             try {
454                 Files.delete(outfile);
455             } catch (IOException e) {
456                 throw new UncheckedIOException(e);
457             }
458         }
459         runJmod(args);
460     }
461 
462     /**
463      * Execute jmod hash on the modules in the lib directory. Returns a map of
464      * the modules, with the module name as the key, for the modules that have
465      * a ModuleHashes class file attribute.
466      */
467     private Map&lt;String, ModuleHashes&gt; runJmodHash() {
468         runJmod(List.of(&quot;hash&quot;,
469                 &quot;--module-path&quot;, lib.toString(),
470                 &quot;--hash-modules&quot;, &quot;.*&quot;));
471         HashesTest ht = this;
472         return ModulePath.of(Runtime.version(), true, lib)
473                 .findAll()
474                 .stream()
475                 .map(ModuleReference::descriptor)
476                 .map(ModuleDescriptor::name)
477                 .filter(mn -&gt; ht.hashes(mn) != null)
478                 .collect(Collectors.toMap(mn -&gt; mn, ht::hashes));
479     }
480 
481     private static void runJmod(List&lt;String&gt; args) {
482         int rc = JMOD_TOOL.run(System.out, System.out, args.toArray(new String[args.size()]));
483         System.out.println(&quot;jmod &quot; + args.stream().collect(Collectors.joining(&quot; &quot;)));
484         if (rc != 0) {
485             throw new AssertionError(&quot;jmod failed: rc = &quot; + rc);
486         }
487     }
488 
489     private void makeJar(String moduleName, String... options) {
490         Path mclasses = mods.resolve(moduleName);
491         Path outfile = lib.resolve(moduleName + &quot;.jar&quot;);
492         List&lt;String&gt; args = new ArrayList&lt;&gt;();
493         Stream.concat(Stream.of(&quot;--create&quot;,
494                                 &quot;--file=&quot; + outfile.toString()),
495                       Arrays.stream(options))
496               .forEach(args::add);
497         args.add(&quot;-C&quot;);
498         args.add(mclasses.toString());
499         args.add(&quot;.&quot;);
500 
501         if (Files.exists(outfile)) {
502             try {
503                 Files.delete(outfile);
504             } catch (IOException e) {
505                 throw new UncheckedIOException(e);
506             }
507         }
508 
509         int rc = JAR_TOOL.run(System.out, System.out, args.toArray(new String[args.size()]));
510         System.out.println(&quot;jar &quot; + args.stream().collect(Collectors.joining(&quot; &quot;)));
511         if (rc != 0) {
512             throw new AssertionError(&quot;jar failed: rc = &quot; + rc);
513         }
514     }
515 }
    </pre>
  </body>
</html>
diff a/test/jdk/tools/jmod/hashes/HashesTest.java b/test/jdk/tools/jmod/hashes/HashesTest.java
--- a/test/jdk/tools/jmod/hashes/HashesTest.java
+++ b/test/jdk/tools/jmod/hashes/HashesTest.java
@@ -1,7 +1,7 @@
 /**
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -21,11 +21,11 @@
  * questions.
  */
 
 /*
  * @test
- * @bug 8160286
+ * @bug 8160286 8243666
  * @summary Test the recording and checking of module hashes
  * @library /test/lib
  * @modules java.base/jdk.internal.misc
  *          java.base/jdk.internal.module
  *          jdk.compiler
@@ -52,10 +52,11 @@
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import java.util.spi.ToolProvider;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -82,10 +83,11 @@
 
     private final Path mods;
     private final Path srcDir;
     private final Path lib;
     private final ModuleInfoMaker builder;
+
     HashesTest(Path dest) throws IOException {
         if (Files.exists(dest)) {
             deleteDirectory(dest);
         }
         this.mods = dest.resolve("mods");
@@ -303,10 +305,33 @@
                     mpath.toString() + File.pathSeparator + ht.lib.toString(),
                     "--hash-modules", ".*");
         validateImageJmodsTest(ht, mpath);
     }
 
+    @Test
+    public static void testReproducibibleHash() throws Exception {
+        HashesTest ht = new HashesTest(Path.of("repro"));
+        ht.makeModule("m4");
+        ht.makeModule("m3", "m4");
+        ht.makeModule("m2");
+        ht.makeModule("m1", "m2", "m3");
+
+        // create JMOD files and run jmod hash
+        List.of("m1", "m2", "m3", "m4").forEach(ht::makeJmod);
+        Map<String, ModuleHashes> hashes1 = ht.runJmodHash();
+
+        // sleep a bit to be confident that the hashes aren't dependent on timestamps
+        Thread.sleep(2000);
+
+        // (re)create JMOD files and run jmod hash
+        List.of("m1", "m2", "m3", "m4").forEach(ht::makeJmod);
+        Map<String, ModuleHashes> hashes2 = ht.runJmodHash();
+
+        // hashes should be equal
+        assertEquals(hashes1, hashes2);
+    }
+
     private static void validateImageJmodsTest(HashesTest ht, Path mpath)
         throws IOException
     {
         // hash is recorded in m1 and not any other packaged modules on module path
         ht.checkHashes("m1", "m2");
@@ -432,10 +457,29 @@
             }
         }
         runJmod(args);
     }
 
+    /**
+     * Execute jmod hash on the modules in the lib directory. Returns a map of
+     * the modules, with the module name as the key, for the modules that have
+     * a ModuleHashes class file attribute.
+     */
+    private Map<String, ModuleHashes> runJmodHash() {
+        runJmod(List.of("hash",
+                "--module-path", lib.toString(),
+                "--hash-modules", ".*"));
+        HashesTest ht = this;
+        return ModulePath.of(Runtime.version(), true, lib)
+                .findAll()
+                .stream()
+                .map(ModuleReference::descriptor)
+                .map(ModuleDescriptor::name)
+                .filter(mn -> ht.hashes(mn) != null)
+                .collect(Collectors.toMap(mn -> mn, ht::hashes));
+    }
+
     private static void runJmod(List<String> args) {
         int rc = JMOD_TOOL.run(System.out, System.out, args.toArray(new String[args.size()]));
         System.out.println("jmod " + args.stream().collect(Collectors.joining(" ")));
         if (rc != 0) {
             throw new AssertionError("jmod failed: rc = " + rc);

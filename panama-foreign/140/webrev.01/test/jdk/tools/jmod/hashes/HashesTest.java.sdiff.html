<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/tools/jmod/hashes/HashesTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../jlink/plugins/OrderResourcesPluginTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../jpackage/helpers/jdk/jpackage/test/JPackageCommand.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/tools/jmod/hashes/HashesTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /**
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  * @bug 8160286</span>
 27  * @summary Test the recording and checking of module hashes
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  *          java.base/jdk.internal.module
 31  *          jdk.compiler
 32  *          jdk.jartool
 33  *          jdk.jlink
 34  * @build jdk.test.lib.compiler.ModuleInfoMaker
 35  *        jdk.test.lib.compiler.CompilerUtils
 36  * @run testng HashesTest
 37  */
 38 
 39 import java.io.File;
 40 import java.io.IOException;
 41 import java.io.InputStream;
 42 import java.io.UncheckedIOException;
 43 import java.lang.module.ModuleDescriptor;
 44 import java.lang.module.ModuleFinder;
 45 import java.lang.module.ModuleReader;
 46 import java.lang.module.ModuleReference;
 47 import java.nio.file.FileVisitResult;
 48 import java.nio.file.Files;
 49 import java.nio.file.Path;
 50 import java.nio.file.Paths;
 51 import java.nio.file.SimpleFileVisitor;
 52 import java.nio.file.attribute.BasicFileAttributes;
 53 import java.util.ArrayList;
 54 import java.util.Arrays;
 55 import java.util.Collections;
 56 import java.util.List;

 57 import java.util.Set;
 58 import java.util.spi.ToolProvider;
 59 import java.util.stream.Collectors;
 60 import java.util.stream.Stream;
 61 
 62 import jdk.internal.module.ModuleInfo;
 63 import jdk.internal.module.ModuleHashes;
 64 import jdk.internal.module.ModulePath;
 65 
 66 import jdk.test.lib.compiler.ModuleInfoMaker;
 67 
 68 import org.testng.annotations.Test;
 69 
 70 import static org.testng.Assert.*;
 71 import static java.lang.module.ModuleDescriptor.Requires.Modifier.*;
 72 
 73 public class HashesTest {
 74     static final ToolProvider JMOD_TOOL = ToolProvider.findFirst(&quot;jmod&quot;)
 75         .orElseThrow(() -&gt;
 76             new RuntimeException(&quot;jmod tool not found&quot;)
 77         );
 78     static final ToolProvider JAR_TOOL = ToolProvider.findFirst(&quot;jar&quot;)
 79         .orElseThrow(() -&gt;
 80             new RuntimeException(&quot;jar tool not found&quot;)
 81         );
 82 
 83     private final Path mods;
 84     private final Path srcDir;
 85     private final Path lib;
 86     private final ModuleInfoMaker builder;

 87     HashesTest(Path dest) throws IOException {
 88         if (Files.exists(dest)) {
 89             deleteDirectory(dest);
 90         }
 91         this.mods = dest.resolve(&quot;mods&quot;);
 92         this.srcDir = dest.resolve(&quot;src&quot;);
 93         this.lib = dest.resolve(&quot;lib&quot;);
 94         this.builder = new ModuleInfoMaker(srcDir);
 95 
 96         Files.createDirectories(lib);
 97         Files.createDirectories(mods);
 98     }
 99 
100     @Test
101     public static void test() throws IOException {
102         Path dest = Paths.get(&quot;test&quot;);
103         HashesTest ht = new HashesTest(dest);
104 
105         // create modules for test cases
106         ht.makeModule(&quot;m2&quot;);
</pre>
<hr />
<pre>
288     public static void testImageJmods1() throws IOException {
289         Path mpath = Paths.get(System.getProperty(&quot;java.home&quot;), &quot;jmods&quot;);
290         if (!Files.exists(mpath)) {
291             return;
292         }
293 
294         Path dest = Paths.get(&quot;test6&quot;);
295         HashesTest ht = new HashesTest(dest);
296         ht.makeModule(&quot;m1&quot;, &quot;jdk.compiler&quot;, &quot;jdk.attach&quot;);
297         ht.makeModule(&quot;m2&quot;, &quot;m1&quot;);
298         ht.makeModule(&quot;m3&quot;, &quot;java.compiler&quot;);
299 
300         ht.makeJar(&quot;m2&quot;);
301         ht.makeJar(&quot;m1&quot;,
302                     &quot;--module-path&quot;,
303                     mpath.toString() + File.pathSeparator + ht.lib.toString(),
304                     &quot;--hash-modules&quot;, &quot;.*&quot;);
305         validateImageJmodsTest(ht, mpath);
306     }
307 























308     private static void validateImageJmodsTest(HashesTest ht, Path mpath)
309         throws IOException
310     {
311         // hash is recorded in m1 and not any other packaged modules on module path
312         ht.checkHashes(&quot;m1&quot;, &quot;m2&quot;);
313         assertTrue(ht.hashes(&quot;m2&quot;) == null);
314 
315         // should not override any JDK packaged modules
316         ModuleFinder finder = ModulePath.of(Runtime.version(), true, mpath);
317         assertTrue(ht.hashes(finder,&quot;jdk.compiler&quot;) == null);
318         assertTrue(ht.hashes(finder,&quot;jdk.attach&quot;) == null);
319     }
320 
321     private void checkHashes(String mn, String... hashModules) throws IOException {
322         ModuleHashes hashes = hashes(mn);
323         assertTrue(hashes.names().equals(Set.of(hashModules)));
324     }
325 
326     private ModuleHashes hashes(String name) {
327         ModuleFinder finder = ModulePath.of(Runtime.version(), true, lib);
</pre>
<hr />
<pre>
417 
418     private void makeJmod(String moduleName, String... options) {
419         Path mclasses = mods.resolve(moduleName);
420         Path outfile = lib.resolve(moduleName + &quot;.jmod&quot;);
421         List&lt;String&gt; args = new ArrayList&lt;&gt;();
422         args.add(&quot;create&quot;);
423         Collections.addAll(args, options);
424         Collections.addAll(args, &quot;--class-path&quot;, mclasses.toString(),
425                            outfile.toString());
426 
427         if (Files.exists(outfile)) {
428             try {
429                 Files.delete(outfile);
430             } catch (IOException e) {
431                 throw new UncheckedIOException(e);
432             }
433         }
434         runJmod(args);
435     }
436 



















437     private static void runJmod(List&lt;String&gt; args) {
438         int rc = JMOD_TOOL.run(System.out, System.out, args.toArray(new String[args.size()]));
439         System.out.println(&quot;jmod &quot; + args.stream().collect(Collectors.joining(&quot; &quot;)));
440         if (rc != 0) {
441             throw new AssertionError(&quot;jmod failed: rc = &quot; + rc);
442         }
443     }
444 
445     private void makeJar(String moduleName, String... options) {
446         Path mclasses = mods.resolve(moduleName);
447         Path outfile = lib.resolve(moduleName + &quot;.jar&quot;);
448         List&lt;String&gt; args = new ArrayList&lt;&gt;();
449         Stream.concat(Stream.of(&quot;--create&quot;,
450                                 &quot;--file=&quot; + outfile.toString()),
451                       Arrays.stream(options))
452               .forEach(args::add);
453         args.add(&quot;-C&quot;);
454         args.add(mclasses.toString());
455         args.add(&quot;.&quot;);
456 
</pre>
</td>
<td>
<hr />
<pre>
  1 /**
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  * @bug 8160286 8243666</span>
 27  * @summary Test the recording and checking of module hashes
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  *          java.base/jdk.internal.module
 31  *          jdk.compiler
 32  *          jdk.jartool
 33  *          jdk.jlink
 34  * @build jdk.test.lib.compiler.ModuleInfoMaker
 35  *        jdk.test.lib.compiler.CompilerUtils
 36  * @run testng HashesTest
 37  */
 38 
 39 import java.io.File;
 40 import java.io.IOException;
 41 import java.io.InputStream;
 42 import java.io.UncheckedIOException;
 43 import java.lang.module.ModuleDescriptor;
 44 import java.lang.module.ModuleFinder;
 45 import java.lang.module.ModuleReader;
 46 import java.lang.module.ModuleReference;
 47 import java.nio.file.FileVisitResult;
 48 import java.nio.file.Files;
 49 import java.nio.file.Path;
 50 import java.nio.file.Paths;
 51 import java.nio.file.SimpleFileVisitor;
 52 import java.nio.file.attribute.BasicFileAttributes;
 53 import java.util.ArrayList;
 54 import java.util.Arrays;
 55 import java.util.Collections;
 56 import java.util.List;
<span class="line-added"> 57 import java.util.Map;</span>
 58 import java.util.Set;
 59 import java.util.spi.ToolProvider;
 60 import java.util.stream.Collectors;
 61 import java.util.stream.Stream;
 62 
 63 import jdk.internal.module.ModuleInfo;
 64 import jdk.internal.module.ModuleHashes;
 65 import jdk.internal.module.ModulePath;
 66 
 67 import jdk.test.lib.compiler.ModuleInfoMaker;
 68 
 69 import org.testng.annotations.Test;
 70 
 71 import static org.testng.Assert.*;
 72 import static java.lang.module.ModuleDescriptor.Requires.Modifier.*;
 73 
 74 public class HashesTest {
 75     static final ToolProvider JMOD_TOOL = ToolProvider.findFirst(&quot;jmod&quot;)
 76         .orElseThrow(() -&gt;
 77             new RuntimeException(&quot;jmod tool not found&quot;)
 78         );
 79     static final ToolProvider JAR_TOOL = ToolProvider.findFirst(&quot;jar&quot;)
 80         .orElseThrow(() -&gt;
 81             new RuntimeException(&quot;jar tool not found&quot;)
 82         );
 83 
 84     private final Path mods;
 85     private final Path srcDir;
 86     private final Path lib;
 87     private final ModuleInfoMaker builder;
<span class="line-added"> 88 </span>
 89     HashesTest(Path dest) throws IOException {
 90         if (Files.exists(dest)) {
 91             deleteDirectory(dest);
 92         }
 93         this.mods = dest.resolve(&quot;mods&quot;);
 94         this.srcDir = dest.resolve(&quot;src&quot;);
 95         this.lib = dest.resolve(&quot;lib&quot;);
 96         this.builder = new ModuleInfoMaker(srcDir);
 97 
 98         Files.createDirectories(lib);
 99         Files.createDirectories(mods);
100     }
101 
102     @Test
103     public static void test() throws IOException {
104         Path dest = Paths.get(&quot;test&quot;);
105         HashesTest ht = new HashesTest(dest);
106 
107         // create modules for test cases
108         ht.makeModule(&quot;m2&quot;);
</pre>
<hr />
<pre>
290     public static void testImageJmods1() throws IOException {
291         Path mpath = Paths.get(System.getProperty(&quot;java.home&quot;), &quot;jmods&quot;);
292         if (!Files.exists(mpath)) {
293             return;
294         }
295 
296         Path dest = Paths.get(&quot;test6&quot;);
297         HashesTest ht = new HashesTest(dest);
298         ht.makeModule(&quot;m1&quot;, &quot;jdk.compiler&quot;, &quot;jdk.attach&quot;);
299         ht.makeModule(&quot;m2&quot;, &quot;m1&quot;);
300         ht.makeModule(&quot;m3&quot;, &quot;java.compiler&quot;);
301 
302         ht.makeJar(&quot;m2&quot;);
303         ht.makeJar(&quot;m1&quot;,
304                     &quot;--module-path&quot;,
305                     mpath.toString() + File.pathSeparator + ht.lib.toString(),
306                     &quot;--hash-modules&quot;, &quot;.*&quot;);
307         validateImageJmodsTest(ht, mpath);
308     }
309 
<span class="line-added">310     @Test</span>
<span class="line-added">311     public static void testReproducibibleHash() throws Exception {</span>
<span class="line-added">312         HashesTest ht = new HashesTest(Path.of(&quot;repro&quot;));</span>
<span class="line-added">313         ht.makeModule(&quot;m4&quot;);</span>
<span class="line-added">314         ht.makeModule(&quot;m3&quot;, &quot;m4&quot;);</span>
<span class="line-added">315         ht.makeModule(&quot;m2&quot;);</span>
<span class="line-added">316         ht.makeModule(&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;);</span>
<span class="line-added">317 </span>
<span class="line-added">318         // create JMOD files and run jmod hash</span>
<span class="line-added">319         List.of(&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;, &quot;m4&quot;).forEach(ht::makeJmod);</span>
<span class="line-added">320         Map&lt;String, ModuleHashes&gt; hashes1 = ht.runJmodHash();</span>
<span class="line-added">321 </span>
<span class="line-added">322         // sleep a bit to be confident that the hashes aren&#39;t dependent on timestamps</span>
<span class="line-added">323         Thread.sleep(2000);</span>
<span class="line-added">324 </span>
<span class="line-added">325         // (re)create JMOD files and run jmod hash</span>
<span class="line-added">326         List.of(&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;, &quot;m4&quot;).forEach(ht::makeJmod);</span>
<span class="line-added">327         Map&lt;String, ModuleHashes&gt; hashes2 = ht.runJmodHash();</span>
<span class="line-added">328 </span>
<span class="line-added">329         // hashes should be equal</span>
<span class="line-added">330         assertEquals(hashes1, hashes2);</span>
<span class="line-added">331     }</span>
<span class="line-added">332 </span>
333     private static void validateImageJmodsTest(HashesTest ht, Path mpath)
334         throws IOException
335     {
336         // hash is recorded in m1 and not any other packaged modules on module path
337         ht.checkHashes(&quot;m1&quot;, &quot;m2&quot;);
338         assertTrue(ht.hashes(&quot;m2&quot;) == null);
339 
340         // should not override any JDK packaged modules
341         ModuleFinder finder = ModulePath.of(Runtime.version(), true, mpath);
342         assertTrue(ht.hashes(finder,&quot;jdk.compiler&quot;) == null);
343         assertTrue(ht.hashes(finder,&quot;jdk.attach&quot;) == null);
344     }
345 
346     private void checkHashes(String mn, String... hashModules) throws IOException {
347         ModuleHashes hashes = hashes(mn);
348         assertTrue(hashes.names().equals(Set.of(hashModules)));
349     }
350 
351     private ModuleHashes hashes(String name) {
352         ModuleFinder finder = ModulePath.of(Runtime.version(), true, lib);
</pre>
<hr />
<pre>
442 
443     private void makeJmod(String moduleName, String... options) {
444         Path mclasses = mods.resolve(moduleName);
445         Path outfile = lib.resolve(moduleName + &quot;.jmod&quot;);
446         List&lt;String&gt; args = new ArrayList&lt;&gt;();
447         args.add(&quot;create&quot;);
448         Collections.addAll(args, options);
449         Collections.addAll(args, &quot;--class-path&quot;, mclasses.toString(),
450                            outfile.toString());
451 
452         if (Files.exists(outfile)) {
453             try {
454                 Files.delete(outfile);
455             } catch (IOException e) {
456                 throw new UncheckedIOException(e);
457             }
458         }
459         runJmod(args);
460     }
461 
<span class="line-added">462     /**</span>
<span class="line-added">463      * Execute jmod hash on the modules in the lib directory. Returns a map of</span>
<span class="line-added">464      * the modules, with the module name as the key, for the modules that have</span>
<span class="line-added">465      * a ModuleHashes class file attribute.</span>
<span class="line-added">466      */</span>
<span class="line-added">467     private Map&lt;String, ModuleHashes&gt; runJmodHash() {</span>
<span class="line-added">468         runJmod(List.of(&quot;hash&quot;,</span>
<span class="line-added">469                 &quot;--module-path&quot;, lib.toString(),</span>
<span class="line-added">470                 &quot;--hash-modules&quot;, &quot;.*&quot;));</span>
<span class="line-added">471         HashesTest ht = this;</span>
<span class="line-added">472         return ModulePath.of(Runtime.version(), true, lib)</span>
<span class="line-added">473                 .findAll()</span>
<span class="line-added">474                 .stream()</span>
<span class="line-added">475                 .map(ModuleReference::descriptor)</span>
<span class="line-added">476                 .map(ModuleDescriptor::name)</span>
<span class="line-added">477                 .filter(mn -&gt; ht.hashes(mn) != null)</span>
<span class="line-added">478                 .collect(Collectors.toMap(mn -&gt; mn, ht::hashes));</span>
<span class="line-added">479     }</span>
<span class="line-added">480 </span>
481     private static void runJmod(List&lt;String&gt; args) {
482         int rc = JMOD_TOOL.run(System.out, System.out, args.toArray(new String[args.size()]));
483         System.out.println(&quot;jmod &quot; + args.stream().collect(Collectors.joining(&quot; &quot;)));
484         if (rc != 0) {
485             throw new AssertionError(&quot;jmod failed: rc = &quot; + rc);
486         }
487     }
488 
489     private void makeJar(String moduleName, String... options) {
490         Path mclasses = mods.resolve(moduleName);
491         Path outfile = lib.resolve(moduleName + &quot;.jar&quot;);
492         List&lt;String&gt; args = new ArrayList&lt;&gt;();
493         Stream.concat(Stream.of(&quot;--create&quot;,
494                                 &quot;--file=&quot; + outfile.toString()),
495                       Arrays.stream(options))
496               .forEach(args::add);
497         args.add(&quot;-C&quot;);
498         args.add(mclasses.toString());
499         args.add(&quot;.&quot;);
500 
</pre>
</td>
</tr>
</table>
<center><a href="../../jlink/plugins/OrderResourcesPluginTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../jpackage/helpers/jdk/jpackage/test/JPackageCommand.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
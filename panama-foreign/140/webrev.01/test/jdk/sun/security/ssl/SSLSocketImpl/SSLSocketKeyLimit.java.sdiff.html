<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/sun/security/ssl/SSLSocketImpl/SSLSocketKeyLimit.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../CipherSuite/NamedGroupsWithCipherSuite.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../util/RegisteredDomain/ParseNames.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/sun/security/ssl/SSLSocketImpl/SSLSocketKeyLimit.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 42   */
 43 
 44 import javax.net.ssl.KeyManagerFactory;
 45 import javax.net.ssl.SSLContext;
 46 import javax.net.ssl.SSLServerSocket;
 47 import javax.net.ssl.SSLServerSocketFactory;
 48 import javax.net.ssl.SSLSocket;
 49 import javax.net.ssl.SSLSocketFactory;
 50 import javax.net.ssl.TrustManagerFactory;
 51 import java.io.File;
 52 import java.io.InputStream;
 53 import java.io.OutputStream;
 54 import java.io.PrintWriter;
 55 import java.security.KeyStore;
 56 import java.security.SecureRandom;
 57 import java.util.Arrays;
 58 
 59 import jdk.test.lib.process.OutputAnalyzer;
 60 import jdk.test.lib.process.ProcessTools;
 61 import jdk.test.lib.Utils;
<span class="line-modified"> 62 import sun.security.util.HexDumpEncoder;</span>
 63 
 64 public class SSLSocketKeyLimit {
 65     SSLSocket socket;
 66     private InputStream in;
 67     private OutputStream out;
 68 
 69     static boolean serverReady = false;
 70     static int serverPort = 0;
 71 
 72     static String pathToStores = &quot;../../../../javax/net/ssl/etc/&quot;;
 73     static String keyStoreFile = &quot;keystore&quot;;
 74     static String passwd = &quot;passphrase&quot;;
 75     static int dataLen = 10240;
 76     static byte[] data  = new byte[dataLen];
 77     static boolean serverwrite = true;
 78     int totalDataLen = 0;
 79     static boolean done = false;
 80 
 81     SSLSocketKeyLimit() {
 82     }
</pre>
<hr />
<pre>
195     }
196 
197 
198     void read(SSLSocket s) throws Exception {
199         byte[] buf = new byte[dataLen];
200         int len;
201         byte i = 0;
202         try {
203             System.out.println(&quot;Server: connected &quot; + s.getSession().getCipherSuite());
204             in = s.getInputStream();
205             out = s.getOutputStream();
206             while (true) {
207                 len = in.read(buf, 0, dataLen);
208                 System.out.print(&quot;r&quot;);
209                 out.write(i++);
210                 System.out.print(&quot;w&quot;);
211                 for (byte b: buf) {
212                     if (b == 0x0A || b == 0x0D) {
213                         continue;
214                     }
<span class="line-modified">215                     System.out.println(&quot;\nData invalid: &quot; + new HexDumpEncoder().encode(buf));</span>
216                     break;
217                 }
218 
219                 if (len &gt; 0 &amp;&amp; buf[len-1] == 0x0D) {
220                     System.out.println(&quot;got end byte&quot;);
221                     break;
222                 }
223                 totalDataLen += len;
224             }
225         } catch (Exception e) {
226             System.out.println(&quot;\n&quot;  + e.getMessage());
227             e.printStackTrace();
228         } finally {
229             // Tell write side that we are done reading
230             out.close();
231             in.close();
232             done = true;
233         }
234         System.out.println(&quot;\nTotalDataLen = &quot; + totalDataLen);
235     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 42   */
 43 
 44 import javax.net.ssl.KeyManagerFactory;
 45 import javax.net.ssl.SSLContext;
 46 import javax.net.ssl.SSLServerSocket;
 47 import javax.net.ssl.SSLServerSocketFactory;
 48 import javax.net.ssl.SSLSocket;
 49 import javax.net.ssl.SSLSocketFactory;
 50 import javax.net.ssl.TrustManagerFactory;
 51 import java.io.File;
 52 import java.io.InputStream;
 53 import java.io.OutputStream;
 54 import java.io.PrintWriter;
 55 import java.security.KeyStore;
 56 import java.security.SecureRandom;
 57 import java.util.Arrays;
 58 
 59 import jdk.test.lib.process.OutputAnalyzer;
 60 import jdk.test.lib.process.ProcessTools;
 61 import jdk.test.lib.Utils;
<span class="line-modified"> 62 import jdk.test.lib.hexdump.HexPrinter;</span>
 63 
 64 public class SSLSocketKeyLimit {
 65     SSLSocket socket;
 66     private InputStream in;
 67     private OutputStream out;
 68 
 69     static boolean serverReady = false;
 70     static int serverPort = 0;
 71 
 72     static String pathToStores = &quot;../../../../javax/net/ssl/etc/&quot;;
 73     static String keyStoreFile = &quot;keystore&quot;;
 74     static String passwd = &quot;passphrase&quot;;
 75     static int dataLen = 10240;
 76     static byte[] data  = new byte[dataLen];
 77     static boolean serverwrite = true;
 78     int totalDataLen = 0;
 79     static boolean done = false;
 80 
 81     SSLSocketKeyLimit() {
 82     }
</pre>
<hr />
<pre>
195     }
196 
197 
198     void read(SSLSocket s) throws Exception {
199         byte[] buf = new byte[dataLen];
200         int len;
201         byte i = 0;
202         try {
203             System.out.println(&quot;Server: connected &quot; + s.getSession().getCipherSuite());
204             in = s.getInputStream();
205             out = s.getOutputStream();
206             while (true) {
207                 len = in.read(buf, 0, dataLen);
208                 System.out.print(&quot;r&quot;);
209                 out.write(i++);
210                 System.out.print(&quot;w&quot;);
211                 for (byte b: buf) {
212                     if (b == 0x0A || b == 0x0D) {
213                         continue;
214                     }
<span class="line-modified">215                     System.out.println(&quot;\nData invalid: &quot; + HexPrinter.minimal().toString(buf));</span>
216                     break;
217                 }
218 
219                 if (len &gt; 0 &amp;&amp; buf[len-1] == 0x0D) {
220                     System.out.println(&quot;got end byte&quot;);
221                     break;
222                 }
223                 totalDataLen += len;
224             }
225         } catch (Exception e) {
226             System.out.println(&quot;\n&quot;  + e.getMessage());
227             e.printStackTrace();
228         } finally {
229             // Tell write side that we are done reading
230             out.close();
231             in.close();
232             done = true;
233         }
234         System.out.println(&quot;\nTotalDataLen = &quot; + totalDataLen);
235     }
</pre>
</td>
</tr>
</table>
<center><a href="../CipherSuite/NamedGroupsWithCipherSuite.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../util/RegisteredDomain/ParseNames.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
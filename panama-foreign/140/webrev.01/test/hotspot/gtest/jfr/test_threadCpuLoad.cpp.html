<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/gtest/jfr/test_threadCpuLoad.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 // This test performs mocking of certain JVM functionality. This works by
 28 // including the source file under test inside an anonymous namespace (which
 29 // prevents linking conflicts) with the mocked symbols redefined.
 30 
 31 // The include list should mirror the one found in the included source file -
 32 // with the ones that should pick up the mocks removed. Those should be included
 33 // later after the mocks have been defined.
 34 
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;jfr/jfrEvents.hpp&quot;
 37 #include &quot;jfr/support/jfrThreadId.hpp&quot;
 38 #include &quot;jfr/support/jfrThreadLocal.hpp&quot;
 39 #include &quot;jfr/utilities/jfrThreadIterator.hpp&quot;
 40 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 41 #include &quot;utilities/globalDefinitions.hpp&quot;
 42 #include &quot;runtime/os.hpp&quot;
 43 
 44 #include &quot;unittest.hpp&quot;
 45 
 46 namespace {
 47 
 48   class MockEventThreadCPULoad : public ::EventThreadCPULoad
 49   {
 50   public:
 51     float user;
 52     float system;
 53 
 54   public:
 55     MockEventThreadCPULoad(EventStartTime timing=TIMED) : ::EventThreadCPULoad(timing) {}
 56 
 57     void set_user(float new_value) {
 58       user = new_value;
 59     }
 60     void set_system(float new_value) {
 61       system = new_value;
 62     }
 63   };
 64 
 65   class MockOs : public ::os {
 66   public:
 67     static jlong user_cpu_time;
 68     static jlong system_cpu_time;
 69 
 70     static jlong thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {
 71       return user_sys_cpu_time ? user_cpu_time + system_cpu_time : user_cpu_time;
 72     }
 73   };
 74 
 75   jlong MockOs::user_cpu_time;
 76   jlong MockOs::system_cpu_time;
 77 
 78   class MockJavaThread : public ::JavaThread {
 79   public:
 80     MockJavaThread() : ::JavaThread() {}
 81   };
 82 
 83   class MockJfrJavaThreadIterator
 84   {
 85   public:
 86     MockJavaThread* next() { return NULL; }
 87     bool has_next() const { return false; }
 88   };
 89 
 90   class MockJfrJavaThreadIteratorAdapter
 91   {
 92   public:
 93     MockJavaThread* next() { return NULL; }
 94     bool has_next() const { return false; }
 95   };
 96 
 97 // Reincluding source files in the anonymous namespace unfortunately seems to
 98 // behave strangely with precompiled headers (only when using gcc though)
 99 #ifndef DONT_USE_PRECOMPILED_HEADER
100 #define DONT_USE_PRECOMPILED_HEADER
101 #endif
102 
103 #define os MockOs
104 #define EventThreadCPULoad MockEventThreadCPULoad
105 #define JavaThread MockJavaThread
106 #define JfrJavaThreadIterator MockJfrJavaThreadIterator
107 #define JfrJavaThreadIteratorAdapter MockJfrJavaThreadIteratorAdapter
108 
109 #include &quot;jfr/periodic/jfrThreadCPULoadEvent.hpp&quot;
110 #include &quot;jfr/periodic/jfrThreadCPULoadEvent.cpp&quot;
111 
112 #undef os
113 #undef EventThreadCPULoad
114 #undef JavaThread
115 #define JfrJavaThreadIterator MockJfrJavaThreadIterator
116 #define JfrJavaThreadIteratorAdapter MockJfrJavaThreadIteratorAdapter
117 
118 } // anonymous namespace
119 
120 class JfrTestThreadCPULoadSingle : public ::testing::Test {
121 protected:
122   MockJavaThread* thread;
123   JfrThreadLocal* thread_data;
124   MockEventThreadCPULoad event;
125 
126   void SetUp() {
127     thread = new MockJavaThread();
128     thread_data = thread-&gt;jfr_thread_local();
129     thread_data-&gt;set_wallclock_time(0);
130     thread_data-&gt;set_user_time(0);
131     thread_data-&gt;set_cpu_time(0);
132   }
133 
134   void TearDown() {
135     delete thread;
136   }
137 
138   // Fix for gcc compilation warning about unused functions
139   bool TouchUnused() {
140     return (&amp;JfrThreadCPULoadEvent::send_events &amp;&amp;
141             &amp;JfrThreadCPULoadEvent::send_event_for_thread);
142   }
143 };
144 
145 TEST_VM_F(JfrTestThreadCPULoadSingle, SingleCpu) {
146   MockOs::user_cpu_time = 100 * NANOSECS_PER_MILLISEC;
147   MockOs::system_cpu_time = 100 * NANOSECS_PER_MILLISEC;
148   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, 400 * NANOSECS_PER_MILLISEC, 1));
149   EXPECT_FLOAT_EQ(0.25, event.user);
150   EXPECT_FLOAT_EQ(0.25, event.system);
151 
152   MockOs::user_cpu_time += 50 * NANOSECS_PER_MILLISEC;
153   MockOs::system_cpu_time += 50 * NANOSECS_PER_MILLISEC;
154   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (400 + 400) * NANOSECS_PER_MILLISEC, 1));
155   EXPECT_FLOAT_EQ(0.125, event.user);
156   EXPECT_FLOAT_EQ(0.125, event.system);
157 }
158 
159 TEST_VM_F(JfrTestThreadCPULoadSingle, MultipleCpus) {
160   MockOs::user_cpu_time = 100 * NANOSECS_PER_MILLISEC;
161   MockOs::system_cpu_time = 100 * NANOSECS_PER_MILLISEC;
162   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, 400 * NANOSECS_PER_MILLISEC, 2));
163   EXPECT_FLOAT_EQ(0.125, event.user);
164   EXPECT_FLOAT_EQ(0.125, event.system);
165 }
166 
167 TEST_VM_F(JfrTestThreadCPULoadSingle, BelowThreshold) {
168   MockOs::user_cpu_time = 100;
169   MockOs::system_cpu_time = 100;
170   EXPECT_FALSE(JfrThreadCPULoadEvent::update_event(event, thread, 400 * NANOSECS_PER_MILLISEC, 2));
171 }
172 
173 TEST_VM_F(JfrTestThreadCPULoadSingle, UserAboveMaximum) {
174 
175   // First call will not report above 100%
176   MockOs::user_cpu_time = 200 * NANOSECS_PER_MILLISEC;
177   MockOs::system_cpu_time = 100 * NANOSECS_PER_MILLISEC;
178   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, 200 * NANOSECS_PER_MILLISEC, 1));
179   EXPECT_FLOAT_EQ(0.5, event.user);
180   EXPECT_FLOAT_EQ(0.5, event.system);
181 
182   // Second call will see an extra 100 millisecs user time from the remainder
183   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (200 + 400) * NANOSECS_PER_MILLISEC, 1));
184   EXPECT_FLOAT_EQ(0.25, event.user);
185   EXPECT_FLOAT_EQ(0, event.system);
186 
187   // Third call: make sure there are no leftovers
188   MockOs::user_cpu_time += 50 * NANOSECS_PER_MILLISEC;
189   MockOs::system_cpu_time += 50 * NANOSECS_PER_MILLISEC;
190   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (200 + 400 + 400) * NANOSECS_PER_MILLISEC, 1));
191   EXPECT_FLOAT_EQ(0.125, event.user);
192   EXPECT_FLOAT_EQ(0.125, event.system);
193 }
194 
195 TEST_VM_F(JfrTestThreadCPULoadSingle, UserAboveMaximumNonZeroBase) {
196 
197   // Setup a non zero base
198   // Previously there was a bug when cur_user_time would be reset to zero and test that uses zero base would fail to detect it
199   MockOs::user_cpu_time = 100 * NANOSECS_PER_MILLISEC;
200   MockOs::system_cpu_time = 100 * NANOSECS_PER_MILLISEC;
201   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, 400 * NANOSECS_PER_MILLISEC, 1));
202   EXPECT_FLOAT_EQ(0.25, event.user);
203   EXPECT_FLOAT_EQ(0.25, event.system);
204 
205   // First call will not report above 100%
206   MockOs::user_cpu_time += 200 * NANOSECS_PER_MILLISEC;
207   MockOs::system_cpu_time += 100 * NANOSECS_PER_MILLISEC;
208   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (400 + 200) * NANOSECS_PER_MILLISEC, 1));
209   EXPECT_FLOAT_EQ(0.5, event.user);
210   EXPECT_FLOAT_EQ(0.5, event.system);
211 
212   // Second call will see an extra 100 millisecs user time from the remainder
213   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (400 + 200 + 400) * NANOSECS_PER_MILLISEC, 1));
214   EXPECT_FLOAT_EQ(0.25, event.user);
215   EXPECT_FLOAT_EQ(0, event.system);
216 
217   // Third call: make sure there are no leftovers
218   MockOs::user_cpu_time += 50 * NANOSECS_PER_MILLISEC;
219   MockOs::system_cpu_time += 50 * NANOSECS_PER_MILLISEC;
220   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (400 + 200 + 400 + 400) * NANOSECS_PER_MILLISEC, 1));
221   EXPECT_FLOAT_EQ(0.125, event.user);
222   EXPECT_FLOAT_EQ(0.125, event.system);
223 }
224 
225 TEST_VM_F(JfrTestThreadCPULoadSingle, SystemAboveMaximum) {
226 
227   // First call will not report above 100%
228   MockOs::user_cpu_time = 100 * NANOSECS_PER_MILLISEC;
229   MockOs::system_cpu_time = 300 * NANOSECS_PER_MILLISEC;
230   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, 200 * NANOSECS_PER_MILLISEC, 1));
231   EXPECT_FLOAT_EQ(0, event.user);
232   EXPECT_FLOAT_EQ(1, event.system);
233 
234   // Second call will see an extra 100 millisecs user and system time from the remainder
235   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (200 + 400) * NANOSECS_PER_MILLISEC, 1));
236   EXPECT_FLOAT_EQ(0.25, event.user);
237   EXPECT_FLOAT_EQ(0.25, event.system);
238 
239   // Third call: make sure there are no leftovers
240   MockOs::user_cpu_time += 50 * NANOSECS_PER_MILLISEC;
241   MockOs::system_cpu_time += 50 * NANOSECS_PER_MILLISEC;
242   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (200 + 400 + 400) * NANOSECS_PER_MILLISEC, 1));
243   EXPECT_FLOAT_EQ(0.125, event.user);
244   EXPECT_FLOAT_EQ(0.125, event.system);
245 }
246 
247 TEST_VM_F(JfrTestThreadCPULoadSingle, SystemAboveMaximumNonZeroBase) {
248 
249   // Setup a non zero base
250   // Previously there was a bug when cur_user_time would be reset to zero and test that uses zero base would fail to detect it
251   MockOs::user_cpu_time = 100 * NANOSECS_PER_MILLISEC;
252   MockOs::system_cpu_time = 100 * NANOSECS_PER_MILLISEC;
253   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, 400 * NANOSECS_PER_MILLISEC, 1));
254   EXPECT_FLOAT_EQ(0.25, event.user);
255   EXPECT_FLOAT_EQ(0.25, event.system);
256 
257   // First call will not report above 100%
258   MockOs::user_cpu_time += 100 * NANOSECS_PER_MILLISEC;
259   MockOs::system_cpu_time += 300 * NANOSECS_PER_MILLISEC;
260   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (400 + 200) * NANOSECS_PER_MILLISEC, 1));
261   EXPECT_FLOAT_EQ(0, event.user);
262   EXPECT_FLOAT_EQ(1, event.system);
263 
264   // Second call will see an extra 100 millisecs user and system time from the remainder
265   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (400 + 200 + 400) * NANOSECS_PER_MILLISEC, 1));
266   EXPECT_FLOAT_EQ(0.25, event.user);
267   EXPECT_FLOAT_EQ(0.25, event.system);
268 
269   // Third call: make sure there are no leftovers
270   MockOs::user_cpu_time += 50 * NANOSECS_PER_MILLISEC;
271   MockOs::system_cpu_time += 50 * NANOSECS_PER_MILLISEC;
272   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (400 + 200 + 400 + 400) * NANOSECS_PER_MILLISEC, 1));
273   EXPECT_FLOAT_EQ(0.125, event.user);
274   EXPECT_FLOAT_EQ(0.125, event.system);
275 }
276 
277 TEST_VM_F(JfrTestThreadCPULoadSingle, SystemTimeDecreasing) {
278 
279   // As seen in an actual run - caused by different resolution for total and user time
280   // Total time    User time    (Calculated system time)
281   //       200          100         100
282   //       210          200          10
283   //       400          300         100
284 
285   MockOs::user_cpu_time = 100 * NANOSECS_PER_MILLISEC;
286   MockOs::system_cpu_time = 100 * NANOSECS_PER_MILLISEC;
287   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, 400 * NANOSECS_PER_MILLISEC, 1));
288   EXPECT_FLOAT_EQ(0.25, event.user);
289   EXPECT_FLOAT_EQ(0.25, event.system);
290 
291   MockOs::user_cpu_time += 100 * NANOSECS_PER_MILLISEC;
292   MockOs::system_cpu_time -= 90 * NANOSECS_PER_MILLISEC;
293   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (400 + 400) * NANOSECS_PER_MILLISEC, 1));
294   EXPECT_FLOAT_EQ(0.25, event.user);
295   EXPECT_FLOAT_EQ(0, event.system);
296 
297   MockOs::user_cpu_time += 100 * NANOSECS_PER_MILLISEC;
298   MockOs::system_cpu_time += 90 * NANOSECS_PER_MILLISEC;
299   EXPECT_TRUE(JfrThreadCPULoadEvent::update_event(event, thread, (400 + 400 + 400) * NANOSECS_PER_MILLISEC, 1));
300   EXPECT_FLOAT_EQ(0.25, event.user);
301   EXPECT_FLOAT_EQ(0, event.system);
302 }
    </pre>
  </body>
</html>
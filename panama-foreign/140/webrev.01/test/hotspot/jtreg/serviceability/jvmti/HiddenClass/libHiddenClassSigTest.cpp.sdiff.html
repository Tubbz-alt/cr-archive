<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/serviceability/jvmti/HiddenClass/libHiddenClassSigTest.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="P/Q/HiddenClassSigTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../RedefineClasses/RedefineLeak.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/serviceability/jvmti/HiddenClass/libHiddenClassSigTest.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 
 27 extern &quot;C&quot; {
 28 
<span class="line-modified"> 29 static const char* EXP_INTERF_SIG = &quot;LP/Q/Test;&quot;;</span>
 30 static const char* SIG_START      = &quot;LP/Q/HiddenClassSig&quot;;
 31 static const size_t SIG_START_LEN = strlen(SIG_START);
 32 static const int    ACC_INTERFACE = 0x0200; // Interface class modifiers bit
 33 
 34 static jvmtiEnv *jvmti = NULL;
 35 static jint class_load_count = 0;

 36 static bool failed = false;
 37 
 38 #define LOG0(str)             { printf(str); fflush(stdout); }
 39 #define LOG1(str, arg)        { printf(str, arg); fflush(stdout); }
 40 #define LOG2(str, arg1, arg2) { printf(str, arg1, arg2); fflush(stdout); }
 41 
 42 #define CHECK_JVMTI_ERROR(jni, err, msg) \
 43   if (err != JVMTI_ERROR_NONE) { \
 44     LOG1(&quot;CHECK_JVMTI_ERROR: JVMTI function returned error: %d\n&quot;, err); \
 45     jni-&gt;FatalError(msg); \
 46     return; \
 47   }
 48 
 49 /* Return the jmethodID of j.l.Class.isHidden() method. */
 50 static jmethodID
 51 is_hidden_mid(JNIEnv* jni) {
 52   char* csig = NULL;
 53   jint count = 0;
 54   jmethodID *methods = NULL;
 55   jclass clazz  = jni-&gt;FindClass(&quot;java/lang/Class&quot;);
</pre>
<hr />
<pre>
 69 /* Return true if the klass is hidden. */
 70 static bool
 71 is_hidden(JNIEnv* jni, jclass klass) {
 72   static jmethodID is_hid_mid = NULL;
 73 
 74   if (is_hid_mid == NULL) {
 75     is_hid_mid = is_hidden_mid(jni);
 76   }
 77   // invoke j.l.Class.isHidden() method
 78   return jni-&gt;CallBooleanMethod(klass, is_hid_mid);
 79 }
 80 
 81 /* Check the class signature matches the expected. */
 82 static void
 83 check_class_signature(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass, bool is_hidden, const char* exp_sig) {
 84   jint class_modifiers = 0;
 85   char* sig = NULL;
 86   char* gsig = NULL;
 87   jvmtiError err;
 88 

 89   err = jvmti-&gt;GetClassSignature(klass, &amp;sig, &amp;gsig);
 90   CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class: Error in JVMTI GetClassSignature&quot;);
 91 
 92   LOG1(&quot;check_class_signature: class with sig: %s\n&quot;, sig);
 93   LOG1(&quot;check_class_signature: class with gsig: %s\n&quot;, gsig);
 94 
 95   if (strcmp(sig, exp_sig) != 0) {
 96     LOG2(&quot;check_class_signature: FAIL: Hidden class signature %s does not match expected: %s\n&quot;, sig, exp_sig);
 97     failed = true;
 98   }
 99   if (is_hidden &amp;&amp; gsig == NULL) {
100     LOG0(&quot;check_class_signature: FAIL: unexpected NULL generic signature for hidden class\n&quot;);
101     failed = true;
102   }
103 }
104 
105 /* Test hidden class flags: it should not be interface, array nor modifiable. */
106 static void
107 check_hidden_class_flags(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass) {
108   jint modifiers = 0;
</pre>
<hr />
<pre>
143 
144 /* Test GetClassLoaderClasses: it should not return any hidden classes. */
145 static void
146 check_hidden_class_loader(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass) {
147   jint count = 0;
148   jobject loader = NULL;
149   jclass* loader_classes = NULL;
150   jboolean found = false;
151   jvmtiError err;
152 
153   err = jvmti-&gt;GetClassLoader(klass, &amp;loader);
154   CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class_loader: Error in JVMTI GetClassLoader&quot;);
155 
156   err = jvmti-&gt;GetClassLoaderClasses(loader, &amp;count, &amp;loader_classes);
157   CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class_loader: Error in JVMTI GetClassLoaderClasses&quot;);
158 
159   for (int idx = 0; idx &lt; count; idx++) {
160     char* sig = NULL;
161     jclass kls = loader_classes[idx];
162 

163     if (!is_hidden(jni, kls)) {
164       continue;
165     }

166     err = jvmti-&gt;GetClassSignature(kls, &amp;sig, NULL);
167     CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class_loader: Error in JVMTI GetClassSignature&quot;);
168 
169     LOG1(&quot;check_hidden_class_loader: FAIL: JVMTI GetClassLoaderClasses returned hidden class: %s\n&quot;, sig);
170     failed = true;
171     return;
172   }
173   LOG0(&quot;check_hidden_class_loader: not found hidden class in its loader classes as expected\n&quot;);
174 }
175 
176 /* Test the hidden class implements expected interface. */
177 static void
178 check_hidden_class_impl_interf(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass) {
179   char* sig = NULL;
180   jint count = 0;
181   jclass* interfaces = NULL;
182   jvmtiError err;
183 
184   // check that hidden class implements just one interface
185   err = jvmti-&gt;GetImplementedInterfaces(klass, &amp;count, &amp;interfaces);
186   CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class_impl_interf: Error in JVMTI GetImplementedInterfaces&quot;);
187   if (count != 1) {
188     LOG1(&quot;check_hidden_class_impl_interf: FAIL: implemented interfaces count: %d, expected to be 1\n&quot;, count);
189     failed = true;
190     return;
191   }
<span class="line-modified">192 </span>
<span class="line-removed">193   // check the interface signature is matching the expected</span>
194   err = jvmti-&gt;GetClassSignature(interfaces[0], &amp;sig, NULL);
195   CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class_impl_interf: Error in JVMTI GetClassSignature for implemented interface&quot;);
196 

197   if (strcmp(sig, EXP_INTERF_SIG) != 0) {
198     LOG2(&quot;check_hidden_class_impl_interf: FAIL: implemented interface signature: %s, expected to be: %s\n&quot;,
199            sig, EXP_INTERF_SIG);
200     failed = true;
201   }
202 }
203 
204 /* Test hidden class. */
205 static void
206 check_hidden_class(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass, const char* exp_sig) {
207   char* source_file_name = NULL;
208 
209   LOG1(&quot;\n### Native agent: check_hidden_class started: class: %s\n&quot;, exp_sig);
210 
211   check_class_signature(jvmti, jni, klass, true /* not hidden */,  exp_sig);
212   if (failed) return;
213 
214   check_hidden_class_flags(jvmti, jni, klass);
215   if (failed) return;
216 
</pre>
<hr />
<pre>
219 
220   check_hidden_class_impl_interf(jvmti, jni, klass);
221   if (failed) return;
222 
223   LOG0(&quot;### Native agent: check_hidden_class finished\n&quot;);
224 }
225 
226 /* Test hidden class array. */
227 static void
228 check_hidden_class_array(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass_array, const char* exp_sig) {
229   char* source_file_name = NULL;
230 
231   LOG1(&quot;\n### Native agent: check_hidden_class_array started: array: %s\n&quot;, exp_sig);
232 
233   check_class_signature(jvmti, jni, klass_array, false /* is hidden */, exp_sig);
234   if (failed) return;
235 
236   LOG0(&quot;### Native agent: check_hidden_class_array finished\n&quot;);
237 }
238 
<span class="line-modified">239 /* Enable CLASS_LOAD event notification mode. */</span>
<span class="line-modified">240 static void JNICALL</span>
<span class="line-modified">241 VMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {</span>
<span class="line-removed">242   jvmtiError err;</span>
<span class="line-removed">243 </span>
<span class="line-removed">244   printf(&quot;VMInit event: SIG_START: %s, SIG_START_LEN: %d\n&quot;, SIG_START, (int)SIG_START_LEN);</span>
<span class="line-removed">245   fflush(stdout);</span>
<span class="line-removed">246 </span>
<span class="line-removed">247   err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);</span>
<span class="line-removed">248   CHECK_JVMTI_ERROR(jni, err, &quot;VMInit event: Error in enabling ClassLoad events notification&quot;);</span>
<span class="line-removed">249 }</span>
<span class="line-removed">250 </span>
<span class="line-removed">251 /* Check CLASS_LOAD event is generated for the given hidden class. */</span>
<span class="line-removed">252 static void JNICALL</span>
<span class="line-removed">253 ClassLoad(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread, jclass klass) {</span>
254   char* sig = NULL;
255   char* gsig = NULL;
<span class="line-removed">256   char* src_name = NULL;</span>
257   jvmtiError err;
258 

259   err = jvmti-&gt;GetClassSignature(klass, &amp;sig, &amp;gsig);
260   CHECK_JVMTI_ERROR(jni, err, &quot;ClassLoad event: Error in JVMTI GetClassSignature&quot;);
261 

262   if (strlen(sig) &gt; strlen(SIG_START) &amp;&amp;
263       strncmp(sig, SIG_START, SIG_START_LEN) == 0 &amp;&amp;
264       is_hidden(jni, klass)) {
<span class="line-modified">265     class_load_count++;</span>
266     if (gsig == NULL) {
<span class="line-modified">267       LOG0(&quot;ClassLoad event: FAIL: GetClassSignature returned NULL generic signature for hidden class\n&quot;);</span>
268       failed = true;
269     }
<span class="line-modified">270     LOG1(&quot;ClassLoad event: hidden class with sig: %s\n&quot;, sig);</span>
<span class="line-modified">271     LOG1(&quot;ClassLoad event: hidden class with gsig: %s\n&quot;, gsig);</span>
272   }
273 }
274 





























275 JNIEXPORT jint JNICALL
276 Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {
277   jvmtiEventCallbacks callbacks;
<span class="line-removed">278   jvmtiCapabilities caps;</span>
279   jvmtiError err;
280 
281   LOG0(&quot;Agent_OnLoad: started\n&quot;);
282   if (jvm-&gt;GetEnv((void **) (&amp;jvmti), JVMTI_VERSION) != JNI_OK) {
283     LOG0(&quot;Agent_OnLoad: Error in GetEnv in obtaining jvmtiEnv*\n&quot;);
284     failed = true;
285     return JNI_ERR;
286   }
287 
288   // set required event callbacks
289   memset(&amp;callbacks, 0, sizeof(callbacks));
290   callbacks.ClassLoad = &amp;ClassLoad;

291   callbacks.VMInit = &amp;VMInit;
292 
293   err = jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(jvmtiEventCallbacks));
294   if (err != JVMTI_ERROR_NONE) {
295     LOG1(&quot;Agent_OnLoad: Error in JVMTI SetEventCallbacks: %d\n&quot;, err);
296     failed = true;
297     return JNI_ERR;
298   }
299 
<span class="line-removed">300   // add required capabilities</span>
<span class="line-removed">301   memset(&amp;caps, 0, sizeof(caps));</span>
<span class="line-removed">302   caps.can_get_source_file_name = 1;</span>
<span class="line-removed">303   err = jvmti-&gt;AddCapabilities(&amp;caps);</span>
<span class="line-removed">304   if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-removed">305     LOG1(&quot;Agent_OnLoad: Error in JVMTI AddCapabilities: %d\n&quot;, err);</span>
<span class="line-removed">306     failed = true;</span>
<span class="line-removed">307     return JNI_ERR;</span>
<span class="line-removed">308   }</span>
<span class="line-removed">309 </span>
310   // enable VM_INIT event notification mode
311   err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);
312   if (err != JVMTI_ERROR_NONE) {
313     LOG1(&quot;Agent_OnLoad: Error in JVMTI SetEventNotificationMode: %d\n&quot;, err);
314     failed = true;
315     return JNI_ERR;
316   }
317 
318   LOG0(&quot;Agent_OnLoad: finished\n&quot;);
319   return JNI_OK;
320 }
321 
322 /* Native method: checkHiddenClass(). */
323 JNIEXPORT void JNICALL
324 Java_P_Q_HiddenClassSigTest_checkHiddenClass(JNIEnv *jni, jclass klass, jclass hidden_klass, jstring exp_sig_str) {
325   const char* exp_sig = jni-&gt;GetStringUTFChars(exp_sig_str, NULL);
326 
327   if (exp_sig == NULL) {
328     jni-&gt;FatalError(&quot;check_hidden_class: Error: JNI GetStringChars returned NULL for jstring\n&quot;);
329     return;
</pre>
<hr />
<pre>
334 }
335 
336 /* Native method: checkHiddenClassArray(). */
337 JNIEXPORT void JNICALL
338 Java_P_Q_HiddenClassSigTest_checkHiddenClassArray(JNIEnv *jni, jclass klass, jclass hidden_klass_array, jstring exp_sig_str) {
339   const char* exp_sig = jni-&gt;GetStringUTFChars(exp_sig_str, NULL);
340 
341   if (exp_sig == NULL) {
342     jni-&gt;FatalError(&quot;check_hidden_class_array: Error: JNI GetStringChars returned NULL for jstring\n&quot;);
343     return;
344   }
345   check_hidden_class_array(jvmti, jni, hidden_klass_array, exp_sig);
346 
347   jni-&gt;ReleaseStringUTFChars(exp_sig_str, exp_sig);
348 }
349 
350 /* Native method: checkFailed(). */
351 JNIEXPORT jboolean JNICALL
352 Java_P_Q_HiddenClassSigTest_checkFailed(JNIEnv *jni, jclass klass) {
353   if (class_load_count == 0) {
<span class="line-modified">354     LOG0(&quot;Native Agent: missed ClassLoad event for hidden class\n&quot;);</span>






355     failed = true;
356   }
357   return failed;
358 }
359 
360 } // extern &quot;C&quot;
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 
 27 extern &quot;C&quot; {
 28 
<span class="line-modified"> 29 static const char* EXP_INTERF_SIG = &quot;LP/Q/HCInterf;&quot;;</span>
 30 static const char* SIG_START      = &quot;LP/Q/HiddenClassSig&quot;;
 31 static const size_t SIG_START_LEN = strlen(SIG_START);
 32 static const int    ACC_INTERFACE = 0x0200; // Interface class modifiers bit
 33 
 34 static jvmtiEnv *jvmti = NULL;
 35 static jint class_load_count = 0;
<span class="line-added"> 36 static jint class_prep_count = 0;</span>
 37 static bool failed = false;
 38 
 39 #define LOG0(str)             { printf(str); fflush(stdout); }
 40 #define LOG1(str, arg)        { printf(str, arg); fflush(stdout); }
 41 #define LOG2(str, arg1, arg2) { printf(str, arg1, arg2); fflush(stdout); }
 42 
 43 #define CHECK_JVMTI_ERROR(jni, err, msg) \
 44   if (err != JVMTI_ERROR_NONE) { \
 45     LOG1(&quot;CHECK_JVMTI_ERROR: JVMTI function returned error: %d\n&quot;, err); \
 46     jni-&gt;FatalError(msg); \
 47     return; \
 48   }
 49 
 50 /* Return the jmethodID of j.l.Class.isHidden() method. */
 51 static jmethodID
 52 is_hidden_mid(JNIEnv* jni) {
 53   char* csig = NULL;
 54   jint count = 0;
 55   jmethodID *methods = NULL;
 56   jclass clazz  = jni-&gt;FindClass(&quot;java/lang/Class&quot;);
</pre>
<hr />
<pre>
 70 /* Return true if the klass is hidden. */
 71 static bool
 72 is_hidden(JNIEnv* jni, jclass klass) {
 73   static jmethodID is_hid_mid = NULL;
 74 
 75   if (is_hid_mid == NULL) {
 76     is_hid_mid = is_hidden_mid(jni);
 77   }
 78   // invoke j.l.Class.isHidden() method
 79   return jni-&gt;CallBooleanMethod(klass, is_hid_mid);
 80 }
 81 
 82 /* Check the class signature matches the expected. */
 83 static void
 84 check_class_signature(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass, bool is_hidden, const char* exp_sig) {
 85   jint class_modifiers = 0;
 86   char* sig = NULL;
 87   char* gsig = NULL;
 88   jvmtiError err;
 89 
<span class="line-added"> 90   // get class signature</span>
 91   err = jvmti-&gt;GetClassSignature(klass, &amp;sig, &amp;gsig);
 92   CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class: Error in JVMTI GetClassSignature&quot;);
 93 
 94   LOG1(&quot;check_class_signature: class with sig: %s\n&quot;, sig);
 95   LOG1(&quot;check_class_signature: class with gsig: %s\n&quot;, gsig);
 96 
 97   if (strcmp(sig, exp_sig) != 0) {
 98     LOG2(&quot;check_class_signature: FAIL: Hidden class signature %s does not match expected: %s\n&quot;, sig, exp_sig);
 99     failed = true;
100   }
101   if (is_hidden &amp;&amp; gsig == NULL) {
102     LOG0(&quot;check_class_signature: FAIL: unexpected NULL generic signature for hidden class\n&quot;);
103     failed = true;
104   }
105 }
106 
107 /* Test hidden class flags: it should not be interface, array nor modifiable. */
108 static void
109 check_hidden_class_flags(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass) {
110   jint modifiers = 0;
</pre>
<hr />
<pre>
145 
146 /* Test GetClassLoaderClasses: it should not return any hidden classes. */
147 static void
148 check_hidden_class_loader(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass) {
149   jint count = 0;
150   jobject loader = NULL;
151   jclass* loader_classes = NULL;
152   jboolean found = false;
153   jvmtiError err;
154 
155   err = jvmti-&gt;GetClassLoader(klass, &amp;loader);
156   CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class_loader: Error in JVMTI GetClassLoader&quot;);
157 
158   err = jvmti-&gt;GetClassLoaderClasses(loader, &amp;count, &amp;loader_classes);
159   CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class_loader: Error in JVMTI GetClassLoaderClasses&quot;);
160 
161   for (int idx = 0; idx &lt; count; idx++) {
162     char* sig = NULL;
163     jclass kls = loader_classes[idx];
164 
<span class="line-added">165     // GetClassLoaderClasses should not return any hidden classes</span>
166     if (!is_hidden(jni, kls)) {
167       continue;
168     }
<span class="line-added">169     // get class signature</span>
170     err = jvmti-&gt;GetClassSignature(kls, &amp;sig, NULL);
171     CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class_loader: Error in JVMTI GetClassSignature&quot;);
172 
173     LOG1(&quot;check_hidden_class_loader: FAIL: JVMTI GetClassLoaderClasses returned hidden class: %s\n&quot;, sig);
174     failed = true;
175     return;
176   }
177   LOG0(&quot;check_hidden_class_loader: not found hidden class in its loader classes as expected\n&quot;);
178 }
179 
180 /* Test the hidden class implements expected interface. */
181 static void
182 check_hidden_class_impl_interf(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass) {
183   char* sig = NULL;
184   jint count = 0;
185   jclass* interfaces = NULL;
186   jvmtiError err;
187 
188   // check that hidden class implements just one interface
189   err = jvmti-&gt;GetImplementedInterfaces(klass, &amp;count, &amp;interfaces);
190   CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class_impl_interf: Error in JVMTI GetImplementedInterfaces&quot;);
191   if (count != 1) {
192     LOG1(&quot;check_hidden_class_impl_interf: FAIL: implemented interfaces count: %d, expected to be 1\n&quot;, count);
193     failed = true;
194     return;
195   }
<span class="line-modified">196   // get interface signature</span>

197   err = jvmti-&gt;GetClassSignature(interfaces[0], &amp;sig, NULL);
198   CHECK_JVMTI_ERROR(jni, err, &quot;check_hidden_class_impl_interf: Error in JVMTI GetClassSignature for implemented interface&quot;);
199 
<span class="line-added">200   // check the interface signature is matching the expected</span>
201   if (strcmp(sig, EXP_INTERF_SIG) != 0) {
202     LOG2(&quot;check_hidden_class_impl_interf: FAIL: implemented interface signature: %s, expected to be: %s\n&quot;,
203            sig, EXP_INTERF_SIG);
204     failed = true;
205   }
206 }
207 
208 /* Test hidden class. */
209 static void
210 check_hidden_class(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass, const char* exp_sig) {
211   char* source_file_name = NULL;
212 
213   LOG1(&quot;\n### Native agent: check_hidden_class started: class: %s\n&quot;, exp_sig);
214 
215   check_class_signature(jvmti, jni, klass, true /* not hidden */,  exp_sig);
216   if (failed) return;
217 
218   check_hidden_class_flags(jvmti, jni, klass);
219   if (failed) return;
220 
</pre>
<hr />
<pre>
223 
224   check_hidden_class_impl_interf(jvmti, jni, klass);
225   if (failed) return;
226 
227   LOG0(&quot;### Native agent: check_hidden_class finished\n&quot;);
228 }
229 
230 /* Test hidden class array. */
231 static void
232 check_hidden_class_array(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass_array, const char* exp_sig) {
233   char* source_file_name = NULL;
234 
235   LOG1(&quot;\n### Native agent: check_hidden_class_array started: array: %s\n&quot;, exp_sig);
236 
237   check_class_signature(jvmti, jni, klass_array, false /* is hidden */, exp_sig);
238   if (failed) return;
239 
240   LOG0(&quot;### Native agent: check_hidden_class_array finished\n&quot;);
241 }
242 
<span class="line-modified">243 /* Process a CLASS_LOAD or aClassPrepare event. */</span>
<span class="line-modified">244 static void process_class_event(jvmtiEnv* jvmti, JNIEnv* jni, jclass klass,</span>
<span class="line-modified">245                                 jint* event_count_ptr, const char* event_name) {</span>












246   char* sig = NULL;
247   char* gsig = NULL;

248   jvmtiError err;
249 
<span class="line-added">250   // get class signature</span>
251   err = jvmti-&gt;GetClassSignature(klass, &amp;sig, &amp;gsig);
252   CHECK_JVMTI_ERROR(jni, err, &quot;ClassLoad event: Error in JVMTI GetClassSignature&quot;);
253 
<span class="line-added">254   // check if this is an expected class event for hidden class</span>
255   if (strlen(sig) &gt; strlen(SIG_START) &amp;&amp;
256       strncmp(sig, SIG_START, SIG_START_LEN) == 0 &amp;&amp;
257       is_hidden(jni, klass)) {
<span class="line-modified">258     (*event_count_ptr)++;</span>
259     if (gsig == NULL) {
<span class="line-modified">260       LOG1(&quot;%s event: FAIL: GetClassSignature returned NULL generic signature for hidden class\n&quot;, event_name);</span>
261       failed = true;
262     }
<span class="line-modified">263     LOG2(&quot;%s event: hidden class with sig: %s\n&quot;, event_name, sig);</span>
<span class="line-modified">264     LOG2(&quot;%s event: hidden class with gsig: %s\n&quot;, event_name, gsig);</span>
265   }
266 }
267 
<span class="line-added">268 /* Check CLASS_LOAD event is generated for the given hidden class. */</span>
<span class="line-added">269 static void JNICALL</span>
<span class="line-added">270 ClassLoad(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread, jclass klass) {</span>
<span class="line-added">271   process_class_event(jvmti, jni, klass, &amp;class_load_count, &quot;ClassLoad&quot;);</span>
<span class="line-added">272 }</span>
<span class="line-added">273 </span>
<span class="line-added">274 /* Check CLASS_PREPARE event is generated for the given hidden class. */</span>
<span class="line-added">275 static void JNICALL</span>
<span class="line-added">276 ClassPrepare(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread, jclass klass) {</span>
<span class="line-added">277   process_class_event(jvmti, jni, klass, &amp;class_prep_count, &quot;ClassPrepare&quot;);</span>
<span class="line-added">278 }</span>
<span class="line-added">279 </span>
<span class="line-added">280 /* Enable CLASS_LOAD event notification mode. */</span>
<span class="line-added">281 static void JNICALL</span>
<span class="line-added">282 VMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {</span>
<span class="line-added">283   jvmtiError err;</span>
<span class="line-added">284 </span>
<span class="line-added">285   printf(&quot;VMInit event: SIG_START: %s, SIG_START_LEN: %d\n&quot;, SIG_START, (int)SIG_START_LEN);</span>
<span class="line-added">286   fflush(stdout);</span>
<span class="line-added">287 </span>
<span class="line-added">288   // enable ClassLoad event notification mode</span>
<span class="line-added">289   err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);</span>
<span class="line-added">290   CHECK_JVMTI_ERROR(jni, err, &quot;VMInit event: Error in enabling ClassLoad events notification&quot;);</span>
<span class="line-added">291 </span>
<span class="line-added">292   // enable ClassPrepare event notification mode</span>
<span class="line-added">293   err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);</span>
<span class="line-added">294   CHECK_JVMTI_ERROR(jni, err, &quot;VMInit event: Error in enabling ClassPrepare events notification&quot;);</span>
<span class="line-added">295 }</span>
<span class="line-added">296 </span>
297 JNIEXPORT jint JNICALL
298 Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {
299   jvmtiEventCallbacks callbacks;

300   jvmtiError err;
301 
302   LOG0(&quot;Agent_OnLoad: started\n&quot;);
303   if (jvm-&gt;GetEnv((void **) (&amp;jvmti), JVMTI_VERSION) != JNI_OK) {
304     LOG0(&quot;Agent_OnLoad: Error in GetEnv in obtaining jvmtiEnv*\n&quot;);
305     failed = true;
306     return JNI_ERR;
307   }
308 
309   // set required event callbacks
310   memset(&amp;callbacks, 0, sizeof(callbacks));
311   callbacks.ClassLoad = &amp;ClassLoad;
<span class="line-added">312   callbacks.ClassPrepare = &amp;ClassPrepare;</span>
313   callbacks.VMInit = &amp;VMInit;
314 
315   err = jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(jvmtiEventCallbacks));
316   if (err != JVMTI_ERROR_NONE) {
317     LOG1(&quot;Agent_OnLoad: Error in JVMTI SetEventCallbacks: %d\n&quot;, err);
318     failed = true;
319     return JNI_ERR;
320   }
321 










322   // enable VM_INIT event notification mode
323   err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);
324   if (err != JVMTI_ERROR_NONE) {
325     LOG1(&quot;Agent_OnLoad: Error in JVMTI SetEventNotificationMode: %d\n&quot;, err);
326     failed = true;
327     return JNI_ERR;
328   }
329 
330   LOG0(&quot;Agent_OnLoad: finished\n&quot;);
331   return JNI_OK;
332 }
333 
334 /* Native method: checkHiddenClass(). */
335 JNIEXPORT void JNICALL
336 Java_P_Q_HiddenClassSigTest_checkHiddenClass(JNIEnv *jni, jclass klass, jclass hidden_klass, jstring exp_sig_str) {
337   const char* exp_sig = jni-&gt;GetStringUTFChars(exp_sig_str, NULL);
338 
339   if (exp_sig == NULL) {
340     jni-&gt;FatalError(&quot;check_hidden_class: Error: JNI GetStringChars returned NULL for jstring\n&quot;);
341     return;
</pre>
<hr />
<pre>
346 }
347 
348 /* Native method: checkHiddenClassArray(). */
349 JNIEXPORT void JNICALL
350 Java_P_Q_HiddenClassSigTest_checkHiddenClassArray(JNIEnv *jni, jclass klass, jclass hidden_klass_array, jstring exp_sig_str) {
351   const char* exp_sig = jni-&gt;GetStringUTFChars(exp_sig_str, NULL);
352 
353   if (exp_sig == NULL) {
354     jni-&gt;FatalError(&quot;check_hidden_class_array: Error: JNI GetStringChars returned NULL for jstring\n&quot;);
355     return;
356   }
357   check_hidden_class_array(jvmti, jni, hidden_klass_array, exp_sig);
358 
359   jni-&gt;ReleaseStringUTFChars(exp_sig_str, exp_sig);
360 }
361 
362 /* Native method: checkFailed(). */
363 JNIEXPORT jboolean JNICALL
364 Java_P_Q_HiddenClassSigTest_checkFailed(JNIEnv *jni, jclass klass) {
365   if (class_load_count == 0) {
<span class="line-modified">366     // expected ClassLoad event was not generated for hidden class</span>
<span class="line-added">367     LOG0(&quot;Native Agent: FAIL: missed ClassLoad event for hidden class\n&quot;);</span>
<span class="line-added">368     failed = true;</span>
<span class="line-added">369   }</span>
<span class="line-added">370   if (class_prep_count == 0) {</span>
<span class="line-added">371     // expected ClassPrepare event was not generated for hidden class</span>
<span class="line-added">372     LOG0(&quot;Native Agent: FAIL: missed ClassPrepare event for hidden class\n&quot;);</span>
373     failed = true;
374   }
375   return failed;
376 }
377 
378 } // extern &quot;C&quot;
</pre>
</td>
</tr>
</table>
<center><a href="P/Q/HiddenClassSigTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../RedefineClasses/RedefineLeak.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
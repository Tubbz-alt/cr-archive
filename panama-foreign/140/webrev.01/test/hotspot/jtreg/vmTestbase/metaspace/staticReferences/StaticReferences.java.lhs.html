<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/metaspace/staticReferences/StaticReferences.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @modules java.base/jdk.internal.misc:+open
 27  *
 28  * @summary converted from VM Testbase metaspace/staticReferences.
 29  * VM Testbase keywords: [nonconcurrent, javac, no_cds]
 30  *
 31  * @requires vm.opt.final.ClassUnloading
 32  * @library /vmTestbase /test/lib
 33  * @run driver jdk.test.lib.FileInstaller . .
 34  * @build sun.hotspot.WhiteBox
 35  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
<a name="2" id="anc2"></a><span class="line-removed"> 36  *                                sun.hotspot.WhiteBox$WhiteBoxPermission</span>
 37  * @run main/othervm
 38  *      -Xmx800m
 39  *      -Xbootclasspath/a:.
 40  *      -XX:+UnlockDiagnosticVMOptions
 41  *      -XX:+WhiteBoxAPI
 42  *      metaspace.staticReferences.StaticReferences
 43  */
 44 
 45 package metaspace.staticReferences;
 46 
 47 import java.lang.ref.WeakReference;
 48 import java.lang.ref.Reference;
 49 import java.lang.reflect.Field;
 50 import java.lang.reflect.Modifier;
 51 import java.util.HashMap;
 52 import java.util.LinkedList;
 53 import java.util.List;
 54 import java.util.Map;
 55 import java.util.Random;
 56 
 57 import vm.share.InMemoryJavaCompiler;
 58 import nsk.share.gc.GCTestBase;
 59 import nsk.share.test.ExecutionController;
 60 import nsk.share.test.Stresser;
 61 import nsk.share.test.TestBase;
 62 import nsk.share.test.Tests;
 63 import jdk.internal.misc.Unsafe;
 64 import vm.share.gc.TriggerUnloadingHelper;
 65 import vm.share.gc.TriggerUnloadingWithWhiteBox;
 66 
 67 /**
 68  * Test checks that static fields will be initialized in new loaded class. Test performs in loop the following routine:
 69  * 1.) Load class either by regular classloader or by Unsafe.defineAnonymousClass.
 70  * 2.) Trigger unloading. Class must be alive. Next step will check that static fields were not lost.
 71  * 3.) Change static fields.
 72  * 4.) Unload class.
 73  * 5.) Load class again as in step 1.
 74  * 6.) Check that static fields were initialized.
 75  */
 76 @SuppressWarnings(&quot;rawtypes&quot;)
 77 public class StaticReferences extends GCTestBase {
 78 
 79     private static final int UNLOADING_ATTEMPTS_LIMIT = 50;
 80 
 81     private static final Object[] NO_CP_PATCHES = new Object[0];
 82 
 83     private static String[] args;
 84 
 85     private static final int LIMIT = 20;
 86 
 87     private List&lt;Object&gt; keepAlive = new LinkedList&lt;Object&gt;();
 88 
 89     private Random random;
 90 
 91     private TriggerUnloadingHelper triggerUnloadingHelper = new TriggerUnloadingWithWhiteBox();
 92 
 93     private String[] typesArray = new String[] {&quot;Object object&quot;, &quot;boolean boolean&quot;, &quot;byte byte&quot;, &quot;char char&quot;, &quot;double double&quot;, &quot;float float&quot;, &quot;int int&quot;, &quot;long long&quot;, &quot;short short&quot;};
 94 
 95     public static void main(String[] args) {
 96         StaticReferences.args = args;
 97         Tests.runTest(new StaticReferences(), args);
 98     }
 99 
100     private static Unsafe getUnsafe() {
101         return Unsafe.getUnsafe();
102     }
103 
104         @Override
105     public void run() {
106         random = new Random(runParams.getSeed());
107         ExecutionController stresser = new Stresser(args);
108         stresser.start(1);
109 
110         // Generate and compile classes
111         List&lt;byte[]&gt; bytecodeList = new LinkedList&lt;byte[]&gt;();
112         int[] fieldQuantities = new int[9];
113         long startTimeStamp = System.currentTimeMillis();
114         for (int i = 0; i &lt; LIMIT; i++) {
115             if (!stresser.continueExecution()) {
116                         return;
117                 }
118             for (int j = 0; j &lt; fieldQuantities.length; j++) {
119                 fieldQuantities[j] = 1 + random.nextInt(20);
120             }
121             bytecodeList.add(generateAndCompile(fieldQuantities));
122         }
123         log.info(&quot;Compilation finished in &quot; + ((System.currentTimeMillis() - startTimeStamp)/1000/60.0) + &quot; minutes &quot;);
124 
125         // Core of test
126         for (byte[] classBytecode : bytecodeList) {
127             boolean anonymous = random.nextBoolean();
128 
129             log.info(&quot;Load class first time&quot;);
130             Class clazz = loadClass(classBytecode, anonymous);
131 
132             log.info(&quot;Trigger unloading&quot;);
133             triggerUnloadingHelper.triggerUnloading(stresser);
134             if (!stresser.continueExecution()) {
135                         return;
136                 }
137 
138             log.info(&quot;Set up static fields. This will check that static fields are reachable.&quot;);
139             setupFields(clazz);
140 
141             log.info(&quot;Cleanup references&quot;);
142             Reference&lt;Class&gt; weakReference = new WeakReference&lt;Class&gt;(clazz);
143             clazz = null;
144 
145             log.info(&quot;Trigger unloading again&quot;);
146             int numberOfAttemps = 0;
147             while (weakReference.get() != null &amp;&amp; numberOfAttemps &lt; UNLOADING_ATTEMPTS_LIMIT) {
148                 if (!stresser.continueExecution()) {
149                         return;
150                 }
151                 triggerUnloadingHelper.triggerUnloading(stresser);
152             }
153             if (numberOfAttemps &gt;= UNLOADING_ATTEMPTS_LIMIT) {
154                 setFailed(true);
155                 throw new RuntimeException(&quot;Test failed: was unable to unload class with &quot; + UNLOADING_ATTEMPTS_LIMIT + &quot; attempts.&quot;);
156             }
157 
158             log.info(&quot;Load class second time&quot;);
159             clazz = loadClass(classBytecode, anonymous);
160 
161             log.info(&quot;check fields reinitialized&quot;);
162             checkStaticFields(clazz);
163 
164             keepAlive.add(clazz);
165         }
166     }
167 
168         private Class loadClass(byte[] classBytecode,
169                         boolean anonymous) {
170                 Class clazz;
171                 if (anonymous) {
172                         clazz = getUnsafe().defineAnonymousClass(StaticReferences.class, classBytecode, NO_CP_PATCHES);
173                 } else {
174                         OneUsageClassloader classloader = new OneUsageClassloader();
175                         clazz = classloader.define(classBytecode);
176                 }
177                 return clazz;
178         }
179 
180     private void checkStaticFields(Class clazz) {
181         for (Field field : clazz.getFields()) {
182             try {
183                 if (Modifier.isStatic(field.getModifiers())) {
184                     Class fieldType = field.getType();
185                     if ((fieldType.equals(Object.class) &amp;&amp; field.get(null) != null )
186                             || (fieldType.equals(int.class) &amp;&amp; field.getInt(null) != 0)
187                             || (fieldType.equals(boolean.class) &amp;&amp; field.getBoolean(null) != false)
188                             || (fieldType.equals(char.class) &amp;&amp; field.getChar(null) != 0)
189                             || (fieldType.equals(long.class) &amp;&amp; field.getLong(null) != 0)
190                             || (fieldType.equals(short.class) &amp;&amp; field.getShort(null) != 0)
191                             || (fieldType.equals(float.class) &amp;&amp; field.getFloat(null) != 0.0f)
192                             || (fieldType.equals(double.class) &amp;&amp; field.getDouble(null) != 0.0)
193                             || (fieldType.equals(byte.class) &amp;&amp; field.getByte(null) != 0)) {
194                         setFailed(true);
195                         throw new RuntimeException(&quot;Failing test: field &quot;
196                                 + field.getName() + &quot; of type &quot;
197                                 + field.getType() + &quot; in class &quot;
198                                 + field.getDeclaringClass().getName()
199                                 + &quot; was not cleared&quot;);
200                     }
201                 }
202             } catch (IllegalArgumentException | IllegalAccessException e) {
203                 e.printStackTrace();
204                 throw new RuntimeException(&quot;Was unable to set static field &quot;
205                         + field.getName() + &quot; of type &quot;
206                         + field.getType().getName() + &quot; in class &quot;
207                         + field.getDeclaringClass().getName(), e);
208             }
209         }
210     }
211 
212     private byte[] generateAndCompile(int[] fieldQuantities) {
213         Map&lt;String, CharSequence&gt; sources = new HashMap&lt;String, CharSequence&gt;();
214         sources.put(&quot;A&quot;, generateSource(fieldQuantities));
215         return InMemoryJavaCompiler.compile(sources).values().iterator().next();
216     }
217 
218     private StringBuffer generateSource(int[] fieldQuantities) {
219         StringBuffer result = new StringBuffer(&quot;public class A { \n&quot;);
220         int fieldsCounter = 0;
221         for (int i = 0; i &lt; typesArray.length; i++) {
222             for (int j = 0; j &lt; fieldQuantities[i]; j++) {
223                 result.append(&quot; public static &quot; + typesArray[i] + fieldsCounter++ + &quot;;\n&quot;);
224             }
225         }
226         result.append(&quot; } &quot;);
227         return result;
228     }
229 
230     private void setupFields(Class clazz) {
231         for (Field field : clazz.getFields()) {
232             try {
233                 if (Modifier.isStatic(field.getModifiers())) {
234                     Class fieldType = field.getType();
235                     if (fieldType.equals(Object.class)) {
236                         field.set(null, this);
237                     } else if (fieldType.equals(int.class)) {
238                         field.setInt(null, 42);
239                     } else if (fieldType.equals(boolean.class)) {
240                         field.setBoolean(null, true);
241                     } else if (fieldType.equals(char.class)) {
242                         field.setChar(null, &#39;c&#39;);
243                     } else if (fieldType.equals(long.class)) {
244                         field.setLong(null, (long) 42);
245                     } else if (fieldType.equals(short.class)) {
246                         field.setShort(null, (short) 42);
247                     } else if (fieldType.equals(float.class)) {
248                         field.setFloat(null, 42.42f);
249                     } else if (fieldType.equals(double.class)) {
250                         field.setDouble(null, 42.42);
251                     } else if (fieldType.equals(byte.class)) {
252                         field.setByte(null, (byte) 42);
253                     }
254                 }
255             } catch (IllegalArgumentException | IllegalAccessException e) {
256                 e.printStackTrace();
257                 throw new RuntimeException(
258                         &quot;Was unable to set static field &quot; + field.getName()
259                                 + &quot; of type &quot; + field.getType().getName()
260                                 + &quot; in class &quot;
261                                 + field.getDeclaringClass().getName(), e);
262             }
263         }
264     }
265 
266 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
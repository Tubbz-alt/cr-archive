diff a/test/hotspot/jtreg/vmTestbase/nsk/share/test/LocalRandom.java b/test/hotspot/jtreg/vmTestbase/nsk/share/test/LocalRandom.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/test/LocalRandom.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/test/LocalRandom.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -21,32 +21,54 @@
  * questions.
  */
 
 package nsk.share.test;
 
-import java.util.concurrent.ThreadLocalRandom;
+import java.util.Random;
+import jdk.test.lib.Utils;
 import nsk.share.TestFailure;
 
 /**
  * Utility class which encapsulates all useful static methods.
  */
 public class LocalRandom {
+    static {
+        // ensure seed got printed out
+        Utils.getRandomInstance();
+    }
+    private final static ThreadLocal<Random> random = new ThreadLocal<>() {
+        protected Random initialValue() {
+            // each thread gets its own seed independendly on the order they
+            // use LocalRandom, yet it depends on the order threads are created.
+            // main thread uses original seed
+            return new Random(Utils.SEED ^ (Thread.currentThread().getId() - 1));
+        }
+    };
     private static int minPauseTime = 3000;
     private static int maxPauseTime = 5000;
     private static int maxRandomCount = 65536;
 
+
+    /*
+     * Initializes a thread-local instance to ensure that there is enough memory.
+     * Useful for tests that exhaust memory.
+     */
+    public static void init() {
+        random.get();
+    }
+
     /*
      * Return next random double number.
      *
      * @return random double
      */
     public static double random() {
-        return ThreadLocalRandom.current().nextDouble();
+        return random.get().nextDouble();
     }
 
     public static double nextDouble() {
-        return ThreadLocalRandom.current().nextDouble();
+        return random.get().nextDouble();
     }
 
     public static byte nextByte() {
         return (byte) nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE);
     }
@@ -58,11 +80,11 @@
     public static short nextShort() {
         return (short) nextInt(Short.MIN_VALUE, Short.MAX_VALUE);
     }
 
     public static boolean nextBoolean() {
-        return ThreadLocalRandom.current().nextBoolean();
+        return random.get().nextBoolean();
     }
 
     public static void nextBytes(byte[] arr) {
         if (arr.length == 0) {
             return;
@@ -250,25 +272,25 @@
 
     public static void validate(double[] arr) {
     }
 
     public static int nextInt() {
-        return ThreadLocalRandom.current().nextInt();
+        return random.get().nextInt();
     }
 
     /**
      * Return next integer value from 0..n range.
      *
      * @param n maximum value
      * @return random integer
      */
     public static int nextInt(int n) {
-        return ThreadLocalRandom.current().nextInt(n);
+        return random.get().nextInt(n);
     }
 
     public static long nextLong() {
-        return ThreadLocalRandom.current().nextLong();
+        return random.get().nextLong();
     }
 
     /**
      * Return next random integer from min..max range.
      *
@@ -284,11 +306,11 @@
      * Return next random float number.
      *
      * @return random double
      */
     public static float nextFloat() {
-        return ThreadLocalRandom.current().nextFloat();
+        return random.get().nextFloat();
     }
 
     /**
      * Return random pause time.
      */

diff a/test/hotspot/jtreg/vmTestbase/nsk/share/gc/NonbranchyTree.java b/test/hotspot/jtreg/vmTestbase/nsk/share/gc/NonbranchyTree.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/gc/NonbranchyTree.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/gc/NonbranchyTree.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,10 +25,11 @@
 
 import java.io.*;
 import java.util.*;
 
 import nsk.share.test.ExecutionController;
+import nsk.share.test.LocalRandom;
 
 /**
  * <tt>NonbranchyTree</tt> defines a tree structure. Each node of the tree
  * always has one son. A node may have the second son with probability
  * <tt>branchiness</tt>.
@@ -36,11 +37,10 @@
 public class NonbranchyTree {
 
     /** Minimal size of each node (in bytes) */
     public final static int MIN_NODE_SIZE = 20;
     private Node root;
-    private Random random;
     private int numberOfNodes;
     private float branchiness;
     private int size;
     private ExecutionController controller;
 
@@ -59,25 +59,20 @@
      *         less than 1; or <tt>branchiness</tt> is greater than 1, or less
      *         or equal than 0; or <tt>size</tt> is less than 1.
      *
      */
     public NonbranchyTree(int numberOfNodes, float branchiness, int size) {
-        this(numberOfNodes, branchiness, size, new Random(System.currentTimeMillis()), null);
+        this(numberOfNodes, branchiness, size, null);
         initTree();
     }
 
     public NonbranchyTree(int numberOfNodes, float branchiness, int size, ExecutionController controller) {
-        this(numberOfNodes, branchiness, size, new Random(System.currentTimeMillis()), controller);
-        initTree();
-    }
-
-    private NonbranchyTree(int numberOfNodes, float branchiness, int size, Random random, ExecutionController controller) {
         this.numberOfNodes = numberOfNodes;
         this.branchiness = branchiness;
         this.size = size;
-        this.random = random;
         this.controller = controller;
+        initTree();
     }
 
     private void initTree() {
         if (numberOfNodes < 1) {
             throw new IllegalArgumentException("Illegal number of nodes: "
@@ -92,10 +87,12 @@
         }
         if (size < 1) {
             throw new IllegalArgumentException("Illegal size of nodes: "
                                              + size + ", must be at least 1.");
         }
+        // ensure that LocalRandom is loaded and has enough memory
+        LocalRandom.nextBoolean();
         root = createTree(numberOfNodes, size);
     }
 
     // Create a new tree with specified number of nodes and size of each node
     private Node createTree(int numberOfNodes, int size) {
@@ -117,11 +114,11 @@
                 return node;
             } else {
                 // Create a few nodes
                 if (makeRightNode()) {
                     // The node will have two sons
-                    int leftNodes = 1 + random.nextInt(numberOfNodes - 2);
+                    int leftNodes = 1 + LocalRandom.nextInt(numberOfNodes - 2);
                     int rightNodes = numberOfNodes - 1 - leftNodes;
 
                     node.left = createTree(leftNodes, size);
                     node.right = createTree(rightNodes, size);
                 } else {
@@ -140,11 +137,11 @@
         } // try
     } // createTree()
 
     // Define the "branchiness" of the tree
     private boolean makeRightNode() {
-        return (random.nextFloat() < branchiness);
+        return (LocalRandom.nextFloat() < branchiness);
     }
 
     /**
      * Bends the tree. A son of a leaf of the tree is set to the root node.
      *

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/gc/g1/plab/TestPLABResize.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24  /*
 25  * @test TestPLABResize
 26  * @bug 8141278 8141141
 27  * @summary Test for PLAB resizing
 28  * @requires vm.gc.G1
 29  * @requires !vm.flightRecorder
 30  * @library /test/lib /
 31  * @modules java.base/jdk.internal.misc
 32  * @modules java.management
 33  * @build sun.hotspot.WhiteBox
 34  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
<a name="2" id="anc2"></a><span class="line-removed"> 35  *                              sun.hotspot.WhiteBox$WhiteBoxPermission</span>
 36  * @run main gc.g1.plab.TestPLABResize
 37  */
 38 package gc.g1.plab;
 39 
 40 import java.util.Arrays;
 41 import java.util.List;
 42 import java.util.stream.Collectors;
 43 import java.io.PrintStream;
 44 
 45 import gc.g1.plab.lib.LogParser;
 46 import gc.g1.plab.lib.PLABUtils;
 47 import gc.g1.plab.lib.AppPLABResize;
 48 import gc.g1.plab.lib.PlabReport;
 49 
 50 import jdk.test.lib.process.OutputAnalyzer;
 51 import jdk.test.lib.process.ProcessTools;
 52 
 53 /**
 54  * Test for PLAB resizing.
 55  */
 56 public class TestPLABResize {
 57 
 58     private static final int OBJECT_SIZE_SMALL = 10;
 59     private static final int OBJECT_SIZE_MEDIUM = 70;
 60     private static final int OBJECT_SIZE_HIGH = 150;
 61     private static final int GC_NUM_SMALL = 1;
 62     private static final int GC_NUM_MEDIUM = 3;
 63     private static final int GC_NUM_HIGH = 7;
 64     private static final int WASTE_PCT_SMALL = 10;
 65     private static final int WASTE_PCT_MEDIUM = 20;
 66     private static final int WASTE_PCT_HIGH = 30;
 67 
 68     private static final int ITERATIONS_SMALL = 3;
 69     private static final int ITERATIONS_MEDIUM = 5;
 70     private static final int ITERATIONS_HIGH = 8;
 71 
 72     private static final String PLAB_SIZE_FIELD_NAME = &quot;actual&quot;;
 73 
 74     private final static TestCase[] TEST_CASES = {
 75         new TestCase(WASTE_PCT_SMALL, OBJECT_SIZE_SMALL, GC_NUM_SMALL, ITERATIONS_MEDIUM),
 76         new TestCase(WASTE_PCT_SMALL, OBJECT_SIZE_MEDIUM, GC_NUM_HIGH, ITERATIONS_SMALL),
 77         new TestCase(WASTE_PCT_SMALL, OBJECT_SIZE_HIGH, GC_NUM_MEDIUM, ITERATIONS_HIGH),
 78         new TestCase(WASTE_PCT_MEDIUM, OBJECT_SIZE_SMALL, GC_NUM_HIGH, ITERATIONS_MEDIUM),
 79         new TestCase(WASTE_PCT_MEDIUM, OBJECT_SIZE_MEDIUM, GC_NUM_SMALL, ITERATIONS_SMALL),
 80         new TestCase(WASTE_PCT_MEDIUM, OBJECT_SIZE_HIGH, GC_NUM_MEDIUM, ITERATIONS_HIGH),
 81         new TestCase(WASTE_PCT_HIGH, OBJECT_SIZE_SMALL, GC_NUM_HIGH, ITERATIONS_MEDIUM),
 82         new TestCase(WASTE_PCT_HIGH, OBJECT_SIZE_MEDIUM, GC_NUM_SMALL, ITERATIONS_SMALL),
 83         new TestCase(WASTE_PCT_HIGH, OBJECT_SIZE_HIGH, GC_NUM_MEDIUM, ITERATIONS_HIGH)
 84     };
 85 
 86     public static void main(String[] args) throws Throwable {
 87         for (TestCase testCase : TEST_CASES) {
 88             testCase.print(System.out);
 89             List&lt;String&gt; options = PLABUtils.prepareOptions(testCase.toOptions());
 90             options.add(AppPLABResize.class.getName());
<a name="3" id="anc3"></a><span class="line-modified"> 91             OutputAnalyzer out = ProcessTools.executeTestJvm(options.toArray(new String[options.size()]));</span>
 92             PLABUtils.commonCheck(out);
 93             checkResults(out.getOutput(), testCase);
 94         }
 95     }
 96 
 97     /**
 98      * Checks testing results.
 99      * Expected results - desired PLAB size is decreased and increased during promotion to Survivor.
100      *
101      * @param output - VM output
102      * @param testCase
103      */
104     private static void checkResults(String output, TestCase testCase) {
105         final LogParser log = new LogParser(output);
106         final PlabReport report = log.getEntries();
107 
108         final List&lt;Long&gt; plabSizes = report.entryStream()
109                 .map(item -&gt; item.getValue()
110                         .get(LogParser.ReportType.SURVIVOR_STATS)
111                         .get(PLAB_SIZE_FIELD_NAME)
112                 )
113                 .collect(Collectors.toList());
114 
115         // Check that desired plab size was changed during iterations.
116         // The test case does 3 rounds of allocations.  The second round of N allocations and GC&#39;s
117         // has a decreasing size of allocations so that iterations N to 2*N -1 will be of decreasing size.
118         // The third round with iterations 2*N to 3*N -1 has increasing sizes of allocation.
119         if ( plabSizes.size() != testCase.iterations * 3 ) {
120             System.out.println(output);
121             throw new RuntimeException (&quot;Expects for &quot; + testCase.iterations * 3 + &quot; PLAB entries in log, found &quot; + plabSizes.size());
122         }
123 
124         long startDesiredPLABSize = plabSizes.get(testCase.getIterations());
125         long endDesiredPLABSize = plabSizes.get(testCase.getIterations() * 2 - 1);
126 
127         if (startDesiredPLABSize &lt; endDesiredPLABSize) {
128             System.out.println(output);
129             throw new RuntimeException(&quot;Test failed! Expect that initial PLAB size should be greater than checked. Initial size: &quot; + startDesiredPLABSize + &quot; Checked size:&quot; + endDesiredPLABSize);
130         }
131 
132         startDesiredPLABSize = plabSizes.get(testCase.getIterations() * 2);
133         endDesiredPLABSize = plabSizes.get(testCase.getIterations() * 3 - 1);
134 
135         if (startDesiredPLABSize &gt; endDesiredPLABSize) {
136             System.out.println(output);
137             throw new RuntimeException(&quot;Test failed! Expect that initial PLAB size should be less than checked. Initial size: &quot; + startDesiredPLABSize + &quot; Checked size:&quot; + endDesiredPLABSize);
138         }
139 
140         System.out.println(&quot;Test passed!&quot;);
141     }
142 
143     /**
144      * Description of one test case.
145      */
146     private static class TestCase {
147 
148         private final int wastePct;
149         private final int chunkSize;
150         private final int parGCThreads;
151         private final int iterations;
152 
153         /**
154          * @param wastePct
155          * ParallelGCBufferWastePct
156          * @param chunkSize
157          * requested object size for memory consumption
158          * @param parGCThreads
159          * -XX:ParallelGCThreads
160          * @param iterations
161          *
162          */
163         public TestCase(int wastePct,
164                 int chunkSize,
165                 int parGCThreads,
166                 int iterations
167         ) {
168             if (wastePct == 0 || chunkSize == 0 || parGCThreads == 0 || iterations == 0) {
169                 throw new IllegalArgumentException(&quot;Parameters should not be 0&quot;);
170             }
171             this.wastePct = wastePct;
172 
173             this.chunkSize = chunkSize;
174             this.parGCThreads = parGCThreads;
175             this.iterations = iterations;
176         }
177 
178         /**
179          * Convert current TestCase to List of options.
180          *
181          * @return
182          * List of options
183          */
184         public List&lt;String&gt; toOptions() {
185             return Arrays.asList(&quot;-XX:ParallelGCThreads=&quot; + parGCThreads,
186                     &quot;-XX:ParallelGCBufferWastePct=&quot; + wastePct,
187                     &quot;-XX:+ResizePLAB&quot;,
188                     &quot;-Dchunk.size=&quot; + chunkSize,
189                     &quot;-Diterations=&quot; + iterations,
190                     &quot;-XX:NewSize=16m&quot;,
191                     &quot;-XX:MaxNewSize=16m&quot;
192             );
193         }
194 
195         /**
196          * Print details about test case.
197          */
198         public void print(PrintStream out) {
199             out.println(&quot;Test case details:&quot;);
200             out.println(&quot;  Parallel GC buffer waste pct : &quot; + wastePct);
201             out.println(&quot;  Chunk size : &quot; + chunkSize);
202             out.println(&quot;  Parallel GC threads : &quot; + parGCThreads);
203             out.println(&quot;  Iterations: &quot; + iterations);
204         }
205 
206         /**
207          * @return iterations
208          */
209         public int getIterations() {
210             return iterations;
211         }
212     }
213 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
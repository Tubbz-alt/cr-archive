<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/gc/g1/TestShrinkAuxiliaryData.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.g1;
 25 
 26 import jdk.test.lib.Asserts;
 27 import jdk.test.lib.Platform;
 28 import jdk.test.lib.Utils;
 29 import jdk.test.lib.process.ProcessTools;
 30 import jdk.test.lib.process.OutputAnalyzer;
 31 import jtreg.SkippedException;
 32 
 33 import java.io.IOException;
 34 import java.lang.management.ManagementFactory;
 35 import java.lang.management.MemoryUsage;
 36 import java.text.DecimalFormat;
 37 import java.text.DecimalFormatSymbols;
 38 import java.util.ArrayList;
 39 import java.util.Collections;
 40 import java.util.LinkedList;
 41 import java.util.List;
 42 import java.util.Random;
 43 import jdk.internal.misc.Unsafe; // for ADDRESS_SIZE
 44 import sun.hotspot.WhiteBox;
 45 
 46 public class TestShrinkAuxiliaryData {
 47     private static final Random RNG = Utils.getRandomInstance();
 48 
 49     private static final int REGION_SIZE = 1024 * 1024;
 50 
 51     private final static String[] initialOpts = new String[]{
 52         &quot;-XX:NewSize=16m&quot;,
 53         &quot;-XX:MinHeapFreeRatio=10&quot;,
 54         &quot;-XX:MaxHeapFreeRatio=11&quot;,
 55         &quot;-XX:+UseG1GC&quot;,
 56         &quot;-XX:G1HeapRegionSize=&quot; + REGION_SIZE,
 57         &quot;-XX:-ExplicitGCInvokesConcurrent&quot;,
 58         &quot;-Xlog:gc=debug&quot;,
 59         &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
 60         &quot;-XX:+WhiteBoxAPI&quot;,
 61         &quot;--add-exports=java.base/jdk.internal.misc=ALL-UNNAMED&quot;,
 62         &quot;-Xbootclasspath/a:.&quot;,
 63     };
 64 
 65     private final int hotCardTableSize;
 66 
 67     protected TestShrinkAuxiliaryData(int hotCardTableSize) {
 68         this.hotCardTableSize = hotCardTableSize;
 69     }
 70 
 71     protected void test() throws Exception {
 72         ArrayList&lt;String&gt; vmOpts = new ArrayList&lt;&gt;();
 73         Collections.addAll(vmOpts, initialOpts);
 74 
 75         int maxCacheSize = Math.max(0, Math.min(31, getMaxCacheSize()));
 76         if (maxCacheSize &lt; hotCardTableSize) {
 77             throw new SkippedException(String.format(
 78                     &quot;Skiping test for %d cache size due max cache size %d&quot;,
 79                     hotCardTableSize, maxCacheSize));
 80         }
 81 
 82         printTestInfo(maxCacheSize);
 83 
 84         vmOpts.add(&quot;-XX:G1ConcRSLogCacheSize=&quot; + hotCardTableSize);
 85 
 86         // for 32 bits ObjectAlignmentInBytes is not a option
 87         if (Platform.is32bit()) {
 88             ArrayList&lt;String&gt; vmOptsWithoutAlign = new ArrayList&lt;&gt;(vmOpts);
 89             vmOptsWithoutAlign.add(ShrinkAuxiliaryDataTest.class.getName());
 90             performTest(vmOptsWithoutAlign);
 91             return;
 92         }
 93 
 94         for (int alignment = 3; alignment &lt;= 8; alignment++) {
 95             ArrayList&lt;String&gt; vmOptsWithAlign = new ArrayList&lt;&gt;(vmOpts);
 96             vmOptsWithAlign.add(&quot;-XX:ObjectAlignmentInBytes=&quot;
 97                     + (int) Math.pow(2, alignment));
 98             vmOptsWithAlign.add(ShrinkAuxiliaryDataTest.class.getName());
 99 
100             performTest(vmOptsWithAlign);
101         }
102     }
103 
104     private void performTest(List&lt;String&gt; opts) throws Exception {
105         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, opts);
106 
107         OutputAnalyzer output = new OutputAnalyzer(pb.start());
108         System.out.println(output.getStdout());
109         System.err.println(output.getStderr());
110         output.shouldHaveExitValue(0);
111     }
112 
113     private void printTestInfo(int maxCacheSize) {
114 
115         DecimalFormat grouped = new DecimalFormat(&quot;000,000&quot;);
116         DecimalFormatSymbols formatSymbols = grouped.getDecimalFormatSymbols();
117         formatSymbols.setGroupingSeparator(&#39; &#39;);
118         grouped.setDecimalFormatSymbols(formatSymbols);
119 
120         System.out.format(
121                 &quot;Test will use %s bytes of memory of %s available%n&quot;
122                 + &quot;Available memory is %s with %d bytes pointer size - can save %s pointers%n&quot;
123                 + &quot;Max cache size: 2^%d = %s elements%n&quot;,
124                 grouped.format(ShrinkAuxiliaryDataTest.getMemoryUsedByTest()),
125                 grouped.format(Runtime.getRuntime().maxMemory()),
126                 grouped.format(Runtime.getRuntime().maxMemory()
127                         - ShrinkAuxiliaryDataTest.getMemoryUsedByTest()),
128                 Unsafe.ADDRESS_SIZE,
129                 grouped.format((Runtime.getRuntime().freeMemory()
130                         - ShrinkAuxiliaryDataTest.getMemoryUsedByTest())
131                         / Unsafe.ADDRESS_SIZE),
132                 maxCacheSize,
133                 grouped.format((int) Math.pow(2, maxCacheSize))
134         );
135     }
136 
137     /**
138      * Detects maximum possible size of G1ConcRSLogCacheSize available for
139      * current process based on maximum available process memory size
140      *
141      * @return power of two
142      */
143     private static int getMaxCacheSize() {
144         long availableMemory = Runtime.getRuntime().freeMemory()
145                 - ShrinkAuxiliaryDataTest.getMemoryUsedByTest() - 1l;
146         if (availableMemory &lt;= 0) {
147             return 0;
148         }
149 
150         long availablePointersCount = availableMemory / Unsafe.ADDRESS_SIZE;
151         return (63 - (int) Long.numberOfLeadingZeros(availablePointersCount));
152     }
153 
154     static class ShrinkAuxiliaryDataTest {
155 
156         public static void main(String[] args) throws IOException {
157 
158             ShrinkAuxiliaryDataTest testCase = new ShrinkAuxiliaryDataTest();
159 
160             if (!testCase.checkEnvApplicability()) {
161                 return;
162             }
163 
164             testCase.test();
165         }
166 
167         /**
168          * Checks is this environment suitable to run this test
169          * - memory is enough to decommit (page size is not big)
170          * - RSet cache size is not too big
171          *
172          * @return true if test could run, false if test should be skipped
173          */
174         protected boolean checkEnvApplicability() {
175 
176             int pageSize = WhiteBox.getWhiteBox().getVMPageSize();
177             System.out.println( &quot;Page size = &quot; + pageSize
178                     + &quot; region size = &quot; + REGION_SIZE
179                     + &quot; aux data ~= &quot; + (REGION_SIZE * 3 / 100));
180             // If auxdata size will be less than page size it wouldn&#39;t decommit.
181             // Auxiliary data size is about ~3.6% of heap size.
182             if (pageSize &gt;= REGION_SIZE * 3 / 100) {
183                 System.out.format(&quot;Skipping test for too large page size = %d&quot;,
184                        pageSize
185                 );
186                 return false;
187             }
188 
189             if (REGION_SIZE * REGIONS_TO_ALLOCATE &gt; Runtime.getRuntime().maxMemory()) {
190                 System.out.format(&quot;Skipping test for too low available memory. &quot;
191                         + &quot;Need %d, available %d&quot;,
192                         REGION_SIZE * REGIONS_TO_ALLOCATE,
193                         Runtime.getRuntime().maxMemory()
194                 );
195                 return false;
196             }
197 
198             return true;
199         }
200 
201         class GarbageObject {
202 
203             private final List&lt;byte[]&gt; payload = new ArrayList&lt;&gt;();
204             private final List&lt;GarbageObject&gt; ref = new LinkedList&lt;&gt;();
205 
206             public GarbageObject(int size) {
207                 payload.add(new byte[size]);
208             }
209 
210             public void addRef(GarbageObject g) {
211                 ref.add(g);
212             }
213 
214             public void mutate() {
215                 if (!payload.isEmpty() &amp;&amp; payload.get(0).length &gt; 0) {
216                     payload.get(0)[0] = (byte) (RNG.nextDouble() * Byte.MAX_VALUE);
217                 }
218             }
219         }
220 
221         private final List&lt;GarbageObject&gt; garbage = new ArrayList&lt;&gt;();
222 
223         public void test() throws IOException {
224 
225             MemoryUsage muFull, muFree, muAuxDataFull, muAuxDataFree;
226             float auxFull, auxFree;
227 
228             allocate();
229             link();
230             mutate();
231 
232             muFull = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
233             long numUsedRegions = WhiteBox.getWhiteBox().g1NumMaxRegions()
234                     - WhiteBox.getWhiteBox().g1NumFreeRegions();
235             muAuxDataFull = WhiteBox.getWhiteBox().g1AuxiliaryMemoryUsage();
236             auxFull = (float)muAuxDataFull.getUsed() / numUsedRegions;
237 
238             System.out.format(&quot;Full aux data  ratio= %f, regions max= %d, used= %d\n&quot;,
239                     auxFull, WhiteBox.getWhiteBox().g1NumMaxRegions(), numUsedRegions
240             );
241 
242             deallocate();
243             System.gc();
244 
245             muFree = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
246             muAuxDataFree = WhiteBox.getWhiteBox().g1AuxiliaryMemoryUsage();
247 
248             numUsedRegions = WhiteBox.getWhiteBox().g1NumMaxRegions()
249                     - WhiteBox.getWhiteBox().g1NumFreeRegions();
250             auxFree = (float)muAuxDataFree.getUsed() / numUsedRegions;
251 
252             System.out.format(&quot;Free aux data ratio= %f, regions max= %d, used= %d\n&quot;,
253                     auxFree, WhiteBox.getWhiteBox().g1NumMaxRegions(), numUsedRegions
254             );
255 
256             Asserts.assertLessThanOrEqual(muFree.getCommitted(), muFull.getCommitted(),
257                     String.format(&quot;heap decommit failed - full &gt; free: %d &gt; %d&quot;,
258                             muFree.getCommitted(), muFull.getCommitted()
259                     )
260             );
261 
262             System.out.format(&quot;State               used   committed\n&quot;);
263             System.out.format(&quot;Full aux data: %10d %10d\n&quot;, muAuxDataFull.getUsed(), muAuxDataFull.getCommitted());
264             System.out.format(&quot;Free aux data: %10d %10d\n&quot;, muAuxDataFree.getUsed(), muAuxDataFree.getCommitted());
265 
266             // if decommited check that aux data has same ratio
267             if (muFree.getCommitted() &lt; muFull.getCommitted()) {
268                 Asserts.assertLessThanOrEqual(auxFree, auxFull,
269                         String.format(&quot;auxiliary data decommit failed - full &gt; free: %f &gt; %f&quot;,
270                                 auxFree, auxFull
271                         )
272                 );
273             }
274         }
275 
276         private void allocate() {
277             for (int r = 0; r &lt; REGIONS_TO_ALLOCATE; r++) {
278                 for (int i = 0; i &lt; NUM_OBJECTS_PER_REGION; i++) {
279                     GarbageObject g = new GarbageObject(REGION_SIZE
280                             / NUM_OBJECTS_PER_REGION);
281                     garbage.add(g);
282                 }
283             }
284         }
285 
286         /**
287          * Iterate through all allocated objects, and link to objects in another
288          * regions
289          */
290         private void link() {
291             for (int ig = 0; ig &lt; garbage.size(); ig++) {
292                 int regionNumber = ig / NUM_OBJECTS_PER_REGION;
293 
294                 for (int i = 0; i &lt; NUM_LINKS; i++) {
295                     int regionToLink;
296                     do {
297                         regionToLink = (int) (RNG.nextDouble() * REGIONS_TO_ALLOCATE);
298                     } while (regionToLink == regionNumber);
299 
300                     // get random garbage object from random region
301                     garbage.get(ig).addRef(garbage.get(regionToLink
302                             * NUM_OBJECTS_PER_REGION + (int) (RNG.nextDouble()
303                             * NUM_OBJECTS_PER_REGION)));
304                 }
305             }
306         }
307 
308         private void mutate() {
309             for (int ig = 0; ig &lt; garbage.size(); ig++) {
310                 garbage.get(ig).mutate();
311             }
312         }
313 
314         private void deallocate() {
315             garbage.clear();
316             System.gc();
317         }
318 
319         static long getMemoryUsedByTest() {
320             return REGIONS_TO_ALLOCATE * REGION_SIZE;
321         }
322 
323         private static final int REGIONS_TO_ALLOCATE = 100;
324         private static final int NUM_OBJECTS_PER_REGION = 10;
325         private static final int NUM_LINKS = 20; // how many links create for each object
326     }
327 }
    </pre>
  </body>
</html>
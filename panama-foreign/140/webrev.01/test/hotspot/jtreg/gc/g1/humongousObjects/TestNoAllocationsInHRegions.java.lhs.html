<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/gc/g1/humongousObjects/TestNoAllocationsInHRegions.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.g1.humongousObjects;
 25 
 26 import jdk.test.lib.Utils;
 27 import sun.hotspot.WhiteBox;
 28 
 29 import static gc.testlibrary.Allocation.blackHole;
 30 
 31 import java.util.LinkedList;
 32 import java.util.List;
 33 import java.util.Random;
 34 import java.util.stream.Collectors;
 35 
 36 /**
 37  * @test TestNoAllocationsInHRegions
 38  * @key randomness
 39  * @summary Checks that no additional allocations are made in humongous regions
 40  * @requires vm.gc.G1
 41  * @library /test/lib /
 42  * @modules java.management java.base/jdk.internal.misc
 43  * @build sun.hotspot.WhiteBox
 44  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
<a name="1" id="anc1"></a><span class="line-removed"> 45  *      sun.hotspot.WhiteBox$WhiteBoxPermission</span>
 46  *
 47  * @run main/othervm -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:.
 48  *                   -XX:G1HeapRegionSize=1M -Xms200m -Xmx200m -XX:MaxTenuringThreshold=0
 49  *                   -Xlog:gc=trace:file=TestNoAllocationsInHRegions10.log
 50  *                   gc.g1.humongousObjects.TestNoAllocationsInHRegions 30 10
 51  *
 52  * @run main/othervm -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:.
 53  *                   -XX:G1HeapRegionSize=1M -Xms200m -Xmx200m -XX:MaxTenuringThreshold=0
 54  *                   -Xlog:gc=trace:file=TestNoAllocationsInHRegions50.log
 55  *                   gc.g1.humongousObjects.TestNoAllocationsInHRegions 30 50
 56  *
 57  * @run main/othervm -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:.
 58  *                   -XX:G1HeapRegionSize=1M -Xms200m -Xmx200m -XX:MaxTenuringThreshold=0
 59  *                   -Xlog:gc=trace:file=TestNoAllocationsInHRegions70.log
 60  *                   gc.g1.humongousObjects.TestNoAllocationsInHRegions 30 70
 61  */
 62 public class TestNoAllocationsInHRegions {
 63     private static final WhiteBox WB = WhiteBox.getWhiteBox();
 64     private static final Random RND = Utils.getRandomInstance();
 65     private static final int G1_REGION_SIZE = WB.g1RegionSize();
 66     private static final int[] HUMONGOUS_SIZES = {G1_REGION_SIZE / 2, G1_REGION_SIZE + 1, G1_REGION_SIZE * 2 + 1};
 67     private static final int ALLOC_THREAD_COUNT = 5;
 68 
 69     // We fill specified part of heap with humongous objects - we need public static to prevent escape analysis to
 70     // collect this field
 71     public static LinkedList&lt;byte[]&gt; humongousAllocations = new LinkedList&lt;&gt;();
 72 
 73     private static volatile boolean shouldStop = false;
 74     private static volatile Error error = null;
 75 
 76     static class Allocator implements Runnable {
 77         private final Random random;
 78         private final List&lt;byte[]&gt; liveObjects = new LinkedList&lt;&gt;();
 79         private int usedMemory = 0;
 80         public final Runnable[] actions;
 81 
 82         /**
 83          * Maximum size of simple allocation
 84          */
 85         private static final int MAX_ALLOCATION_SIZE = (int) (G1_REGION_SIZE / 2 * 0.9);
 86 
 87         /**
 88          * Maximum size of dead (i.e. one which is made unreachable right after allocation) object
 89          */
 90         private static final int DEAD_OBJECT_MAX_SIZE = G1_REGION_SIZE / 10;
 91 
 92         public Allocator(int maxAllocationMemory) {
 93             random = new Random(RND.nextLong());
 94             actions = new Runnable[]{
 95                     // Allocation
 96                     () -&gt; {
 97                         if (maxAllocationMemory - usedMemory != 0) {
 98                             int arraySize = random.nextInt(Math.min(maxAllocationMemory - usedMemory,
 99                                     MAX_ALLOCATION_SIZE));
100 
101                             if (arraySize != 0) {
102                                 byte[] allocation = new byte[arraySize];
103                                 liveObjects.add(allocation);
104                                 usedMemory += arraySize;
105 
106                                 // Sanity check
107                                 if (WB.g1IsHumongous(allocation)) {
108                                     String errorMessage = String.format(&quot;Test Bug: Byte array of size&quot;
109                                                     + &quot; %d is expected to be non-humongous but it is humongous&quot;,
110                                             allocation.length);
111 
112                                     System.out.println(errorMessage);
113                                     error = new Error(errorMessage);
114                                     shouldStop = true;
115                                 }
116 
117                                 // Test check
118                                 if (WB.g1BelongsToHumongousRegion(WB.getObjectAddress(allocation))) {
119                                     String errorMessage = String.format(&quot;Non-humongous allocation of byte array of &quot;
120                                             + &quot;length %d and size %d with address %d was made in Humongous Region&quot;,
121                                             allocation.length, WB.getObjectSize(allocation),
122                                             WB.getObjectAddress(allocation));
123 
124                                     System.out.println(errorMessage);
125                                     error = new Error(errorMessage);
126                                     shouldStop = true;
127                                 }
128                             }
129                         }
130                     },
131 
132                     // Deallocation
133                     () -&gt; {
134                         if (liveObjects.size() != 0) {
135                             int elementNum = random.nextInt(liveObjects.size());
136                             int shouldFree = liveObjects.get(elementNum).length;
137                             liveObjects.remove(elementNum);
138                             usedMemory -= shouldFree;
139                         }
140                     },
141 
142                     // Dead object allocation
143                     () -&gt; {
144                         int size = random.nextInt(DEAD_OBJECT_MAX_SIZE);
145                         blackHole(new byte[size]);
146                     },
147 
148                     // Check
149                     () -&gt; {
150                         List&lt;byte[]&gt; wrongHumongousAllocations = liveObjects.stream()
151                                 .filter(WB::g1IsHumongous)
152                                 .collect(Collectors.toList());
153 
154                         if (wrongHumongousAllocations.size() &gt; 0) {
155                             wrongHumongousAllocations.stream().forEach(a -&gt;
156                                     System.out.format(&quot;Non-humongous allocation of byte array of length %d and&quot;
157                                                     + &quot; size %d with address %d was made in Humongous Region&quot;,
158                                             a.length, WB.getObjectSize(a), WB.getObjectAddress(a)));
159                             error = new Error(&quot;Some non-humongous allocations were made to humongous region&quot;);
160                             shouldStop = true;
161                         }
162                     }
163             };
164         }
165 
166         @Override
167         public void run() {
168             while (!shouldStop) {
169                 actions[random.nextInt(actions.length)].run();
170                 Thread.yield();
171             }
172         }
173     }
174 
175     public static void main(String[] args) {
176         if (args.length != 2) {
177             throw new Error(&quot;Test Bug: Expected duration (in seconds) and percent of allocated regions were not &quot;
178                     + &quot;provided as command line argument&quot;);
179         }
180 
181         // test duration
182         long duration = Integer.parseInt(args[0]) * 1000L;
183         // part of heap preallocated with humongous objects (in percents)
184         int percentOfAllocatedHeap = Integer.parseInt(args[1]);
185 
186         long startTime = System.currentTimeMillis();
187 
188         long initialFreeRegionsCount = WB.g1NumFreeRegions();
189         int regionsToAllocate = (int) ((double) initialFreeRegionsCount / 100.0 * percentOfAllocatedHeap);
190         long freeRegionLeft = initialFreeRegionsCount - regionsToAllocate;
191 
192         System.out.println(&quot;Regions to allocate: &quot; + regionsToAllocate + &quot;; regions to left free: &quot; + freeRegionLeft);
193 
194         int maxMemoryPerAllocThread = (int) ((Runtime.getRuntime().freeMemory() / 100.0
195                 * (100 - percentOfAllocatedHeap)) / ALLOC_THREAD_COUNT * 0.5);
196 
197         System.out.println(&quot;Using &quot; + maxMemoryPerAllocThread / 1024 + &quot;KB for each of &quot; + ALLOC_THREAD_COUNT
198                 + &quot; allocation threads&quot;);
199 
200         while (WB.g1NumFreeRegions() &gt; freeRegionLeft) {
201             try {
202                 humongousAllocations.add(new byte[HUMONGOUS_SIZES[RND.nextInt(HUMONGOUS_SIZES.length)]]);
203             } catch (OutOfMemoryError oom) {
204                 //We got OOM trying to fill heap with humongous objects
205                 //It probably means that heap is fragmented which is strange since the test logic should avoid it
206                 System.out.println(&quot;Warning: OOM while allocating humongous objects - it likely means &quot;
207                         + &quot;that heap is fragmented&quot;);
208                 break;
209             }
210         }
211 
212         System.out.println(&quot;Initial free regions &quot; + initialFreeRegionsCount + &quot;; Free regions left &quot;
213                 + WB.g1NumFreeRegions());
214 
215         LinkedList&lt;Thread&gt; threads = new LinkedList&lt;&gt;();
216 
217         for (int i = 0; i &lt; ALLOC_THREAD_COUNT; i++) {
218             threads.add(new Thread(new Allocator(maxMemoryPerAllocThread)));
219         }
220 
221         threads.stream().forEach(Thread::start);
222 
223         while ((System.currentTimeMillis() - startTime &lt; duration) &amp;&amp; error == null) {
224             Thread.yield();
225         }
226 
227         shouldStop = true;
228         System.out.println(&quot;Finished test&quot;);
229         if (error != null) {
230             throw error;
231         }
232     }
233 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
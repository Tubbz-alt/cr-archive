<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/gc/arguments/TestMaxMinHeapFreeRatioFlags.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.arguments;
 25 
 26 /*
 27  * @test TestMaxMinHeapFreeRatioFlags
 28  * @key gc
 29  * @summary Verify that heap size changes according to max and min heap free ratios.
 30  * @requires vm.gc != &quot;Z&quot; &amp; vm.gc != &quot;Shenandoah&quot;
 31  * @library /test/lib
 32  * @library /
 33  * @modules java.base/jdk.internal.misc
 34  *          java.management
 35  * @run driver/timeout=240 gc.arguments.TestMaxMinHeapFreeRatioFlags
 36  */
 37 
 38 import java.util.LinkedList;
 39 import java.util.Arrays;
 40 import java.util.Collections;
 41 import jdk.test.lib.process.OutputAnalyzer;
 42 import jdk.test.lib.process.ProcessTools;
 43 import jdk.test.lib.Utils;
 44 import jdk.internal.misc.Unsafe;
 45 
 46 public class TestMaxMinHeapFreeRatioFlags {
 47 
 48     public static final long M = 1024 * 1024;
 49     public static final long MAX_HEAP_SIZE = 200 * M;
 50     public static final long HEAP_SIZE = 10 * M;
 51     public static final long MAX_NEW_SIZE = 20 * M;
 52     public static final long NEW_SIZE = 5 * M;
 53 
 54     public static void main(String args[]) throws Exception {
 55         LinkedList&lt;String&gt; options = new LinkedList&lt;&gt;(
 56                 Arrays.asList(Utils.getFilteredTestJavaOpts(&quot;-XX:[^ ]*HeapFreeRatio&quot;,&quot;-XX:\\+ExplicitGCInvokesConcurrent&quot;))
 57         );
 58 
 59         negativeTest(20, false, 10, true, options);
 60         negativeTest(100, true, 0, false, options);
 61         negativeTest(101, false, 50, false, options);
 62         negativeTest(49, true, 102, true, options);
 63         negativeTest(-1, false, 50, false, options);
 64         negativeTest(50, true, -1, true, options);
 65 
 66         positiveTest(10, false, 90, false, true, options);
 67         positiveTest(10, true, 80, false, true, options);
 68         positiveTest(20, false, 70, true, true, options);
 69         positiveTest(25, true, 65, true, true, options);
 70         positiveTest(40, false, 50, false, true, options);
 71     }
 72 
 73     /**
 74      * Verify that heap size will be changed to conform
 75      * min and max heap free ratios.
 76      *
 77      * @param minRatio value of MinHeapFreeRatio option
 78      * @param useXminf used Xminf option instead of MinHeapFreeRatio
 79      * @param maxRatio value of MaxHeapFreeRatio option
 80      * @param useXmaxf used Xmaxf option instead of MaxHeapFreeRatio
 81      * @param options additional options for JVM
 82      */
 83     public static void positiveTest(int minRatio, boolean useXminf,
 84             int maxRatio, boolean useXmaxf, boolean shrinkHeapInSteps,
 85             LinkedList&lt;String&gt; options) throws Exception {
 86 
 87         LinkedList&lt;String&gt; vmOptions = new LinkedList&lt;&gt;(options);
 88         Collections.addAll(vmOptions,
 89                 (useXminf ? &quot;-Xminf&quot; + minRatio / 100.0 : &quot;-XX:MinHeapFreeRatio=&quot; + minRatio),
 90                 (useXmaxf ? &quot;-Xmaxf&quot; + maxRatio / 100.0 : &quot;-XX:MaxHeapFreeRatio=&quot; + maxRatio),
 91                 &quot;-Xmx&quot; + MAX_HEAP_SIZE,
 92                 &quot;-Xms&quot; + HEAP_SIZE,
 93                 &quot;--add-exports=java.base/jdk.internal.misc=ALL-UNNAMED&quot;,
 94                 &quot;-XX:NewSize=&quot; + NEW_SIZE,
 95                 &quot;-XX:MaxNewSize=&quot; + MAX_NEW_SIZE,
 96                 &quot;-XX:&quot; + (shrinkHeapInSteps ? &#39;+&#39; : &#39;-&#39;) + &quot;ShrinkHeapInSteps&quot;,
 97                 RatioVerifier.class.getName(),
 98                 Integer.toString(minRatio),
 99                 Integer.toString(maxRatio),
100                 Boolean.toString(shrinkHeapInSteps)
101         );
102 
<a name="1" id="anc1"></a><span class="line-modified">103         ProcessBuilder procBuilder = GCArguments.createJavaProcessBuilder(vmOptions.toArray(new String[vmOptions.size()]));</span>
104         OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());
105         analyzer.shouldHaveExitValue(0);
106     }
107 
108     /**
109      * Verify that VM will fail to start with specified ratios.
110      *
111      * @param minRatio value of MinHeapFreeRatio option
112      * @param useXminf used Xminf option instead of MinHeapFreeRatio
113      * @param maxRatio value of MaxHeapFreeRatio option
114      * @param useXmaxf used Xmaxf option instead of MaxHeapFreeRatio
115      * @param options additional options for JVM
116      */
117     public static void negativeTest(int minRatio, boolean useXminf,
118             int maxRatio, boolean useXmaxf,
119             LinkedList&lt;String&gt; options) throws Exception {
120 
121         LinkedList&lt;String&gt; vmOptions = new LinkedList&lt;&gt;(options);
122         Collections.addAll(vmOptions,
123                 (useXminf ? &quot;-Xminf&quot; + minRatio / 100.0 : &quot;-XX:MinHeapFreeRatio=&quot; + minRatio),
124                 (useXmaxf ? &quot;-Xmaxf&quot; + maxRatio / 100.0 : &quot;-XX:MaxHeapFreeRatio=&quot; + maxRatio),
125                 &quot;--add-exports=java.base/jdk.internal.misc=ALL-UNNAMED&quot;,
126                 &quot;-version&quot;
127         );
<a name="2" id="anc2"></a><span class="line-modified">128         ProcessBuilder procBuilder = GCArguments.createJavaProcessBuilder(vmOptions.toArray(new String[vmOptions.size()]));</span>
129         OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());
130         analyzer.shouldHaveExitValue(1);
131         analyzer.shouldContain(&quot;Error: Could not create the Java Virtual Machine.&quot;);
132     }
133 
134     /**
135      * RatioVerifier will be executed in the tested VM.
136      * It will check that real heap usage after collection lies between MinHeapFreeRatio and MaxHeapFreeRatio.
137      */
138     public static class RatioVerifier {
139 
140         private static final Unsafe unsafe = Unsafe.getUnsafe();
141 
142         // Size of byte array that will be allocated
143         public static final int CHUNK_SIZE = 1024;
144         // Length of byte array, that will be added to &quot;garbage&quot; list.
145         public static final int ARRAY_LENGTH = CHUNK_SIZE - Unsafe.ARRAY_BYTE_BASE_OFFSET;
146         // Amount of tries to force heap shrinking/expansion using GC
147         public static final int GC_TRIES = 10;
148 
149         // Value that will be added/substracted from expected min/max heap free ratio
150         // during memory allocation to make sure that specified limit will be exceeded.
151         public static final double OVERLOAD = 0.05;
152         // Acceptable heap free ratio limit exceedance: verification will fail if
153         // actual ratio is lower than expected min heap free ratio - VARIANCE or
154         // higher than expected max heap free ratio + VARIANCE.
155         public static final double VARIANCE = 0.025;
156 
157         public static LinkedList&lt;Object&gt; garbage = new LinkedList&lt;&gt;();
158 
159         public static void main(String args[]) throws Exception {
160             if (args.length != 3) {
161                 throw new IllegalArgumentException(&quot;Expected 3 args: &lt;minRatio&gt; &lt;maxRatio&gt; &lt;shrinkHeapInSteps&gt;&quot;);
162             }
163             if (GCTypes.OldGCType.getOldGCType() == GCTypes.OldGCType.PSOld ||
164                 GCTypes.OldGCType.getOldGCType() == GCTypes.OldGCType.G1) {
165                 System.out.println(&quot;Test is not applicable to parallel full GCs&quot;);
166                 return;
167             }
168 
169             double minRatio = Integer.valueOf(args[0]) / 100.0;
170             double maxRatio = Integer.valueOf(args[1]) / 100.0;
171             boolean shrinkHeapInSteps = Boolean.valueOf(args[2]);
172 
173             long maxHeapSize = getMax();
174             int gcTries = (shrinkHeapInSteps ? GC_TRIES : 1);
175 
176             // Initial checks. This also links up everything in these helper methods,
177             // in case it brings more garbage.
178             forceGC(gcTries);
179             verifyRatio(minRatio, maxRatio);
180 
181             // commit 0.5 of total heap size to have enough space
182             // to both shink and expand
183             while (getCommitted() &lt; maxHeapSize / 2) {
184                 garbage.add(new byte[ARRAY_LENGTH]);
185             }
186 
187             forceGC(gcTries);
188             // Verify that current heap free ratio lies between specified limits
189             verifyRatio(minRatio, maxRatio);
190 
191             // Estimate how much memory we have to allocate to force expansion
192             long memoryToFill = (long) (getCommitted() * (1 - minRatio + OVERLOAD))
193                     - getUsed();
194 
195             long previouslyCommitted = getCommitted();
196 
197             while (memoryToFill &gt; 0) {
198                 garbage.add(new byte[CHUNK_SIZE]);
199                 memoryToFill -= CHUNK_SIZE;
200             }
201 
202             forceGC(gcTries);
203             // Verify that after memory allocation heap free ratio is still conforming specified limits
204             verifyRatio(minRatio, maxRatio);
205             // Verify that heap was actually expanded
206             if (previouslyCommitted &gt;= getCommitted()) {
207                 throw new RuntimeException(&quot;Heap was not expanded.&quot;);
208             }
209 
210             // Estimate how much memory we have to free to force shrinking
211             long memoryToFree = getUsed()
212                     - (long) (getCommitted() * (1 - maxRatio - OVERLOAD));
213 
214             previouslyCommitted = getCommitted();
215 
216             while (memoryToFree &gt; 0 &amp;&amp; garbage.size() &gt; 0) {
217                 garbage.remove(garbage.size() - 1);
218                 memoryToFree -= CHUNK_SIZE;
219             }
220 
221             forceGC(gcTries);
222             // Verify that heap free ratio is still conforming specified limits
223             verifyRatio(minRatio, maxRatio);
224             // Verify that heap was actually shrinked
225             if (previouslyCommitted &lt;= getCommitted()) {
226                 throw new RuntimeException(&quot;Heap was not shrinked.&quot;);
227             }
228         }
229 
230         public static void forceGC(int gcTries) {
231             for (int i = 0; i &lt; gcTries; i++) {
232                 System.gc();
233                 try {
234                     Thread.sleep(10);
235                 } catch (InterruptedException ie) {
236                 }
237             }
238         }
239 
240         /**
241          * Verify that heap free ratio is conforming specified limits.
242          * Actual heap free ratio may be very close to one of specified limits,
243          * but exceed for more then VARIANCE.
244          * Verification will also pass if actual ratio is not conforming limits,
245          * but it is not possible to shrink/expand heap.
246          */
247         public static void verifyRatio(double minRatio, double maxRatio) {
248             double ratio = getHeapFreeRatio();
249             System.out.println(minRatio + &quot; &quot; + ratio + &quot; &quot; + maxRatio);
250             if (minRatio - ratio &gt; VARIANCE
251                     &amp;&amp; getCommitted() &lt; getMax()) {
252                 throw new RuntimeException(&quot;Current heap free ratio is lower than &quot;
253                         + &quot;MinHeapFreeRatio (&quot; + ratio + &quot; vs &quot; + minRatio + &quot;).&quot;);
254             }
255             if (ratio - maxRatio &gt; VARIANCE
256                     &amp;&amp; getUsed() &gt; getInit()) {
257                 throw new RuntimeException(&quot;Current heap free ratio is higher than &quot;
258                         + &quot;MaxHeapFreeRatio (&quot; + ratio + &quot; vs &quot; + maxRatio + &quot;).&quot;);
259             }
260         }
261 
262         /*
263          * Obtain information about heap size.
264          *
265          * For G1 information summed up for all type of regions,
266          * because tested options affect overall heap sizing.
267          *
268          * For all other GCs return information only for old gen.
269          */
270         public static long getMax() {
271             return HeapRegionUsageTool.getOldUsage().getMax();
272         }
273 
274         public static long getInit() {
275             if (GCTypes.OldGCType.getOldGCType() == GCTypes.OldGCType.G1) {
276                 return HeapRegionUsageTool.getEdenUsage().getInit()
277                         + HeapRegionUsageTool.getSurvivorUsage().getInit()
278                         + HeapRegionUsageTool.getOldUsage().getInit();
279             } else {
280                 return HeapRegionUsageTool.getOldUsage().getInit();
281             }
282         }
283 
284         public static long getUsed() {
285             if (GCTypes.OldGCType.getOldGCType() == GCTypes.OldGCType.G1) {
286                 return HeapRegionUsageTool.getEdenUsage().getUsed()
287                         + HeapRegionUsageTool.getSurvivorUsage().getUsed()
288                         + HeapRegionUsageTool.getOldUsage().getUsed();
289             } else {
290                 return HeapRegionUsageTool.getOldUsage().getUsed();
291             }
292         }
293 
294         public static long getCommitted() {
295             if (GCTypes.OldGCType.getOldGCType() == GCTypes.OldGCType.G1) {
296                 return HeapRegionUsageTool.getEdenUsage().getCommitted()
297                         + HeapRegionUsageTool.getSurvivorUsage().getCommitted()
298                         + HeapRegionUsageTool.getOldUsage().getCommitted();
299             } else {
300                 return HeapRegionUsageTool.getOldUsage().getCommitted();
301             }
302         }
303 
304         public static long getFree() {
305             return getCommitted() - getUsed();
306         }
307 
308         public static double getHeapFreeRatio() {
309             return getFree() / (double) getCommitted();
310         }
311     }
312 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
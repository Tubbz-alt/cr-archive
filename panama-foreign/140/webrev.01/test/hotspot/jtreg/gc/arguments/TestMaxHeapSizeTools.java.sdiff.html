<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/gc/arguments/TestMaxHeapSizeTools.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="TestInitialTenuringThreshold.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestMaxMinHeapFreeRatioFlags.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/gc/arguments/TestMaxHeapSizeTools.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
176 
177   private static void checkValidMinMaxHeapCombinations(String gcflag) throws Exception {
178     expectValid(new String[] { gcflag, &quot;-XX:MinHeapSize=4M&quot;, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-version&quot; });
179     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-XX:MinHeapSize=4M&quot;, &quot;-version&quot; });
180     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:MinHeapSize=4M&quot;, &quot;-version&quot; });
181     // a value of &quot;0&quot; for min heap size means auto-detect
182     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:MinHeapSize=0M&quot;, &quot;-version&quot; });
183   }
184 
185   private static long valueAfter(String source, String match) {
186     int start = source.indexOf(match) + match.length();
187     String tail = source.substring(start).split(&quot; &quot;)[0];
188     return Long.parseLong(tail);
189   }
190 
191   /**
192    * Executes a new VM process with the given class and parameters.
193    * @param vmargs Arguments to the VM to run
194    * @param classname Name of the class to run
195    * @param arguments Arguments to the class
<span class="line-removed">196    * @param useTestDotJavaDotOpts Use test.java.opts as part of the VM argument string</span>
197    * @return The OutputAnalyzer with the results for the invocation.
198    */
<span class="line-modified">199   public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments, boolean useTestDotJavaDotOpts) throws Exception {</span>
200     ArrayList&lt;String&gt; finalargs = new ArrayList&lt;String&gt;();
201 
202     String[] whiteboxOpts = new String[] {
203       &quot;-Xbootclasspath/a:.&quot;,
204       &quot;-XX:+UnlockDiagnosticVMOptions&quot;, &quot;-XX:+WhiteBoxAPI&quot;,
205       &quot;-cp&quot;, System.getProperty(&quot;java.class.path&quot;),
206     };
207 
<span class="line-removed">208     if (useTestDotJavaDotOpts) {</span>
<span class="line-removed">209       // System.getProperty(&quot;test.java.opts&quot;) is &#39;&#39; if no options is set,</span>
<span class="line-removed">210       // we need to skip such a result</span>
<span class="line-removed">211       String[] externalVMOpts = new String[0];</span>
<span class="line-removed">212       if (System.getProperty(&quot;test.java.opts&quot;) != null &amp;&amp; System.getProperty(&quot;test.java.opts&quot;).length() != 0) {</span>
<span class="line-removed">213         externalVMOpts = System.getProperty(&quot;test.java.opts&quot;).split(&quot; &quot;);</span>
<span class="line-removed">214       }</span>
<span class="line-removed">215       finalargs.addAll(Arrays.asList(externalVMOpts));</span>
<span class="line-removed">216     }</span>
<span class="line-removed">217 </span>
218     finalargs.addAll(Arrays.asList(vmargs));
219     finalargs.addAll(Arrays.asList(whiteboxOpts));
220     finalargs.add(classname);
221     finalargs.addAll(Arrays.asList(arguments));
222 
<span class="line-modified">223     ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs.toArray(new String[0]));</span>
224     OutputAnalyzer output = new OutputAnalyzer(pb.start());
225     output.shouldHaveExitValue(0);
226 
227     return output;
228   }
229 
230   private static void getMinInitialMaxHeap(String[] args, MinInitialMaxValues val) throws Exception {
<span class="line-modified">231     OutputAnalyzer output = runWhiteBoxTest(args, ErgoArgsPrinter.class.getName(), new String[] {}, false);</span>
232 
233     // the output we watch for has the following format:
234     //
235     // &quot;Minimum heap X Initial heap Y Maximum heap Z Min alignment A Max Alignment B&quot;
236     //
237     // where A, B, X, Y and Z are sizes in bytes.
238     // Unfortunately there is no other way to retrieve the minimum heap size and
239     // the alignments.
240 
241     Matcher m = Pattern.compile(&quot;Minimum heap \\d+ Initial heap \\d+ Maximum heap \\d+ Space alignment \\d+ Heap alignment \\d+&quot;).
242       matcher(output.getStdout());
243     if (!m.find()) {
244       throw new RuntimeException(&quot;Could not find heap size string.&quot;);
245     }
246 
247     String match = m.group();
248 
249     // actual values
250     val.minHeapSize = valueAfter(match, &quot;Minimum heap &quot;);
251     val.initialHeapSize = valueAfter(match, &quot;Initial heap &quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
176 
177   private static void checkValidMinMaxHeapCombinations(String gcflag) throws Exception {
178     expectValid(new String[] { gcflag, &quot;-XX:MinHeapSize=4M&quot;, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-version&quot; });
179     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-XX:MinHeapSize=4M&quot;, &quot;-version&quot; });
180     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:MinHeapSize=4M&quot;, &quot;-version&quot; });
181     // a value of &quot;0&quot; for min heap size means auto-detect
182     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:MinHeapSize=0M&quot;, &quot;-version&quot; });
183   }
184 
185   private static long valueAfter(String source, String match) {
186     int start = source.indexOf(match) + match.length();
187     String tail = source.substring(start).split(&quot; &quot;)[0];
188     return Long.parseLong(tail);
189   }
190 
191   /**
192    * Executes a new VM process with the given class and parameters.
193    * @param vmargs Arguments to the VM to run
194    * @param classname Name of the class to run
195    * @param arguments Arguments to the class

196    * @return The OutputAnalyzer with the results for the invocation.
197    */
<span class="line-modified">198   public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments) throws Exception {</span>
199     ArrayList&lt;String&gt; finalargs = new ArrayList&lt;String&gt;();
200 
201     String[] whiteboxOpts = new String[] {
202       &quot;-Xbootclasspath/a:.&quot;,
203       &quot;-XX:+UnlockDiagnosticVMOptions&quot;, &quot;-XX:+WhiteBoxAPI&quot;,
204       &quot;-cp&quot;, System.getProperty(&quot;java.class.path&quot;),
205     };
206 










207     finalargs.addAll(Arrays.asList(vmargs));
208     finalargs.addAll(Arrays.asList(whiteboxOpts));
209     finalargs.add(classname);
210     finalargs.addAll(Arrays.asList(arguments));
211 
<span class="line-modified">212     ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs.toArray(String[]::new));</span>
213     OutputAnalyzer output = new OutputAnalyzer(pb.start());
214     output.shouldHaveExitValue(0);
215 
216     return output;
217   }
218 
219   private static void getMinInitialMaxHeap(String[] args, MinInitialMaxValues val) throws Exception {
<span class="line-modified">220     OutputAnalyzer output = runWhiteBoxTest(args, ErgoArgsPrinter.class.getName(), new String[] {});</span>
221 
222     // the output we watch for has the following format:
223     //
224     // &quot;Minimum heap X Initial heap Y Maximum heap Z Min alignment A Max Alignment B&quot;
225     //
226     // where A, B, X, Y and Z are sizes in bytes.
227     // Unfortunately there is no other way to retrieve the minimum heap size and
228     // the alignments.
229 
230     Matcher m = Pattern.compile(&quot;Minimum heap \\d+ Initial heap \\d+ Maximum heap \\d+ Space alignment \\d+ Heap alignment \\d+&quot;).
231       matcher(output.getStdout());
232     if (!m.find()) {
233       throw new RuntimeException(&quot;Could not find heap size string.&quot;);
234     }
235 
236     String match = m.group();
237 
238     // actual values
239     val.minHeapSize = valueAfter(match, &quot;Minimum heap &quot;);
240     val.initialHeapSize = valueAfter(match, &quot;Initial heap &quot;);
</pre>
</td>
</tr>
</table>
<center><a href="TestInitialTenuringThreshold.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestMaxMinHeapFreeRatioFlags.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
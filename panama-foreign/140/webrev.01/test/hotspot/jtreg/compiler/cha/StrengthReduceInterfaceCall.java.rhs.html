<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/cha/StrengthReduceInterfaceCall.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @requires !vm.graal.enabled
 27  * @modules java.base/jdk.internal.org.objectweb.asm
 28  *          java.base/jdk.internal.misc
 29  *          java.base/jdk.internal.vm.annotation
 30  * @library /test/lib /
 31  * @build sun.hotspot.WhiteBox
 32  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
<a name="2" id="anc2"></a>
 33  *
 34  * @run main/othervm -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
 35  *                   -XX:+PrintCompilation -XX:+PrintInlining -XX:+TraceDependencies -verbose:class -XX:CompileCommand=quiet
 36  *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=compileonly,*::m -XX:CompileCommand=dontinline,*::test
 37  *                   -Xbatch -XX:+WhiteBoxAPI -Xmixed
 38  *                   -XX:-TieredCompilation
 39  *                      compiler.cha.StrengthReduceInterfaceCall
 40  *
 41  * @run main/othervm -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
 42  *                   -XX:+PrintCompilation -XX:+PrintInlining -XX:+TraceDependencies -verbose:class -XX:CompileCommand=quiet
 43  *                   -XX:CompileCommand=compileonly,*::test -XX:CompileCommand=compileonly,*::m -XX:CompileCommand=dontinline,*::test
 44  *                   -Xbatch -XX:+WhiteBoxAPI -Xmixed
 45  *                   -XX:+TieredCompilation -XX:TieredStopAtLevel=1
 46  *                      compiler.cha.StrengthReduceInterfaceCall
 47  */
 48 package compiler.cha;
 49 
 50 import jdk.internal.misc.Unsafe;
 51 import jdk.internal.org.objectweb.asm.ClassWriter;
 52 import jdk.internal.org.objectweb.asm.MethodVisitor;
 53 import jdk.internal.vm.annotation.DontInline;
 54 import sun.hotspot.WhiteBox;
 55 import sun.hotspot.code.NMethod;
 56 
 57 import java.io.IOException;
 58 import java.lang.annotation.Retention;
 59 import java.lang.annotation.RetentionPolicy;
 60 import java.lang.invoke.MethodHandle;
 61 import java.lang.invoke.MethodHandles;
 62 import java.lang.reflect.Method;
 63 import java.util.HashMap;
 64 import java.util.concurrent.Callable;
 65 
 66 import static jdk.test.lib.Asserts.*;
 67 import static jdk.internal.org.objectweb.asm.ClassWriter.*;
 68 import static jdk.internal.org.objectweb.asm.Opcodes.*;
 69 
 70 public class StrengthReduceInterfaceCall {
 71     public static void main(String[] args) {
 72         run(ObjectToString.class);
 73         run(ObjectHashCode.class);
 74         run(TwoLevelHierarchyLinear.class);
 75         run(ThreeLevelHierarchyLinear.class);
 76         run(ThreeLevelHierarchyAbstractVsDefault.class);
 77         run(ThreeLevelDefaultHierarchy.class);
 78         run(ThreeLevelDefaultHierarchy1.class);
 79     }
 80 
 81     public static class ObjectToString extends ATest&lt;ObjectToString.I&gt; {
 82         public ObjectToString() { super(I.class, C.class); }
 83 
 84         interface J           { String toString(); }
 85         interface I extends J {}
 86 
 87         static class C implements I {}
 88 
 89         interface K1 extends I {}
 90         interface K2 extends I { String toString(); } // K2.tS() ABSTRACT
 91         // interface K3 extends I { default String toString() { return &quot;K3&quot;; } // K2.tS() DEFAULT
 92 
 93         static class D implements I { public String toString() { return &quot;D&quot;; }}
 94 
 95         static class DJ1 implements J {}
 96         static class DJ2 implements J { public String toString() { return &quot;DJ2&quot;; }}
 97 
 98         @Override
 99         public Object test(I i) { return ObjectToStringHelper.test(i); /* invokeinterface I.toString() */ }
100 
101         @TestCase
102         public void testMono() {
103             // 0. Trigger compilation of a monomorphic call site
104             compile(monomophic()); // C1 &lt;: C &lt;: intf I &lt;: intf J &lt;: Object.toString()
105             assertCompiled();
106 
107             // Dependency: none
108 
109             call(new C() { public String toString() { return &quot;Cn&quot;; }}); // Cn.tS &lt;: C.tS &lt;: intf I
110             assertCompiled();
111         }
112 
113         @TestCase
114         public void testBi() {
115             // 0. Trigger compilation of a bimorphic call site
116             compile(bimorphic()); // C1 &lt;: C &lt;: intf I &lt;: intf J &lt;: Object.toString()
117             assertCompiled();
118 
119             // Dependency: none
120 
121             call(new C() { public String toString() { return &quot;Cn&quot;; }}); // Cn.tS &lt;: C.tS &lt;: intf I
122             assertCompiled();
123         }
124 
125         @TestCase
126         public void testMega() {
127             // 0. Trigger compilation of a megamorphic call site
128             compile(megamorphic()); // C1,C2,C3 &lt;: C &lt;: intf I &lt;: intf J &lt;: Object.toString()
129             assertCompiled();
130 
131             // Dependency: none
132             // compiler.cha.StrengthReduceInterfaceCall$ObjectToString::test (5 bytes)
133             //     @ 1   compiler.cha.StrengthReduceInterfaceCall$ObjectToStringHelper::test (7 bytes)   inline (hot)
134             //       @ 1   java.lang.Object::toString (36 bytes)   virtual call
135 
136             // No dependency - no invalidation
137             repeat(100, () -&gt; call(new C(){})); // Cn &lt;: C &lt;: intf I
138             assertCompiled();
139 
140             initialize(K1.class,   // intf  K1             &lt;: intf I &lt;: intf J
141                        K2.class,   // intf  K2.tS ABSTRACT &lt;: intf I &lt;: intf J
142                        DJ1.class,  //      DJ1                       &lt;: intf J
143                        DJ2.class); //      DJ2.tS                    &lt;: intf J
144             assertCompiled();
145 
146             initialize(D.class); // D.tS &lt;: intf I &lt;: intf J
147             assertCompiled();
148 
149             call(new C() { public String toString() { return &quot;Cn&quot;; }}); // Cn.tS &lt;: C.tS &lt;: intf I
150             assertCompiled();
151         }
152 
153         @Override
154         public void checkInvalidReceiver() {
155             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
156                 I o = (I) unsafeCastMH(I.class).invokeExact(new Object()); // unrelated
157                 test(o);
158             });
159             assertCompiled();
160 
161             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
162                 I j = (I) unsafeCastMH(I.class).invokeExact((Object)new J() {}); // super interface
163                 test(j);
164             });
165             assertCompiled();
166         }
167     }
168 
169     public static class ObjectHashCode extends ATest&lt;ObjectHashCode.I&gt; {
170         public ObjectHashCode() { super(I.class, C.class); }
171 
172         interface J {}
173         interface I extends J {}
174 
175         static class C implements I {}
176 
177         interface K1 extends I {}
178         interface K2 extends I { int hashCode(); } // K2.hC() ABSTRACT
179         // interface K3 extends I { default int hashCode() { return CORRECT; } // K2.hC() DEFAULT
180 
181         static class D implements I { public int hashCode() { return super.hashCode(); }}
182 
183         static class DJ1 implements J {}
184         static class DJ2 implements J { public int hashCode() { return super.hashCode(); }}
185 
186         @Override
187         public Object test(I i) {
188             return ObjectHashCodeHelper.test(i); /* invokeinterface I.hashCode() */
189         }
190 
191         @TestCase
192         public void testMono() {
193             // 0. Trigger compilation of a monomorphic call site
194             compile(monomophic()); // C1 &lt;: C &lt;: intf I &lt;: intf J &lt;: Object.hashCode()
195             assertCompiled();
196 
197             // Dependency: none
198 
199             call(new C() { public int hashCode() { return super.hashCode(); }}); // Cn.hC &lt;: C.hC &lt;: intf I
200             assertCompiled();
201         }
202 
203         @TestCase
204         public void testBi() {
205             // 0. Trigger compilation of a bimorphic call site
206             compile(bimorphic()); // C1 &lt;: C &lt;: intf I &lt;: intf J &lt;: Object.toString()
207             assertCompiled();
208 
209             // Dependency: none
210 
211             call(new C() { public int hashCode() { return super.hashCode(); }}); // Cn.hC &lt;: C.hC &lt;: intf I
212             assertCompiled();
213         }
214 
215         @TestCase
216         public void testMega() {
217             // 0. Trigger compilation of a megamorphic call site
218             compile(megamorphic()); // C1,C2,C3 &lt;: C &lt;: intf I &lt;: intf J &lt;: Object.hashCode()
219             assertCompiled();
220 
221             // Dependency: none
222 
223             // No dependency - no invalidation
224             repeat(100, () -&gt; call(new C(){})); // Cn &lt;: C &lt;: intf I
225             assertCompiled();
226 
227             initialize(K1.class,   // intf  K1             &lt;: intf I &lt;: intf J
228                        K2.class,   // intf  K2.hC ABSTRACT &lt;: intf I &lt;: intf J
229                        DJ1.class,  //      DJ1                       &lt;: intf J
230                        DJ2.class); //      DJ2.hC                    &lt;: intf J
231             assertCompiled();
232 
233             initialize(D.class); // D.hC &lt;: intf I &lt;: intf J
234             assertCompiled();
235 
236             call(new C() { public int hashCode() { return super.hashCode(); }}); // Cn.hC &lt;: C.hC &lt;: intf I
237             assertCompiled();
238         }
239 
240         @Override
241         public void checkInvalidReceiver() {
242             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
243                 I o = (I) unsafeCastMH(I.class).invokeExact(new Object()); // unrelated
244                 test(o);
245             });
246             assertCompiled();
247 
248             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
249                 I j = (I) unsafeCastMH(I.class).invokeExact((Object)new J() {}); // super interface
250                 test(j);
251             });
252             assertCompiled();
253         }
254     }
255 
256     public static class TwoLevelHierarchyLinear extends ATest&lt;TwoLevelHierarchyLinear.I&gt; {
257         public TwoLevelHierarchyLinear() { super(I.class, C.class); }
258 
259         interface J { default Object m() { return WRONG; } }
260 
261         interface I extends J { Object m(); }
262         static class C implements I { public Object m() { return CORRECT; }}
263 
264         interface K1 extends I {}
265         interface K2 extends I { Object m(); }
266         interface K3 extends I { default Object m() { return WRONG; }}
267 
268         static class D implements I { public Object m() { return WRONG;   }}
269 
270         static class DJ1 implements J {}
271         static class DJ2 implements J { public Object m() { return WRONG; }}
272 
273         @DontInline
274         public Object test(I i) {
275             return i.m();
276         }
277 
278         @TestCase
279         public void testMega1() {
280             // 0. Trigger compilation of a megamorphic call site
281             compile(megamorphic()); // C1,C2,C3 &lt;: C.m &lt;: intf I.m ABSTRACT &lt;: intf J.m ABSTRACT
282             assertCompiled();
283 
284             // Dependency: type = unique_concrete_method, context = I, method = C.m
285 
286             checkInvalidReceiver(); // ensure proper type check is preserved
287 
288             // 1. No deoptimization/invalidation on not-yet-seen receiver
289             repeat(100, () -&gt; call(new C(){})); // Cn &lt;: C.m &lt;: intf I.m ABSTRACT &lt;: intf J.m DEFAULT
290             assertCompiled();
291 
292             // 2. No dependency invalidation on class loading of unrelated classes: different context
293             initialize(K1.class,   // intf  K1            &lt;: intf I.m ABSTRACT &lt;: intf J.m DEFAULT
294                        K2.class,   // intf  K2.m ABSTRACT &lt;: intf I.m ABSTRACT &lt;: intf J.m DEFAULT
295                        DJ1.class,  //      DJ1                                 &lt;: intf J.m DEFAULT
296                        DJ2.class); //      DJ2.m                               &lt;: intf J.m DEFAULT
297             assertCompiled();
298 
299             // 3. Dependency invalidation on D &lt;: I
300             initialize(D.class); // D.m &lt;: intf I.m ABSTRACT &lt;: intf J.m DEFAULT
301             assertNotCompiled();
302 
303             // 4. Recompilation: no inlining, no dependencies
304             compile(megamorphic());
305             call(new C() { public Object m() { return CORRECT; }}); // Cn.m &lt;: C.m &lt;: intf I.m ABSTRACT &lt;: intf J.m DEFAULT
306             assertCompiled();
307 
308             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
309         }
310 
311         @TestCase
312         public void testMega2() {
313             // 0. Trigger compilation of a megamorphic call site
314             compile(megamorphic()); // C1,C2,C3 &lt;: C.m &lt;: intf I.m ABSTRACT &lt;: intf J.m DEFAULT
315             assertCompiled();
316 
317             // Dependency: type = unique_concrete_method, context = I, method = C.m
318 
319             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
320 
321             // 1. Dependency invalidation
322             initialize(K3.class); // intf K3.m DEFAULT &lt;: intf I.m ABSTRACT &lt;: intf J.m DEFAULT
323             assertNotCompiled();
324 
325             // 2. Recompilation: still inlines
326             // FIXME: no default method support in CHA yet
327             compile(megamorphic());
328             call(new K3() { public Object m() { return CORRECT; }}); // K3n.m &lt;: intf K3.m DEFAULT &lt;: intf I.m ABSTRACT &lt;: intf J.m ABSTRACT
329             assertNotCompiled();
330 
331             // 3. Recompilation: no inlining, no dependencies
332             compile(megamorphic());
333             call(new K3() { public Object m() { return CORRECT; }}); // Kn.m &lt;: intf K3.m DEFAULT  &lt;: intf I.m ABSTRACT &lt;: intf J.m DEFAULT
334             assertCompiled();
335 
336             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
337         }
338 
339         @Override
340         public void checkInvalidReceiver() {
341             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
342                 I o = (I) unsafeCastMH(I.class).invokeExact(new Object()); // unrelated
343                 test(o);
344             });
345             assertCompiled();
346 
347             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
348                 I j = (I) unsafeCastMH(I.class).invokeExact((Object)new J() {}); // super interface
349                 test(j);
350             });
351             assertCompiled();
352         }
353     }
354 
355     public static class ThreeLevelHierarchyLinear extends ATest&lt;ThreeLevelHierarchyLinear.I&gt; {
356         public ThreeLevelHierarchyLinear() { super(I.class, C.class); }
357 
358         interface J           { Object m(); }
359         interface I extends J {}
360 
361         interface K1 extends I {}
362         interface K2 extends I { Object m(); }
363         interface K3 extends I { default Object m() { return WRONG; }}
364 
365         static class C  implements I { public Object m() { return CORRECT; }}
366 
367         static class DI implements I { public Object m() { return WRONG;   }}
368         static class DJ implements J { public Object m() { return WRONG;   }}
369 
370         @DontInline
371         public Object test(I i) {
372             return i.m(); // I &lt;: J.m ABSTRACT
373         }
374 
375         @TestCase
376         public void testMega1() {
377             // 0. Trigger compilation of a megamorphic call site
378             compile(megamorphic()); // C1,C2,C3 &lt;: C.m &lt;: intf I &lt;: intf J.m ABSTRACT
379             assertCompiled();
380 
381             // Dependency: type = unique_concrete_method, context = I, method = C.m
382 
383             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
384 
385             // 1. No deoptimization/invalidation on not-yet-seen receiver
386             repeat(100, () -&gt; call(new C(){})); // Cn &lt;: C.m &lt;: intf I
387             assertCompiled(); // No deopt on not-yet-seen receiver
388 
389             // 2. No dependency invalidation: different context
390             initialize(DJ.class,  //      DJ.m                    &lt;: intf J.m ABSTRACT
391                        K1.class,  // intf K1            &lt;: intf I &lt;: intf J.m ABSTRACT
392                        K2.class); // intf K2.m ABSTRACT &lt;: intf I &lt;: intf J.m ABSTRACT
393             assertCompiled();
394 
395             // 3. Dependency invalidation: DI.m &lt;: I
396             initialize(DI.class); //      DI.m          &lt;: intf I &lt;: intf J.m ABSTRACT
397             assertNotCompiled();
398 
399             // 4. Recompilation w/o a dependency
400             compile(megamorphic());
401             call(new C() { public Object m() { return CORRECT; }}); // Cn.m &lt;: C.m &lt;: intf I &lt;: intf J.m ABSTRACT
402             assertCompiled(); // no dependency
403 
404             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
405         }
406 
407         @TestCase
408         public void testMega2() {
409             compile(megamorphic()); // C1,C2,C3 &lt;: C.m &lt;: intf I &lt;: intf J.m ABSTRACT
410             assertCompiled();
411 
412             // Dependency: type = unique_concrete_method, context = I, method = C.m
413 
414             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
415 
416             // Dependency invalidation
417             initialize(K3.class); // intf K3.m DEFAULT &lt;: intf I;
418             assertNotCompiled(); // FIXME: default methods in sub-interfaces shouldn&#39;t be taken into account by CHA
419 
420             // Recompilation with a dependency
421             compile(megamorphic());
422             assertCompiled();
423 
424             // Dependency: type = unique_concrete_method, context = I, method = C.m
425 
426             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
427 
428             call(new K3() { public Object m() { return CORRECT; }}); // Kn.m &lt;: K3.m DEFAULT &lt;: intf I &lt;: intf J.m ABSTRACT
429             assertNotCompiled();
430 
431             // Recompilation w/o a dependency
432             compile(megamorphic());
433             // Dependency: none
434             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
435             call(new C() { public Object m() { return CORRECT; }}); // Cn.m &lt;: C.m &lt;: intf I &lt;: intf J.m ABSTRACT
436             assertCompiled();
437         }
438 
439         @Override
440         public void checkInvalidReceiver() {
441             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
442                 I o = (I) unsafeCastMH(I.class).invokeExact(new Object()); // unrelated
443                 test(o);
444             });
445             assertCompiled();
446 
447             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
448                 I j = (I) unsafeCastMH(I.class).invokeExact((Object)new J() { public Object m() { return WRONG; }}); // super interface
449                 test(j);
450             });
451             assertCompiled();
452         }
453     }
454 
455     public static class ThreeLevelHierarchyAbstractVsDefault extends ATest&lt;ThreeLevelHierarchyAbstractVsDefault.I&gt; {
456         public ThreeLevelHierarchyAbstractVsDefault() { super(I.class, C.class); }
457 
458         interface J1                { default Object m() { return WRONG; } } // intf J1.m DEFAULT
459         interface J2 extends J1     { Object m(); }                          // intf J2.m ABSTRACT &lt;: intf J1
460         interface I  extends J1, J2 {}                                       // intf  I.m OVERPASS &lt;: intf J1,J2
461 
462         static class C  implements I { public Object m() { return CORRECT; }}
463 
464         @DontInline
465         public Object test(I i) {
466             return i.m(); // intf I.m OVERPASS
467         }
468 
469         static class DI implements I { public Object m() { return WRONG;   }}
470 
471         static class DJ11 implements J1 {}
472         static class DJ12 implements J1 { public Object m() { return WRONG; }}
473 
474         static class DJ2 implements J2 { public Object m() { return WRONG;   }}
475 
476         interface K11 extends J1 {}
477         interface K12 extends J1 { Object m(); }
478         interface K13 extends J1 { default Object m() { return WRONG; }}
479         interface K21 extends J2 {}
480         interface K22 extends J2 { Object m(); }
481         interface K23 extends J2 { default Object m() { return WRONG; }}
482 
483 
484         public void testMega1() {
485             // 0. Trigger compilation of megamorphic call site
486             compile(megamorphic()); // C1,C2,C3 &lt;: C.m &lt;: intf I.m OVERPASS &lt;: intf J2.m ABSTRACT &lt;: intf J1.m DEFAULT
487             assertCompiled();
488 
489             // Dependency: type = unique_concrete_method, context = I, method = C.m
490 
491             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
492 
493             // 1. No deopt/invalidation on not-yet-seen receiver
494             repeat(100, () -&gt; call(new C(){})); // Cn &lt;: C.m &lt;: intf I.m OVERPASS &lt;: intf J2.m ABSTRACT &lt;: intf J1.m DEFAULT
495             assertCompiled();
496 
497             // 2. No dependency invalidation: different context
498             initialize(K11.class, K12.class, K13.class,
499                        K21.class, K22.class, K23.class);
500 
501             // 3. Dependency invalidation: Cn.m &lt;: C &lt;: I
502             call(new C() { public Object m() { return CORRECT; }}); // Cn.m &lt;: C.m &lt;: intf I.m OVERPASS &lt;: intf J2.m ABSTRACT &lt;: intf J1.m DEFAULT
503             assertNotCompiled();
504 
505             // 4. Recompilation w/o a dependency
506             compile(megamorphic());
507             call(new C() { public Object m() { return CORRECT; }});
508             assertCompiled(); // no inlining
509 
510             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
511         }
512 
513         public void testMega2() {
514             // 0. Trigger compilation of a megamorphic call site
515             compile(megamorphic());
516             assertCompiled();
517 
518             // Dependency: type = unique_concrete_method, context = I, method = C.m
519 
520             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
521 
522             // 1. No dependency invalidation: different context
523             initialize(DJ11.class,
524                        DJ12.class,
525                        DJ2.class);
526             assertCompiled();
527 
528             // 2. Dependency invalidation: DI.m &lt;: I
529             initialize(DI.class);
530             assertNotCompiled();
531 
532             // 3. Recompilation w/o a dependency
533             compile(megamorphic());
534             call(new C() { public Object m() { return CORRECT; }});
535             assertCompiled(); // no inlining
536 
537             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
538         }
539 
540         @Override
541         public void checkInvalidReceiver() {
542             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
543                 I o = (I) unsafeCastMH(I.class).invokeExact(new Object()); // unrelated
544                 test(o);
545             });
546             assertCompiled();
547 
548             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
549                 I j = (I) unsafeCastMH(I.class).invokeExact((Object)new J1() {}); // super interface
550                 test(j);
551             });
552             assertCompiled();
553 
554             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
555                 I j = (I) unsafeCastMH(I.class).invokeExact((Object)new J2() { public Object m() { return WRONG; }}); // super interface
556                 test(j);
557             });
558             assertCompiled();
559         }
560     }
561 
562     public static class ThreeLevelDefaultHierarchy extends ATest&lt;ThreeLevelDefaultHierarchy.I&gt; {
563         public ThreeLevelDefaultHierarchy() { super(I.class, C.class); }
564 
565         interface J           { default Object m() { return WRONG; }}
566         interface I extends J {}
567 
568         static class C  implements I { public Object m() { return CORRECT; }}
569 
570         interface K1 extends I {}
571         interface K2 extends I { Object m(); }
572         interface K3 extends I { default Object m() { return WRONG; }}
573 
574         static class DI implements I { public Object m() { return WRONG; }}
575         static class DJ implements J { public Object m() { return WRONG; }}
576 
577         @DontInline
578         public Object test(I i) {
579             return i.m(); // no inlining since J.m is a default method
580         }
581 
582         @TestCase
583         public void testMega() {
584             // 0. Trigger compilation of a megamorphic call site
585             compile(megamorphic()); // C1,C2,C3 &lt;: C.m &lt;: intf I &lt;: intf J.m ABSTRACT
586             assertCompiled();
587 
588             // Dependency: none
589 
590             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
591 
592             // 1. No deoptimization/invalidation on not-yet-seen receiver
593             repeat(100, () -&gt; call(new C() {}));
594             assertCompiled();
595 
596             // 2. No dependency and no inlining
597             initialize(DJ.class,  //      DJ.m                    &lt;: intf J.m ABSTRACT
598                        DI.class,  //      DI.m          &lt;: intf I &lt;: intf J.m ABSTRACT
599                        K1.class,  // intf K1            &lt;: intf I &lt;: intf J.m ABSTRACT
600                        K2.class); // intf K2.m ABSTRACT &lt;: intf I &lt;: intf J.m ABSTRACT
601             assertCompiled();
602         }
603 
604         @Override
605         public void checkInvalidReceiver() {
606             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
607                 I o = (I) unsafeCastMH(I.class).invokeExact(new Object()); // unrelated
608                 test(o);
609             });
610             assertCompiled();
611 
612             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
613                 I j = (I) unsafeCastMH(I.class).invokeExact((Object)new J() {}); // super interface
614                 test(j);
615             });
616             assertCompiled();
617         }
618     }
619 
620     public static class ThreeLevelDefaultHierarchy1 extends ATest&lt;ThreeLevelDefaultHierarchy1.I&gt; {
621         public ThreeLevelDefaultHierarchy1() { super(I.class, C.class); }
622 
623         interface J1                { Object m();}
624         interface J2 extends J1     { default Object m() { return WRONG; }  }
625         interface I  extends J1, J2 {}
626 
627         static class C  implements I { public Object m() { return CORRECT; }}
628 
629         interface K1 extends I {}
630         interface K2 extends I { Object m(); }
631         interface K3 extends I { default Object m() { return WRONG; }}
632 
633         static class DI implements I { public Object m() { return WRONG; }}
634         static class DJ1 implements J1 { public Object m() { return WRONG; }}
635         static class DJ2 implements J2 { public Object m() { return WRONG; }}
636 
637         @DontInline
638         public Object test(I i) {
639             return i.m(); // no inlining since J.m is a default method
640         }
641 
642         @TestCase
643         public void testMega() {
644             // 0. Trigger compilation of a megamorphic call site
645             compile(megamorphic());
646             assertCompiled();
647 
648             // Dependency: none
649 
650             checkInvalidReceiver(); // ensure proper type check on receiver is preserved
651 
652             // 1. No deoptimization/invalidation on not-yet-seen receiver
653             repeat(100, () -&gt; call(new C() {}));
654             assertCompiled();
655 
656             // 2. No dependency, no inlining
657             // CHA doesn&#39;t support default methods yet.
658             initialize(DJ1.class,
659                        DJ2.class,
660                        DI.class,
661                        K1.class,
662                        K2.class,
663                        K3.class);
664             assertCompiled();
665         }
666 
667         @Override
668         public void checkInvalidReceiver() {
669             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
670                 I o = (I) unsafeCastMH(I.class).invokeExact(new Object()); // unrelated
671                 test(o);
672             });
673             assertCompiled();
674 
675             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
676                 I j = (I) unsafeCastMH(I.class).invokeExact((Object)new J1() { public Object m() { return WRONG; } }); // super interface
677                 test(j);
678             });
679             assertCompiled();
680 
681             shouldThrow(IncompatibleClassChangeError.class, () -&gt; {
682                 I j = (I) unsafeCastMH(I.class).invokeExact((Object)new J2() {}); // super interface
683                 test(j);
684             });
685             assertCompiled();
686         }
687     }
688 
689     /* =========================================================== */
690 
691     interface Action {
692         int run();
693     }
694 
695     public static final Unsafe U = Unsafe.getUnsafe();
696 
697     interface Test&lt;T&gt; {
698         void call(T o);
699         T receiver(int id);
700 
701         default Runnable monomophic() {
702             return () -&gt; {
703                 call(receiver(0)); // 100%
704             };
705         }
706 
707         default Runnable bimorphic() {
708             return () -&gt; {
709                 call(receiver(0)); // 50%
710                 call(receiver(1)); // 50%
711             };
712         }
713 
714         default Runnable polymorphic() {
715             return () -&gt; {
716                 for (int i = 0; i &lt; 23; i++) {
717                     call(receiver(0)); // 92%
718                 }
719                 call(receiver(1)); // 4%
720                 call(receiver(2)); // 4%
721             };
722         }
723 
724         default Runnable megamorphic() {
725             return () -&gt; {
726                 call(receiver(0)); // 33%
727                 call(receiver(1)); // 33%
728                 call(receiver(2)); // 33%
729             };
730         }
731 
732         default void initialize(Class&lt;?&gt;... cs) {
733             for (Class&lt;?&gt; c : cs) {
734                 U.ensureClassInitialized(c);
735             }
736         }
737 
738         default void repeat(int cnt, Runnable r) {
739             for (int i = 0; i &lt; cnt; i++) {
740                 r.run();
741             }
742         }
743     }
744 
745     public static abstract class ATest&lt;T&gt; implements Test&lt;T&gt; {
746         public static final WhiteBox WB = WhiteBox.getWhiteBox();
747 
748         public static final Object CORRECT = new Object();
749         public static final Object WRONG   = new Object();
750 
751         final Method TEST;
752         private final Class&lt;T&gt; declared;
753         private final Class&lt;?&gt; receiver;
754 
755         private final HashMap&lt;Integer, T&gt; receivers = new HashMap&lt;&gt;();
756 
757         public ATest(Class&lt;T&gt; declared, Class&lt;?&gt; receiver) {
758             this.declared = declared;
759             this.receiver = receiver;
760             TEST = compute(() -&gt; this.getClass().getDeclaredMethod(&quot;test&quot;, declared));
761         }
762 
763         @DontInline
764         public abstract Object test(T i);
765 
766         public abstract void checkInvalidReceiver();
767 
768         public T receiver(int id) {
769             return receivers.computeIfAbsent(id, (i -&gt; {
770                 try {
771                     MyClassLoader cl = (MyClassLoader) receiver.getClassLoader();
772                     Class&lt;?&gt; sub = cl.subclass(receiver, i);
773                     return (T)sub.getDeclaredConstructor().newInstance();
774                 } catch (Exception e) {
775                     throw new Error(e);
776                 }
777             }));
778         }
779 
780 
781         public void compile(Runnable r) {
782             while (!WB.isMethodCompiled(TEST)) {
783                 for (int i = 0; i &lt; 100; i++) {
784                     r.run();
785                 }
786             }
787             assertCompiled(); // record nmethod info
788         }
789 
790         private NMethod prevNM = null;
791 
792         public void assertNotCompiled() {
793             NMethod curNM = NMethod.get(TEST, false);
794             assertTrue(prevNM != null); // was previously compiled
795             assertTrue(curNM == null || prevNM.compile_id != curNM.compile_id); // either no nmethod present or recompiled
796             prevNM = curNM; // update nmethod info
797         }
798 
799         public void assertCompiled() {
800             NMethod curNM = NMethod.get(TEST, false);
801             assertTrue(curNM != null); // nmethod is present
802             assertTrue(prevNM == null || prevNM.compile_id == curNM.compile_id); // no recompilations if nmethod present
803             prevNM = curNM; // update nmethod info
804         }
805 
806         @Override
807         public void call(T i) {
808             assertTrue(test(i) != WRONG);
809         }
810     }
811 
812     @Retention(value = RetentionPolicy.RUNTIME)
813     public @interface TestCase {}
814 
815     static void run(Class&lt;?&gt; test) {
816         try {
817             for (Method m : test.getDeclaredMethods()) {
818                 if (m.isAnnotationPresent(TestCase.class)) {
819                     System.out.println(m.toString());
820                     ClassLoader cl = new MyClassLoader(test);
821                     Class&lt;?&gt; c = cl.loadClass(test.getName());
822                     c.getMethod(m.getName()).invoke(c.getDeclaredConstructor().newInstance());
823                 }
824             }
825         } catch (Exception e) {
826             throw new Error(e);
827         }
828     }
829 
830     static class ObjectToStringHelper {
831         static Object test(Object o) {
832             throw new Error(&quot;not used&quot;);
833         }
834     }
835     static class ObjectHashCodeHelper {
836         static int test(Object o) {
837         throw new Error(&quot;not used&quot;);
838     }
839     }
840 
841     static final class MyClassLoader extends ClassLoader {
842         private final Class&lt;?&gt; test;
843 
844         MyClassLoader(Class&lt;?&gt; test) {
845             this.test = test;
846         }
847 
848         static String intl(String s) {
849             return s.replace(&#39;.&#39;, &#39;/&#39;);
850         }
851 
852         Class&lt;?&gt; subclass(Class&lt;?&gt; c, int id) {
853             String name = c.getName() + id;
854             Class&lt;?&gt; sub = findLoadedClass(name);
855             if (sub == null) {
856                 ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);
857                 cw.visit(52, ACC_PUBLIC | ACC_SUPER, intl(name), null, intl(c.getName()), null);
858 
859                 { // Default constructor: &lt;init&gt;()V
860                     MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
861                     mv.visitCode();
862                     mv.visitVarInsn(ALOAD, 0);
863                     mv.visitMethodInsn(INVOKESPECIAL, intl(c.getName()), &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
864                     mv.visitInsn(RETURN);
865                     mv.visitMaxs(0, 0);
866                     mv.visitEnd();
867                 }
868 
869                 byte[] classFile = cw.toByteArray();
870                 return defineClass(name, classFile, 0, classFile.length);
871             }
872             return sub;
873         }
874 
875         protected Class&lt;?&gt; loadClass(String name, boolean resolve)
876                 throws ClassNotFoundException
877         {
878             // First, check if the class has already been loaded
879             Class&lt;?&gt; c = findLoadedClass(name);
880             if (c == null) {
881                 try {
882                     c = getParent().loadClass(name);
883                     if (name.endsWith(&quot;ObjectToStringHelper&quot;)) {
884                         ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);
885                         cw.visit(52, ACC_PUBLIC | ACC_SUPER, intl(name), null, &quot;java/lang/Object&quot;, null);
886 
887                         {
888                             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, &quot;test&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;, null, null);
889                             mv.visitCode();
890                             mv.visitVarInsn(ALOAD, 0);
891                             mv.visitMethodInsn(INVOKEINTERFACE, intl(test.getName()) + &quot;$I&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, true);
892                             mv.visitInsn(ARETURN);
893                             mv.visitMaxs(0, 0);
894                             mv.visitEnd();
895                         }
896 
897                         byte[] classFile = cw.toByteArray();
898                         return defineClass(name, classFile, 0, classFile.length);
899                     } else if (name.endsWith(&quot;ObjectHashCodeHelper&quot;)) {
900                         ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);
901                         cw.visit(52, ACC_PUBLIC | ACC_SUPER, intl(name), null, &quot;java/lang/Object&quot;, null);
902 
903                         {
904                             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, &quot;test&quot;, &quot;(Ljava/lang/Object;)I&quot;, null, null);
905                             mv.visitCode();
906                             mv.visitVarInsn(ALOAD, 0);
907                             mv.visitMethodInsn(INVOKEINTERFACE, intl(test.getName()) + &quot;$I&quot;, &quot;hashCode&quot;, &quot;()I&quot;, true);
908                             mv.visitInsn(IRETURN);
909                             mv.visitMaxs(0, 0);
910                             mv.visitEnd();
911                         }
912 
913                         byte[] classFile = cw.toByteArray();
914                         return defineClass(name, classFile, 0, classFile.length);
915                     } else if (c == test || name.startsWith(test.getName())) {
916                         try {
917                             String path = name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;;
918                             byte[] classFile = getParent().getResourceAsStream(path).readAllBytes();
919                             return defineClass(name, classFile, 0, classFile.length);
920                         } catch (IOException e) {
921                             throw new Error(e);
922                         }
923                     }
924                 } catch (ClassNotFoundException e) {
925                     // ClassNotFoundException thrown if class not found
926                     // from the non-null parent class loader
927                 }
928 
929                 if (c == null) {
930                     // If still not found, then invoke findClass in order
931                     // to find the class.
932                     c = findClass(name);
933                 }
934             }
935             if (resolve) {
936                 resolveClass(c);
937             }
938             return c;
939         }
940     }
941 
942     public interface RunnableWithException {
943         void run() throws Throwable;
944     }
945 
946     public static void shouldThrow(Class&lt;? extends Throwable&gt; expectedException, RunnableWithException r) {
947         try {
948             r.run();
949             throw new AssertionError(&quot;Exception not thrown: &quot; + expectedException.getName());
950         } catch(Throwable e) {
951             if (expectedException == e.getClass()) {
952                 // success: proper exception is thrown
953             } else {
954                 throw new Error(expectedException.getName() + &quot; is expected&quot;, e);
955             }
956         }
957     }
958 
959     public static MethodHandle unsafeCastMH(Class&lt;?&gt; cls) {
960         try {
961             MethodHandle mh = MethodHandles.identity(Object.class);
962             return MethodHandles.explicitCastArguments(mh, mh.type().changeReturnType(cls));
963         } catch (Throwable e) {
964             throw new Error(e);
965         }
966     }
967 
968     static &lt;T&gt; T compute(Callable&lt;T&gt; c) {
969         try {
970             return c.call();
971         } catch (Exception e) {
972             throw new Error(e);
973         }
974     }
975 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
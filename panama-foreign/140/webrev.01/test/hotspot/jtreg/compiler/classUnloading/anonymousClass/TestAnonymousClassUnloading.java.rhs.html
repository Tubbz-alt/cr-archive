<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/classUnloading/anonymousClass/TestAnonymousClassUnloading.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8054402
 27  * @summary &quot;Tests unloading of anonymous classes.&quot;
 28  * @library /test/lib /
 29  * @modules java.base/jdk.internal.misc
 30  * @build sun.hotspot.WhiteBox
 31  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
<a name="2" id="anc2"></a>
 32  *
 33  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 34  *      -XX:-BackgroundCompilation
 35  *      compiler.classUnloading.anonymousClass.TestAnonymousClassUnloading
 36  */
 37 
 38 package compiler.classUnloading.anonymousClass;
 39 
 40 import jdk.internal.misc.Unsafe;
 41 import sun.hotspot.WhiteBox;
 42 
 43 import java.io.IOException;
 44 import java.lang.reflect.Method;
 45 import java.net.URL;
 46 import java.net.URLConnection;
 47 import compiler.whitebox.CompilerWhiteBoxTest;
 48 
 49 public class TestAnonymousClassUnloading {
 50     private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
 51     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
 52 
 53     /**
 54      * We override hashCode here to be able to access this implementation
 55      * via an Object reference (we cannot cast to TestAnonymousClassUnloading).
 56      */
 57     @Override
 58     public int hashCode() {
 59         return 42;
 60     }
 61 
 62     /**
 63      * Does some work by using the anonymousClass.
 64      * @param anonymousClass Class performing some work (will be unloaded)
 65      */
 66     static private void doWork(Class&lt;?&gt; anonymousClass) throws InstantiationException, IllegalAccessException {
 67         // Create a new instance
 68         Object anon = anonymousClass.newInstance();
 69         // We would like to call a method of anonymousClass here but we cannot cast because the class
 70         // was loaded by a different class loader. One solution would be to use reflection but since
 71         // we want C2 to implement the call as an IC we call Object::hashCode() here which actually
 72         // calls anonymousClass::hashCode(). C2 will then implement this call as an IC.
 73         if (anon.hashCode() != 42) {
 74             new RuntimeException(&quot;Work not done&quot;);
 75         }
 76     }
 77 
 78     /**
 79      * Makes sure that method is compiled by forcing compilation if not yet compiled.
 80      * @param m Method to be checked
 81      */
 82     static private void makeSureIsCompiled(Method m) {
 83         // Make sure background compilation is disabled
 84         if (WHITE_BOX.getBooleanVMFlag(&quot;BackgroundCompilation&quot;)) {
 85             throw new RuntimeException(&quot;Background compilation enabled&quot;);
 86         }
 87 
 88         // Check if already compiled
 89         if (!WHITE_BOX.isMethodCompiled(m)) {
 90             // If not, try to compile it with C2
 91             if(!WHITE_BOX.enqueueMethodForCompilation(m, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION)) {
 92                 // C2 compiler not available, try to compile with C1
 93                 WHITE_BOX.enqueueMethodForCompilation(m, CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE);
 94             }
 95             // Because background compilation is disabled, method should now be compiled
 96             if(!WHITE_BOX.isMethodCompiled(m)) {
 97                 throw new RuntimeException(m + &quot; not compiled&quot;);
 98             }
 99         }
100     }
101 
102     /**
103      * This test creates stale Klass* metadata referenced by a compiled IC.
104      *
105      * The following steps are performed:
106      * (1) An anonymous version of TestAnonymousClassUnloading is loaded by a custom class loader
107      * (2) The method doWork that calls a method of the anonymous class is compiled. The call
108      *     is implemented as an IC referencing Klass* metadata of the anonymous class.
109      * (3) Unloading of the anonymous class is enforced. The IC now references dead metadata.
110      */
111     static public void main(String[] args) throws Exception {
112         // (1) Load an anonymous version of this class using the corresponding Unsafe method
113         String rn = TestAnonymousClassUnloading.class.getSimpleName() + &quot;.class&quot;;
114         URL classUrl = TestAnonymousClassUnloading.class.getResource(rn);
115         URLConnection connection = classUrl.openConnection();
116 
117         int length = connection.getContentLength();
118         byte[] classBytes = connection.getInputStream().readAllBytes();
119         if (length != -1 &amp;&amp; classBytes.length != length) {
120             throw new IOException(&quot;Expected:&quot; + length + &quot;, actual: &quot; + classBytes.length);
121         }
122 
123         Class&lt;?&gt; anonymousClass = UNSAFE.defineAnonymousClass(TestAnonymousClassUnloading.class, classBytes, null);
124 
125         // (2) Make sure all paths of doWork are profiled and compiled
126         for (int i = 0; i &lt; 100000; ++i) {
127             doWork(anonymousClass);
128         }
129 
130         // Make sure doWork is compiled now
131         Method doWork = TestAnonymousClassUnloading.class.getDeclaredMethod(&quot;doWork&quot;, Class.class);
132         makeSureIsCompiled(doWork);
133 
134         // (3) Throw away reference to anonymousClass to allow unloading
135         anonymousClass = null;
136 
137         // Force garbage collection to trigger unloading of anonymousClass
138         // Dead metadata reference to anonymousClass triggers JDK-8054402
139         WHITE_BOX.fullGC();
140     }
141 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
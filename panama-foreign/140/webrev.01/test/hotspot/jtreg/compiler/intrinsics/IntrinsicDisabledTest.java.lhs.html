<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/intrinsics/IntrinsicDisabledTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8138651
 27  *
 28  * @requires !vm.graal.enabled
 29  * @modules java.base/jdk.internal.misc
 30  * @library /test/lib /
 31  *
 32  * @build sun.hotspot.WhiteBox
 33  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
<a name="2" id="anc2"></a><span class="line-removed"> 34  *                                sun.hotspot.WhiteBox$WhiteBoxPermission</span>
 35  * @run main/othervm -Xbootclasspath/a:.
 36  *                   -XX:+UnlockDiagnosticVMOptions
 37  *                   -XX:+WhiteBoxAPI
 38  *                   -XX:DisableIntrinsic=_putCharVolatile,_putInt
 39  *                   -XX:DisableIntrinsic=_putIntVolatile
 40  *                   -XX:CompileCommand=option,jdk.internal.misc.Unsafe::putChar,ccstrlist,DisableIntrinsic,_getCharVolatile,_getInt
 41  *                   -XX:CompileCommand=option,jdk.internal.misc.Unsafe::putCharVolatile,ccstrlist,DisableIntrinsic,_getIntVolatile
 42  *                   compiler.intrinsics.IntrinsicDisabledTest
 43  */
 44 
 45 package compiler.intrinsics;
 46 
 47 import jdk.test.lib.Platform;
 48 import sun.hotspot.WhiteBox;
 49 import compiler.whitebox.CompilerWhiteBoxTest;
 50 
 51 import java.lang.reflect.Executable;
 52 import java.util.Objects;
 53 
 54 public class IntrinsicDisabledTest {
 55 
 56     private static final WhiteBox wb = WhiteBox.getWhiteBox();
 57 
 58     /* Determine if tiered compilation is enabled. */
 59     private static final boolean TIERED_COMPILATION = wb.getBooleanVMFlag(&quot;TieredCompilation&quot;);
 60 
 61     private static final int TIERED_STOP_AT_LEVEL = wb.getIntxVMFlag(&quot;TieredStopAtLevel&quot;).intValue();
 62 
 63     /* This test uses several methods from jdk.internal.misc.Unsafe. The method
 64      * getMethod() returns a different Executable for each different
 65      * combination of its input parameters. There are eight possible
 66      * combinations, getMethod can return an Executable representing
 67      * the following methods: putChar, putCharVolatile, getChar,
 68      * getCharVolatile, putInt, putIntVolatile, getInt,
 69      * getIntVolatile. These methods were selected because they can
 70      * be intrinsified by both the C1 and the C2 compiler.
 71      */
 72     static Executable getMethod(boolean isChar, boolean isPut, boolean isVolatile) throws RuntimeException {
 73         Executable aMethod;
 74         String methodTypeName = isChar ? &quot;Char&quot; : &quot;Int&quot;;
 75 
 76         try {
 77             Class aClass = Class.forName(&quot;jdk.internal.misc.Unsafe&quot;);
 78             if (isPut) {
 79                 aMethod = aClass.getDeclaredMethod(&quot;put&quot; + methodTypeName + (isVolatile ? &quot;Volatile&quot; : &quot;&quot;),
 80                                                    Object.class,
 81                                                    long.class,
 82                                                    isChar ? char.class : int.class);
 83             } else {
 84                 aMethod = aClass.getDeclaredMethod(&quot;get&quot; + methodTypeName + (isVolatile ? &quot;Volatile&quot; : &quot;&quot;),
 85                                                    Object.class,
 86                                                    long.class);
 87             }
 88         } catch (NoSuchMethodException e) {
 89             throw new RuntimeException(&quot;Test bug, method is unavailable. &quot; + e);
 90         } catch (ClassNotFoundException e) {
 91             throw new RuntimeException(&quot;Test bug, class is unavailable. &quot; + e);
 92         }
 93 
 94         return aMethod;
 95     }
 96 
 97     public static void test(int compLevel) {
 98 
 99         Executable putChar = getMethod(true, /*isPut =*/ true, /*isVolatile = */ false);
100         Executable getChar = getMethod(true, /*isPut =*/ false, /*isVolatile = */ false);
101         Executable putCharVolatile = getMethod(true, /*isPut =*/ true, /*isVolatile = */ true);
102         Executable getCharVolatile = getMethod(true, /*isPut =*/ false, /*isVolatile = */ true);
103         Executable putInt = getMethod(false, /*isPut =*/ true, /*isVolatile = */ false);
104         Executable getInt = getMethod(false, /*isPut =*/ false, /*isVolatile = */ false);
105         Executable putIntVolatile = getMethod(false, /*isPut =*/ true, /*isVolatile = */ true);
106         Executable getIntVolatile = getMethod(false, /*isPut =*/ false, /*isVolatile = */ true);
107 
108         /* Test if globally disabling intrinsics works. */
109         if (!wb.isIntrinsicAvailable(putChar, compLevel)) {
110             throw new RuntimeException(&quot;Intrinsic for [&quot; + putChar.toGenericString() +
111                                        &quot;] is not available globally although it should be.&quot;);
112         }
113 
114         if (wb.isIntrinsicAvailable(putCharVolatile, compLevel)) {
115             throw new RuntimeException(&quot;Intrinsic for [&quot; + putCharVolatile.toGenericString() +
116                                        &quot;] is available globally although it should not be.&quot;);
117         }
118 
119         if (wb.isIntrinsicAvailable(putInt, compLevel)) {
120             throw new RuntimeException(&quot;Intrinsic for [&quot; + putInt.toGenericString() +
121                                        &quot;] is available globally although it should not be.&quot;);
122         }
123 
124         if (wb.isIntrinsicAvailable(putIntVolatile, compLevel)) {
125             throw new RuntimeException(&quot;Intrinsic for [&quot; + putIntVolatile.toGenericString() +
126                                        &quot;] is available globally although it should not be.&quot;);
127         }
128 
129         /* Test if disabling intrinsics on a per-method level
130          * works. The method for which intrinsics are
131          * disabled (the compilation context) is putChar. */
132         if (!wb.isIntrinsicAvailable(getChar, putChar, compLevel)) {
133             throw new RuntimeException(&quot;Intrinsic for [&quot; + getChar.toGenericString() +
134                                        &quot;] is not available for intrinsification in [&quot; +
135                                        putChar.toGenericString() + &quot;] although it should be.&quot;);
136         }
137 
138         if (wb.isIntrinsicAvailable(getCharVolatile, putChar, compLevel)) {
139             throw new RuntimeException(&quot;Intrinsic for [&quot; + getCharVolatile.toGenericString() +
140                                        &quot;] is available for intrinsification in [&quot; +
141                                        putChar.toGenericString() + &quot;] although it should not be.&quot;);
142         }
143 
144         if (wb.isIntrinsicAvailable(getInt, putChar, compLevel)) {
145             throw new RuntimeException(&quot;Intrinsic for [&quot; + getInt.toGenericString() +
146                                        &quot;] is available for intrinsification in [&quot; +
147                                        putChar.toGenericString() + &quot;] although it should not be.&quot;);
148         }
149 
150         if (wb.isIntrinsicAvailable(getIntVolatile, putCharVolatile, compLevel)) {
151             throw new RuntimeException(&quot;Intrinsic for [&quot; + getIntVolatile.toGenericString() +
152                                        &quot;] is available for intrinsification in [&quot; +
153                                        putCharVolatile.toGenericString() + &quot;] although it should not be.&quot;);
154         }
155 
156         /* Test if disabling intrinsics on a per-method level
157          * leaves those intrinsics enabled globally. */
158         if (!wb.isIntrinsicAvailable(getCharVolatile, compLevel)) {
159             throw new RuntimeException(&quot;Intrinsic for [&quot; + getCharVolatile.toGenericString() +
160                                        &quot;] is not available globally although it should be.&quot;);
161         }
162 
163         if (!wb.isIntrinsicAvailable(getInt, compLevel)) {
164             throw new RuntimeException(&quot;Intrinsic for [&quot; + getInt.toGenericString() +
165                                        &quot;] is not available globally although it should be.&quot;);
166         }
167 
168 
169         if (!wb.isIntrinsicAvailable(getIntVolatile, compLevel)) {
170             throw new RuntimeException(&quot;Intrinsic for [&quot; + getIntVolatile.toGenericString() +
171                                        &quot;] is not available globally although it should be.&quot;);
172         }
173 
174         /* Test if disabling an intrinsic globally disables it on a
175          * per-method level as well. */
176         if (!wb.isIntrinsicAvailable(putChar, getChar, compLevel)) {
177             throw new RuntimeException(&quot;Intrinsic for [&quot; + putChar.toGenericString() +
178                                        &quot;] is not available for intrinsification in [&quot; +
179                                        getChar.toGenericString() + &quot;] although it should be.&quot;);
180         }
181 
182         if (wb.isIntrinsicAvailable(putCharVolatile, getChar, compLevel)) {
183             throw new RuntimeException(&quot;Intrinsic for [&quot; + putCharVolatile.toGenericString() +
184                                        &quot;] is available for intrinsification in [&quot; +
185                                        getChar.toGenericString() + &quot;] although it should not be.&quot;);
186         }
187 
188         if (wb.isIntrinsicAvailable(putInt, getChar, compLevel)) {
189             throw new RuntimeException(&quot;Intrinsic for [&quot; + putInt.toGenericString() +
190                                        &quot;] is available for intrinsification in [&quot; +
191                                        getChar.toGenericString() + &quot;] although it should not be.&quot;);
192         }
193 
194         if (wb.isIntrinsicAvailable(putIntVolatile, getChar, compLevel)) {
195             throw new RuntimeException(&quot;Intrinsic for [&quot; + putIntVolatile.toGenericString() +
196                                        &quot;] is available for intrinsification in [&quot; +
197                                        getChar.toGenericString() + &quot;] although it should not be.&quot;);
198         }
199     }
200 
201     public static void main(String args[]) {
202         if (Platform.isServer() &amp;&amp; !Platform.isEmulatedClient() &amp;&amp;
203                                    (TIERED_STOP_AT_LEVEL == CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION)) {
204             if (TIERED_COMPILATION) {
205                 test(CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE);
206             }
207             test(CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);
208         } else {
209             test(CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE);
210         }
211     }
212 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
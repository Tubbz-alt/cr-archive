<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/oracle/MethodMatcherTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test MethodMatcherTest
 26  * @summary Testing of compiler/MethodMatcher
 27  * @bug 8135068
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  * @build sun.hotspot.WhiteBox
 31  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
<a name="2" id="anc2"></a><span class="line-removed"> 32  *                                sun.hotspot.WhiteBox$WhiteBoxPermission</span>
 33  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 34  *                   compiler.oracle.MethodMatcherTest
 35  */
 36 
 37 package compiler.oracle;
 38 
 39 import sun.hotspot.WhiteBox;
 40 
 41 import java.lang.reflect.Method;
 42 import java.util.ArrayList;
 43 
 44 public class MethodMatcherTest {
 45 
 46     /** Instance of WhiteBox */
 47     protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
 48 
 49     Method helper;
 50     Method getDate;
 51     Method inner;
 52     Method toString;
 53 
 54     static final int MATCH = 1;
 55     static final int NO_MATCH = 0;
 56     static final int PARSING_FAILURE = -1;
 57 
 58     public MethodMatcherTest() {
 59     }
 60 
 61     public void test() throws Exception {
 62         // instantiate before calling getMethod on innerHelper
 63         TestCases testCases = new TestCases();
 64 
 65         helper = getMethod(MethodMatcherTest.class, &quot;helper&quot;);
 66         getDate = getMethod(java.util.Date.class, &quot;getDate&quot;);
 67         inner = getMethod(TestCases.class, &quot;innerHelper&quot;);
 68         toString = getMethod(String.class, &quot;toString&quot;);
 69 
 70         testCases.add(helper, &quot;pool/sub/Klass.method(I[Ljava/lang/String;Ljava/lang/Integer;[B[[D)V&quot;, NO_MATCH);
 71 
 72         // These should be improved to parsing failed in the future
 73         testCases.add(helper, &quot;*Klass*,*$method*::&quot;, NO_MATCH);
 74         testCases.add(helper, &quot;*Klass *+*&quot;, NO_MATCH);
 75         testCases.add(helper, &quot;*Klass*::*method*&quot;, NO_MATCH);
 76 
 77         testCases.add(helper, &quot;*,**&quot;, PARSING_FAILURE);
 78         testCases.add(helper, &quot;*,*(I[Ljava/lang/String;Lj]ava/lang/Integer;[B[[D)V&quot;, PARSING_FAILURE);
 79         testCases.add(helper, &quot;*,*)method*.&quot;, PARSING_FAILURE);
 80         testCases.add(helper, &quot;{pool.subpack.Klass}* *&quot;, PARSING_FAILURE);
 81         testCases.add(helper, &quot;*Klass met]hod/&quot;, PARSING_FAILURE);
 82         testCases.add(helper, &quot;pool::su@%b::Klass* *)method.&quot;, PARSING_FAILURE);
 83         testCases.add(helper, &quot;0pool/sub/Klass,*{method}*.(I[Ljava/lang/String;Lj]ava/lang/Integer;[B[[D)V&quot;, PARSING_FAILURE);
 84         testCases.add(helper, &quot;*Klass nonexistent::)(I[Ljava/lang/String;Ljava/lang/Integer;[B[[D)V&quot;, PARSING_FAILURE);
 85         testCases.add(helper, &quot;pool,su]b,Klass*,*)method*/&quot;, PARSING_FAILURE);
 86         testCases.add(helper, &quot;_pool,sub,Klass*,met@%hod,(0)V&quot;, PARSING_FAILURE);
 87 
 88         testCases.add(helper, &quot;*.*&quot;, MATCH);
 89         testCases.add(helper, &quot;compiler/oracle/MethodMatcherTest.*&quot;, MATCH);
 90         testCases.add(helper, &quot;compiler/oracle/MethodMatcherTest.helper&quot;, MATCH);
 91         testCases.add(helper, &quot;compiler/oracle/MethodMatcherTest.helper()&quot;, MATCH);
 92         testCases.add(helper, &quot;compiler/oracle/MethodMatcherTest.helper()V&quot;, MATCH);
 93         testCases.add(helper, &quot;compiler/oracle/MethodMatcherTest.helper()V;&quot;, NO_MATCH);
 94         testCases.add(helper, &quot;compiler/oracle/MethodMatcherTest.helper()I&quot;, NO_MATCH);
 95         testCases.add(helper, &quot;compiler/oracle/MethodMatcherTest.helperX&quot;, NO_MATCH);
 96         testCases.add(helper, &quot;compiler/oracle/MethodMatcherTest.helper;&quot;, NO_MATCH);
 97         testCases.add(helper, &quot;abc.*&quot;, NO_MATCH);
 98         testCases.add(helper, &quot;*.abc&quot;, NO_MATCH);
 99 
100         testCases.add(getDate, &quot;*.*&quot;, MATCH);
101         testCases.add(getDate, &quot;*.getDate&quot;, MATCH);
102         testCases.add(getDate, &quot;java/util/Date.getDate&quot;, MATCH);
103         testCases.add(getDate, &quot;java/util/Date.*&quot;, MATCH);
104 
105         testCases.add(inner, &quot;*.*&quot;, MATCH);
106         testCases.add(inner, &quot;compiler/oracle/MethodMatcherTest$TestCases.innerHelper&quot;, MATCH);
107         testCases.add(inner, &quot;compiler/oracle/MethodMatcherTest*.innerHelper&quot;, MATCH);
108         testCases.add(inner, &quot;compiler/oracle/MethodMatcherTest$*.innerHelper&quot;, MATCH);
109         testCases.add(inner, &quot;*$TestCases.innerHelper&quot;, MATCH);
110         testCases.add(inner, &quot;*TestCases.innerHelper&quot;, MATCH);
111         testCases.add(inner, &quot;TestCases.innerHelper&quot;, NO_MATCH);
112         testCases.add(inner, &quot;compiler/oracle/MethodMatcherTest.innerHelper&quot;, NO_MATCH);
113 
114         testCases.add(toString, &quot;*.*&quot;, MATCH);
115         testCases.add(toString, &quot;java/lang/String.toString&quot;, MATCH);
116         testCases.add(toString, &quot;java.lang.String::toString&quot;, MATCH);
117 
118         testCases.add(toString, &quot;java/lang/String::toString&quot;, PARSING_FAILURE);
119         testCases.add(toString, &quot;java.lang/String::toString&quot;, PARSING_FAILURE);
120         testCases.add(toString, &quot;java.lang/String.toString&quot;, PARSING_FAILURE);
121         testCases.add(toString, &quot;java::lang::String::toString&quot;, PARSING_FAILURE);
122 
123         testCases.add(toString, &quot;java/lang/String.toString(*)&quot;, PARSING_FAILURE);
124         testCases.add(toString, &quot;java/lang/String.toString(L*&quot;, PARSING_FAILURE);
125         testCases.add(toString, &quot;java/lang/String.toString*(lsd)l&quot;, NO_MATCH);
126         testCases.add(toString, &quot;java/lang/String.toString(lsd)l&quot;, NO_MATCH);
127         testCases.add(toString, &quot;java/lang/String.toString (&quot;, MATCH);
128         testCases.add(toString, &quot;java/lang/String.toString ()&quot;, MATCH);
129         testCases.add(toString, &quot;java/lang/String.toString ()L&quot;, MATCH);
130         testCases.add(toString, &quot;java/lang/String.toString ()Lj&quot;, MATCH);
131         testCases.add(toString, &quot;java/lang/String.toString ()Ls&quot;, NO_MATCH);
132         testCases.add(toString, &quot;java/lang/String.toString*(&quot;, MATCH);
133         testCases.add(toString, &quot;java/lang/String.toString* (&quot;, MATCH);
134         testCases.add(toString, &quot;java/lang/String.toString*(;&quot;, NO_MATCH);
135         testCases.add(toString, &quot;java/lang/String.toString*();sf&quot;, NO_MATCH);
136         testCases.add(toString, &quot;java/lang/String.toString*()Ljava/lang/String;&quot;, MATCH);
137         testCases.add(toString, &quot;java/lang/String.toString()Ljava/lang/String;&quot;, MATCH);
138         testCases.add(toString, &quot;java/lang/String.toString ()Ljava/lang/String;&quot;, MATCH);
139         testCases.add(toString, &quot;java/lang/String.toString ()Ljava/lang/String&quot;, MATCH);
140         testCases.add(toString, &quot;java/lang/String.toString ()L&quot;, MATCH);
141         testCases.add(toString, &quot;java/lang/String.toString ()I;&quot;, NO_MATCH);
142 
143         testCases.add(toString, &quot;*Internal.*&quot;, NO_MATCH);
144         testCases.add(toString, &quot;*Internal.**&quot;, PARSING_FAILURE);
145         testCases.add(toString, &quot;*Internal.***&quot;, PARSING_FAILURE);
146         testCases.add(toString, &quot;*Internal.*a**&quot;, PARSING_FAILURE);
147         testCases.add(toString, &quot;*Internal.**a*&quot;, PARSING_FAILURE);
148 
149         testCases.add(toString, &quot;java.lang.String::&lt;init&gt;(Ljava/lang/String;)V&quot;, NO_MATCH);
150         testCases.add(toString, &quot;java.lang.String::&lt;clinit&gt;(Ljava/lang/String;)V&quot;, NO_MATCH);
151         testCases.add(toString, &quot;java.lang.String::&lt;init(Ljava/lang/String;)V&quot;, PARSING_FAILURE);
152         testCases.add(toString, &quot;java.lang.String::init&gt;(Ljava/lang/String;)V&quot;, PARSING_FAILURE);
153 
154         testCases.add(toString, &quot;java/lang/String.toString()Ljava/lang/String;&quot;, MATCH);
155         testCases.add(toString, &quot;java/lang/Str&lt;ing.toString()Ljava/lang/String;&quot;, PARSING_FAILURE);
156         testCases.add(toString, &quot;java/lang/Str&gt;ing.toString()Ljava/lang/String;&quot;, PARSING_FAILURE);
157         testCases.add(toString, &quot;java/lang/&lt;init&gt;.toString()Ljava/lang/String;&quot;, PARSING_FAILURE);
158         testCases.add(toString, &quot;java/lang/&lt;clinit&gt;.toString()Ljava/lang/String;&quot;, PARSING_FAILURE);
159 
160         int failures = 0;
161         for (TestCase t : testCases) {
162             System.out.println(&quot;Test case: &quot; + t.pattern);
163             if (!t.test()) {
164                 failures++;
165                 System.out.println(&quot; * FAILED&quot;);
166             }
167         }
168         if (failures != 0) {
169             throw new Exception(&quot;There where &quot; + failures + &quot; failures in this test&quot;);
170         }
171     }
172 
173     public static void main(String... args) throws Exception {
174         MethodMatcherTest test = new MethodMatcherTest();
175         test.test();
176     }
177 
178     public void helper() {
179 
180     }
181 
182     private static Method getMethod(Class klass, String name, Class&lt;?&gt;... parameterTypes) {
183         try {
184             return klass.getDeclaredMethod(name, parameterTypes);
185         } catch (NoSuchMethodException | SecurityException e) {
186             throw new RuntimeException(&quot;exception on getting method Helper.&quot; + name, e);
187         }
188     }
189 
190     class TestCase {
191         String pattern;
192         Method testTarget;
193         int expectedResult;
194 
195         public TestCase(Method testTarget, String pattern, int expectedResult) {
196             this.testTarget = testTarget;
197             this.pattern = pattern;
198             this.expectedResult = expectedResult;
199         }
200 
201         public String resultAsStr(int errorCode) {
202             switch (errorCode) {
203             case PARSING_FAILURE:
204                 return &quot;Parsing failed&quot;;
205             case NO_MATCH:
206                 return &quot;No match&quot;;
207             case MATCH:
208                 return &quot;Match&quot;;
209             default:
210                 return &quot;Unknown error&quot;;
211             }
212         }
213 
214         boolean test() {
215             int result = WHITE_BOX.matchesMethod(testTarget, pattern);
216             if (result != expectedResult) {
217                 System.out
218                         .println(&quot;FAIL Wrong result, Got: &quot; + resultAsStr(result) + &quot;\n TestCase: &quot; + this.toString());
219                 return false;
220             }
221             return true;
222         }
223 
224         @Override
225         public String toString() {
226             return &quot;Method: &#39;&quot; + testTarget.toString() + &quot;&#39; Pattern: &#39;&quot; + pattern + &quot;&#39; Expected: &quot;
227                     + resultAsStr(expectedResult);
228         }
229 
230         public void innerHelper() {
231         }
232     }
233 
234     class TestCases extends ArrayList&lt;TestCase&gt; {
235         private static final long serialVersionUID = 1L;
236 
237         public boolean add(Method testTarget, String pattern, int expectedResult) {
238             return super.add(new TestCase(testTarget, pattern, expectedResult));
239         }
240 
241         public void innerHelper() {
242         }
243     }
244 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/c2/cr6340864/TestDoubleVect.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 6340864
 27  * @summary Implement vectorization optimizations in hotspot-server
 28  *
 29  * @run main/othervm/timeout=400 -Xbatch -Xmx128m compiler.c2.cr6340864.TestDoubleVect
 30  * @run main/othervm/timeout=400 -Xbatch -Xmx128m -XX:MaxVectorSize=8 compiler.c2.cr6340864.TestDoubleVect
 31  * @run main/othervm/timeout=400 -Xbatch -Xmx128m -XX:MaxVectorSize=16 compiler.c2.cr6340864.TestDoubleVect
 32  * @run main/othervm/timeout=400 -Xbatch -Xmx128m -XX:MaxVectorSize=32 compiler.c2.cr6340864.TestDoubleVect
 33  */
 34 
 35 package compiler.c2.cr6340864;
 36 
 37 public class TestDoubleVect {
 38   private static final int ARRLEN = 997;
 39   private static final int ITERS  = 11000;
 40   private static final double ADD_INIT = -7500.;
 41   private static final double VALUE = 15.;
 42 
 43   public static void main(String args[]) {
 44     System.out.println(&quot;Testing Double vectors&quot;);
 45     int errn = test();
 46     if (errn &gt; 0) {
 47       System.err.println(&quot;FAILED: &quot; + errn + &quot; errors&quot;);
 48       System.exit(97);
 49     }
 50     System.out.println(&quot;PASSED&quot;);
 51   }
 52 
 53   static int test() {
 54     double[] a0 = new double[ARRLEN];
 55     double[] a1 = new double[ARRLEN];
 56     double[] a2 = new double[ARRLEN];
 57     double[] a3 = new double[ARRLEN];
 58     // Initialize
 59     double gold_sum = 0;
 60     for (int i=0; i&lt;ARRLEN; i++) {
 61       double val = ADD_INIT+(double)i;
 62       gold_sum += val;
 63       a1[i] = val;
 64       a2[i] = VALUE;
 65       a3[i] = -VALUE;
 66     }
 67 
 68     System.out.println(&quot;Warmup&quot;);
 69     for (int i=0; i&lt;ITERS; i++) {
 70       test_sum(a1);
 71       test_addc(a0, a1);
 72       test_addv(a0, a1, VALUE);
 73       test_adda(a0, a1, a2);
 74       test_subc(a0, a1);
 75       test_subv(a0, a1, VALUE);
 76       test_suba(a0, a1, a2);
 77       test_mulc(a0, a1);
 78       test_mulv(a0, a1, VALUE);
 79       test_mula(a0, a1, a2);
 80       test_divc(a0, a1);
 81       test_divv(a0, a1, VALUE);
 82       test_diva(a0, a1, a2);
 83       test_mulc_n(a0, a1);
 84       test_mulv(a0, a1, -VALUE);
 85       test_mula(a0, a1, a3);
 86       test_divc_n(a0, a1);
 87       test_divv(a0, a1, -VALUE);
 88       test_diva(a0, a1, a3);
 89       test_negc(a0, a1);
 90       test_rint(a0, a1);
 91       test_ceil(a0, a1);
 92       test_floor(a0, a1);
 93       test_sqrt(a0, a1);
 94     }
 95     // Test and verify results
 96     System.out.println(&quot;Verification&quot;);
 97     int errn = 0;
 98     {
 99       double sum = test_sum(a1);
100       if (sum != gold_sum) {
101         System.err.println(&quot;test_sum:  &quot; + sum + &quot; != &quot; + gold_sum);
102         errn++;
103       }
104       // Overwrite with NaN values
105       a1[0] = Double.NaN;
106       a1[1] = Double.POSITIVE_INFINITY;
107       a1[2] = Double.NEGATIVE_INFINITY;
108       a1[3] = Double.MAX_VALUE;
109       a1[4] = Double.MIN_VALUE;
110       a1[5] = Double.MIN_NORMAL;
111 
112       a2[6] = a1[0];
113       a2[7] = a1[1];
114       a2[8] = a1[2];
115       a2[9] = a1[3];
116       a2[10] = a1[4];
117       a2[11] = a1[5];
118 
119       a3[6] = -a2[6];
120       a3[7] = -a2[7];
121       a3[8] = -a2[8];
122       a3[9] = -a2[9];
123       a3[10] = -a2[10];
124       a3[11] = -a2[11];
125 
126       test_addc(a0, a1);
127       errn += verify(&quot;test_addc: &quot;, 0, a0[0], (Double.NaN+VALUE));
128       errn += verify(&quot;test_addc: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY+VALUE));
129       errn += verify(&quot;test_addc: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY+VALUE));
130       errn += verify(&quot;test_addc: &quot;, 3, a0[3], (Double.MAX_VALUE+VALUE));
131       errn += verify(&quot;test_addc: &quot;, 4, a0[4], (Double.MIN_VALUE+VALUE));
132       errn += verify(&quot;test_addc: &quot;, 5, a0[5], (Double.MIN_NORMAL+VALUE));
133       for (int i=6; i&lt;ARRLEN; i++) {
134         errn += verify(&quot;test_addc: &quot;, i, a0[i], ((ADD_INIT+i)+VALUE));
135       }
136       test_addv(a0, a1, VALUE);
137       errn += verify(&quot;test_addv: &quot;, 0, a0[0], (Double.NaN+VALUE));
138       errn += verify(&quot;test_addv: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY+VALUE));
139       errn += verify(&quot;test_addv: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY+VALUE));
140       errn += verify(&quot;test_addv: &quot;, 3, a0[3], (Double.MAX_VALUE+VALUE));
141       errn += verify(&quot;test_addv: &quot;, 4, a0[4], (Double.MIN_VALUE+VALUE));
142       errn += verify(&quot;test_addv: &quot;, 5, a0[5], (Double.MIN_NORMAL+VALUE));
143       for (int i=6; i&lt;ARRLEN; i++) {
144         errn += verify(&quot;test_addv: &quot;, i, a0[i], ((ADD_INIT+i)+VALUE));
145       }
146       test_adda(a0, a1, a2);
147       errn += verify(&quot;test_adda: &quot;, 0, a0[0], (Double.NaN+VALUE));
148       errn += verify(&quot;test_adda: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY+VALUE));
149       errn += verify(&quot;test_adda: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY+VALUE));
150       errn += verify(&quot;test_adda: &quot;, 3, a0[3], (Double.MAX_VALUE+VALUE));
151       errn += verify(&quot;test_adda: &quot;, 4, a0[4], (Double.MIN_VALUE+VALUE));
152       errn += verify(&quot;test_adda: &quot;, 5, a0[5], (Double.MIN_NORMAL+VALUE));
153       errn += verify(&quot;test_adda: &quot;, 6, a0[6], ((ADD_INIT+6)+Double.NaN));
154       errn += verify(&quot;test_adda: &quot;, 7, a0[7], ((ADD_INIT+7)+Double.POSITIVE_INFINITY));
155       errn += verify(&quot;test_adda: &quot;, 8, a0[8], ((ADD_INIT+8)+Double.NEGATIVE_INFINITY));
156       errn += verify(&quot;test_adda: &quot;, 9, a0[9], ((ADD_INIT+9)+Double.MAX_VALUE));
157       errn += verify(&quot;test_adda: &quot;, 10, a0[10], ((ADD_INIT+10)+Double.MIN_VALUE));
158       errn += verify(&quot;test_adda: &quot;, 11, a0[11], ((ADD_INIT+11)+Double.MIN_NORMAL));
159       for (int i=12; i&lt;ARRLEN; i++) {
160         errn += verify(&quot;test_adda: &quot;, i, a0[i], ((ADD_INIT+i)+VALUE));
161       }
162 
163       test_subc(a0, a1);
164       errn += verify(&quot;test_subc: &quot;, 0, a0[0], (Double.NaN-VALUE));
165       errn += verify(&quot;test_subc: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY-VALUE));
166       errn += verify(&quot;test_subc: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY-VALUE));
167       errn += verify(&quot;test_subc: &quot;, 3, a0[3], (Double.MAX_VALUE-VALUE));
168       errn += verify(&quot;test_subc: &quot;, 4, a0[4], (Double.MIN_VALUE-VALUE));
169       errn += verify(&quot;test_subc: &quot;, 5, a0[5], (Double.MIN_NORMAL-VALUE));
170       for (int i=6; i&lt;ARRLEN; i++) {
171         errn += verify(&quot;test_subc: &quot;, i, a0[i], ((ADD_INIT+i)-VALUE));
172       }
173       test_subv(a0, a1, VALUE);
174       errn += verify(&quot;test_subv: &quot;, 0, a0[0], (Double.NaN-VALUE));
175       errn += verify(&quot;test_subv: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY-VALUE));
176       errn += verify(&quot;test_subv: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY-VALUE));
177       errn += verify(&quot;test_subv: &quot;, 3, a0[3], (Double.MAX_VALUE-VALUE));
178       errn += verify(&quot;test_subv: &quot;, 4, a0[4], (Double.MIN_VALUE-VALUE));
179       errn += verify(&quot;test_subv: &quot;, 5, a0[5], (Double.MIN_NORMAL-VALUE));
180       for (int i=6; i&lt;ARRLEN; i++) {
181         errn += verify(&quot;test_subv: &quot;, i, a0[i], ((ADD_INIT+i)-VALUE));
182       }
183       test_suba(a0, a1, a2);
184       errn += verify(&quot;test_suba: &quot;, 0, a0[0], (Double.NaN-VALUE));
185       errn += verify(&quot;test_suba: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY-VALUE));
186       errn += verify(&quot;test_suba: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY-VALUE));
187       errn += verify(&quot;test_suba: &quot;, 3, a0[3], (Double.MAX_VALUE-VALUE));
188       errn += verify(&quot;test_suba: &quot;, 4, a0[4], (Double.MIN_VALUE-VALUE));
189       errn += verify(&quot;test_suba: &quot;, 5, a0[5], (Double.MIN_NORMAL-VALUE));
190       errn += verify(&quot;test_suba: &quot;, 6, a0[6], ((ADD_INIT+6)-Double.NaN));
191       errn += verify(&quot;test_suba: &quot;, 7, a0[7], ((ADD_INIT+7)-Double.POSITIVE_INFINITY));
192       errn += verify(&quot;test_suba: &quot;, 8, a0[8], ((ADD_INIT+8)-Double.NEGATIVE_INFINITY));
193       errn += verify(&quot;test_suba: &quot;, 9, a0[9], ((ADD_INIT+9)-Double.MAX_VALUE));
194       errn += verify(&quot;test_suba: &quot;, 10, a0[10], ((ADD_INIT+10)-Double.MIN_VALUE));
195       errn += verify(&quot;test_suba: &quot;, 11, a0[11], ((ADD_INIT+11)-Double.MIN_NORMAL));
196       for (int i=12; i&lt;ARRLEN; i++) {
197         errn += verify(&quot;test_suba: &quot;, i, a0[i], ((ADD_INIT+i)-VALUE));
198       }
199 
200       test_mulc(a0, a1);
201       errn += verify(&quot;test_mulc: &quot;, 0, a0[0], (Double.NaN*VALUE));
202       errn += verify(&quot;test_mulc: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY*VALUE));
203       errn += verify(&quot;test_mulc: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY*VALUE));
204       errn += verify(&quot;test_mulc: &quot;, 3, a0[3], (Double.MAX_VALUE*VALUE));
205       errn += verify(&quot;test_mulc: &quot;, 4, a0[4], (Double.MIN_VALUE*VALUE));
206       errn += verify(&quot;test_mulc: &quot;, 5, a0[5], (Double.MIN_NORMAL*VALUE));
207       for (int i=6; i&lt;ARRLEN; i++) {
208         errn += verify(&quot;test_mulc: &quot;, i, a0[i], ((ADD_INIT+i)*VALUE));
209       }
210       test_mulv(a0, a1, VALUE);
211       errn += verify(&quot;test_mulv: &quot;, 0, a0[0], (Double.NaN*VALUE));
212       errn += verify(&quot;test_mulv: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY*VALUE));
213       errn += verify(&quot;test_mulv: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY*VALUE));
214       errn += verify(&quot;test_mulv: &quot;, 3, a0[3], (Double.MAX_VALUE*VALUE));
215       errn += verify(&quot;test_mulv: &quot;, 4, a0[4], (Double.MIN_VALUE*VALUE));
216       errn += verify(&quot;test_mulv: &quot;, 5, a0[5], (Double.MIN_NORMAL*VALUE));
217       for (int i=6; i&lt;ARRLEN; i++) {
218         errn += verify(&quot;test_mulv: &quot;, i, a0[i], ((ADD_INIT+i)*VALUE));
219       }
220       test_mula(a0, a1, a2);
221       errn += verify(&quot;test_mula: &quot;, 0, a0[0], (Double.NaN*VALUE));
222       errn += verify(&quot;test_mula: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY*VALUE));
223       errn += verify(&quot;test_mula: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY*VALUE));
224       errn += verify(&quot;test_mula: &quot;, 3, a0[3], (Double.MAX_VALUE*VALUE));
225       errn += verify(&quot;test_mula: &quot;, 4, a0[4], (Double.MIN_VALUE*VALUE));
226       errn += verify(&quot;test_mula: &quot;, 5, a0[5], (Double.MIN_NORMAL*VALUE));
227       errn += verify(&quot;test_mula: &quot;, 6, a0[6], ((ADD_INIT+6)*Double.NaN));
228       errn += verify(&quot;test_mula: &quot;, 7, a0[7], ((ADD_INIT+7)*Double.POSITIVE_INFINITY));
229       errn += verify(&quot;test_mula: &quot;, 8, a0[8], ((ADD_INIT+8)*Double.NEGATIVE_INFINITY));
230       errn += verify(&quot;test_mula: &quot;, 9, a0[9], ((ADD_INIT+9)*Double.MAX_VALUE));
231       errn += verify(&quot;test_mula: &quot;, 10, a0[10], ((ADD_INIT+10)*Double.MIN_VALUE));
232       errn += verify(&quot;test_mula: &quot;, 11, a0[11], ((ADD_INIT+11)*Double.MIN_NORMAL));
233       for (int i=12; i&lt;ARRLEN; i++) {
234         errn += verify(&quot;test_mula: &quot;, i, a0[i], ((ADD_INIT+i)*VALUE));
235       }
236 
237       test_divc(a0, a1);
238       errn += verify(&quot;test_divc: &quot;, 0, a0[0], (Double.NaN/VALUE));
239       errn += verify(&quot;test_divc: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY/VALUE));
240       errn += verify(&quot;test_divc: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY/VALUE));
241       errn += verify(&quot;test_divc: &quot;, 3, a0[3], (Double.MAX_VALUE/VALUE));
242       errn += verify(&quot;test_divc: &quot;, 4, a0[4], (Double.MIN_VALUE/VALUE));
243       errn += verify(&quot;test_divc: &quot;, 5, a0[5], (Double.MIN_NORMAL/VALUE));
244       for (int i=6; i&lt;ARRLEN; i++) {
245         errn += verify(&quot;test_divc: &quot;, i, a0[i], ((ADD_INIT+i)/VALUE));
246       }
247       test_divv(a0, a1, VALUE);
248       errn += verify(&quot;test_divv: &quot;, 0, a0[0], (Double.NaN/VALUE));
249       errn += verify(&quot;test_divv: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY/VALUE));
250       errn += verify(&quot;test_divv: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY/VALUE));
251       errn += verify(&quot;test_divv: &quot;, 3, a0[3], (Double.MAX_VALUE/VALUE));
252       errn += verify(&quot;test_divv: &quot;, 4, a0[4], (Double.MIN_VALUE/VALUE));
253       errn += verify(&quot;test_divv: &quot;, 5, a0[5], (Double.MIN_NORMAL/VALUE));
254       for (int i=6; i&lt;ARRLEN; i++) {
255         errn += verify(&quot;test_divv: &quot;, i, a0[i], ((ADD_INIT+i)/VALUE));
256       }
257       test_diva(a0, a1, a2);
258       errn += verify(&quot;test_diva: &quot;, 0, a0[0], (Double.NaN/VALUE));
259       errn += verify(&quot;test_diva: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY/VALUE));
260       errn += verify(&quot;test_diva: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY/VALUE));
261       errn += verify(&quot;test_diva: &quot;, 3, a0[3], (Double.MAX_VALUE/VALUE));
262       errn += verify(&quot;test_diva: &quot;, 4, a0[4], (Double.MIN_VALUE/VALUE));
263       errn += verify(&quot;test_diva: &quot;, 5, a0[5], (Double.MIN_NORMAL/VALUE));
264       errn += verify(&quot;test_diva: &quot;, 6, a0[6], ((ADD_INIT+6)/Double.NaN));
265       errn += verify(&quot;test_diva: &quot;, 7, a0[7], ((ADD_INIT+7)/Double.POSITIVE_INFINITY));
266       errn += verify(&quot;test_diva: &quot;, 8, a0[8], ((ADD_INIT+8)/Double.NEGATIVE_INFINITY));
267       errn += verify(&quot;test_diva: &quot;, 9, a0[9], ((ADD_INIT+9)/Double.MAX_VALUE));
268       errn += verify(&quot;test_diva: &quot;, 10, a0[10], ((ADD_INIT+10)/Double.MIN_VALUE));
269       errn += verify(&quot;test_diva: &quot;, 11, a0[11], ((ADD_INIT+11)/Double.MIN_NORMAL));
270       for (int i=12; i&lt;ARRLEN; i++) {
271         errn += verify(&quot;test_diva: &quot;, i, a0[i], ((ADD_INIT+i)/VALUE));
272       }
273 
274       test_mulc_n(a0, a1);
275       errn += verify(&quot;test_mulc_n: &quot;, 0, a0[0], (Double.NaN*(-VALUE)));
276       errn += verify(&quot;test_mulc_n: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY*(-VALUE)));
277       errn += verify(&quot;test_mulc_n: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY*(-VALUE)));
278       errn += verify(&quot;test_mulc_n: &quot;, 3, a0[3], (Double.MAX_VALUE*(-VALUE)));
279       errn += verify(&quot;test_mulc_n: &quot;, 4, a0[4], (Double.MIN_VALUE*(-VALUE)));
280       errn += verify(&quot;test_mulc_n: &quot;, 5, a0[5], (Double.MIN_NORMAL*(-VALUE)));
281       for (int i=6; i&lt;ARRLEN; i++) {
282         errn += verify(&quot;test_mulc_n: &quot;, i, a0[i], ((ADD_INIT+i)*(-VALUE)));
283       }
284       test_mulv(a0, a1, -VALUE);
285       errn += verify(&quot;test_mulv_n: &quot;, 0, a0[0], (Double.NaN*(-VALUE)));
286       errn += verify(&quot;test_mulv_n: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY*(-VALUE)));
287       errn += verify(&quot;test_mulv_n: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY*(-VALUE)));
288       errn += verify(&quot;test_mulv_n: &quot;, 3, a0[3], (Double.MAX_VALUE*(-VALUE)));
289       errn += verify(&quot;test_mulv_n: &quot;, 4, a0[4], (Double.MIN_VALUE*(-VALUE)));
290       errn += verify(&quot;test_mulv_n: &quot;, 5, a0[5], (Double.MIN_NORMAL*(-VALUE)));
291       for (int i=6; i&lt;ARRLEN; i++) {
292         errn += verify(&quot;test_mulv_n: &quot;, i, a0[i], ((ADD_INIT+i)*(-VALUE)));
293       }
294       test_mula(a0, a1, a3);
295       errn += verify(&quot;test_mula_n: &quot;, 0, a0[0], (Double.NaN*(-VALUE)));
296       errn += verify(&quot;test_mula_n: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY*(-VALUE)));
297       errn += verify(&quot;test_mula_n: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY*(-VALUE)));
298       errn += verify(&quot;test_mula_n: &quot;, 3, a0[3], (Double.MAX_VALUE*(-VALUE)));
299       errn += verify(&quot;test_mula_n: &quot;, 4, a0[4], (Double.MIN_VALUE*(-VALUE)));
300       errn += verify(&quot;test_mula_n: &quot;, 5, a0[5], (Double.MIN_NORMAL*(-VALUE)));
301       errn += verify(&quot;test_mula_n: &quot;, 6, a0[6], ((ADD_INIT+6)*(-Double.NaN)));
302       errn += verify(&quot;test_mula_n: &quot;, 7, a0[7], ((ADD_INIT+7)*(-Double.POSITIVE_INFINITY)));
303       errn += verify(&quot;test_mula_n: &quot;, 8, a0[8], ((ADD_INIT+8)*(-Double.NEGATIVE_INFINITY)));
304       errn += verify(&quot;test_mula_n: &quot;, 9, a0[9], ((ADD_INIT+9)*(-Double.MAX_VALUE)));
305       errn += verify(&quot;test_mula_n: &quot;, 10, a0[10], ((ADD_INIT+10)*(-Double.MIN_VALUE)));
306       errn += verify(&quot;test_mula_n: &quot;, 11, a0[11], ((ADD_INIT+11)*(-Double.MIN_NORMAL)));
307       for (int i=12; i&lt;ARRLEN; i++) {
308         errn += verify(&quot;test_mula_n: &quot;, i, a0[i], ((ADD_INIT+i)*(-VALUE)));
309       }
310 
311       test_divc_n(a0, a1);
312       errn += verify(&quot;test_divc_n: &quot;, 0, a0[0], (Double.NaN/(-VALUE)));
313       errn += verify(&quot;test_divc_n: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY/(-VALUE)));
314       errn += verify(&quot;test_divc_n: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY/(-VALUE)));
315       errn += verify(&quot;test_divc_n: &quot;, 3, a0[3], (Double.MAX_VALUE/(-VALUE)));
316       errn += verify(&quot;test_divc_n: &quot;, 4, a0[4], (Double.MIN_VALUE/(-VALUE)));
317       errn += verify(&quot;test_divc_n: &quot;, 5, a0[5], (Double.MIN_NORMAL/(-VALUE)));
318       for (int i=6; i&lt;ARRLEN; i++) {
319         errn += verify(&quot;test_divc_n: &quot;, i, a0[i], ((ADD_INIT+i)/(-VALUE)));
320       }
321       test_divv(a0, a1, -VALUE);
322       errn += verify(&quot;test_divv_n: &quot;, 0, a0[0], (Double.NaN/(-VALUE)));
323       errn += verify(&quot;test_divv_n: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY/(-VALUE)));
324       errn += verify(&quot;test_divv_n: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY/(-VALUE)));
325       errn += verify(&quot;test_divv_n: &quot;, 3, a0[3], (Double.MAX_VALUE/(-VALUE)));
326       errn += verify(&quot;test_divv_n: &quot;, 4, a0[4], (Double.MIN_VALUE/(-VALUE)));
327       errn += verify(&quot;test_divv_n: &quot;, 5, a0[5], (Double.MIN_NORMAL/(-VALUE)));
328       for (int i=6; i&lt;ARRLEN; i++) {
329         errn += verify(&quot;test_divv_n: &quot;, i, a0[i], ((ADD_INIT+i)/(-VALUE)));
330       }
331       test_diva(a0, a1, a3);
332       errn += verify(&quot;test_diva_n: &quot;, 0, a0[0], (Double.NaN/(-VALUE)));
333       errn += verify(&quot;test_diva_n: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY/(-VALUE)));
334       errn += verify(&quot;test_diva_n: &quot;, 2, a0[2], (Double.NEGATIVE_INFINITY/(-VALUE)));
335       errn += verify(&quot;test_diva_n: &quot;, 3, a0[3], (Double.MAX_VALUE/(-VALUE)));
336       errn += verify(&quot;test_diva_n: &quot;, 4, a0[4], (Double.MIN_VALUE/(-VALUE)));
337       errn += verify(&quot;test_diva_n: &quot;, 5, a0[5], (Double.MIN_NORMAL/(-VALUE)));
338       errn += verify(&quot;test_diva_n: &quot;, 6, a0[6], ((ADD_INIT+6)/(-Double.NaN)));
339       errn += verify(&quot;test_diva_n: &quot;, 7, a0[7], ((ADD_INIT+7)/(-Double.POSITIVE_INFINITY)));
340       errn += verify(&quot;test_diva_n: &quot;, 8, a0[8], ((ADD_INIT+8)/(-Double.NEGATIVE_INFINITY)));
341       errn += verify(&quot;test_diva_n: &quot;, 9, a0[9], ((ADD_INIT+9)/(-Double.MAX_VALUE)));
342       errn += verify(&quot;test_diva_n: &quot;, 10, a0[10], ((ADD_INIT+10)/(-Double.MIN_VALUE)));
343       errn += verify(&quot;test_diva_n: &quot;, 11, a0[11], ((ADD_INIT+11)/(-Double.MIN_NORMAL)));
344       for (int i=12; i&lt;ARRLEN; i++) {
345         errn += verify(&quot;test_diva_n: &quot;, i, a0[i], ((ADD_INIT+i)/(-VALUE)));
346       }
347       test_negc(a0, a1);
348       errn += verify(&quot;test_negc: &quot;, 0, a0[0], (Double.NaN));
349       errn += verify(&quot;test_negc: &quot;, 1, a0[1], (Double.NEGATIVE_INFINITY));
350       errn += verify(&quot;test_negc: &quot;, 2, a0[2], (Double.POSITIVE_INFINITY));
351       errn += verify(&quot;test_negc: &quot;, 3, a0[3], (double)(-Double.MAX_VALUE));
352       errn += verify(&quot;test_negc: &quot;, 4, a0[4], (double)(-Double.MIN_VALUE));
353       errn += verify(&quot;test_negc: &quot;, 5, a0[5], (double)(-Double.MIN_NORMAL));
354       for (int i=6; i&lt;ARRLEN; i++) {
355         errn += verify(&quot;test_negc: &quot;, i, a0[i], (double)(-((double)(ADD_INIT+i))));
356       }
357 
358       // To test -ve and +ve Zero scenarios.
359       double [] other_corner_cases     = { -0.0, 0.0, 9.007199254740992E15 };
360       double [] other_corner_cases_res = new double[3];
361       test_floor(a0, a1);
362       errn += verify(&quot;test_floor: &quot;, 0, a0[0], Double.NaN);
363       errn += verify(&quot;test_floor: &quot;, 1, a0[1], Double.POSITIVE_INFINITY);
364       errn += verify(&quot;test_floor: &quot;, 2, a0[2], Double.NEGATIVE_INFINITY);
365       errn += verify(&quot;test_floor: &quot;, 3, a0[3], Double.MAX_VALUE);
366       errn += verify(&quot;test_floor: &quot;, 4, a0[4], 0.0);
367       errn += verify(&quot;test_floor: &quot;, 5, a0[5], 0.0);
368       for (int i=6; i&lt;ARRLEN; i++) {
369         errn += verify(&quot;test_floor: &quot;, i, a0[i], ((double)(ADD_INIT+i)));
370       }
371       test_floor_cc(other_corner_cases_res, other_corner_cases);
372       errn += verify(&quot;test_floor_cc: &quot;, 0, other_corner_cases_res[0], -0.0);
373       errn += verify(&quot;test_floor_cc: &quot;, 1, other_corner_cases_res[1], 0.0);
374       errn += verify(&quot;test_floor_cc: &quot;, 2, other_corner_cases_res[2], 9.007199254740992E15);
375 
376       test_ceil(a0, a1);
377       errn += verify(&quot;test_ceil: &quot;, 0, a0[0], Double.NaN);
378       errn += verify(&quot;test_ceil: &quot;, 1, a0[1], Double.POSITIVE_INFINITY);
379       errn += verify(&quot;test_ceil: &quot;, 2, a0[2], Double.NEGATIVE_INFINITY);
380       errn += verify(&quot;test_ceil: &quot;, 3, a0[3], Double.MAX_VALUE);
381       errn += verify(&quot;test_ceil: &quot;, 4, a0[4], 1.0);
382       errn += verify(&quot;test_ceil: &quot;, 5, a0[5], 1.0);
383       for (int i=6; i&lt;ARRLEN; i++) {
384         errn += verify(&quot;test_ceil: &quot;, i, a0[i], ((double)(ADD_INIT+i+1.0)));
385       }
386       test_ceil_cc(other_corner_cases_res, other_corner_cases);
387       errn += verify(&quot;test_ceil_cc: &quot;, 0, other_corner_cases_res[0], -0.0);
388       errn += verify(&quot;test_ceil_cc: &quot;, 1, other_corner_cases_res[1], 0.0);
389       errn += verify(&quot;test_ceil_cc: &quot;, 2, other_corner_cases_res[2], 9.007199254740992E15);
390 
391       test_rint(a0, a1);
392       errn += verify(&quot;test_rint: &quot;, 0, a0[0], Double.NaN);
393       errn += verify(&quot;test_rint: &quot;, 1, a0[1], Double.POSITIVE_INFINITY);
394       errn += verify(&quot;test_rint: &quot;, 2, a0[2], Double.NEGATIVE_INFINITY);
395       errn += verify(&quot;test_rint: &quot;, 3, a0[3], Double.MAX_VALUE);
396       errn += verify(&quot;test_rint: &quot;, 4, a0[4], 0.0);
397       errn += verify(&quot;test_rint: &quot;, 5, a0[5], 0.0);
398       for (int i=6; i&lt;ARRLEN; i++) {
399         if ( i &lt;= 500 )
400            errn += verify(&quot;test_rint: &quot;, i, a0[i], ((double)(ADD_INIT+i)));
401         else
402            errn += verify(&quot;test_rint: &quot;, i, a0[i], ((double)(ADD_INIT+i+1.0)));
403       }
404       test_rint_cc(other_corner_cases_res, other_corner_cases);
405       errn += verify(&quot;test_rint_cc: &quot;, 0, other_corner_cases_res[0], -0.0);
406       errn += verify(&quot;test_rint_cc: &quot;, 1, other_corner_cases_res[1], 0.0);
407       errn += verify(&quot;test_rint_cc: &quot;, 2, other_corner_cases_res[2], 9.007199254740992E15);
408 
409       // Overwrite with +0.0/-0.0 values
410       a1[6] = (double)0.0;
411       a1[7] = (double)-0.0;
412       test_sqrt(a0, a1);
413       errn += verify(&quot;test_sqrt: &quot;, 0, a0[0], (Double.NaN));
414       errn += verify(&quot;test_sqrt: &quot;, 1, a0[1], (Double.POSITIVE_INFINITY));
415       errn += verify(&quot;test_sqrt: &quot;, 2, a0[2], (Double.NaN));
416       errn += verify(&quot;test_sqrt: &quot;, 3, a0[3], Math.sqrt(Double.MAX_VALUE));
417       errn += verify(&quot;test_sqrt: &quot;, 4, a0[4], Math.sqrt(Double.MIN_VALUE));
418       errn += verify(&quot;test_sqrt: &quot;, 5, a0[5], Math.sqrt(Double.MIN_NORMAL));
419       errn += verify(&quot;test_sqrt: &quot;, 6, a0[6], (double)0.0);
420       errn += verify(&quot;test_sqrt: &quot;, 7, a0[7], (double)-0.0);
421       for (int i=8; i&lt;ARRLEN; i++) {
422         errn += verify(&quot;test_sqrt: &quot;, i, a0[i], Math.sqrt((double)(ADD_INIT+i)));
423       }
424     }
425 
426     if (errn &gt; 0)
427       return errn;
428 
429     System.out.println(&quot;Time&quot;);
430     long start, end;
431 
432     start = System.currentTimeMillis();
433     for (int i=0; i&lt;ITERS; i++) {
434       test_sum(a1);
435     }
436     end = System.currentTimeMillis();
437     System.out.println(&quot;test_sum: &quot; + (end - start));
438 
439     start = System.currentTimeMillis();
440     for (int i=0; i&lt;ITERS; i++) {
441       test_addc(a0, a1);
442     }
443     end = System.currentTimeMillis();
444     System.out.println(&quot;test_addc: &quot; + (end - start));
445     start = System.currentTimeMillis();
446     for (int i=0; i&lt;ITERS; i++) {
447       test_addv(a0, a1, VALUE);
448     }
449     end = System.currentTimeMillis();
450     System.out.println(&quot;test_addv: &quot; + (end - start));
451     start = System.currentTimeMillis();
452     for (int i=0; i&lt;ITERS; i++) {
453       test_adda(a0, a1, a2);
454     }
455     end = System.currentTimeMillis();
456     System.out.println(&quot;test_adda: &quot; + (end - start));
457 
458     start = System.currentTimeMillis();
459     for (int i=0; i&lt;ITERS; i++) {
460       test_subc(a0, a1);
461     }
462     end = System.currentTimeMillis();
463     System.out.println(&quot;test_subc: &quot; + (end - start));
464     start = System.currentTimeMillis();
465     for (int i=0; i&lt;ITERS; i++) {
466       test_subv(a0, a1, VALUE);
467     }
468     end = System.currentTimeMillis();
469     System.out.println(&quot;test_subv: &quot; + (end - start));
470     start = System.currentTimeMillis();
471     for (int i=0; i&lt;ITERS; i++) {
472       test_suba(a0, a1, a2);
473     }
474     end = System.currentTimeMillis();
475     System.out.println(&quot;test_suba: &quot; + (end - start));
476 
477     start = System.currentTimeMillis();
478     for (int i=0; i&lt;ITERS; i++) {
479       test_mulc(a0, a1);
480     }
481     end = System.currentTimeMillis();
482     System.out.println(&quot;test_mulc: &quot; + (end - start));
483     start = System.currentTimeMillis();
484     for (int i=0; i&lt;ITERS; i++) {
485       test_mulv(a0, a1, VALUE);
486     }
487     end = System.currentTimeMillis();
488     System.out.println(&quot;test_mulv: &quot; + (end - start));
489     start = System.currentTimeMillis();
490     for (int i=0; i&lt;ITERS; i++) {
491       test_mula(a0, a1, a2);
492     }
493     end = System.currentTimeMillis();
494     System.out.println(&quot;test_mula: &quot; + (end - start));
495 
496     start = System.currentTimeMillis();
497     for (int i=0; i&lt;ITERS; i++) {
498       test_divc(a0, a1);
499     }
500     end = System.currentTimeMillis();
501     System.out.println(&quot;test_divc: &quot; + (end - start));
502     start = System.currentTimeMillis();
503     for (int i=0; i&lt;ITERS; i++) {
504       test_divv(a0, a1, VALUE);
505     }
506     end = System.currentTimeMillis();
507     System.out.println(&quot;test_divv: &quot; + (end - start));
508     start = System.currentTimeMillis();
509     for (int i=0; i&lt;ITERS; i++) {
510       test_diva(a0, a1, a2);
511     }
512     end = System.currentTimeMillis();
513     System.out.println(&quot;test_diva: &quot; + (end - start));
514 
515     start = System.currentTimeMillis();
516     for (int i=0; i&lt;ITERS; i++) {
517       test_mulc_n(a0, a1);
518     }
519     end = System.currentTimeMillis();
520     System.out.println(&quot;test_mulc_n: &quot; + (end - start));
521     start = System.currentTimeMillis();
522     for (int i=0; i&lt;ITERS; i++) {
523       test_mulv(a0, a1, -VALUE);
524     }
525     end = System.currentTimeMillis();
526     System.out.println(&quot;test_mulv_n: &quot; + (end - start));
527     start = System.currentTimeMillis();
528     for (int i=0; i&lt;ITERS; i++) {
529       test_mula(a0, a1, a3);
530     }
531     end = System.currentTimeMillis();
532     System.out.println(&quot;test_mula_n: &quot; + (end - start));
533 
534     start = System.currentTimeMillis();
535     for (int i=0; i&lt;ITERS; i++) {
536       test_divc_n(a0, a1);
537     }
538     end = System.currentTimeMillis();
539     System.out.println(&quot;test_divc_n: &quot; + (end - start));
540     start = System.currentTimeMillis();
541     for (int i=0; i&lt;ITERS; i++) {
542       test_divv(a0, a1, -VALUE);
543     }
544     end = System.currentTimeMillis();
545     System.out.println(&quot;test_divv_n: &quot; + (end - start));
546     start = System.currentTimeMillis();
547     for (int i=0; i&lt;ITERS; i++) {
548       test_diva(a0, a1, a3);
549     }
550     end = System.currentTimeMillis();
551     System.out.println(&quot;test_diva_n: &quot; + (end - start));
552 
553     start = System.currentTimeMillis();
554     for (int i=0; i&lt;ITERS; i++) {
555       test_negc(a0, a1);
556     }
557     end = System.currentTimeMillis();
558     System.out.println(&quot;test_negc_n: &quot; + (end - start));
559 
560     start = System.currentTimeMillis();
561     for (int i=0; i&lt;ITERS; i++) {
562       test_sqrt(a0, a1);
563     }
564     end = System.currentTimeMillis();
565     System.out.println(&quot;test_sqrt_n: &quot; + (end - start));
566 
567     return errn;
568   }
569 
570   static double test_sum(double[] a1) {
571     double sum = 0;
572     for (int i = 0; i &lt; a1.length; i+=1) {
573       sum += a1[i];
574     }
575     return sum;
576   }
577 
578   static void test_addc(double[] a0, double[] a1) {
579     for (int i = 0; i &lt; a0.length; i+=1) {
580       a0[i] = (a1[i]+VALUE);
581     }
582   }
583   static void test_addv(double[] a0, double[] a1, double b) {
584     for (int i = 0; i &lt; a0.length; i+=1) {
585       a0[i] = (a1[i]+b);
586     }
587   }
588   static void test_adda(double[] a0, double[] a1, double[] a2) {
589     for (int i = 0; i &lt; a0.length; i+=1) {
590       a0[i] = (a1[i]+a2[i]);
591     }
592   }
593 
594   static void test_subc(double[] a0, double[] a1) {
595     for (int i = 0; i &lt; a0.length; i+=1) {
596       a0[i] = (a1[i]-VALUE);
597     }
598   }
599   static void test_subv(double[] a0, double[] a1, double b) {
600     for (int i = 0; i &lt; a0.length; i+=1) {
601       a0[i] = (a1[i]-b);
602     }
603   }
604   static void test_suba(double[] a0, double[] a1, double[] a2) {
605     for (int i = 0; i &lt; a0.length; i+=1) {
606       a0[i] = (a1[i]-a2[i]);
607     }
608   }
609 
610   static void test_mulc(double[] a0, double[] a1) {
611     for (int i = 0; i &lt; a0.length; i+=1) {
612       a0[i] = (a1[i]*VALUE);
613     }
614   }
615   static void test_mulc_n(double[] a0, double[] a1) {
616     for (int i = 0; i &lt; a0.length; i+=1) {
617       a0[i] = (a1[i]*(-VALUE));
618     }
619   }
620   static void test_mulv(double[] a0, double[] a1, double b) {
621     for (int i = 0; i &lt; a0.length; i+=1) {
622       a0[i] = (a1[i]*b);
623     }
624   }
625   static void test_mula(double[] a0, double[] a1, double[] a2) {
626     for (int i = 0; i &lt; a0.length; i+=1) {
627       a0[i] = (a1[i]*a2[i]);
628     }
629   }
630 
631   static void test_divc(double[] a0, double[] a1) {
632     for (int i = 0; i &lt; a0.length; i+=1) {
633       a0[i] = (a1[i]/VALUE);
634     }
635   }
636   static void test_divc_n(double[] a0, double[] a1) {
637     for (int i = 0; i &lt; a0.length; i+=1) {
638       a0[i] = (a1[i]/(-VALUE));
639     }
640   }
641   static void test_divv(double[] a0, double[] a1, double b) {
642     for (int i = 0; i &lt; a0.length; i+=1) {
643       a0[i] = (a1[i]/b);
644     }
645   }
646   static void test_diva(double[] a0, double[] a1, double[] a2) {
647     for (int i = 0; i &lt; a0.length; i+=1) {
648       a0[i] = (a1[i]/a2[i]);
649     }
650   }
651   static void test_negc(double[] a0, double[] a1) {
652     for (int i = 0; i &lt; a0.length; i+=1) {
653       a0[i] = (double)(-((double)a1[i]));
654     }
655   }
656 
657   static void test_rint(double[] a0, double[] a1) {
658     for (int i = 0; i &lt; a0.length; i+=1) {
659       a0[i] = Math.rint(a1[i] + ((double)(i))/1000);
660     }
661   }
662   static void test_ceil(double[] a0, double[] a1) {
663     for (int i = 0; i &lt; a0.length; i+=1) {
664       a0[i] = Math.ceil(a1[i] + ((double)(i))/1000);
665     }
666   }
667   static void test_floor(double[] a0, double[] a1) {
668     for (int i = 0; i &lt; a0.length; i+=1) {
669       a0[i] = Math.floor(a1[i] + ((double)(i))/1000);
670     }
671   }
672   static void test_rint_cc(double[] a0, double[] a1) {
673     for (int i = 0; i &lt; a0.length; i+=1) {
674       a0[i] = Math.rint(a1[i]);
675     }
676   }
677   static void test_ceil_cc(double[] a0, double[] a1) {
678     for (int i = 0; i &lt; a0.length; i+=1) {
679       a0[i] = Math.ceil(a1[i]);
680     }
681   }
682   static void test_floor_cc(double[] a0, double[] a1) {
683     for (int i = 0; i &lt; a0.length; i+=1) {
684       a0[i] = Math.floor(a1[i]);
685     }
686   }
687 
688   static void test_sqrt(double[] a0, double[] a1) {
689     for (int i = 0; i &lt; a0.length; i+=1) {
690       a0[i] = (double)(Math.sqrt((double)a1[i]));
691     }
692   }
693 
694   static int verify(String text, int i, double elem, double val) {
695     if (elem != val &amp;&amp; !(Double.isNaN(elem) &amp;&amp; Double.isNaN(val))) {
696       System.err.println(text + &quot;[&quot; + i + &quot;] = &quot; + elem + &quot; != &quot; + val);
697       return 1;
698     }
699     return 0;
700   }
701 }
    </pre>
  </body>
</html>
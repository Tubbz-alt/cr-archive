<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/containers/cgroup/CgroupSubsystemFactory.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Red Hat Inc.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test CgroupSubsystemFactory
 26  * @requires os.family == &quot;linux&quot;
 27  * @library /testlibrary /test/lib
 28  * @build sun.hotspot.WhiteBox
 29  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 30  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI CgroupSubsystemFactory
 31  */
 32 
 33 import java.io.IOException;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.Files;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 
 39 import jdk.test.lib.Asserts;
 40 import jdk.test.lib.Utils;
 41 import jdk.test.lib.util.FileUtils;
 42 import sun.hotspot.WhiteBox;
 43 
 44 /*
 45  * Verify hotspot&#39;s detection heuristics of CgroupSubsystemFactory::create()
 46  */
 47 public class CgroupSubsystemFactory {
 48 
 49     // Mirrored from src/hotspot/os/linux/cgroupSubsystem_linux.hpp
 50     private static final int CGROUPS_V1 = 1;
 51     private static final int CGROUPS_V2 = 2;
 52     private static final int INVALID_CGROUPS_V2 = 3;
 53     private static final int INVALID_CGROUPS_V1 = 4;
 54     private static final int INVALID_CGROUPS_NO_MOUNT = 5;
 55     private Path existingDirectory;
 56     private Path cgroupv1CgInfoZeroHierarchy;
 57     private Path cgroupv1MntInfoZeroHierarchy;
 58     private Path cgroupv2CgInfoZeroHierarchy;
 59     private Path cgroupv2MntInfoZeroHierarchy;
 60     private Path cgroupv1CgInfoNonZeroHierarchy;
 61     private Path cgroupv1MntInfoNonZeroHierarchyOtherOrder;
 62     private Path cgroupv1MntInfoNonZeroHierarchy;
 63     private String mntInfoEmpty = &quot;&quot;;
 64     private Path cgroupV1SelfCgroup;
 65     private Path cgroupV2SelfCgroup;
 66     private Path cgroupV2MntInfoMissingCgroupv2;
 67     private Path cgroupv1MntInfoMissingMemoryController;
 68     private String procSelfCgroupHybridContent = &quot;11:hugetlb:/\n&quot; +
 69             &quot;10:devices:/user.slice\n&quot; +
 70             &quot;9:pids:/user.slice/user-15263.slice/user@15263.service\n&quot; +
 71             &quot;8:cpu,cpuacct:/\n&quot; +
 72             &quot;7:perf_event:/\n&quot; +
 73             &quot;6:freezer:/\n&quot; +
 74             &quot;5:blkio:/\n&quot; +
 75             &quot;4:net_cls,net_prio:/\n&quot; +
 76             &quot;3:cpuset:/\n&quot; +
 77             &quot;2:memory:/user.slice/user-15263.slice/user@15263.service\n&quot; +
 78             &quot;1:name=systemd:/user.slice/user-15263.slice/user@15263.service/gnome-terminal-server.service\n&quot; +
 79             &quot;0::/user.slice/user-15263.slice/user@15263.service/gnome-terminal-server.service&quot;;
 80     private String procSelfCgroupV2UnifiedContent = &quot;0::/user.slice/user-1000.slice/session-3.scope&quot;;
 81     private String cgroupsZeroHierarchy =
 82             &quot;#subsys_name hierarchy num_cgroups enabled\n&quot; +
 83             &quot;cpuset 0 1 1\n&quot; +
 84             &quot;cpu 0 1 1\n&quot; +
 85             &quot;cpuacct 0 1 1\n&quot; +
 86             &quot;memory 0 1 1\n&quot; +
 87             &quot;devices 0 1 1\n&quot; +
 88             &quot;freezer 0 1 1\n&quot; +
 89             &quot;net_cls 0 1 1\n&quot; +
 90             &quot;blkio 0 1 1\n&quot; +
 91             &quot;perf_event 0 1 1 &quot;;
 92     private String cgroupV2LineHybrid = &quot;31 30 0:27 / /sys/fs/cgroup/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\n&quot;;
 93     private String cgroupv1MountInfoLineMemory = &quot;35 30 0:31 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\n&quot;;
 94     private String mntInfoHybridStub =
 95             &quot;30 23 0:26 / /sys/fs/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\n&quot; +
 96             &quot;32 30 0:28 / /sys/fs/cgroup/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\n&quot; +
 97             &quot;36 30 0:32 / /sys/fs/cgroup/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\n&quot; +
 98             &quot;37 30 0:33 / /sys/fs/cgroup/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\n&quot; +
 99             &quot;38 30 0:34 / /sys/fs/cgroup/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\n&quot; +
100             &quot;39 30 0:35 / /sys/fs/cgroup/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\n&quot; +
101             &quot;40 30 0:36 / /sys/fs/cgroup/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\n&quot; +
102             &quot;41 30 0:37 / /sys/fs/cgroup/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\n&quot; +
103             &quot;42 30 0:38 / /sys/fs/cgroup/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\n&quot; +
104             &quot;43 30 0:39 / /sys/fs/cgroup/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\n&quot; +
105             &quot;44 30 0:40 / /sys/fs/cgroup/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer&quot;;
106     private String mntInfoHybridRest = cgroupv1MountInfoLineMemory + mntInfoHybridStub;
107     private String mntInfoHybridMissingMemory = mntInfoHybridStub;
108     private String mntInfoHybrid = cgroupV2LineHybrid + mntInfoHybridRest;
109     private String mntInfoHybridFlippedOrder = mntInfoHybridRest + cgroupV2LineHybrid;
110     private String cgroupsNonZeroHierarchy =
111             &quot;#subsys_name hierarchy   num_cgroups enabled\n&quot; +
112             &quot;cpuset  3   1   1\n&quot; +
113             &quot;cpu 8   1   1\n&quot; +
114             &quot;cpuacct 8   1   1\n&quot; +
115             &quot;blkio   10  1   1\n&quot; +
116             &quot;memory  2   90  1\n&quot; +
117             &quot;devices 8   74  1\n&quot; +
118             &quot;freezer 11  1   1\n&quot; +
119             &quot;net_cls 5   1   1\n&quot; +
120             &quot;perf_event  4   1   1\n&quot; +
121             &quot;net_prio    5   1   1\n&quot; +
122             &quot;hugetlb 6   1   1\n&quot; +
123             &quot;pids    3   80  1&quot;;
124     private String mntInfoCgroupsV2Only =
125             &quot;28 21 0:25 / /sys/fs/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate&quot;;
126 
127     private void setup() {
128         try {
129             existingDirectory = Utils.createTempDirectory(CgroupSubsystemFactory.class.getSimpleName());
130             Path cgroupsZero = Paths.get(existingDirectory.toString(), &quot;cgroups_zero&quot;);
131             Files.writeString(cgroupsZero, cgroupsZeroHierarchy, StandardCharsets.UTF_8);
132             cgroupv1CgInfoZeroHierarchy = cgroupsZero;
133             cgroupv2CgInfoZeroHierarchy = cgroupsZero;
134             cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), &quot;mountinfo_empty&quot;);
135             Files.writeString(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty);
136 
137             cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), &quot;mountinfo_cgroupv2&quot;);
138             Files.writeString(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only);
139 
140             cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), &quot;cgroups_non_zero&quot;);
141             Files.writeString(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy);
142 
143             cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), &quot;mountinfo_non_zero&quot;);
144             Files.writeString(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid);
145 
146             cgroupv1MntInfoNonZeroHierarchyOtherOrder = Paths.get(existingDirectory.toString(), &quot;mountinfo_non_zero_cgroupv2_last&quot;);
147             Files.writeString(cgroupv1MntInfoNonZeroHierarchyOtherOrder, mntInfoHybridFlippedOrder);
148 
149             cgroupV1SelfCgroup = Paths.get(existingDirectory.toString(), &quot;cgroup_self_hybrid&quot;);
150             Files.writeString(cgroupV1SelfCgroup, procSelfCgroupHybridContent);
151 
152             cgroupV2SelfCgroup = Paths.get(existingDirectory.toString(), &quot;cgroup_self_v2&quot;);
153             Files.writeString(cgroupV2SelfCgroup, procSelfCgroupV2UnifiedContent);
154 
155             cgroupv1MntInfoMissingMemoryController = Paths.get(existingDirectory.toString(), &quot;mnt_info_missing_memory&quot;);
156             Files.writeString(cgroupv1MntInfoMissingMemoryController, mntInfoHybridMissingMemory);
157 
158             cgroupV2MntInfoMissingCgroupv2 = Paths.get(existingDirectory.toString(), &quot;mnt_info_missing_cgroup2&quot;);
159             Files.writeString(cgroupV2MntInfoMissingCgroupv2, mntInfoHybridStub);
160         } catch (IOException e) {
161             throw new RuntimeException(e);
162         }
163     }
164 
165     private void teardown() {
166         try {
167             FileUtils.deleteFileTreeWithRetry(existingDirectory);
168         } catch (IOException e) {
169             System.err.println(&quot;Teardown failed. &quot; + e.getMessage());
170         }
171     }
172 
173     private boolean isValidCgroup(int value) {
174         return value == CGROUPS_V1 || value == CGROUPS_V2;
175     }
176 
177     public void testCgroupv1NoMounts(WhiteBox wb) {
178         String procCgroups = cgroupv1CgInfoZeroHierarchy.toString();
179         String procSelfCgroup = cgroupV1SelfCgroup.toString();
180         String procSelfMountinfo = cgroupv1MntInfoZeroHierarchy.toString();
181         int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);
182         Asserts.assertEQ(INVALID_CGROUPS_NO_MOUNT, retval, &quot;No cgroups mounted in /proc/self/mountinfo. Invalid.&quot;);
183         Asserts.assertFalse(isValidCgroup(retval));
184         System.out.println(&quot;testCgroupv1NoMounts PASSED!&quot;);
185     }
186 
187     public void testCgroupv2NoCgroup2Fs(WhiteBox wb) {
188         String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();
189         String procSelfCgroup = cgroupV2SelfCgroup.toString();
190         String procSelfMountinfo = cgroupV2MntInfoMissingCgroupv2.toString();
191         int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);
192         Asserts.assertEQ(INVALID_CGROUPS_V2, retval, &quot;No cgroup2 filesystem in /proc/self/mountinfo. Invalid.&quot;);
193         Asserts.assertFalse(isValidCgroup(retval));
194         System.out.println(&quot;testCgroupv2NoCgroup2Fs PASSED!&quot;);
195     }
196 
197     public void testCgroupv1MissingMemoryController(WhiteBox wb) {
198         String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();
199         String procSelfCgroup = cgroupV1SelfCgroup.toString();
200         String procSelfMountinfo = cgroupv1MntInfoMissingMemoryController.toString();
201         int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);
202         Asserts.assertEQ(INVALID_CGROUPS_V1, retval, &quot;Required memory controller path missing in mountinfo. Invalid.&quot;);
203         Asserts.assertFalse(isValidCgroup(retval));
204         System.out.println(&quot;testCgroupv1MissingMemoryController PASSED!&quot;);
205     }
206 
207     public void testCgroupv2(WhiteBox wb) {
208         String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();
209         String procSelfCgroup = cgroupV2SelfCgroup.toString();
210         String procSelfMountinfo = cgroupv2MntInfoZeroHierarchy.toString();
211         int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);
212         Asserts.assertEQ(CGROUPS_V2, retval, &quot;Expected&quot;);
213         Asserts.assertTrue(isValidCgroup(retval));
214         System.out.println(&quot;testCgroupv2 PASSED!&quot;);
215     }
216 
217     public void testCgroupV1Hybrid(WhiteBox wb) {
218         String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();
219         String procSelfCgroup = cgroupV1SelfCgroup.toString();
220         String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchy.toString();
221         int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);
222         Asserts.assertEQ(CGROUPS_V1, retval, &quot;Hybrid cgroups expected as cgroups v1&quot;);
223         Asserts.assertTrue(isValidCgroup(retval));
224         System.out.println(&quot;testCgroupv1Hybrid PASSED!&quot;);
225     }
226 
227     public void testCgroupV1HybridMntInfoOrder(WhiteBox wb) {
228         String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();
229         String procSelfCgroup = cgroupV1SelfCgroup.toString();
230         String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchyOtherOrder.toString();
231         int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);
232         Asserts.assertEQ(CGROUPS_V1, retval, &quot;Hybrid cgroups expected as cgroups v1&quot;);
233         Asserts.assertTrue(isValidCgroup(retval));
234         System.out.println(&quot;testCgroupv1HybridMntInfoOrder PASSED!&quot;);
235     }
236 
237 
238     public static void main(String[] args) throws Exception {
239         WhiteBox wb = WhiteBox.getWhiteBox();
240         CgroupSubsystemFactory test = new CgroupSubsystemFactory();
241         test.setup();
242         try {
243             test.testCgroupv1NoMounts(wb);
244             test.testCgroupv2(wb);
245             test.testCgroupV1Hybrid(wb);
246             test.testCgroupV1HybridMntInfoOrder(wb);
247             test.testCgroupv1MissingMemoryController(wb);
248             test.testCgroupv2NoCgroup2Fs(wb);
249         } finally {
250             test.teardown();
251         }
252     }
253 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/Metaspace/DefineClass.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /**
 26  * @test
 27  * @bug 8173743
 28  * @requires vm.compMode != &quot;Xcomp&quot;
 29  * @summary Failures during class definition can lead to memory leaks in metaspace
 30  * @requires vm.opt.final.ClassUnloading
 31  * @library /test/lib
 32  * @build sun.hotspot.WhiteBox
 33  * @run main ClassFileInstaller sun.hotspot.WhiteBox
 34  *                              sun.hotspot.WhiteBox$WhiteBoxPermission
 35  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI test.DefineClass defineClass
 36  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI test.DefineClass defineSystemClass
 37  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 38  *                   -XX:+AllowParallelDefineClass
 39  *                   test.DefineClass defineClassParallel
 40  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 41  *                   -XX:-AllowParallelDefineClass
 42  *                   test.DefineClass defineClassParallel
 43  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 44  *                   -Djdk.attach.allowAttachSelf test.DefineClass redefineClass
 45  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 46  *                   -Djdk.attach.allowAttachSelf test.DefineClass redefineClassWithError
 47  * @author volker.simonis@gmail.com
 48  */
 49 
 50 package test;
 51 
 52 import java.io.ByteArrayOutputStream;
 53 import java.io.File;
 54 import java.io.FileOutputStream;
 55 import java.io.InputStream;
 56 import java.lang.instrument.ClassDefinition;
 57 import java.lang.instrument.Instrumentation;
 58 import java.util.concurrent.CountDownLatch;
 59 import java.util.jar.Attributes;
 60 import java.util.jar.JarEntry;
 61 import java.util.jar.JarOutputStream;
 62 import java.util.jar.Manifest;
 63 
 64 import com.sun.tools.attach.VirtualMachine;
 65 
 66 import jdk.test.lib.process.ProcessTools;
 67 import sun.hotspot.WhiteBox;
 68 
 69 public class DefineClass {
 70 
 71     private static Instrumentation instrumentation;
 72 
 73     public void getID(CountDownLatch start, CountDownLatch stop) {
 74         String id = &quot;AAAAAAAA&quot;;
 75         System.out.println(id);
 76         try {
 77             // Signal that we&#39;ve entered the activation..
 78             start.countDown();
 79             //..and wait until we can leave it.
 80             stop.await();
 81         } catch (InterruptedException e) {
 82             e.printStackTrace();
 83         }
 84         System.out.println(id);
 85         return;
 86     }
 87 
 88     private static class MyThread extends Thread {
 89         private DefineClass dc;
 90         private CountDownLatch start, stop;
 91 
 92         public MyThread(DefineClass dc, CountDownLatch start, CountDownLatch stop) {
 93             this.dc = dc;
 94             this.start = start;
 95             this.stop = stop;
 96         }
 97 
 98         public void run() {
 99             dc.getID(start, stop);
100         }
101     }
102 
103     private static class ParallelLoadingThread extends Thread {
104         private MyParallelClassLoader pcl;
105         private CountDownLatch stop;
106         private byte[] buf;
107 
108         public ParallelLoadingThread(MyParallelClassLoader pcl, byte[] buf, CountDownLatch stop) {
109             this.pcl = pcl;
110             this.stop = stop;
111             this.buf = buf;
112         }
113 
114         public void run() {
115             try {
116                 stop.await();
117             } catch (InterruptedException e) {
118                 e.printStackTrace();
119             }
120             try {
121                 @SuppressWarnings(&quot;unchecked&quot;)
122                 Class&lt;DefineClass&gt; dc = (Class&lt;DefineClass&gt;) pcl.myDefineClass(DefineClass.class.getName(), buf, 0, buf.length);
123             }
124             catch (LinkageError jle) {
125                 // Expected with a parallel capable class loader and
126                 // -XX:+AllowParallelDefineClass
127                 pcl.incrementLinkageErrors();
128             }
129 
130         }
131     }
132 
133     static private class MyClassLoader extends ClassLoader {
134         public Class&lt;?&gt; myDefineClass(String name, byte[] b, int off, int len) throws ClassFormatError {
135             return defineClass(name, b, off, len, null);
136         }
137     }
138 
139     static private class MyParallelClassLoader extends ClassLoader {
140         static {
141             System.out.println(&quot;parallelCapable : &quot; + registerAsParallelCapable());
142         }
143         public Class&lt;?&gt; myDefineClass(String name, byte[] b, int off, int len) throws ClassFormatError {
144             return defineClass(name, b, off, len, null);
145         }
146         public synchronized void incrementLinkageErrors() {
147             linkageErrors++;
148         }
149         public int getLinkageErrors() {
150             return linkageErrors;
151         }
152         private volatile int linkageErrors;
153     }
154 
155     public static void agentmain(String args, Instrumentation inst) {
156         System.out.println(&quot;Loading Java Agent.&quot;);
157         instrumentation = inst;
158     }
159 
160 
161     private static void loadInstrumentationAgent(String myName, byte[] buf) throws Exception {
162         // Create agent jar file on the fly
163         Manifest m = new Manifest();
164         m.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, &quot;1.0&quot;);
165         m.getMainAttributes().put(new Attributes.Name(&quot;Agent-Class&quot;), myName);
166         m.getMainAttributes().put(new Attributes.Name(&quot;Can-Redefine-Classes&quot;), &quot;true&quot;);
167         File jarFile = File.createTempFile(&quot;agent&quot;, &quot;.jar&quot;);
168         jarFile.deleteOnExit();
169         JarOutputStream jar = new JarOutputStream(new FileOutputStream(jarFile), m);
170         jar.putNextEntry(new JarEntry(myName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;));
171         jar.write(buf);
172         jar.close();
173         String pid = Long.toString(ProcessTools.getProcessId());
174         System.out.println(&quot;Our pid is = &quot; + pid);
175         VirtualMachine vm = VirtualMachine.attach(pid);
176         vm.loadAgent(jarFile.getAbsolutePath());
177     }
178 
179     private static byte[] getBytecodes(String myName) throws Exception {
180         InputStream is = DefineClass.class.getResourceAsStream(myName + &quot;.class&quot;);
181         ByteArrayOutputStream baos = new ByteArrayOutputStream();
182         byte[] buf = new byte[4096];
183         int len;
184         while ((len = is.read(buf)) != -1) baos.write(buf, 0, len);
185         buf = baos.toByteArray();
186         System.out.println(&quot;sizeof(&quot; + myName + &quot;.class) == &quot; + buf.length);
187         return buf;
188     }
189 
190     private static int getStringIndex(String needle, byte[] buf) {
191         return getStringIndex(needle, buf, 0);
192     }
193 
194     private static int getStringIndex(String needle, byte[] buf, int offset) {
195         outer:
196         for (int i = offset; i &lt; buf.length - offset - needle.length(); i++) {
197             for (int j = 0; j &lt; needle.length(); j++) {
198                 if (buf[i + j] != (byte)needle.charAt(j)) continue outer;
199             }
200             return i;
201         }
202         return 0;
203     }
204 
205     private static void replaceString(byte[] buf, String name, int index) {
206         for (int i = index; i &lt; index + name.length(); i++) {
207             buf[i] = (byte)name.charAt(i - index);
208         }
209     }
210 
211     public static WhiteBox wb = WhiteBox.getWhiteBox();
212 
213     private static void checkClasses(int expectedCount, boolean reportError) {
214         int count = wb.countAliveClasses(&quot;test.DefineClass&quot;);
215         String res = &quot;Should have &quot; + expectedCount +
216                      &quot; DefineClass instances and we have: &quot; + count;
217         System.out.println(res);
218         if (reportError &amp;&amp; count != expectedCount) {
219             throw new RuntimeException(res);
220         }
221     }
222 
223     public static final int ITERATIONS = 10;
224 
225     private static void checkClassesAfterGC(int expectedCount) {
226         // The first System.gc() doesn&#39;t clean metaspaces but triggers cleaning
227         // for the next safepoint.
228         // In the future the ServiceThread may clean metaspaces, but this loop
229         // should give it enough time to run, when that is changed.
230         // We might need to revisit this test though.
231         for (int i = 0; i &lt; ITERATIONS; i++) {
232             System.gc();
233             System.out.println(&quot;System.gc()&quot;);
234             // Break if the GC has cleaned metaspace before iterations.
235             if (wb.countAliveClasses(&quot;test.DefineClass&quot;) == expectedCount) break;
236         }
237         checkClasses(expectedCount, true);
238     }
239 
240     public static void main(String[] args) throws Exception {
241         String myName = DefineClass.class.getName();
242         byte[] buf = getBytecodes(myName.substring(myName.lastIndexOf(&quot;.&quot;) + 1));
243         int iterations = (args.length &gt; 1 ? Integer.parseInt(args[1]) : ITERATIONS);
244 
245         if (args.length == 0 || &quot;defineClass&quot;.equals(args[0])) {
246             MyClassLoader cl = new MyClassLoader();
247             for (int i = 0; i &lt; iterations; i++) {
248                 try {
249                     @SuppressWarnings(&quot;unchecked&quot;)
250                     Class&lt;DefineClass&gt; dc = (Class&lt;DefineClass&gt;) cl.myDefineClass(myName, buf, 0, buf.length);
251                     System.out.println(dc);
252                 }
253                 catch (LinkageError jle) {
254                     // Can only define once!
255                     if (i == 0) throw new Exception(&quot;Should succeed the first time.&quot;);
256                 }
257             }
258             // We expect to have two instances of DefineClass here: the initial version in which we are
259             // executing and another version which was loaded into our own classloader &#39;MyClassLoader&#39;.
260             // All the subsequent attempts to reload DefineClass into our &#39;MyClassLoader&#39; should have failed.
261             // The ClassLoaderDataGraph has the failed instances recorded at least until the next GC.
262             checkClasses(2, false);
263             // At least after some System.gc() the failed loading attempts should leave no instances around!
264             checkClassesAfterGC(2);
265         }
266         else if (&quot;defineSystemClass&quot;.equals(args[0])) {
267             MyClassLoader cl = new MyClassLoader();
268             int index = getStringIndex(&quot;test/DefineClass&quot;, buf);
269             replaceString(buf, &quot;java/DefineClass&quot;, index);
270             while ((index = getStringIndex(&quot;Ltest/DefineClass;&quot;, buf, index + 1)) != 0) {
271                 replaceString(buf, &quot;Ljava/DefineClass;&quot;, index);
272             }
273             index = getStringIndex(&quot;test.DefineClass&quot;, buf);
274             replaceString(buf, &quot;java.DefineClass&quot;, index);
275 
276             for (int i = 0; i &lt; iterations; i++) {
277                 try {
278                     @SuppressWarnings(&quot;unchecked&quot;)
279                     Class&lt;DefineClass&gt; dc = (Class&lt;DefineClass&gt;) cl.myDefineClass(null, buf, 0, buf.length);
280                     throw new RuntimeException(&quot;Defining a class in the &#39;java&#39; package should fail!&quot;);
281                 }
282                 catch (java.lang.SecurityException jlse) {
283                     // Expected, because we&#39;re not allowed to define a class in the &#39;java&#39; package
284                 }
285             }
286             // We expect to stay with one (the initial) instances of DefineClass.
287             // All the subsequent attempts to reload DefineClass into the &#39;java&#39; package should have failed.
288             // The ClassLoaderDataGraph has the failed instances recorded at least until the next GC.
289             checkClasses(1, false);
290             checkClassesAfterGC(1);
291         }
292         else if (&quot;defineClassParallel&quot;.equals(args[0])) {
293             MyParallelClassLoader pcl = new MyParallelClassLoader();
294             CountDownLatch stop = new CountDownLatch(1);
295 
296             Thread[] threads = new Thread[iterations];
297             for (int i = 0; i &lt; iterations; i++) {
298                 (threads[i] = new ParallelLoadingThread(pcl, buf, stop)).start();
299             }
300             stop.countDown(); // start parallel class loading..
301             // ..and wait until all threads loaded the class
302             for (int i = 0; i &lt; iterations; i++) {
303                 threads[i].join();
304             }
305             System.out.print(&quot;Counted &quot; + pcl.getLinkageErrors() + &quot; LinkageErrors &quot;);
306             System.out.println(pcl.getLinkageErrors() == 0 ?
307                     &quot;&quot; : &quot;(use -XX:+AllowParallelDefineClass to avoid this)&quot;);
308             // After System.gc() we expect to remain with two instances: one is the initial version which is
309             // kept alive by this main method and another one in the parallel class loader.
310             checkClassesAfterGC(2);
311         }
312         else if (&quot;redefineClass&quot;.equals(args[0])) {
313             loadInstrumentationAgent(myName, buf);
314             int index = getStringIndex(&quot;AAAAAAAA&quot;, buf);
315             CountDownLatch stop = new CountDownLatch(1);
316 
317             Thread[] threads = new Thread[iterations];
318             for (int i = 0; i &lt; iterations; i++) {
319                 buf[index] = (byte) (&#39;A&#39; + i + 1); // Change string constant in getID() which is legal in redefinition
320                 instrumentation.redefineClasses(new ClassDefinition(DefineClass.class, buf));
321                 DefineClass dc = DefineClass.class.newInstance();
322                 CountDownLatch start = new CountDownLatch(1);
323                 (threads[i] = new MyThread(dc, start, stop)).start();
324                 start.await(); // Wait until the new thread entered the getID() method
325             }
326             // We expect to have one instance for each redefinition because they are all kept alive by an activation
327             // plus the initial version which is kept active by this main method.
328             checkClasses(iterations + 1, true);
329             stop.countDown(); // Let all threads leave the DefineClass.getID() activation..
330             // ..and wait until really all of them returned from DefineClass.getID()
331             for (int i = 0; i &lt; iterations; i++) {
332                 threads[i].join();
333             }
334             // After System.gc() we expect to remain with two instances: one is the initial version which is
335             // kept alive by this main method and another one which is the latest redefined version.
336             checkClassesAfterGC(2);
337         }
338         else if (&quot;redefineClassWithError&quot;.equals(args[0])) {
339             loadInstrumentationAgent(myName, buf);
340             int index = getStringIndex(&quot;getID&quot;, buf);
341 
342             for (int i = 0; i &lt; iterations; i++) {
343                 buf[index] = (byte) &#39;X&#39;; // Change getID() to XetID() which is illegal in redefinition
344                 try {
345                     instrumentation.redefineClasses(new ClassDefinition(DefineClass.class, buf));
346                     throw new RuntimeException(&quot;Class redefinition isn&#39;t allowed to change method names!&quot;);
347                 }
348                 catch (UnsupportedOperationException uoe) {
349                     // Expected because redefinition can&#39;t change the name of methods
350                 }
351             }
352             // We expect just a single DefineClass instance because failed redefinitions should
353             // leave no garbage around.
354             // The ClassLoaderDataGraph has the failed instances recorded at least until the next GC.
355             checkClasses(1, false);
356             // At least after a System.gc() we should definitely stay with a single instance!
357             checkClassesAfterGC(1);
358         }
359     }
360 }
    </pre>
  </body>
</html>
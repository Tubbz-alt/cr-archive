<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/NMT/CommitOverlappingRegions.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Test commits of overlapping regions of memory.
 27  * @key nmt jcmd
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  *          java.management
 31  * @build sun.hotspot.WhiteBox
 32  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 33  *                              sun.hotspot.WhiteBox$WhiteBoxPermission
 34  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail CommitOverlappingRegions
 35  */
 36 
 37 import jdk.test.lib.process.ProcessTools;
 38 import jdk.test.lib.process.OutputAnalyzer;
 39 import jdk.test.lib.JDKToolFinder;
 40 import sun.hotspot.WhiteBox;
 41 
 42 public class CommitOverlappingRegions {
 43     public static WhiteBox wb = WhiteBox.getWhiteBox();
 44     public static void main(String args[]) throws Exception {
 45         OutputAnalyzer output;
 46 
 47         long size = 32 * 1024;
 48         int pagesize = wb.getVMPageSize();
 49         if (size &lt; pagesize) { size = pagesize; }  // Should be aligned.
 50         long sizek = size / 1024;
 51 
 52         long addr = wb.NMTReserveMemory(8*size);
 53 
 54         String pid = Long.toString(ProcessTools.getProcessId());
 55         ProcessBuilder pb = new ProcessBuilder();
 56 
 57         pb.command(new String[] { JDKToolFinder.getJDKTool(&quot;jcmd&quot;), pid, &quot;VM.native_memory&quot;, &quot;detail&quot;});
 58         System.out.println(&quot;Address is &quot; + Long.toHexString(addr));
 59 
 60         // Start: . . . . . . . .
 61         output = new OutputAnalyzer(pb.start());
 62         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=0KB)&quot;);
 63 
 64         // Committing: * * * . . . . .
 65         // Region:     * * * . . . . .
 66         // Expected Total: 3 x sizek KB
 67         wb.NMTCommitMemory(addr + 0*size, 3*size);
 68 
 69         // Committing: . . . . * * * .
 70         // Region:     * * * . * * * .
 71         // Expected Total: 6 x sizek KB
 72         wb.NMTCommitMemory(addr + 4*size, 3*size);
 73 
 74         // Check output after first 2 commits.
 75         output = new OutputAnalyzer(pb.start());
 76         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=&quot; + 6*sizek + &quot;KB)&quot;);
 77 
 78         // Committing: . . * * * . . .
 79         // Region:     * * * * * * * .
 80         // Expected Total: 7 x sizek KB
 81         wb.NMTCommitMemory(addr + 2*size, 3*size);
 82 
 83         // Check output after overlapping commit.
 84         output = new OutputAnalyzer(pb.start());
 85         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=&quot; + 7*sizek + &quot;KB)&quot;);
 86 
 87         // Uncommitting: * * * * * * * *
 88         // Region:       . . . . . . . .
 89         // Expected Total: 0 x sizek KB
 90         wb.NMTUncommitMemory(addr + 0*size, 8*size);
 91         output = new OutputAnalyzer(pb.start());
 92         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=0KB)&quot;);
 93 
 94         // Committing: * * . . . . . .
 95         // Region:     * * . . . . . .
 96         // Expected Total: 2 x sizek KB
 97         wb.NMTCommitMemory(addr + 0*size, 2*size);
 98         output = new OutputAnalyzer(pb.start());
 99         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=&quot; + 2*sizek + &quot;KB)&quot;);
100 
101         // Committing: . * * * . . . .
102         // Region:     * * * * . . . .
103         // Expected Total: 4 x sizek KB
104         wb.NMTCommitMemory(addr + 1*size, 3*size);
105         output = new OutputAnalyzer(pb.start());
106         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=&quot; + 4*sizek + &quot;KB)&quot;);
107 
108         // Uncommitting: * * * . . . . .
109         // Region:       . . . * . . . .
110         // Expected Total: 1 x sizek KB
111         wb.NMTUncommitMemory(addr + 0*size, 3*size);
112         output = new OutputAnalyzer(pb.start());
113         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=&quot; + 1*sizek + &quot;KB)&quot;);
114 
115         // Committing: . . . * * . . .
116         // Region:     . . . * * . . .
117         // Expected Total: 2 x sizek KB
118         wb.NMTCommitMemory(addr + 3*size, 2*size);
119         System.out.println(&quot;Address is &quot; + Long.toHexString(addr + 3*size));
120         output = new OutputAnalyzer(pb.start());
121         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=&quot; + 2*sizek + &quot;KB)&quot;);
122 
123         // Committing: . . . . * * . .
124         // Region:     . . . * * * . .
125         // Expected Total: 3 x sizek KB
126         wb.NMTCommitMemory(addr + 4*size, 2*size);
127         output = new OutputAnalyzer(pb.start());
128         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=&quot; + 3*sizek + &quot;KB)&quot;);
129 
130         // Committing: . . . . . * * .
131         // Region:     . . . * * * * .
132         // Expected Total: 4 x sizek KB
133         wb.NMTCommitMemory(addr + 5*size, 2*size);
134         output = new OutputAnalyzer(pb.start());
135         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=&quot; + 4*sizek + &quot;KB)&quot;);
136 
137         // Committing: . . . . . . * *
138         // Region:     . . . * * * * *
139         // Expected Total: 5 x sizek KB
140         wb.NMTCommitMemory(addr + 6*size, 2*size);
141         output = new OutputAnalyzer(pb.start());
142         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=&quot; + 5*sizek + &quot;KB)&quot;);
143 
144         // Uncommitting: * * * * * * * *
145         // Region:       . . . . . . . .
146         // Expected Total: 0 x sizek KB
147         wb.NMTUncommitMemory(addr + 0*size, 8*size);
148         output = new OutputAnalyzer(pb.start());
149         output.shouldContain(&quot;Test (reserved=&quot; + 8*sizek + &quot;KB, committed=0KB)&quot;);
150     }
151 }
    </pre>
  </body>
</html>
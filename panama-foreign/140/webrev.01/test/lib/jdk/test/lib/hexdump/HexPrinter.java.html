<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/lib/jdk/test/lib/hexdump/HexPrinter.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package jdk.test.lib.hexdump;
  25 
  26 import java.io.BufferedInputStream;
  27 import java.io.ByteArrayInputStream;
  28 import java.io.CharArrayWriter;
  29 import java.io.DataInputStream;
  30 import java.io.EOFException;
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.PrintStream;
  34 import java.io.UncheckedIOException;
  35 import java.io.Writer;
  36 import java.nio.ByteBuffer;
  37 import java.util.Objects;
  38 
  39 /**
  40  * Decode a sequence of bytes to a readable format.
  41  * &lt;p&gt;
  42  * The predefined formats are:
  43  * &lt;DL&gt;
  44  * &lt;DT&gt;{@link #minimal() Minimal format}:  {@code &quot;Now is the time for Java.\n&quot;}&lt;/DT&gt;
  45  * &lt;DD&gt;&lt;pre&gt;    {@code
  46  *     4e6f77206973207468652074696d6520666f72204a6176612e0a} &lt;/pre&gt;
  47  * &lt;/DD&gt;
  48  *
  49  * &lt;DT&gt;{@link #simple() Simple format}: {@code &quot;Now is the time for Java.\n&quot;}&lt;/DT&gt;
  50  * &lt;DD&gt;&lt;pre&gt;{@code
  51  *     0: 4e 6f 77 20 69 73 20 74 68 65 20 74 69 6d 65 20  // Now is the time for Java.\n
  52  *    16: 66 6f 72 20 4a 61 76 61 2e 0a} &lt;/pre&gt;
  53  * &lt;/DD&gt;
  54  *
  55  * &lt;DT&gt;{@link #canonical() Canonical format}: {@code &quot;Now is the time for Java.\n&quot;}&lt;/DT&gt;
  56  * &lt;DD&gt;&lt;pre&gt;{@code
  57  *     00000000  4e 6f 77 20 69 73 20 74 68 65 20 74 69 6d 65 20 |Now is the time |
  58  *     00000010  66 6f 72 20 4a 61 76 61 2e 0a                   |for Java.|} &lt;/pre&gt;
  59  * &lt;/DD&gt;
  60  * &lt;DT&gt;{@link #source() Byte array initialization source}: {@code &quot;Now is the time for Java.\n&quot;}&lt;/DT&gt;
  61  * &lt;DD&gt;&lt;pre&gt;{@code
  62  *     (byte) 78, (byte)111, (byte)119, (byte) 32, (byte)105, (byte)115, (byte) 32, (byte)116,  // Now is t
  63  *     (byte)104, (byte)101, (byte) 32, (byte)116, (byte)105, (byte)109, (byte)101, (byte) 32,  // he time
  64  *     (byte)102, (byte)111, (byte)114, (byte) 32, (byte) 74, (byte) 97, (byte)118, (byte) 97,  // for Java
  65  *     (byte) 46, (byte) 10,                                                                    // .\n}&lt;/pre&gt;
  66  * &lt;/DD&gt;
  67  * &lt;/DL&gt;
  68  * &lt;p&gt;
  69  * The static factories {@link #minimal minimal}, {@link #simple simple},
  70  * {@link #canonical canonical}, and {@link #source() Java source}
  71  * return predefined {@code HexPrinter}s for the formats above.
  72  * HexPrinter holds the formatting parameters that control the width and formatting
  73  * of each of the offset, byte values, and formatted output.
  74  * New HexPrinters with different parameters are created using an existing HexPrinter
  75  * as a template with the methods {@link #formatter(Formatter)},
  76  * {@link #withBytesFormat(String, int)}, {@link #withOffsetFormat(String)},
  77  * and {@link #withLineSeparator(String)}.
  78  * &lt;p&gt;
  79  * The source of the bytes includes byte arrays, InputStreams, and ByteBuffers.
  80  * For example, {@link #toString(InputStream)} reads the input and returns a String.
  81  * Each of the {@code toString(...)} methods immediately reads and
  82  * formats all of the bytes from the source and returns a String.
  83  * &lt;p&gt;
  84  * Each of the  {@code format(...)} methods immediately reads and
  85  * formats all of the bytes from the source and appends it to the destination.
  86  * For example, {@link #format(InputStream)} reads the input and
  87  * appends the output to {@link System#out System.out} unless the
  88  * {@link #dest(Appendable) destination} is changed to an {@link Appendable}
  89  * such as {@link PrintStream}, {@link StringBuilder}, or {@link Writer}.
  90  * &lt;p&gt;
  91  * {@linkplain Formatter Formatter} functions read and interpret the bytes to show the
  92  * structure and content of a protocol or data stream.
  93  * Built-in formatters include {@link HexPrinter#formatter(Class, String) primitives},
  94  * {@link Formatters#PRINTABLE printable ascii},
  95  * and {@link Formatters#utf8Parser(DataInputStream, Appendable) UTF-8 strings}.
  96  * The {@link #formatter(Formatter, String, int) formatter} method sets the
  97  * formatting function, the delimiter, and the width.
  98  * Custom formatter functions can be implemented as a lambda, a method, an inner class, or a concrete class.
  99  * &lt;p&gt;
 100  * The format of each line is customizable.
 101  * The {@link #withOffsetFormat(String) withOffsetFormat} method controls
 102  * the format of the byte offset.
 103  * The {@link #withBytesFormat(String, int) withBytesFormat} method controls
 104  * the printing of each byte value including the separator,
 105  * and the maximum number of byte values per line.
 106  * The offset and byte values are formatted using the familiar
 107  * {@link String#format String formats} with spacing
 108  * and delimiters included in the format string.
 109  * The {@link #withLineSeparator(String) withLineSeparator} method sets
 110  * the line separator.
 111  * &lt;p&gt;
 112  * Examples:
 113  * &lt;UL&gt;
 114  * &lt;LI&gt; Encoding bytes to a minimal string.
 115  * &lt;pre&gt;{@code
 116  * byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 117  * String s = HexPrinter.minimal().toString(bytes);
 118  * Result: &quot;2041420a&quot;
 119  * }&lt;/pre&gt;
 120  * &lt;LI&gt;Simple formatting of a byte array.
 121  * &lt;pre&gt;{@code
 122  * byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 123  * String s = HexPrinter.simple().toString(bytes);
 124  * Result:    0: 20 41 42 0a                                      //  AB\n
 125  * }&lt;/pre&gt;
 126  * &lt;LI&gt;Simple formatting of a ByteBuffer.
 127  * &lt;pre&gt;{@code
 128  * ByteBuffer bb = ByteBuffer.wrap(bytes);
 129  * String s = HexPrinter.simple().toString(bb);
 130  * Result:    0: 20 41 42 0a                                      //  AB\n
 131  * }&lt;/pre&gt;
 132  * &lt;LI&gt;Simple formatting of ranges of a byte array to System.err.
 133  * &lt;pre&gt;{@code
 134  * byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, 0x43, 0x44, &#39;\n&#39;};
 135  * HexPrinter hex = HexPrinter.simple()
 136  *                            .dest(System.err);
 137  *                            .format(bytes, 1, 2)
 138  *                            .format(bytes, 3, 2);
 139  * Result:
 140  * 1: 41 42                                            // AB
 141  * 3: 43 44                                            // CD
 142  * }&lt;/pre&gt;
 143  * &lt;/UL&gt;
 144  * &lt;p&gt;
 145  * This is a &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;
 146  * class; use of identity-sensitive operations (including reference equality
 147  * ({@code ==}), identity hash code, or synchronization) on instances
 148  * may have unpredictable results and should be avoided.
 149  * The {@code equals} method should be used for comparisons.
 150  *
 151  * &lt;p&gt;
 152  * This class is immutable and thread-safe.
 153  */
 154 public final class HexPrinter {
 155 
 156     /**
 157      * Mnemonics for control characters.
 158      */
 159     static final String[] CONTROL_MNEMONICS = {
 160             &quot;nul&quot;, &quot;soh&quot;, &quot;stx&quot;, &quot;etx&quot;, &quot;eot&quot;, &quot;enq&quot;, &quot;ack&quot;, &quot;bel&quot;,
 161             &quot;b&quot;, &quot;t&quot;, &quot;n&quot;, &quot;vt&quot;, &quot;f&quot;, &quot;r&quot;, &quot;so&quot;, &quot;si&quot;,
 162             &quot;dle&quot;, &quot;dc1&quot;, &quot;dc2&quot;, &quot;dc3&quot;, &quot;dc4&quot;, &quot;nak&quot;, &quot;syn&quot;, &quot;etb&quot;,
 163             &quot;can&quot;, &quot;em&quot;, &quot;sub&quot;, &quot;esc&quot;, &quot;fs&quot;, &quot;gs&quot;, &quot;rs&quot;, &quot;us&quot;
 164     };
 165     private static final String initOffsetFormat = &quot;%5d: &quot;;
 166     private static final int initBytesCount = 16;   // 16 byte values
 167     private static final String initBytesFormat = &quot;%02x &quot;;
 168     private static final int initAnnoWidth = initBytesCount * 4;
 169     private static final String initAnnoDelim = &quot; // &quot;;
 170 
 171     final Appendable dest;              // Final output target
 172     final String offsetFormat;          // Byte offset Formatter String
 173     final String bytesFormat;           // Hex bytes Formatter string
 174     final int bytesCount;               // Maximum number of byte values per line
 175     final String annoDelim;             // Annotation delimiter
 176     final int annoWidth;                // Annotation field width (characters)
 177     final String lineSeparator;         // End of line separator
 178     final Formatter annoFormatter;      // formatter function
 179 
 180     /**
 181      * Construct a new HexPrinter with all new values.
 182      *
 183      * @param printer       the formatter
 184      * @param offsetFormat  the offset format
 185      * @param bytesFormat   the bytes format
 186      * @param bytesCount    the count of bytes per line
 187      * @param annoDelim     the delimiter before the annotation
 188      * @param annoWidth     the width of the annotation
 189      * @param lineSeparator the line separator
 190      * @param dest          the destination
 191      */
 192     private HexPrinter(Formatter printer, String offsetFormat, String bytesFormat, int bytesCount,
 193                        String annoDelim, int annoWidth,
 194                        String lineSeparator, Appendable dest) {
 195         this.annoFormatter = Objects.requireNonNull(printer, &quot;formatter&quot;);
 196         this.bytesCount = bytesCount;
 197         this.bytesFormat = Objects.requireNonNull(bytesFormat, bytesFormat);
 198         this.offsetFormat = Objects.requireNonNull(offsetFormat, &quot;offsetFormat&quot;);
 199         this.annoDelim = Objects.requireNonNull(annoDelim, &quot;annoDelim&quot;);
 200         this.annoWidth = annoWidth;
 201         this.lineSeparator = Objects.requireNonNull(lineSeparator, &quot;lineSeparator&quot;);
 202         this.dest = Objects.requireNonNull(dest, &quot;dest&quot;);
 203     }
 204 
 205     /**
 206      * Returns a new HexPrinter setting the parameters to produce a minimal string.
 207      * The parameters are set to:
 208      * &lt;UL&gt;
 209      * &lt;LI&gt;byte offset format: none {@code &quot;&quot;},
 210      * &lt;LI&gt;each byte value is formatted as 2 hex digits: {@code &quot;%02x&quot;},
 211      * &lt;LI&gt;maximum number of byte values per line: unbounded,
 212      * &lt;LI&gt;delimiter for the annotation: none {@code &quot;&quot;},
 213      * &lt;LI&gt;formatter: {@link Formatters#NONE does not output a formatted byte}, and
 214      * &lt;LI&gt;destination: {@link System#out System.out}.
 215      * &lt;/UL&gt;
 216      * Example,
 217      * &lt;pre&gt;
 218      * {@code     byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 219      *     String s = HexPrinter.minimal()
 220      *             .toString(bytes);
 221      *     Result: &quot;2041420a&quot;
 222      * }&lt;/pre&gt;
 223      *
 224      * @return a new HexPrinter
 225      */
 226     public static HexPrinter minimal() {
 227         return new HexPrinter(Formatters.NONE, &quot;&quot;,
 228                 &quot;%02x&quot;, initBytesCount,
 229                 &quot;&quot;, initAnnoWidth, &quot;&quot;,
 230                 System.out);
 231     }
 232 
 233     /**
 234      * Returns a new HexPrinter setting the parameters to produce canonical output.
 235      * The parameters are set to:
 236      * &lt;UL&gt;
 237      * &lt;LI&gt;byte offset format: {@code &quot;%08x  &quot;},
 238      * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
 239      * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
 240      * &lt;LI&gt;delimiter for the annotation: {@code &quot;|&quot;},
 241      * &lt;LI&gt;formatter: {@link Formatters#ASCII ASCII bytes}, and
 242      * &lt;LI&gt;line separator: &quot;|&quot; + {@link  System#lineSeparator()},
 243      * &lt;LI&gt;destination: {@link System#out System.out}.
 244      * &lt;/UL&gt;
 245      * Example,
 246      * &lt;pre&gt;
 247      * {@code     byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 248      *     String s = HexPrinter.canonical()
 249      *             .toString(bytes);
 250      *
 251      *     Result: &quot;00000000  20 41 42 0a                                     | AB|&quot;
 252      * }&lt;/pre&gt;
 253      *
 254      * @return a new HexPrinter
 255      */
 256     public static HexPrinter canonical() {
 257         return new HexPrinter(Formatters.ASCII, &quot;%08x  &quot;,
 258                 &quot;%02x &quot;, initBytesCount,
 259                 &quot;|&quot;, 31, &quot;|&quot; + System.lineSeparator(),
 260                 System.out);
 261     }
 262 
 263     /**
 264      * Returns a new HexPrinter setting simple formatting parameters to output
 265      * to a multi-line string.
 266      * The parameters are set to:
 267      * &lt;UL&gt;
 268      * &lt;LI&gt;byte offset format: signed decimal width 5 and a space, {@code &quot;%5d: &quot;},
 269      * &lt;LI&gt;each byte value is formatted as 2 hex digits and a space: {@code &quot;%02x &quot;},
 270      * &lt;LI&gt;maximum number of byte values per line: {@value initBytesCount},
 271      * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
 272      * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
 273      * &lt;LI&gt;line separator: {@link System#lineSeparator()},
 274      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable ASCII}
 275      * showing printable characters, mnemonics for control chars, and
 276      * otherwise the decimal byte values,
 277      * &lt;LI&gt;destination default: {@link System#out System.out}.
 278      * &lt;/UL&gt;
 279      * Example,
 280      * &lt;pre&gt;
 281      * {@code    byte[] bytes = new byte[] { &#39; &#39;, 0x41, 0x42, &#39;\n&#39;};
 282      *    String s = HexPrinter.simple()
 283      *            .toString(bytes);
 284      *
 285      *    Result: &quot;    0: 20 41 42 0a                                      //  AB\n&quot;
 286      * }&lt;/pre&gt;
 287      *
 288      * @return a new HexPrinter
 289      */
 290     public static HexPrinter simple() {
 291         return new HexPrinter(Formatters.PRINTABLE, initOffsetFormat,
 292                 initBytesFormat, initBytesCount,
 293                 initAnnoDelim, initAnnoWidth, System.lineSeparator(),
 294                 System.out);
 295     }
 296 
 297     /**
 298      * Returns a new HexPrinter setting formatting parameters to output
 299      * to a multi-line string as a byte array initialization for Java source.
 300      * The parameters are set to:
 301      * &lt;UL&gt;
 302      * &lt;LI&gt;byte offset format: 4 space indent: {@code &quot;    &quot;},
 303      * &lt;LI&gt;each byte value is formatted as: {@code &quot;(byte)%3d, &quot;},
 304      * &lt;LI&gt;maximum number of byte values per line: {@code 8},
 305      * &lt;LI&gt;delimiter for the annotation: {@code &quot; // &quot;},
 306      * &lt;LI&gt;width for the annotation: {@value initAnnoWidth},
 307      * &lt;LI&gt;line separator: {@link System#lineSeparator()},
 308      * &lt;LI&gt;formatter: {@link Formatters#PRINTABLE printable ASCII}
 309      * showing printable characters, mnemonics for control chars, and
 310      * otherwise the decimal byte values,
 311      * &lt;LI&gt;destination default: {@link System#out System.out}.
 312      * &lt;/UL&gt;
 313      *
 314      * @return a new HexPrinter
 315      */
 316     public static HexPrinter source() {
 317         return new HexPrinter(Formatters.PRINTABLE, &quot;    &quot;,
 318                 &quot;(byte)%3d, &quot;, 8,
 319                 &quot; // &quot;, initAnnoWidth, System.lineSeparator(),
 320                 System.out);
 321     }
 322 
 323     /**
 324      * Returns a new HexPrinter setting the destination to the Appendable.
 325      * {@code Appendable} classes include: {@link PrintStream}, {@link Writer},
 326      * {@link StringBuilder}, and {@link StringBuffer}.
 327      *
 328      * @param dest the Appendable destination for the output, non-null
 329      * @return a new HexPrinter
 330      * @throws UncheckedIOException if an I/O error occurs
 331      */
 332     public HexPrinter dest(Appendable dest) {
 333         Objects.requireNonNull(dest, &quot;dest&quot;);
 334         return new HexPrinter(annoFormatter, offsetFormat,
 335                 bytesFormat, bytesCount, annoDelim,
 336                 annoWidth, lineSeparator, dest);
 337     }
 338 
 339     /**
 340      * The formatter function is called repeatedly to read all of the bytes
 341      * and append the output.
 342      * All output is appended and flushed to the destination.
 343      * &lt;p&gt;
 344      * The result is equivalent to calling
 345      * {@code format(new ByteArrayInputStream(source))}.
 346      *
 347      * @param source a non-null array of bytes.
 348      * @return this HexPrinter
 349      * @throws java.io.UncheckedIOException if an I/O error occurs
 350      */
 351     public HexPrinter format(byte[] source) {
 352         Objects.requireNonNull(source, &quot;byte array must be non-null&quot;);
 353         return format(new ByteArrayInputStream(source));
 354     }
 355 
 356     /**
 357      * The formatter function is called repeatedly to read the bytes from offset
 358      * for length and append the output.
 359      * All output is appended and flushed to the destination.
 360      * Only {@code length} bytes starting at the {@code offset} are formatted.
 361      * &lt;p&gt;
 362      * The result is equivalent to calling
 363      * {@code format(new ByteArrayInputStream(source, offset, len))}.
 364      *
 365      * @param source a non-null array of bytes.
 366      * @param offset the offset into the array to start
 367      * @param length the length of bytes in the array to format
 368      * @return this HexPrinter
 369      * @throws java.io.UncheckedIOException if an I/O error occurs
 370      */
 371     public HexPrinter format(byte[] source, int offset, int length) {
 372         Objects.requireNonNull(source, &quot;byte array must be non-null&quot;);
 373         return format(new ByteArrayInputStream(source, offset, length), offset);
 374     }
 375 
 376     /**
 377      * The formatter function is called repeatedly to read all of the bytes
 378      * and append the output.
 379      * All output is appended and flushed to the destination.
 380      * &lt;p&gt;
 381      * The {@code format} method invokes the {@code formatter} to read bytes from the
 382      * source and append the formatted sequence of byte values to the destination.
 383      * As the bytes are read they are printed using the {@link #withBytesFormat}
 384      * to fill the bytes values of the output destination.
 385      * The output of the {@code formatter} fills the annotation field.
 386      * A new line is started when either the byte values or annotation
 387      * is filled to its respective width. The offset of the first byte on the line
 388      * is inserted at the beginning of each line using {@link #withOffsetFormat(String)}.
 389      * &lt;p&gt;
 390      * This method may block indefinitely reading from the input stream,
 391      * or writing to the output stream. The behavior for the case where
 392      * the input and/or output stream is asynchronously closed,
 393      * or the thread interrupted during the transfer, is highly input
 394      * and output stream specific, and therefore not specified.
 395      * &lt;p&gt;
 396      * If an I/O error occurs reading from the input stream or
 397      * writing to the output stream, then it may do so after some bytes
 398      * have been read or written. Consequently the input stream
 399      * may not be at end of stream and one, or both, streams may be
 400      * in an inconsistent state. It is strongly recommended that both streams
 401      * be promptly closed if an I/O error occurs.
 402      *
 403      * @param source an InputStream to read from, the stream not closed and
 404      *               is at end-of-file.
 405      * @return this HexPrinter
 406      * @throws java.io.UncheckedIOException if an I/O error occurs
 407      */
 408     public HexPrinter format(InputStream source) {
 409         return format(source, 0);
 410     }
 411 
 412     /**
 413      * Format an InputStream and supply the initial offset.
 414      *
 415      * @param source an InputStream
 416      * @param offset an offset
 417      * @return this HexPrinter
 418      */
 419     private HexPrinter format(InputStream source, int offset) {
 420         Objects.requireNonNull(source, &quot;InputStream must be non-null&quot;);
 421         try (AnnotationWriter writer =
 422                      new AnnotationWriter(this, source, offset, dest)) {
 423             writer.flush();
 424             return this;
 425         }
 426     }
 427 
 428     /**
 429      * The formatter function is called repeatedly to read the bytes
 430      * from the offset for the length and append the output.
 431      * All annotation output is appended and flushed to the output destination.
 432      * The ByteBuffer position and limit are unused and not modified.
 433      *
 434      * @param source a ByteBuffer
 435      * @param offset the offset in the ByteBuffer
 436      * @param length the length in the ByteBuffer
 437      * @return this HexPrinter
 438      * @throws java.io.UncheckedIOException if an I/O error occurs
 439      */
 440     public HexPrinter format(ByteBuffer source, int offset, int length) {
 441         Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
 442         ByteArrayInputStream bais;
 443         if (source.hasArray() &amp;&amp; !source.isReadOnly()) {
 444             bais = new ByteArrayInputStream(source.array(), offset, length);
 445         } else {
 446             int size = source.limit() - source.position();
 447             byte[] bytes = new byte[size];
 448             source.get(bytes, offset, length);
 449             bais = new ByteArrayInputStream(bytes);
 450         }
 451         return format(bais, offset);
 452     }
 453 
 454     /**
 455      * The formatter function is called repeatedly to read all of the bytes
 456      * in the source and append the output.
 457      * The source bytes are from the {@code ByteBuffer.position()}
 458      * to the {@code ByteBuffer.limit()}.
 459      * The position is not modified.
 460      * All output is appended and flushed to the destination.
 461      *
 462      * @param source a ByteBuffer
 463      * @return this HexPrinter
 464      * @throws java.io.UncheckedIOException if an I/O error occurs
 465      */
 466     public HexPrinter format(ByteBuffer source) {
 467         return format(source, source.position(), source.limit());
 468     }
 469 
 470     /**
 471      * The formatter function is called repeatedly to read all of the bytes
 472      * and return a String.
 473      *
 474      * @param source a non-null array of bytes.
 475      * @return the output as a non-null {@code String}
 476      * @throws java.io.UncheckedIOException if an I/O error occurs
 477      */
 478     public String toString(byte[] source) {
 479         Objects.requireNonNull(source, &quot;byte array must be non-null&quot;);
 480         return toString(new ByteArrayInputStream(source));
 481     }
 482 
 483     /**
 484      * The formatter function is called repeatedly to read the bytes from offset
 485      * for length and return a String.
 486      * Only {@code length} bytes starting at the {@code offset} are formatted.
 487      *
 488      * @param source a non-null array of bytes.
 489      * @param offset the offset into the array to start
 490      * @param length the length of bytes in the array to format
 491      * @return the output as a non-null {@code String}
 492      * @throws java.io.UncheckedIOException if an I/O error occurs
 493      */
 494     public String toString(byte[] source, int offset, int length) {
 495         Objects.requireNonNull(source, &quot;byte array must be non-null&quot;);
 496         StringBuilder sb = new StringBuilder();
 497         try (AnnotationWriter writer =
 498                      new AnnotationWriter(this, new ByteArrayInputStream(source, offset, length),
 499                              offset, sb)) {
 500             writer.flush();
 501             return sb.toString();
 502         }
 503     }
 504 
 505     /**
 506      * The formatter function is called repeatedly to read all of the bytes
 507      * and return a String.
 508      * &lt;p&gt;
 509      * The {@code toString} method invokes the formatter to read bytes from the
 510      * source and append the formatted sequence of byte values.
 511      * As the bytes are read they are printed using the {@link #withBytesFormat}
 512      * to fill the second field of the line.
 513      * The output of the {@code formatter} fills the annotation field.
 514      * A new line is started when either the byte values or annotation
 515      * is filled to its respective width. The offset of the first byte on the line
 516      * is inserted at the beginning of each line using {@link #withOffsetFormat(String)}.
 517      * &lt;p&gt;
 518      * This method may block indefinitely reading from the input stream,
 519      * or writing to the output stream. The behavior for the case where
 520      * the input and/or output stream is asynchronously closed,
 521      * or the thread interrupted during the transfer, is highly input
 522      * and output stream specific, and therefore not specified.
 523      * &lt;p&gt;
 524      * If an I/O error occurs reading from the input stream or
 525      * writing to the output stream, then it may do so after some bytes
 526      * have been read or written. Consequently the input stream
 527      * may not be at end of stream and one, or both, streams may be
 528      * in an inconsistent state. It is strongly recommended that both streams
 529      * be promptly closed if an I/O error occurs.
 530      *
 531      * @param source an InputStream to read from, the stream not closed and
 532      *               is at end-of-file upon return.
 533      * @return the output as a non-null {@code String}
 534      * @throws java.io.UncheckedIOException if an I/O error occurs
 535      */
 536     public String toString(InputStream source) {
 537         Objects.requireNonNull(source, &quot;InputStream must be non-null&quot;);
 538         StringBuilder sb = new StringBuilder();
 539         try (AnnotationWriter writer =
 540                      new AnnotationWriter(this, source, 0, sb)) {
 541             writer.flush();
 542             return sb.toString();
 543         }
 544     }
 545 
 546     /**
 547      * The formatter function is called repeatedly to read the bytes
 548      * from the offset for the length and return a String.
 549      * The ByteBuffer position and limit are unused and not modified.
 550      *
 551      * @param source a ByteBuffer
 552      * @param offset the offset in the ByteBuffer
 553      * @param length the length in the ByteBuffer
 554      * @return the output as a non-null {@code String}
 555      * @throws java.io.UncheckedIOException if an I/O error occurs
 556      */
 557     public String toString(ByteBuffer source, int offset, int length) {
 558         Objects.requireNonNull(source, &quot;ByteBuffer must be non-null&quot;);
 559         StringBuilder sb = new StringBuilder();
 560         ByteArrayInputStream bais;
 561         if (source.hasArray() &amp;&amp; !source.isReadOnly()) {
 562             bais = new ByteArrayInputStream(source.array(), offset, length);
 563         } else {
 564             byte[] bytes = new byte[length];
 565             source.get(bytes, offset, length);
 566             bais = new ByteArrayInputStream(bytes);
 567         }
 568         try (AnnotationWriter writer =
 569                      new AnnotationWriter(this, bais, offset, sb)) {
 570             writer.flush();
 571             return sb.toString();
 572         }
 573     }
 574 
 575     /**
 576      * The formatter function is called repeatedly to read all of the bytes
 577      * in the source and return a String.
 578      * The source bytes are from the {@code ByteBuffer.position()}
 579      * to the {@code ByteBuffer.limit()}.
 580      * The position is not modified.
 581      *
 582      * @param source a ByteBuffer
 583      * @return the output as a non-null {@code String}
 584      * @throws java.io.UncheckedIOException if an I/O error occurs
 585      */
 586     public String toString(ByteBuffer source) {
 587         return toString(source, source.position(), source.limit());
 588     }
 589 
 590     /**
 591      * Returns a new HexPrinter setting the format for the byte offset.
 592      * The format string is specified by {@link String#format String format}
 593      * including any delimiters. For example, {@code &quot;%3x: &quot;}.
 594      * If the format is an empty string, there is no offset in the output.
 595      *
 596      * @param offsetFormat a new format string for the byte offset.
 597      * @return a new HexPrinter
 598      */
 599     public HexPrinter withOffsetFormat(String offsetFormat) {
 600         Objects.requireNonNull(offsetFormat, &quot;offsetFormat&quot;);
 601         return new HexPrinter(annoFormatter, offsetFormat, bytesFormat, bytesCount,
 602                 annoDelim, annoWidth, lineSeparator, dest);
 603     }
 604 
 605     /**
 606      * Returns a new HexPrinter setting the format for each byte value and
 607      * the maximum number of byte values per line.
 608      * The format string is specified by {@link String#format String format},
 609      * including any delimiters or padding. For example, {@code &quot;%02x &quot;}.
 610      * If the byteFormat is an empty String, there are no byte values in the output.
 611      *
 612      * @param byteFormat a format string for each byte
 613      * @param bytesCount the maximum number of byte values per line
 614      * @return a new HexPrinter
 615      */
 616     public HexPrinter withBytesFormat(String byteFormat, int bytesCount) {
 617         Objects.requireNonNull(bytesFormat, &quot;bytesFormat&quot;);
 618         return new HexPrinter(annoFormatter, offsetFormat, byteFormat, bytesCount,
 619                 annoDelim, annoWidth, lineSeparator, dest);
 620     }
 621 
 622     /**
 623      * Returns a new HexPrinter setting the line separator.
 624      * The line separator can be set to an empty string or to
 625      * a string to be added at the end of each line.  It should include the line
 626      * separator {@link System#lineSeparator()} if a line break is to be output.
 627      *
 628      * @param separator the line separator
 629      * @return a new HexPrinter
 630      */
 631     public HexPrinter withLineSeparator(String separator) {
 632         return new HexPrinter(annoFormatter, offsetFormat, bytesFormat, bytesCount,
 633                 annoDelim, annoWidth, separator, dest);
 634     }
 635 
 636     /**
 637      * Returns a new HexPrinter setting the formatter.
 638      * The widths, delimiters and other parameters are unchanged.
 639      *
 640      * @param formatter a non-null Formatter
 641      * @return a new HexPrinter
 642      */
 643     public HexPrinter formatter(Formatter formatter) {
 644         Objects.requireNonNull(formatter, &quot;Formatter must be non-null&quot;);
 645         return new HexPrinter(formatter, offsetFormat, bytesFormat, bytesCount,
 646                 annoDelim, annoWidth, lineSeparator, dest);
 647     }
 648 
 649     /**
 650      * Returns a new HexPrinter setting the formatter, delimiter, and width of the annotation.
 651      * Note: The annotations may exceed the width.
 652      *
 653      * @param formatter a non-null Formatter
 654      * @param delim     a string delimiter for the annotation
 655      * @param width     the width of the annotation, non-negative
 656      * @return a new HexPrinter
 657      */
 658     public HexPrinter formatter(Formatter formatter, String delim, int width) {
 659         Objects.requireNonNull(formatter, &quot;formatter&quot;);
 660         Objects.requireNonNull(delim, &quot;delim&quot;);
 661         return new HexPrinter(formatter, offsetFormat, bytesFormat, bytesCount,
 662                 delim, width, lineSeparator, dest);
 663     }
 664 
 665     /**
 666      * Returns a new HexPrinter setting the formatter to format a primitive type
 667      * using the format string.
 668      * The format string should include any pre or post spacing and delimiters.
 669      * &lt;p&gt;
 670      * This is a convenience function equivalent to finding a formatter using
 671      * {@link HexPrinter.Formatters#ofPrimitive}.
 672      * &lt;/p&gt;
 673      *
 674      * @param primClass a primitive class, for example, {@code int.class}
 675      * @param fmtString a {@link java.util.Formatter format string}.
 676      * @return a new HexPrinter
 677      * @throws IllegalArgumentException if the class is not a primitive class
 678      */
 679     public HexPrinter formatter(Class&lt;?&gt; primClass, String fmtString) {
 680         Formatter formatter = getFormatter(primClass, fmtString);
 681         return new HexPrinter(formatter, offsetFormat, bytesFormat, bytesCount,
 682                 annoDelim, annoWidth, lineSeparator, dest);
 683     }
 684 
 685     /**
 686      * Returns a formatter for the primitive type using the format string.
 687      * The formatter reads a value of the primitive type from the stream
 688      * and formats it using the format string.
 689      * The format string includes any pre or post spacing and delimiters.
 690      *
 691      * @param primClass a primitive class, for example, {@code int.class}
 692      * @param fmtString a {@link java.util.Formatter format string}
 693      * @return a Formatter for the primitive type using the format string
 694      */
 695     static Formatter getFormatter(Class&lt;?&gt; primClass, String fmtString) {
 696         return new PrimitiveFormatter(primClass, fmtString);
 697     }
 698 
 699     /**
 700      * Returns a string describing this HexPrinter.
 701      * The string indicates the type of the destination and
 702      * the formatting options.
 703      *
 704      * @return a String describing this HexPrinter
 705      */
 706     public String toString() {
 707         return &quot;formatter: &quot; + annoFormatter
 708                 + &quot;, dest: &quot; + dest.getClass().getName()
 709                 + &quot;, offset: \&quot;&quot; + offsetFormat
 710                 + &quot;\&quot;, bytes: &quot; + bytesCount
 711                 + &quot; x \&quot;&quot; + bytesFormat + &quot;\&quot;&quot;
 712                 + &quot;, delim: \&quot;&quot; + annoDelim + &quot;\&quot;&quot;
 713                 + &quot;, width: &quot; + annoWidth
 714                 + &quot;, nl: \&quot;&quot; + expand(lineSeparator) + &quot;\&quot;&quot;;
 715     }
 716 
 717     private String expand(String sep) {
 718         return sep.replace(&quot;\n&quot;, &quot;\\n&quot;)
 719                 .replace(&quot;\r&quot;, &quot;\\r&quot;);
 720     }
 721 
 722     private static class PrimitiveFormatter implements Formatter {
 723 
 724         private final Class&lt;?&gt; primClass;
 725         private final String fmtString;
 726 
 727         PrimitiveFormatter(Class&lt;?&gt; primClass, String fmtString) {
 728             Objects.requireNonNull(primClass, &quot;primClass&quot;);
 729             Objects.requireNonNull(fmtString, &quot;fmtString&quot;);
 730             if (!primClass.isPrimitive())
 731                 throw new IllegalArgumentException(&quot;Not a primitive type: &quot; + primClass.getName());
 732             this.primClass = primClass;
 733             this.fmtString = fmtString;
 734         }
 735 
 736         public void annotate(DataInputStream in, Appendable out) throws IOException {
 737             if (primClass == byte.class) {
 738                 int v = in.readByte();
 739                 out.append(String.format(fmtString, v));
 740             } else if (primClass == boolean.class) {
 741                 boolean v = in.readByte() != 0;
 742                 out.append(String.format(fmtString, v));
 743             } else if (primClass == short.class | primClass == char.class) {
 744                 int v = in.readShort();
 745                 out.append(String.format(fmtString, v));
 746             } else if (primClass == float.class) {
 747                 float v = in.readFloat();
 748                 out.append(String.format(fmtString, v));
 749             } else if (primClass == int.class) {
 750                 int v = in.readInt();
 751                 out.append(String.format(fmtString, v));
 752             } else if (primClass == double.class) {
 753                 double v = in.readDouble();
 754                 out.append(String.format(fmtString, v));
 755             } else if (primClass == long.class) {
 756                 long v = in.readLong();
 757                 out.append(String.format(fmtString, v));
 758             } else {
 759                 throw new AssertionError(&quot;missing case on primitive class&quot;);
 760             }
 761         }
 762 
 763         public String toString() {
 764             return &quot;(&quot; + primClass.getName() + &quot;, \&quot;&quot; + fmtString + &quot;\&quot;)&quot;;
 765         }
 766     }
 767 
 768     /**
 769      * Formatter function reads bytes from a stream and
 770      * appends a readable annotation to the output destination.
 771      * &lt;p&gt;
 772      * Each invocation of the {@link #annotate annotate} method reads and annotates
 773      * a single instance of its protocol or data type.
 774      * &lt;p&gt;
 775      * Built-in formatting functions are provided in the {@link Formatters} class.
 776      * &lt;p&gt;
 777      * As described by the {@link HexPrinter#toString(InputStream)} method,
 778      * the {@link #annotate annotate} method is called to read bytes and produce
 779      * the descriptive annotation.
 780      * &lt;p&gt;
 781      * For example, a custom lambda formatter to read a float value (4 bytes) and
 782      * print as a floating number could be written as a static method.
 783      * &lt;pre&gt;{@code
 784      *     // Format 4 bytes read from the input as a float 3.4.
 785      *     static void annotate(DataInputStream in, Appendable out) throws IOException {
 786      *         float f = in.readFloat();
 787      *         out.append(String.format(&quot;%3.4f, &quot;, f));
 788      *     }
 789      *
 790      *     byte[] bytes = new byte[] {00 00 00 00 3f 80 00 00 40 00 00 00 40 40 00 00};
 791      *     HexPrinter pp = HexPrinter.simple()
 792      *         .withBytesFormat(&quot;%02x &quot;, 8)
 793      *         .formatter(Example::annotate)
 794      *         .format(bytes);
 795      *
 796      * Result:
 797      *     0: 00 00 00 00 3f 80 00 00  // 0.0000, 1.0000,
 798      *     8: 40 00 00 00 40 40 00 00  // 2.0000, 3.0000,
 799      * }&lt;/pre&gt;
 800      *
 801      * &lt;p&gt;
 802      * The details of the buffering and calling of the formatter {@code annotate}
 803      * methods is roughly as follows.
 804      * The bytes read by the {@code annotate} method are logically buffered
 805      * for each line of output.
 806      * The {@code annotate} method writes its description of the bytes read
 807      * to the output, this output is also buffered.
 808      * When the number of bytes read exceeds the
 809      * {@link #withBytesFormat(String, int) byte values count per line},
 810      * the buffered output exceeds the
 811      * {@link #formatter(Formatter, String, int) width of the annotation field},
 812      * or a new line {@code &quot;\n&quot;} character is found in the output then
 813      * a line of output is assembled and written to the destination Appendable.
 814      * The formatter&#39;s {@code annotate} method is called repeatedly
 815      * until the input is completely consumed or an exception is thrown.
 816      * Any remaining buffered bytes or description are flushed to the destination Appendable.
 817      */
 818     @FunctionalInterface
 819     public interface Formatter {
 820 
 821         /**
 822          * Read bytes from the input stream and append a descriptive annotation
 823          * to the output destination.
 824          *
 825          * @param in  a DataInputStream
 826          * @param out an Appendable for the output
 827          * @throws IOException if an I/O error occurs
 828          */
 829         void annotate(DataInputStream in, Appendable out) throws IOException;
 830     }
 831 
 832     /**
 833      * Built-in formatters for printable byte, ASCII, UTF-8 and primitive types.
 834      * Formatters for primitive types and different formatting options
 835      * can be found by calling {@link #ofPrimitive(Class, String)}.
 836      */
 837     public enum Formatters implements Formatter {
 838         /**
 839          * Read a byte and if it is ASCII write it,
 840          * otherwise, write its mnemonic or its decimal value.
 841          */
 842         PRINTABLE,
 843         /**
 844          * Read a byte, if it is ASCII write it, otherwise write a &quot;.&quot;.
 845          */
 846         ASCII,
 847         /**
 848          * Read a modified UTF-8 string and write it.
 849          */
 850         UTF8,
 851         /**
 852          * Read a byte and write nothing.
 853          */
 854         NONE;
 855 
 856         public void annotate(DataInputStream in, Appendable out) throws IOException {
 857             switch (this) {
 858                 case PRINTABLE -&gt; bytePrintable(in, out);
 859                 case ASCII -&gt; byteASCII(in, out);
 860                 case UTF8 -&gt; utf8Parser(in, out);
 861                 case NONE -&gt; byteNoneParser(in, out);
 862             }
 863         }
 864 
 865         /**
 866          * Read a byte and write it as ASCII if it is printable,
 867          * print its mnemonic if it is a control character,
 868          * and print its decimal value otherwise.
 869          * A space separator character is appended for control and decimal values.
 870          *
 871          * @param in  a DataInputStream
 872          * @param out an Appendable to write to
 873          * @throws IOException if an I/O error occurs
 874          */
 875         static void bytePrintable(DataInputStream in, Appendable out) throws IOException {
 876             int v = in.readUnsignedByte();
 877             if (v &lt; 32) {
 878                 out.append(&quot;\\&quot;).append(CONTROL_MNEMONICS[v]);
 879             } else if (v &lt; 126 &amp;&amp; Character.isDefined(v)) {
 880                 out.append((char) v);
 881             } else {
 882                 out.append(&quot;\\&quot;).append(Integer.toString(v, 10));
 883             }
 884         }
 885 
 886         /**
 887          * Read a byte and write it as ASCII if it is printable, otherwise print &quot;.&quot;.
 888          *
 889          * @param in  a DataInputStream
 890          * @param out an Appendable to write to
 891          * @throws IOException if an I/O error occurs
 892          */
 893         static void byteASCII(DataInputStream in, Appendable out) throws IOException {
 894             int v = in.readUnsignedByte();
 895             if (Character.isDefined(v)) {
 896                 out.append((char) v);
 897             } else {
 898                 out.append(&#39;.&#39;);
 899             }
 900         }
 901 
 902         /**
 903          * Read a modified UTF-8 string and write it to the output destination.
 904          *
 905          * @param in  a DataInputStream
 906          * @param out an Appendable to write the output to
 907          * @throws IOException if an I/O error occurs
 908          */
 909         static void utf8Parser(DataInputStream in, Appendable out) throws IOException {
 910             out.append(in.readUTF()).append(&quot; &quot;);
 911         }
 912 
 913         /**
 914          * Read a a byte and write nothing.
 915          *
 916          * @param in  a DataInputStream
 917          * @param out an Appendable to write the output to
 918          * @throws IOException if an I/O error occurs
 919          */
 920         static void byteNoneParser(DataInputStream in, Appendable out) throws IOException {
 921             in.readByte();
 922         }
 923 
 924         /**
 925          * Returns a {@code Formatter} for a primitive using the format string.
 926          * The format string includes any pre or post spacing or delimiters.
 927          * A value of the primitive is read using the type specific methods
 928          * of {@link DataInputStream}, formatted using the format string, and
 929          * written to the output.
 930          *
 931          * @param primClass a primitive class, for example, {@code int.class}
 932          * @param fmtString a {@link java.util.Formatter format string}.
 933          * @return a Formatter
 934          */
 935         public static Formatter ofPrimitive(Class&lt;?&gt; primClass, String fmtString) {
 936             Objects.requireNonNull(primClass, &quot;primClass&quot;);
 937             Objects.requireNonNull(fmtString, &quot;fmtString&quot;);
 938             return new PrimitiveFormatter(primClass, fmtString);
 939         }
 940     }
 941 
 942     /**
 943      * Internal implementation of the annotation output and processor of annotated output.
 944      * Created for each new input source and discarded after each use.
 945      * An OffsetInputStream is created to buffer and count the input bytes.
 946      *
 947      */
 948     private static final class AnnotationWriter extends CharArrayWriter {
 949         private final transient OffsetInputStream source;
 950         private final transient DataInputStream in;
 951         private final transient int baseOffset;
 952         private final transient HexPrinter params;
 953         private final transient int bytesColWidth;
 954         private final transient int annoWidth;
 955         private final transient Appendable dest;
 956 
 957         /**
 958          * Construct a new AnnotationWriter to process the source into the destination.
 959          * Initializes the DataInputStream and marking of the input to keep track
 960          * of bytes as they are read by the formatter.
 961          * @param params formatting parameters
 962          * @param source source InputStream
 963          * @param baseOffset initial offset
 964          * @param dest destination Appendable
 965          */
 966         AnnotationWriter(HexPrinter params, InputStream source, int baseOffset, Appendable dest) {
 967             this.params = params;
 968             this.baseOffset = baseOffset;
 969             Objects.requireNonNull(source, &quot;Source is null&quot;);
 970             this.source = new OffsetInputStream(source);
 971             this.source.mark(1024);
 972             this.in = new DataInputStream(this.source);
 973             this.bytesColWidth = params.bytesCount * String.format(params.bytesFormat, 255).length();
 974             this.annoWidth = params.annoWidth;
 975             this.dest = dest;
 976         }
 977 
 978         @Override
 979         public void write(int c) {
 980             super.write(c);
 981             checkFlush();
 982         }
 983 
 984         @Override
 985         public void write(char[] c, int off, int len) {
 986             super.write(c, off, len);
 987             for (int i = 0; i &lt; len; i++) {
 988                 if (c[off+i] == &#39;\n&#39;) {
 989                     process();
 990                     return;
 991                 }
 992             }
 993             checkFlush();
 994         }
 995 
 996         @Override
 997         public void write(String str, int off, int len) {
 998             super.write(str, off, len);
 999             if (str.indexOf(&#39;\n&#39;) &gt;=0 )
1000                 process();
1001             else
1002                 checkFlush();
1003         }
1004 
1005         private void checkFlush() {
1006             if (size() &gt; annoWidth)
1007                 process();
1008         }
1009 
1010         /**
1011          * The annotation printing function is called repeatedly to read all of the bytes
1012          * in the source stream and annotate the stream.
1013          * The annotated output is appended to the output dest or buffered.
1014          * &lt;p&gt;
1015          *     The HexPrinter is not closed and can be used as a template
1016          *     to create a new formatter with a new Source or different formatting
1017          *     options.
1018          * &lt;/p&gt;
1019          */
1020         @Override
1021         public void flush() {
1022             try {
1023                 while (true) {
1024                     if (source.markedByteCount() &gt;= params.bytesCount)
1025                         process();
1026                     params.annoFormatter.annotate(in, this);
1027                     if (source.markedByteCount() &gt; 256) {
1028                         // Normally annotations would cause processing more often
1029                         // Guard against overrunning the mark/reset buffer.
1030                         process();
1031                     }
1032                 }
1033             } catch (IOException ioe) {
1034                 process();
1035                 if (!(ioe instanceof EOFException)) {
1036                     throw new UncheckedIOException(ioe);
1037                 }
1038             } catch (UncheckedIOException uio) {
1039                 process();      // clear out the buffers
1040                 throw uio;
1041             }
1042         }
1043 
1044         /**
1045          * Merge the buffered stream of annotations with the formatted bytes
1046          * and append them to the dest.
1047          * &lt;p&gt;
1048          * The annotation mapping function has read some bytes and buffered
1049          * some output that corresponds to those bytes.
1050          * The un-formatted bytes are in the OffsetInputStream after the mark.
1051          * The stream is reset and the bytes are read again.
1052          * Each line of the produced one line at a time to the dest.
1053          * The byte offset is formatted according to the offsetFormat.
1054          * The bytes after the mark are read and formatted using the bytesFormat
1055          * and written to the dest up to the bytesWidth.
1056          * The annotation stream is appended to the dest, but only up to the
1057          * first newline (if any). The alignment between the annotated stream
1058          * and the formatted bytes is approximate.
1059          * New line characters in the annotation cause a new line to be started
1060          * without regard to the number of formatted bytes. The column of formatted
1061          * bytes may be incomplete.
1062          */
1063         private void process() {
1064             String info = toString();
1065             reset();
1066             int count = source.markedByteCount();
1067             try {
1068                 source.reset();
1069                 long binColOffset = source.byteOffset();
1070                 while (count &gt; 0 || info.length() &gt; 0) {
1071                     dest.append(String.format(params.offsetFormat, binColOffset + baseOffset));
1072                     int colWidth = 0;
1073                     int byteCount = Math.min(params.bytesCount, count);
1074                     for (int i = 0; i &lt; byteCount; i++) {
1075                         int b = source.read();
1076                         if (b == -1)
1077                             throw new IllegalStateException(&quot;BUG&quot;);
1078                         String s = String.format(params.bytesFormat, b);
1079                         colWidth += s.length();
1080                         dest.append(s);
1081                     }
1082                     binColOffset += byteCount;
1083                     count -= byteCount;
1084 
1085                     // Pad out the bytes column to its width
1086                     dest.append(&quot; &quot;.repeat(Math.max(0, bytesColWidth - colWidth)));
1087                     dest.append(params.annoDelim);
1088 
1089                     // finish a line and prepare for next line
1090                     // Add a line from annotation buffer
1091                     if (info.length() &gt; 0) {
1092                         int nl = info.indexOf(&#39;\n&#39;);
1093                         if (nl &lt; 0) {
1094                             dest.append(info);
1095                             info = &quot;&quot;;
1096                         } else {
1097                             dest.append(info, 0, nl);
1098                             info = info.substring(nl + 1);
1099                         }
1100                     }
1101                     dest.append(params.lineSeparator);
1102                 }
1103             } catch (IOException ioe) {
1104                 try {
1105                     dest.append(&quot;\nIOException during annotations: &quot;)
1106                         .append(ioe.getMessage())
1107                         .append(&quot;\n&quot;);
1108                 } catch (IOException ignore) {
1109                     // ignore
1110                 }
1111             }
1112             // reset the mark for the next line
1113             source.mark(1024);
1114         }
1115     }
1116 
1117     /**
1118      * Buffered InputStream that keeps track of byte offset.
1119      */
1120     private static final class OffsetInputStream extends BufferedInputStream {
1121         private long byteOffset;
1122         private long markByteOffset;
1123 
1124         OffsetInputStream(InputStream in) {
1125             super(in);
1126             byteOffset = 0;
1127             markByteOffset = 0;
1128         }
1129 
1130         long byteOffset() {
1131             return byteOffset;
1132         }
1133 
1134         @Override
1135         public void reset() throws IOException {
1136             super.reset();
1137             byteOffset = markByteOffset;
1138         }
1139 
1140         @Override
1141         public synchronized void mark(int readlimit) {
1142             super.mark(readlimit);
1143             markByteOffset = byteOffset;
1144         }
1145 
1146         int markedByteCount() {
1147             if (markpos &lt; 0)
1148                 return 0;
1149             return pos - markpos;
1150         }
1151 
1152         @Override
1153         public int read() throws IOException {
1154             int b = super.read();
1155             if (b &gt;= 0)
1156                 byteOffset++;
1157             return b;
1158         }
1159 
1160         @Override
1161         public long skip(long n) throws IOException {
1162             long size = super.skip(n);
1163             byteOffset += size;
1164             return size;
1165         }
1166 
1167         @Override
1168         public int read(byte[] b) throws IOException {
1169             int size = super.read(b);
1170             byteOffset += Math.max(size, 0);
1171             return size;
1172         }
1173 
1174         @Override
1175         public int read(byte[] b, int off, int len) throws IOException {
1176             int size = super.read(b, off, len);
1177             byteOffset += Math.max(size, 0);
1178             return size;
1179         }
1180     }
1181 }
    </pre>
  </body>
</html>
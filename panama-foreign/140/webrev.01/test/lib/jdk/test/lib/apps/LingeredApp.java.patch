diff a/test/lib/jdk/test/lib/apps/LingeredApp.java b/test/lib/jdk/test/lib/apps/LingeredApp.java
--- a/test/lib/jdk/test/lib/apps/LingeredApp.java
+++ b/test/lib/jdk/test/lib/apps/LingeredApp.java
@@ -21,14 +21,12 @@
  * questions.
  */
 
 package jdk.test.lib.apps;
 
-import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.StringReader;
 import java.nio.file.Files;
 import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.attribute.BasicFileAttributes;
@@ -38,22 +36,33 @@
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
 import java.util.stream.Collectors;
 import java.util.UUID;
+
+import jdk.test.lib.JDKToolFinder;
 import jdk.test.lib.Utils;
 import jdk.test.lib.process.OutputBuffer;
 import jdk.test.lib.process.StreamPumper;
 
 /**
  * This is a framework to launch an app that could be synchronized with caller
  * to make further attach actions reliable across supported platforms
 
  * Caller example:
- *   SmartTestApp a = SmartTestApp.startApp(cmd);
+ *
+ *   LingeredApp a = LingeredApp.startApp(cmd);
+ *     // do something.
+ *     // a.getPid(). a.getProcess(), a.getProcessStdout() are available.
+ *   LingeredApp.stopApp(a);
+ *
+ *   for use custom LingeredApp (class SmartTestApp extends LingeredApp):
+ *
+ *   SmartTestApp = new SmartTestApp();
+ *   LingeredApp.startApp(a, cmd);
  *     // do something
- *   a.stopApp();
+ *   a.stopApp();   // LingeredApp.stopApp(a) can be used as well
  *
  *   or fine grained control
  *
  *   a = new SmartTestApp("MyLock.lck");
  *   a.createLock();
@@ -61,14 +70,13 @@
  *   a.waitAppReady();
  *     // do something
  *   a.deleteLock();
  *   a.waitAppTerminate();
  *
- *  Then you can work with app output and process object
+ *  After app termination (stopApp/waitAppTermination) its output is available
  *
  *   output = a.getAppOutput();
- *   process = a.getProcess();
  *
  */
 public class LingeredApp {
 
     private static final long spinDelay = 1000;
@@ -142,11 +150,11 @@
     public OutputBuffer getOutput() {
         if (appProcess.isAlive()) {
             throw new RuntimeException("Process is still alive. Can't get its output.");
         }
         if (output == null) {
-            output = OutputBuffer.of(stdoutBuffer.toString(), stderrBuffer.toString());
+            output = OutputBuffer.of(stdoutBuffer.toString(), stderrBuffer.toString(), appProcess.exitValue());
         }
         return output;
     }
 
     /*
@@ -166,22 +174,10 @@
 
         outPumperThread.start();
         errPumperThread.start();
     }
 
-    /**
-     *
-     * @return application output as List. Empty List if application produced no output
-     */
-    public List<String> getAppOutput() {
-        if (appProcess.isAlive()) {
-            throw new RuntimeException("Process is still alive. Can't get its output.");
-        }
-        BufferedReader bufReader = new BufferedReader(new StringReader(output.getStdout()));
-        return bufReader.lines().collect(Collectors.toList());
-    }
-
     /* Make sure all part of the app use the same method to get dates,
      as different methods could produce different results
      */
     private static long epoch() {
         return new Date().getTime();
@@ -239,18 +235,20 @@
 
     /**
      * The app touches the lock file when it's started
      * wait while it happens. Caller have to delete lock on wait error.
      *
-     * @param timeout
+     * @param timeout timeout in seconds
      * @throws java.io.IOException
      */
     public void waitAppReady(long timeout) throws IOException {
+        // adjust timeout for timeout_factor and convert to ms
+        timeout = Utils.adjustTimeout(timeout) * 1000;
         long here = epoch();
         while (true) {
             long epoch = epoch();
-            if (epoch - here > (timeout * 1000)) {
+            if (epoch - here > timeout) {
                 throw new IOException("App waiting timeout");
             }
 
             // Live process should touch lock file every second
             long lm = lastModified(lockFileName);
@@ -269,34 +267,24 @@
                 // pass
             }
         }
     }
 
+    /**
+     * Waits the application to start with the default timeout.
+     */
+    public void waitAppReady() throws IOException {
+        waitAppReady(appWaitTime);
+    }
+
     /**
      * Analyze an environment and prepare a command line to
      * run the app, app name should be added explicitly
      */
     private List<String> runAppPrepare(String[] vmArguments) {
-        // We should always use testjava or throw an exception,
-        // so we can't use JDKToolFinder.getJDKTool("java");
-        // that falls back to compile java on error
-        String jdkPath = System.getProperty("test.jdk");
-        if (jdkPath == null) {
-            // we are not under jtreg, try env
-            Map<String, String> env = System.getenv();
-            jdkPath = env.get("TESTJAVA");
-        }
-
-        if (jdkPath == null) {
-            throw new RuntimeException("Can't determine jdk path neither test.jdk property no TESTJAVA env are set");
-        }
-
-        String osname = System.getProperty("os.name");
-        String javapath = jdkPath + ((osname.startsWith("window")) ? "/bin/java.exe" : "/bin/java");
-
-        List<String> cmd = new ArrayList<String>();
-        cmd.add(javapath);
+        List<String> cmd = new ArrayList<>();
+        cmd.add(JDKToolFinder.getTestJDKTool("java"));
         Collections.addAll(cmd, vmArguments);
 
         // Make sure we set correct classpath to run the app
         cmd.add("-cp");
         String classpath = System.getProperty("test.class.path");
@@ -316,16 +304,13 @@
     /**
      * Assemble command line to a printable string
      */
     public void printCommandLine(List<String> cmd) {
         // A bit of verbosity
-        StringBuilder cmdLine = new StringBuilder();
-        for (String strCmd : cmd) {
-            cmdLine.append("'").append(strCmd).append("' ");
-        }
-
-        System.err.println("Command line: [" + cmdLine.toString() + "]");
+        System.out.println(cmd.stream()
+                .map(s -> "'" + s + "'")
+                .collect(Collectors.joining(" ", "Command line: [", "]")));
     }
 
     /**
      * Run the app.
      * User should provide exact options to run app. Might use #Utils.getTestJavaOpts() to set default test options.
@@ -355,11 +340,11 @@
             String msg =
                     " LingeredApp stdout: [" + output.getStdout() + "];\n" +
                     " LingeredApp stderr: [" + output.getStderr() + "]\n" +
                     " LingeredApp exitValue = " + appProcess.exitValue();
 
-            System.err.println(msg);
+            System.out.println(msg);
         }
     }
 
     /**
      * Delete lock file that signals app to terminate, then
@@ -396,11 +381,11 @@
      */
     public static void startAppExactJvmOpts(LingeredApp theApp, String... jvmOpts) throws IOException {
         theApp.createLock();
         try {
             theApp.runAppExactJvmOpts(jvmOpts);
-            theApp.waitAppReady(appWaitTime);
+            theApp.waitAppReady();
         } catch (Exception ex) {
             theApp.deleteLock();
             throw ex;
         }
     }
@@ -426,11 +411,11 @@
     public static LingeredApp startApp(String... additionalJvmOpts) throws IOException {
         LingeredApp a = new LingeredApp();
         try {
             startApp(a, additionalJvmOpts);
         } catch (Exception ex) {
-            System.err.println("LingeredApp failed to start: " + ex);
+            System.out.println("LingeredApp failed to start: " + ex);
             a.finishApp();
             throw ex;
         }
 
         return a;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/apps/LingeredApp.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../ClassFileInstaller.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../process/OutputBuffer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/apps/LingeredApp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.apps;
 25 
<span class="line-removed"> 26 import java.io.BufferedReader;</span>
 27 import java.io.ByteArrayOutputStream;
 28 import java.io.IOException;
<span class="line-removed"> 29 import java.io.StringReader;</span>
 30 import java.nio.file.Files;
 31 import java.nio.file.NoSuchFileException;
 32 import java.nio.file.Path;
 33 import java.nio.file.Paths;
 34 import java.nio.file.attribute.BasicFileAttributes;
 35 import java.nio.file.attribute.FileTime;
 36 import java.util.ArrayList;
 37 import java.util.Collections;
 38 import java.util.Date;
 39 import java.util.List;
 40 import java.util.Map;
 41 import java.util.stream.Collectors;
 42 import java.util.UUID;


 43 import jdk.test.lib.Utils;
 44 import jdk.test.lib.process.OutputBuffer;
 45 import jdk.test.lib.process.StreamPumper;
 46 
 47 /**
 48  * This is a framework to launch an app that could be synchronized with caller
 49  * to make further attach actions reliable across supported platforms
 50 
 51  * Caller example:
<span class="line-modified"> 52  *   SmartTestApp a = SmartTestApp.startApp(cmd);</span>









 53  *     // do something
<span class="line-modified"> 54  *   a.stopApp();</span>
 55  *
 56  *   or fine grained control
 57  *
 58  *   a = new SmartTestApp(&quot;MyLock.lck&quot;);
 59  *   a.createLock();
 60  *   a.runAppExactJvmOpts(Utils.getTestJavaOpts());
 61  *   a.waitAppReady();
 62  *     // do something
 63  *   a.deleteLock();
 64  *   a.waitAppTerminate();
 65  *
<span class="line-modified"> 66  *  Then you can work with app output and process object</span>
 67  *
 68  *   output = a.getAppOutput();
<span class="line-removed"> 69  *   process = a.getProcess();</span>
 70  *
 71  */
 72 public class LingeredApp {
 73 
 74     private static final long spinDelay = 1000;
 75 
 76     private long lockCreationTime;
 77     private ByteArrayOutputStream stderrBuffer;
 78     private ByteArrayOutputStream stdoutBuffer;
 79     private Thread outPumperThread;
 80     private Thread errPumperThread;
 81 
 82     protected Process appProcess;
 83     protected OutputBuffer output;
 84     protected static final int appWaitTime = 100;
 85     protected final String lockFileName;
 86 
 87     /**
 88      * Create LingeredApp object on caller side. Lock file have be a valid filename
 89      * at writable location
</pre>
<hr />
<pre>
127     }
128 
129     /**
130      * @return the LingeredApp&#39;s output.
131      * Can be called after the app is run.
132      */
133     public String getProcessStdout() {
134         return stdoutBuffer.toString();
135     }
136 
137     /**
138      *
139      * @return OutputBuffer object for the LingeredApp&#39;s output. Can only be called
140      * after LingeredApp has exited.
141      */
142     public OutputBuffer getOutput() {
143         if (appProcess.isAlive()) {
144             throw new RuntimeException(&quot;Process is still alive. Can&#39;t get its output.&quot;);
145         }
146         if (output == null) {
<span class="line-modified">147             output = OutputBuffer.of(stdoutBuffer.toString(), stderrBuffer.toString());</span>
148         }
149         return output;
150     }
151 
152     /*
153      * Capture all stdout and stderr output from the LingeredApp so it can be returned
154      * to the driver app later. This code is modeled after ProcessTools.getOutput().
155      */
156     private void startOutputPumpers() {
157         stderrBuffer = new ByteArrayOutputStream();
158         stdoutBuffer = new ByteArrayOutputStream();
159         StreamPumper outPumper = new StreamPumper(appProcess.getInputStream(), stdoutBuffer);
160         StreamPumper errPumper = new StreamPumper(appProcess.getErrorStream(), stderrBuffer);
161         outPumperThread = new Thread(outPumper);
162         errPumperThread = new Thread(errPumper);
163 
164         outPumperThread.setDaemon(true);
165         errPumperThread.setDaemon(true);
166 
167         outPumperThread.start();
168         errPumperThread.start();
169     }
170 
<span class="line-removed">171     /**</span>
<span class="line-removed">172      *</span>
<span class="line-removed">173      * @return application output as List. Empty List if application produced no output</span>
<span class="line-removed">174      */</span>
<span class="line-removed">175     public List&lt;String&gt; getAppOutput() {</span>
<span class="line-removed">176         if (appProcess.isAlive()) {</span>
<span class="line-removed">177             throw new RuntimeException(&quot;Process is still alive. Can&#39;t get its output.&quot;);</span>
<span class="line-removed">178         }</span>
<span class="line-removed">179         BufferedReader bufReader = new BufferedReader(new StringReader(output.getStdout()));</span>
<span class="line-removed">180         return bufReader.lines().collect(Collectors.toList());</span>
<span class="line-removed">181     }</span>
<span class="line-removed">182 </span>
183     /* Make sure all part of the app use the same method to get dates,
184      as different methods could produce different results
185      */
186     private static long epoch() {
187         return new Date().getTime();
188     }
189 
190     private static long lastModified(String fileName) throws IOException {
191         Path path = Paths.get(fileName);
192         BasicFileAttributes attr = Files.readAttributes(path, BasicFileAttributes.class);
193         return attr.lastModifiedTime().toMillis();
194     }
195 
196     private static void setLastModified(String fileName, long newTime) throws IOException {
197         Path path = Paths.get(fileName);
198         FileTime fileTime = FileTime.fromMillis(newTime);
199         Files.setLastModifiedTime(path, fileTime);
200     }
201 
202     /**
</pre>
<hr />
<pre>
224             // Lock already deleted. Ignore error
225         }
226     }
227 
228     public void waitAppTerminate() {
229         // This code is modeled after tail end of ProcessTools.getOutput().
230         try {
231             appProcess.waitFor();
232             outPumperThread.join();
233             errPumperThread.join();
234         } catch (InterruptedException e) {
235             Thread.currentThread().interrupt();
236             // pass
237         }
238     }
239 
240     /**
241      * The app touches the lock file when it&#39;s started
242      * wait while it happens. Caller have to delete lock on wait error.
243      *
<span class="line-modified">244      * @param timeout</span>
245      * @throws java.io.IOException
246      */
247     public void waitAppReady(long timeout) throws IOException {


248         long here = epoch();
249         while (true) {
250             long epoch = epoch();
<span class="line-modified">251             if (epoch - here &gt; (timeout * 1000)) {</span>
252                 throw new IOException(&quot;App waiting timeout&quot;);
253             }
254 
255             // Live process should touch lock file every second
256             long lm = lastModified(lockFileName);
257             if (lm &gt; lockCreationTime) {
258                 break;
259             }
260 
261             // Make sure process didn&#39;t already exit
262             if (!appProcess.isAlive()) {
263                 throw new IOException(&quot;App exited unexpectedly with &quot; + appProcess.exitValue());
264             }
265 
266             try {
267                 Thread.sleep(spinDelay);
268             } catch (InterruptedException ex) {
269                 // pass
270             }
271         }
272     }
273 







274     /**
275      * Analyze an environment and prepare a command line to
276      * run the app, app name should be added explicitly
277      */
278     private List&lt;String&gt; runAppPrepare(String[] vmArguments) {
<span class="line-modified">279         // We should always use testjava or throw an exception,</span>
<span class="line-modified">280         // so we can&#39;t use JDKToolFinder.getJDKTool(&quot;java&quot;);</span>
<span class="line-removed">281         // that falls back to compile java on error</span>
<span class="line-removed">282         String jdkPath = System.getProperty(&quot;test.jdk&quot;);</span>
<span class="line-removed">283         if (jdkPath == null) {</span>
<span class="line-removed">284             // we are not under jtreg, try env</span>
<span class="line-removed">285             Map&lt;String, String&gt; env = System.getenv();</span>
<span class="line-removed">286             jdkPath = env.get(&quot;TESTJAVA&quot;);</span>
<span class="line-removed">287         }</span>
<span class="line-removed">288 </span>
<span class="line-removed">289         if (jdkPath == null) {</span>
<span class="line-removed">290             throw new RuntimeException(&quot;Can&#39;t determine jdk path neither test.jdk property no TESTJAVA env are set&quot;);</span>
<span class="line-removed">291         }</span>
<span class="line-removed">292 </span>
<span class="line-removed">293         String osname = System.getProperty(&quot;os.name&quot;);</span>
<span class="line-removed">294         String javapath = jdkPath + ((osname.startsWith(&quot;window&quot;)) ? &quot;/bin/java.exe&quot; : &quot;/bin/java&quot;);</span>
<span class="line-removed">295 </span>
<span class="line-removed">296         List&lt;String&gt; cmd = new ArrayList&lt;String&gt;();</span>
<span class="line-removed">297         cmd.add(javapath);</span>
298         Collections.addAll(cmd, vmArguments);
299 
300         // Make sure we set correct classpath to run the app
301         cmd.add(&quot;-cp&quot;);
302         String classpath = System.getProperty(&quot;test.class.path&quot;);
303         cmd.add((classpath == null) ? &quot;.&quot; : classpath);
304 
305         return cmd;
306     }
307 
308     /**
309      * Adds application name to the command line.
310      * By default adds name of this class.
311      */
312     protected void runAddAppName(List&lt;String&gt; cmd) {
313         cmd.add(getClass().getName());
314     }
315 
316     /**
317      * Assemble command line to a printable string
318      */
319     public void printCommandLine(List&lt;String&gt; cmd) {
320         // A bit of verbosity
<span class="line-modified">321         StringBuilder cmdLine = new StringBuilder();</span>
<span class="line-modified">322         for (String strCmd : cmd) {</span>
<span class="line-modified">323             cmdLine.append(&quot;&#39;&quot;).append(strCmd).append(&quot;&#39; &quot;);</span>
<span class="line-removed">324         }</span>
<span class="line-removed">325 </span>
<span class="line-removed">326         System.err.println(&quot;Command line: [&quot; + cmdLine.toString() + &quot;]&quot;);</span>
327     }
328 
329     /**
330      * Run the app.
331      * User should provide exact options to run app. Might use #Utils.getTestJavaOpts() to set default test options.
332      * @param vmOpts
333      * @throws IOException
334      */
335     public void runAppExactJvmOpts(String[] vmOpts)
336             throws IOException {
337 
338         List&lt;String&gt; cmd = runAppPrepare(vmOpts);
339 
340         runAddAppName(cmd);
341         cmd.add(lockFileName);
342 
343         printCommandLine(cmd);
344 
345         ProcessBuilder pb = new ProcessBuilder(cmd);
346         // ProcessBuilder.start can throw IOException
347         appProcess = pb.start();
348 
349         startOutputPumpers();
350     }
351 
352     private void finishApp() {
353         if (appProcess != null) {
354             OutputBuffer output = getOutput();
355             String msg =
356                     &quot; LingeredApp stdout: [&quot; + output.getStdout() + &quot;];\n&quot; +
357                     &quot; LingeredApp stderr: [&quot; + output.getStderr() + &quot;]\n&quot; +
358                     &quot; LingeredApp exitValue = &quot; + appProcess.exitValue();
359 
<span class="line-modified">360             System.err.println(msg);</span>
361         }
362     }
363 
364     /**
365      * Delete lock file that signals app to terminate, then
366      * wait until app is actually terminated.
367      * @throws IOException
368      */
369     public void stopApp() throws IOException {
370         deleteLock();
371         // The startApp() of the derived app can throw
372         // an exception before the LA actually starts
373         if (appProcess != null) {
374             waitAppTerminate();
375 
376             finishApp();
377 
378             int exitcode = appProcess.exitValue();
379             if (exitcode != 0) {
380                 throw new IOException(&quot;LingeredApp terminated with non-zero exit code &quot; + exitcode);
381             }
382         }
383     }
384 
385     /**
386      *  High level interface for test writers
387      */
388 
389     /**
390      * Factory method that starts pre-created LingeredApp
391      * lock name is autogenerated
392      * User should provide exact options to run app. Might use #Utils.getTestJavaOpts() to set default test options.
393      * @param jvmOpts - the exact vm options used to start LingeredApp
394      * @param theApp - app to start
395      * @throws IOException
396      */
397     public static void startAppExactJvmOpts(LingeredApp theApp, String... jvmOpts) throws IOException {
398         theApp.createLock();
399         try {
400             theApp.runAppExactJvmOpts(jvmOpts);
<span class="line-modified">401             theApp.waitAppReady(appWaitTime);</span>
402         } catch (Exception ex) {
403             theApp.deleteLock();
404             throw ex;
405         }
406     }
407 
408     /**
409      * Factory method that starts pre-created LingeredApp
410      * lock name is autogenerated, additionalJvmOpts are appended to default test options
411      * @param additionalJvmOpts - additional Jvm options, appended to #Utils.getTestJavaOpts();
412      * @param theApp - app to start
413      * @throws IOException
414      */
415     public static void startApp(LingeredApp theApp, String... additionalJvmOpts) throws IOException {
416         startAppExactJvmOpts(theApp, Utils.prependTestJavaOpts(additionalJvmOpts));
417     }
418 
419     /**
420      * Factory method that creates LingeredApp object with ready to use application
421      * lock name is autogenerated, additionalJvmOpts are appended to default test options
422      * @param additionalJvmOpts - additional Jvm options, appended to #Utils.getTestJavaOpts();
423      * @return LingeredApp object
424      * @throws IOException
425      */
426     public static LingeredApp startApp(String... additionalJvmOpts) throws IOException {
427         LingeredApp a = new LingeredApp();
428         try {
429             startApp(a, additionalJvmOpts);
430         } catch (Exception ex) {
<span class="line-modified">431             System.err.println(&quot;LingeredApp failed to start: &quot; + ex);</span>
432             a.finishApp();
433             throw ex;
434         }
435 
436         return a;
437     }
438 
439     public static void stopApp(LingeredApp app) throws IOException {
440         if (app != null) {
441             // LingeredApp can throw an exception during the intialization,
442             // make sure we don&#39;t have cascade NPE
443             app.stopApp();
444         }
445     }
446 
447     /**
448      * LastModified time might not work correctly in some cases it might
449      * cause later failures
450      */
451 
</pre>
</td>
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.apps;
 25 

 26 import java.io.ByteArrayOutputStream;
 27 import java.io.IOException;

 28 import java.nio.file.Files;
 29 import java.nio.file.NoSuchFileException;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.nio.file.attribute.BasicFileAttributes;
 33 import java.nio.file.attribute.FileTime;
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.Date;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.stream.Collectors;
 40 import java.util.UUID;
<span class="line-added"> 41 </span>
<span class="line-added"> 42 import jdk.test.lib.JDKToolFinder;</span>
 43 import jdk.test.lib.Utils;
 44 import jdk.test.lib.process.OutputBuffer;
 45 import jdk.test.lib.process.StreamPumper;
 46 
 47 /**
 48  * This is a framework to launch an app that could be synchronized with caller
 49  * to make further attach actions reliable across supported platforms
 50 
 51  * Caller example:
<span class="line-modified"> 52  *</span>
<span class="line-added"> 53  *   LingeredApp a = LingeredApp.startApp(cmd);</span>
<span class="line-added"> 54  *     // do something.</span>
<span class="line-added"> 55  *     // a.getPid(). a.getProcess(), a.getProcessStdout() are available.</span>
<span class="line-added"> 56  *   LingeredApp.stopApp(a);</span>
<span class="line-added"> 57  *</span>
<span class="line-added"> 58  *   for use custom LingeredApp (class SmartTestApp extends LingeredApp):</span>
<span class="line-added"> 59  *</span>
<span class="line-added"> 60  *   SmartTestApp = new SmartTestApp();</span>
<span class="line-added"> 61  *   LingeredApp.startApp(a, cmd);</span>
 62  *     // do something
<span class="line-modified"> 63  *   a.stopApp();   // LingeredApp.stopApp(a) can be used as well</span>
 64  *
 65  *   or fine grained control
 66  *
 67  *   a = new SmartTestApp(&quot;MyLock.lck&quot;);
 68  *   a.createLock();
 69  *   a.runAppExactJvmOpts(Utils.getTestJavaOpts());
 70  *   a.waitAppReady();
 71  *     // do something
 72  *   a.deleteLock();
 73  *   a.waitAppTerminate();
 74  *
<span class="line-modified"> 75  *  After app termination (stopApp/waitAppTermination) its output is available</span>
 76  *
 77  *   output = a.getAppOutput();

 78  *
 79  */
 80 public class LingeredApp {
 81 
 82     private static final long spinDelay = 1000;
 83 
 84     private long lockCreationTime;
 85     private ByteArrayOutputStream stderrBuffer;
 86     private ByteArrayOutputStream stdoutBuffer;
 87     private Thread outPumperThread;
 88     private Thread errPumperThread;
 89 
 90     protected Process appProcess;
 91     protected OutputBuffer output;
 92     protected static final int appWaitTime = 100;
 93     protected final String lockFileName;
 94 
 95     /**
 96      * Create LingeredApp object on caller side. Lock file have be a valid filename
 97      * at writable location
</pre>
<hr />
<pre>
135     }
136 
137     /**
138      * @return the LingeredApp&#39;s output.
139      * Can be called after the app is run.
140      */
141     public String getProcessStdout() {
142         return stdoutBuffer.toString();
143     }
144 
145     /**
146      *
147      * @return OutputBuffer object for the LingeredApp&#39;s output. Can only be called
148      * after LingeredApp has exited.
149      */
150     public OutputBuffer getOutput() {
151         if (appProcess.isAlive()) {
152             throw new RuntimeException(&quot;Process is still alive. Can&#39;t get its output.&quot;);
153         }
154         if (output == null) {
<span class="line-modified">155             output = OutputBuffer.of(stdoutBuffer.toString(), stderrBuffer.toString(), appProcess.exitValue());</span>
156         }
157         return output;
158     }
159 
160     /*
161      * Capture all stdout and stderr output from the LingeredApp so it can be returned
162      * to the driver app later. This code is modeled after ProcessTools.getOutput().
163      */
164     private void startOutputPumpers() {
165         stderrBuffer = new ByteArrayOutputStream();
166         stdoutBuffer = new ByteArrayOutputStream();
167         StreamPumper outPumper = new StreamPumper(appProcess.getInputStream(), stdoutBuffer);
168         StreamPumper errPumper = new StreamPumper(appProcess.getErrorStream(), stderrBuffer);
169         outPumperThread = new Thread(outPumper);
170         errPumperThread = new Thread(errPumper);
171 
172         outPumperThread.setDaemon(true);
173         errPumperThread.setDaemon(true);
174 
175         outPumperThread.start();
176         errPumperThread.start();
177     }
178 












179     /* Make sure all part of the app use the same method to get dates,
180      as different methods could produce different results
181      */
182     private static long epoch() {
183         return new Date().getTime();
184     }
185 
186     private static long lastModified(String fileName) throws IOException {
187         Path path = Paths.get(fileName);
188         BasicFileAttributes attr = Files.readAttributes(path, BasicFileAttributes.class);
189         return attr.lastModifiedTime().toMillis();
190     }
191 
192     private static void setLastModified(String fileName, long newTime) throws IOException {
193         Path path = Paths.get(fileName);
194         FileTime fileTime = FileTime.fromMillis(newTime);
195         Files.setLastModifiedTime(path, fileTime);
196     }
197 
198     /**
</pre>
<hr />
<pre>
220             // Lock already deleted. Ignore error
221         }
222     }
223 
224     public void waitAppTerminate() {
225         // This code is modeled after tail end of ProcessTools.getOutput().
226         try {
227             appProcess.waitFor();
228             outPumperThread.join();
229             errPumperThread.join();
230         } catch (InterruptedException e) {
231             Thread.currentThread().interrupt();
232             // pass
233         }
234     }
235 
236     /**
237      * The app touches the lock file when it&#39;s started
238      * wait while it happens. Caller have to delete lock on wait error.
239      *
<span class="line-modified">240      * @param timeout timeout in seconds</span>
241      * @throws java.io.IOException
242      */
243     public void waitAppReady(long timeout) throws IOException {
<span class="line-added">244         // adjust timeout for timeout_factor and convert to ms</span>
<span class="line-added">245         timeout = Utils.adjustTimeout(timeout) * 1000;</span>
246         long here = epoch();
247         while (true) {
248             long epoch = epoch();
<span class="line-modified">249             if (epoch - here &gt; timeout) {</span>
250                 throw new IOException(&quot;App waiting timeout&quot;);
251             }
252 
253             // Live process should touch lock file every second
254             long lm = lastModified(lockFileName);
255             if (lm &gt; lockCreationTime) {
256                 break;
257             }
258 
259             // Make sure process didn&#39;t already exit
260             if (!appProcess.isAlive()) {
261                 throw new IOException(&quot;App exited unexpectedly with &quot; + appProcess.exitValue());
262             }
263 
264             try {
265                 Thread.sleep(spinDelay);
266             } catch (InterruptedException ex) {
267                 // pass
268             }
269         }
270     }
271 
<span class="line-added">272     /**</span>
<span class="line-added">273      * Waits the application to start with the default timeout.</span>
<span class="line-added">274      */</span>
<span class="line-added">275     public void waitAppReady() throws IOException {</span>
<span class="line-added">276         waitAppReady(appWaitTime);</span>
<span class="line-added">277     }</span>
<span class="line-added">278 </span>
279     /**
280      * Analyze an environment and prepare a command line to
281      * run the app, app name should be added explicitly
282      */
283     private List&lt;String&gt; runAppPrepare(String[] vmArguments) {
<span class="line-modified">284         List&lt;String&gt; cmd = new ArrayList&lt;&gt;();</span>
<span class="line-modified">285         cmd.add(JDKToolFinder.getTestJDKTool(&quot;java&quot;));</span>

















286         Collections.addAll(cmd, vmArguments);
287 
288         // Make sure we set correct classpath to run the app
289         cmd.add(&quot;-cp&quot;);
290         String classpath = System.getProperty(&quot;test.class.path&quot;);
291         cmd.add((classpath == null) ? &quot;.&quot; : classpath);
292 
293         return cmd;
294     }
295 
296     /**
297      * Adds application name to the command line.
298      * By default adds name of this class.
299      */
300     protected void runAddAppName(List&lt;String&gt; cmd) {
301         cmd.add(getClass().getName());
302     }
303 
304     /**
305      * Assemble command line to a printable string
306      */
307     public void printCommandLine(List&lt;String&gt; cmd) {
308         // A bit of verbosity
<span class="line-modified">309         System.out.println(cmd.stream()</span>
<span class="line-modified">310                 .map(s -&gt; &quot;&#39;&quot; + s + &quot;&#39;&quot;)</span>
<span class="line-modified">311                 .collect(Collectors.joining(&quot; &quot;, &quot;Command line: [&quot;, &quot;]&quot;)));</span>



312     }
313 
314     /**
315      * Run the app.
316      * User should provide exact options to run app. Might use #Utils.getTestJavaOpts() to set default test options.
317      * @param vmOpts
318      * @throws IOException
319      */
320     public void runAppExactJvmOpts(String[] vmOpts)
321             throws IOException {
322 
323         List&lt;String&gt; cmd = runAppPrepare(vmOpts);
324 
325         runAddAppName(cmd);
326         cmd.add(lockFileName);
327 
328         printCommandLine(cmd);
329 
330         ProcessBuilder pb = new ProcessBuilder(cmd);
331         // ProcessBuilder.start can throw IOException
332         appProcess = pb.start();
333 
334         startOutputPumpers();
335     }
336 
337     private void finishApp() {
338         if (appProcess != null) {
339             OutputBuffer output = getOutput();
340             String msg =
341                     &quot; LingeredApp stdout: [&quot; + output.getStdout() + &quot;];\n&quot; +
342                     &quot; LingeredApp stderr: [&quot; + output.getStderr() + &quot;]\n&quot; +
343                     &quot; LingeredApp exitValue = &quot; + appProcess.exitValue();
344 
<span class="line-modified">345             System.out.println(msg);</span>
346         }
347     }
348 
349     /**
350      * Delete lock file that signals app to terminate, then
351      * wait until app is actually terminated.
352      * @throws IOException
353      */
354     public void stopApp() throws IOException {
355         deleteLock();
356         // The startApp() of the derived app can throw
357         // an exception before the LA actually starts
358         if (appProcess != null) {
359             waitAppTerminate();
360 
361             finishApp();
362 
363             int exitcode = appProcess.exitValue();
364             if (exitcode != 0) {
365                 throw new IOException(&quot;LingeredApp terminated with non-zero exit code &quot; + exitcode);
366             }
367         }
368     }
369 
370     /**
371      *  High level interface for test writers
372      */
373 
374     /**
375      * Factory method that starts pre-created LingeredApp
376      * lock name is autogenerated
377      * User should provide exact options to run app. Might use #Utils.getTestJavaOpts() to set default test options.
378      * @param jvmOpts - the exact vm options used to start LingeredApp
379      * @param theApp - app to start
380      * @throws IOException
381      */
382     public static void startAppExactJvmOpts(LingeredApp theApp, String... jvmOpts) throws IOException {
383         theApp.createLock();
384         try {
385             theApp.runAppExactJvmOpts(jvmOpts);
<span class="line-modified">386             theApp.waitAppReady();</span>
387         } catch (Exception ex) {
388             theApp.deleteLock();
389             throw ex;
390         }
391     }
392 
393     /**
394      * Factory method that starts pre-created LingeredApp
395      * lock name is autogenerated, additionalJvmOpts are appended to default test options
396      * @param additionalJvmOpts - additional Jvm options, appended to #Utils.getTestJavaOpts();
397      * @param theApp - app to start
398      * @throws IOException
399      */
400     public static void startApp(LingeredApp theApp, String... additionalJvmOpts) throws IOException {
401         startAppExactJvmOpts(theApp, Utils.prependTestJavaOpts(additionalJvmOpts));
402     }
403 
404     /**
405      * Factory method that creates LingeredApp object with ready to use application
406      * lock name is autogenerated, additionalJvmOpts are appended to default test options
407      * @param additionalJvmOpts - additional Jvm options, appended to #Utils.getTestJavaOpts();
408      * @return LingeredApp object
409      * @throws IOException
410      */
411     public static LingeredApp startApp(String... additionalJvmOpts) throws IOException {
412         LingeredApp a = new LingeredApp();
413         try {
414             startApp(a, additionalJvmOpts);
415         } catch (Exception ex) {
<span class="line-modified">416             System.out.println(&quot;LingeredApp failed to start: &quot; + ex);</span>
417             a.finishApp();
418             throw ex;
419         }
420 
421         return a;
422     }
423 
424     public static void stopApp(LingeredApp app) throws IOException {
425         if (app != null) {
426             // LingeredApp can throw an exception during the intialization,
427             // make sure we don&#39;t have cascade NPE
428             app.stopApp();
429         }
430     }
431 
432     /**
433      * LastModified time might not work correctly in some cases it might
434      * cause later failures
435      */
436 
</pre>
</td>
</tr>
</table>
<center><a href="../../../../ClassFileInstaller.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../process/OutputBuffer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
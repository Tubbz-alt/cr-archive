<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ProgrammableUpcallHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UpcallStubs.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 60                     methodType(MemoryAddress.class));
 61             MH_BUFFER_COPY = lookup.findStatic(SharedUtils.class, &quot;bufferCopy&quot;,
 62                     methodType(MemoryAddress.class, MemoryAddress.class, MemorySegment.class));
 63         } catch (ReflectiveOperationException e) {
 64             throw new BootstrapMethodError(e);
 65         }
 66     }
 67 
 68     /**
 69      * Align the specified type from a given address
 70      * @return The address the data should be at based on alignment requirement
 71      */
 72     public static long align(MemoryLayout t, boolean isVar, long addr) {
 73         return alignUp(addr, alignment(t, isVar));
 74     }
 75 
 76     public static long alignUp(long addr, long alignment) {
 77         return ((addr - 1) | (alignment - 1)) + 1;
 78     }
 79 
<span class="line-removed"> 80     public static long alignDown(long addr, long alignment) {</span>
<span class="line-removed"> 81         return addr &amp; ~(alignment - 1);</span>
<span class="line-removed"> 82     }</span>
<span class="line-removed"> 83 </span>
 84     /**
 85      * The alignment requirement for a given type
 86      * @param isVar indicate if the type is a standalone variable. This change how
 87      * array is aligned. for example.
 88      */
 89     public static long alignment(MemoryLayout t, boolean isVar) {
 90         if (t instanceof ValueLayout) {
 91             return alignmentOfScalar((ValueLayout) t);
 92         } else if (t instanceof SequenceLayout) {
 93             // when array is used alone
 94             return alignmentOfArray((SequenceLayout) t, isVar);
 95         } else if (t instanceof GroupLayout) {
 96             return alignmentOfContainer((GroupLayout) t);
 97         } else if (Utils.isPadding(t)) {
 98             return 1;
 99         } else {
100             throw new IllegalArgumentException(&quot;Invalid type: &quot; + t);
101         }
102     }
103 
104     private static long alignmentOfScalar(ValueLayout st) {
105         return st.byteSize();
106     }
107 
108     private static long alignmentOfArray(SequenceLayout ar, boolean isVar) {
<span class="line-modified">109         if (ar.elementCount().getAsLong() == 0) {</span>
110             // VLA or incomplete
111             return 16;
112         } else if ((ar.byteSize()) &gt;= 16 &amp;&amp; isVar) {
113             return 16;
114         } else {
115             // align as element type
116             MemoryLayout elementType = ar.elementLayout();
117             return alignment(elementType, false);
118         }
119     }
120 
121     private static long alignmentOfContainer(GroupLayout ct) {
122         // Most strict member
123         return ct.memberLayouts().stream().mapToLong(t -&gt; alignment(t, false)).max().orElse(1);
124     }
125 
126     /**
127      * Takes a MethodHandle that takes an input buffer as a first argument (a MemoryAddress), and returns nothing,
128      * and adapts it to return a MemorySegment, by allocating a MemorySegment for the input
129      * buffer, calling the target MethodHandle, and then returning the allocated MemorySegment.
</pre>
</td>
<td>
<hr />
<pre>
 60                     methodType(MemoryAddress.class));
 61             MH_BUFFER_COPY = lookup.findStatic(SharedUtils.class, &quot;bufferCopy&quot;,
 62                     methodType(MemoryAddress.class, MemoryAddress.class, MemorySegment.class));
 63         } catch (ReflectiveOperationException e) {
 64             throw new BootstrapMethodError(e);
 65         }
 66     }
 67 
 68     /**
 69      * Align the specified type from a given address
 70      * @return The address the data should be at based on alignment requirement
 71      */
 72     public static long align(MemoryLayout t, boolean isVar, long addr) {
 73         return alignUp(addr, alignment(t, isVar));
 74     }
 75 
 76     public static long alignUp(long addr, long alignment) {
 77         return ((addr - 1) | (alignment - 1)) + 1;
 78     }
 79 




 80     /**
 81      * The alignment requirement for a given type
 82      * @param isVar indicate if the type is a standalone variable. This change how
 83      * array is aligned. for example.
 84      */
 85     public static long alignment(MemoryLayout t, boolean isVar) {
 86         if (t instanceof ValueLayout) {
 87             return alignmentOfScalar((ValueLayout) t);
 88         } else if (t instanceof SequenceLayout) {
 89             // when array is used alone
 90             return alignmentOfArray((SequenceLayout) t, isVar);
 91         } else if (t instanceof GroupLayout) {
 92             return alignmentOfContainer((GroupLayout) t);
 93         } else if (Utils.isPadding(t)) {
 94             return 1;
 95         } else {
 96             throw new IllegalArgumentException(&quot;Invalid type: &quot; + t);
 97         }
 98     }
 99 
100     private static long alignmentOfScalar(ValueLayout st) {
101         return st.byteSize();
102     }
103 
104     private static long alignmentOfArray(SequenceLayout ar, boolean isVar) {
<span class="line-modified">105         if (ar.elementCount().orElseThrow() == 0) {</span>
106             // VLA or incomplete
107             return 16;
108         } else if ((ar.byteSize()) &gt;= 16 &amp;&amp; isVar) {
109             return 16;
110         } else {
111             // align as element type
112             MemoryLayout elementType = ar.elementLayout();
113             return alignment(elementType, false);
114         }
115     }
116 
117     private static long alignmentOfContainer(GroupLayout ct) {
118         // Most strict member
119         return ct.memberLayouts().stream().mapToLong(t -&gt; alignment(t, false)).max().orElse(1);
120     }
121 
122     /**
123      * Takes a MethodHandle that takes an input buffer as a first argument (a MemoryAddress), and returns nothing,
124      * and adapts it to return a MemorySegment, by allocating a MemorySegment for the input
125      * buffer, calling the target MethodHandle, and then returning the allocated MemorySegment.
</pre>
</td>
</tr>
</table>
<center><a href="ProgrammableUpcallHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UpcallStubs.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
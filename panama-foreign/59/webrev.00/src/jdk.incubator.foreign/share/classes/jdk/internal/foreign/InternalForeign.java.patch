diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
@@ -47,15 +47,15 @@
     private static final InternalForeign INSTANCE = new InternalForeign();
 
     private InternalForeign() {}
 
     public static InternalForeign getInstance() {
-        checkRestrictedAcccess();
-        return getInstancePriviledged();
+        checkRestrictedAccess();
+        return getInstancePrivileged();
     }
 
-    public static InternalForeign getInstancePriviledged() {
+    public static InternalForeign getInstancePrivileged() {
         return INSTANCE;
     }
 
     @Override
     public long asLong(MemoryAddress address) throws IllegalAccessError {
@@ -81,19 +81,19 @@
             return AArch64ABI.getInstance();
         }
         throw new UnsupportedOperationException("Unsupported os or arch: " + os + ", " + arch);
     }
 
-    private static void checkRestrictedAcccess() {
+    private static void checkRestrictedAccess() {
         switch (foreignAccess) {
             case "deny" -> throwIllegalAccessError(foreignAccess);
             case "warn" -> System.err.println("WARNING: Accessing jdk.incubator.foreign.Foreign.");
             case "debug" -> {
                 StringBuilder sb = new StringBuilder("DEBUG: Accessing jdk.incubator.foreign.Foreign.");
                 StackWalker.getInstance().walk(s -> {
                      s
-                     .forEach(f -> sb.append(System.lineSeparator()).append("\tat " + f));
+                     .forEach(f -> sb.append(System.lineSeparator()).append("\tat ").append(f));
                     return null;
                 });
                 System.out.println(sb.toString());
             }
             case "permit" -> {}

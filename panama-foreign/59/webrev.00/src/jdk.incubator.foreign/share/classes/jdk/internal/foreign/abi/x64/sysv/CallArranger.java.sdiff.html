<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../aarch64/CallArranger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SysVx64ABI.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
340                     break;
341                 }
342                 case FLOAT: {
343                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);
344                     bindings.move(storage, carrier);
345                     break;
346                 }
347                 default:
348                     throw new UnsupportedOperationException(&quot;Unhandled class &quot; + argumentClass);
349             }
350             return bindings.build();
351         }
352     }
353 
354     static class BoxBindingCalculator extends BindingCalculator {
355 
356         BoxBindingCalculator(boolean forArguments) {
357             super(forArguments);
358         }
359 
<span class="line-removed">360         @SuppressWarnings(&quot;fallthrough&quot;)</span>
361         @Override
362         List&lt;Binding&gt; getBindings(Class&lt;?&gt; carrier, MemoryLayout layout) {
363             TypeClass argumentClass = classifyLayout(layout);
364             Binding.Builder bindings = Binding.builder();
365             switch (argumentClass.kind) {
366                 case STRUCT: {
367                     assert carrier == MemorySegment.class;
368                     bindings.allocate(layout);
369                     VMStorage[] regs = storageCalculator.structStorages(argumentClass);
370                     int regIndex = 0;
371                     long offset = 0;
372                     while (offset &lt; layout.byteSize()) {
373                         final long copy = Math.min(layout.byteSize() - offset, 8);
374                         VMStorage storage = regs[regIndex++];
375                         bindings.dup();
376                         Class&lt;?&gt; type = SharedUtils.primitiveCarrierForSize(copy);
377                         bindings.move(storage, type)
378                                 .dereference(offset, type);
379                         offset += copy;
380                     }
</pre>
<hr />
<pre>
420     }
421 
422 
423     private static List&lt;ArgumentClassImpl&gt; createMemoryClassArray(long size) {
424         return IntStream.range(0, (int)size)
425                 .mapToObj(i -&gt; ArgumentClassImpl.MEMORY)
426                 .collect(Collectors.toCollection(ArrayList::new));
427     }
428 
429 
430     private static List&lt;ArgumentClassImpl&gt; classifyValueType(ValueLayout type) {
431         ArrayList&lt;ArgumentClassImpl&gt; classes = new ArrayList&lt;&gt;();
432         var optAbiType = type.abiType();
433         //padding not allowed here
434         ArgumentClassImpl clazz = optAbiType.map(SysVx64ABI::argumentClassFor).
435             orElseThrow(()-&gt;new IllegalStateException(&quot;Unexpected value layout: could not determine ABI class&quot;));
436         if (clazz == null) {
437             //padding not allowed here
438             throw new IllegalStateException(&quot;Unexpected value layout: could not determine ABI class&quot;);
439         }
<span class="line-removed">440         if (clazz == ArgumentClassImpl.POINTER) {</span>
<span class="line-removed">441             clazz = ArgumentClassImpl.POINTER;</span>
<span class="line-removed">442         }</span>
443         classes.add(clazz);
444         if (clazz == ArgumentClassImpl.INTEGER) {
445             // int128
446             long left = (type.byteSize()) - 8;
447             while (left &gt; 0) {
448                 classes.add(ArgumentClassImpl.INTEGER);
449                 left -= 8;
450             }
451             return classes;
452         } else if (clazz == ArgumentClassImpl.X87) {
453             classes.add(ArgumentClassImpl.X87UP);
454         }
455 
456         return classes;
457     }
458 
459     private static List&lt;ArgumentClassImpl&gt; classifyArrayType(SequenceLayout type) {
460         long nWords = Utils.alignUp((type.byteSize()), 8) / 8;
461         if (nWords &gt; MAX_AGGREGATE_REGS_SIZE) {
462             return createMemoryClassArray(nWords);
463         }
464 
465         ArrayList&lt;ArgumentClassImpl&gt; classes = new ArrayList&lt;&gt;();
466 
467         for (long i = 0; i &lt; nWords; i++) {
468             classes.add(ArgumentClassImpl.NO_CLASS);
469         }
470 
471         long offset = 0;
<span class="line-modified">472         final long count = type.elementCount().getAsLong();</span>
473         for (long idx = 0; idx &lt; count; idx++) {
474             MemoryLayout t = type.elementLayout();
475             offset = SharedUtils.align(t, false, offset);
476             List&lt;ArgumentClassImpl&gt; subclasses = classifyType(t);
477             if (subclasses.isEmpty()) {
478                 return classes;
479             }
480 
481             for (int i = 0; i &lt; subclasses.size(); i++) {
482                 int pos = (int)(offset / 8);
483                 ArgumentClassImpl newClass = classes.get(i + pos).merge(subclasses.get(i));
484                 classes.set(i + pos, newClass);
485             }
486 
487             offset += t.byteSize();
488         }
489 
490         for (int i = 0; i &lt; classes.size(); i++) {
491             ArgumentClassImpl c = classes.get(i);
492 
</pre>
<hr />
<pre>
533         if (nWords &gt; MAX_AGGREGATE_REGS_SIZE) {
534             return createMemoryClassArray(nWords);
535         }
536 
537         ArrayList&lt;ArgumentClassImpl&gt; classes = new ArrayList&lt;&gt;();
538 
539         for (long i = 0; i &lt; nWords; i++) {
540             classes.add(ArgumentClassImpl.NO_CLASS);
541         }
542 
543         long offset = 0;
544         final int count = type.memberLayouts().size();
545         for (int idx = 0; idx &lt; count; idx++) {
546             MemoryLayout t = type.memberLayouts().get(idx);
547             if (Utils.isPadding(t)) {
548                 continue;
549             }
550             // ignore zero-length array for now
551             // TODO: handle zero length arrays here
552             if (t instanceof SequenceLayout) {
<span class="line-modified">553                 if (((SequenceLayout) t).elementCount().getAsLong() == 0) {</span>
554                     continue;
555                 }
556             }
557             offset = SharedUtils.align(t, false, offset);
558             List&lt;ArgumentClassImpl&gt; subclasses = classifyType(t);
559             if (subclasses.isEmpty()) {
560                 return classes;
561             }
562 
563             for (int i = 0; i &lt; subclasses.size(); i++) {
564                 int pos = (int)(offset / 8);
565                 ArgumentClassImpl newClass = classes.get(i + pos).merge(subclasses.get(i));
566                 classes.set(i + pos, newClass);
567             }
568 
569             // TODO: validate union strategy is sound
570             if (type.isStruct()) {
571                 offset += t.byteSize();
572             }
573         }
</pre>
</td>
<td>
<hr />
<pre>
340                     break;
341                 }
342                 case FLOAT: {
343                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);
344                     bindings.move(storage, carrier);
345                     break;
346                 }
347                 default:
348                     throw new UnsupportedOperationException(&quot;Unhandled class &quot; + argumentClass);
349             }
350             return bindings.build();
351         }
352     }
353 
354     static class BoxBindingCalculator extends BindingCalculator {
355 
356         BoxBindingCalculator(boolean forArguments) {
357             super(forArguments);
358         }
359 

360         @Override
361         List&lt;Binding&gt; getBindings(Class&lt;?&gt; carrier, MemoryLayout layout) {
362             TypeClass argumentClass = classifyLayout(layout);
363             Binding.Builder bindings = Binding.builder();
364             switch (argumentClass.kind) {
365                 case STRUCT: {
366                     assert carrier == MemorySegment.class;
367                     bindings.allocate(layout);
368                     VMStorage[] regs = storageCalculator.structStorages(argumentClass);
369                     int regIndex = 0;
370                     long offset = 0;
371                     while (offset &lt; layout.byteSize()) {
372                         final long copy = Math.min(layout.byteSize() - offset, 8);
373                         VMStorage storage = regs[regIndex++];
374                         bindings.dup();
375                         Class&lt;?&gt; type = SharedUtils.primitiveCarrierForSize(copy);
376                         bindings.move(storage, type)
377                                 .dereference(offset, type);
378                         offset += copy;
379                     }
</pre>
<hr />
<pre>
419     }
420 
421 
422     private static List&lt;ArgumentClassImpl&gt; createMemoryClassArray(long size) {
423         return IntStream.range(0, (int)size)
424                 .mapToObj(i -&gt; ArgumentClassImpl.MEMORY)
425                 .collect(Collectors.toCollection(ArrayList::new));
426     }
427 
428 
429     private static List&lt;ArgumentClassImpl&gt; classifyValueType(ValueLayout type) {
430         ArrayList&lt;ArgumentClassImpl&gt; classes = new ArrayList&lt;&gt;();
431         var optAbiType = type.abiType();
432         //padding not allowed here
433         ArgumentClassImpl clazz = optAbiType.map(SysVx64ABI::argumentClassFor).
434             orElseThrow(()-&gt;new IllegalStateException(&quot;Unexpected value layout: could not determine ABI class&quot;));
435         if (clazz == null) {
436             //padding not allowed here
437             throw new IllegalStateException(&quot;Unexpected value layout: could not determine ABI class&quot;);
438         }



439         classes.add(clazz);
440         if (clazz == ArgumentClassImpl.INTEGER) {
441             // int128
442             long left = (type.byteSize()) - 8;
443             while (left &gt; 0) {
444                 classes.add(ArgumentClassImpl.INTEGER);
445                 left -= 8;
446             }
447             return classes;
448         } else if (clazz == ArgumentClassImpl.X87) {
449             classes.add(ArgumentClassImpl.X87UP);
450         }
451 
452         return classes;
453     }
454 
455     private static List&lt;ArgumentClassImpl&gt; classifyArrayType(SequenceLayout type) {
456         long nWords = Utils.alignUp((type.byteSize()), 8) / 8;
457         if (nWords &gt; MAX_AGGREGATE_REGS_SIZE) {
458             return createMemoryClassArray(nWords);
459         }
460 
461         ArrayList&lt;ArgumentClassImpl&gt; classes = new ArrayList&lt;&gt;();
462 
463         for (long i = 0; i &lt; nWords; i++) {
464             classes.add(ArgumentClassImpl.NO_CLASS);
465         }
466 
467         long offset = 0;
<span class="line-modified">468         final long count = type.elementCount().orElseThrow();</span>
469         for (long idx = 0; idx &lt; count; idx++) {
470             MemoryLayout t = type.elementLayout();
471             offset = SharedUtils.align(t, false, offset);
472             List&lt;ArgumentClassImpl&gt; subclasses = classifyType(t);
473             if (subclasses.isEmpty()) {
474                 return classes;
475             }
476 
477             for (int i = 0; i &lt; subclasses.size(); i++) {
478                 int pos = (int)(offset / 8);
479                 ArgumentClassImpl newClass = classes.get(i + pos).merge(subclasses.get(i));
480                 classes.set(i + pos, newClass);
481             }
482 
483             offset += t.byteSize();
484         }
485 
486         for (int i = 0; i &lt; classes.size(); i++) {
487             ArgumentClassImpl c = classes.get(i);
488 
</pre>
<hr />
<pre>
529         if (nWords &gt; MAX_AGGREGATE_REGS_SIZE) {
530             return createMemoryClassArray(nWords);
531         }
532 
533         ArrayList&lt;ArgumentClassImpl&gt; classes = new ArrayList&lt;&gt;();
534 
535         for (long i = 0; i &lt; nWords; i++) {
536             classes.add(ArgumentClassImpl.NO_CLASS);
537         }
538 
539         long offset = 0;
540         final int count = type.memberLayouts().size();
541         for (int idx = 0; idx &lt; count; idx++) {
542             MemoryLayout t = type.memberLayouts().get(idx);
543             if (Utils.isPadding(t)) {
544                 continue;
545             }
546             // ignore zero-length array for now
547             // TODO: handle zero length arrays here
548             if (t instanceof SequenceLayout) {
<span class="line-modified">549                 if (((SequenceLayout) t).elementCount().orElseThrow() == 0) {</span>
550                     continue;
551                 }
552             }
553             offset = SharedUtils.align(t, false, offset);
554             List&lt;ArgumentClassImpl&gt; subclasses = classifyType(t);
555             if (subclasses.isEmpty()) {
556                 return classes;
557             }
558 
559             for (int i = 0; i &lt; subclasses.size(); i++) {
560                 int pos = (int)(offset / 8);
561                 ArgumentClassImpl newClass = classes.get(i + pos).merge(subclasses.get(i));
562                 classes.set(i + pos, newClass);
563             }
564 
565             // TODO: validate union strategy is sound
566             if (type.isStruct()) {
567                 offset += t.byteSize();
568             }
569         }
</pre>
</td>
</tr>
</table>
<center><a href="../../aarch64/CallArranger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SysVx64ABI.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AllocationScope.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AllocationScope.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AllocationScope.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.internal.clang;
-
-import jdk.incubator.foreign.MemorySegment;
-
-import java.util.LinkedHashSet;
-import java.util.Set;
-
-class AllocationScope implements AutoCloseable {
-    private final Set<MemorySegment> segments = new LinkedHashSet<>();
-
-    MemorySegment track(MemorySegment segment) {
-        if (!segments.add(segment)) {
-            throw new IllegalArgumentException("Attempt to track a memory segment twice");
-        }
-        return segment;
-    }
-
-    void forget(MemorySegment segment) {
-        if (!segments.remove(segment)) {
-            throw new IllegalArgumentException("Attempt to forget a memory segment not tracked by this scope");
-        }
-    }
-
-    @Override
-    public void close() {
-        var currentThread = Thread.currentThread();
-        segments.stream()
-                .filter(ms -> ms.ownerThread() == currentThread)
-                .forEach(MemorySegment::close);
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java
@@ -333,19 +333,30 @@
      */
     public Cursor getSpecializedCursorTemplate() {
         return new Cursor(Index_h.clang_getSpecializedCursorTemplate(cursor));
     }
 
-    public Stream<Cursor> children() {
-        final ArrayList<Cursor> ar = new ArrayList<>();
-        // FIXME: need a way to pass ar down as user data
-        Index_h.clang_visitChildren(cursor, Index_h.clang_visitChildren$visitor$make((c, p, d) -> {
+    private static class CursorChildren {
+        private static final ArrayList<Cursor> children = new ArrayList<>();
+        private static final MemoryAddress callback = Index_h.clang_visitChildren$visitor$allocate((c, p, d) -> {
             Cursor cursor = new Cursor(c);
-            ar.add(cursor);
+            children.add(cursor);
             return Index_h.CXChildVisit_Continue;
-        }), MemoryAddress.NULL);
-        return ar.stream();
+        });
+
+        synchronized static Stream<Cursor> get(Cursor c) {
+            try {
+                Index_h.clang_visitChildren(c.cursor, callback, MemoryAddress.NULL);
+                return new ArrayList<>(children).stream();
+            } finally {
+                children.clear();
+            }
+        }
+    }
+
+    public Stream<Cursor> children() {
+        return CursorChildren.get(this);
     }
 
     public Stream<Cursor> allChildren() {
         return children().flatMap(c -> Stream.concat(Stream.of(c), c.children()));
     }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java
@@ -24,10 +24,11 @@
  *
  */
 
 package jdk.internal.clang;
 
+import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.internal.clang.libclang.Index_h;
 
 public class EvalResult implements AutoCloseable {
     private MemoryAddress ptr;
@@ -88,11 +89,11 @@
         }
     }
 
     private String getAsString0() {
         MemoryAddress value = Index_h.clang_EvalResult_getAsStr(ptr);
-        return Utils.toJavaString(value);
+        return CSupport.toJavaStringRestricted(value);
     }
 
     public String getAsString() {
         Kind kind = getKind();
         switch (kind) {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java
@@ -25,20 +25,23 @@
  */
 
 package jdk.internal.clang;
 
 import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.internal.clang.libclang.Index_h;
 
 import java.lang.invoke.VarHandle;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Consumer;
+import java.util.stream.Stream;
 
 public class Index implements AutoCloseable {
     // Pointer to CXIndex
     private MemoryAddress ptr;
     // Set of TranslationUnit
@@ -78,13 +81,17 @@
     private static final VarHandle VH_MemoryAddress =
             MemoryHandles.asAddressVarHandle(CSupport.C_POINTER.varHandle(long.class));
 
     public TranslationUnit parseTU(String file, Consumer<Diagnostic> dh, int options, String... args)
     throws ParsingFailedException {
-        try (MemorySegment src = Utils.toNativeString(file) ;
-             MemorySegment cargs = Utils.toNativeStringArray(args);
-             MemorySegment outAddress = MemorySegment.allocateNative(CSupport.C_POINTER)) {
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            MemorySegment src = CSupport.toCString(file, scope);
+            MemorySegment cargs = scope.allocateArray(CSupport.C_POINTER, args.length);
+            for (int i = 0 ; i < args.length ; i++) {
+                MemoryAccess.setAddressAtIndex(cargs, i, CSupport.toCString(args[i], scope).address());
+            }
+            MemorySegment outAddress = scope.allocate(CSupport.C_POINTER);
             ErrorCode code = ErrorCode.valueOf(Index_h.clang_parseTranslationUnit2(
                     ptr,
                     src.address(),
                     cargs == null ? MemoryAddress.NULL : cargs.address(),
                     args.length, MemoryAddress.NULL,
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java
@@ -39,11 +39,11 @@
 public class LibClang {
     private static final boolean DEBUG = Boolean.getBoolean("libclang.debug");
     private static final boolean CRASH_RECOVERY = Boolean.getBoolean("libclang.crash_recovery");
 
     private final static MemorySegment disableCrashRecovery =
-            Utils.toNativeString("LIBCLANG_DISABLE_CRASH_RECOVERY=" + CRASH_RECOVERY)
+            CSupport.toCString("LIBCLANG_DISABLE_CRASH_RECOVERY=" + CRASH_RECOVERY)
                 .withAccessModes(MemorySegment.READ);
 
     static {
         if (!CRASH_RECOVERY) {
             //this is an hack - needed because clang_toggleCrashRecovery only takes effect _after_ the
@@ -70,11 +70,11 @@
         return index;
     }
 
     public static String CXStrToString(MemorySegment cxstr) {
         MemoryAddress buf = Index_h.clang_getCString(cxstr);
-        String str = Utils.toJavaString(buf);
+        String str = CSupport.toJavaStringRestricted(buf);
         Index_h.clang_disposeString(cxstr);
         return str;
     }
 
     public static String version() {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java
@@ -24,10 +24,11 @@
  *
  */
 package jdk.internal.clang;
 
 import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.internal.clang.libclang.Index_h;
 
 import java.nio.file.Path;
@@ -54,19 +55,19 @@
              MemorySegment line = MemorySegment.allocateNative(CSupport.C_INT);
              MemorySegment col = MemorySegment.allocateNative(CSupport.C_INT);
              MemorySegment offset = MemorySegment.allocateNative(CSupport.C_INT)) {
 
             fn.get(loc, file.address(), line.address(), col.address(), offset.address());
-            MemoryAddress fname = Utils.getPointer(file);
+            MemoryAddress fname = MemoryAccess.getAddress(file);
 
 
             String str = fname == MemoryAddress.NULL ?
                     null :
                     LibClang.CXStrToString(Index_h.clang_getFileName(fname));
 
-            return new Location(str, Utils.getInt(line),
-                Utils.getInt(col), Utils.getInt(offset));
+            return new Location(str, MemoryAccess.getInt(line),
+                MemoryAccess.getInt(col), MemoryAccess.getInt(offset));
         }
     }
 
     public Location getFileLocation() { return getLocation(Index_h::clang_getFileLocation); }
     public Location getExpansionLocation() { return getLocation(Index_h::clang_getExpansionLocation); }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java
@@ -25,13 +25,15 @@
  */
 
 package jdk.internal.clang;
 
 import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.internal.clang.libclang.Index_h;
 
 import java.io.IOException;
 import java.nio.file.Path;
 import java.util.Objects;
@@ -59,11 +61,11 @@
 
         return rv;
     }
 
     public final void save(Path path) throws TranslationUnitSaveException {
-        try (MemorySegment pathStr = Utils.toNativeString(path.toAbsolutePath().toString())) {
+        try (MemorySegment pathStr = CSupport.toCString(path.toAbsolutePath().toString())) {
             SaveError res = SaveError.valueOf(Index_h.clang_saveTranslationUnit(tu, pathStr.address(), 0));
             if (res != SaveError.None) {
                 throw new TranslationUnitSaveException(path, res);
             }
         }
@@ -79,19 +81,19 @@
     static long FILENAME_OFFSET = Index_h.CXUnsavedFile$LAYOUT.bitOffset(MemoryLayout.PathElement.groupElement("Filename")) / 8;
     static long CONTENTS_OFFSET = Index_h.CXUnsavedFile$LAYOUT.bitOffset(MemoryLayout.PathElement.groupElement("Contents")) / 8;
     static long LENGTH_OFFSET = Index_h.CXUnsavedFile$LAYOUT.bitOffset(MemoryLayout.PathElement.groupElement("Length")) / 8;
 
     public void reparse(Index.UnsavedFile... inMemoryFiles) {
-        try (AllocationScope scope = new AllocationScope()) {
+        try (NativeScope scope = NativeScope.unboundedScope()) {
             MemorySegment files = inMemoryFiles.length == 0 ?
                     null :
-                    scope.track(MemorySegment.allocateNative(MemoryLayout.ofSequence(inMemoryFiles.length, Index_h.CXUnsavedFile$LAYOUT)));
+                    scope.allocateArray(Index_h.CXUnsavedFile$LAYOUT, inMemoryFiles.length);
             for (int i = 0; i < inMemoryFiles.length; i++) {
                 MemorySegment start = files.asSlice(i * Index_h.CXUnsavedFile$LAYOUT.byteSize());
-                Utils.setPointer(start.asSlice(FILENAME_OFFSET), scope.track(Utils.toNativeString(inMemoryFiles[i].file)).address());
-                Utils.setPointer(start.asSlice(CONTENTS_OFFSET), scope.track(Utils.toNativeString(inMemoryFiles[i].contents)).address());
-                Utils.setLong(start.asSlice(LENGTH_OFFSET), inMemoryFiles[i].contents.length());
+                MemoryAccess.setAddress(start.asSlice(FILENAME_OFFSET), CSupport.toCString(inMemoryFiles[i].file, scope).address());
+                MemoryAccess.setAddress(start.asSlice(CONTENTS_OFFSET), CSupport.toCString(inMemoryFiles[i].contents, scope).address());
+                MemoryAccess.setLong(start.asSlice(LENGTH_OFFSET), inMemoryFiles[i].contents.length());
             }
             ErrorCode code = ErrorCode.valueOf(Index_h.clang_reparseTranslationUnit(
                         tu,
                         inMemoryFiles.length,
                         files == null ? MemoryAddress.NULL : files.address(),
@@ -119,11 +121,11 @@
 
     public Tokens tokenize(SourceRange range) {
         MemorySegment p = MemorySegment.allocateNative(CSupport.C_POINTER);
         MemorySegment pCnt = MemorySegment.allocateNative(CSupport.C_INT);
         Index_h.clang_tokenize(tu, range.range, p.address(), pCnt.address());
-        Tokens rv = new Tokens(Utils.getPointer(p), Utils.getInt(pCnt));
+        Tokens rv = new Tokens(MemoryAccess.getAddress(p), MemoryAccess.getInt(pCnt));
         return rv;
     }
 
     @Override
     public void close() {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java
@@ -24,10 +24,11 @@
  *
  */
 
 package jdk.internal.clang;
 
+import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.internal.clang.libclang.Index_h;
 
 
 public final class Type {
@@ -106,11 +107,11 @@
         return Index_h.clang_getNumElements(type);
     }
 
     // Struct/RecordType
     private long getOffsetOf0(String fieldName) {
-        try (MemorySegment cfname = Utils.toNativeString(fieldName)) {
+        try (MemorySegment cfname = CSupport.toCString(fieldName)) {
             return Index_h.clang_Type_getOffsetOf(type, cfname.address());
         }
     }
 
     public long getOffsetOf(String fieldName) {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.internal.clang;
-
-import jdk.incubator.foreign.CSupport;
-import jdk.incubator.foreign.MemoryAccess;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-
-public class Utils {
-
-    static int getInt(MemorySegment addr) {
-        return MemoryAccess.getInt(addr);
-    }
-
-    static void setLong(MemorySegment addr, long i) {
-        MemoryAccess.setLong(addr, i);
-    }
-
-    static MemoryAddress getPointer(MemorySegment addr) {
-        return MemoryAccess.getAddress(addr);
-    }
-
-    static void setPointer(MemorySegment addr, MemoryAddress ptr) {
-        MemoryAccess.setAddress(addr, ptr);
-    }
-
-    static MemorySegment toNativeString(String value) {
-        return toNativeString(value, value.length() + 1);
-    }
-
-    static MemorySegment toNativeString(String value, int length) {
-        MemoryLayout strLayout = MemoryLayout.ofSequence(length, CSupport.C_CHAR);
-        MemorySegment segment = MemorySegment.allocateNative(strLayout);
-        for (int i = 0 ; i < value.length() ; i++) {
-            MemoryAccess.setByteAtOffset(segment, i, (byte)value.charAt(i));
-        }
-        MemoryAccess.setByteAtOffset(segment, value.length(), (byte)0);
-        return segment;
-    }
-
-    static String toJavaString(MemoryAddress address) {
-        return CSupport.toJavaStringRestricted(address);
-    }
-
-    static MemorySegment toNativeStringArray(String[] ar) {
-        if (ar.length == 0) {
-            return null;
-        }
-
-        MemorySegment segment = MemorySegment.allocateNative(MemoryLayout.ofSequence(ar.length, CSupport.C_POINTER));
-        for (int i = 0; i < ar.length; i++) {
-            MemoryAccess.setAddressAtIndex(segment, i, toNativeString(ar[i]).address());
-        }
-
-        return segment;
-    }
-
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java
@@ -4338,11 +4338,11 @@
         CSupport.C_POINTER
     );
     public interface clang_visitChildren$visitor {
         int apply(MemorySegment x0, MemorySegment x1, MemoryAddress x2);
     }
-    public static final MemoryAddress clang_visitChildren$visitor$make(clang_visitChildren$visitor fi) {
+    public static final MemoryAddress clang_visitChildren$visitor$allocate(clang_visitChildren$visitor fi) {
         return RuntimeHelper.upcallStub(clang_visitChildren$visitor.class, fi, clang_visitChildren$visitor$DESC, "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;)I");
     }
     public static final MethodHandle clang_getCursorUSR = RuntimeHelper.downcallHandle(
         LIBRARIES, "clang_getCursorUSR",
         "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",

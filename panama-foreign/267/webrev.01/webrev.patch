diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/ConstantHelper.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/ConstantHelper.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/ConstantHelper.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/ConstantHelper.java
@@ -91,17 +91,10 @@
             desc(MemoryAddress.class),
             "ofLong",
             desc(methodType(MemoryAddress.class, long.class))
     );
 
-    private static final DirectMethodHandleDesc MH_MemorySegment_baseAddress = MethodHandleDesc.ofMethod(
-            Kind.INTERFACE_VIRTUAL,
-            desc(MemorySegment.class),
-            "address",
-            desc(methodType(MemoryAddress.class))
-    );
-
     private static final DirectMethodHandleDesc MH_MemoryHandles_asAddressVarHandle = MethodHandleDesc.ofMethod(
             Kind.STATIC,
             desc(MemoryHandles.class),
             "asAddressVarHandle",
             desc(methodType(VarHandle.class, VarHandle.class))
@@ -161,11 +154,11 @@
         );
         this.MH_lookupGlobalVariable = findRuntimeHelperBootstrap(
                 runtimeHelper,
                 "lookupGlobalVariable",
                 methodType(
-                        MemoryAddress.class,
+                        MemorySegment.class,
                         LibraryLookup[].class,
                         String.class,
                         MemoryLayout.class)
         );
         this.MH_makeCString = findRuntimeHelperBootstrap(
@@ -207,22 +200,26 @@
     public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
         return emitCondyGetter(javaName + "$MH", MethodHandle.class, methodHandleDesc(nativeName, mtype, desc, varargs));
     }
 
     public DirectMethodHandleDesc addAddress(String javaName, String nativeName, MemoryLayout layout) {
-        return emitCondyGetter(javaName + "$ADDR", MemoryAddress.class, globalVarAddressDesc(nativeName, layout));
+        return emitCondyGetter(javaName + "$ADDR", MemorySegment.class, globalVarAddressDesc(nativeName, layout));
     }
 
     public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc) {
         return emitCondyGetter(javaName + "$DESC", FunctionDescriptor.class, desc(fDesc));
     }
 
     public DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value) {
         if (type == MemoryAddress.class) {
             if (value instanceof Long) {
                 return emitCondyGetter(name, type, addressDesc((Long) value));
-            } else if (value instanceof String) {
+            } else {
+                throw new IllegalStateException("Unhandled constant value type: " + value.getClass());
+            }
+        } else if (type == MemorySegment.class) {
+            if (value instanceof String) {
                 return emitCondyGetter(name, type, cStringDesc((String) value));
             } else {
                 throw new IllegalStateException("Unhandled constant value type: " + value.getClass());
             }
         } else if (type.isPrimitive()) {
@@ -447,21 +444,19 @@
 
         return type == MemoryAddress.class ? addressVarHandleDesc(javaName, varHandle) : varHandle;
     }
 
     private ConstantDesc globalVarAddressDesc(String name, MemoryLayout layout) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "ADDR_" + name, CD_MemoryAddress, MH_lookupGlobalVariable, LIBRARIES, name, desc(layout));
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "ADDR_" + name, CD_MemorySegment, MH_lookupGlobalVariable, LIBRARIES, name, desc(layout));
     }
 
     private ConstantDesc addressDesc(long value) {
         return DynamicConstantDesc.ofNamed(BSM_INVOKE, "MA_" + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);
     }
 
     private ConstantDesc cStringDesc(String value) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "BASEADDRESS", CD_MemoryAddress, MH_MemorySegment_baseAddress,
-            DynamicConstantDesc.ofNamed(BSM_INVOKE, "CSTRING", CD_MemorySegment, MH_makeCString, value)
-        );
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "CSTRING", CD_MemorySegment, MH_makeCString, value);
     }
 
     private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {
         return DynamicConstantDesc.ofNamed(BSM_INVOKE, "MH_" + name, CD_MethodHandle, MH_downcallHandle,
             LIBRARIES,
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/HeaderBuilder.java
@@ -173,14 +173,14 @@
         decrAlign();
         indent();
         sb.append("}\n");
 
         indent();
-        sb.append(PUB_MODS + "MemoryAddress allocate(" + className + " fi, NativeScope scope) {\n");
+        sb.append(PUB_MODS + "MemorySegment allocate(" + className + " fi, NativeScope scope) {\n");
         incrAlign();
         indent();
-        sb.append("return scope.register(allocate(fi)).address();\n");
+        sb.append("return scope.register(allocate(fi));\n");
         decrAlign();
         indent();
         sb.append("}\n");
     }
 }
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/OutputFactory.java
@@ -199,11 +199,13 @@
         if (!constants.add(constant.name())) {
             //skip
             return null;
         }
 
-        builder.addConstantGetter(Utils.javaSafeIdentifier(constant.name()), typeTranslator.getJavaType(constant.type()), constant.value());
+        builder.addConstantGetter(Utils.javaSafeIdentifier(constant.name()),
+                constant.value() instanceof String ? MemorySegment.class :
+                typeTranslator.getJavaType(constant.type()), constant.value());
         return null;
     }
 
     @Override
     public Void visitScoped(Declaration.Scoped d, Declaration parent) {
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/StructBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/StructBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/StructBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/StructBuilder.java
@@ -24,10 +24,11 @@
  */
 package jdk.incubator.jextract;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
 
 /**
  * This class generates static utilities class for C structs, unions.
  */
 public class StructBuilder extends JavaSourceBuilder {
@@ -77,11 +78,11 @@
 
     @Override
     public void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
         incrAlign();
         indent();
-        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(MemoryAddress addr) {\n");
+        sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(MemorySegment addr) {\n");
         incrAlign();
         indent();
         sb.append("return (" + type.getName() + ")"
                 + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr);\n");
         decrAlign();
@@ -94,11 +95,11 @@
 
     @Override
     public void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
         incrAlign();
         indent();
-        String param = MemoryAddress.class.getName() + " addr";
+        String param = MemorySegment.class.getName() + " addr";
         sb.append(PUB_MODS + "void " + javaName + "$set(" + param + ", " + type.getName() + " x) {\n");
         incrAlign();
         indent();
         sb.append(varHandleGetCallString(javaName, nativeName, layout, type, null) + ".set(addr, x);\n");
         decrAlign();
@@ -111,18 +112,18 @@
 
     @Override
     public void addAddressGetter(String javaName, String nativeName, MemoryLayout layout, MemoryLayout parentLayout) {
         incrAlign();
         indent();
-        sb.append(PUB_MODS + "MemoryAddress " + javaName + "$addr(MemoryAddress addr) {\n");
+        sb.append(PUB_MODS + "MemorySegment " + javaName + "$addr(MemorySegment addr) {\n");
         incrAlign();
         indent();
-        sb.append("return addr.segment().asSlice(");
+        sb.append("return addr.asSlice(");
         sb.append(parentLayout.byteOffset(MemoryLayout.PathElement.groupElement(nativeName)));
         sb.append(", ");
         sb.append(layout.byteSize());
-        sb.append(").address();\n");
+        sb.append(");\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
@@ -145,11 +146,11 @@
 
     private void emitScopeAllocate() {
         incrAlign();
         indent();
         sb.append(PUB_MODS);
-        sb.append("MemoryAddress allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n");
+        sb.append("MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n");
         decrAlign();
     }
 
     private void emitAllocateArray() {
         incrAlign();
@@ -166,11 +167,11 @@
 
     private void emitScopeAllocateArray() {
         incrAlign();
         indent();
         sb.append(PUB_MODS);
-        sb.append("MemoryAddress allocateArray(int len, NativeScope scope) {\n");
+        sb.append("MemorySegment allocateArray(int len, NativeScope scope) {\n");
         incrAlign();
         indent();
         sb.append("return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));");
         decrAlign();
         sb.append("}\n");
@@ -178,30 +179,30 @@
     }
 
     private void addIndexGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
         incrAlign();
         indent();
-        String params = MemoryAddress.class.getName() + " addr, long index";
+        String params = MemorySegment.class.getName() + " addr, long index";
         sb.append(PUB_MODS + type.getName() + " " + javaName + "$get(" + params + ") {\n");
         incrAlign();
         indent();
         sb.append("return (" + type.getName() + ")"
-                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr.addOffset(index*sizeof()));\n");
+                + varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".get(addr.asSlice(index*sizeof()));\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
     private void addIndexSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
         incrAlign();
         indent();
-        String params = MemoryAddress.class.getName() + " addr, long index, " + type.getName() + " x";
+        String params = MemorySegment.class.getName() + " addr, long index, " + type.getName() + " x";
         sb.append(PUB_MODS + "void " + javaName + "$set(" + params + ") {\n");
         incrAlign();
         indent();
-        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".set(addr.addOffset(index*sizeof()), x);\n");
+        sb.append(varHandleGetCallString(javaName, nativeName, layout, type, parentLayout) + ".set(addr.asSlice(index*sizeof()), x);\n");
         decrAlign();
         indent();
         sb.append("}\n");
         decrAlign();
     }
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template
@@ -13,10 +13,11 @@
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.io.File;
 import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
+import java.util.Objects;
 import java.util.Optional;
 
 import static ${C_LANG}.*;
 
 public class RuntimeHelper {
@@ -55,15 +56,15 @@
         } catch (Throwable t) {
             return Optional.empty();
         }
     }
 
-    public static final MemoryAddress lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name, MemoryLayout layout) {
-        return lookup(LIBRARIES, name).map(a ->
+    public static final MemorySegment lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name, MemoryLayout layout) {
+        return lookup(LIBRARIES, name).map(s ->
             MemorySegment.ofNativeRestricted(
-                 a.address(), layout.byteSize(), null, null, a
-            ).withAccessModes(MemorySegment.READ | MemorySegment.WRITE).address()).orElse(null);
+                 s.address(), layout.byteSize(), null, null, s
+            ).withAccessModes(MemorySegment.READ | MemorySegment.WRITE)).orElse(null);
     }
 
     public static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {
         return lookup(LIBRARIES, name).map(
                 addr -> {
@@ -87,21 +88,18 @@
         } catch (Throwable ex) {
             throw new AssertionError(ex);
         }
     }
 
-    public static MemoryAddress asArrayRestricted(MemoryAddress addr, MemoryLayout layout, int numElements) {
+    public static MemorySegment asArrayRestricted(MemoryAddress addr, MemoryLayout layout, int numElements) {
         return MemorySegment.ofNativeRestricted(addr, numElements * layout.byteSize(),
-               Thread.currentThread(), null, null).address();
+               Thread.currentThread(), null, null);
     }
 
-    public static MemoryAddress asArray(MemoryAddress addr, MemoryLayout layout, int numElements) {
-        var seg = addr.segment();
-        if (seg == null) {
-            throw new IllegalArgumentException("no underlying segment for the address");
-        }
-        return seg.asSlice(addr.segmentOffset(), numElements * layout.byteSize()).address();
+    public static MemorySegment asArray(MemorySegment seg, MemoryLayout layout, int numElements) {
+        Objects.requireNonNull(seg);
+        return seg.asSlice(0L, numElements * layout.byteSize());
     }
 
     private static class VarargsInvoker {
         private static final MethodHandle INVOKE_MH;
         private final Addressable symbol;
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AllocationScope.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AllocationScope.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AllocationScope.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.internal.clang;
-
-import jdk.incubator.foreign.MemorySegment;
-
-import java.util.LinkedHashSet;
-import java.util.Set;
-
-class AllocationScope implements AutoCloseable {
-    private final Set<MemorySegment> segments = new LinkedHashSet<>();
-
-    MemorySegment track(MemorySegment segment) {
-        if (!segments.add(segment)) {
-            throw new IllegalArgumentException("Attempt to track a memory segment twice");
-        }
-        return segment;
-    }
-
-    void forget(MemorySegment segment) {
-        if (!segments.remove(segment)) {
-            throw new IllegalArgumentException("Attempt to forget a memory segment not tracked by this scope");
-        }
-    }
-
-    @Override
-    public void close() {
-        var currentThread = Thread.currentThread();
-        segments.stream()
-                .filter(ms -> ms.ownerThread() == currentThread)
-                .forEach(MemorySegment::close);
-    }
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java
@@ -344,11 +344,11 @@
         });
 
         synchronized static Stream<Cursor> get(Cursor c) {
             try {
                 Index_h.clang_visitChildren(c.cursor, callback, MemoryAddress.NULL);
-                return new ArrayList<Cursor>(children).stream();
+                return new ArrayList<>(children).stream();
             } finally {
                 children.clear();
             }
         }
     }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java
@@ -24,10 +24,11 @@
  *
  */
 
 package jdk.internal.clang;
 
+import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.internal.clang.libclang.Index_h;
 
 public class EvalResult implements AutoCloseable {
     private MemoryAddress ptr;
@@ -88,11 +89,11 @@
         }
     }
 
     private String getAsString0() {
         MemoryAddress value = Index_h.clang_EvalResult_getAsStr(ptr);
-        return Utils.toJavaString(value);
+        return CSupport.toJavaStringRestricted(value);
     }
 
     public String getAsString() {
         Kind kind = getKind();
         switch (kind) {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java
@@ -25,20 +25,23 @@
  */
 
 package jdk.internal.clang;
 
 import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.internal.clang.libclang.Index_h;
 
 import java.lang.invoke.VarHandle;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Consumer;
+import java.util.stream.Stream;
 
 public class Index implements AutoCloseable {
     // Pointer to CXIndex
     private MemoryAddress ptr;
     // Set of TranslationUnit
@@ -78,23 +81,27 @@
     private static final VarHandle VH_MemoryAddress =
             MemoryHandles.asAddressVarHandle(CSupport.C_POINTER.varHandle(long.class));
 
     public TranslationUnit parseTU(String file, Consumer<Diagnostic> dh, int options, String... args)
     throws ParsingFailedException {
-        try (MemorySegment src = Utils.toNativeString(file) ;
-             MemorySegment cargs = Utils.toNativeStringArray(args);
-             MemorySegment outAddress = MemorySegment.allocateNative(CSupport.C_POINTER)) {
+        try (NativeScope scope = NativeScope.unboundedScope()) {
+            MemorySegment src = CSupport.toCString(file, scope);
+            MemorySegment cargs = scope.allocateArray(CSupport.C_POINTER, args.length);
+            for (int i = 0 ; i < args.length ; i++) {
+                MemoryAccess.setAddressAtIndex(cargs, i, CSupport.toCString(args[i], scope).address());
+            }
+            MemorySegment outAddress = scope.allocate(CSupport.C_POINTER);
             ErrorCode code = ErrorCode.valueOf(Index_h.clang_parseTranslationUnit2(
                     ptr,
                     src.address(),
                     cargs == null ? MemoryAddress.NULL : cargs.address(),
                     args.length, MemoryAddress.NULL,
                     0,
                     options,
                     outAddress.address()));
 
-            MemoryAddress tu = (MemoryAddress) VH_MemoryAddress.get(outAddress.address());
+            MemoryAddress tu = (MemoryAddress) VH_MemoryAddress.get(outAddress);
             TranslationUnit rv = new TranslationUnit(tu);
             // even if we failed to parse, we might still have diagnostics
             rv.processDiagnostics(dh);
 
             if (code != ErrorCode.Success) {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java
@@ -39,11 +39,11 @@
 public class LibClang {
     private static final boolean DEBUG = Boolean.getBoolean("libclang.debug");
     private static final boolean CRASH_RECOVERY = Boolean.getBoolean("libclang.crash_recovery");
 
     private final static MemorySegment disableCrashRecovery =
-            Utils.toNativeString("LIBCLANG_DISABLE_CRASH_RECOVERY=" + CRASH_RECOVERY)
+            CSupport.toCString("LIBCLANG_DISABLE_CRASH_RECOVERY=" + CRASH_RECOVERY)
                 .withAccessModes(MemorySegment.READ);
 
     static {
         if (!CRASH_RECOVERY) {
             //this is an hack - needed because clang_toggleCrashRecovery only takes effect _after_ the
@@ -70,11 +70,11 @@
         return index;
     }
 
     public static String CXStrToString(MemorySegment cxstr) {
         MemoryAddress buf = Index_h.clang_getCString(cxstr);
-        String str = Utils.toJavaString(buf);
+        String str = CSupport.toJavaStringRestricted(buf);
         Index_h.clang_disposeString(cxstr);
         return str;
     }
 
     public static String version() {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java
@@ -24,10 +24,11 @@
  *
  */
 package jdk.internal.clang;
 
 import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.internal.clang.libclang.Index_h;
 
 import java.nio.file.Path;
@@ -54,19 +55,19 @@
              MemorySegment line = MemorySegment.allocateNative(CSupport.C_INT);
              MemorySegment col = MemorySegment.allocateNative(CSupport.C_INT);
              MemorySegment offset = MemorySegment.allocateNative(CSupport.C_INT)) {
 
             fn.get(loc, file.address(), line.address(), col.address(), offset.address());
-            MemoryAddress fname = Utils.getPointer(file.address());
+            MemoryAddress fname = MemoryAccess.getAddress(file);
 
 
             String str = fname == MemoryAddress.NULL ?
                     null :
                     LibClang.CXStrToString(Index_h.clang_getFileName(fname));
 
-            return new Location(str, Utils.getInt(line.address()),
-                Utils.getInt(col.address()), Utils.getInt(offset.address()));
+            return new Location(str, MemoryAccess.getInt(line),
+                MemoryAccess.getInt(col), MemoryAccess.getInt(offset));
         }
     }
 
     public Location getFileLocation() { return getLocation(Index_h::clang_getFileLocation); }
     public Location getExpansionLocation() { return getLocation(Index_h::clang_getExpansionLocation); }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java
@@ -25,13 +25,15 @@
  */
 
 package jdk.internal.clang;
 
 import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.NativeScope;
 import jdk.internal.clang.libclang.Index_h;
 
 import java.io.IOException;
 import java.nio.file.Path;
 import java.util.Objects;
@@ -59,11 +61,11 @@
 
         return rv;
     }
 
     public final void save(Path path) throws TranslationUnitSaveException {
-        try (MemorySegment pathStr = Utils.toNativeString(path.toAbsolutePath().toString())) {
+        try (MemorySegment pathStr = CSupport.toCString(path.toAbsolutePath().toString())) {
             SaveError res = SaveError.valueOf(Index_h.clang_saveTranslationUnit(tu, pathStr.address(), 0));
             if (res != SaveError.None) {
                 throw new TranslationUnitSaveException(path, res);
             }
         }
@@ -79,19 +81,19 @@
     static long FILENAME_OFFSET = Index_h.CXUnsavedFile$LAYOUT.bitOffset(MemoryLayout.PathElement.groupElement("Filename")) / 8;
     static long CONTENTS_OFFSET = Index_h.CXUnsavedFile$LAYOUT.bitOffset(MemoryLayout.PathElement.groupElement("Contents")) / 8;
     static long LENGTH_OFFSET = Index_h.CXUnsavedFile$LAYOUT.bitOffset(MemoryLayout.PathElement.groupElement("Length")) / 8;
 
     public void reparse(Index.UnsavedFile... inMemoryFiles) {
-        try (AllocationScope scope = new AllocationScope()) {
+        try (NativeScope scope = NativeScope.unboundedScope()) {
             MemorySegment files = inMemoryFiles.length == 0 ?
                     null :
-                    scope.track(MemorySegment.allocateNative(MemoryLayout.ofSequence(inMemoryFiles.length, Index_h.CXUnsavedFile$LAYOUT)));
+                    scope.allocateArray(Index_h.CXUnsavedFile$LAYOUT, inMemoryFiles.length);
             for (int i = 0; i < inMemoryFiles.length; i++) {
-                MemoryAddress start = files.address().addOffset(i * Index_h.CXUnsavedFile$LAYOUT.byteSize());
-                Utils.setPointer(start.addOffset(FILENAME_OFFSET), scope.track(Utils.toNativeString(inMemoryFiles[i].file)).address());
-                Utils.setPointer(start.addOffset(CONTENTS_OFFSET), scope.track(Utils.toNativeString(inMemoryFiles[i].contents)).address());
-                Utils.setLong(start.addOffset(LENGTH_OFFSET), inMemoryFiles[i].contents.length());
+                MemorySegment start = files.asSlice(i * Index_h.CXUnsavedFile$LAYOUT.byteSize());
+                MemoryAccess.setAddress(start.asSlice(FILENAME_OFFSET), CSupport.toCString(inMemoryFiles[i].file, scope).address());
+                MemoryAccess.setAddress(start.asSlice(CONTENTS_OFFSET), CSupport.toCString(inMemoryFiles[i].contents, scope).address());
+                MemoryAccess.setLong(start.asSlice(LENGTH_OFFSET), inMemoryFiles[i].contents.length());
             }
             ErrorCode code = ErrorCode.valueOf(Index_h.clang_reparseTranslationUnit(
                         tu,
                         inMemoryFiles.length,
                         files == null ? MemoryAddress.NULL : files.address(),
@@ -119,11 +121,11 @@
 
     public Tokens tokenize(SourceRange range) {
         MemorySegment p = MemorySegment.allocateNative(CSupport.C_POINTER);
         MemorySegment pCnt = MemorySegment.allocateNative(CSupport.C_INT);
         Index_h.clang_tokenize(tu, range.range, p.address(), pCnt.address());
-        Tokens rv = new Tokens(Utils.getPointer(p.address()), Utils.getInt(pCnt.address()));
+        Tokens rv = new Tokens(MemoryAccess.getAddress(p), MemoryAccess.getInt(pCnt));
         return rv;
     }
 
     @Override
     public void close() {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java
@@ -24,10 +24,11 @@
  *
  */
 
 package jdk.internal.clang;
 
+import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.internal.clang.libclang.Index_h;
 
 
 public final class Type {
@@ -106,11 +107,11 @@
         return Index_h.clang_getNumElements(type);
     }
 
     // Struct/RecordType
     private long getOffsetOf0(String fieldName) {
-        try (MemorySegment cfname = Utils.toNativeString(fieldName)) {
+        try (MemorySegment cfname = CSupport.toCString(fieldName)) {
             return Index_h.clang_Type_getOffsetOf(type, cfname.address());
         }
     }
 
     public long getOffsetOf(String fieldName) {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.internal.clang;
-
-import jdk.incubator.foreign.CSupport;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryHandles;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-import java.lang.invoke.VarHandle;
-
-public class Utils {
-    public static final VarHandle BYTE_VH = CSupport.C_CHAR.varHandle(byte.class);
-    public static final VarHandle BYTE_ARR_VH = MemoryHandles.withStride(BYTE_VH, 1);
-    public static final VarHandle INT_VH = CSupport.C_INT.varHandle(int.class);
-    public static final VarHandle LONG_VH = CSupport.C_LONGLONG.varHandle(long.class);
-    public static final VarHandle POINTER_VH = MemoryHandles.asAddressVarHandle(CSupport.C_POINTER.varHandle(long.class));
-    public static final VarHandle POINTER_ARR_VH = MemoryHandles.withStride(POINTER_VH, 8);
-
-    static int getInt(MemoryAddress addr) {
-        return (int)INT_VH.get(addr);
-    }
-
-    static void setInt(MemoryAddress addr, int i) {
-        INT_VH.set(addr, i);
-    }
-
-    static int getLong(MemoryAddress addr) {
-        return (int)LONG_VH.get(addr);
-    }
-
-    static void setLong(MemoryAddress addr, long i) {
-        LONG_VH.set(addr, i);
-    }
-
-    static byte getByte(MemoryAddress addr) {
-        return (byte)BYTE_VH.get(addr);
-    }
-
-    static MemoryAddress getPointer(MemoryAddress addr) {
-        return (MemoryAddress)POINTER_VH.get(addr);
-    }
-
-    static void setPointer(MemoryAddress addr, MemoryAddress ptr) {
-        POINTER_VH.set(addr, ptr);
-    }
-
-    static MemorySegment toNativeString(String value) {
-        return toNativeString(value, value.length() + 1);
-    }
-
-    static MemorySegment toNativeString(String value, int length) {
-        MemoryLayout strLayout = MemoryLayout.ofSequence(length, CSupport.C_CHAR);
-        MemorySegment segment = MemorySegment.allocateNative(strLayout);
-        MemoryAddress addr = segment.address();
-        for (int i = 0 ; i < value.length() ; i++) {
-            BYTE_ARR_VH.set(addr, i, (byte)value.charAt(i));
-        }
-        BYTE_ARR_VH.set(addr, (long)value.length(), (byte)0);
-        return segment;
-    }
-
-    static String toJavaString(MemoryAddress address) {
-        return CSupport.toJavaStringRestricted(address);
-    }
-
-    static MemorySegment toNativeStringArray(String[] ar) {
-        if (ar.length == 0) {
-            return null;
-        }
-
-        MemorySegment segment = MemorySegment.allocateNative(MemoryLayout.ofSequence(ar.length, CSupport.C_POINTER));
-        for (int i = 0; i < ar.length; i++) {
-            POINTER_ARR_VH.set(segment.address(), i, toNativeString(ar[i]).address());
-        }
-
-        return segment;
-    }
-
-}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java
@@ -63,26 +63,26 @@
         CSupport.C_INT.withName("private_flags"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXString$private_flags = CXString$LAYOUT.varHandle(int.class, PathElement.groupElement("private_flags"));
     public static final int CXString$private_flags$get(MemorySegment seg) {
-        return (int)CXString$private_flags.get(seg.address());
+        return (int)CXString$private_flags.get(seg);
     }
     public static final void CXString$private_flags$set(MemorySegment seg, int x) {
-        CXString$private_flags.set(seg.address(), x);
+        CXString$private_flags.set(seg, x);
     }
     public static final MemoryLayout CXStringSet$LAYOUT = MemoryLayout.ofStruct(
         CSupport.C_POINTER.withName("Strings"),
         CSupport.C_INT.withName("Count"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXStringSet$Count = CXStringSet$LAYOUT.varHandle(int.class, PathElement.groupElement("Count"));
     public static final int CXStringSet$Count$get(MemorySegment seg) {
-        return (int)CXStringSet$Count.get(seg.address());
+        return (int)CXStringSet$Count.get(seg);
     }
     public static final void CXStringSet$Count$set(MemorySegment seg, int x) {
-        CXStringSet$Count.set(seg.address(), x);
+        CXStringSet$Count.set(seg, x);
     }
     public static final MethodHandle clang_getCString = RuntimeHelper.downcallHandle(
         LIBRARIES, "clang_getCString",
         "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
         FunctionDescriptor.of(CSupport.C_POINTER,
@@ -314,14 +314,14 @@
         CSupport.C_POINTER.withName("Contents"),
         CSupport.C_LONGLONG.withName("Length")
     ).withName("CXUnsavedFile");
     public static final VarHandle CXUnsavedFile$Length = CXUnsavedFile$LAYOUT.varHandle(long.class, PathElement.groupElement("Length"));
     public static final long CXUnsavedFile$Length$get(MemorySegment seg) {
-        return (long)CXUnsavedFile$Length.get(seg.address());
+        return (long)CXUnsavedFile$Length.get(seg);
     }
     public static final void CXUnsavedFile$Length$set(MemorySegment seg, long x) {
-        CXUnsavedFile$Length.set(seg.address(), x);
+        CXUnsavedFile$Length.set(seg, x);
     }
     public static final int CXAvailability_Available = (int)0L;
     public static final int CXAvailability_Deprecated = (int)1L;
     public static final int CXAvailability_NotAvailable = (int)2L;
     public static final int CXAvailability_NotAccessible = (int)3L;
@@ -330,28 +330,28 @@
         CSupport.C_INT.withName("Minor"),
         CSupport.C_INT.withName("Subminor")
     ).withName("CXVersion");
     public static final VarHandle CXVersion$Major = CXVersion$LAYOUT.varHandle(int.class, PathElement.groupElement("Major"));
     public static final int CXVersion$Major$get(MemorySegment seg) {
-        return (int)CXVersion$Major.get(seg.address());
+        return (int)CXVersion$Major.get(seg);
     }
     public static final void CXVersion$Major$set(MemorySegment seg, int x) {
-        CXVersion$Major.set(seg.address(), x);
+        CXVersion$Major.set(seg, x);
     }
     public static final VarHandle CXVersion$Minor = CXVersion$LAYOUT.varHandle(int.class, PathElement.groupElement("Minor"));
     public static final int CXVersion$Minor$get(MemorySegment seg) {
-        return (int)CXVersion$Minor.get(seg.address());
+        return (int)CXVersion$Minor.get(seg);
     }
     public static final void CXVersion$Minor$set(MemorySegment seg, int x) {
-        CXVersion$Minor.set(seg.address(), x);
+        CXVersion$Minor.set(seg, x);
     }
     public static final VarHandle CXVersion$Subminor = CXVersion$LAYOUT.varHandle(int.class, PathElement.groupElement("Subminor"));
     public static final int CXVersion$Subminor$get(MemorySegment seg) {
-        return (int)CXVersion$Subminor.get(seg.address());
+        return (int)CXVersion$Subminor.get(seg);
     }
     public static final void CXVersion$Subminor$set(MemorySegment seg, int x) {
-        CXVersion$Subminor.set(seg.address(), x);
+        CXVersion$Subminor.set(seg, x);
     }
     public static final int CXCursor_ExceptionSpecificationKind_None = (int)0L;
     public static final int CXCursor_ExceptionSpecificationKind_DynamicNone = (int)1L;
     public static final int CXCursor_ExceptionSpecificationKind_Dynamic = (int)2L;
     public static final int CXCursor_ExceptionSpecificationKind_MSAny = (int)3L;
@@ -572,33 +572,33 @@
         CSupport.C_INT.withName("int_data"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXSourceLocation$int_data = CXSourceLocation$LAYOUT.varHandle(int.class, PathElement.groupElement("int_data"));
     public static final int CXSourceLocation$int_data$get(MemorySegment seg) {
-        return (int)CXSourceLocation$int_data.get(seg.address());
+        return (int)CXSourceLocation$int_data.get(seg);
     }
     public static final void CXSourceLocation$int_data$set(MemorySegment seg, int x) {
-        CXSourceLocation$int_data.set(seg.address(), x);
+        CXSourceLocation$int_data.set(seg, x);
     }
     public static final MemoryLayout CXSourceRange$LAYOUT = MemoryLayout.ofStruct(
         MemoryLayout.ofSequence(2, CSupport.C_POINTER).withName("ptr_data"),
         CSupport.C_INT.withName("begin_int_data"),
         CSupport.C_INT.withName("end_int_data")
     );
     public static final VarHandle CXSourceRange$begin_int_data = CXSourceRange$LAYOUT.varHandle(int.class, PathElement.groupElement("begin_int_data"));
     public static final int CXSourceRange$begin_int_data$get(MemorySegment seg) {
-        return (int)CXSourceRange$begin_int_data.get(seg.address());
+        return (int)CXSourceRange$begin_int_data.get(seg);
     }
     public static final void CXSourceRange$begin_int_data$set(MemorySegment seg, int x) {
-        CXSourceRange$begin_int_data.set(seg.address(), x);
+        CXSourceRange$begin_int_data.set(seg, x);
     }
     public static final VarHandle CXSourceRange$end_int_data = CXSourceRange$LAYOUT.varHandle(int.class, PathElement.groupElement("end_int_data"));
     public static final int CXSourceRange$end_int_data$get(MemorySegment seg) {
-        return (int)CXSourceRange$end_int_data.get(seg.address());
+        return (int)CXSourceRange$end_int_data.get(seg);
     }
     public static final void CXSourceRange$end_int_data$set(MemorySegment seg, int x) {
-        CXSourceRange$end_int_data.set(seg.address(), x);
+        CXSourceRange$end_int_data.set(seg, x);
     }
     public static final MethodHandle clang_getNullLocation = RuntimeHelper.downcallHandle(
         LIBRARIES, "clang_getNullLocation",
         "()Ljdk/incubator/foreign/MemorySegment;",
         FunctionDescriptor.of(MemoryLayout.ofStruct(
@@ -956,14 +956,14 @@
         MemoryLayout.ofPaddingBits(32),
         CSupport.C_POINTER.withName("ranges")
     );
     public static final VarHandle CXSourceRangeList$count = CXSourceRangeList$LAYOUT.varHandle(int.class, PathElement.groupElement("count"));
     public static final int CXSourceRangeList$count$get(MemorySegment seg) {
-        return (int)CXSourceRangeList$count.get(seg.address());
+        return (int)CXSourceRangeList$count.get(seg);
     }
     public static final void CXSourceRangeList$count$set(MemorySegment seg, int x) {
-        CXSourceRangeList$count.set(seg.address(), x);
+        CXSourceRangeList$count.set(seg, x);
     }
     public static final MethodHandle clang_getSkippedRanges = RuntimeHelper.downcallHandle(
         LIBRARIES, "clang_getSkippedRanges",
         "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
         FunctionDescriptor.of(CSupport.C_POINTER,
@@ -1658,34 +1658,34 @@
         MemoryLayout.ofPaddingBits(32),
         CSupport.C_LONGLONG.withName("amount")
     ).withName("CXTUResourceUsageEntry");
     public static final VarHandle CXTUResourceUsageEntry$kind = CXTUResourceUsageEntry$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
     public static final int CXTUResourceUsageEntry$kind$get(MemorySegment seg) {
-        return (int)CXTUResourceUsageEntry$kind.get(seg.address());
+        return (int)CXTUResourceUsageEntry$kind.get(seg);
     }
     public static final void CXTUResourceUsageEntry$kind$set(MemorySegment seg, int x) {
-        CXTUResourceUsageEntry$kind.set(seg.address(), x);
+        CXTUResourceUsageEntry$kind.set(seg, x);
     }
     public static final VarHandle CXTUResourceUsageEntry$amount = CXTUResourceUsageEntry$LAYOUT.varHandle(long.class, PathElement.groupElement("amount"));
     public static final long CXTUResourceUsageEntry$amount$get(MemorySegment seg) {
-        return (long)CXTUResourceUsageEntry$amount.get(seg.address());
+        return (long)CXTUResourceUsageEntry$amount.get(seg);
     }
     public static final void CXTUResourceUsageEntry$amount$set(MemorySegment seg, long x) {
-        CXTUResourceUsageEntry$amount.set(seg.address(), x);
+        CXTUResourceUsageEntry$amount.set(seg, x);
     }
     public static final MemoryLayout CXTUResourceUsage$LAYOUT = MemoryLayout.ofStruct(
         CSupport.C_POINTER.withName("data"),
         CSupport.C_INT.withName("numEntries"),
         MemoryLayout.ofPaddingBits(32),
         CSupport.C_POINTER.withName("entries")
     ).withName("CXTUResourceUsage");
     public static final VarHandle CXTUResourceUsage$numEntries = CXTUResourceUsage$LAYOUT.varHandle(int.class, PathElement.groupElement("numEntries"));
     public static final int CXTUResourceUsage$numEntries$get(MemorySegment seg) {
-        return (int)CXTUResourceUsage$numEntries.get(seg.address());
+        return (int)CXTUResourceUsage$numEntries.get(seg);
     }
     public static final void CXTUResourceUsage$numEntries$set(MemorySegment seg, int x) {
-        CXTUResourceUsage$numEntries.set(seg.address(), x);
+        CXTUResourceUsage$numEntries.set(seg, x);
     }
     public static final MethodHandle clang_getCXTUResourceUsage = RuntimeHelper.downcallHandle(
         LIBRARIES, "clang_getCXTUResourceUsage",
         "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
         FunctionDescriptor.of(MemoryLayout.ofStruct(
@@ -2043,21 +2043,21 @@
         CSupport.C_INT.withName("xdata"),
         MemoryLayout.ofSequence(3, CSupport.C_POINTER).withName("data")
     );
     public static final VarHandle CXCursor$kind = CXCursor$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
     public static final int CXCursor$kind$get(MemorySegment seg) {
-        return (int)CXCursor$kind.get(seg.address());
+        return (int)CXCursor$kind.get(seg);
     }
     public static final void CXCursor$kind$set(MemorySegment seg, int x) {
-        CXCursor$kind.set(seg.address(), x);
+        CXCursor$kind.set(seg, x);
     }
     public static final VarHandle CXCursor$xdata = CXCursor$LAYOUT.varHandle(int.class, PathElement.groupElement("xdata"));
     public static final int CXCursor$xdata$get(MemorySegment seg) {
-        return (int)CXCursor$xdata.get(seg.address());
+        return (int)CXCursor$xdata.get(seg);
     }
     public static final void CXCursor$xdata$set(MemorySegment seg, int x) {
-        CXCursor$xdata.set(seg.address(), x);
+        CXCursor$xdata.set(seg, x);
     }
     public static final MethodHandle clang_getNullCursor = RuntimeHelper.downcallHandle(
         LIBRARIES, "clang_getNullCursor",
         "()Ljdk/incubator/foreign/MemorySegment;",
         FunctionDescriptor.of(MemoryLayout.ofStruct(
@@ -2421,14 +2421,14 @@
             MemoryLayout.ofPaddingBits(32)
         ).withName("Message")
     ).withName("CXPlatformAvailability");
     public static final VarHandle CXPlatformAvailability$Unavailable = CXPlatformAvailability$LAYOUT.varHandle(int.class, PathElement.groupElement("Unavailable"));
     public static final int CXPlatformAvailability$Unavailable$get(MemorySegment seg) {
-        return (int)CXPlatformAvailability$Unavailable.get(seg.address());
+        return (int)CXPlatformAvailability$Unavailable.get(seg);
     }
     public static final void CXPlatformAvailability$Unavailable$set(MemorySegment seg, int x) {
-        CXPlatformAvailability$Unavailable.set(seg.address(), x);
+        CXPlatformAvailability$Unavailable.set(seg, x);
     }
     public static final MethodHandle clang_getCursorPlatformAvailability = RuntimeHelper.downcallHandle(
         LIBRARIES, "clang_getCursorPlatformAvailability",
         "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;I)I",
         FunctionDescriptor.of(CSupport.C_INT,
@@ -2897,14 +2897,14 @@
         MemoryLayout.ofPaddingBits(32),
         MemoryLayout.ofSequence(2, CSupport.C_POINTER).withName("data")
     );
     public static final VarHandle CXType$kind = CXType$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
     public static final int CXType$kind$get(MemorySegment seg) {
-        return (int)CXType$kind.get(seg.address());
+        return (int)CXType$kind.get(seg);
     }
     public static final void CXType$kind$set(MemorySegment seg, int x) {
-        CXType$kind.set(seg.address(), x);
+        CXType$kind.set(seg, x);
     }
     public static final MethodHandle clang_getCursorType = RuntimeHelper.downcallHandle(
         LIBRARIES, "clang_getCursorType",
         "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
         FunctionDescriptor.of(MemoryLayout.ofStruct(
@@ -5770,14 +5770,14 @@
         MemoryLayout.ofPaddingBits(32),
         CSupport.C_POINTER.withName("CompletionString")
     );
     public static final VarHandle CXCompletionResult$CursorKind = CXCompletionResult$LAYOUT.varHandle(int.class, PathElement.groupElement("CursorKind"));
     public static final int CXCompletionResult$CursorKind$get(MemorySegment seg) {
-        return (int)CXCompletionResult$CursorKind.get(seg.address());
+        return (int)CXCompletionResult$CursorKind.get(seg);
     }
     public static final void CXCompletionResult$CursorKind$set(MemorySegment seg, int x) {
-        CXCompletionResult$CursorKind.set(seg.address(), x);
+        CXCompletionResult$CursorKind.set(seg, x);
     }
     public static final int CXCompletionChunk_Optional = (int)0L;
     public static final int CXCompletionChunk_TypedText = (int)1L;
     public static final int CXCompletionChunk_Text = (int)2L;
     public static final int CXCompletionChunk_Placeholder = (int)3L;
@@ -5982,14 +5982,14 @@
         CSupport.C_INT.withName("NumResults"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXCodeCompleteResults$NumResults = CXCodeCompleteResults$LAYOUT.varHandle(int.class, PathElement.groupElement("NumResults"));
     public static final int CXCodeCompleteResults$NumResults$get(MemorySegment seg) {
-        return (int)CXCodeCompleteResults$NumResults.get(seg.address());
+        return (int)CXCodeCompleteResults$NumResults.get(seg);
     }
     public static final void CXCodeCompleteResults$NumResults$set(MemorySegment seg, int x) {
-        CXCodeCompleteResults$NumResults.set(seg.address(), x);
+        CXCodeCompleteResults$NumResults.set(seg, x);
     }
     public static final MethodHandle clang_getCompletionNumFixIts = RuntimeHelper.downcallHandle(
         LIBRARIES, "clang_getCompletionNumFixIts",
         "(Ljdk/incubator/foreign/MemoryAddress;I)I",
         FunctionDescriptor.of(CSupport.C_INT,
@@ -6535,14 +6535,14 @@
         CSupport.C_INT.withName("int_data"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXIdxLoc$int_data = CXIdxLoc$LAYOUT.varHandle(int.class, PathElement.groupElement("int_data"));
     public static final int CXIdxLoc$int_data$get(MemorySegment seg) {
-        return (int)CXIdxLoc$int_data.get(seg.address());
+        return (int)CXIdxLoc$int_data.get(seg);
     }
     public static final void CXIdxLoc$int_data$set(MemorySegment seg, int x) {
-        CXIdxLoc$int_data.set(seg.address(), x);
+        CXIdxLoc$int_data.set(seg, x);
     }
     public static final MemoryLayout CXIdxIncludedFileInfo$LAYOUT = MemoryLayout.ofStruct(
         MemoryLayout.ofStruct(
             MemoryLayout.ofSequence(2, CSupport.C_POINTER).withName("ptr_data"),
             CSupport.C_INT.withName("int_data"),
@@ -6555,28 +6555,28 @@
         CSupport.C_INT.withName("isModuleImport"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXIdxIncludedFileInfo$isImport = CXIdxIncludedFileInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isImport"));
     public static final int CXIdxIncludedFileInfo$isImport$get(MemorySegment seg) {
-        return (int)CXIdxIncludedFileInfo$isImport.get(seg.address());
+        return (int)CXIdxIncludedFileInfo$isImport.get(seg);
     }
     public static final void CXIdxIncludedFileInfo$isImport$set(MemorySegment seg, int x) {
-        CXIdxIncludedFileInfo$isImport.set(seg.address(), x);
+        CXIdxIncludedFileInfo$isImport.set(seg, x);
     }
     public static final VarHandle CXIdxIncludedFileInfo$isAngled = CXIdxIncludedFileInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isAngled"));
     public static final int CXIdxIncludedFileInfo$isAngled$get(MemorySegment seg) {
-        return (int)CXIdxIncludedFileInfo$isAngled.get(seg.address());
+        return (int)CXIdxIncludedFileInfo$isAngled.get(seg);
     }
     public static final void CXIdxIncludedFileInfo$isAngled$set(MemorySegment seg, int x) {
-        CXIdxIncludedFileInfo$isAngled.set(seg.address(), x);
+        CXIdxIncludedFileInfo$isAngled.set(seg, x);
     }
     public static final VarHandle CXIdxIncludedFileInfo$isModuleImport = CXIdxIncludedFileInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isModuleImport"));
     public static final int CXIdxIncludedFileInfo$isModuleImport$get(MemorySegment seg) {
-        return (int)CXIdxIncludedFileInfo$isModuleImport.get(seg.address());
+        return (int)CXIdxIncludedFileInfo$isModuleImport.get(seg);
     }
     public static final void CXIdxIncludedFileInfo$isModuleImport$set(MemorySegment seg, int x) {
-        CXIdxIncludedFileInfo$isModuleImport.set(seg.address(), x);
+        CXIdxIncludedFileInfo$isModuleImport.set(seg, x);
     }
     public static final MemoryLayout CXIdxImportedASTFileInfo$LAYOUT = MemoryLayout.ofStruct(
         CSupport.C_POINTER.withName("file"),
         CSupport.C_POINTER.withName("module"),
         MemoryLayout.ofStruct(
@@ -6587,14 +6587,14 @@
         CSupport.C_INT.withName("isImplicit"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXIdxImportedASTFileInfo$isImplicit = CXIdxImportedASTFileInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isImplicit"));
     public static final int CXIdxImportedASTFileInfo$isImplicit$get(MemorySegment seg) {
-        return (int)CXIdxImportedASTFileInfo$isImplicit.get(seg.address());
+        return (int)CXIdxImportedASTFileInfo$isImplicit.get(seg);
     }
     public static final void CXIdxImportedASTFileInfo$isImplicit$set(MemorySegment seg, int x) {
-        CXIdxImportedASTFileInfo$isImplicit.set(seg.address(), x);
+        CXIdxImportedASTFileInfo$isImplicit.set(seg, x);
     }
     public static final int CXIdxEntity_Unexposed = (int)0L;
     public static final int CXIdxEntity_Typedef = (int)1L;
     public static final int CXIdxEntity_Function = (int)2L;
     public static final int CXIdxEntity_Variable = (int)3L;
@@ -6648,14 +6648,14 @@
             MemoryLayout.ofPaddingBits(32)
         ).withName("loc")
     );
     public static final VarHandle CXIdxAttrInfo$kind = CXIdxAttrInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
     public static final int CXIdxAttrInfo$kind$get(MemorySegment seg) {
-        return (int)CXIdxAttrInfo$kind.get(seg.address());
+        return (int)CXIdxAttrInfo$kind.get(seg);
     }
     public static final void CXIdxAttrInfo$kind$set(MemorySegment seg, int x) {
-        CXIdxAttrInfo$kind.set(seg.address(), x);
+        CXIdxAttrInfo$kind.set(seg, x);
     }
     public static final MemoryLayout CXIdxEntityInfo$LAYOUT = MemoryLayout.ofStruct(
         CSupport.C_INT.withName("kind"),
         CSupport.C_INT.withName("templateKind"),
         CSupport.C_INT.withName("lang"),
@@ -6671,35 +6671,35 @@
         CSupport.C_INT.withName("numAttributes"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXIdxEntityInfo$kind = CXIdxEntityInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
     public static final int CXIdxEntityInfo$kind$get(MemorySegment seg) {
-        return (int)CXIdxEntityInfo$kind.get(seg.address());
+        return (int)CXIdxEntityInfo$kind.get(seg);
     }
     public static final void CXIdxEntityInfo$kind$set(MemorySegment seg, int x) {
-        CXIdxEntityInfo$kind.set(seg.address(), x);
+        CXIdxEntityInfo$kind.set(seg, x);
     }
     public static final VarHandle CXIdxEntityInfo$templateKind = CXIdxEntityInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("templateKind"));
     public static final int CXIdxEntityInfo$templateKind$get(MemorySegment seg) {
-        return (int)CXIdxEntityInfo$templateKind.get(seg.address());
+        return (int)CXIdxEntityInfo$templateKind.get(seg);
     }
     public static final void CXIdxEntityInfo$templateKind$set(MemorySegment seg, int x) {
-        CXIdxEntityInfo$templateKind.set(seg.address(), x);
+        CXIdxEntityInfo$templateKind.set(seg, x);
     }
     public static final VarHandle CXIdxEntityInfo$lang = CXIdxEntityInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("lang"));
     public static final int CXIdxEntityInfo$lang$get(MemorySegment seg) {
-        return (int)CXIdxEntityInfo$lang.get(seg.address());
+        return (int)CXIdxEntityInfo$lang.get(seg);
     }
     public static final void CXIdxEntityInfo$lang$set(MemorySegment seg, int x) {
-        CXIdxEntityInfo$lang.set(seg.address(), x);
+        CXIdxEntityInfo$lang.set(seg, x);
     }
     public static final VarHandle CXIdxEntityInfo$numAttributes = CXIdxEntityInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("numAttributes"));
     public static final int CXIdxEntityInfo$numAttributes$get(MemorySegment seg) {
-        return (int)CXIdxEntityInfo$numAttributes.get(seg.address());
+        return (int)CXIdxEntityInfo$numAttributes.get(seg);
     }
     public static final void CXIdxEntityInfo$numAttributes$set(MemorySegment seg, int x) {
-        CXIdxEntityInfo$numAttributes.set(seg.address(), x);
+        CXIdxEntityInfo$numAttributes.set(seg, x);
     }
     public static final MemoryLayout CXIdxContainerInfo$LAYOUT = MemoryLayout.ofStruct(
         MemoryLayout.ofStruct(
             CSupport.C_INT.withName("kind"),
             CSupport.C_INT.withName("xdata"),
@@ -6746,49 +6746,49 @@
         CSupport.C_INT.withName("numAttributes"),
         CSupport.C_INT.withName("flags")
     );
     public static final VarHandle CXIdxDeclInfo$isRedeclaration = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isRedeclaration"));
     public static final int CXIdxDeclInfo$isRedeclaration$get(MemorySegment seg) {
-        return (int)CXIdxDeclInfo$isRedeclaration.get(seg.address());
+        return (int)CXIdxDeclInfo$isRedeclaration.get(seg);
     }
     public static final void CXIdxDeclInfo$isRedeclaration$set(MemorySegment seg, int x) {
-        CXIdxDeclInfo$isRedeclaration.set(seg.address(), x);
+        CXIdxDeclInfo$isRedeclaration.set(seg, x);
     }
     public static final VarHandle CXIdxDeclInfo$isDefinition = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isDefinition"));
     public static final int CXIdxDeclInfo$isDefinition$get(MemorySegment seg) {
-        return (int)CXIdxDeclInfo$isDefinition.get(seg.address());
+        return (int)CXIdxDeclInfo$isDefinition.get(seg);
     }
     public static final void CXIdxDeclInfo$isDefinition$set(MemorySegment seg, int x) {
-        CXIdxDeclInfo$isDefinition.set(seg.address(), x);
+        CXIdxDeclInfo$isDefinition.set(seg, x);
     }
     public static final VarHandle CXIdxDeclInfo$isContainer = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isContainer"));
     public static final int CXIdxDeclInfo$isContainer$get(MemorySegment seg) {
-        return (int)CXIdxDeclInfo$isContainer.get(seg.address());
+        return (int)CXIdxDeclInfo$isContainer.get(seg);
     }
     public static final void CXIdxDeclInfo$isContainer$set(MemorySegment seg, int x) {
-        CXIdxDeclInfo$isContainer.set(seg.address(), x);
+        CXIdxDeclInfo$isContainer.set(seg, x);
     }
     public static final VarHandle CXIdxDeclInfo$isImplicit = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isImplicit"));
     public static final int CXIdxDeclInfo$isImplicit$get(MemorySegment seg) {
-        return (int)CXIdxDeclInfo$isImplicit.get(seg.address());
+        return (int)CXIdxDeclInfo$isImplicit.get(seg);
     }
     public static final void CXIdxDeclInfo$isImplicit$set(MemorySegment seg, int x) {
-        CXIdxDeclInfo$isImplicit.set(seg.address(), x);
+        CXIdxDeclInfo$isImplicit.set(seg, x);
     }
     public static final VarHandle CXIdxDeclInfo$numAttributes = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("numAttributes"));
     public static final int CXIdxDeclInfo$numAttributes$get(MemorySegment seg) {
-        return (int)CXIdxDeclInfo$numAttributes.get(seg.address());
+        return (int)CXIdxDeclInfo$numAttributes.get(seg);
     }
     public static final void CXIdxDeclInfo$numAttributes$set(MemorySegment seg, int x) {
-        CXIdxDeclInfo$numAttributes.set(seg.address(), x);
+        CXIdxDeclInfo$numAttributes.set(seg, x);
     }
     public static final VarHandle CXIdxDeclInfo$flags = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("flags"));
     public static final int CXIdxDeclInfo$flags$get(MemorySegment seg) {
-        return (int)CXIdxDeclInfo$flags.get(seg.address());
+        return (int)CXIdxDeclInfo$flags.get(seg);
     }
     public static final void CXIdxDeclInfo$flags$set(MemorySegment seg, int x) {
-        CXIdxDeclInfo$flags.set(seg.address(), x);
+        CXIdxDeclInfo$flags.set(seg, x);
     }
     public static final int CXIdxObjCContainer_ForwardRef = (int)0L;
     public static final int CXIdxObjCContainer_Interface = (int)1L;
     public static final int CXIdxObjCContainer_Implementation = (int)2L;
     public static final MemoryLayout CXIdxObjCContainerDeclInfo$LAYOUT = MemoryLayout.ofStruct(
@@ -6796,14 +6796,14 @@
         CSupport.C_INT.withName("kind"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXIdxObjCContainerDeclInfo$kind = CXIdxObjCContainerDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
     public static final int CXIdxObjCContainerDeclInfo$kind$get(MemorySegment seg) {
-        return (int)CXIdxObjCContainerDeclInfo$kind.get(seg.address());
+        return (int)CXIdxObjCContainerDeclInfo$kind.get(seg);
     }
     public static final void CXIdxObjCContainerDeclInfo$kind$set(MemorySegment seg, int x) {
-        CXIdxObjCContainerDeclInfo$kind.set(seg.address(), x);
+        CXIdxObjCContainerDeclInfo$kind.set(seg, x);
     }
     public static final MemoryLayout CXIdxBaseClassInfo$LAYOUT = MemoryLayout.ofStruct(
         CSupport.C_POINTER.withName("base"),
         MemoryLayout.ofStruct(
             CSupport.C_INT.withName("kind"),
@@ -6834,14 +6834,14 @@
         CSupport.C_INT.withName("numProtocols"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXIdxObjCProtocolRefListInfo$numProtocols = CXIdxObjCProtocolRefListInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("numProtocols"));
     public static final int CXIdxObjCProtocolRefListInfo$numProtocols$get(MemorySegment seg) {
-        return (int)CXIdxObjCProtocolRefListInfo$numProtocols.get(seg.address());
+        return (int)CXIdxObjCProtocolRefListInfo$numProtocols.get(seg);
     }
     public static final void CXIdxObjCProtocolRefListInfo$numProtocols$set(MemorySegment seg, int x) {
-        CXIdxObjCProtocolRefListInfo$numProtocols.set(seg.address(), x);
+        CXIdxObjCProtocolRefListInfo$numProtocols.set(seg, x);
     }
     public static final MemoryLayout CXIdxObjCInterfaceDeclInfo$LAYOUT = MemoryLayout.ofStruct(
         CSupport.C_POINTER.withName("containerInfo"),
         CSupport.C_POINTER.withName("superInfo"),
         CSupport.C_POINTER.withName("protocols")
@@ -6872,14 +6872,14 @@
         CSupport.C_INT.withName("numBases"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXIdxCXXClassDeclInfo$numBases = CXIdxCXXClassDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("numBases"));
     public static final int CXIdxCXXClassDeclInfo$numBases$get(MemorySegment seg) {
-        return (int)CXIdxCXXClassDeclInfo$numBases.get(seg.address());
+        return (int)CXIdxCXXClassDeclInfo$numBases.get(seg);
     }
     public static final void CXIdxCXXClassDeclInfo$numBases$set(MemorySegment seg, int x) {
-        CXIdxCXXClassDeclInfo$numBases.set(seg.address(), x);
+        CXIdxCXXClassDeclInfo$numBases.set(seg, x);
     }
     public static final int CXIdxEntityRef_Direct = (int)1L;
     public static final int CXIdxEntityRef_Implicit = (int)2L;
     public static final int CXSymbolRole_None = (int)0L;
     public static final int CXSymbolRole_Declaration = (int)1L;
@@ -6910,21 +6910,21 @@
         CSupport.C_INT.withName("role"),
         MemoryLayout.ofPaddingBits(32)
     );
     public static final VarHandle CXIdxEntityRefInfo$kind = CXIdxEntityRefInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
     public static final int CXIdxEntityRefInfo$kind$get(MemorySegment seg) {
-        return (int)CXIdxEntityRefInfo$kind.get(seg.address());
+        return (int)CXIdxEntityRefInfo$kind.get(seg);
     }
     public static final void CXIdxEntityRefInfo$kind$set(MemorySegment seg, int x) {
-        CXIdxEntityRefInfo$kind.set(seg.address(), x);
+        CXIdxEntityRefInfo$kind.set(seg, x);
     }
     public static final VarHandle CXIdxEntityRefInfo$role = CXIdxEntityRefInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("role"));
     public static final int CXIdxEntityRefInfo$role$get(MemorySegment seg) {
-        return (int)CXIdxEntityRefInfo$role.get(seg.address());
+        return (int)CXIdxEntityRefInfo$role.get(seg);
     }
     public static final void CXIdxEntityRefInfo$role$set(MemorySegment seg, int x) {
-        CXIdxEntityRefInfo$role.set(seg.address(), x);
+        CXIdxEntityRefInfo$role.set(seg, x);
     }
     public static final MemoryLayout IndexerCallbacks$LAYOUT = MemoryLayout.ofStruct(
         CSupport.C_POINTER.withName("abortQuery"),
         CSupport.C_POINTER.withName("diagnostic"),
         CSupport.C_POINTER.withName("enteredMainFile"),
diff a/test/jdk/tools/jextract/ConstantsTest.java b/test/jdk/tools/jextract/ConstantsTest.java
--- a/test/jdk/tools/jextract/ConstantsTest.java
+++ b/test/jdk/tools/jextract/ConstantsTest.java
@@ -20,10 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.MemorySegment;
 import org.testng.annotations.AfterTest;
 import org.testng.annotations.BeforeTest;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 import java.nio.file.Path;
@@ -95,22 +96,22 @@
                 { "CHAR_VALUE", int.class, equalsTo(104) }, //integer char constants have type int
                 { "MULTICHAR_VALUE", int.class, equalsTo(26728) },  //integer char constants have type int
                 { "BOOL_VALUE", byte.class, equalsTo((byte)1) },
                 { "SUB", int.class, equalsTo( 7 ) },
                 // pointer type values
-                { "STR", MemoryAddress.class, equalsToJavaStr("Hello") },
-                { "QUOTE", MemoryAddress.class, equalsToJavaStr("QUOTE") },
+                { "STR", MemorySegment.class, equalsToJavaStr("Hello") },
+                { "QUOTE", MemorySegment.class, equalsToJavaStr("QUOTE") },
                 { "ZERO_PTR", MemoryAddress.class, equalsPtrContents(0) },
                 { "F_PTR", MemoryAddress.class, equalsPtrContents(0xFFFFFFFFFFFFFFFFL) },
         };
     }
 
     static Consumer<Object> equalsTo(Object expected) {
         return actual -> assertEquals(actual, expected);
     }
 
-    static Consumer<MemoryAddress> equalsToJavaStr(String expected) {
+    static Consumer<MemorySegment> equalsToJavaStr(String expected) {
         return actual -> assertEquals(CSupport.toJavaString(actual), expected);
     }
 
     static Consumer<MemoryAddress> equalsPtrContents(long expected) {
         return actual -> assertEquals(actual.toRawLongValue(), expected);
diff a/test/jdk/tools/jextract/Test8248415.java b/test/jdk/tools/jextract/Test8248415.java
--- a/test/jdk/tools/jextract/Test8248415.java
+++ b/test/jdk/tools/jextract/Test8248415.java
@@ -21,10 +21,11 @@
  * questions.
  */
 
 import java.nio.file.Path;
 import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
 import org.testng.annotations.Test;
 
 /*
  * @test
  * @library /test/lib
@@ -43,16 +44,16 @@
         run("-d", outputPath.toString(), headerFile.toString()).checkSuccess();
         try(Loader loader = classLoader(outputPath)) {
             Class<?> nodeClass = loader.loadClass("test8248415_h$Node");
 
             // Check if getters for pointer fields were generated
-            checkMethod(nodeClass, "next$get", MemoryAddress.class, MemoryAddress.class);
-            checkMethod(nodeClass, "next$get", MemoryAddress.class, MemoryAddress.class, long.class);
+            checkMethod(nodeClass, "next$get", MemoryAddress.class, MemorySegment.class);
+            checkMethod(nodeClass, "next$get", MemoryAddress.class, MemorySegment.class, long.class);
 
             // Check if setters for pointer fields were generated
-            checkMethod(nodeClass, "next$set", void.class, MemoryAddress.class, MemoryAddress.class);
-            checkMethod(nodeClass, "next$set", void.class, MemoryAddress.class, long.class, MemoryAddress.class);
+            checkMethod(nodeClass, "next$set", void.class, MemorySegment.class, MemoryAddress.class);
+            checkMethod(nodeClass, "next$set", void.class, MemorySegment.class, long.class, MemoryAddress.class);
         } finally {
             deleteDir(outputPath);
         }
     }
 }
diff a/test/jdk/tools/jextract/test8241925/LibTest8241925Test.java b/test/jdk/tools/jextract/test8241925/LibTest8241925Test.java
--- a/test/jdk/tools/jextract/test8241925/LibTest8241925Test.java
+++ b/test/jdk/tools/jextract/test8241925/LibTest8241925Test.java
@@ -56,26 +56,26 @@
 
             int[] intArray = { 34, 67, 78, 8 };
             addr = scope.allocateArray(C_INT, intArray);
             int sum = sum(addr, intArray.length);
             assertEquals(sum, IntStream.of(intArray).sum());
-            int[] convertedArray = addr.segment().toIntArray();
+            int[] convertedArray = addr.toIntArray();
             assertEquals(convertedArray, intArray);
 
             double[] dblArray = { 34.5, 67.56, 78.2, 8.45 };
             addr = scope.allocateArray(C_DOUBLE, dblArray);
             double sumd = sum_fp(addr, dblArray.length);
             assertEquals(sumd, DoubleStream.of(dblArray).sum(), 0.1);
-            double[] convertedDblArray = addr.segment().toDoubleArray();
+            double[] convertedDblArray = addr.toDoubleArray();
             for (int i = 0; i < dblArray.length; i++) {
                 assertEquals(dblArray[i], convertedDblArray[i], 0.1);
             }
 
             assertEquals(toJavaStringRestricted(name()), "java");
 
             var dest = scope.allocateArray(C_CHAR, 12);
-            dest.segment().copyFrom(toCString("hello "));
+            dest.copyFrom(toCString("hello "));
             var src = toCString("world", scope);
             assertEquals(toJavaStringRestricted(concatenate(dest, src)), "hello world");
         }
     }
 }
diff a/test/jdk/tools/jextract/test8244938/Test8244938.java b/test/jdk/tools/jextract/test8244938/Test8244938.java
--- a/test/jdk/tools/jextract/test8244938/Test8244938.java
+++ b/test/jdk/tools/jextract/test8244938/Test8244938.java
@@ -37,12 +37,11 @@
 public class Test8244938 {
     @Test
     public void testNestedStructReturn() {
          var seg = func();
          assertEquals(seg.byteSize(), Point.sizeof());
-         var addr = seg.address();
-         assertEquals(Point.k$get(addr), 44);
-         var point2dAddr = Point.point2d$addr(addr);
+         assertEquals(Point.k$get(seg), 44);
+         var point2dAddr = Point.point2d$addr(seg);
          assertEquals(Point2D.i$get(point2dAddr), 567);
          assertEquals(Point2D.j$get(point2dAddr), 33);
     }
 }
diff a/test/jdk/tools/jextract/test8244959/Test8244959.java b/test/jdk/tools/jextract/test8244959/Test8244959.java
--- a/test/jdk/tools/jextract/test8244959/Test8244959.java
+++ b/test/jdk/tools/jextract/test8244959/Test8244959.java
@@ -38,13 +38,13 @@
  */
 public class Test8244959 {
     @Test
     public void testsPrintf() {
         try (MemorySegment s = MemorySegment.allocateNative(1024)) {
-            my_sprintf(s.address(),
-                toCString("%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c").address(), 12,
+            my_sprintf(s,
+                toCString("%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c"), 12,
                 (byte) 1, 'b', -1.25f, 5.5d, -200L, Long.MAX_VALUE, (byte) -2, (short) 2, 3, (short) -4, 5L, 'a');
-            String str = toJavaString(s.address());
+            String str = toJavaString(s);
             assertEquals(str, "1 b -1.25 5.50 -200 " + Long.MAX_VALUE + " -2 2 3 -4 5 a");
         }
     }
 }
diff a/test/jdk/tools/jextract/test8245003/Test8245003.java b/test/jdk/tools/jextract/test8245003/Test8245003.java
--- a/test/jdk/tools/jextract/test8245003/Test8245003.java
+++ b/test/jdk/tools/jextract/test8245003/Test8245003.java
@@ -38,38 +38,38 @@
  */
 public class Test8245003 {
     @Test
     public void testStructAccessor() {
         var addr = special_pt$ADDR();
-        assertEquals(addr.segment().byteSize(), Point.sizeof());
+        assertEquals(addr.byteSize(), Point.sizeof());
         assertEquals(Point.x$get(addr), 56);
         assertEquals(Point.y$get(addr), 75);
 
         addr = special_pt3d$ADDR();
-        assertEquals(addr.segment().byteSize(), Point3D.sizeof());
+        assertEquals(addr.byteSize(), Point3D.sizeof());
         assertEquals(Point3D.z$get(addr), 35);
         var pointAddr = Point3D.p$addr(addr);
-        assertEquals(pointAddr.segment().byteSize(), Point.sizeof());
+        assertEquals(pointAddr.byteSize(), Point.sizeof());
         assertEquals(Point.x$get(pointAddr), 43);
         assertEquals(Point.y$get(pointAddr), 45);
     }
 
     @Test
     public void testArrayAccessor() {
         var addr = iarr$ADDR();
-        assertEquals(addr.segment().byteSize(), C_INT.byteSize()*5);
-        int[] arr = addr.segment().toIntArray();
+        assertEquals(addr.byteSize(), C_INT.byteSize()*5);
+        int[] arr = addr.toIntArray();
         assertEquals(arr.length, 5);
         assertEquals(arr[0], 2);
         assertEquals(arr[1], -2);
         assertEquals(arr[2], 42);
         assertEquals(arr[3], -42);
         assertEquals(arr[4], 345);
 
         addr = foo$ADDR();
-        assertEquals(addr.segment().byteSize(), Foo.sizeof());
+        assertEquals(addr.byteSize(), Foo.sizeof());
         assertEquals(Foo.count$get(addr), 37);
         var greeting = Foo.greeting$addr(addr);
-        byte[] barr = greeting.segment().toByteArray();
+        byte[] barr = greeting.toByteArray();
         assertEquals(new String(barr), "hello");
     }
 }
diff a/test/jdk/tools/jextract/test8246341/LibTest8246341Test.java b/test/jdk/tools/jextract/test8246341/LibTest8246341Test.java
--- a/test/jdk/tools/jextract/test8246341/LibTest8246341Test.java
+++ b/test/jdk/tools/jextract/test8246341/LibTest8246341Test.java
@@ -52,11 +52,11 @@
             assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 0)), "java");
             assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 1)), "python");
             assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 2)), "javascript");
             assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 3)), "c++");
         })) {
-            func(callback.address());
+            func(callback);
         }
         assertTrue(callbackCalled[0]);
     }
 
     @Test
diff a/test/jdk/tools/jextract/test8246400/LibTest8246400Test.java b/test/jdk/tools/jextract/test8246400/LibTest8246400Test.java
--- a/test/jdk/tools/jextract/test8246400/LibTest8246400Test.java
+++ b/test/jdk/tools/jextract/test8246400/LibTest8246400Test.java
@@ -42,36 +42,36 @@
  */
 public class LibTest8246400Test {
     @Test
     public void testSegmentRegister() {
         MemorySegment sum = null;
-        MemoryAddress callback = null;
+        MemorySegment callback = null;
         try (var scope = NativeScope.unboundedScope()) {
             var v1 = Vector.allocate(scope);
             Vector.x$set(v1, 1.0);
             Vector.y$set(v1, 0.0);
 
             var v2 = Vector.allocate(scope);
             Vector.x$set(v2, 0.0);
             Vector.y$set(v2, 1.0);
 
-            sum = add(v1.segment(), v2.segment());
+            sum = add(v1, v2);
             sum = scope.register(sum);
 
-            assertEquals(Vector.x$get(sum.address()), 1.0, 0.1);
-            assertEquals(Vector.y$get(sum.address()), 1.0, 0.1);
+            assertEquals(Vector.x$get(sum), 1.0, 0.1);
+            assertEquals(Vector.y$get(sum), 1.0, 0.1);
 
             callback = cosine_similarity$dot.allocate((a, b) -> {
-                return (Vector.x$get(a.address()) * Vector.x$get(b.address())) +
-                    (Vector.y$get(a.address()) * Vector.y$get(b.address()));
+                return (Vector.x$get(a) * Vector.x$get(b)) +
+                    (Vector.y$get(a) * Vector.y$get(b));
             }, scope);
 
-            var value = cosine_similarity(v1.segment(), v2.segment(), callback);
+            var value = cosine_similarity(v1, v2, callback);
             assertEquals(value, 0.0, 0.1);
 
-            value = cosine_similarity(v1.segment(), v1.segment(), callback);
+            value = cosine_similarity(v1, v1, callback);
             assertEquals(value, 1.0, 0.1);
         }
         assertTrue(!sum.isAlive());
-        assertTrue(!callback.segment().isAlive());
+        assertTrue(!callback.isAlive());
     }
 }
diff a/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java b/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
--- a/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
+++ b/test/jdk/tools/jextract/testClassGen/TestClassGeneration.java
@@ -148,14 +148,14 @@
         assertEquals(getter.invoke(null), expectedValue);
     }
 
     @Test(dataProvider = "stringConstants")
     public void testStringConstant(String name, String expectedValue) throws Throwable {
-        Method getter = checkMethod(cls, name, MemoryAddress.class);
-        MemoryAddress actual = (MemoryAddress) getter.invoke(null);
+        Method getter = checkMethod(cls, name, MemorySegment.class);
+        MemorySegment actual = (MemorySegment) getter.invoke(null);
         byte[] expected = expectedValue.getBytes(StandardCharsets.UTF_8);
-        assertEquals(actual.segment().byteSize(), expected.length + 1);
+        assertEquals(actual.byteSize(), expected.length + 1);
         for (int i = 0; i < expected.length; i++) {
             assertEquals((byte) VH_bytes.get(actual, (long) i), expected[i]);
         }
     }
 
@@ -176,20 +176,17 @@
     @Test(dataProvider = "globals")
     public void testGlobal(String name, Class<?> expectedType, MemoryLayout expectedLayout, Object expectedValue) throws Throwable {
         Method layout_getter = checkMethod(cls, name + "$LAYOUT", MemoryLayout.class);
         assertEquals(layout_getter.invoke(null), expectedLayout);
 
-        Method addr_getter = checkMethod(cls, name + "$ADDR", MemoryAddress.class);
-        MemoryAddress addr = MemorySegment.ofNativeRestricted(
-                (MemoryAddress)addr_getter.invoke(null),
-                expectedLayout.byteSize(),
-                null, null, null).address();
+        Method addr_getter = checkMethod(cls, name + "$ADDR", MemorySegment.class);
+        MemorySegment segment = (MemorySegment)addr_getter.invoke(null);
 
         Method vh_getter = checkMethod(cls, name + "$VH", VarHandle.class);
         VarHandle vh = (VarHandle) vh_getter.invoke(null);
         assertEquals(vh.varType(), expectedType);
-        assertEquals(vh.get(addr), expectedValue);
+        assertEquals(vh.get(segment), expectedValue);
 
         checkMethod(cls, name + "$get", expectedType);
         checkMethod(cls, name + "$set", void.class, expectedType);
     }
 
@@ -203,13 +200,13 @@
         try (MemorySegment struct = MemorySegment.allocateNative(structLayout)) {
             Method vh_getter = checkMethod(structCls, memberName + "$VH", VarHandle.class);
             VarHandle vh = (VarHandle) vh_getter.invoke(null);
             assertEquals(vh.varType(), expectedType);
 
-            Method getter = checkMethod(structCls, memberName + "$get", expectedType, MemoryAddress.class);
-            Method setter = checkMethod(structCls, memberName + "$set", void.class, MemoryAddress.class, expectedType);
-            MemoryAddress addr = struct.address();
+            Method getter = checkMethod(structCls, memberName + "$get", expectedType, MemorySegment.class);
+            Method setter = checkMethod(structCls, memberName + "$set", void.class, MemorySegment.class, expectedType);
+            MemorySegment addr = struct;
             setter.invoke(null, addr, testValue);
             assertEquals(getter.invoke(null, addr), testValue);
         }
     }
 
diff a/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java b/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java
--- a/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java
+++ b/test/jdk/tools/jextract/testFunctionPointer/LibFuncPtrTest.java
@@ -36,9 +36,9 @@
  */
 public class LibFuncPtrTest {
     @Test
     public void test() {
         try (var handle = func$f.allocate(x -> x*x)) {
-            assertEquals(func(handle.address(), 35), 35 * 35 + 35);
+            assertEquals(func(handle, 35), 35 * 35 + 35);
         } //deallocate
     }
 }
diff a/test/jdk/tools/jextract/testStruct/LibStructTest.java b/test/jdk/tools/jextract/testStruct/LibStructTest.java
--- a/test/jdk/tools/jextract/testStruct/LibStructTest.java
+++ b/test/jdk/tools/jextract/testStruct/LibStructTest.java
@@ -39,38 +39,35 @@
  */
 public class LibStructTest {
     @Test
     public void testMakePoint() {
         try (var seg = makePoint(42, -39)) {
-            var addr = seg.address();
-            assertEquals(Point.x$get(addr), 42);
-            assertEquals(Point.y$get(addr), -39);
+            assertEquals(Point.x$get(seg), 42);
+            assertEquals(Point.y$get(seg), -39);
         }
     }
 
     @Test
     public void testAllocate() {
         try (var seg = Point.allocate()) {
-            var addr = seg.address();
-            Point.x$set(addr, 56);
-            Point.y$set(addr, 65);
-            assertEquals(Point.x$get(addr), 56);
-            assertEquals(Point.y$get(addr), 65);
+            Point.x$set(seg, 56);
+            Point.y$set(seg, 65);
+            assertEquals(Point.x$get(seg), 56);
+            assertEquals(Point.y$get(seg), 65);
         }
     }
 
     @Test
     public void testAllocateArray() {
         try (var seg = Point.allocateArray(3)) {
-            var addr = seg.address();
             for (int i = 0; i < 3; i++) {
-                Point.x$set(addr, i, 56 + i);
-                Point.y$set(addr, i, 65 + i);
+                Point.x$set(seg, i, 56 + i);
+                Point.y$set(seg, i, 65 + i);
             }
             for (int i = 0; i < 3; i++) {
-                assertEquals(Point.x$get(addr, i), 56 + i);
-                assertEquals(Point.y$get(addr, i), 65 + i);
+                assertEquals(Point.x$get(seg, i), 56 + i);
+                assertEquals(Point.y$get(seg, i), 65 + i);
             }
         }
     }
 
     private static void checkField(GroupLayout group, String fieldName, MemoryLayout expected) {

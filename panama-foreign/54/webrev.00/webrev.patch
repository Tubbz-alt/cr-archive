diff a/src/java.base/share/classes/java/nio/Buffer.java b/src/java.base/share/classes/java/nio/Buffer.java
--- a/src/java.base/share/classes/java/nio/Buffer.java
+++ b/src/java.base/share/classes/java/nio/Buffer.java
@@ -27,10 +27,11 @@
 
 import jdk.internal.HotSpotIntrinsicCandidate;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.MemorySegmentProxy;
+import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.vm.annotation.ForceInline;
 
 import java.util.Spliterator;
 
@@ -765,10 +766,15 @@
                 @Override
                 public ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj, MemorySegmentProxy segment) {
                     return new DirectByteBuffer(addr, cap, obj, segment);
                 }
 
+                @Override
+                public ByteBuffer newMappedByteBuffer(UnmapperProxy unmapperProxy, long addr, int cap, Object obj, MemorySegmentProxy segment) {
+                    return new DirectByteBuffer(addr, cap, obj, unmapperProxy.fileDescriptor(), unmapperProxy.isSync(), segment);
+                }
+
                 @Override
                 public ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity, MemorySegmentProxy segment) {
                     return new HeapByteBuffer(hb, offset, capacity, segment);
                 }
 
@@ -780,10 +786,19 @@
                 @Override
                 public long getBufferAddress(ByteBuffer bb) {
                     return bb.address;
                 }
 
+                @Override
+                public UnmapperProxy unmapper(ByteBuffer bb) {
+                    if (bb instanceof MappedByteBuffer) {
+                        return ((MappedByteBuffer)bb).unmapper();
+                    } else {
+                        return null;
+                    }
+                }
+
                 @Override
                 public void checkSegment(Buffer buffer) {
                     buffer.checkSegment();
                 }
             });
diff a/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template b/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
--- a/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
+++ b/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
@@ -151,10 +151,19 @@
         address = addr;
         cleaner = null;
         att = ob;
     }
 
+    // Invoked to construct a direct ByteBuffer referring to the block of
+    // memory. A given arbitrary object may also be attached to the buffer.
+    //
+    Direct$Type$Buffer(long addr, int cap, Object ob, FileDescriptor fd, boolean isSync, MemorySegmentProxy segment) {
+        super(-1, 0, cap, cap, fd, isSync, segment);
+        address = addr;
+        cleaner = null;
+        att = ob;
+    }
 
     // Invoked only by JNI: NewDirectByteBuffer(void*, long)
     //
     private Direct$Type$Buffer(long addr, int cap) {
         super(-1, 0, cap, cap, null);
diff a/src/java.base/share/classes/java/nio/MappedByteBuffer.java b/src/java.base/share/classes/java/nio/MappedByteBuffer.java
--- a/src/java.base/share/classes/java/nio/MappedByteBuffer.java
+++ b/src/java.base/share/classes/java/nio/MappedByteBuffer.java
@@ -28,10 +28,11 @@
 import java.io.FileDescriptor;
 import java.lang.ref.Reference;
 import java.util.Objects;
 
 import jdk.internal.access.foreign.MemorySegmentProxy;
+import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
 
 
 /**
  * A direct byte buffer whose content is a memory-mapped region of a file.
@@ -107,10 +108,35 @@
         super(mark, pos, lim, cap, segment);
         this.fd = null;
         this.isSync = false;
     }
 
+    UnmapperProxy unmapper() {
+        return fd != null ?
+                new UnmapperProxy() {
+                    @Override
+                    public long address() {
+                        return address;
+                    }
+
+                    @Override
+                    public FileDescriptor fileDescriptor() {
+                        return fd;
+                    }
+
+                    @Override
+                    public boolean isSync() {
+                        return isSync;
+                    }
+
+                    @Override
+                    public void unmap() {
+                        throw new UnsupportedOperationException();
+                    }
+                } : null;
+    }
+
     // Returns the distance (in bytes) of the buffer start from the
     // largest page aligned address of the mapping less than or equal
     // to the start address.
     private long mappingOffset() {
         return mappingOffset(0);
diff a/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
@@ -24,10 +24,11 @@
  */
 
 package jdk.internal.access;
 
 import jdk.internal.access.foreign.MemorySegmentProxy;
+import jdk.internal.access.foreign.UnmapperProxy;
 
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 
 public interface JavaNioAccess {
@@ -49,10 +50,20 @@
      * to the resulting buffer.
      * Used by {@code jdk.internal.foreignMemorySegmentImpl}.
      */
     ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj, MemorySegmentProxy segment);
 
+    /**
+     * Constructs a mapped ByteBuffer referring to the block of memory starting
+     * at the given memory address and extending {@code cap} bytes.
+     * The {@code ob} parameter is an arbitrary object that is attached
+     * to the resulting buffer. The {@code sync} and {@code fd} parameters of the mapped
+     * buffer are derived from the {@code UnmapperProxy}.
+     * Used by {@code jdk.internal.foreignMemorySegmentImpl}.
+     */
+    ByteBuffer newMappedByteBuffer(UnmapperProxy unmapperProxy, long addr, int cap, Object obj, MemorySegmentProxy segment);
+
     /**
      * Constructs an heap ByteBuffer with given backing array, offset, capacity and segment.
      * Used by {@code jdk.internal.foreignMemorySegmentImpl}.
      */
     ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity, MemorySegmentProxy segment);
@@ -65,10 +76,15 @@
     /**
      * Used by {@code jdk.internal.foreign.Utils}.
      */
     long getBufferAddress(ByteBuffer bb);
 
+    /**
+     * Used by {@code jdk.internal.foreign.Utils}.
+     */
+    UnmapperProxy unmapper(ByteBuffer bb);
+
     /**
      * Used by byte buffer var handle views.
      */
     void checkSegment(Buffer buffer);
 }
diff a/src/java.base/share/classes/jdk/internal/access/foreign/UnmapperProxy.java b/src/java.base/share/classes/jdk/internal/access/foreign/UnmapperProxy.java
--- a/src/java.base/share/classes/jdk/internal/access/foreign/UnmapperProxy.java
+++ b/src/java.base/share/classes/jdk/internal/access/foreign/UnmapperProxy.java
@@ -24,13 +24,17 @@
  *
  */
 
 package jdk.internal.access.foreign;
 
+import java.io.FileDescriptor;
+
 /**
  * This proxy interface is required to allow instances of the {@code FileChannelImpl.Unmapper} interface (which is a non-public class
  * inside the {@code sun.nio.ch} package) to be accessed from the mapped memory segment factory.
  */
 public interface UnmapperProxy {
     long address();
+    FileDescriptor fileDescriptor();
+    boolean isSync();
     void unmap();
 }
diff a/src/java.base/share/classes/module-info.java b/src/java.base/share/classes/module-info.java
--- a/src/java.base/share/classes/module-info.java
+++ b/src/java.base/share/classes/module-info.java
@@ -221,11 +221,12 @@
         jdk.management.agent,
         jdk.internal.jvmstat;
     exports jdk.internal.platform to
         jdk.management;
     exports jdk.internal.ref to
-        java.desktop;
+        java.desktop,
+        jdk.incubator.foreign;
     exports jdk.internal.reflect to
         java.logging,
         java.sql,
         java.sql.rowset,
         jdk.dynalink,
diff a/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java b/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java
--- a/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java
+++ b/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java
@@ -892,10 +892,15 @@
         @Override
         public long address() {
             return address;
         }
 
+        @Override
+        public FileDescriptor fileDescriptor() {
+            return fd;
+        }
+
         @Override
         public void run() {
             unmap();
         }
 
@@ -945,10 +950,14 @@
                 count--;
                 totalSize -= size;
                 totalCapacity -= cap;
             }
         }
+
+        public boolean isSync() {
+            return false;
+        }
     }
 
     private static class SyncUnmapper extends Unmapper {
 
         // keep track of mapped buffer usage
@@ -974,10 +983,14 @@
                 count--;
                 totalSize -= size;
                 totalCapacity -= cap;
             }
         }
+
+        public boolean isSync() {
+            return true;
+        }
     }
 
     private static void unmap(MappedByteBuffer bb) {
         Cleaner cl = ((DirectBuffer)bb).cleaner();
         if (cl != null)
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySource.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySource.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySource.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.foreign;
+
+/**
+ * A mapped memory source describes an underlying memory region which is memory-mapped from a given path.
+ * As such, it provides additional operations to allow for syncing the contents of the mapped memory source with
+ * the ones of the underlying file backing the memory mapping (see {@link #force()} and {@link #force(MemorySegment)}).
+ *
+ * @apiNote In the future, if the Java language permits, {@link MemorySource}
+ * may become a {@code sealed} interface, which would prohibit subclassing except by
+ * explicitly permitted types.
+ */
+public interface MappedMemorySource extends MemorySource {
+    /**
+     * Forces any changes made to this memory source to be written to the
+     * storage device containing the path associated with this memory source.
+     *
+     * <p> If the path associated with this memory source resides on a local storage
+     * device then when this method returns it is guaranteed that all changes
+     * made to this memory source since it was created, or since this method was last
+     * invoked, will have been written to that device.
+     *
+     * <p> If the path associated to this memory source does not reside on a local device,
+     * then no such guarantee is made.
+     *
+     * <p> If this the map mode associated with this memory source is not ({@link
+     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then invoking this method may have no effect.
+     * This method may or may not have an effect for implementation-specific mapping modes.</p>
+     *
+     * @throws IllegalStateException if the memory region backing this memory source has already been released (see
+     * {@link #isReleased()}).
+     */
+    void force();
+
+    /**
+     * Forces any changes made to a segment derived from this memory source to be written to the
+     * storage device containing the path associated with this memory source.
+     *
+     * <p> If the path associated with this memory source resides on a local storage
+     * device then when this method returns it is guaranteed that all changes
+     * made to this memory source since it was created, or since this method was last
+     * invoked, will have been written to that device.
+     *
+     * <p> If the path associated to this memory source does not reside on a local device,
+     * then no such guarantee is made.
+     *
+     * <p> If this the map modes associated with this memory source is not ({@link
+     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then invoking this method may have no effect.
+     * This method may or may not have an effect for implementation-specific mapping modes.</p>
+     *
+     * @param segment the memory segment whose contents are to be written back to storage.
+     *
+     * @throws IllegalStateException if the memory region backing this memory source has already been released (see
+     * {@link #isReleased()}).
+     */
+    void force(MemorySegment segment);
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -33,12 +33,12 @@
 import java.io.IOException;
 import java.nio.channels.FileChannel;
 import java.nio.file.Path;
 
 /**
- * A memory segment models a contiguous region of memory. A memory segment is associated with both spatial
- * and temporal bounds. Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location
+ * A memory segment is a view over a given memory source (see {@link MemorySource}), which is associated with both spatial
+ * and temporal <em>bounds</em>. Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location
  * which falls <em>outside</em> the boundaries of the memory segment being accessed. Temporal checks ensure that memory access
  * operations on a segment cannot occur after a memory segment has been closed (see {@link MemorySegment#close()}).
  * <p>
  * All implementations of this interface must be <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>;
  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
@@ -50,59 +50,49 @@
  * <h2>Constructing memory segments from different sources</h2>
  *
  * There are multiple ways to obtain a memory segment. First, memory segments backed by off-heap memory can
  * be allocated using one of the many factory methods provided (see {@link MemorySegment#allocateNative(MemoryLayout)},
  * {@link MemorySegment#allocateNative(long)} and {@link MemorySegment#allocateNative(long, long)}). Memory segments obtained
- * in this way are called <em>native memory segments</em>.
+ * in this way are backed by a <em>native</em> memory source (see {@link MemorySource}).
  * <p>
  * It is also possible to obtain a memory segment backed by an existing heap-allocated Java array,
  * using one of the provided factory methods (e.g. {@link MemorySegment#ofArray(int[])}). Memory segments obtained
- * in this way are called <em>array memory segments</em>.
+ * in this way are backed by a <em>heap</em> memory source (see {@link MemorySource}).
  * <p>
- * It is possible to obtain a memory segment backed by an existing Java byte buffer (see {@link ByteBuffer}),
- * using the factory method {@link MemorySegment#ofByteBuffer(ByteBuffer)}.
- * Memory segments obtained in this way are called <em>buffer memory segments</em>. Note that buffer memory segments might
- * be backed by native memory (as in the case of native memory segments) or heap memory (as in the case of array memory segments),
- * depending on the characteristics of the byte buffer instance the segment is associated with. For instance, a buffer memory
- * segment obtained from a byte buffer created with the {@link ByteBuffer#allocateDirect(int)} method will be backed
- * by native memory.
+ * It is possible to obtain a memory segment backed by a memory-mapped file using the factory method
+ * {@link MemorySegment#mapFromPath(Path, long, FileChannel.MapMode)}. Such memory segments are backed by a
+ * <em>mapped</em> memory source (see {@link MappedMemorySource}).
  * <p>
- * Finally, it is also possible to obtain a memory segment backed by a memory-mapped file using the factory method
- * {@link MemorySegment#mapFromPath(Path, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments</em>.
+ * Finally, it is also possible to obtain a memory segment backed by an existing Java byte buffer (see {@link ByteBuffer}),
+ * using the factory method {@link MemorySegment#ofByteBuffer(ByteBuffer)}. Memory segments obtained in this can be
+ * backed by a native memory source, an heap memory source, or a mapped memory source, depending on the characteristics
+ * of the byte buffer instance the segment is associated with. For instance, a memory segment obtained from a byte buffer
+ * created with the {@link ByteBuffer#allocateDirect(int)} method will be backed by a native memory source; a memory segment
+ * obtained from a byte buffer created with the {@link ByteBuffer#allocate(int)} will be backed by a heap memory source;
+ * finally, a memory segment obtained from a byte buffer created with the {@link FileChannel#map(FileChannel.MapMode, long, long)} method
+ * will be backed by a mapped memory source.
  *
  * <h2>Closing a memory segment</h2>
  *
- * Memory segments are closed explicitly (see {@link MemorySegment#close()}). In general when a segment is closed, all off-heap
- * resources associated with it are released; this has different meanings depending on the kind of memory segment being
- * considered:
- * <ul>
- *     <li>closing a native memory segment results in <em>freeing</em> the native memory associated with it</li>
- *     <li>closing a mapped memory segment results in the backing memory-mapped file to be unmapped</li>
- *     <li>closing an acquired memory segment <b>does not</b> result in the release of resources
- *     (see the section on <a href="#thread-confinement">thread confinement</a> for more details)</li>
- *     <li>closing a buffer, or a heap segment does not have any side-effect, other than marking the segment
- *     as <em>not alive</em> (see {@link MemorySegment#isAlive()}). Also, since the buffer and heap segments might keep
- *     strong references to the original buffer or array instance, it is the responsibility of clients to ensure that
- *     these segments are discarded in a timely manner, so as not to prevent garbage collection to reclaim the underlying
- *     objects.</li>
- * </ul>
+ * Memory segments are closed explicitly (see {@link MemorySegment#close()}). When a memory segment is closed,
+ * the segment, and all memory addresses (see {@link MemoryAddress}) derived from it are rendered invalid. This means
+ * that e.g. dereferencing a memory address derived from a segment that has been closed will result in a runtime
+ * exception. Closing a memory segment <em>might</em> additionally result in <a href="MemorySource.html#releasing-sources">
+ * releasing</a> the memory source backing that memory segment.
  *
  * <h2><a id = "thread-confinement">Thread confinement</a></h2>
  *
  * Memory segments support strong thread-confinement guarantees. Upon creation, they are assigned an <em>owner thread</em>,
  * typically the thread which initiated the creation operation. After creation, only the owner thread will be allowed
  * to directly manipulate the memory segment (e.g. close the memory segment) or access the underlying memory associated with
  * the segment using a memory access var handle. Any attempt to perform such operations from a thread other than the
  * owner thread will result in a runtime failure.
  * <p>
  * If a memory segment S owned by thread A needs to be used by thread B, B needs to explicitly <em>acquire</em> S,
- * which will create a so called <em>acquired</em> memory segment owned by B (see {@link #acquire()}) backed by the same resources
- * as S. A memory segment can be acquired multiple times by one or more threads; in that case, a memory segment S cannot
- * be closed until all the acquired memory segments derived from S have been closed. Furthermore, closing an acquired
- * memory segment does <em>not</em> trigger any deallocation action. It is therefore important that clients remember to
- * explicitly close the original segment from which the acquired memory segments have been obtained in order to truly
- * ensure that off-heap resources associated with the memory segment are released.
+ * which will create a new memory segment owned by B (see {@link #acquire()}) backed by the same memory
+ * source as S. A memory segment can be acquired multiple times by one or more threads; in that case, the underlying memory
+ * source will not be released until <em>all</em> the memory segments derived from it have been closed.
  *
  * <h2><a id = "access-modes">Access modes</a></h2>
  *
  * Memory segments supports zero or more <em>access modes</em>. Supported access modes are {@link #READ},
  * {@link #WRITE}, {@link #CLOSE} and {@link #ACQUIRE}. The set of access modes supported by a segment alters the
@@ -150,16 +140,15 @@
      * @return The base memory address.
      */
     MemoryAddress baseAddress();
 
     /**
-     * Obtains an <a href="#thread-confinement">acquired</a> memory segment which can be used to access memory associated
-     * with this segment from the current thread. As a side-effect, this segment cannot be closed until the acquired
-     * view has been closed too (see {@link #close()}).
-     * @return an <a href="#thread-confinement">acquired</a> memory segment which can be used to access memory associated
+     * Obtains a new memory segment backed by the same memory source as this segment which can be used to access memory associated
      * with this segment from the current thread.
-     * @throws IllegalStateException if this segment has been closed.
+     * @return a new memory segment backed by the same memory source as this segment which can be used to access memory associated
+     * with this segment from the current thread.
+     * @throws IllegalStateException if the memory source associated with this segment has been released (see {@link MemorySource#isReleased()}).
      */
     MemorySegment acquire();
 
     /**
      * The thread owning this segment.
@@ -186,21 +175,27 @@
     MemorySegment withAccessModes(int accessModes);
 
     /**
      * Does this segment support a given set of access modes?
      * @param accessModes an ORed mask of zero or more access modes.
-     * @return true, if the access modes in {@accessModes} are stricter than the ones supported by this segment.
+     * @return true, if the access modes in {@code accessModes} are stricter than the ones supported by this segment.
      */
     boolean hasAccessModes(int accessModes);
 
     /**
      * Returns the <a href="#access-modes">access modes</a> associated with this segment; the result is represented as ORed values from
      * {@link #READ}, {@link #WRITE}, {@link #CLOSE} and {@link #ACQUIRE}.
      * @return the access modes associated with this segment.
      */
     int accessModes();
 
+    /**
+     * Returns the memory source associated with this segment.
+     * @return the memory source associated with this segment.
+     */
+    MemorySource source();
+
     /**
      * Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
      * and whose new size is specified by the given argument.
      * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.
      * @param newSize The new segment size, specified in bytes.
@@ -257,110 +252,113 @@
      * thread owning this segment.
      */
     byte[] toByteArray();
 
     /**
-     * Creates a new buffer memory segment that models the memory associated with the given byte
-     * buffer. The segment starts relative to the buffer's position (inclusive)
-     * and ends relative to the buffer's limit (exclusive).
+     * Creates a new memory segment view of the memory associated with a given byte buffer.
+     * The segment starts relative to the buffer's position (inclusive) and ends relative to the buffer's limit (exclusive).
      * <p>
      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains <em>reachable</em>
      * for the life-time of the segment.
      *
      * @param bb the byte buffer backing the buffer memory segment.
-     * @return a new buffer memory segment.
+     * @return a new memory segment. The memory source of the returned segment depends on the characteristics of {@code bb}. More specifically,
+     * if {@code bb} has been created with the {@link ByteBuffer#allocateDirect(int)} method, the resulting segment will be
+     * backed by a native memory source; if {@code bb} has been created with the {@link ByteBuffer#allocate(int)} method,
+     * the resulting sement will be backed by a heap memory source; finally, if {@code bb} has been created with the
+     * {@link FileChannel#map(FileChannel.MapMode, long, long)} method, the resulting segment  will be backed by a mapped memory source.
      */
     static MemorySegment ofByteBuffer(ByteBuffer bb) {
         return Utils.makeBufferSegment(bb);
     }
 
     /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
+     * Creates a new memory segment view of the memory associated with a given heap-allocated byte array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
      * for the life-time of the segment.
      *
      * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
+     * @return a new memory segment backed by an heap memory source.
      */
     static MemorySegment ofArray(byte[] arr) {
         return Utils.makeArraySegment(arr);
     }
 
     /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
+     * Creates a new memory segment view of the memory associated with a given heap-allocated char array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
      * for the life-time of the segment.
      *
      * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
+     * @return a new memory segment backed by an heap memory source.
      */
     static MemorySegment ofArray(char[] arr) {
         return Utils.makeArraySegment(arr);
     }
 
     /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
+     * Creates a new memory segment view of the memory associated with a given heap-allocated short array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
      * for the life-time of the segment.
      *
      * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
+     * @return a new memory segment backed by an heap memory source.
      */
     static MemorySegment ofArray(short[] arr) {
         return Utils.makeArraySegment(arr);
     }
 
     /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
+     * Creates a new memory segment view of the memory associated with a given heap-allocated int array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
      * for the life-time of the segment.
      *
      * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
+     * @return a new memory segment backed by an heap memory source.
      */
     static MemorySegment ofArray(int[] arr) {
         return Utils.makeArraySegment(arr);
     }
 
     /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
+     * Creates a new memory segment view of the memory associated with a given heap-allocated float array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
      * for the life-time of the segment.
      *
      * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
+     * @return a new memory segment backed by an heap memory source.
      */
     static MemorySegment ofArray(float[] arr) {
         return Utils.makeArraySegment(arr);
     }
 
     /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
+     * Creates a new memory segment view of the memory associated with a given heap-allocated long array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
      * for the life-time of the segment.
      *
      * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
+     * @return a new memory segment backed by an heap memory source.
      */
     static MemorySegment ofArray(long[] arr) {
         return Utils.makeArraySegment(arr);
     }
 
     /**
-     * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
+     * Creates a new memory segment view of the memory associated with a given heap-allocated double array.
      * <p>
      * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
      * for the life-time of the segment.
      *
      * @param arr the primitive array backing the array memory segment.
-     * @return a new array memory segment.
+     * @return a new memory segment backed by an heap memory source.
      */
     static MemorySegment ofArray(double[] arr) {
         return Utils.makeArraySegment(arr);
     }
 
@@ -375,11 +373,11 @@
      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
      *
      * @param layout the layout of the off-heap memory block backing the native memory segment.
-     * @return a new native memory segment.
+     * @return a new memory segment backed by a native memory source.
      * @throws IllegalArgumentException if the specified layout has illegal size or alignment constraint.
      */
     static MemorySegment allocateNative(MemoryLayout layout) {
         return allocateNative(layout.byteSize(), layout.byteAlignment());
     }
@@ -395,11 +393,11 @@
      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
      *
      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
-     * @return a new native memory segment.
+     * @return a new memory segment backed by a native memory source.
      * @throws IllegalArgumentException if {@code bytesSize < 0}.
      */
     static MemorySegment allocateNative(long bytesSize) {
         return allocateNative(bytesSize, 1);
     }
@@ -411,11 +409,11 @@
      * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
      *
      * @param path the path to the file to memory map.
      * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
      * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}.
-     * @return a new mapped memory segment.
+     * @return a new memory segment backed by a mapped memory source.
      * @throws IllegalArgumentException if {@code bytesSize < 0}.
      * @throws UnsupportedOperationException if an unsupported map mode is specified.
      * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
      */
     static MemorySegment mapFromPath(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
@@ -430,11 +428,11 @@
      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
      *
      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
      * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
-     * @return a new native memory segment.
+     * @return a new memory segment backed by a native memory source.
      * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes < 0}, or if {@code alignmentBytes}
      * is not a power of 2.
      */
     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
         if (bytesSize <= 0) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySource.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySource.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySource.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.foreign;
+
+/**
+ * A memory source describes an underlying memory region with specific size and kind. Supported memory sources are:
+ * on-heap sources, native sources or mapped sources. Memory sources cannot be allocated or released explicitly - instead,
+ * clients need to operate on them using a memory segment (see {@link MemorySegment}). In other words, a memory segment
+ * can be thought of as a <em>view</em> over a given memory source.
+ *
+ * <h2><a id = "releasing-sources">Releasing memory sources</a></h2>
+ *
+ * When <em>all</em> memory segments associated with a given memory source have been closed explicitly
+ * (see {@link MemorySegment#close()}), or, alternatively, when all said segments are deemed <em>unreacheable</em> <em>and</em>
+ * the memory source has been registered against a cleaner (see {@link MemorySource#registerCleaner()}), the memory source
+ * is <em>released</em>; this has different meanings depending on the kind of memory source being considered:
+ * <ul>
+ *     <li>releasing a native memory source results in <em>freeing</em> the native memory associated with it</li>
+ *     <li>releasing a mapped memory source results in the backing memory-mapped file to be unmapped</li>
+ *     <li>releasing a heap memory source does not have any side-effect; since heap memory sources might keep
+ *     strong references to the original heap-based object, it is the responsibility of clients to ensure that
+ *     all segments referring to the released heap source are discarded in a timely manner, so as not to prevent garbage
+ *     collection to reclaim the underlying objects.</li>
+ * </ul>
+ *
+ * @apiNote In the future, if the Java language permits, {@link MemorySource}
+ * may become a {@code sealed} interface, which would prohibit subclassing except by
+ * explicitly permitted types.
+ */
+public interface MemorySource {
+    /**
+     * Has this memory source been released?
+     * @return {@code true}, if this memory source been released.
+     */
+    boolean isReleased();
+
+    /**
+     * Register this memory source against a {@link java.lang.ref.Cleaner}; this means that when all memory segments
+     * backed by this memory sources become unreacheable, this memory source will be automatically released.
+     */
+    void registerCleaner();
+
+    /**
+     * Obtains the size (in bytes) of this memory source.
+     * @return the size (in bytes) of this memory source.
+     */
+    long byteSize();
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
@@ -57,14 +57,13 @@
  * memory access var handles, e.g. using <a href="MemoryLayout.html#layout-paths"><em>layout paths</em></a>.
  *
  * <h2><a id="deallocation"></a>Deterministic deallocation</h2>
  *
  * When writing code that manipulates memory segments, especially if backed by memory which resides outside the Java heap, it is
- * crucial that the resources associated with a memory segment are released when the segment is no longer in use, by calling the {@link jdk.incubator.foreign.MemorySegment#close()}
- * method either explicitly, or implicitly, by relying on try-with-resources construct (as demonstrated in the example above).
- * Closing a given memory segment is an <em>atomic</em> operation which can either succeed - and result in the underlying
- * memory associated with the segment to be released, or <em>fail</em> with an exception.
+ * crucial that the memory source associated with a memory segment is <a href="MemorySource.html#releasing-sources">released</a>
+ * when the segment is no longer in use; this is achieved by calling the {@link jdk.incubator.foreign.MemorySegment#close()} method,
+ * either explicitly, or implicitly, by relying on try-with-resources construct (as demonstrated in the example above).
  * <p>
  * The deterministic deallocation model differs significantly from the implicit strategies adopted within other APIs, most
  * notably the {@link java.nio.ByteBuffer} API: in that case, when a native byte buffer is created (see {@link java.nio.ByteBuffer#allocateDirect(int)}),
  * the underlying memory is not released until the byte buffer reference becomes <em>unreachable</em>. While implicit deallocation
  * models such as this can be very convenient - clients do not have to remember to <em>close</em> a direct buffer - such models can also make it
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -83,11 +83,11 @@
     public void checkAccess(long offset, long length, boolean readOnly) {
         segment.checkRange(MemoryAddressProxy.addOffsets(this.offset, offset, this), length, !readOnly);
     }
 
     public long unsafeGetOffset() {
-        return segment.min + offset;
+        return segment.addr() + segment.min + offset;
     }
 
     public Object unsafeGetBase() {
         return segment.base();
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
@@ -24,96 +24,23 @@
  *
  */
 
 package jdk.internal.foreign;
 
-import java.lang.invoke.MethodHandles;
-import java.lang.invoke.VarHandle;
-
 /**
  * This class manages the temporal bounds associated with a memory segment. A scope has a liveness bit, which is updated
- * when the scope is closed (this operation is triggered by {@link MemorySegmentImpl#close()}). Furthermore, a scope is
- * associated with an <em>atomic</em> counter which can be incremented (upon calling the {@link #acquire()} method),
- * and is decremented (when a previously acquired segment is later closed).
+ * when the scope is closed (this operation is triggered by {@link MemorySegmentImpl#close()}).
  */
-public final class MemoryScope {
-
-    //reference to keep hold onto
-    final Object ref;
-
-    int activeCount = UNACQUIRED;
-
-    final static VarHandle COUNT_HANDLE;
-
-    static {
-        try {
-            COUNT_HANDLE = MethodHandles.lookup().findVarHandle(MemoryScope.class, "activeCount", int.class);
-        } catch (Throwable ex) {
-            throw new ExceptionInInitializerError(ex);
-        }
-    }
-
-    final static int UNACQUIRED = 0;
-    final static int CLOSED = -1;
-    final static int MAX_ACQUIRE = Integer.MAX_VALUE;
+public class MemoryScope {
 
-    final Runnable cleanupAction;
+    boolean isAlive = true;
 
-    public MemoryScope(Object ref, Runnable cleanupAction) {
-        this.ref = ref;
-        this.cleanupAction = cleanupAction;
-    }
-
-    /**
-     * This method performs a full, thread-safe liveness check; can be used outside confinement thread.
-     */
-    final boolean isAliveThreadSafe() {
-        return ((int)COUNT_HANDLE.getVolatile(this)) != CLOSED;
-    }
-
-    /**
-     * This method performs a quick liveness check; must be called from the confinement thread.
-     */
-    final void checkAliveConfined() {
-        if (activeCount == CLOSED) {
-            throw new IllegalStateException("Segment is not alive");
-        }
-    }
-
-    MemoryScope acquire() {
-        int value;
-        do {
-            value = (int)COUNT_HANDLE.getVolatile(this);
-            if (value == CLOSED) {
-                //segment is not alive!
-                throw new IllegalStateException("Segment is not alive");
-            } else if (value == MAX_ACQUIRE) {
-                //overflow
-                throw new IllegalStateException("Segment acquire limit exceeded");
-            }
-        } while (!COUNT_HANDLE.compareAndSet(this, value, value + 1));
-        return new MemoryScope(ref, this::release);
-    }
+    final MemorySourceImpl source;
 
-    private void release() {
-        int value;
-        do {
-            value = (int)COUNT_HANDLE.getVolatile(this);
-            if (value <= UNACQUIRED) {
-                //cannot get here - we can't close segment twice
-                throw new IllegalStateException();
-            }
-        } while (!COUNT_HANDLE.compareAndSet(this, value, value - 1));
+    public MemoryScope(MemorySourceImpl source) {
+        this.source = source;
     }
 
-    void close() {
-        if (!COUNT_HANDLE.compareAndSet(this, UNACQUIRED, CLOSED)) {
-            //first check if already closed...
-            checkAliveConfined();
-            //...if not, then we have acquired views that are still active
-            throw new IllegalStateException("Cannot close a segment that has active acquired views");
-        }
-        if (cleanupAction != null) {
-            cleanupAction.run();
-        }
+    public void close() {
+        isAlive = false;
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
@@ -26,17 +26,20 @@
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySource;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.MemorySegmentProxy;
+import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.vm.annotation.ForceInline;
 
 import java.nio.ByteBuffer;
+import java.nio.MappedByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
 import java.util.Random;
 
@@ -54,11 +57,10 @@
     private static final int BYTE_ARR_BASE = UNSAFE.arrayBaseOffset(byte[].class);
 
     final long length;
     final int mask;
     final long min;
-    final Object base;
     final Thread owner;
     final MemoryScope scope;
 
     final static int ACCESS_MASK = READ | WRITE | CLOSE | ACQUIRE;
     final static int FIRST_RESERVED_FLAG = 1 << 16; // upper 16 bits are reserved
@@ -66,37 +68,36 @@
 
     final static long NONCE = new Random().nextLong();
 
     final static int DEFAULT_MASK = READ | WRITE | CLOSE | ACQUIRE;
 
-    public MemorySegmentImpl(long min, Object base, long length, Thread owner, MemoryScope scope) {
-        this(min, base, length, DEFAULT_MASK, owner, scope);
+    public MemorySegmentImpl(long min, long length, Thread owner, MemoryScope scope) {
+        this(min, length, DEFAULT_MASK, owner, scope);
     }
 
-    private MemorySegmentImpl(long min, Object base, long length, int mask, Thread owner, MemoryScope scope) {
+    private MemorySegmentImpl(long min, long length, int mask, Thread owner, MemoryScope scope) {
         this.length = length;
         this.mask = length > Integer.MAX_VALUE ? mask : (mask | SMALL);
         this.min = min;
-        this.base = base;
         this.owner = owner;
         this.scope = scope;
     }
 
     // MemorySegment methods
 
     @Override
     public final MemorySegmentImpl asSlice(long offset, long newSize) {
         checkBounds(offset, newSize);
-        return new MemorySegmentImpl(min + offset, base, newSize, mask, owner, scope);
+        return new MemorySegmentImpl(min + offset, newSize, mask, owner, scope);
     }
 
     @Override
     public MemorySegment acquire() {
         if (!isSet(ACQUIRE)) {
             throw unsupportedAccessMode(ACQUIRE);
         }
-        return new MemorySegmentImpl(min, base, length, mask, Thread.currentThread(), scope.acquire());
+        return new MemorySegmentImpl(min, length, mask, Thread.currentThread(), scope.source.acquire());
     }
 
     @Override
     @ForceInline
     public final MemoryAddress baseAddress() {
@@ -108,11 +109,16 @@
         return length;
     }
 
     @Override
     public final boolean isAlive() {
-        return scope.isAliveThreadSafe();
+        return scope.isAlive;
+    }
+
+    @Override
+    public MemorySource source() {
+        return scope.source;
     }
 
     @Override
     public Thread ownerThread() {
         return owner;
@@ -138,12 +144,14 @@
         if (base() != null) {
             if (!(base() instanceof byte[])) {
                 throw new UnsupportedOperationException("Not an address to an heap-allocated byte array");
             }
             _bb = nioAccess.newHeapByteBuffer((byte[]) base(), (int)min - BYTE_ARR_BASE, (int) length, this);
+        } else if (unmapper() != null) {
+            _bb = nioAccess.newMappedByteBuffer(unmapper(), addr() + min, (int) length, null, this);
         } else {
-            _bb = nioAccess.newDirectByteBuffer(min, (int) length, null, this);
+            _bb = nioAccess.newDirectByteBuffer(addr() + min, (int) length, null, this);
         }
         if (!isSet(WRITE)) {
             //scope is IMMUTABLE - obtain a RO byte buffer
             _bb = _bb.asReadOnlyBuffer();
         }
@@ -154,11 +162,11 @@
     public MemorySegment withAccessModes(int accessModes) {
         checkAccessModes(accessModes);
         if ((~accessModes() & accessModes) != 0) {
             throw new UnsupportedOperationException("Cannot acquire more access modes");
         }
-        return new MemorySegmentImpl(min, base, length, accessModes, owner, scope);
+        return new MemorySegmentImpl(min, length, accessModes, owner, scope);
     }
 
     @Override
     public boolean hasAccessModes(int accessModes) {
         checkAccessModes(accessModes);
@@ -190,11 +198,13 @@
     @Override
     public final void checkValidState() {
         if (owner != Thread.currentThread()) {
             throw new IllegalStateException("Attempt to access segment outside owning thread");
         }
-        scope.checkAliveConfined();
+        if (!scope.isAlive) {
+            throw new IllegalStateException("Scope is not alive");
+        }
     }
 
     boolean isSmall() {
         return isSet(SMALL);
     }
@@ -216,12 +226,20 @@
             throw unsupportedAccessMode(READ);
         }
         checkBounds(offset, length);
     }
 
+    long addr() {
+        return scope.source.unsafeAddress();
+    }
+
+    UnmapperProxy unmapper() {
+        return scope.source.unmapper();
+    }
+
     Object base() {
-        return base;
+        return scope.source.unsafeBase();
     }
 
     private boolean isSet(int mask) {
         return (this.mask & mask) != 0;
     }
@@ -280,9 +298,9 @@
                         this, offset, length));
     }
 
     private int id() {
         //compute a stable and random id for this memory segment
-        return Math.abs(Objects.hash(base, min, NONCE));
+        return Math.abs(Objects.hash(scope.source.unsafeBase(), min, NONCE));
     }
 
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySourceImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySourceImpl.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySourceImpl.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.foreign;
+
+import jdk.incubator.foreign.MappedMemorySource;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySource;
+import jdk.internal.access.foreign.UnmapperProxy;
+import jdk.internal.ref.CleanerFactory;
+import jdk.internal.ref.PhantomCleanable;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+import java.nio.MappedByteBuffer;
+import java.nio.file.Path;
+import java.util.Optional;
+
+/**
+ * Implementation of a memory source. A memory source acts as a shared, <am>atomic</am> reference counter for all the memory segments
+ * which are derived from it. The counter can be incremented (upon calling the {@link #acquire()} method),
+ * and is decremented (when a previously acquired memory scope is later closed).
+ */
+public abstract class MemorySourceImpl implements MemorySource {
+
+    //reference to keep hold onto
+    final Object ref;
+    final long size;
+    volatile PhantomCleanable<?> cleaneable;
+
+    int activeCount = UNACQUIRED;
+
+    final static VarHandle COUNT_HANDLE;
+
+    static {
+        try {
+            COUNT_HANDLE = MethodHandles.lookup().findVarHandle(MemorySourceImpl.class, "activeCount", int.class);
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
+    final static int UNACQUIRED = 0;
+    final static int RELEASED = -1;
+    final static int MAX_ACQUIRE = Integer.MAX_VALUE;
+
+    final Runnable cleanupAction;
+
+    public MemorySourceImpl(long size, Object ref, Runnable cleanupAction) {
+        this.size = size;
+        this.ref = ref;
+        this.cleanupAction = cleanupAction;
+    }
+
+    Object unsafeBase() {
+        return null;
+    }
+
+    long unsafeAddress() {
+        return 0L;
+    }
+
+    UnmapperProxy unmapper() {
+        return null;
+    }
+
+    @Override
+    public long byteSize() {
+        return size;
+    }
+
+    @Override
+    public void registerCleaner() {
+        if (cleanupAction != null) {
+            MemoryScope scope = acquire();
+            try {
+                //Note: if we are here nobody else could be attempting to call the cleanupAction in release()
+                synchronized (this) {
+                    if (cleaneable == null) {
+                        cleaneable = (PhantomCleanable<?>) CleanerFactory.cleaner().register(this, cleanupAction);
+                    }
+                }
+            } finally {
+                scope.close();
+            }
+        }
+    }
+
+    /**
+     * This method performs a full, thread-safe liveness check; can be used outside confinement thread.
+     */
+
+    @Override
+    public boolean isReleased() {
+        return ((int)COUNT_HANDLE.getVolatile(this)) == RELEASED;
+    }
+
+    public MemoryScope acquire() {
+        int value;
+        do {
+            value = (int)COUNT_HANDLE.getVolatile(this);
+            if (value == RELEASED) {
+                //segment is not alive!
+                throw new IllegalStateException("Segment is not alive");
+            } else if (value == MAX_ACQUIRE) {
+                //overflow
+                throw new IllegalStateException("Segment acquire limit exceeded");
+            }
+        } while (!COUNT_HANDLE.compareAndSet(this, value, value + 1));
+        return new MemoryScope(this) {
+            @Override
+            public void close() {
+                super.close();
+                source.release();
+            }
+        };
+    }
+
+    void release() {
+        int value;
+        do {
+            value = (int)COUNT_HANDLE.getVolatile(this);
+            if (value <= UNACQUIRED) {
+                //cannot get here - we can't close segment twice
+                throw new IllegalStateException();
+            }
+        } while (!COUNT_HANDLE.compareAndSet(this, value, value - 1));
+        //auto-close
+        if ((boolean)COUNT_HANDLE.compareAndSet(this, UNACQUIRED, RELEASED)) {
+            // Note: if we are here it means that nobody else could be in the middle of a registerCleaner
+            if (cleanupAction != null) {
+                cleanupAction.run();
+                if (cleaneable != null) {
+                    // if we are here, we are explicitly releasing (e.g. close()), so we need to unregister the cleaneable
+                    cleaneable.clear();
+                }
+            }
+        }
+    }
+
+    public static class OfHeap extends MemorySourceImpl {
+
+        final Object base;
+
+        public OfHeap(long size, Object base, Object ref, Runnable cleanupAction) {
+            super(size, ref, cleanupAction);
+            this.base = base;
+        }
+
+        @Override
+        Object unsafeBase() {
+            return base;
+        }
+    }
+
+    public static class OfNative extends MemorySourceImpl {
+
+        final long addr;
+
+        public OfNative(long addr, long size, Object ref, Runnable cleanupAction) {
+            super(size, ref, cleanupAction);
+            this.addr = addr;
+        }
+
+        @Override
+        long unsafeAddress() {
+            return addr;
+        }
+    }
+
+    public static class OfMapped extends MemorySourceImpl implements MappedMemorySource {
+
+        final UnmapperProxy unmapperProxy;
+
+        public OfMapped(UnmapperProxy unmapperProxy, long size, Object ref, Runnable cleanupAction) {
+            super(size, ref, cleanupAction);
+            this.unmapperProxy = unmapperProxy;
+        }
+
+        @Override
+        long unsafeAddress() {
+            return unmapperProxy.address();
+        }
+
+        @Override
+        public void force() {
+            try (MemorySegment segment = new MemorySegmentImpl(0L, size, Thread.currentThread(), acquire())) {
+                force(segment);
+            }
+        }
+
+        @Override
+        public void force(MemorySegment segment) {
+            if (segment.source() instanceof MappedMemorySource) {
+                ((MappedByteBuffer)segment.asByteBuffer()).force();
+            } else {
+                throw new IllegalArgumentException("Not a mapped memory segment");
+            }
+        }
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -26,10 +26,11 @@
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemorySource;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.MemoryAddressProxy;
 import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
@@ -40,10 +41,11 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteBuffer;
+import java.nio.MappedByteBuffer;
 import java.nio.channels.FileChannel;
 import java.nio.file.OpenOption;
 import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
 import java.util.function.Supplier;
@@ -98,12 +100,12 @@
         long buf = unsafe.allocateMemory(alignedSize);
         if (!skipZeroMemory) {
             unsafe.setMemory(buf, alignedSize, (byte)0);
         }
         long alignedBuf = Utils.alignUp(buf, alignmentBytes);
-        MemoryScope scope = new MemoryScope(null, () -> unsafe.freeMemory(buf));
-        MemorySegment segment = new MemorySegmentImpl(buf, null, alignedSize, Thread.currentThread(), scope);
+        MemorySourceImpl source = new MemorySourceImpl.OfNative(buf, alignedSize, null, () -> unsafe.freeMemory(buf));
+        MemorySegment segment = new MemorySegmentImpl(0, alignedSize, Thread.currentThread(), source.acquire());
         if (alignedBuf != buf) {
             long delta = alignedBuf - buf;
             segment = segment.asSlice(delta, bytesSize);
         }
         return segment;
@@ -136,32 +138,41 @@
     public static MemorySegment makeArraySegment(double[] arr) {
         return makeArraySegment(arr, arr.length, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE);
     }
 
     private static MemorySegment makeArraySegment(Object arr, int size, int base, int scale) {
-        MemoryScope scope = new MemoryScope(null, null);
-        return new MemorySegmentImpl(base, arr, size * scale, Thread.currentThread(), scope);
+        MemorySourceImpl source = new MemorySourceImpl.OfHeap(size, arr, null, null);
+        return new MemorySegmentImpl(base,  size * scale, Thread.currentThread(), source.acquire());
     }
 
     public static MemorySegment makeBufferSegment(ByteBuffer bb) {
-        long bbAddress = javaNioAccess.getBufferAddress(bb);
-        Object base = javaNioAccess.getBufferBase(bb);
-
         int pos = bb.position();
         int limit = bb.limit();
-
-        MemoryScope bufferScope = new MemoryScope(bb, null);
-        return new MemorySegmentImpl(bbAddress + pos, base, limit - pos, Thread.currentThread(), bufferScope);
+        int cap = bb.capacity();
+        long bbAddress = javaNioAccess.getBufferAddress(bb);
+        Object base = javaNioAccess.getBufferBase(bb);
+        UnmapperProxy unmapper = javaNioAccess.unmapper(bb);
+
+        if (unmapper != null) {
+            MemorySourceImpl source = new MemorySourceImpl.OfMapped(unmapper, cap, bb, null);
+            return new MemorySegmentImpl(pos, limit - pos, Thread.currentThread(), source.acquire());
+        } else if (base == null) {
+            MemorySourceImpl source = new MemorySourceImpl.OfNative(bbAddress, cap, bb, null);
+            return new MemorySegmentImpl(pos, limit - pos, Thread.currentThread(), source.acquire());
+        } else {
+            MemorySourceImpl source = new MemorySourceImpl.OfHeap(cap, base, bb, null);
+            return new MemorySegmentImpl(bbAddress + pos, limit - pos, Thread.currentThread(), source.acquire());
+        }
     }
 
     // create and map a file into a fresh segment
     public static MemorySegment makeMappedSegment(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
         if (bytesSize <= 0) throw new IllegalArgumentException("Requested bytes size must be > 0.");
         try (FileChannelImpl channelImpl = (FileChannelImpl)FileChannel.open(path, openOptions(mapMode))) {
             UnmapperProxy unmapperProxy = channelImpl.mapInternal(mapMode, 0L, bytesSize);
-            MemoryScope scope = new MemoryScope(null, unmapperProxy::unmap);
-            return new MemorySegmentImpl(unmapperProxy.address(), null, bytesSize, Thread.currentThread(), scope);
+            MemorySourceImpl source = new MemorySourceImpl.OfMapped(unmapperProxy, bytesSize, null, unmapperProxy::unmap);
+            return new MemorySegmentImpl(0L, bytesSize, Thread.currentThread(), source.acquire());
         }
     }
 
     private static OpenOption[] openOptions(FileChannel.MapMode mapMode) {
         if (mapMode == FileChannel.MapMode.READ_ONLY) {
diff a/test/failure_handler/src/share/conf/linux.properties b/test/failure_handler/src/share/conf/linux.properties
--- a/test/failure_handler/src/share/conf/linux.properties
+++ b/test/failure_handler/src/share/conf/linux.properties
@@ -66,12 +66,12 @@
   process.top process.ps \
   memory.free memory.vmstat.default memory.vmstat.statistics \
         memory.vmstat.slabinfo memory.vmstat.disk \
   files \
   locks \
-  net.sockets net.statistics net.ifconfig \
-  screenshot
+  net.sockets net.statistics net.ifconfig
+#  screenshot
 ################################################################################
 users.current.app=id
 users.current.args=-a
 users.logged.app=who
 users.logged.args=-a
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -29,10 +29,11 @@
  *          jdk.incubator.foreign/jdk.internal.foreign
  * @run testng TestByteBuffer
  */
 
 
+import jdk.incubator.foreign.MappedMemorySource;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
@@ -225,10 +226,11 @@
 
         //write to channel
         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
             MemoryAddress base = segment.baseAddress();
             initTuples(base);
+            ((MappedMemorySource)segment.source()).force();
         }
 
         //read from channel
         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
             MemoryAddress base = segment.baseAddress();
diff a/test/jdk/java/foreign/TestCleaner.java b/test/jdk/java/foreign/TestCleaner.java
--- /dev/null
+++ b/test/jdk/java/foreign/TestCleaner.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @modules jdk.incubator.foreign/jdk.internal.foreign
+ */
+
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.foreign.MemorySegmentImpl;
+import jdk.internal.foreign.MemorySourceImpl;
+
+public class TestCleaner {
+
+    boolean isDone = false;
+
+    public static void main(String[] args) {
+        new TestCleaner().test();
+    }
+
+    void test() {
+        MemorySegment segment = makeSegment();
+        segment.source().registerCleaner();
+        for (int i = 0 ; i < 1000 ; i++) {
+            segment.acquire();
+        }
+        segment = null;
+        while (!checkDone()) {
+            byte[] b = new byte[100];
+            System.gc();
+            try {
+                Thread.sleep(10);
+            } catch (InterruptedException ex) {
+                throw new AssertionError(ex);
+            }
+        }
+    }
+
+    MemorySegment makeSegment() {
+        MemorySourceImpl memorySource = new MemorySourceImpl.OfHeap(0, null, null, this::done);
+        return new MemorySegmentImpl(0, 0, Thread.currentThread(), memorySource.acquire());
+    }
+
+    synchronized void done() {
+        isDone = true;
+    }
+
+    synchronized boolean checkDone() {
+        return isDone;
+    }
+}
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -41,10 +41,11 @@
 
     static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
 
     @Test
     public void testShared() throws Throwable {
+        MemorySegment closedSegment;
         try (MemorySegment s = MemorySegment.allocateNative(4)) {
             setInt(s, 42);
             assertEquals(getInt(s), 42);
             List<Thread> threads = new ArrayList<>();
             for (int i = 0 ; i < 1000 ; i++) {
@@ -60,18 +61,23 @@
                     t.join();
                 } catch (Throwable e) {
                     throw new IllegalStateException(e);
                 }
             });
+            closedSegment = s;
         }
+        assertTrue(closedSegment.source().isReleased());
     }
 
-    @Test(expectedExceptions=IllegalStateException.class)
-    public void testBadCloseWithPendingAcquire() {
-        try (MemorySegment segment = MemorySegment.allocateNative(8)) {
-            segment.acquire();
-        } //should fail here!
+    @Test
+    public void testCloseWithPendingAcquire() {
+        MemorySegment segment = MemorySegment.allocateNative(8);
+        MemorySegment acquired = segment.acquire();
+        segment.close();
+        assertFalse(segment.source().isReleased());
+        acquired.close();
+        assertTrue(segment.source().isReleased());
     }
 
     static int getInt(MemorySegment handle) {
         return (int)intHandle.getVolatile(handle.baseAddress());
     }

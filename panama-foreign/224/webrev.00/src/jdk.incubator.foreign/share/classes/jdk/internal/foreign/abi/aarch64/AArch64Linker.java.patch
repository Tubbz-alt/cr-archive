diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64Linker.java
@@ -1,8 +1,8 @@
 /*
  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Arm Limited. All rights reserved.
+ * Copyright (c) 2019, 2020, Arm Limited. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,19 +23,23 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi.aarch64;
 
+import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.foreign.abi.SharedUtils;
 import jdk.internal.foreign.abi.UpcallStubs;
 
 import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
+import java.util.function.Consumer;
 
 import static jdk.incubator.foreign.CSupport.*;
 
 /**
  * ABI implementation based on ARM document "Procedure Call Standard for
@@ -44,24 +48,43 @@
 public class AArch64Linker implements ForeignLinker {
     private static AArch64Linker instance;
 
     static final long ADDRESS_SIZE = 64; // bits
 
+    private static final MethodHandle MH_unboxVaList;
+    private static final MethodHandle MH_boxVaList;
+
+    static {
+        try {
+            MethodHandles.Lookup lookup = MethodHandles.lookup();
+            MH_unboxVaList = lookup.findVirtual(CSupport.VaList.class, "address",
+                MethodType.methodType(MemoryAddress.class));
+            MH_boxVaList = lookup.findStatic(AArch64Linker.class, "newVaListOfAddress",
+                MethodType.methodType(VaList.class, MemoryAddress.class));
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
     public static AArch64Linker getInstance() {
         if (instance == null) {
             instance = new AArch64Linker();
         }
         return instance;
     }
 
     @Override
     public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        return CallArranger.arrangeDowncall(symbol, type, function);
+        MethodType llMt = SharedUtils.convertVaListCarriers(type, AArch64VaList.CARRIER);
+        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);
+        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);
+        return handle;
     }
 
     @Override
     public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {
+        target = SharedUtils.boxVaLists(target, MH_boxVaList);
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
     }
 
     @Override
     public String name() {
@@ -69,6 +92,21 @@
     }
 
     static AArch64.ArgumentClass argumentClassFor(MemoryLayout layout) {
         return (AArch64.ArgumentClass)layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get();
     }
+
+    public static VaList newVaList(Consumer<VaList.Builder> actions) {
+        AArch64VaList.Builder builder = AArch64VaList.builder();
+        actions.accept(builder);
+        return builder.build();
+    }
+
+    public static VaList newVaListOfAddress(MemoryAddress ma) {
+        return AArch64VaList.ofAddress(ma);
+    }
+
+    public static VaList emptyVaList() {
+        return AArch64VaList.empty();
+    }
+
 }

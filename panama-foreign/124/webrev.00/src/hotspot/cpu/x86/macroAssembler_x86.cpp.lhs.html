<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/accessDecorators.hpp&quot;
  37 #include &quot;oops/compressedOops.inline.hpp&quot;
  38 #include &quot;oops/klass.inline.hpp&quot;
  39 #include &quot;prims/methodHandles.hpp&quot;
  40 #include &quot;runtime/biasedLocking.hpp&quot;
  41 #include &quot;runtime/flags/flagSetting.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/stubRoutines.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 #include &quot;crc32c.h&quot;
  52 
  53 #ifdef PRODUCT
  54 #define BLOCK_COMMENT(str) /* nothing */
  55 #define STOP(error) stop(error)
  56 #else
  57 #define BLOCK_COMMENT(str) block_comment(str)
  58 #define STOP(error) block_comment(error); stop(error)
  59 #endif
  60 
  61 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  62 
  63 #ifdef ASSERT
  64 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
  65 #endif
  66 
  67 static Assembler::Condition reverse[] = {
  68     Assembler::noOverflow     /* overflow      = 0x0 */ ,
  69     Assembler::overflow       /* noOverflow    = 0x1 */ ,
  70     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
  71     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
  72     Assembler::notZero        /* zero          = 0x4, equal         = 0x4 */ ,
  73     Assembler::zero           /* notZero       = 0x5, notEqual      = 0x5 */ ,
  74     Assembler::above          /* belowEqual    = 0x6 */ ,
  75     Assembler::belowEqual     /* above         = 0x7 */ ,
  76     Assembler::positive       /* negative      = 0x8 */ ,
  77     Assembler::negative       /* positive      = 0x9 */ ,
  78     Assembler::noParity       /* parity        = 0xa */ ,
  79     Assembler::parity         /* noParity      = 0xb */ ,
  80     Assembler::greaterEqual   /* less          = 0xc */ ,
  81     Assembler::less           /* greaterEqual  = 0xd */ ,
  82     Assembler::greater        /* lessEqual     = 0xe */ ,
  83     Assembler::lessEqual      /* greater       = 0xf, */
  84 
  85 };
  86 
  87 
  88 // Implementation of MacroAssembler
  89 
  90 // First all the versions that have distinct versions depending on 32/64 bit
  91 // Unless the difference is trivial (1 line or so).
  92 
  93 #ifndef _LP64
  94 
  95 // 32bit versions
  96 
  97 Address MacroAssembler::as_Address(AddressLiteral adr) {
  98   return Address(adr.target(), adr.rspec());
  99 }
 100 
 101 Address MacroAssembler::as_Address(ArrayAddress adr) {
 102   return Address::make_array(adr);
 103 }
 104 
 105 void MacroAssembler::call_VM_leaf_base(address entry_point,
 106                                        int number_of_arguments) {
 107   call(RuntimeAddress(entry_point));
 108   increment(rsp, number_of_arguments * wordSize);
 109 }
 110 
 111 void MacroAssembler::cmpklass(Address src1, Metadata* obj) {
 112   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 113 }
 114 
 115 void MacroAssembler::cmpklass(Register src1, Metadata* obj) {
 116   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 117 }
 118 
 119 void MacroAssembler::cmpoop_raw(Address src1, jobject obj) {
 120   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 121 }
 122 
 123 void MacroAssembler::cmpoop_raw(Register src1, jobject obj) {
 124   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 125 }
 126 
 127 void MacroAssembler::cmpoop(Address src1, jobject obj) {
 128   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 129   bs-&gt;obj_equals(this, src1, obj);
 130 }
 131 
 132 void MacroAssembler::cmpoop(Register src1, jobject obj) {
 133   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 134   bs-&gt;obj_equals(this, src1, obj);
 135 }
 136 
 137 void MacroAssembler::extend_sign(Register hi, Register lo) {
 138   // According to Intel Doc. AP-526, &quot;Integer Divide&quot;, p.18.
 139   if (VM_Version::is_P6() &amp;&amp; hi == rdx &amp;&amp; lo == rax) {
 140     cdql();
 141   } else {
 142     movl(hi, lo);
 143     sarl(hi, 31);
 144   }
 145 }
 146 
 147 void MacroAssembler::jC2(Register tmp, Label&amp; L) {
 148   // set parity bit if FPU flag C2 is set (via rax)
 149   save_rax(tmp);
 150   fwait(); fnstsw_ax();
 151   sahf();
 152   restore_rax(tmp);
 153   // branch
 154   jcc(Assembler::parity, L);
 155 }
 156 
 157 void MacroAssembler::jnC2(Register tmp, Label&amp; L) {
 158   // set parity bit if FPU flag C2 is set (via rax)
 159   save_rax(tmp);
 160   fwait(); fnstsw_ax();
 161   sahf();
 162   restore_rax(tmp);
 163   // branch
 164   jcc(Assembler::noParity, L);
 165 }
 166 
 167 // 32bit can do a case table jump in one instruction but we no longer allow the base
 168 // to be installed in the Address class
 169 void MacroAssembler::jump(ArrayAddress entry) {
 170   jmp(as_Address(entry));
 171 }
 172 
 173 // Note: y_lo will be destroyed
 174 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 175   // Long compare for Java (semantics as described in JVM spec.)
 176   Label high, low, done;
 177 
 178   cmpl(x_hi, y_hi);
 179   jcc(Assembler::less, low);
 180   jcc(Assembler::greater, high);
 181   // x_hi is the return register
 182   xorl(x_hi, x_hi);
 183   cmpl(x_lo, y_lo);
 184   jcc(Assembler::below, low);
 185   jcc(Assembler::equal, done);
 186 
 187   bind(high);
 188   xorl(x_hi, x_hi);
 189   increment(x_hi);
 190   jmp(done);
 191 
 192   bind(low);
 193   xorl(x_hi, x_hi);
 194   decrementl(x_hi);
 195 
 196   bind(done);
 197 }
 198 
 199 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 200     mov_literal32(dst, (int32_t)src.target(), src.rspec());
 201 }
 202 
 203 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 204   // leal(dst, as_Address(adr));
 205   // see note in movl as to why we must use a move
 206   mov_literal32(dst, (int32_t) adr.target(), adr.rspec());
 207 }
 208 
 209 void MacroAssembler::leave() {
 210   mov(rsp, rbp);
 211   pop(rbp);
 212 }
 213 
 214 void MacroAssembler::lmul(int x_rsp_offset, int y_rsp_offset) {
 215   // Multiplication of two Java long values stored on the stack
 216   // as illustrated below. Result is in rdx:rax.
 217   //
 218   // rsp ---&gt; [  ??  ] \               \
 219   //            ....    | y_rsp_offset  |
 220   //          [ y_lo ] /  (in bytes)    | x_rsp_offset
 221   //          [ y_hi ]                  | (in bytes)
 222   //            ....                    |
 223   //          [ x_lo ]                 /
 224   //          [ x_hi ]
 225   //            ....
 226   //
 227   // Basic idea: lo(result) = lo(x_lo * y_lo)
 228   //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 229   Address x_hi(rsp, x_rsp_offset + wordSize); Address x_lo(rsp, x_rsp_offset);
 230   Address y_hi(rsp, y_rsp_offset + wordSize); Address y_lo(rsp, y_rsp_offset);
 231   Label quick;
 232   // load x_hi, y_hi and check if quick
 233   // multiplication is possible
 234   movl(rbx, x_hi);
 235   movl(rcx, y_hi);
 236   movl(rax, rbx);
 237   orl(rbx, rcx);                                 // rbx, = 0 &lt;=&gt; x_hi = 0 and y_hi = 0
 238   jcc(Assembler::zero, quick);                   // if rbx, = 0 do quick multiply
 239   // do full multiplication
 240   // 1st step
 241   mull(y_lo);                                    // x_hi * y_lo
 242   movl(rbx, rax);                                // save lo(x_hi * y_lo) in rbx,
 243   // 2nd step
 244   movl(rax, x_lo);
 245   mull(rcx);                                     // x_lo * y_hi
 246   addl(rbx, rax);                                // add lo(x_lo * y_hi) to rbx,
 247   // 3rd step
 248   bind(quick);                                   // note: rbx, = 0 if quick multiply!
 249   movl(rax, x_lo);
 250   mull(y_lo);                                    // x_lo * y_lo
 251   addl(rdx, rbx);                                // correct hi(x_lo * y_lo)
 252 }
 253 
 254 void MacroAssembler::lneg(Register hi, Register lo) {
 255   negl(lo);
 256   adcl(hi, 0);
 257   negl(hi);
 258 }
 259 
 260 void MacroAssembler::lshl(Register hi, Register lo) {
 261   // Java shift left long support (semantics as described in JVM spec., p.305)
 262   // (basic idea for shift counts s &gt;= n: x &lt;&lt; s == (x &lt;&lt; n) &lt;&lt; (s - n))
 263   // shift value is in rcx !
 264   assert(hi != rcx, &quot;must not use rcx&quot;);
 265   assert(lo != rcx, &quot;must not use rcx&quot;);
 266   const Register s = rcx;                        // shift count
 267   const int      n = BitsPerWord;
 268   Label L;
 269   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 270   cmpl(s, n);                                    // if (s &lt; n)
 271   jcc(Assembler::less, L);                       // else (s &gt;= n)
 272   movl(hi, lo);                                  // x := x &lt;&lt; n
 273   xorl(lo, lo);
 274   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 275   bind(L);                                       // s (mod n) &lt; n
 276   shldl(hi, lo);                                 // x := x &lt;&lt; s
 277   shll(lo);
 278 }
 279 
 280 
 281 void MacroAssembler::lshr(Register hi, Register lo, bool sign_extension) {
 282   // Java shift right long support (semantics as described in JVM spec., p.306 &amp; p.310)
 283   // (basic idea for shift counts s &gt;= n: x &gt;&gt; s == (x &gt;&gt; n) &gt;&gt; (s - n))
 284   assert(hi != rcx, &quot;must not use rcx&quot;);
 285   assert(lo != rcx, &quot;must not use rcx&quot;);
 286   const Register s = rcx;                        // shift count
 287   const int      n = BitsPerWord;
 288   Label L;
 289   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 290   cmpl(s, n);                                    // if (s &lt; n)
 291   jcc(Assembler::less, L);                       // else (s &gt;= n)
 292   movl(lo, hi);                                  // x := x &gt;&gt; n
 293   if (sign_extension) sarl(hi, 31);
 294   else                xorl(hi, hi);
 295   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 296   bind(L);                                       // s (mod n) &lt; n
 297   shrdl(lo, hi);                                 // x := x &gt;&gt; s
 298   if (sign_extension) sarl(hi);
 299   else                shrl(hi);
 300 }
 301 
 302 void MacroAssembler::movoop(Register dst, jobject obj) {
 303   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 304 }
 305 
 306 void MacroAssembler::movoop(Address dst, jobject obj) {
 307   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 308 }
 309 
 310 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 311   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 312 }
 313 
 314 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 315   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 316 }
 317 
 318 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 319   // scratch register is not used,
 320   // it is defined to match parameters of 64-bit version of this method.
 321   if (src.is_lval()) {
 322     mov_literal32(dst, (intptr_t)src.target(), src.rspec());
 323   } else {
 324     movl(dst, as_Address(src));
 325   }
 326 }
 327 
 328 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 329   movl(as_Address(dst), src);
 330 }
 331 
 332 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 333   movl(dst, as_Address(src));
 334 }
 335 
 336 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 337 void MacroAssembler::movptr(Address dst, intptr_t src) {
 338   movl(dst, src);
 339 }
 340 
 341 
 342 void MacroAssembler::pop_callee_saved_registers() {
 343   pop(rcx);
 344   pop(rdx);
 345   pop(rdi);
 346   pop(rsi);
 347 }
 348 
 349 void MacroAssembler::push_callee_saved_registers() {
 350   push(rsi);
 351   push(rdi);
 352   push(rdx);
 353   push(rcx);
 354 }
 355 
 356 void MacroAssembler::pushoop(jobject obj) {
 357   push_literal32((int32_t)obj, oop_Relocation::spec_for_immediate());
 358 }
 359 
 360 void MacroAssembler::pushklass(Metadata* obj) {
 361   push_literal32((int32_t)obj, metadata_Relocation::spec_for_immediate());
 362 }
 363 
 364 void MacroAssembler::pushptr(AddressLiteral src) {
 365   if (src.is_lval()) {
 366     push_literal32((int32_t)src.target(), src.rspec());
 367   } else {
 368     pushl(as_Address(src));
 369   }
 370 }
 371 
 372 void MacroAssembler::set_word_if_not_zero(Register dst) {
 373   xorl(dst, dst);
 374   set_byte_if_not_zero(dst);
 375 }
 376 
 377 static void pass_arg0(MacroAssembler* masm, Register arg) {
 378   masm-&gt;push(arg);
 379 }
 380 
 381 static void pass_arg1(MacroAssembler* masm, Register arg) {
 382   masm-&gt;push(arg);
 383 }
 384 
 385 static void pass_arg2(MacroAssembler* masm, Register arg) {
 386   masm-&gt;push(arg);
 387 }
 388 
 389 static void pass_arg3(MacroAssembler* masm, Register arg) {
 390   masm-&gt;push(arg);
 391 }
 392 
 393 #ifndef PRODUCT
 394 extern &quot;C&quot; void findpc(intptr_t x);
 395 #endif
 396 
 397 void MacroAssembler::debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg) {
 398   // In order to get locks to work, we need to fake a in_VM state
 399   JavaThread* thread = JavaThread::current();
 400   JavaThreadState saved_state = thread-&gt;thread_state();
 401   thread-&gt;set_thread_state(_thread_in_vm);
 402   if (ShowMessageBoxOnError) {
 403     JavaThread* thread = JavaThread::current();
 404     JavaThreadState saved_state = thread-&gt;thread_state();
 405     thread-&gt;set_thread_state(_thread_in_vm);
 406     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 407       ttyLocker ttyl;
 408       BytecodeCounter::print();
 409     }
 410     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 411     // This is the value of eip which points to where verify_oop will return.
 412     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 413       print_state32(rdi, rsi, rbp, rsp, rbx, rdx, rcx, rax, eip);
 414       BREAKPOINT;
 415     }
 416   }
 417   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 418 }
 419 
 420 void MacroAssembler::print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip) {
 421   ttyLocker ttyl;
 422   FlagSetting fs(Debugging, true);
 423   tty-&gt;print_cr(&quot;eip = 0x%08x&quot;, eip);
 424 #ifndef PRODUCT
 425   if ((WizardMode || Verbose) &amp;&amp; PrintMiscellaneous) {
 426     tty-&gt;cr();
 427     findpc(eip);
 428     tty-&gt;cr();
 429   }
 430 #endif
 431 #define PRINT_REG(rax) \
 432   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, rax); }
 433   PRINT_REG(rax);
 434   PRINT_REG(rbx);
 435   PRINT_REG(rcx);
 436   PRINT_REG(rdx);
 437   PRINT_REG(rdi);
 438   PRINT_REG(rsi);
 439   PRINT_REG(rbp);
 440   PRINT_REG(rsp);
 441 #undef PRINT_REG
 442   // Print some words near top of staack.
 443   int* dump_sp = (int*) rsp;
 444   for (int col1 = 0; col1 &lt; 8; col1++) {
 445     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 446     os::print_location(tty, *dump_sp++);
 447   }
 448   for (int row = 0; row &lt; 16; row++) {
 449     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 450     for (int col = 0; col &lt; 8; col++) {
 451       tty-&gt;print(&quot; 0x%08x&quot;, *dump_sp++);
 452     }
 453     tty-&gt;cr();
 454   }
 455   // Print some instructions around pc:
 456   Disassembler::decode((address)eip-64, (address)eip);
 457   tty-&gt;print_cr(&quot;--------&quot;);
 458   Disassembler::decode((address)eip, (address)eip+32);
 459 }
 460 
 461 void MacroAssembler::stop(const char* msg) {
 462   ExternalAddress message((address)msg);
 463   // push address of message
 464   pushptr(message.addr());
 465   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 466   pusha();                                            // push registers
 467   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
 468   hlt();
 469 }
 470 
 471 void MacroAssembler::warn(const char* msg) {
 472   push_CPU_state();
 473 
 474   ExternalAddress message((address) msg);
 475   // push address of message
 476   pushptr(message.addr());
 477 
 478   call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));
 479   addl(rsp, wordSize);       // discard argument
 480   pop_CPU_state();
 481 }
 482 
 483 void MacroAssembler::print_state() {
 484   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 485   pusha();                                            // push registers
 486 
 487   push_CPU_state();
 488   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::print_state32)));
 489   pop_CPU_state();
 490 
 491   popa();
 492   addl(rsp, wordSize);
 493 }
 494 
 495 #else // _LP64
 496 
 497 // 64 bit versions
 498 
 499 Address MacroAssembler::as_Address(AddressLiteral adr) {
 500   // amd64 always does this as a pc-rel
 501   // we can be absolute or disp based on the instruction type
 502   // jmp/call are displacements others are absolute
 503   assert(!adr.is_lval(), &quot;must be rval&quot;);
 504   assert(reachable(adr), &quot;must be&quot;);
 505   return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());
 506 
 507 }
 508 
 509 Address MacroAssembler::as_Address(ArrayAddress adr) {
 510   AddressLiteral base = adr.base();
 511   lea(rscratch1, base);
 512   Address index = adr.index();
 513   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
 514   Address array(rscratch1, index._index, index._scale, index._disp);
 515   return array;
 516 }
 517 
 518 void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) {
 519   Label L, E;
 520 
 521 #ifdef _WIN64
 522   // Windows always allocates space for it&#39;s register args
 523   assert(num_args &lt;= 4, &quot;only register arguments supported&quot;);
 524   subq(rsp,  frame::arg_reg_save_area_bytes);
 525 #endif
 526 
 527   // Align stack if necessary
 528   testl(rsp, 15);
 529   jcc(Assembler::zero, L);
 530 
 531   subq(rsp, 8);
 532   {
 533     call(RuntimeAddress(entry_point));
 534   }
 535   addq(rsp, 8);
 536   jmp(E);
 537 
 538   bind(L);
 539   {
 540     call(RuntimeAddress(entry_point));
 541   }
 542 
 543   bind(E);
 544 
 545 #ifdef _WIN64
 546   // restore stack pointer
 547   addq(rsp, frame::arg_reg_save_area_bytes);
 548 #endif
 549 
 550 }
 551 
 552 void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {
 553   assert(!src2.is_lval(), &quot;should use cmpptr&quot;);
 554 
 555   if (reachable(src2)) {
 556     cmpq(src1, as_Address(src2));
 557   } else {
 558     lea(rscratch1, src2);
 559     Assembler::cmpq(src1, Address(rscratch1, 0));
 560   }
 561 }
 562 
 563 int MacroAssembler::corrected_idivq(Register reg) {
 564   // Full implementation of Java ldiv and lrem; checks for special
 565   // case as described in JVM spec., p.243 &amp; p.271.  The function
 566   // returns the (pc) offset of the idivl instruction - may be needed
 567   // for implicit exceptions.
 568   //
 569   //         normal case                           special case
 570   //
 571   // input : rax: dividend                         min_long
 572   //         reg: divisor   (may not be eax/edx)   -1
 573   //
 574   // output: rax: quotient  (= rax idiv reg)       min_long
 575   //         rdx: remainder (= rax irem reg)       0
 576   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax or rdx register&quot;);
 577   static const int64_t min_long = 0x8000000000000000;
 578   Label normal_case, special_case;
 579 
 580   // check for special case
 581   cmp64(rax, ExternalAddress((address) &amp;min_long));
 582   jcc(Assembler::notEqual, normal_case);
 583   xorl(rdx, rdx); // prepare rdx for possible special case (where
 584                   // remainder = 0)
 585   cmpq(reg, -1);
 586   jcc(Assembler::equal, special_case);
 587 
 588   // handle normal case
 589   bind(normal_case);
 590   cdqq();
 591   int idivq_offset = offset();
 592   idivq(reg);
 593 
 594   // normal and special case exit
 595   bind(special_case);
 596 
 597   return idivq_offset;
 598 }
 599 
 600 void MacroAssembler::decrementq(Register reg, int value) {
 601   if (value == min_jint) { subq(reg, value); return; }
 602   if (value &lt;  0) { incrementq(reg, -value); return; }
 603   if (value == 0) {                        ; return; }
 604   if (value == 1 &amp;&amp; UseIncDec) { decq(reg) ; return; }
 605   /* else */      { subq(reg, value)       ; return; }
 606 }
 607 
 608 void MacroAssembler::decrementq(Address dst, int value) {
 609   if (value == min_jint) { subq(dst, value); return; }
 610   if (value &lt;  0) { incrementq(dst, -value); return; }
 611   if (value == 0) {                        ; return; }
 612   if (value == 1 &amp;&amp; UseIncDec) { decq(dst) ; return; }
 613   /* else */      { subq(dst, value)       ; return; }
 614 }
 615 
 616 void MacroAssembler::incrementq(AddressLiteral dst) {
 617   if (reachable(dst)) {
 618     incrementq(as_Address(dst));
 619   } else {
 620     lea(rscratch1, dst);
 621     incrementq(Address(rscratch1, 0));
 622   }
 623 }
 624 
 625 void MacroAssembler::incrementq(Register reg, int value) {
 626   if (value == min_jint) { addq(reg, value); return; }
 627   if (value &lt;  0) { decrementq(reg, -value); return; }
 628   if (value == 0) {                        ; return; }
 629   if (value == 1 &amp;&amp; UseIncDec) { incq(reg) ; return; }
 630   /* else */      { addq(reg, value)       ; return; }
 631 }
 632 
 633 void MacroAssembler::incrementq(Address dst, int value) {
 634   if (value == min_jint) { addq(dst, value); return; }
 635   if (value &lt;  0) { decrementq(dst, -value); return; }
 636   if (value == 0) {                        ; return; }
 637   if (value == 1 &amp;&amp; UseIncDec) { incq(dst) ; return; }
 638   /* else */      { addq(dst, value)       ; return; }
 639 }
 640 
 641 // 32bit can do a case table jump in one instruction but we no longer allow the base
 642 // to be installed in the Address class
 643 void MacroAssembler::jump(ArrayAddress entry) {
 644   lea(rscratch1, entry.base());
 645   Address dispatch = entry.index();
 646   assert(dispatch._base == noreg, &quot;must be&quot;);
 647   dispatch._base = rscratch1;
 648   jmp(dispatch);
 649 }
 650 
 651 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 652   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 653   cmpq(x_lo, y_lo);
 654 }
 655 
 656 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 657     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 658 }
 659 
 660 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 661   mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());
 662   movptr(dst, rscratch1);
 663 }
 664 
 665 void MacroAssembler::leave() {
 666   // %%% is this really better? Why not on 32bit too?
 667   emit_int8((unsigned char)0xC9); // LEAVE
 668 }
 669 
 670 void MacroAssembler::lneg(Register hi, Register lo) {
 671   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 672   negq(lo);
 673 }
 674 
 675 void MacroAssembler::movoop(Register dst, jobject obj) {
 676   mov_literal64(dst, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 677 }
 678 
 679 void MacroAssembler::movoop(Address dst, jobject obj) {
 680   mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 681   movq(dst, rscratch1);
 682 }
 683 
 684 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 685   mov_literal64(dst, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 686 }
 687 
 688 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 689   mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 690   movq(dst, rscratch1);
 691 }
 692 
 693 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 694   if (src.is_lval()) {
 695     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 696   } else {
 697     if (reachable(src)) {
 698       movq(dst, as_Address(src));
 699     } else {
 700       lea(scratch, src);
 701       movq(dst, Address(scratch, 0));
 702     }
 703   }
 704 }
 705 
 706 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 707   movq(as_Address(dst), src);
 708 }
 709 
 710 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 711   movq(dst, as_Address(src));
 712 }
 713 
 714 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 715 void MacroAssembler::movptr(Address dst, intptr_t src) {
 716   mov64(rscratch1, src);
 717   movq(dst, rscratch1);
 718 }
 719 
 720 // These are mostly for initializing NULL
 721 void MacroAssembler::movptr(Address dst, int32_t src) {
 722   movslq(dst, src);
 723 }
 724 
 725 void MacroAssembler::movptr(Register dst, int32_t src) {
 726   mov64(dst, (intptr_t)src);
 727 }
 728 
 729 void MacroAssembler::pushoop(jobject obj) {
 730   movoop(rscratch1, obj);
 731   push(rscratch1);
 732 }
 733 
 734 void MacroAssembler::pushklass(Metadata* obj) {
 735   mov_metadata(rscratch1, obj);
 736   push(rscratch1);
 737 }
 738 
 739 void MacroAssembler::pushptr(AddressLiteral src) {
 740   lea(rscratch1, src);
 741   if (src.is_lval()) {
 742     push(rscratch1);
 743   } else {
 744     pushq(Address(rscratch1, 0));
 745   }
 746 }
 747 
 748 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 749   // we must set sp to zero to clear frame
 750   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
 751   // must clear fp, so that compiled frames are not confused; it is
 752   // possible that we need it only for debugging
 753   if (clear_fp) {
 754     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
 755   }
 756 
 757   // Always clear the pc because it could have been set by make_walkable()
 758   movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
 759   vzeroupper();
 760 }
 761 
 762 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 763                                          Register last_java_fp,
 764                                          address  last_java_pc) {
 765   vzeroupper();
 766   // determine last_java_sp register
 767   if (!last_java_sp-&gt;is_valid()) {
 768     last_java_sp = rsp;
 769   }
 770 
 771   // last_java_fp is optional
 772   if (last_java_fp-&gt;is_valid()) {
 773     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),
 774            last_java_fp);
 775   }
 776 
 777   // last_java_pc is optional
 778   if (last_java_pc != NULL) {
 779     Address java_pc(r15_thread,
 780                     JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 781     lea(rscratch1, InternalAddress(last_java_pc));
 782     movptr(java_pc, rscratch1);
 783   }
 784 
 785   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
 786 }
 787 
 788 static void pass_arg0(MacroAssembler* masm, Register arg) {
 789   if (c_rarg0 != arg ) {
 790     masm-&gt;mov(c_rarg0, arg);
 791   }
 792 }
 793 
 794 static void pass_arg1(MacroAssembler* masm, Register arg) {
 795   if (c_rarg1 != arg ) {
 796     masm-&gt;mov(c_rarg1, arg);
 797   }
 798 }
 799 
 800 static void pass_arg2(MacroAssembler* masm, Register arg) {
 801   if (c_rarg2 != arg ) {
 802     masm-&gt;mov(c_rarg2, arg);
 803   }
 804 }
 805 
 806 static void pass_arg3(MacroAssembler* masm, Register arg) {
 807   if (c_rarg3 != arg ) {
 808     masm-&gt;mov(c_rarg3, arg);
 809   }
 810 }
 811 
 812 void MacroAssembler::stop(const char* msg) {
 813   if (ShowMessageBoxOnError) {
 814     address rip = pc();
 815     pusha(); // get regs on stack
 816     lea(c_rarg1, InternalAddress(rip));
 817     movq(c_rarg2, rsp); // pass pointer to regs array
 818   }
 819   lea(c_rarg0, ExternalAddress((address) msg));
 820   andq(rsp, -16); // align stack as required by ABI
 821   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
 822   hlt();
 823 }
 824 
 825 void MacroAssembler::warn(const char* msg) {
 826   push(rbp);
 827   movq(rbp, rsp);
 828   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 829   push_CPU_state();   // keeps alignment at 16 bytes
 830   lea(c_rarg0, ExternalAddress((address) msg));
 831   lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));
 832   call(rax);
 833   pop_CPU_state();
 834   mov(rsp, rbp);
 835   pop(rbp);
 836 }
 837 
 838 void MacroAssembler::print_state() {
 839   address rip = pc();
 840   pusha();            // get regs on stack
 841   push(rbp);
 842   movq(rbp, rsp);
 843   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 844   push_CPU_state();   // keeps alignment at 16 bytes
 845 
 846   lea(c_rarg0, InternalAddress(rip));
 847   lea(c_rarg1, Address(rbp, wordSize)); // pass pointer to regs array
 848   call_VM_leaf(CAST_FROM_FN_PTR(address, MacroAssembler::print_state64), c_rarg0, c_rarg1);
 849 
 850   pop_CPU_state();
 851   mov(rsp, rbp);
 852   pop(rbp);
 853   popa();
 854 }
 855 
 856 #ifndef PRODUCT
 857 extern &quot;C&quot; void findpc(intptr_t x);
 858 #endif
 859 
 860 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[]) {
 861   // In order to get locks to work, we need to fake a in_VM state
 862   if (ShowMessageBoxOnError) {
 863     JavaThread* thread = JavaThread::current();
 864     JavaThreadState saved_state = thread-&gt;thread_state();
 865     thread-&gt;set_thread_state(_thread_in_vm);
 866 #ifndef PRODUCT
 867     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 868       ttyLocker ttyl;
 869       BytecodeCounter::print();
 870     }
 871 #endif
 872     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 873     // XXX correct this offset for amd64
 874     // This is the value of eip which points to where verify_oop will return.
 875     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 876       print_state64(pc, regs);
 877       BREAKPOINT;
 878     }
 879   }
 880   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 881 }
 882 
 883 void MacroAssembler::print_state64(int64_t pc, int64_t regs[]) {
 884   ttyLocker ttyl;
 885   FlagSetting fs(Debugging, true);
 886   tty-&gt;print_cr(&quot;rip = 0x%016lx&quot;, (intptr_t)pc);
 887 #ifndef PRODUCT
 888   tty-&gt;cr();
 889   findpc(pc);
 890   tty-&gt;cr();
 891 #endif
 892 #define PRINT_REG(rax, value) \
 893   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, value); }
 894   PRINT_REG(rax, regs[15]);
 895   PRINT_REG(rbx, regs[12]);
 896   PRINT_REG(rcx, regs[14]);
 897   PRINT_REG(rdx, regs[13]);
 898   PRINT_REG(rdi, regs[8]);
 899   PRINT_REG(rsi, regs[9]);
 900   PRINT_REG(rbp, regs[10]);
 901   PRINT_REG(rsp, regs[11]);
 902   PRINT_REG(r8 , regs[7]);
 903   PRINT_REG(r9 , regs[6]);
 904   PRINT_REG(r10, regs[5]);
 905   PRINT_REG(r11, regs[4]);
 906   PRINT_REG(r12, regs[3]);
 907   PRINT_REG(r13, regs[2]);
 908   PRINT_REG(r14, regs[1]);
 909   PRINT_REG(r15, regs[0]);
 910 #undef PRINT_REG
 911   // Print some words near top of staack.
 912   int64_t* rsp = (int64_t*) regs[11];
 913   int64_t* dump_sp = rsp;
 914   for (int col1 = 0; col1 &lt; 8; col1++) {
 915     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 916     os::print_location(tty, *dump_sp++);
 917   }
 918   for (int row = 0; row &lt; 25; row++) {
 919     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 920     for (int col = 0; col &lt; 4; col++) {
 921       tty-&gt;print(&quot; 0x%016lx&quot;, (intptr_t)*dump_sp++);
 922     }
 923     tty-&gt;cr();
 924   }
 925   // Print some instructions around pc:
 926   Disassembler::decode((address)pc-64, (address)pc);
 927   tty-&gt;print_cr(&quot;--------&quot;);
 928   Disassembler::decode((address)pc, (address)pc+32);
 929 }
 930 
 931 #endif // _LP64
 932 
 933 // Now versions that are common to 32/64 bit
 934 
 935 void MacroAssembler::addptr(Register dst, int32_t imm32) {
 936   LP64_ONLY(addq(dst, imm32)) NOT_LP64(addl(dst, imm32));
 937 }
 938 
 939 void MacroAssembler::addptr(Register dst, Register src) {
 940   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 941 }
 942 
 943 void MacroAssembler::addptr(Address dst, Register src) {
 944   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 945 }
 946 
 947 void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {
 948   if (reachable(src)) {
 949     Assembler::addsd(dst, as_Address(src));
 950   } else {
 951     lea(rscratch1, src);
 952     Assembler::addsd(dst, Address(rscratch1, 0));
 953   }
 954 }
 955 
 956 void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {
 957   if (reachable(src)) {
 958     addss(dst, as_Address(src));
 959   } else {
 960     lea(rscratch1, src);
 961     addss(dst, Address(rscratch1, 0));
 962   }
 963 }
 964 
 965 void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {
 966   if (reachable(src)) {
 967     Assembler::addpd(dst, as_Address(src));
 968   } else {
 969     lea(rscratch1, src);
 970     Assembler::addpd(dst, Address(rscratch1, 0));
 971   }
 972 }
 973 
 974 void MacroAssembler::align(int modulus) {
 975   align(modulus, offset());
 976 }
 977 
 978 void MacroAssembler::align(int modulus, int target) {
 979   if (target % modulus != 0) {
 980     nop(modulus - (target % modulus));
 981   }
 982 }
 983 
 984 void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 985   // Used in sign-masking with aligned address.
 986   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 987   if (reachable(src)) {
 988     Assembler::andpd(dst, as_Address(src));
 989   } else {
 990     lea(scratch_reg, src);
 991     Assembler::andpd(dst, Address(scratch_reg, 0));
 992   }
 993 }
 994 
 995 void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 996   // Used in sign-masking with aligned address.
 997   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 998   if (reachable(src)) {
 999     Assembler::andps(dst, as_Address(src));
1000   } else {
1001     lea(scratch_reg, src);
1002     Assembler::andps(dst, Address(scratch_reg, 0));
1003   }
1004 }
1005 
1006 void MacroAssembler::andptr(Register dst, int32_t imm32) {
1007   LP64_ONLY(andq(dst, imm32)) NOT_LP64(andl(dst, imm32));
1008 }
1009 
1010 void MacroAssembler::atomic_incl(Address counter_addr) {
1011   lock();
1012   incrementl(counter_addr);
1013 }
1014 
1015 void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {
1016   if (reachable(counter_addr)) {
1017     atomic_incl(as_Address(counter_addr));
1018   } else {
1019     lea(scr, counter_addr);
1020     atomic_incl(Address(scr, 0));
1021   }
1022 }
1023 
1024 #ifdef _LP64
1025 void MacroAssembler::atomic_incq(Address counter_addr) {
1026   lock();
1027   incrementq(counter_addr);
1028 }
1029 
1030 void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {
1031   if (reachable(counter_addr)) {
1032     atomic_incq(as_Address(counter_addr));
1033   } else {
1034     lea(scr, counter_addr);
1035     atomic_incq(Address(scr, 0));
1036   }
1037 }
1038 #endif
1039 
1040 // Writes to stack successive pages until offset reached to check for
1041 // stack overflow + shadow pages.  This clobbers tmp.
1042 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
1043   movptr(tmp, rsp);
1044   // Bang stack for total size given plus shadow page size.
1045   // Bang one page at a time because large size can bang beyond yellow and
1046   // red zones.
1047   Label loop;
1048   bind(loop);
1049   movl(Address(tmp, (-os::vm_page_size())), size );
1050   subptr(tmp, os::vm_page_size());
1051   subl(size, os::vm_page_size());
1052   jcc(Assembler::greater, loop);
1053 
1054   // Bang down shadow pages too.
1055   // At this point, (tmp-0) is the last address touched, so don&#39;t
1056   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
1057   // was post-decremented.)  Skip this address by starting at i=1, and
1058   // touch a few more pages below.  N.B.  It is important to touch all
1059   // the way down including all pages in the shadow zone.
1060   for (int i = 1; i &lt; ((int)JavaThread::stack_shadow_zone_size() / os::vm_page_size()); i++) {
1061     // this could be any sized move but this is can be a debugging crumb
1062     // so the bigger the better.
1063     movptr(Address(tmp, (-i*os::vm_page_size())), size );
1064   }
1065 }
1066 
1067 void MacroAssembler::reserved_stack_check() {
1068     // testing if reserved zone needs to be enabled
1069     Label no_reserved_zone_enabling;
1070     Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
1071     NOT_LP64(get_thread(rsi);)
1072 
1073     cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));
1074     jcc(Assembler::below, no_reserved_zone_enabling);
1075 
1076     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);
1077     jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
1078     should_not_reach_here();
1079 
1080     bind(no_reserved_zone_enabling);
1081 }
1082 
1083 int MacroAssembler::biased_locking_enter(Register lock_reg,
1084                                          Register obj_reg,
1085                                          Register swap_reg,
1086                                          Register tmp_reg,
1087                                          bool swap_reg_contains_mark,
1088                                          Label&amp; done,
1089                                          Label* slow_case,
1090                                          BiasedLockingCounters* counters) {
1091   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1092   assert(swap_reg == rax, &quot;swap_reg must be rax for cmpxchgq&quot;);
1093   assert(tmp_reg != noreg, &quot;tmp_reg must be supplied&quot;);
1094   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);
1095   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
1096   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
1097   NOT_LP64( Address saved_mark_addr(lock_reg, 0); )
1098 
1099   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL) {
1100     counters = BiasedLocking::counters();
1101   }
1102   // Biased locking
1103   // See whether the lock is currently biased toward our thread and
1104   // whether the epoch is still valid
1105   // Note that the runtime guarantees sufficient alignment of JavaThread
1106   // pointers to allow age to be placed into low bits
1107   // First check to see whether biasing is even enabled for this object
1108   Label cas_label;
1109   int null_check_offset = -1;
1110   if (!swap_reg_contains_mark) {
1111     null_check_offset = offset();
1112     movptr(swap_reg, mark_addr);
1113   }
1114   movptr(tmp_reg, swap_reg);
1115   andptr(tmp_reg, markWord::biased_lock_mask_in_place);
1116   cmpptr(tmp_reg, markWord::biased_lock_pattern);
1117   jcc(Assembler::notEqual, cas_label);
1118   // The bias pattern is present in the object&#39;s header. Need to check
1119   // whether the bias owner and the epoch are both still current.
1120 #ifndef _LP64
1121   // Note that because there is no current thread register on x86_32 we
1122   // need to store off the mark word we read out of the object to
1123   // avoid reloading it and needing to recheck invariants below. This
1124   // store is unfortunate but it makes the overall code shorter and
1125   // simpler.
1126   movptr(saved_mark_addr, swap_reg);
1127 #endif
1128   if (swap_reg_contains_mark) {
1129     null_check_offset = offset();
1130   }
1131   load_prototype_header(tmp_reg, obj_reg);
1132 #ifdef _LP64
1133   orptr(tmp_reg, r15_thread);
1134   xorptr(tmp_reg, swap_reg);
1135   Register header_reg = tmp_reg;
1136 #else
1137   xorptr(tmp_reg, swap_reg);
1138   get_thread(swap_reg);
1139   xorptr(swap_reg, tmp_reg);
1140   Register header_reg = swap_reg;
1141 #endif
1142   andptr(header_reg, ~((int) markWord::age_mask_in_place));
1143   if (counters != NULL) {
1144     cond_inc32(Assembler::zero,
1145                ExternalAddress((address) counters-&gt;biased_lock_entry_count_addr()));
1146   }
1147   jcc(Assembler::equal, done);
1148 
1149   Label try_revoke_bias;
1150   Label try_rebias;
1151 
1152   // At this point we know that the header has the bias pattern and
1153   // that we are not the bias owner in the current epoch. We need to
1154   // figure out more details about the state of the header in order to
1155   // know what operations can be legally performed on the object&#39;s
1156   // header.
1157 
1158   // If the low three bits in the xor result aren&#39;t clear, that means
1159   // the prototype header is no longer biased and we have to revoke
1160   // the bias on this object.
1161   testptr(header_reg, markWord::biased_lock_mask_in_place);
1162   jccb(Assembler::notZero, try_revoke_bias);
1163 
1164   // Biasing is still enabled for this data type. See whether the
1165   // epoch of the current bias is still valid, meaning that the epoch
1166   // bits of the mark word are equal to the epoch bits of the
1167   // prototype header. (Note that the prototype header&#39;s epoch bits
1168   // only change at a safepoint.) If not, attempt to rebias the object
1169   // toward the current thread. Note that we must be absolutely sure
1170   // that the current epoch is invalid in order to do this because
1171   // otherwise the manipulations it performs on the mark word are
1172   // illegal.
1173   testptr(header_reg, markWord::epoch_mask_in_place);
1174   jccb(Assembler::notZero, try_rebias);
1175 
1176   // The epoch of the current bias is still valid but we know nothing
1177   // about the owner; it might be set or it might be clear. Try to
1178   // acquire the bias of the object using an atomic operation. If this
1179   // fails we will go in to the runtime to revoke the object&#39;s bias.
1180   // Note that we first construct the presumed unbiased header so we
1181   // don&#39;t accidentally blow away another thread&#39;s valid bias.
1182   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1183   andptr(swap_reg,
1184          markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
1185 #ifdef _LP64
1186   movptr(tmp_reg, swap_reg);
1187   orptr(tmp_reg, r15_thread);
1188 #else
1189   get_thread(tmp_reg);
1190   orptr(tmp_reg, swap_reg);
1191 #endif
1192   lock();
1193   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1194   // If the biasing toward our thread failed, this means that
1195   // another thread succeeded in biasing it toward itself and we
1196   // need to revoke that bias. The revocation will occur in the
1197   // interpreter runtime in the slow case.
1198   if (counters != NULL) {
1199     cond_inc32(Assembler::zero,
1200                ExternalAddress((address) counters-&gt;anonymously_biased_lock_entry_count_addr()));
1201   }
1202   if (slow_case != NULL) {
1203     jcc(Assembler::notZero, *slow_case);
1204   }
1205   jmp(done);
1206 
1207   bind(try_rebias);
1208   // At this point we know the epoch has expired, meaning that the
1209   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
1210   // circumstances _only_, we are allowed to use the current header&#39;s
1211   // value as the comparison value when doing the cas to acquire the
1212   // bias in the current epoch. In other words, we allow transfer of
1213   // the bias from one thread to another directly in this situation.
1214   //
1215   // FIXME: due to a lack of registers we currently blow away the age
1216   // bits in this situation. Should attempt to preserve them.
1217   load_prototype_header(tmp_reg, obj_reg);
1218 #ifdef _LP64
1219   orptr(tmp_reg, r15_thread);
1220 #else
1221   get_thread(swap_reg);
1222   orptr(tmp_reg, swap_reg);
1223   movptr(swap_reg, saved_mark_addr);
1224 #endif
1225   lock();
1226   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1227   // If the biasing toward our thread failed, then another thread
1228   // succeeded in biasing it toward itself and we need to revoke that
1229   // bias. The revocation will occur in the runtime in the slow case.
1230   if (counters != NULL) {
1231     cond_inc32(Assembler::zero,
1232                ExternalAddress((address) counters-&gt;rebiased_lock_entry_count_addr()));
1233   }
1234   if (slow_case != NULL) {
1235     jcc(Assembler::notZero, *slow_case);
1236   }
1237   jmp(done);
1238 
1239   bind(try_revoke_bias);
1240   // The prototype mark in the klass doesn&#39;t have the bias bit set any
1241   // more, indicating that objects of this data type are not supposed
1242   // to be biased any more. We are going to try to reset the mark of
1243   // this object to the prototype value and fall through to the
1244   // CAS-based locking scheme. Note that if our CAS fails, it means
1245   // that another thread raced us for the privilege of revoking the
1246   // bias of this particular object, so it&#39;s okay to continue in the
1247   // normal locking code.
1248   //
1249   // FIXME: due to a lack of registers we currently blow away the age
1250   // bits in this situation. Should attempt to preserve them.
1251   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1252   load_prototype_header(tmp_reg, obj_reg);
1253   lock();
1254   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1255   // Fall through to the normal CAS-based lock, because no matter what
1256   // the result of the above CAS, some thread must have succeeded in
1257   // removing the bias bit from the object&#39;s header.
1258   if (counters != NULL) {
1259     cond_inc32(Assembler::zero,
1260                ExternalAddress((address) counters-&gt;revoked_lock_entry_count_addr()));
1261   }
1262 
1263   bind(cas_label);
1264 
1265   return null_check_offset;
1266 }
1267 
1268 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
1269   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1270 
1271   // Check for biased locking unlock case, which is a no-op
1272   // Note: we do not have to check the thread ID for two reasons.
1273   // First, the interpreter checks for IllegalMonitorStateException at
1274   // a higher level. Second, if the bias was revoked while we held the
1275   // lock, the object could not be rebiased toward another thread, so
1276   // the bias bit would be clear.
1277   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1278   andptr(temp_reg, markWord::biased_lock_mask_in_place);
1279   cmpptr(temp_reg, markWord::biased_lock_pattern);
1280   jcc(Assembler::equal, done);
1281 }
1282 
1283 void MacroAssembler::c2bool(Register x) {
1284   // implements x == 0 ? 0 : 1
1285   // note: must only look at least-significant byte of x
1286   //       since C-style booleans are stored in one byte
1287   //       only! (was bug)
1288   andl(x, 0xFF);
1289   setb(Assembler::notZero, x);
1290 }
1291 
1292 // Wouldn&#39;t need if AddressLiteral version had new name
1293 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
1294   Assembler::call(L, rtype);
1295 }
1296 
1297 void MacroAssembler::call(Register entry) {
1298   Assembler::call(entry);
1299 }
1300 
1301 void MacroAssembler::call(AddressLiteral entry) {
1302   if (reachable(entry)) {
1303     Assembler::call_literal(entry.target(), entry.rspec());
1304   } else {
1305     lea(rscratch1, entry);
1306     Assembler::call(rscratch1);
1307   }
1308 }
1309 
1310 void MacroAssembler::ic_call(address entry, jint method_index) {
1311   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
1312   movptr(rax, (intptr_t)Universe::non_oop_word());
1313   call(AddressLiteral(entry, rh));
1314 }
1315 
1316 // Implementation of call_VM versions
1317 
1318 void MacroAssembler::call_VM(Register oop_result,
1319                              address entry_point,
1320                              bool check_exceptions) {
1321   Label C, E;
1322   call(C, relocInfo::none);
1323   jmp(E);
1324 
1325   bind(C);
1326   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
1327   ret(0);
1328 
1329   bind(E);
1330 }
1331 
1332 void MacroAssembler::call_VM(Register oop_result,
1333                              address entry_point,
1334                              Register arg_1,
1335                              bool check_exceptions) {
1336   Label C, E;
1337   call(C, relocInfo::none);
1338   jmp(E);
1339 
1340   bind(C);
1341   pass_arg1(this, arg_1);
1342   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
1343   ret(0);
1344 
1345   bind(E);
1346 }
1347 
1348 void MacroAssembler::call_VM(Register oop_result,
1349                              address entry_point,
1350                              Register arg_1,
1351                              Register arg_2,
1352                              bool check_exceptions) {
1353   Label C, E;
1354   call(C, relocInfo::none);
1355   jmp(E);
1356 
1357   bind(C);
1358 
1359   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1360 
1361   pass_arg2(this, arg_2);
1362   pass_arg1(this, arg_1);
1363   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
1364   ret(0);
1365 
1366   bind(E);
1367 }
1368 
1369 void MacroAssembler::call_VM(Register oop_result,
1370                              address entry_point,
1371                              Register arg_1,
1372                              Register arg_2,
1373                              Register arg_3,
1374                              bool check_exceptions) {
1375   Label C, E;
1376   call(C, relocInfo::none);
1377   jmp(E);
1378 
1379   bind(C);
1380 
1381   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1382   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1383   pass_arg3(this, arg_3);
1384 
1385   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1386   pass_arg2(this, arg_2);
1387 
1388   pass_arg1(this, arg_1);
1389   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
1390   ret(0);
1391 
1392   bind(E);
1393 }
1394 
1395 void MacroAssembler::call_VM(Register oop_result,
1396                              Register last_java_sp,
1397                              address entry_point,
1398                              int number_of_arguments,
1399                              bool check_exceptions) {
1400   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1401   call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1402 }
1403 
1404 void MacroAssembler::call_VM(Register oop_result,
1405                              Register last_java_sp,
1406                              address entry_point,
1407                              Register arg_1,
1408                              bool check_exceptions) {
1409   pass_arg1(this, arg_1);
1410   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1411 }
1412 
1413 void MacroAssembler::call_VM(Register oop_result,
1414                              Register last_java_sp,
1415                              address entry_point,
1416                              Register arg_1,
1417                              Register arg_2,
1418                              bool check_exceptions) {
1419 
1420   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1421   pass_arg2(this, arg_2);
1422   pass_arg1(this, arg_1);
1423   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1424 }
1425 
1426 void MacroAssembler::call_VM(Register oop_result,
1427                              Register last_java_sp,
1428                              address entry_point,
1429                              Register arg_1,
1430                              Register arg_2,
1431                              Register arg_3,
1432                              bool check_exceptions) {
1433   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1434   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1435   pass_arg3(this, arg_3);
1436   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1437   pass_arg2(this, arg_2);
1438   pass_arg1(this, arg_1);
1439   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1440 }
1441 
1442 void MacroAssembler::super_call_VM(Register oop_result,
1443                                    Register last_java_sp,
1444                                    address entry_point,
1445                                    int number_of_arguments,
1446                                    bool check_exceptions) {
1447   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1448   MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1449 }
1450 
1451 void MacroAssembler::super_call_VM(Register oop_result,
1452                                    Register last_java_sp,
1453                                    address entry_point,
1454                                    Register arg_1,
1455                                    bool check_exceptions) {
1456   pass_arg1(this, arg_1);
1457   super_call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1458 }
1459 
1460 void MacroAssembler::super_call_VM(Register oop_result,
1461                                    Register last_java_sp,
1462                                    address entry_point,
1463                                    Register arg_1,
1464                                    Register arg_2,
1465                                    bool check_exceptions) {
1466 
1467   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1468   pass_arg2(this, arg_2);
1469   pass_arg1(this, arg_1);
1470   super_call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1471 }
1472 
1473 void MacroAssembler::super_call_VM(Register oop_result,
1474                                    Register last_java_sp,
1475                                    address entry_point,
1476                                    Register arg_1,
1477                                    Register arg_2,
1478                                    Register arg_3,
1479                                    bool check_exceptions) {
1480   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1481   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1482   pass_arg3(this, arg_3);
1483   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1484   pass_arg2(this, arg_2);
1485   pass_arg1(this, arg_1);
1486   super_call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1487 }
1488 
1489 void MacroAssembler::call_VM_base(Register oop_result,
1490                                   Register java_thread,
1491                                   Register last_java_sp,
1492                                   address  entry_point,
1493                                   int      number_of_arguments,
1494                                   bool     check_exceptions) {
1495   // determine java_thread register
1496   if (!java_thread-&gt;is_valid()) {
1497 #ifdef _LP64
1498     java_thread = r15_thread;
1499 #else
1500     java_thread = rdi;
1501     get_thread(java_thread);
1502 #endif // LP64
1503   }
1504   // determine last_java_sp register
1505   if (!last_java_sp-&gt;is_valid()) {
1506     last_java_sp = rsp;
1507   }
1508   // debugging support
1509   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
1510   LP64_ONLY(assert(java_thread == r15_thread, &quot;unexpected register&quot;));
1511 #ifdef ASSERT
1512   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
1513   // r12 is the heapbase.
1514   LP64_ONLY(if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);)
1515 #endif // ASSERT
1516 
1517   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
1518   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
1519 
1520   // push java thread (becomes first argument of C function)
1521 
1522   NOT_LP64(push(java_thread); number_of_arguments++);
1523   LP64_ONLY(mov(c_rarg0, r15_thread));
1524 
1525   // set last Java frame before call
1526   assert(last_java_sp != rbp, &quot;can&#39;t use ebp/rbp&quot;);
1527 
1528   // Only interpreter should have to set fp
1529   set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);
1530 
1531   // do the call, remove parameters
1532   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments);
1533 
1534   // restore the thread (cannot use the pushed argument since arguments
1535   // may be overwritten by C code generated by an optimizing compiler);
1536   // however can use the register value directly if it is callee saved.
1537   if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {
1538     // rdi &amp; rsi (also r15) are callee saved -&gt; nothing to do
1539 #ifdef ASSERT
1540     guarantee(java_thread != rax, &quot;change this code&quot;);
1541     push(rax);
1542     { Label L;
1543       get_thread(rax);
1544       cmpptr(java_thread, rax);
1545       jcc(Assembler::equal, L);
1546       STOP(&quot;MacroAssembler::call_VM_base: rdi not callee saved?&quot;);
1547       bind(L);
1548     }
1549     pop(rax);
1550 #endif
1551   } else {
1552     get_thread(java_thread);
1553   }
1554   // reset last Java frame
1555   // Only interpreter should have to clear fp
1556   reset_last_Java_frame(java_thread, true);
1557 
1558    // C++ interp handles this in the interpreter
1559   check_and_handle_popframe(java_thread);
1560   check_and_handle_earlyret(java_thread);
1561 
1562   if (check_exceptions) {
1563     // check for pending exceptions (java_thread is set upon return)
1564     cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
1565 #ifndef _LP64
1566     jump_cc(Assembler::notEqual,
1567             RuntimeAddress(StubRoutines::forward_exception_entry()));
1568 #else
1569     // This used to conditionally jump to forward_exception however it is
1570     // possible if we relocate that the branch will not reach. So we must jump
1571     // around so we can always reach
1572 
1573     Label ok;
1574     jcc(Assembler::equal, ok);
1575     jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
1576     bind(ok);
1577 #endif // LP64
1578   }
1579 
1580   // get oop result if there is one and reset the value in the thread
1581   if (oop_result-&gt;is_valid()) {
1582     get_vm_result(oop_result, java_thread);
1583   }
1584 }
1585 
1586 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
1587 
1588   // Calculate the value for last_Java_sp
1589   // somewhat subtle. call_VM does an intermediate call
1590   // which places a return address on the stack just under the
1591   // stack pointer as the user finsihed with it. This allows
1592   // use to retrieve last_Java_pc from last_Java_sp[-1].
1593   // On 32bit we then have to push additional args on the stack to accomplish
1594   // the actual requested call. On 64bit call_VM only can use register args
1595   // so the only extra space is the return address that call_VM created.
1596   // This hopefully explains the calculations here.
1597 
1598 #ifdef _LP64
1599   // We&#39;ve pushed one address, correct last_Java_sp
1600   lea(rax, Address(rsp, wordSize));
1601 #else
1602   lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));
1603 #endif // LP64
1604 
1605   call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);
1606 
1607 }
1608 
1609 // Use this method when MacroAssembler version of call_VM_leaf_base() should be called from Interpreter.
1610 void MacroAssembler::call_VM_leaf0(address entry_point) {
1611   MacroAssembler::call_VM_leaf_base(entry_point, 0);
1612 }
1613 
1614 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1615   call_VM_leaf_base(entry_point, number_of_arguments);
1616 }
1617 
1618 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1619   pass_arg0(this, arg_0);
1620   call_VM_leaf(entry_point, 1);
1621 }
1622 
1623 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1624 
1625   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1626   pass_arg1(this, arg_1);
1627   pass_arg0(this, arg_0);
1628   call_VM_leaf(entry_point, 2);
1629 }
1630 
1631 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1632   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1633   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1634   pass_arg2(this, arg_2);
1635   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1636   pass_arg1(this, arg_1);
1637   pass_arg0(this, arg_0);
1638   call_VM_leaf(entry_point, 3);
1639 }
1640 
1641 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1642   pass_arg0(this, arg_0);
1643   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1644 }
1645 
1646 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1647 
1648   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1649   pass_arg1(this, arg_1);
1650   pass_arg0(this, arg_0);
1651   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1652 }
1653 
1654 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1655   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1656   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1657   pass_arg2(this, arg_2);
1658   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1659   pass_arg1(this, arg_1);
1660   pass_arg0(this, arg_0);
1661   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1662 }
1663 
1664 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1665   LP64_ONLY(assert(arg_0 != c_rarg3, &quot;smashed arg&quot;));
1666   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1667   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1668   pass_arg3(this, arg_3);
1669   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1670   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1671   pass_arg2(this, arg_2);
1672   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1673   pass_arg1(this, arg_1);
1674   pass_arg0(this, arg_0);
1675   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1676 }
1677 
1678 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
1679   movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
1680   movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);
1681   verify_oop_msg(oop_result, &quot;broken oop in call_VM_base&quot;);
1682 }
1683 
1684 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
1685   movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
1686   movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);
1687 }
1688 
1689 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
1690 }
1691 
1692 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
1693 }
1694 
1695 void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {
1696   if (reachable(src1)) {
1697     cmpl(as_Address(src1), imm);
1698   } else {
1699     lea(rscratch1, src1);
1700     cmpl(Address(rscratch1, 0), imm);
1701   }
1702 }
1703 
1704 void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {
1705   assert(!src2.is_lval(), &quot;use cmpptr&quot;);
1706   if (reachable(src2)) {
1707     cmpl(src1, as_Address(src2));
1708   } else {
1709     lea(rscratch1, src2);
1710     cmpl(src1, Address(rscratch1, 0));
1711   }
1712 }
1713 
1714 void MacroAssembler::cmp32(Register src1, int32_t imm) {
1715   Assembler::cmpl(src1, imm);
1716 }
1717 
1718 void MacroAssembler::cmp32(Register src1, Address src2) {
1719   Assembler::cmpl(src1, src2);
1720 }
1721 
1722 void MacroAssembler::cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1723   ucomisd(opr1, opr2);
1724 
1725   Label L;
1726   if (unordered_is_less) {
1727     movl(dst, -1);
1728     jcc(Assembler::parity, L);
1729     jcc(Assembler::below , L);
1730     movl(dst, 0);
1731     jcc(Assembler::equal , L);
1732     increment(dst);
1733   } else { // unordered is greater
1734     movl(dst, 1);
1735     jcc(Assembler::parity, L);
1736     jcc(Assembler::above , L);
1737     movl(dst, 0);
1738     jcc(Assembler::equal , L);
1739     decrementl(dst);
1740   }
1741   bind(L);
1742 }
1743 
1744 void MacroAssembler::cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1745   ucomiss(opr1, opr2);
1746 
1747   Label L;
1748   if (unordered_is_less) {
1749     movl(dst, -1);
1750     jcc(Assembler::parity, L);
1751     jcc(Assembler::below , L);
1752     movl(dst, 0);
1753     jcc(Assembler::equal , L);
1754     increment(dst);
1755   } else { // unordered is greater
1756     movl(dst, 1);
1757     jcc(Assembler::parity, L);
1758     jcc(Assembler::above , L);
1759     movl(dst, 0);
1760     jcc(Assembler::equal , L);
1761     decrementl(dst);
1762   }
1763   bind(L);
1764 }
1765 
1766 
1767 void MacroAssembler::cmp8(AddressLiteral src1, int imm) {
1768   if (reachable(src1)) {
1769     cmpb(as_Address(src1), imm);
1770   } else {
1771     lea(rscratch1, src1);
1772     cmpb(Address(rscratch1, 0), imm);
1773   }
1774 }
1775 
1776 void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {
1777 #ifdef _LP64
1778   if (src2.is_lval()) {
1779     movptr(rscratch1, src2);
1780     Assembler::cmpq(src1, rscratch1);
1781   } else if (reachable(src2)) {
1782     cmpq(src1, as_Address(src2));
1783   } else {
1784     lea(rscratch1, src2);
1785     Assembler::cmpq(src1, Address(rscratch1, 0));
1786   }
1787 #else
1788   if (src2.is_lval()) {
1789     cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1790   } else {
1791     cmpl(src1, as_Address(src2));
1792   }
1793 #endif // _LP64
1794 }
1795 
1796 void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {
1797   assert(src2.is_lval(), &quot;not a mem-mem compare&quot;);
1798 #ifdef _LP64
1799   // moves src2&#39;s literal address
1800   movptr(rscratch1, src2);
1801   Assembler::cmpq(src1, rscratch1);
1802 #else
1803   cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1804 #endif // _LP64
1805 }
1806 
1807 void MacroAssembler::cmpoop(Register src1, Register src2) {
1808   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1809   bs-&gt;obj_equals(this, src1, src2);
1810 }
1811 
1812 void MacroAssembler::cmpoop(Register src1, Address src2) {
1813   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1814   bs-&gt;obj_equals(this, src1, src2);
1815 }
1816 
1817 #ifdef _LP64
1818 void MacroAssembler::cmpoop(Register src1, jobject src2) {
1819   movoop(rscratch1, src2);
1820   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1821   bs-&gt;obj_equals(this, src1, rscratch1);
1822 }
1823 #endif
1824 
1825 void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {
1826   if (reachable(adr)) {
1827     lock();
1828     cmpxchgptr(reg, as_Address(adr));
1829   } else {
1830     lea(rscratch1, adr);
1831     lock();
1832     cmpxchgptr(reg, Address(rscratch1, 0));
1833   }
1834 }
1835 
1836 void MacroAssembler::cmpxchgptr(Register reg, Address adr) {
1837   LP64_ONLY(cmpxchgq(reg, adr)) NOT_LP64(cmpxchgl(reg, adr));
1838 }
1839 
1840 void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {
1841   if (reachable(src)) {
1842     Assembler::comisd(dst, as_Address(src));
1843   } else {
1844     lea(rscratch1, src);
1845     Assembler::comisd(dst, Address(rscratch1, 0));
1846   }
1847 }
1848 
1849 void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {
1850   if (reachable(src)) {
1851     Assembler::comiss(dst, as_Address(src));
1852   } else {
1853     lea(rscratch1, src);
1854     Assembler::comiss(dst, Address(rscratch1, 0));
1855   }
1856 }
1857 
1858 
1859 void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {
1860   Condition negated_cond = negate_condition(cond);
1861   Label L;
1862   jcc(negated_cond, L);
1863   pushf(); // Preserve flags
1864   atomic_incl(counter_addr);
1865   popf();
1866   bind(L);
1867 }
1868 
1869 int MacroAssembler::corrected_idivl(Register reg) {
1870   // Full implementation of Java idiv and irem; checks for
1871   // special case as described in JVM spec., p.243 &amp; p.271.
1872   // The function returns the (pc) offset of the idivl
1873   // instruction - may be needed for implicit exceptions.
1874   //
1875   //         normal case                           special case
1876   //
1877   // input : rax,: dividend                         min_int
1878   //         reg: divisor   (may not be rax,/rdx)   -1
1879   //
1880   // output: rax,: quotient  (= rax, idiv reg)       min_int
1881   //         rdx: remainder (= rax, irem reg)       0
1882   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax, or rdx register&quot;);
1883   const int min_int = 0x80000000;
1884   Label normal_case, special_case;
1885 
1886   // check for special case
1887   cmpl(rax, min_int);
1888   jcc(Assembler::notEqual, normal_case);
1889   xorl(rdx, rdx); // prepare rdx for possible special case (where remainder = 0)
1890   cmpl(reg, -1);
1891   jcc(Assembler::equal, special_case);
1892 
1893   // handle normal case
1894   bind(normal_case);
1895   cdql();
1896   int idivl_offset = offset();
1897   idivl(reg);
1898 
1899   // normal and special case exit
1900   bind(special_case);
1901 
1902   return idivl_offset;
1903 }
1904 
1905 
1906 
1907 void MacroAssembler::decrementl(Register reg, int value) {
1908   if (value == min_jint) {subl(reg, value) ; return; }
1909   if (value &lt;  0) { incrementl(reg, -value); return; }
1910   if (value == 0) {                        ; return; }
1911   if (value == 1 &amp;&amp; UseIncDec) { decl(reg) ; return; }
1912   /* else */      { subl(reg, value)       ; return; }
1913 }
1914 
1915 void MacroAssembler::decrementl(Address dst, int value) {
1916   if (value == min_jint) {subl(dst, value) ; return; }
1917   if (value &lt;  0) { incrementl(dst, -value); return; }
1918   if (value == 0) {                        ; return; }
1919   if (value == 1 &amp;&amp; UseIncDec) { decl(dst) ; return; }
1920   /* else */      { subl(dst, value)       ; return; }
1921 }
1922 
1923 void MacroAssembler::division_with_shift (Register reg, int shift_value) {
1924   assert (shift_value &gt; 0, &quot;illegal shift value&quot;);
1925   Label _is_positive;
1926   testl (reg, reg);
1927   jcc (Assembler::positive, _is_positive);
1928   int offset = (1 &lt;&lt; shift_value) - 1 ;
1929 
1930   if (offset == 1) {
1931     incrementl(reg);
1932   } else {
1933     addl(reg, offset);
1934   }
1935 
1936   bind (_is_positive);
1937   sarl(reg, shift_value);
1938 }
1939 
1940 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
1941   if (reachable(src)) {
1942     Assembler::divsd(dst, as_Address(src));
1943   } else {
1944     lea(rscratch1, src);
1945     Assembler::divsd(dst, Address(rscratch1, 0));
1946   }
1947 }
1948 
1949 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
1950   if (reachable(src)) {
1951     Assembler::divss(dst, as_Address(src));
1952   } else {
1953     lea(rscratch1, src);
1954     Assembler::divss(dst, Address(rscratch1, 0));
1955   }
1956 }
1957 
1958 void MacroAssembler::enter() {
1959   push(rbp);
1960   mov(rbp, rsp);
1961 }
1962 
1963 // A 5 byte nop that is safe for patching (see patch_verified_entry)
1964 void MacroAssembler::fat_nop() {
1965   if (UseAddressNop) {
1966     addr_nop_5();
1967   } else {
1968     emit_int8(0x26); // es:
1969     emit_int8(0x2e); // cs:
1970     emit_int8(0x64); // fs:
1971     emit_int8(0x65); // gs:
1972     emit_int8((unsigned char)0x90);
1973   }
1974 }
1975 
1976 #ifndef _LP64
1977 void MacroAssembler::fcmp(Register tmp) {
1978   fcmp(tmp, 1, true, true);
1979 }
1980 
1981 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
1982   assert(!pop_right || pop_left, &quot;usage error&quot;);
1983   if (VM_Version::supports_cmov()) {
1984     assert(tmp == noreg, &quot;unneeded temp&quot;);
1985     if (pop_left) {
1986       fucomip(index);
1987     } else {
1988       fucomi(index);
1989     }
1990     if (pop_right) {
1991       fpop();
1992     }
1993   } else {
1994     assert(tmp != noreg, &quot;need temp&quot;);
1995     if (pop_left) {
1996       if (pop_right) {
1997         fcompp();
1998       } else {
1999         fcomp(index);
2000       }
2001     } else {
2002       fcom(index);
2003     }
2004     // convert FPU condition into eflags condition via rax,
2005     save_rax(tmp);
2006     fwait(); fnstsw_ax();
2007     sahf();
2008     restore_rax(tmp);
2009   }
2010   // condition codes set as follows:
2011   //
2012   // CF (corresponds to C0) if x &lt; y
2013   // PF (corresponds to C2) if unordered
2014   // ZF (corresponds to C3) if x = y
2015 }
2016 
2017 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {
2018   fcmp2int(dst, unordered_is_less, 1, true, true);
2019 }
2020 
2021 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {
2022   fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);
2023   Label L;
2024   if (unordered_is_less) {
2025     movl(dst, -1);
2026     jcc(Assembler::parity, L);
2027     jcc(Assembler::below , L);
2028     movl(dst, 0);
2029     jcc(Assembler::equal , L);
2030     increment(dst);
2031   } else { // unordered is greater
2032     movl(dst, 1);
2033     jcc(Assembler::parity, L);
2034     jcc(Assembler::above , L);
2035     movl(dst, 0);
2036     jcc(Assembler::equal , L);
2037     decrementl(dst);
2038   }
2039   bind(L);
2040 }
2041 
2042 void MacroAssembler::fld_d(AddressLiteral src) {
2043   fld_d(as_Address(src));
2044 }
2045 
2046 void MacroAssembler::fld_s(AddressLiteral src) {
2047   fld_s(as_Address(src));
2048 }
2049 
<a name="1" id="anc1"></a><span class="line-removed">2050 void MacroAssembler::fld_x(AddressLiteral src) {</span>
<span class="line-removed">2051   Assembler::fld_x(as_Address(src));</span>
<span class="line-removed">2052 }</span>
<span class="line-removed">2053 </span>
2054 void MacroAssembler::fldcw(AddressLiteral src) {
2055   Assembler::fldcw(as_Address(src));
2056 }
2057 
2058 void MacroAssembler::fpop() {
2059   ffree();
2060   fincstp();
2061 }
2062 
2063 void MacroAssembler::fremr(Register tmp) {
2064   save_rax(tmp);
2065   { Label L;
2066     bind(L);
2067     fprem();
2068     fwait(); fnstsw_ax();
2069     sahf();
2070     jcc(Assembler::parity, L);
2071   }
2072   restore_rax(tmp);
2073   // Result is in ST0.
2074   // Note: fxch &amp; fpop to get rid of ST1
2075   // (otherwise FPU stack could overflow eventually)
2076   fxch(1);
2077   fpop();
2078 }
2079 
2080 void MacroAssembler::empty_FPU_stack() {
2081   if (VM_Version::supports_mmx()) {
2082     emms();
2083   } else {
2084     for (int i = 8; i-- &gt; 0; ) ffree(i);
2085   }
2086 }
2087 #endif // !LP64
2088 
2089 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
2090   if (reachable(src)) {
2091     Assembler::mulpd(dst, as_Address(src));
2092   } else {
2093     lea(rscratch1, src);
2094     Assembler::mulpd(dst, Address(rscratch1, 0));
2095   }
2096 }
2097 
2098 void MacroAssembler::load_float(Address src) {
2099 #ifdef _LP64
2100   movflt(xmm0, src);
2101 #else
2102   if (UseSSE &gt;= 1) {
2103     movflt(xmm0, src);
2104   } else {
2105     fld_s(src);
2106   }
2107 #endif // LP64
2108 }
2109 
2110 void MacroAssembler::store_float(Address dst) {
2111 #ifdef _LP64
2112   movflt(dst, xmm0);
2113 #else
2114   if (UseSSE &gt;= 1) {
2115     movflt(dst, xmm0);
2116   } else {
2117     fstp_s(dst);
2118   }
2119 #endif // LP64
2120 }
2121 
2122 void MacroAssembler::load_double(Address src) {
2123 #ifdef _LP64
2124   movdbl(xmm0, src);
2125 #else
2126   if (UseSSE &gt;= 2) {
2127     movdbl(xmm0, src);
2128   } else {
2129     fld_d(src);
2130   }
2131 #endif // LP64
2132 }
2133 
2134 void MacroAssembler::store_double(Address dst) {
2135 #ifdef _LP64
2136   movdbl(dst, xmm0);
2137 #else
2138   if (UseSSE &gt;= 2) {
2139     movdbl(dst, xmm0);
2140   } else {
2141     fstp_d(dst);
2142   }
2143 #endif // LP64
2144 }
2145 
2146 // dst = c = a * b + c
2147 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2148   Assembler::vfmadd231sd(c, a, b);
2149   if (dst != c) {
2150     movdbl(dst, c);
2151   }
2152 }
2153 
2154 // dst = c = a * b + c
2155 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2156   Assembler::vfmadd231ss(c, a, b);
2157   if (dst != c) {
2158     movflt(dst, c);
2159   }
2160 }
2161 
2162 // dst = c = a * b + c
2163 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2164   Assembler::vfmadd231pd(c, a, b, vector_len);
2165   if (dst != c) {
2166     vmovdqu(dst, c);
2167   }
2168 }
2169 
2170 // dst = c = a * b + c
2171 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2172   Assembler::vfmadd231ps(c, a, b, vector_len);
2173   if (dst != c) {
2174     vmovdqu(dst, c);
2175   }
2176 }
2177 
2178 // dst = c = a * b + c
2179 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2180   Assembler::vfmadd231pd(c, a, b, vector_len);
2181   if (dst != c) {
2182     vmovdqu(dst, c);
2183   }
2184 }
2185 
2186 // dst = c = a * b + c
2187 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2188   Assembler::vfmadd231ps(c, a, b, vector_len);
2189   if (dst != c) {
2190     vmovdqu(dst, c);
2191   }
2192 }
2193 
2194 void MacroAssembler::incrementl(AddressLiteral dst) {
2195   if (reachable(dst)) {
2196     incrementl(as_Address(dst));
2197   } else {
2198     lea(rscratch1, dst);
2199     incrementl(Address(rscratch1, 0));
2200   }
2201 }
2202 
2203 void MacroAssembler::incrementl(ArrayAddress dst) {
2204   incrementl(as_Address(dst));
2205 }
2206 
2207 void MacroAssembler::incrementl(Register reg, int value) {
2208   if (value == min_jint) {addl(reg, value) ; return; }
2209   if (value &lt;  0) { decrementl(reg, -value); return; }
2210   if (value == 0) {                        ; return; }
2211   if (value == 1 &amp;&amp; UseIncDec) { incl(reg) ; return; }
2212   /* else */      { addl(reg, value)       ; return; }
2213 }
2214 
2215 void MacroAssembler::incrementl(Address dst, int value) {
2216   if (value == min_jint) {addl(dst, value) ; return; }
2217   if (value &lt;  0) { decrementl(dst, -value); return; }
2218   if (value == 0) {                        ; return; }
2219   if (value == 1 &amp;&amp; UseIncDec) { incl(dst) ; return; }
2220   /* else */      { addl(dst, value)       ; return; }
2221 }
2222 
2223 void MacroAssembler::jump(AddressLiteral dst) {
2224   if (reachable(dst)) {
2225     jmp_literal(dst.target(), dst.rspec());
2226   } else {
2227     lea(rscratch1, dst);
2228     jmp(rscratch1);
2229   }
2230 }
2231 
2232 void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {
2233   if (reachable(dst)) {
2234     InstructionMark im(this);
2235     relocate(dst.reloc());
2236     const int short_size = 2;
2237     const int long_size = 6;
2238     int offs = (intptr_t)dst.target() - ((intptr_t)pc());
2239     if (dst.reloc() == relocInfo::none &amp;&amp; is8bit(offs - short_size)) {
2240       // 0111 tttn #8-bit disp
2241       emit_int8(0x70 | cc);
2242       emit_int8((offs - short_size) &amp; 0xFF);
2243     } else {
2244       // 0000 1111 1000 tttn #32-bit disp
2245       emit_int8(0x0F);
2246       emit_int8((unsigned char)(0x80 | cc));
2247       emit_int32(offs - long_size);
2248     }
2249   } else {
2250 #ifdef ASSERT
2251     warning(&quot;reversing conditional branch&quot;);
2252 #endif /* ASSERT */
2253     Label skip;
2254     jccb(reverse[cc], skip);
2255     lea(rscratch1, dst);
2256     Assembler::jmp(rscratch1);
2257     bind(skip);
2258   }
2259 }
2260 
<a name="2" id="anc2"></a>



2261 void MacroAssembler::ldmxcsr(AddressLiteral src) {
2262   if (reachable(src)) {
2263     Assembler::ldmxcsr(as_Address(src));
2264   } else {
2265     lea(rscratch1, src);
2266     Assembler::ldmxcsr(Address(rscratch1, 0));
2267   }
2268 }
2269 
2270 int MacroAssembler::load_signed_byte(Register dst, Address src) {
2271   int off;
2272   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2273     off = offset();
2274     movsbl(dst, src); // movsxb
2275   } else {
2276     off = load_unsigned_byte(dst, src);
2277     shll(dst, 24);
2278     sarl(dst, 24);
2279   }
2280   return off;
2281 }
2282 
2283 // Note: load_signed_short used to be called load_signed_word.
2284 // Although the &#39;w&#39; in x86 opcodes refers to the term &quot;word&quot; in the assembler
2285 // manual, which means 16 bits, that usage is found nowhere in HotSpot code.
2286 // The term &quot;word&quot; in HotSpot means a 32- or 64-bit machine word.
2287 int MacroAssembler::load_signed_short(Register dst, Address src) {
2288   int off;
2289   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2290     // This is dubious to me since it seems safe to do a signed 16 =&gt; 64 bit
2291     // version but this is what 64bit has always done. This seems to imply
2292     // that users are only using 32bits worth.
2293     off = offset();
2294     movswl(dst, src); // movsxw
2295   } else {
2296     off = load_unsigned_short(dst, src);
2297     shll(dst, 16);
2298     sarl(dst, 16);
2299   }
2300   return off;
2301 }
2302 
2303 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
2304   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2305   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2306   int off;
2307   if (LP64_ONLY(true || ) VM_Version::is_P6() || src.uses(dst)) {
2308     off = offset();
2309     movzbl(dst, src); // movzxb
2310   } else {
2311     xorl(dst, dst);
2312     off = offset();
2313     movb(dst, src);
2314   }
2315   return off;
2316 }
2317 
2318 // Note: load_unsigned_short used to be called load_unsigned_word.
2319 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
2320   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2321   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2322   int off;
2323   if (LP64_ONLY(true ||) VM_Version::is_P6() || src.uses(dst)) {
2324     off = offset();
2325     movzwl(dst, src); // movzxw
2326   } else {
2327     xorl(dst, dst);
2328     off = offset();
2329     movw(dst, src);
2330   }
2331   return off;
2332 }
2333 
2334 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
2335   switch (size_in_bytes) {
2336 #ifndef _LP64
2337   case  8:
2338     assert(dst2 != noreg, &quot;second dest register required&quot;);
2339     movl(dst,  src);
2340     movl(dst2, src.plus_disp(BytesPerInt));
2341     break;
2342 #else
2343   case  8:  movq(dst, src); break;
2344 #endif
2345   case  4:  movl(dst, src); break;
2346   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
2347   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
2348   default:  ShouldNotReachHere();
2349   }
2350 }
2351 
2352 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
2353   switch (size_in_bytes) {
2354 #ifndef _LP64
2355   case  8:
2356     assert(src2 != noreg, &quot;second source register required&quot;);
2357     movl(dst,                        src);
2358     movl(dst.plus_disp(BytesPerInt), src2);
2359     break;
2360 #else
2361   case  8:  movq(dst, src); break;
2362 #endif
2363   case  4:  movl(dst, src); break;
2364   case  2:  movw(dst, src); break;
2365   case  1:  movb(dst, src); break;
2366   default:  ShouldNotReachHere();
2367   }
2368 }
2369 
2370 void MacroAssembler::mov32(AddressLiteral dst, Register src) {
2371   if (reachable(dst)) {
2372     movl(as_Address(dst), src);
2373   } else {
2374     lea(rscratch1, dst);
2375     movl(Address(rscratch1, 0), src);
2376   }
2377 }
2378 
2379 void MacroAssembler::mov32(Register dst, AddressLiteral src) {
2380   if (reachable(src)) {
2381     movl(dst, as_Address(src));
2382   } else {
2383     lea(rscratch1, src);
2384     movl(dst, Address(rscratch1, 0));
2385   }
2386 }
2387 
2388 // C++ bool manipulation
2389 
2390 void MacroAssembler::movbool(Register dst, Address src) {
2391   if(sizeof(bool) == 1)
2392     movb(dst, src);
2393   else if(sizeof(bool) == 2)
2394     movw(dst, src);
2395   else if(sizeof(bool) == 4)
2396     movl(dst, src);
2397   else
2398     // unsupported
2399     ShouldNotReachHere();
2400 }
2401 
2402 void MacroAssembler::movbool(Address dst, bool boolconst) {
2403   if(sizeof(bool) == 1)
2404     movb(dst, (int) boolconst);
2405   else if(sizeof(bool) == 2)
2406     movw(dst, (int) boolconst);
2407   else if(sizeof(bool) == 4)
2408     movl(dst, (int) boolconst);
2409   else
2410     // unsupported
2411     ShouldNotReachHere();
2412 }
2413 
2414 void MacroAssembler::movbool(Address dst, Register src) {
2415   if(sizeof(bool) == 1)
2416     movb(dst, src);
2417   else if(sizeof(bool) == 2)
2418     movw(dst, src);
2419   else if(sizeof(bool) == 4)
2420     movl(dst, src);
2421   else
2422     // unsupported
2423     ShouldNotReachHere();
2424 }
2425 
2426 void MacroAssembler::movbyte(ArrayAddress dst, int src) {
2427   movb(as_Address(dst), src);
2428 }
2429 
2430 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
2431   if (reachable(src)) {
2432     movdl(dst, as_Address(src));
2433   } else {
2434     lea(rscratch1, src);
2435     movdl(dst, Address(rscratch1, 0));
2436   }
2437 }
2438 
2439 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
2440   if (reachable(src)) {
2441     movq(dst, as_Address(src));
2442   } else {
2443     lea(rscratch1, src);
2444     movq(dst, Address(rscratch1, 0));
2445   }
2446 }
2447 
2448 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
2449   if (reachable(src)) {
2450     if (UseXmmLoadAndClearUpper) {
2451       movsd (dst, as_Address(src));
2452     } else {
2453       movlpd(dst, as_Address(src));
2454     }
2455   } else {
2456     lea(rscratch1, src);
2457     if (UseXmmLoadAndClearUpper) {
2458       movsd (dst, Address(rscratch1, 0));
2459     } else {
2460       movlpd(dst, Address(rscratch1, 0));
2461     }
2462   }
2463 }
2464 
2465 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
2466   if (reachable(src)) {
2467     movss(dst, as_Address(src));
2468   } else {
2469     lea(rscratch1, src);
2470     movss(dst, Address(rscratch1, 0));
2471   }
2472 }
2473 
2474 void MacroAssembler::movptr(Register dst, Register src) {
2475   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2476 }
2477 
2478 void MacroAssembler::movptr(Register dst, Address src) {
2479   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2480 }
2481 
2482 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
2483 void MacroAssembler::movptr(Register dst, intptr_t src) {
2484   LP64_ONLY(mov64(dst, src)) NOT_LP64(movl(dst, src));
2485 }
2486 
2487 void MacroAssembler::movptr(Address dst, Register src) {
2488   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2489 }
2490 
2491 void MacroAssembler::movdqu(Address dst, XMMRegister src) {
2492     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2493     Assembler::movdqu(dst, src);
2494 }
2495 
2496 void MacroAssembler::movdqu(XMMRegister dst, Address src) {
2497     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2498     Assembler::movdqu(dst, src);
2499 }
2500 
2501 void MacroAssembler::movdqu(XMMRegister dst, XMMRegister src) {
2502     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2503     Assembler::movdqu(dst, src);
2504 }
2505 
2506 void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {
2507   if (reachable(src)) {
2508     movdqu(dst, as_Address(src));
2509   } else {
2510     lea(scratchReg, src);
2511     movdqu(dst, Address(scratchReg, 0));
2512   }
2513 }
2514 
2515 void MacroAssembler::vmovdqu(Address dst, XMMRegister src) {
2516     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2517     Assembler::vmovdqu(dst, src);
2518 }
2519 
2520 void MacroAssembler::vmovdqu(XMMRegister dst, Address src) {
2521     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2522     Assembler::vmovdqu(dst, src);
2523 }
2524 
2525 void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2526     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2527     Assembler::vmovdqu(dst, src);
2528 }
2529 
2530 void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2531   if (reachable(src)) {
2532     vmovdqu(dst, as_Address(src));
2533   }
2534   else {
2535     lea(scratch_reg, src);
2536     vmovdqu(dst, Address(scratch_reg, 0));
2537   }
2538 }
2539 
2540 void MacroAssembler::evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {
2541   if (reachable(src)) {
2542     Assembler::evmovdquq(dst, as_Address(src), vector_len);
2543   } else {
2544     lea(rscratch, src);
2545     Assembler::evmovdquq(dst, Address(rscratch, 0), vector_len);
2546   }
2547 }
2548 
2549 void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {
2550   if (reachable(src)) {
2551     Assembler::movdqa(dst, as_Address(src));
2552   } else {
2553     lea(rscratch1, src);
2554     Assembler::movdqa(dst, Address(rscratch1, 0));
2555   }
2556 }
2557 
2558 void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {
2559   if (reachable(src)) {
2560     Assembler::movsd(dst, as_Address(src));
2561   } else {
2562     lea(rscratch1, src);
2563     Assembler::movsd(dst, Address(rscratch1, 0));
2564   }
2565 }
2566 
2567 void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {
2568   if (reachable(src)) {
2569     Assembler::movss(dst, as_Address(src));
2570   } else {
2571     lea(rscratch1, src);
2572     Assembler::movss(dst, Address(rscratch1, 0));
2573   }
2574 }
2575 
2576 void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {
2577   if (reachable(src)) {
2578     Assembler::mulsd(dst, as_Address(src));
2579   } else {
2580     lea(rscratch1, src);
2581     Assembler::mulsd(dst, Address(rscratch1, 0));
2582   }
2583 }
2584 
2585 void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {
2586   if (reachable(src)) {
2587     Assembler::mulss(dst, as_Address(src));
2588   } else {
2589     lea(rscratch1, src);
2590     Assembler::mulss(dst, Address(rscratch1, 0));
2591   }
2592 }
2593 
2594 void MacroAssembler::null_check(Register reg, int offset) {
2595   if (needs_explicit_null_check(offset)) {
2596     // provoke OS NULL exception if reg = NULL by
2597     // accessing M[reg] w/o changing any (non-CC) registers
2598     // NOTE: cmpl is plenty here to provoke a segv
2599     cmpptr(rax, Address(reg, 0));
2600     // Note: should probably use testl(rax, Address(reg, 0));
2601     //       may be shorter code (however, this version of
2602     //       testl needs to be implemented first)
2603   } else {
2604     // nothing to do, (later) access of M[reg + offset]
2605     // will provoke OS NULL exception if reg = NULL
2606   }
2607 }
2608 
2609 void MacroAssembler::os_breakpoint() {
2610   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
2611   // (e.g., MSVC can&#39;t call ps() otherwise)
2612   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
2613 }
2614 
2615 void MacroAssembler::unimplemented(const char* what) {
2616   const char* buf = NULL;
2617   {
2618     ResourceMark rm;
2619     stringStream ss;
2620     ss.print(&quot;unimplemented: %s&quot;, what);
2621     buf = code_string(ss.as_string());
2622   }
2623   stop(buf);
2624 }
2625 
2626 #ifdef _LP64
2627 #define XSTATE_BV 0x200
2628 #endif
2629 
2630 void MacroAssembler::pop_CPU_state() {
2631   pop_FPU_state();
2632   pop_IU_state();
2633 }
2634 
2635 void MacroAssembler::pop_FPU_state() {
2636 #ifndef _LP64
2637   frstor(Address(rsp, 0));
2638 #else
2639   fxrstor(Address(rsp, 0));
2640 #endif
2641   addptr(rsp, FPUStateSizeInWords * wordSize);
2642 }
2643 
2644 void MacroAssembler::pop_IU_state() {
2645   popa();
2646   LP64_ONLY(addq(rsp, 8));
2647   popf();
2648 }
2649 
2650 // Save Integer and Float state
2651 // Warning: Stack must be 16 byte aligned (64bit)
2652 void MacroAssembler::push_CPU_state() {
2653   push_IU_state();
2654   push_FPU_state();
2655 }
2656 
2657 void MacroAssembler::push_FPU_state() {
2658   subptr(rsp, FPUStateSizeInWords * wordSize);
2659 #ifndef _LP64
2660   fnsave(Address(rsp, 0));
2661   fwait();
2662 #else
2663   fxsave(Address(rsp, 0));
2664 #endif // LP64
2665 }
2666 
2667 void MacroAssembler::push_IU_state() {
2668   // Push flags first because pusha kills them
2669   pushf();
2670   // Make sure rsp stays 16-byte aligned
2671   LP64_ONLY(subq(rsp, 8));
2672   pusha();
2673 }
2674 
2675 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
2676   if (!java_thread-&gt;is_valid()) {
2677     java_thread = rdi;
2678     get_thread(java_thread);
2679   }
2680   // we must set sp to zero to clear frame
2681   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
2682   if (clear_fp) {
2683     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
2684   }
2685 
2686   // Always clear the pc because it could have been set by make_walkable()
2687   movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
2688 
2689   vzeroupper();
2690 }
2691 
2692 void MacroAssembler::restore_rax(Register tmp) {
2693   if (tmp == noreg) pop(rax);
2694   else if (tmp != rax) mov(rax, tmp);
2695 }
2696 
2697 void MacroAssembler::round_to(Register reg, int modulus) {
2698   addptr(reg, modulus - 1);
2699   andptr(reg, -modulus);
2700 }
2701 
2702 void MacroAssembler::save_rax(Register tmp) {
2703   if (tmp == noreg) push(rax);
2704   else if (tmp != rax) mov(tmp, rax);
2705 }
2706 
2707 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
2708 #ifdef _LP64
2709   assert(thread_reg == r15_thread, &quot;should be&quot;);
2710 #else
2711   if (thread_reg == noreg) {
2712     thread_reg = temp_reg;
2713     get_thread(thread_reg);
2714   }
2715 #endif
2716   testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2717   jcc(Assembler::notZero, slow_path); // handshake bit set implies poll
2718 }
2719 
2720 // Calls to C land
2721 //
2722 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
2723 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
2724 // has to be reset to 0. This is required to allow proper stack traversal.
2725 void MacroAssembler::set_last_Java_frame(Register java_thread,
2726                                          Register last_java_sp,
2727                                          Register last_java_fp,
2728                                          address  last_java_pc) {
2729   vzeroupper();
2730   // determine java_thread register
2731   if (!java_thread-&gt;is_valid()) {
2732     java_thread = rdi;
2733     get_thread(java_thread);
2734   }
2735   // determine last_java_sp register
2736   if (!last_java_sp-&gt;is_valid()) {
2737     last_java_sp = rsp;
2738   }
2739 
2740   // last_java_fp is optional
2741 
2742   if (last_java_fp-&gt;is_valid()) {
2743     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);
2744   }
2745 
2746   // last_java_pc is optional
2747 
2748   if (last_java_pc != NULL) {
2749     lea(Address(java_thread,
2750                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),
2751         InternalAddress(last_java_pc));
2752 
2753   }
2754   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
2755 }
2756 
2757 void MacroAssembler::shlptr(Register dst, int imm8) {
2758   LP64_ONLY(shlq(dst, imm8)) NOT_LP64(shll(dst, imm8));
2759 }
2760 
2761 void MacroAssembler::shrptr(Register dst, int imm8) {
2762   LP64_ONLY(shrq(dst, imm8)) NOT_LP64(shrl(dst, imm8));
2763 }
2764 
2765 void MacroAssembler::sign_extend_byte(Register reg) {
2766   if (LP64_ONLY(true ||) (VM_Version::is_P6() &amp;&amp; reg-&gt;has_byte_register())) {
2767     movsbl(reg, reg); // movsxb
2768   } else {
2769     shll(reg, 24);
2770     sarl(reg, 24);
2771   }
2772 }
2773 
2774 void MacroAssembler::sign_extend_short(Register reg) {
2775   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2776     movswl(reg, reg); // movsxw
2777   } else {
2778     shll(reg, 16);
2779     sarl(reg, 16);
2780   }
2781 }
2782 
2783 void MacroAssembler::testl(Register dst, AddressLiteral src) {
2784   assert(reachable(src), &quot;Address should be reachable&quot;);
2785   testl(dst, as_Address(src));
2786 }
2787 
2788 void MacroAssembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
2789   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2790   Assembler::pcmpeqb(dst, src);
2791 }
2792 
2793 void MacroAssembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
2794   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2795   Assembler::pcmpeqw(dst, src);
2796 }
2797 
2798 void MacroAssembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
2799   assert((dst-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2800   Assembler::pcmpestri(dst, src, imm8);
2801 }
2802 
2803 void MacroAssembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
2804   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2805   Assembler::pcmpestri(dst, src, imm8);
2806 }
2807 
2808 void MacroAssembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
2809   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2810   Assembler::pmovzxbw(dst, src);
2811 }
2812 
2813 void MacroAssembler::pmovzxbw(XMMRegister dst, Address src) {
2814   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2815   Assembler::pmovzxbw(dst, src);
2816 }
2817 
2818 void MacroAssembler::pmovmskb(Register dst, XMMRegister src) {
2819   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2820   Assembler::pmovmskb(dst, src);
2821 }
2822 
2823 void MacroAssembler::ptest(XMMRegister dst, XMMRegister src) {
2824   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2825   Assembler::ptest(dst, src);
2826 }
2827 
2828 void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {
2829   if (reachable(src)) {
2830     Assembler::sqrtsd(dst, as_Address(src));
2831   } else {
2832     lea(rscratch1, src);
2833     Assembler::sqrtsd(dst, Address(rscratch1, 0));
2834   }
2835 }
2836 
2837 void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {
2838   if (reachable(src)) {
2839     Assembler::sqrtss(dst, as_Address(src));
2840   } else {
2841     lea(rscratch1, src);
2842     Assembler::sqrtss(dst, Address(rscratch1, 0));
2843   }
2844 }
2845 
2846 void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {
2847   if (reachable(src)) {
2848     Assembler::subsd(dst, as_Address(src));
2849   } else {
2850     lea(rscratch1, src);
2851     Assembler::subsd(dst, Address(rscratch1, 0));
2852   }
2853 }
2854 
2855 void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {
2856   if (reachable(src)) {
2857     Assembler::roundsd(dst, as_Address(src), rmode);
2858   } else {
2859     lea(scratch_reg, src);
2860     Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);
2861   }
2862 }
2863 
2864 void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {
2865   if (reachable(src)) {
2866     Assembler::subss(dst, as_Address(src));
2867   } else {
2868     lea(rscratch1, src);
2869     Assembler::subss(dst, Address(rscratch1, 0));
2870   }
2871 }
2872 
2873 void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {
2874   if (reachable(src)) {
2875     Assembler::ucomisd(dst, as_Address(src));
2876   } else {
2877     lea(rscratch1, src);
2878     Assembler::ucomisd(dst, Address(rscratch1, 0));
2879   }
2880 }
2881 
2882 void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {
2883   if (reachable(src)) {
2884     Assembler::ucomiss(dst, as_Address(src));
2885   } else {
2886     lea(rscratch1, src);
2887     Assembler::ucomiss(dst, Address(rscratch1, 0));
2888   }
2889 }
2890 
2891 void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2892   // Used in sign-bit flipping with aligned address.
2893   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2894   if (reachable(src)) {
2895     Assembler::xorpd(dst, as_Address(src));
2896   } else {
2897     lea(scratch_reg, src);
2898     Assembler::xorpd(dst, Address(scratch_reg, 0));
2899   }
2900 }
2901 
2902 void MacroAssembler::xorpd(XMMRegister dst, XMMRegister src) {
2903   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
2904     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
2905   }
2906   else {
2907     Assembler::xorpd(dst, src);
2908   }
2909 }
2910 
2911 void MacroAssembler::xorps(XMMRegister dst, XMMRegister src) {
2912   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
2913     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
2914   } else {
2915     Assembler::xorps(dst, src);
2916   }
2917 }
2918 
2919 void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2920   // Used in sign-bit flipping with aligned address.
2921   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2922   if (reachable(src)) {
2923     Assembler::xorps(dst, as_Address(src));
2924   } else {
2925     lea(scratch_reg, src);
2926     Assembler::xorps(dst, Address(scratch_reg, 0));
2927   }
2928 }
2929 
2930 void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {
2931   // Used in sign-bit flipping with aligned address.
2932   bool aligned_adr = (((intptr_t)src.target() &amp; 15) == 0);
2933   assert((UseAVX &gt; 0) || aligned_adr, &quot;SSE mode requires address alignment 16 bytes&quot;);
2934   if (reachable(src)) {
2935     Assembler::pshufb(dst, as_Address(src));
2936   } else {
2937     lea(rscratch1, src);
2938     Assembler::pshufb(dst, Address(rscratch1, 0));
2939   }
2940 }
2941 
2942 // AVX 3-operands instructions
2943 
2944 void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
2945   if (reachable(src)) {
2946     vaddsd(dst, nds, as_Address(src));
2947   } else {
2948     lea(rscratch1, src);
2949     vaddsd(dst, nds, Address(rscratch1, 0));
2950   }
2951 }
2952 
2953 void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
2954   if (reachable(src)) {
2955     vaddss(dst, nds, as_Address(src));
2956   } else {
2957     lea(rscratch1, src);
2958     vaddss(dst, nds, Address(rscratch1, 0));
2959   }
2960 }
2961 
2962 void MacroAssembler::vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {
2963   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
2964   if (reachable(src)) {
2965     Assembler::vpaddd(dst, nds, as_Address(src), vector_len);
2966   } else {
2967     lea(rscratch, src);
2968     Assembler::vpaddd(dst, nds, Address(rscratch, 0), vector_len);
2969   }
2970 }
2971 
2972 void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
2973   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
2974   vandps(dst, nds, negate_field, vector_len);
2975 }
2976 
2977 void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
2978   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
2979   vandpd(dst, nds, negate_field, vector_len);
2980 }
2981 
2982 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
2983   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2984   Assembler::vpaddb(dst, nds, src, vector_len);
2985 }
2986 
2987 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
2988   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2989   Assembler::vpaddb(dst, nds, src, vector_len);
2990 }
2991 
2992 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
2993   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2994   Assembler::vpaddw(dst, nds, src, vector_len);
2995 }
2996 
2997 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
2998   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2999   Assembler::vpaddw(dst, nds, src, vector_len);
3000 }
3001 
3002 void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3003   if (reachable(src)) {
3004     Assembler::vpand(dst, nds, as_Address(src), vector_len);
3005   } else {
3006     lea(scratch_reg, src);
3007     Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);
3008   }
3009 }
3010 
3011 void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
3012   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3013   Assembler::vpbroadcastw(dst, src, vector_len);
3014 }
3015 
3016 void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3017   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3018   Assembler::vpcmpeqb(dst, nds, src, vector_len);
3019 }
3020 
3021 void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3022   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3023   Assembler::vpcmpeqw(dst, nds, src, vector_len);
3024 }
3025 
3026 void MacroAssembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3027   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3028   Assembler::vpmovzxbw(dst, src, vector_len);
3029 }
3030 
3031 void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {
3032   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3033   Assembler::vpmovmskb(dst, src);
3034 }
3035 
3036 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3037   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3038   Assembler::vpmullw(dst, nds, src, vector_len);
3039 }
3040 
3041 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3042   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3043   Assembler::vpmullw(dst, nds, src, vector_len);
3044 }
3045 
3046 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3047   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3048   Assembler::vpsubb(dst, nds, src, vector_len);
3049 }
3050 
3051 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3052   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3053   Assembler::vpsubb(dst, nds, src, vector_len);
3054 }
3055 
3056 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3057   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3058   Assembler::vpsubw(dst, nds, src, vector_len);
3059 }
3060 
3061 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3062   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3063   Assembler::vpsubw(dst, nds, src, vector_len);
3064 }
3065 
3066 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3067   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3068   Assembler::vpsraw(dst, nds, shift, vector_len);
3069 }
3070 
3071 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3072   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3073   Assembler::vpsraw(dst, nds, shift, vector_len);
3074 }
3075 
3076 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3077   assert(UseAVX &gt; 2,&quot;&quot;);
3078   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3079      vector_len = 2;
3080   }
3081   Assembler::evpsraq(dst, nds, shift, vector_len);
3082 }
3083 
3084 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3085   assert(UseAVX &gt; 2,&quot;&quot;);
3086   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3087      vector_len = 2;
3088   }
3089   Assembler::evpsraq(dst, nds, shift, vector_len);
3090 }
3091 
3092 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3093   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3094   Assembler::vpsrlw(dst, nds, shift, vector_len);
3095 }
3096 
3097 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3098   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3099   Assembler::vpsrlw(dst, nds, shift, vector_len);
3100 }
3101 
3102 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3103   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3104   Assembler::vpsllw(dst, nds, shift, vector_len);
3105 }
3106 
3107 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3108   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3109   Assembler::vpsllw(dst, nds, shift, vector_len);
3110 }
3111 
3112 void MacroAssembler::vptest(XMMRegister dst, XMMRegister src) {
3113   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3114   Assembler::vptest(dst, src);
3115 }
3116 
3117 void MacroAssembler::punpcklbw(XMMRegister dst, XMMRegister src) {
3118   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3119   Assembler::punpcklbw(dst, src);
3120 }
3121 
3122 void MacroAssembler::pshufd(XMMRegister dst, Address src, int mode) {
3123   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
3124   Assembler::pshufd(dst, src, mode);
3125 }
3126 
3127 void MacroAssembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
3128   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3129   Assembler::pshuflw(dst, src, mode);
3130 }
3131 
3132 void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3133   if (reachable(src)) {
3134     vandpd(dst, nds, as_Address(src), vector_len);
3135   } else {
3136     lea(scratch_reg, src);
3137     vandpd(dst, nds, Address(scratch_reg, 0), vector_len);
3138   }
3139 }
3140 
3141 void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3142   if (reachable(src)) {
3143     vandps(dst, nds, as_Address(src), vector_len);
3144   } else {
3145     lea(scratch_reg, src);
3146     vandps(dst, nds, Address(scratch_reg, 0), vector_len);
3147   }
3148 }
3149 
3150 void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3151   if (reachable(src)) {
3152     vdivsd(dst, nds, as_Address(src));
3153   } else {
3154     lea(rscratch1, src);
3155     vdivsd(dst, nds, Address(rscratch1, 0));
3156   }
3157 }
3158 
3159 void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3160   if (reachable(src)) {
3161     vdivss(dst, nds, as_Address(src));
3162   } else {
3163     lea(rscratch1, src);
3164     vdivss(dst, nds, Address(rscratch1, 0));
3165   }
3166 }
3167 
3168 void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3169   if (reachable(src)) {
3170     vmulsd(dst, nds, as_Address(src));
3171   } else {
3172     lea(rscratch1, src);
3173     vmulsd(dst, nds, Address(rscratch1, 0));
3174   }
3175 }
3176 
3177 void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3178   if (reachable(src)) {
3179     vmulss(dst, nds, as_Address(src));
3180   } else {
3181     lea(rscratch1, src);
3182     vmulss(dst, nds, Address(rscratch1, 0));
3183   }
3184 }
3185 
3186 void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3187   if (reachable(src)) {
3188     vsubsd(dst, nds, as_Address(src));
3189   } else {
3190     lea(rscratch1, src);
3191     vsubsd(dst, nds, Address(rscratch1, 0));
3192   }
3193 }
3194 
3195 void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3196   if (reachable(src)) {
3197     vsubss(dst, nds, as_Address(src));
3198   } else {
3199     lea(rscratch1, src);
3200     vsubss(dst, nds, Address(rscratch1, 0));
3201   }
3202 }
3203 
3204 void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3205   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3206   vxorps(dst, nds, src, Assembler::AVX_128bit);
3207 }
3208 
3209 void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3210   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3211   vxorpd(dst, nds, src, Assembler::AVX_128bit);
3212 }
3213 
3214 void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3215   if (reachable(src)) {
3216     vxorpd(dst, nds, as_Address(src), vector_len);
3217   } else {
3218     lea(scratch_reg, src);
3219     vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);
3220   }
3221 }
3222 
3223 void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3224   if (reachable(src)) {
3225     vxorps(dst, nds, as_Address(src), vector_len);
3226   } else {
3227     lea(scratch_reg, src);
3228     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
3229   }
3230 }
3231 
3232 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3233   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
3234     if (reachable(src)) {
3235       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
3236     } else {
3237       lea(scratch_reg, src);
3238       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
3239     }
3240   }
3241   else {
3242     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
3243   }
3244 }
3245 
3246 //-------------------------------------------------------------------------------------------
3247 
3248 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
3249   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
3250   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
3251   // The inverted mask is sign-extended
3252   andptr(possibly_jweak, inverted_jweak_mask);
3253 }
3254 
3255 void MacroAssembler::resolve_jobject(Register value,
3256                                      Register thread,
3257                                      Register tmp) {
3258   assert_different_registers(value, thread, tmp);
3259   Label done, not_weak;
3260   testptr(value, value);
3261   jcc(Assembler::zero, done);                // Use NULL as-is.
3262   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
3263   jcc(Assembler::zero, not_weak);
3264   // Resolve jweak.
3265   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3266                  value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);
3267   verify_oop(value);
3268   jmp(done);
3269   bind(not_weak);
3270   // Resolve (untagged) jobject.
3271   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
3272   verify_oop(value);
3273   bind(done);
3274 }
3275 
3276 void MacroAssembler::subptr(Register dst, int32_t imm32) {
3277   LP64_ONLY(subq(dst, imm32)) NOT_LP64(subl(dst, imm32));
3278 }
3279 
3280 // Force generation of a 4 byte immediate value even if it fits into 8bit
3281 void MacroAssembler::subptr_imm32(Register dst, int32_t imm32) {
3282   LP64_ONLY(subq_imm32(dst, imm32)) NOT_LP64(subl_imm32(dst, imm32));
3283 }
3284 
3285 void MacroAssembler::subptr(Register dst, Register src) {
3286   LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src));
3287 }
3288 
3289 // C++ bool manipulation
3290 void MacroAssembler::testbool(Register dst) {
3291   if(sizeof(bool) == 1)
3292     testb(dst, 0xff);
3293   else if(sizeof(bool) == 2) {
3294     // testw implementation needed for two byte bools
3295     ShouldNotReachHere();
3296   } else if(sizeof(bool) == 4)
3297     testl(dst, dst);
3298   else
3299     // unsupported
3300     ShouldNotReachHere();
3301 }
3302 
3303 void MacroAssembler::testptr(Register dst, Register src) {
3304   LP64_ONLY(testq(dst, src)) NOT_LP64(testl(dst, src));
3305 }
3306 
3307 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
3308 void MacroAssembler::tlab_allocate(Register thread, Register obj,
3309                                    Register var_size_in_bytes,
3310                                    int con_size_in_bytes,
3311                                    Register t1,
3312                                    Register t2,
3313                                    Label&amp; slow_case) {
3314   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3315   bs-&gt;tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
3316 }
3317 
3318 // Defines obj, preserves var_size_in_bytes
3319 void MacroAssembler::eden_allocate(Register thread, Register obj,
3320                                    Register var_size_in_bytes,
3321                                    int con_size_in_bytes,
3322                                    Register t1,
3323                                    Label&amp; slow_case) {
3324   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3325   bs-&gt;eden_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
3326 }
3327 
3328 // Preserves the contents of address, destroys the contents length_in_bytes and temp.
3329 void MacroAssembler::zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp) {
3330   assert(address != length_in_bytes &amp;&amp; address != temp &amp;&amp; temp != length_in_bytes, &quot;registers must be different&quot;);
3331   assert((offset_in_bytes &amp; (BytesPerWord - 1)) == 0, &quot;offset must be a multiple of BytesPerWord&quot;);
3332   Label done;
3333 
3334   testptr(length_in_bytes, length_in_bytes);
3335   jcc(Assembler::zero, done);
3336 
3337   // initialize topmost word, divide index by 2, check if odd and test if zero
3338   // note: for the remaining code to work, index must be a multiple of BytesPerWord
3339 #ifdef ASSERT
3340   {
3341     Label L;
3342     testptr(length_in_bytes, BytesPerWord - 1);
3343     jcc(Assembler::zero, L);
3344     stop(&quot;length must be a multiple of BytesPerWord&quot;);
3345     bind(L);
3346   }
3347 #endif
3348   Register index = length_in_bytes;
3349   xorptr(temp, temp);    // use _zero reg to clear memory (shorter code)
3350   if (UseIncDec) {
3351     shrptr(index, 3);  // divide by 8/16 and set carry flag if bit 2 was set
3352   } else {
3353     shrptr(index, 2);  // use 2 instructions to avoid partial flag stall
3354     shrptr(index, 1);
3355   }
3356 #ifndef _LP64
3357   // index could have not been a multiple of 8 (i.e., bit 2 was set)
3358   {
3359     Label even;
3360     // note: if index was a multiple of 8, then it cannot
3361     //       be 0 now otherwise it must have been 0 before
3362     //       =&gt; if it is even, we don&#39;t need to check for 0 again
3363     jcc(Assembler::carryClear, even);
3364     // clear topmost word (no jump would be needed if conditional assignment worked here)
3365     movptr(Address(address, index, Address::times_8, offset_in_bytes - 0*BytesPerWord), temp);
3366     // index could be 0 now, must check again
3367     jcc(Assembler::zero, done);
3368     bind(even);
3369   }
3370 #endif // !_LP64
3371   // initialize remaining object fields: index is a multiple of 2 now
3372   {
3373     Label loop;
3374     bind(loop);
3375     movptr(Address(address, index, Address::times_8, offset_in_bytes - 1*BytesPerWord), temp);
3376     NOT_LP64(movptr(Address(address, index, Address::times_8, offset_in_bytes - 2*BytesPerWord), temp);)
3377     decrement(index);
3378     jcc(Assembler::notZero, loop);
3379   }
3380 
3381   bind(done);
3382 }
3383 
3384 // Look up the method for a megamorphic invokeinterface call.
3385 // The target method is determined by &lt;intf_klass, itable_index&gt;.
3386 // The receiver klass is in recv_klass.
3387 // On success, the result will be in method_result, and execution falls through.
3388 // On failure, execution transfers to the given label.
3389 void MacroAssembler::lookup_interface_method(Register recv_klass,
3390                                              Register intf_klass,
3391                                              RegisterOrConstant itable_index,
3392                                              Register method_result,
3393                                              Register scan_temp,
3394                                              Label&amp; L_no_such_interface,
3395                                              bool return_method) {
3396   assert_different_registers(recv_klass, intf_klass, scan_temp);
3397   assert_different_registers(method_result, intf_klass, scan_temp);
3398   assert(recv_klass != method_result || !return_method,
3399          &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
3400 
3401   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
3402          &quot;caller must use same register for non-constant itable index as for method&quot;);
3403 
3404   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
3405   int vtable_base = in_bytes(Klass::vtable_start_offset());
3406   int itentry_off = itableMethodEntry::method_offset_in_bytes();
3407   int scan_step   = itableOffsetEntry::size() * wordSize;
3408   int vte_size    = vtableEntry::size_in_bytes();
3409   Address::ScaleFactor times_vte_scale = Address::times_ptr;
3410   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
3411 
3412   movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
3413 
3414   // %%% Could store the aligned, prescaled offset in the klassoop.
3415   lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
3416 
3417   if (return_method) {
3418     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
3419     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
3420     lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
3421   }
3422 
3423   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
3424   //   if (scan-&gt;interface() == intf) {
3425   //     result = (klass + scan-&gt;offset() + itable_index);
3426   //   }
3427   // }
3428   Label search, found_method;
3429 
3430   for (int peel = 1; peel &gt;= 0; peel--) {
3431     movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
3432     cmpptr(intf_klass, method_result);
3433 
3434     if (peel) {
3435       jccb(Assembler::equal, found_method);
3436     } else {
3437       jccb(Assembler::notEqual, search);
3438       // (invert the test to fall through to found_method...)
3439     }
3440 
3441     if (!peel)  break;
3442 
3443     bind(search);
3444 
3445     // Check that the previous entry is non-null.  A null entry means that
3446     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
3447     // same as when the caller was compiled.
3448     testptr(method_result, method_result);
3449     jcc(Assembler::zero, L_no_such_interface);
3450     addptr(scan_temp, scan_step);
3451   }
3452 
3453   bind(found_method);
3454 
3455   if (return_method) {
3456     // Got a hit.
3457     movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
3458     movptr(method_result, Address(recv_klass, scan_temp, Address::times_1));
3459   }
3460 }
3461 
3462 
3463 // virtual method calling
3464 void MacroAssembler::lookup_virtual_method(Register recv_klass,
3465                                            RegisterOrConstant vtable_index,
3466                                            Register method_result) {
3467   const int base = in_bytes(Klass::vtable_start_offset());
3468   assert(vtableEntry::size() * wordSize == wordSize, &quot;else adjust the scaling in the code below&quot;);
3469   Address vtable_entry_addr(recv_klass,
3470                             vtable_index, Address::times_ptr,
3471                             base + vtableEntry::method_offset_in_bytes());
3472   movptr(method_result, vtable_entry_addr);
3473 }
3474 
3475 
3476 void MacroAssembler::check_klass_subtype(Register sub_klass,
3477                            Register super_klass,
3478                            Register temp_reg,
3479                            Label&amp; L_success) {
3480   Label L_failure;
3481   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
3482   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
3483   bind(L_failure);
3484 }
3485 
3486 
3487 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
3488                                                    Register super_klass,
3489                                                    Register temp_reg,
3490                                                    Label* L_success,
3491                                                    Label* L_failure,
3492                                                    Label* L_slow_path,
3493                                         RegisterOrConstant super_check_offset) {
3494   assert_different_registers(sub_klass, super_klass, temp_reg);
3495   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
3496   if (super_check_offset.is_register()) {
3497     assert_different_registers(sub_klass, super_klass,
3498                                super_check_offset.as_register());
3499   } else if (must_load_sco) {
3500     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
3501   }
3502 
3503   Label L_fallthrough;
3504   int label_nulls = 0;
3505   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3506   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3507   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
3508   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3509 
3510   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3511   int sco_offset = in_bytes(Klass::super_check_offset_offset());
3512   Address super_check_offset_addr(super_klass, sco_offset);
3513 
3514   // Hacked jcc, which &quot;knows&quot; that L_fallthrough, at least, is in
3515   // range of a jccb.  If this routine grows larger, reconsider at
3516   // least some of these.
3517 #define local_jcc(assembler_cond, label)                                \
3518   if (&amp;(label) == &amp;L_fallthrough)  jccb(assembler_cond, label);         \
3519   else                             jcc( assembler_cond, label) /*omit semi*/
3520 
3521   // Hacked jmp, which may only be used just before L_fallthrough.
3522 #define final_jmp(label)                                                \
3523   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3524   else                            jmp(label)                /*omit semi*/
3525 
3526   // If the pointers are equal, we are done (e.g., String[] elements).
3527   // This self-check enables sharing of secondary supertype arrays among
3528   // non-primary types such as array-of-interface.  Otherwise, each such
3529   // type would need its own customized SSA.
3530   // We move this check to the front of the fast path because many
3531   // type checks are in fact trivially successful in this manner,
3532   // so we get a nicely predicted branch right at the start of the check.
3533   cmpptr(sub_klass, super_klass);
3534   local_jcc(Assembler::equal, *L_success);
3535 
3536   // Check the supertype display:
3537   if (must_load_sco) {
3538     // Positive movl does right thing on LP64.
3539     movl(temp_reg, super_check_offset_addr);
3540     super_check_offset = RegisterOrConstant(temp_reg);
3541   }
3542   Address super_check_addr(sub_klass, super_check_offset, Address::times_1, 0);
3543   cmpptr(super_klass, super_check_addr); // load displayed supertype
3544 
3545   // This check has worked decisively for primary supers.
3546   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
3547   // (Secondary supers are interfaces and very deeply nested subtypes.)
3548   // This works in the same check above because of a tricky aliasing
3549   // between the super_cache and the primary super display elements.
3550   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3551   // Note that the cache is updated below if it does not help us find
3552   // what we need immediately.
3553   // So if it was a primary super, we can just fail immediately.
3554   // Otherwise, it&#39;s the slow path for us (no success at this point).
3555 
3556   if (super_check_offset.is_register()) {
3557     local_jcc(Assembler::equal, *L_success);
3558     cmpl(super_check_offset.as_register(), sc_offset);
3559     if (L_failure == &amp;L_fallthrough) {
3560       local_jcc(Assembler::equal, *L_slow_path);
3561     } else {
3562       local_jcc(Assembler::notEqual, *L_failure);
3563       final_jmp(*L_slow_path);
3564     }
3565   } else if (super_check_offset.as_constant() == sc_offset) {
3566     // Need a slow path; fast failure is impossible.
3567     if (L_slow_path == &amp;L_fallthrough) {
3568       local_jcc(Assembler::equal, *L_success);
3569     } else {
3570       local_jcc(Assembler::notEqual, *L_slow_path);
3571       final_jmp(*L_success);
3572     }
3573   } else {
3574     // No slow path; it&#39;s a fast decision.
3575     if (L_failure == &amp;L_fallthrough) {
3576       local_jcc(Assembler::equal, *L_success);
3577     } else {
3578       local_jcc(Assembler::notEqual, *L_failure);
3579       final_jmp(*L_success);
3580     }
3581   }
3582 
3583   bind(L_fallthrough);
3584 
3585 #undef local_jcc
3586 #undef final_jmp
3587 }
3588 
3589 
3590 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
3591                                                    Register super_klass,
3592                                                    Register temp_reg,
3593                                                    Register temp2_reg,
3594                                                    Label* L_success,
3595                                                    Label* L_failure,
3596                                                    bool set_cond_codes) {
3597   assert_different_registers(sub_klass, super_klass, temp_reg);
3598   if (temp2_reg != noreg)
3599     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg);
3600 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
3601 
3602   Label L_fallthrough;
3603   int label_nulls = 0;
3604   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3605   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3606   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3607 
3608   // a couple of useful fields in sub_klass:
3609   int ss_offset = in_bytes(Klass::secondary_supers_offset());
3610   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3611   Address secondary_supers_addr(sub_klass, ss_offset);
3612   Address super_cache_addr(     sub_klass, sc_offset);
3613 
3614   // Do a linear scan of the secondary super-klass chain.
3615   // This code is rarely used, so simplicity is a virtue here.
3616   // The repne_scan instruction uses fixed registers, which we must spill.
3617   // Don&#39;t worry too much about pre-existing connections with the input regs.
3618 
3619   assert(sub_klass != rax, &quot;killed reg&quot;); // killed by mov(rax, super)
3620   assert(sub_klass != rcx, &quot;killed reg&quot;); // killed by lea(rcx, &amp;pst_counter)
3621 
3622   // Get super_klass value into rax (even if it was in rdi or rcx).
3623   bool pushed_rax = false, pushed_rcx = false, pushed_rdi = false;
3624   if (super_klass != rax || UseCompressedOops) {
3625     if (!IS_A_TEMP(rax)) { push(rax); pushed_rax = true; }
3626     mov(rax, super_klass);
3627   }
3628   if (!IS_A_TEMP(rcx)) { push(rcx); pushed_rcx = true; }
3629   if (!IS_A_TEMP(rdi)) { push(rdi); pushed_rdi = true; }
3630 
3631 #ifndef PRODUCT
3632   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
3633   ExternalAddress pst_counter_addr((address) pst_counter);
3634   NOT_LP64(  incrementl(pst_counter_addr) );
3635   LP64_ONLY( lea(rcx, pst_counter_addr) );
3636   LP64_ONLY( incrementl(Address(rcx, 0)) );
3637 #endif //PRODUCT
3638 
3639   // We will consult the secondary-super array.
3640   movptr(rdi, secondary_supers_addr);
3641   // Load the array length.  (Positive movl does right thing on LP64.)
3642   movl(rcx, Address(rdi, Array&lt;Klass*&gt;::length_offset_in_bytes()));
3643   // Skip to start of data.
3644   addptr(rdi, Array&lt;Klass*&gt;::base_offset_in_bytes());
3645 
3646   // Scan RCX words at [RDI] for an occurrence of RAX.
3647   // Set NZ/Z based on last compare.
3648   // Z flag value will not be set by &#39;repne&#39; if RCX == 0 since &#39;repne&#39; does
3649   // not change flags (only scas instruction which is repeated sets flags).
3650   // Set Z = 0 (not equal) before &#39;repne&#39; to indicate that class was not found.
3651 
3652     testptr(rax,rax); // Set Z = 0
3653     repne_scan();
3654 
3655   // Unspill the temp. registers:
3656   if (pushed_rdi)  pop(rdi);
3657   if (pushed_rcx)  pop(rcx);
3658   if (pushed_rax)  pop(rax);
3659 
3660   if (set_cond_codes) {
3661     // Special hack for the AD files:  rdi is guaranteed non-zero.
3662     assert(!pushed_rdi, &quot;rdi must be left non-NULL&quot;);
3663     // Also, the condition codes are properly set Z/NZ on succeed/failure.
3664   }
3665 
3666   if (L_failure == &amp;L_fallthrough)
3667         jccb(Assembler::notEqual, *L_failure);
3668   else  jcc(Assembler::notEqual, *L_failure);
3669 
3670   // Success.  Cache the super we found and proceed in triumph.
3671   movptr(super_cache_addr, super_klass);
3672 
3673   if (L_success != &amp;L_fallthrough) {
3674     jmp(*L_success);
3675   }
3676 
3677 #undef IS_A_TEMP
3678 
3679   bind(L_fallthrough);
3680 }
3681 
3682 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
3683   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
3684 
3685   Label L_fallthrough;
3686   if (L_fast_path == NULL) {
3687     L_fast_path = &amp;L_fallthrough;
3688   } else if (L_slow_path == NULL) {
3689     L_slow_path = &amp;L_fallthrough;
3690   }
3691 
3692   // Fast path check: class is fully initialized
3693   cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3694   jcc(Assembler::equal, *L_fast_path);
3695 
3696   // Fast path check: current thread is initializer thread
3697   cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));
3698   if (L_slow_path == &amp;L_fallthrough) {
3699     jcc(Assembler::equal, *L_fast_path);
3700     bind(*L_slow_path);
3701   } else if (L_fast_path == &amp;L_fallthrough) {
3702     jcc(Assembler::notEqual, *L_slow_path);
3703     bind(*L_fast_path);
3704   } else {
3705     Unimplemented();
3706   }
3707 }
3708 
3709 void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
3710   if (VM_Version::supports_cmov()) {
3711     cmovl(cc, dst, src);
3712   } else {
3713     Label L;
3714     jccb(negate_condition(cc), L);
3715     movl(dst, src);
3716     bind(L);
3717   }
3718 }
3719 
3720 void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
3721   if (VM_Version::supports_cmov()) {
3722     cmovl(cc, dst, src);
3723   } else {
3724     Label L;
3725     jccb(negate_condition(cc), L);
3726     movl(dst, src);
3727     bind(L);
3728   }
3729 }
3730 
3731 void MacroAssembler::_verify_oop(Register reg, const char* s, const char* file, int line) {
3732   if (!VerifyOops) return;
3733 
3734   // Pass register number to verify_oop_subroutine
3735   const char* b = NULL;
3736   {
3737     ResourceMark rm;
3738     stringStream ss;
3739     ss.print(&quot;verify_oop: %s: %s (%s:%d)&quot;, reg-&gt;name(), s, file, line);
3740     b = code_string(ss.as_string());
3741   }
3742   BLOCK_COMMENT(&quot;verify_oop {&quot;);
3743 #ifdef _LP64
3744   push(rscratch1);                    // save r10, trashed by movptr()
3745 #endif
3746   push(rax);                          // save rax,
3747   push(reg);                          // pass register argument
3748   ExternalAddress buffer((address) b);
3749   // avoid using pushptr, as it modifies scratch registers
3750   // and our contract is not to modify anything
3751   movptr(rax, buffer.addr());
3752   push(rax);
3753   // call indirectly to solve generation ordering problem
3754   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
3755   call(rax);
3756   // Caller pops the arguments (oop, message) and restores rax, r10
3757   BLOCK_COMMENT(&quot;} verify_oop&quot;);
3758 }
3759 
3760 void MacroAssembler::vallones(XMMRegister dst, int vector_len) {
3761   if (UseAVX &gt; 2 &amp;&amp; (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl())) {
3762     vpternlogd(dst, 0xFF, dst, dst, vector_len);
3763   } else {
3764     assert(UseAVX &gt; 0, &quot;&quot;);
3765     vpcmpeqb(dst, dst, dst, vector_len);
3766   }
3767 }
3768 
3769 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
3770                                                       Register tmp,
3771                                                       int offset) {
3772   intptr_t value = *delayed_value_addr;
3773   if (value != 0)
3774     return RegisterOrConstant(value + offset);
3775 
3776   // load indirectly to solve generation ordering problem
3777   movptr(tmp, ExternalAddress((address) delayed_value_addr));
3778 
3779 #ifdef ASSERT
3780   { Label L;
3781     testptr(tmp, tmp);
3782     if (WizardMode) {
3783       const char* buf = NULL;
3784       {
3785         ResourceMark rm;
3786         stringStream ss;
3787         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
3788         buf = code_string(ss.as_string());
3789       }
3790       jcc(Assembler::notZero, L);
3791       STOP(buf);
3792     } else {
3793       jccb(Assembler::notZero, L);
3794       hlt();
3795     }
3796     bind(L);
3797   }
3798 #endif
3799 
3800   if (offset != 0)
3801     addptr(tmp, offset);
3802 
3803   return RegisterOrConstant(tmp);
3804 }
3805 
3806 
3807 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
3808                                          int extra_slot_offset) {
3809   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
3810   int stackElementSize = Interpreter::stackElementSize;
3811   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
3812 #ifdef ASSERT
3813   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
3814   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
3815 #endif
3816   Register             scale_reg    = noreg;
3817   Address::ScaleFactor scale_factor = Address::no_scale;
3818   if (arg_slot.is_constant()) {
3819     offset += arg_slot.as_constant() * stackElementSize;
3820   } else {
3821     scale_reg    = arg_slot.as_register();
3822     scale_factor = Address::times(stackElementSize);
3823   }
3824   offset += wordSize;           // return PC is on stack
3825   return Address(rsp, scale_reg, scale_factor, offset);
3826 }
3827 
3828 
3829 void MacroAssembler::_verify_oop_addr(Address addr, const char* s, const char* file, int line) {
3830   if (!VerifyOops) return;
3831 
3832   // Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);
3833   // Pass register number to verify_oop_subroutine
3834   const char* b = NULL;
3835   {
3836     ResourceMark rm;
3837     stringStream ss;
3838     ss.print(&quot;verify_oop_addr: %s (%s:%d)&quot;, s, file, line);
3839     b = code_string(ss.as_string());
3840   }
3841 #ifdef _LP64
3842   push(rscratch1);                    // save r10, trashed by movptr()
3843 #endif
3844   push(rax);                          // save rax,
3845   // addr may contain rsp so we will have to adjust it based on the push
3846   // we just did (and on 64 bit we do two pushes)
3847   // NOTE: 64bit seemed to have had a bug in that it did movq(addr, rax); which
3848   // stores rax into addr which is backwards of what was intended.
3849   if (addr.uses(rsp)) {
3850     lea(rax, addr);
3851     pushptr(Address(rax, LP64_ONLY(2 *) BytesPerWord));
3852   } else {
3853     pushptr(addr);
3854   }
3855 
3856   ExternalAddress buffer((address) b);
3857   // pass msg argument
3858   // avoid using pushptr, as it modifies scratch registers
3859   // and our contract is not to modify anything
3860   movptr(rax, buffer.addr());
3861   push(rax);
3862 
3863   // call indirectly to solve generation ordering problem
3864   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
3865   call(rax);
3866   // Caller pops the arguments (addr, message) and restores rax, r10.
3867 }
3868 
3869 void MacroAssembler::verify_tlab() {
3870 #ifdef ASSERT
3871   if (UseTLAB &amp;&amp; VerifyOops) {
3872     Label next, ok;
3873     Register t1 = rsi;
3874     Register thread_reg = NOT_LP64(rbx) LP64_ONLY(r15_thread);
3875 
3876     push(t1);
3877     NOT_LP64(push(thread_reg));
3878     NOT_LP64(get_thread(thread_reg));
3879 
3880     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
3881     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_start_offset())));
3882     jcc(Assembler::aboveEqual, next);
3883     STOP(&quot;assert(top &gt;= start)&quot;);
3884     should_not_reach_here();
3885 
3886     bind(next);
3887     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_end_offset())));
3888     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
3889     jcc(Assembler::aboveEqual, ok);
3890     STOP(&quot;assert(top &lt;= end)&quot;);
3891     should_not_reach_here();
3892 
3893     bind(ok);
3894     NOT_LP64(pop(thread_reg));
3895     pop(t1);
3896   }
3897 #endif
3898 }
3899 
3900 class ControlWord {
3901  public:
3902   int32_t _value;
3903 
3904   int  rounding_control() const        { return  (_value &gt;&gt; 10) &amp; 3      ; }
3905   int  precision_control() const       { return  (_value &gt;&gt;  8) &amp; 3      ; }
3906   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
3907   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
3908   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
3909   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
3910   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
3911   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
3912 
3913   void print() const {
3914     // rounding control
3915     const char* rc;
3916     switch (rounding_control()) {
3917       case 0: rc = &quot;round near&quot;; break;
3918       case 1: rc = &quot;round down&quot;; break;
3919       case 2: rc = &quot;round up  &quot;; break;
3920       case 3: rc = &quot;chop      &quot;; break;
3921     };
3922     // precision control
3923     const char* pc;
3924     switch (precision_control()) {
3925       case 0: pc = &quot;24 bits &quot;; break;
3926       case 1: pc = &quot;reserved&quot;; break;
3927       case 2: pc = &quot;53 bits &quot;; break;
3928       case 3: pc = &quot;64 bits &quot;; break;
3929     };
3930     // flags
3931     char f[9];
3932     f[0] = &#39; &#39;;
3933     f[1] = &#39; &#39;;
3934     f[2] = (precision   ()) ? &#39;P&#39; : &#39;p&#39;;
3935     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;u&#39;;
3936     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;o&#39;;
3937     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;z&#39;;
3938     f[6] = (denormalized()) ? &#39;D&#39; : &#39;d&#39;;
3939     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;i&#39;;
3940     f[8] = &#39;\x0&#39;;
3941     // output
3942     printf(&quot;%04x  masks = %s, %s, %s&quot;, _value &amp; 0xFFFF, f, rc, pc);
3943   }
3944 
3945 };
3946 
3947 class StatusWord {
3948  public:
3949   int32_t _value;
3950 
3951   bool busy() const                    { return ((_value &gt;&gt; 15) &amp; 1) != 0; }
3952   bool C3() const                      { return ((_value &gt;&gt; 14) &amp; 1) != 0; }
3953   bool C2() const                      { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
3954   bool C1() const                      { return ((_value &gt;&gt;  9) &amp; 1) != 0; }
3955   bool C0() const                      { return ((_value &gt;&gt;  8) &amp; 1) != 0; }
3956   int  top() const                     { return  (_value &gt;&gt; 11) &amp; 7      ; }
3957   bool error_status() const            { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
3958   bool stack_fault() const             { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
3959   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
3960   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
3961   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
3962   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
3963   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
3964   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
3965 
3966   void print() const {
3967     // condition codes
3968     char c[5];
3969     c[0] = (C3()) ? &#39;3&#39; : &#39;-&#39;;
3970     c[1] = (C2()) ? &#39;2&#39; : &#39;-&#39;;
3971     c[2] = (C1()) ? &#39;1&#39; : &#39;-&#39;;
3972     c[3] = (C0()) ? &#39;0&#39; : &#39;-&#39;;
3973     c[4] = &#39;\x0&#39;;
3974     // flags
3975     char f[9];
3976     f[0] = (error_status()) ? &#39;E&#39; : &#39;-&#39;;
3977     f[1] = (stack_fault ()) ? &#39;S&#39; : &#39;-&#39;;
3978     f[2] = (precision   ()) ? &#39;P&#39; : &#39;-&#39;;
3979     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;-&#39;;
3980     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;-&#39;;
3981     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;-&#39;;
3982     f[6] = (denormalized()) ? &#39;D&#39; : &#39;-&#39;;
3983     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;-&#39;;
3984     f[8] = &#39;\x0&#39;;
3985     // output
3986     printf(&quot;%04x  flags = %s, cc =  %s, top = %d&quot;, _value &amp; 0xFFFF, f, c, top());
3987   }
3988 
3989 };
3990 
3991 class TagWord {
3992  public:
3993   int32_t _value;
3994 
3995   int tag_at(int i) const              { return (_value &gt;&gt; (i*2)) &amp; 3; }
3996 
3997   void print() const {
3998     printf(&quot;%04x&quot;, _value &amp; 0xFFFF);
3999   }
4000 
4001 };
4002 
4003 class FPU_Register {
4004  public:
4005   int32_t _m0;
4006   int32_t _m1;
4007   int16_t _ex;
4008 
4009   bool is_indefinite() const           {
4010     return _ex == -1 &amp;&amp; _m1 == (int32_t)0xC0000000 &amp;&amp; _m0 == 0;
4011   }
4012 
4013   void print() const {
4014     char  sign = (_ex &lt; 0) ? &#39;-&#39; : &#39;+&#39;;
4015     const char* kind = (_ex == 0x7FFF || _ex == (int16_t)-1) ? &quot;NaN&quot; : &quot;   &quot;;
4016     printf(&quot;%c%04hx.%08x%08x  %s&quot;, sign, _ex, _m1, _m0, kind);
4017   };
4018 
4019 };
4020 
4021 class FPU_State {
4022  public:
4023   enum {
4024     register_size       = 10,
4025     number_of_registers =  8,
4026     register_mask       =  7
4027   };
4028 
4029   ControlWord  _control_word;
4030   StatusWord   _status_word;
4031   TagWord      _tag_word;
4032   int32_t      _error_offset;
4033   int32_t      _error_selector;
4034   int32_t      _data_offset;
4035   int32_t      _data_selector;
4036   int8_t       _register[register_size * number_of_registers];
4037 
4038   int tag_for_st(int i) const          { return _tag_word.tag_at((_status_word.top() + i) &amp; register_mask); }
4039   FPU_Register* st(int i) const        { return (FPU_Register*)&amp;_register[register_size * i]; }
4040 
4041   const char* tag_as_string(int tag) const {
4042     switch (tag) {
4043       case 0: return &quot;valid&quot;;
4044       case 1: return &quot;zero&quot;;
4045       case 2: return &quot;special&quot;;
4046       case 3: return &quot;empty&quot;;
4047     }
4048     ShouldNotReachHere();
4049     return NULL;
4050   }
4051 
4052   void print() const {
4053     // print computation registers
4054     { int t = _status_word.top();
4055       for (int i = 0; i &lt; number_of_registers; i++) {
4056         int j = (i - t) &amp; register_mask;
4057         printf(&quot;%c r%d = ST%d = &quot;, (j == 0 ? &#39;*&#39; : &#39; &#39;), i, j);
4058         st(j)-&gt;print();
4059         printf(&quot; %s\n&quot;, tag_as_string(_tag_word.tag_at(i)));
4060       }
4061     }
4062     printf(&quot;\n&quot;);
4063     // print control registers
4064     printf(&quot;ctrl = &quot;); _control_word.print(); printf(&quot;\n&quot;);
4065     printf(&quot;stat = &quot;); _status_word .print(); printf(&quot;\n&quot;);
4066     printf(&quot;tags = &quot;); _tag_word    .print(); printf(&quot;\n&quot;);
4067   }
4068 
4069 };
4070 
4071 class Flag_Register {
4072  public:
4073   int32_t _value;
4074 
4075   bool overflow() const                { return ((_value &gt;&gt; 11) &amp; 1) != 0; }
4076   bool direction() const               { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4077   bool sign() const                    { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4078   bool zero() const                    { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4079   bool auxiliary_carry() const         { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4080   bool parity() const                  { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4081   bool carry() const                   { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4082 
4083   void print() const {
4084     // flags
4085     char f[8];
4086     f[0] = (overflow       ()) ? &#39;O&#39; : &#39;-&#39;;
4087     f[1] = (direction      ()) ? &#39;D&#39; : &#39;-&#39;;
4088     f[2] = (sign           ()) ? &#39;S&#39; : &#39;-&#39;;
4089     f[3] = (zero           ()) ? &#39;Z&#39; : &#39;-&#39;;
4090     f[4] = (auxiliary_carry()) ? &#39;A&#39; : &#39;-&#39;;
4091     f[5] = (parity         ()) ? &#39;P&#39; : &#39;-&#39;;
4092     f[6] = (carry          ()) ? &#39;C&#39; : &#39;-&#39;;
4093     f[7] = &#39;\x0&#39;;
4094     // output
4095     printf(&quot;%08x  flags = %s&quot;, _value, f);
4096   }
4097 
4098 };
4099 
4100 class IU_Register {
4101  public:
4102   int32_t _value;
4103 
4104   void print() const {
4105     printf(&quot;%08x  %11d&quot;, _value, _value);
4106   }
4107 
4108 };
4109 
4110 class IU_State {
4111  public:
4112   Flag_Register _eflags;
4113   IU_Register   _rdi;
4114   IU_Register   _rsi;
4115   IU_Register   _rbp;
4116   IU_Register   _rsp;
4117   IU_Register   _rbx;
4118   IU_Register   _rdx;
4119   IU_Register   _rcx;
4120   IU_Register   _rax;
4121 
4122   void print() const {
4123     // computation registers
4124     printf(&quot;rax,  = &quot;); _rax.print(); printf(&quot;\n&quot;);
4125     printf(&quot;rbx,  = &quot;); _rbx.print(); printf(&quot;\n&quot;);
4126     printf(&quot;rcx  = &quot;); _rcx.print(); printf(&quot;\n&quot;);
4127     printf(&quot;rdx  = &quot;); _rdx.print(); printf(&quot;\n&quot;);
4128     printf(&quot;rdi  = &quot;); _rdi.print(); printf(&quot;\n&quot;);
4129     printf(&quot;rsi  = &quot;); _rsi.print(); printf(&quot;\n&quot;);
4130     printf(&quot;rbp,  = &quot;); _rbp.print(); printf(&quot;\n&quot;);
4131     printf(&quot;rsp  = &quot;); _rsp.print(); printf(&quot;\n&quot;);
4132     printf(&quot;\n&quot;);
4133     // control registers
4134     printf(&quot;flgs = &quot;); _eflags.print(); printf(&quot;\n&quot;);
4135   }
4136 };
4137 
4138 
4139 class CPU_State {
4140  public:
4141   FPU_State _fpu_state;
4142   IU_State  _iu_state;
4143 
4144   void print() const {
4145     printf(&quot;--------------------------------------------------\n&quot;);
4146     _iu_state .print();
4147     printf(&quot;\n&quot;);
4148     _fpu_state.print();
4149     printf(&quot;--------------------------------------------------\n&quot;);
4150   }
4151 
4152 };
4153 
4154 
4155 static void _print_CPU_state(CPU_State* state) {
4156   state-&gt;print();
4157 };
4158 
4159 
4160 void MacroAssembler::print_CPU_state() {
4161   push_CPU_state();
4162   push(rsp);                // pass CPU state
4163   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _print_CPU_state)));
4164   addptr(rsp, wordSize);       // discard argument
4165   pop_CPU_state();
4166 }
4167 
4168 
4169 #ifndef _LP64
4170 static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {
4171   static int counter = 0;
4172   FPU_State* fs = &amp;state-&gt;_fpu_state;
4173   counter++;
4174   // For leaf calls, only verify that the top few elements remain empty.
4175   // We only need 1 empty at the top for C2 code.
4176   if( stack_depth &lt; 0 ) {
4177     if( fs-&gt;tag_for_st(7) != 3 ) {
4178       printf(&quot;FPR7 not empty\n&quot;);
4179       state-&gt;print();
4180       assert(false, &quot;error&quot;);
4181       return false;
4182     }
4183     return true;                // All other stack states do not matter
4184   }
4185 
4186   assert((fs-&gt;_control_word._value &amp; 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,
4187          &quot;bad FPU control word&quot;);
4188 
4189   // compute stack depth
4190   int i = 0;
4191   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i)  &lt; 3) i++;
4192   int d = i;
4193   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i) == 3) i++;
4194   // verify findings
4195   if (i != FPU_State::number_of_registers) {
4196     // stack not contiguous
4197     printf(&quot;%s: stack not contiguous at ST%d\n&quot;, s, i);
4198     state-&gt;print();
4199     assert(false, &quot;error&quot;);
4200     return false;
4201   }
4202   // check if computed stack depth corresponds to expected stack depth
4203   if (stack_depth &lt; 0) {
4204     // expected stack depth is -stack_depth or less
4205     if (d &gt; -stack_depth) {
4206       // too many elements on the stack
4207       printf(&quot;%s: &lt;= %d stack elements expected but found %d\n&quot;, s, -stack_depth, d);
4208       state-&gt;print();
4209       assert(false, &quot;error&quot;);
4210       return false;
4211     }
4212   } else {
4213     // expected stack depth is stack_depth
4214     if (d != stack_depth) {
4215       // wrong stack depth
4216       printf(&quot;%s: %d stack elements expected but found %d\n&quot;, s, stack_depth, d);
4217       state-&gt;print();
4218       assert(false, &quot;error&quot;);
4219       return false;
4220     }
4221   }
4222   // everything is cool
4223   return true;
4224 }
4225 
4226 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {
4227   if (!VerifyFPU) return;
4228   push_CPU_state();
4229   push(rsp);                // pass CPU state
4230   ExternalAddress msg((address) s);
4231   // pass message string s
4232   pushptr(msg.addr());
4233   push(stack_depth);        // pass stack depth
4234   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));
4235   addptr(rsp, 3 * wordSize);   // discard arguments
4236   // check for error
4237   { Label L;
4238     testl(rax, rax);
4239     jcc(Assembler::notZero, L);
4240     int3();                  // break if error condition
4241     bind(L);
4242   }
4243   pop_CPU_state();
4244 }
4245 #endif // _LP64
4246 
4247 void MacroAssembler::restore_cpu_control_state_after_jni() {
4248   // Either restore the MXCSR register after returning from the JNI Call
4249   // or verify that it wasn&#39;t changed (with -Xcheck:jni flag).
4250   if (VM_Version::supports_sse()) {
4251     if (RestoreMXCSROnJNICalls) {
4252       ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));
4253     } else if (CheckJNICalls) {
4254       call(RuntimeAddress(StubRoutines::x86::verify_mxcsr_entry()));
4255     }
4256   }
4257   // Clear upper bits of YMM registers to avoid SSE &lt;-&gt; AVX transition penalty.
4258   vzeroupper();
4259   // Reset k1 to 0xffff.
4260 
4261 #ifdef COMPILER2
4262   if (PostLoopMultiversioning &amp;&amp; VM_Version::supports_evex()) {
4263     push(rcx);
4264     movl(rcx, 0xffff);
4265     kmovwl(k1, rcx);
4266     pop(rcx);
4267   }
4268 #endif // COMPILER2
4269 
4270 #ifndef _LP64
4271   // Either restore the x87 floating pointer control word after returning
4272   // from the JNI call or verify that it wasn&#39;t changed.
4273   if (CheckJNICalls) {
4274     call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));
4275   }
4276 #endif // _LP64
4277 }
4278 
4279 // ((OopHandle)result).resolve();
4280 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
4281   assert_different_registers(result, tmp);
4282 
4283   // Only 64 bit platforms support GCs that require a tmp register
4284   // Only IN_HEAP loads require a thread_tmp register
4285   // OopHandle::resolve is an indirection like jobject.
4286   access_load_at(T_OBJECT, IN_NATIVE,
4287                  result, Address(result, 0), tmp, /*tmp_thread*/noreg);
4288 }
4289 
4290 // ((WeakHandle)result).resolve();
4291 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
4292   assert_different_registers(rresult, rtmp);
4293   Label resolved;
4294 
4295   // A null weak handle resolves to null.
4296   cmpptr(rresult, 0);
4297   jcc(Assembler::equal, resolved);
4298 
4299   // Only 64 bit platforms support GCs that require a tmp register
4300   // Only IN_HEAP loads require a thread_tmp register
4301   // WeakHandle::resolve is an indirection like jweak.
4302   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
4303                  rresult, Address(rresult, 0), rtmp, /*tmp_thread*/noreg);
4304   bind(resolved);
4305 }
4306 
4307 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
4308   // get mirror
4309   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
4310   load_method_holder(mirror, method);
4311   movptr(mirror, Address(mirror, mirror_offset));
4312   resolve_oop_handle(mirror, tmp);
4313 }
4314 
4315 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
4316   load_method_holder(rresult, rmethod);
4317   movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
4318 }
4319 
4320 void MacroAssembler::load_method_holder(Register holder, Register method) {
4321   movptr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
4322   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
4323   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
4324 }
4325 
4326 void MacroAssembler::load_klass(Register dst, Register src) {
4327 #ifdef _LP64
4328   if (UseCompressedClassPointers) {
4329     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4330     decode_klass_not_null(dst);
4331   } else
4332 #endif
4333     movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4334 }
4335 
4336 void MacroAssembler::load_prototype_header(Register dst, Register src) {
4337   load_klass(dst, src);
4338   movptr(dst, Address(dst, Klass::prototype_header_offset()));
4339 }
4340 
4341 void MacroAssembler::store_klass(Register dst, Register src) {
4342 #ifdef _LP64
4343   if (UseCompressedClassPointers) {
4344     encode_klass_not_null(src);
4345     movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4346   } else
4347 #endif
4348     movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4349 }
4350 
4351 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
4352                                     Register tmp1, Register thread_tmp) {
4353   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4354   decorators = AccessInternal::decorator_fixup(decorators);
4355   bool as_raw = (decorators &amp; AS_RAW) != 0;
4356   if (as_raw) {
4357     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4358   } else {
4359     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4360   }
4361 }
4362 
4363 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
4364                                      Register tmp1, Register tmp2) {
4365   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4366   decorators = AccessInternal::decorator_fixup(decorators);
4367   bool as_raw = (decorators &amp; AS_RAW) != 0;
4368   if (as_raw) {
4369     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2);
4370   } else {
4371     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, tmp2);
4372   }
4373 }
4374 
4375 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4376   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4377   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4378     decorators |= ACCESS_READ | ACCESS_WRITE;
4379   }
4380   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4381   return bs-&gt;resolve(this, decorators, obj);
4382 }
4383 
4384 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4385                                    Register thread_tmp, DecoratorSet decorators) {
4386   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4387 }
4388 
4389 // Doesn&#39;t do verfication, generates fixed size code
4390 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4391                                             Register thread_tmp, DecoratorSet decorators) {
4392   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4393 }
4394 
4395 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4396                                     Register tmp2, DecoratorSet decorators) {
4397   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2);
4398 }
4399 
4400 // Used for storing NULLs.
4401 void MacroAssembler::store_heap_oop_null(Address dst) {
4402   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);
4403 }
4404 
4405 #ifdef _LP64
4406 void MacroAssembler::store_klass_gap(Register dst, Register src) {
4407   if (UseCompressedClassPointers) {
4408     // Store to klass gap in destination
4409     movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
4410   }
4411 }
4412 
4413 #ifdef ASSERT
4414 void MacroAssembler::verify_heapbase(const char* msg) {
4415   assert (UseCompressedOops, &quot;should be compressed&quot;);
4416   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4417   if (CheckCompressedOops) {
4418     Label ok;
4419     push(rscratch1); // cmpptr trashes rscratch1
4420     cmpptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4421     jcc(Assembler::equal, ok);
4422     STOP(msg);
4423     bind(ok);
4424     pop(rscratch1);
4425   }
4426 }
4427 #endif
4428 
4429 // Algorithm must match oop.inline.hpp encode_heap_oop.
4430 void MacroAssembler::encode_heap_oop(Register r) {
4431 #ifdef ASSERT
4432   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
4433 #endif
4434   verify_oop_msg(r, &quot;broken oop in encode_heap_oop&quot;);
4435   if (CompressedOops::base() == NULL) {
4436     if (CompressedOops::shift() != 0) {
4437       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4438       shrq(r, LogMinObjAlignmentInBytes);
4439     }
4440     return;
4441   }
4442   testq(r, r);
4443   cmovq(Assembler::equal, r, r12_heapbase);
4444   subq(r, r12_heapbase);
4445   shrq(r, LogMinObjAlignmentInBytes);
4446 }
4447 
4448 void MacroAssembler::encode_heap_oop_not_null(Register r) {
4449 #ifdef ASSERT
4450   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
4451   if (CheckCompressedOops) {
4452     Label ok;
4453     testq(r, r);
4454     jcc(Assembler::notEqual, ok);
4455     STOP(&quot;null oop passed to encode_heap_oop_not_null&quot;);
4456     bind(ok);
4457   }
4458 #endif
4459   verify_oop_msg(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
4460   if (CompressedOops::base() != NULL) {
4461     subq(r, r12_heapbase);
4462   }
4463   if (CompressedOops::shift() != 0) {
4464     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4465     shrq(r, LogMinObjAlignmentInBytes);
4466   }
4467 }
4468 
4469 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
4470 #ifdef ASSERT
4471   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
4472   if (CheckCompressedOops) {
4473     Label ok;
4474     testq(src, src);
4475     jcc(Assembler::notEqual, ok);
4476     STOP(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
4477     bind(ok);
4478   }
4479 #endif
4480   verify_oop_msg(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
4481   if (dst != src) {
4482     movq(dst, src);
4483   }
4484   if (CompressedOops::base() != NULL) {
4485     subq(dst, r12_heapbase);
4486   }
4487   if (CompressedOops::shift() != 0) {
4488     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4489     shrq(dst, LogMinObjAlignmentInBytes);
4490   }
4491 }
4492 
4493 void  MacroAssembler::decode_heap_oop(Register r) {
4494 #ifdef ASSERT
4495   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
4496 #endif
4497   if (CompressedOops::base() == NULL) {
4498     if (CompressedOops::shift() != 0) {
4499       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4500       shlq(r, LogMinObjAlignmentInBytes);
4501     }
4502   } else {
4503     Label done;
4504     shlq(r, LogMinObjAlignmentInBytes);
4505     jccb(Assembler::equal, done);
4506     addq(r, r12_heapbase);
4507     bind(done);
4508   }
4509   verify_oop_msg(r, &quot;broken oop in decode_heap_oop&quot;);
4510 }
4511 
4512 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
4513   // Note: it will change flags
4514   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4515   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4516   // Cannot assert, unverified entry point counts instructions (see .ad file)
4517   // vtableStubs also counts instructions in pd_code_size_limit.
4518   // Also do not verify_oop as this is called by verify_oop.
4519   if (CompressedOops::shift() != 0) {
4520     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4521     shlq(r, LogMinObjAlignmentInBytes);
4522     if (CompressedOops::base() != NULL) {
4523       addq(r, r12_heapbase);
4524     }
4525   } else {
4526     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4527   }
4528 }
4529 
4530 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
4531   // Note: it will change flags
4532   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4533   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4534   // Cannot assert, unverified entry point counts instructions (see .ad file)
4535   // vtableStubs also counts instructions in pd_code_size_limit.
4536   // Also do not verify_oop as this is called by verify_oop.
4537   if (CompressedOops::shift() != 0) {
4538     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4539     if (LogMinObjAlignmentInBytes == Address::times_8) {
4540       leaq(dst, Address(r12_heapbase, src, Address::times_8, 0));
4541     } else {
4542       if (dst != src) {
4543         movq(dst, src);
4544       }
4545       shlq(dst, LogMinObjAlignmentInBytes);
4546       if (CompressedOops::base() != NULL) {
4547         addq(dst, r12_heapbase);
4548       }
4549     }
4550   } else {
4551     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4552     if (dst != src) {
4553       movq(dst, src);
4554     }
4555   }
4556 }
4557 
4558 void MacroAssembler::encode_klass_not_null(Register r) {
4559   if (CompressedKlassPointers::base() != NULL) {
4560     // Use r12 as a scratch register in which to temporarily load the narrow_klass_base.
4561     assert(r != r12_heapbase, &quot;Encoding a klass in r12&quot;);
4562     mov64(r12_heapbase, (int64_t)CompressedKlassPointers::base());
4563     subq(r, r12_heapbase);
4564   }
4565   if (CompressedKlassPointers::shift() != 0) {
4566     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4567     shrq(r, LogKlassAlignmentInBytes);
4568   }
4569   if (CompressedKlassPointers::base() != NULL) {
4570     reinit_heapbase();
4571   }
4572 }
4573 
4574 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
4575   if (dst == src) {
4576     encode_klass_not_null(src);
4577   } else {
4578     if (CompressedKlassPointers::base() != NULL) {
4579       mov64(dst, (int64_t)CompressedKlassPointers::base());
4580       negq(dst);
4581       addq(dst, src);
4582     } else {
4583       movptr(dst, src);
4584     }
4585     if (CompressedKlassPointers::shift() != 0) {
4586       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4587       shrq(dst, LogKlassAlignmentInBytes);
4588     }
4589   }
4590 }
4591 
4592 // Function instr_size_for_decode_klass_not_null() counts the instructions
4593 // generated by decode_klass_not_null(register r) and reinit_heapbase(),
4594 // when (Universe::heap() != NULL).  Hence, if the instructions they
4595 // generate change, then this method needs to be updated.
4596 int MacroAssembler::instr_size_for_decode_klass_not_null() {
4597   assert (UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
4598   if (CompressedKlassPointers::base() != NULL) {
4599     // mov64 + addq + shlq? + mov64  (for reinit_heapbase()).
4600     return (CompressedKlassPointers::shift() == 0 ? 20 : 24);
4601   } else {
4602     // longest load decode klass function, mov64, leaq
4603     return 16;
4604   }
4605 }
4606 
4607 // !!! If the instructions that get generated here change then function
4608 // instr_size_for_decode_klass_not_null() needs to get updated.
4609 void  MacroAssembler::decode_klass_not_null(Register r) {
4610   // Note: it will change flags
4611   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4612   assert(r != r12_heapbase, &quot;Decoding a klass in r12&quot;);
4613   // Cannot assert, unverified entry point counts instructions (see .ad file)
4614   // vtableStubs also counts instructions in pd_code_size_limit.
4615   // Also do not verify_oop as this is called by verify_oop.
4616   if (CompressedKlassPointers::shift() != 0) {
4617     assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4618     shlq(r, LogKlassAlignmentInBytes);
4619   }
4620   // Use r12 as a scratch register in which to temporarily load the narrow_klass_base.
4621   if (CompressedKlassPointers::base() != NULL) {
4622     mov64(r12_heapbase, (int64_t)CompressedKlassPointers::base());
4623     addq(r, r12_heapbase);
4624     reinit_heapbase();
4625   }
4626 }
4627 
4628 void  MacroAssembler::decode_klass_not_null(Register dst, Register src) {
4629   // Note: it will change flags
4630   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4631   if (dst == src) {
4632     decode_klass_not_null(dst);
4633   } else {
4634     // Cannot assert, unverified entry point counts instructions (see .ad file)
4635     // vtableStubs also counts instructions in pd_code_size_limit.
4636     // Also do not verify_oop as this is called by verify_oop.
4637     mov64(dst, (int64_t)CompressedKlassPointers::base());
4638     if (CompressedKlassPointers::shift() != 0) {
4639       assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4640       assert(LogKlassAlignmentInBytes == Address::times_8, &quot;klass not aligned on 64bits?&quot;);
4641       leaq(dst, Address(dst, src, Address::times_8, 0));
4642     } else {
4643       addq(dst, src);
4644     }
4645   }
4646 }
4647 
4648 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4649   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4650   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4651   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4652   int oop_index = oop_recorder()-&gt;find_index(obj);
4653   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4654   mov_narrow_oop(dst, oop_index, rspec);
4655 }
4656 
4657 void  MacroAssembler::set_narrow_oop(Address dst, jobject obj) {
4658   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4659   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4660   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4661   int oop_index = oop_recorder()-&gt;find_index(obj);
4662   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4663   mov_narrow_oop(dst, oop_index, rspec);
4664 }
4665 
4666 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4667   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4668   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4669   int klass_index = oop_recorder()-&gt;find_index(k);
4670   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4671   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4672 }
4673 
4674 void  MacroAssembler::set_narrow_klass(Address dst, Klass* k) {
4675   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4676   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4677   int klass_index = oop_recorder()-&gt;find_index(k);
4678   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4679   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4680 }
4681 
4682 void  MacroAssembler::cmp_narrow_oop(Register dst, jobject obj) {
4683   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4684   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4685   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4686   int oop_index = oop_recorder()-&gt;find_index(obj);
4687   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4688   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
4689 }
4690 
4691 void  MacroAssembler::cmp_narrow_oop(Address dst, jobject obj) {
4692   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4693   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4694   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4695   int oop_index = oop_recorder()-&gt;find_index(obj);
4696   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4697   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
4698 }
4699 
4700 void  MacroAssembler::cmp_narrow_klass(Register dst, Klass* k) {
4701   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4702   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4703   int klass_index = oop_recorder()-&gt;find_index(k);
4704   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4705   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4706 }
4707 
4708 void  MacroAssembler::cmp_narrow_klass(Address dst, Klass* k) {
4709   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4710   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4711   int klass_index = oop_recorder()-&gt;find_index(k);
4712   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4713   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4714 }
4715 
4716 void MacroAssembler::reinit_heapbase() {
4717   if (UseCompressedOops || UseCompressedClassPointers) {
4718     if (Universe::heap() != NULL) {
4719       if (CompressedOops::base() == NULL) {
4720         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
4721       } else {
4722         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
4723       }
4724     } else {
4725       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4726     }
4727   }
4728 }
4729 
4730 #endif // _LP64
4731 
4732 // C2 compiled method&#39;s prolog code.
4733 void MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {
4734 
4735   // WARNING: Initial instruction MUST be 5 bytes or longer so that
4736   // NativeJump::patch_verified_entry will be able to patch out the entry
4737   // code safely. The push to verify stack depth is ok at 5 bytes,
4738   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
4739   // stack bang then we must use the 6 byte frame allocation even if
4740   // we have no frame. :-(
4741   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
4742 
4743   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
4744   // Remove word for return addr
4745   framesize -= wordSize;
4746   stack_bang_size -= wordSize;
4747 
4748   // Calls to C2R adapters often do not accept exceptional returns.
4749   // We require that their callers must bang for them.  But be careful, because
4750   // some VM calls (such as call site linkage) can use several kilobytes of
4751   // stack.  But the stack safety zone should account for that.
4752   // See bugs 4446381, 4468289, 4497237.
4753   if (stack_bang_size &gt; 0) {
4754     generate_stack_overflow_check(stack_bang_size);
4755 
4756     // We always push rbp, so that on return to interpreter rbp, will be
4757     // restored correctly and we can correct the stack.
4758     push(rbp);
4759     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
4760     if (PreserveFramePointer) {
4761       mov(rbp, rsp);
4762     }
4763     // Remove word for ebp
4764     framesize -= wordSize;
4765 
4766     // Create frame
4767     if (framesize) {
4768       subptr(rsp, framesize);
4769     }
4770   } else {
4771     // Create frame (force generation of a 4 byte immediate value)
4772     subptr_imm32(rsp, framesize);
4773 
4774     // Save RBP register now.
4775     framesize -= wordSize;
4776     movptr(Address(rsp, framesize), rbp);
4777     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
4778     if (PreserveFramePointer) {
4779       movptr(rbp, rsp);
4780       if (framesize &gt; 0) {
4781         addptr(rbp, framesize);
4782       }
4783     }
4784   }
4785 
4786   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
4787     framesize -= wordSize;
4788     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
4789   }
4790 
4791 #ifndef _LP64
4792   // If method sets FPU control word do it now
4793   if (fp_mode_24b) {
4794     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
4795   }
4796   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
4797     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
4798   }
4799 #endif
4800 
4801 #ifdef ASSERT
4802   if (VerifyStackAtCalls) {
4803     Label L;
4804     push(rax);
4805     mov(rax, rsp);
4806     andptr(rax, StackAlignmentInBytes-1);
4807     cmpptr(rax, StackAlignmentInBytes-wordSize);
4808     pop(rax);
4809     jcc(Assembler::equal, L);
4810     STOP(&quot;Stack is not properly aligned!&quot;);
4811     bind(L);
4812   }
4813 #endif
4814 
4815   if (!is_stub) {
4816     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4817     bs-&gt;nmethod_entry_barrier(this);
4818   }
4819 }
4820 
4821 // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
4822 void MacroAssembler::xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp) {
4823   // cnt - number of qwords (8-byte words).
4824   // base - start address, qword aligned.
4825   Label L_zero_64_bytes, L_loop, L_sloop, L_tail, L_end;
4826   if (UseAVX &gt;= 2) {
4827     vpxor(xtmp, xtmp, xtmp, AVX_256bit);
4828   } else {
4829     pxor(xtmp, xtmp);
4830   }
4831   jmp(L_zero_64_bytes);
4832 
4833   BIND(L_loop);
4834   if (UseAVX &gt;= 2) {
4835     vmovdqu(Address(base,  0), xtmp);
4836     vmovdqu(Address(base, 32), xtmp);
4837   } else {
4838     movdqu(Address(base,  0), xtmp);
4839     movdqu(Address(base, 16), xtmp);
4840     movdqu(Address(base, 32), xtmp);
4841     movdqu(Address(base, 48), xtmp);
4842   }
4843   addptr(base, 64);
4844 
4845   BIND(L_zero_64_bytes);
4846   subptr(cnt, 8);
4847   jccb(Assembler::greaterEqual, L_loop);
4848   addptr(cnt, 4);
4849   jccb(Assembler::less, L_tail);
4850   // Copy trailing 32 bytes
4851   if (UseAVX &gt;= 2) {
4852     vmovdqu(Address(base, 0), xtmp);
4853   } else {
4854     movdqu(Address(base,  0), xtmp);
4855     movdqu(Address(base, 16), xtmp);
4856   }
4857   addptr(base, 32);
4858   subptr(cnt, 4);
4859 
4860   BIND(L_tail);
4861   addptr(cnt, 4);
4862   jccb(Assembler::lessEqual, L_end);
4863   decrement(cnt);
4864 
4865   BIND(L_sloop);
4866   movq(Address(base, 0), xtmp);
4867   addptr(base, 8);
4868   decrement(cnt);
4869   jccb(Assembler::greaterEqual, L_sloop);
4870   BIND(L_end);
4871 }
4872 
4873 void MacroAssembler::clear_mem(Register base, Register cnt, Register tmp, XMMRegister xtmp, bool is_large) {
4874   // cnt - number of qwords (8-byte words).
4875   // base - start address, qword aligned.
4876   // is_large - if optimizers know cnt is larger than InitArrayShortSize
4877   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
4878   assert(tmp==rax,   &quot;tmp register must be eax for rep stos&quot;);
4879   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
4880   assert(InitArrayShortSize % BytesPerLong == 0,
4881     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
4882 
4883   Label DONE;
4884 
4885   if (!is_large || !UseXMMForObjInit) {
4886     xorptr(tmp, tmp);
4887   }
4888 
4889   if (!is_large) {
4890     Label LOOP, LONG;
4891     cmpptr(cnt, InitArrayShortSize/BytesPerLong);
4892     jccb(Assembler::greater, LONG);
4893 
4894     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
4895 
4896     decrement(cnt);
4897     jccb(Assembler::negative, DONE); // Zero length
4898 
4899     // Use individual pointer-sized stores for small counts:
4900     BIND(LOOP);
4901     movptr(Address(base, cnt, Address::times_ptr), tmp);
4902     decrement(cnt);
4903     jccb(Assembler::greaterEqual, LOOP);
4904     jmpb(DONE);
4905 
4906     BIND(LONG);
4907   }
4908 
4909   // Use longer rep-prefixed ops for non-small counts:
4910   if (UseFastStosb) {
4911     shlptr(cnt, 3); // convert to number of bytes
4912     rep_stosb();
4913   } else if (UseXMMForObjInit) {
4914     movptr(tmp, base);
4915     xmm_clear_mem(tmp, cnt, xtmp);
4916   } else {
4917     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
4918     rep_stos();
4919   }
4920 
4921   BIND(DONE);
4922 }
4923 
4924 void MacroAssembler::generate_fill(BasicType t, bool aligned,
4925                                    Register to, Register value, Register count,
4926                                    Register rtmp, XMMRegister xtmp) {
4927   ShortBranchVerifier sbv(this);
4928   assert_different_registers(to, value, count, rtmp);
4929   Label L_exit;
4930   Label L_fill_2_bytes, L_fill_4_bytes;
4931 
4932   int shift = -1;
4933   switch (t) {
4934     case T_BYTE:
4935       shift = 2;
4936       break;
4937     case T_SHORT:
4938       shift = 1;
4939       break;
4940     case T_INT:
4941       shift = 0;
4942       break;
4943     default: ShouldNotReachHere();
4944   }
4945 
4946   if (t == T_BYTE) {
4947     andl(value, 0xff);
4948     movl(rtmp, value);
4949     shll(rtmp, 8);
4950     orl(value, rtmp);
4951   }
4952   if (t == T_SHORT) {
4953     andl(value, 0xffff);
4954   }
4955   if (t == T_BYTE || t == T_SHORT) {
4956     movl(rtmp, value);
4957     shll(rtmp, 16);
4958     orl(value, rtmp);
4959   }
4960 
4961   cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) fill by element
4962   jcc(Assembler::below, L_fill_4_bytes); // use unsigned cmp
4963   if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {
4964     Label L_skip_align2;
4965     // align source address at 4 bytes address boundary
4966     if (t == T_BYTE) {
4967       Label L_skip_align1;
4968       // One byte misalignment happens only for byte arrays
4969       testptr(to, 1);
4970       jccb(Assembler::zero, L_skip_align1);
4971       movb(Address(to, 0), value);
4972       increment(to);
4973       decrement(count);
4974       BIND(L_skip_align1);
4975     }
4976     // Two bytes misalignment happens only for byte and short (char) arrays
4977     testptr(to, 2);
4978     jccb(Assembler::zero, L_skip_align2);
4979     movw(Address(to, 0), value);
4980     addptr(to, 2);
4981     subl(count, 1&lt;&lt;(shift-1));
4982     BIND(L_skip_align2);
4983   }
4984   if (UseSSE &lt; 2) {
4985     Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
4986     // Fill 32-byte chunks
4987     subl(count, 8 &lt;&lt; shift);
4988     jcc(Assembler::less, L_check_fill_8_bytes);
4989     align(16);
4990 
4991     BIND(L_fill_32_bytes_loop);
4992 
4993     for (int i = 0; i &lt; 32; i += 4) {
4994       movl(Address(to, i), value);
4995     }
4996 
4997     addptr(to, 32);
4998     subl(count, 8 &lt;&lt; shift);
4999     jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5000     BIND(L_check_fill_8_bytes);
5001     addl(count, 8 &lt;&lt; shift);
5002     jccb(Assembler::zero, L_exit);
5003     jmpb(L_fill_8_bytes);
5004 
5005     //
5006     // length is too short, just fill qwords
5007     //
5008     BIND(L_fill_8_bytes_loop);
5009     movl(Address(to, 0), value);
5010     movl(Address(to, 4), value);
5011     addptr(to, 8);
5012     BIND(L_fill_8_bytes);
5013     subl(count, 1 &lt;&lt; (shift + 1));
5014     jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5015     // fall through to fill 4 bytes
5016   } else {
5017     Label L_fill_32_bytes;
5018     if (!UseUnalignedLoadStores) {
5019       // align to 8 bytes, we know we are 4 byte aligned to start
5020       testptr(to, 4);
5021       jccb(Assembler::zero, L_fill_32_bytes);
5022       movl(Address(to, 0), value);
5023       addptr(to, 4);
5024       subl(count, 1&lt;&lt;shift);
5025     }
5026     BIND(L_fill_32_bytes);
5027     {
5028       assert( UseSSE &gt;= 2, &quot;supported cpu only&quot; );
5029       Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5030       movdl(xtmp, value);
5031       if (UseAVX &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
5032         Label L_check_fill_32_bytes;
5033         if (UseAVX &gt; 2) {
5034           // Fill 64-byte chunks
5035           Label L_fill_64_bytes_loop_avx3, L_check_fill_64_bytes_avx2;
5036 
5037           // If number of bytes to fill &lt; AVX3Threshold, perform fill using AVX2
5038           cmpl(count, AVX3Threshold);
5039           jccb(Assembler::below, L_check_fill_64_bytes_avx2);
5040 
5041           vpbroadcastd(xtmp, xtmp, Assembler::AVX_512bit);
5042 
5043           subl(count, 16 &lt;&lt; shift);
5044           jccb(Assembler::less, L_check_fill_32_bytes);
5045           align(16);
5046 
5047           BIND(L_fill_64_bytes_loop_avx3);
5048           evmovdqul(Address(to, 0), xtmp, Assembler::AVX_512bit);
5049           addptr(to, 64);
5050           subl(count, 16 &lt;&lt; shift);
5051           jcc(Assembler::greaterEqual, L_fill_64_bytes_loop_avx3);
5052           jmpb(L_check_fill_32_bytes);
5053 
5054           BIND(L_check_fill_64_bytes_avx2);
5055         }
5056         // Fill 64-byte chunks
5057         Label L_fill_64_bytes_loop;
5058         vpbroadcastd(xtmp, xtmp, Assembler::AVX_256bit);
5059 
5060         subl(count, 16 &lt;&lt; shift);
5061         jcc(Assembler::less, L_check_fill_32_bytes);
5062         align(16);
5063 
5064         BIND(L_fill_64_bytes_loop);
5065         vmovdqu(Address(to, 0), xtmp);
5066         vmovdqu(Address(to, 32), xtmp);
5067         addptr(to, 64);
5068         subl(count, 16 &lt;&lt; shift);
5069         jcc(Assembler::greaterEqual, L_fill_64_bytes_loop);
5070 
5071         BIND(L_check_fill_32_bytes);
5072         addl(count, 8 &lt;&lt; shift);
5073         jccb(Assembler::less, L_check_fill_8_bytes);
5074         vmovdqu(Address(to, 0), xtmp);
5075         addptr(to, 32);
5076         subl(count, 8 &lt;&lt; shift);
5077 
5078         BIND(L_check_fill_8_bytes);
5079         // clean upper bits of YMM registers
5080         movdl(xtmp, value);
5081         pshufd(xtmp, xtmp, 0);
5082       } else {
5083         // Fill 32-byte chunks
5084         pshufd(xtmp, xtmp, 0);
5085 
5086         subl(count, 8 &lt;&lt; shift);
5087         jcc(Assembler::less, L_check_fill_8_bytes);
5088         align(16);
5089 
5090         BIND(L_fill_32_bytes_loop);
5091 
5092         if (UseUnalignedLoadStores) {
5093           movdqu(Address(to, 0), xtmp);
5094           movdqu(Address(to, 16), xtmp);
5095         } else {
5096           movq(Address(to, 0), xtmp);
5097           movq(Address(to, 8), xtmp);
5098           movq(Address(to, 16), xtmp);
5099           movq(Address(to, 24), xtmp);
5100         }
5101 
5102         addptr(to, 32);
5103         subl(count, 8 &lt;&lt; shift);
5104         jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5105 
5106         BIND(L_check_fill_8_bytes);
5107       }
5108       addl(count, 8 &lt;&lt; shift);
5109       jccb(Assembler::zero, L_exit);
5110       jmpb(L_fill_8_bytes);
5111 
5112       //
5113       // length is too short, just fill qwords
5114       //
5115       BIND(L_fill_8_bytes_loop);
5116       movq(Address(to, 0), xtmp);
5117       addptr(to, 8);
5118       BIND(L_fill_8_bytes);
5119       subl(count, 1 &lt;&lt; (shift + 1));
5120       jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5121     }
5122   }
5123   // fill trailing 4 bytes
5124   BIND(L_fill_4_bytes);
5125   testl(count, 1&lt;&lt;shift);
5126   jccb(Assembler::zero, L_fill_2_bytes);
5127   movl(Address(to, 0), value);
5128   if (t == T_BYTE || t == T_SHORT) {
5129     Label L_fill_byte;
5130     addptr(to, 4);
5131     BIND(L_fill_2_bytes);
5132     // fill trailing 2 bytes
5133     testl(count, 1&lt;&lt;(shift-1));
5134     jccb(Assembler::zero, L_fill_byte);
5135     movw(Address(to, 0), value);
5136     if (t == T_BYTE) {
5137       addptr(to, 2);
5138       BIND(L_fill_byte);
5139       // fill trailing byte
5140       testl(count, 1);
5141       jccb(Assembler::zero, L_exit);
5142       movb(Address(to, 0), value);
5143     } else {
5144       BIND(L_fill_byte);
5145     }
5146   } else {
5147     BIND(L_fill_2_bytes);
5148   }
5149   BIND(L_exit);
5150 }
5151 
5152 // encode char[] to byte[] in ISO_8859_1
5153    //@HotSpotIntrinsicCandidate
5154    //private static int implEncodeISOArray(byte[] sa, int sp,
5155    //byte[] da, int dp, int len) {
5156    //  int i = 0;
5157    //  for (; i &lt; len; i++) {
5158    //    char c = StringUTF16.getChar(sa, sp++);
5159    //    if (c &gt; &#39;\u00FF&#39;)
5160    //      break;
5161    //    da[dp++] = (byte)c;
5162    //  }
5163    //  return i;
5164    //}
5165 void MacroAssembler::encode_iso_array(Register src, Register dst, Register len,
5166   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
5167   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
5168   Register tmp5, Register result) {
5169 
5170   // rsi: src
5171   // rdi: dst
5172   // rdx: len
5173   // rcx: tmp5
5174   // rax: result
5175   ShortBranchVerifier sbv(this);
5176   assert_different_registers(src, dst, len, tmp5, result);
5177   Label L_done, L_copy_1_char, L_copy_1_char_exit;
5178 
5179   // set result
5180   xorl(result, result);
5181   // check for zero length
5182   testl(len, len);
5183   jcc(Assembler::zero, L_done);
5184 
5185   movl(result, len);
5186 
5187   // Setup pointers
5188   lea(src, Address(src, len, Address::times_2)); // char[]
5189   lea(dst, Address(dst, len, Address::times_1)); // byte[]
5190   negptr(len);
5191 
5192   if (UseSSE42Intrinsics || UseAVX &gt;= 2) {
5193     Label L_copy_8_chars, L_copy_8_chars_exit;
5194     Label L_chars_16_check, L_copy_16_chars, L_copy_16_chars_exit;
5195 
5196     if (UseAVX &gt;= 2) {
5197       Label L_chars_32_check, L_copy_32_chars, L_copy_32_chars_exit;
5198       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5199       movdl(tmp1Reg, tmp5);
5200       vpbroadcastd(tmp1Reg, tmp1Reg, Assembler::AVX_256bit);
5201       jmp(L_chars_32_check);
5202 
5203       bind(L_copy_32_chars);
5204       vmovdqu(tmp3Reg, Address(src, len, Address::times_2, -64));
5205       vmovdqu(tmp4Reg, Address(src, len, Address::times_2, -32));
5206       vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5207       vptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5208       jccb(Assembler::notZero, L_copy_32_chars_exit);
5209       vpackuswb(tmp3Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5210       vpermq(tmp4Reg, tmp3Reg, 0xD8, /* vector_len */ 1);
5211       vmovdqu(Address(dst, len, Address::times_1, -32), tmp4Reg);
5212 
5213       bind(L_chars_32_check);
5214       addptr(len, 32);
5215       jcc(Assembler::lessEqual, L_copy_32_chars);
5216 
5217       bind(L_copy_32_chars_exit);
5218       subptr(len, 16);
5219       jccb(Assembler::greater, L_copy_16_chars_exit);
5220 
5221     } else if (UseSSE42Intrinsics) {
5222       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5223       movdl(tmp1Reg, tmp5);
5224       pshufd(tmp1Reg, tmp1Reg, 0);
5225       jmpb(L_chars_16_check);
5226     }
5227 
5228     bind(L_copy_16_chars);
5229     if (UseAVX &gt;= 2) {
5230       vmovdqu(tmp2Reg, Address(src, len, Address::times_2, -32));
5231       vptest(tmp2Reg, tmp1Reg);
5232       jcc(Assembler::notZero, L_copy_16_chars_exit);
5233       vpackuswb(tmp2Reg, tmp2Reg, tmp1Reg, /* vector_len */ 1);
5234       vpermq(tmp3Reg, tmp2Reg, 0xD8, /* vector_len */ 1);
5235     } else {
5236       if (UseAVX &gt; 0) {
5237         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5238         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5239         vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 0);
5240       } else {
5241         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5242         por(tmp2Reg, tmp3Reg);
5243         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5244         por(tmp2Reg, tmp4Reg);
5245       }
5246       ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5247       jccb(Assembler::notZero, L_copy_16_chars_exit);
5248       packuswb(tmp3Reg, tmp4Reg);
5249     }
5250     movdqu(Address(dst, len, Address::times_1, -16), tmp3Reg);
5251 
5252     bind(L_chars_16_check);
5253     addptr(len, 16);
5254     jcc(Assembler::lessEqual, L_copy_16_chars);
5255 
5256     bind(L_copy_16_chars_exit);
5257     if (UseAVX &gt;= 2) {
5258       // clean upper bits of YMM registers
5259       vpxor(tmp2Reg, tmp2Reg);
5260       vpxor(tmp3Reg, tmp3Reg);
5261       vpxor(tmp4Reg, tmp4Reg);
5262       movdl(tmp1Reg, tmp5);
5263       pshufd(tmp1Reg, tmp1Reg, 0);
5264     }
5265     subptr(len, 8);
5266     jccb(Assembler::greater, L_copy_8_chars_exit);
5267 
5268     bind(L_copy_8_chars);
5269     movdqu(tmp3Reg, Address(src, len, Address::times_2, -16));
5270     ptest(tmp3Reg, tmp1Reg);
5271     jccb(Assembler::notZero, L_copy_8_chars_exit);
5272     packuswb(tmp3Reg, tmp1Reg);
5273     movq(Address(dst, len, Address::times_1, -8), tmp3Reg);
5274     addptr(len, 8);
5275     jccb(Assembler::lessEqual, L_copy_8_chars);
5276 
5277     bind(L_copy_8_chars_exit);
5278     subptr(len, 8);
5279     jccb(Assembler::zero, L_done);
5280   }
5281 
5282   bind(L_copy_1_char);
5283   load_unsigned_short(tmp5, Address(src, len, Address::times_2, 0));
5284   testl(tmp5, 0xff00);      // check if Unicode char
5285   jccb(Assembler::notZero, L_copy_1_char_exit);
5286   movb(Address(dst, len, Address::times_1, 0), tmp5);
5287   addptr(len, 1);
5288   jccb(Assembler::less, L_copy_1_char);
5289 
5290   bind(L_copy_1_char_exit);
5291   addptr(result, len); // len is negative count of not processed elements
5292 
5293   bind(L_done);
5294 }
5295 
5296 #ifdef _LP64
5297 /**
5298  * Helper for multiply_to_len().
5299  */
5300 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
5301   addq(dest_lo, src1);
5302   adcq(dest_hi, 0);
5303   addq(dest_lo, src2);
5304   adcq(dest_hi, 0);
5305 }
5306 
5307 /**
5308  * Multiply 64 bit by 64 bit first loop.
5309  */
5310 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
5311                                            Register y, Register y_idx, Register z,
5312                                            Register carry, Register product,
5313                                            Register idx, Register kdx) {
5314   //
5315   //  jlong carry, x[], y[], z[];
5316   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
5317   //    huge_128 product = y[idx] * x[xstart] + carry;
5318   //    z[kdx] = (jlong)product;
5319   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
5320   //  }
5321   //  z[xstart] = carry;
5322   //
5323 
5324   Label L_first_loop, L_first_loop_exit;
5325   Label L_one_x, L_one_y, L_multiply;
5326 
5327   decrementl(xstart);
5328   jcc(Assembler::negative, L_one_x);
5329 
5330   movq(x_xstart, Address(x, xstart, Address::times_4,  0));
5331   rorq(x_xstart, 32); // convert big-endian to little-endian
5332 
5333   bind(L_first_loop);
5334   decrementl(idx);
5335   jcc(Assembler::negative, L_first_loop_exit);
5336   decrementl(idx);
5337   jcc(Assembler::negative, L_one_y);
5338   movq(y_idx, Address(y, idx, Address::times_4,  0));
5339   rorq(y_idx, 32); // convert big-endian to little-endian
5340   bind(L_multiply);
5341   movq(product, x_xstart);
5342   mulq(y_idx); // product(rax) * y_idx -&gt; rdx:rax
5343   addq(product, carry);
5344   adcq(rdx, 0);
5345   subl(kdx, 2);
5346   movl(Address(z, kdx, Address::times_4,  4), product);
5347   shrq(product, 32);
5348   movl(Address(z, kdx, Address::times_4,  0), product);
5349   movq(carry, rdx);
5350   jmp(L_first_loop);
5351 
5352   bind(L_one_y);
5353   movl(y_idx, Address(y,  0));
5354   jmp(L_multiply);
5355 
5356   bind(L_one_x);
5357   movl(x_xstart, Address(x,  0));
5358   jmp(L_first_loop);
5359 
5360   bind(L_first_loop_exit);
5361 }
5362 
5363 /**
5364  * Multiply 64 bit by 64 bit and add 128 bit.
5365  */
5366 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y, Register z,
5367                                             Register yz_idx, Register idx,
5368                                             Register carry, Register product, int offset) {
5369   //     huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
5370   //     z[kdx] = (jlong)product;
5371 
5372   movq(yz_idx, Address(y, idx, Address::times_4,  offset));
5373   rorq(yz_idx, 32); // convert big-endian to little-endian
5374   movq(product, x_xstart);
5375   mulq(yz_idx);     // product(rax) * yz_idx -&gt; rdx:product(rax)
5376   movq(yz_idx, Address(z, idx, Address::times_4,  offset));
5377   rorq(yz_idx, 32); // convert big-endian to little-endian
5378 
5379   add2_with_carry(rdx, product, carry, yz_idx);
5380 
5381   movl(Address(z, idx, Address::times_4,  offset+4), product);
5382   shrq(product, 32);
5383   movl(Address(z, idx, Address::times_4,  offset), product);
5384 
5385 }
5386 
5387 /**
5388  * Multiply 128 bit by 128 bit. Unrolled inner loop.
5389  */
5390 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
5391                                              Register yz_idx, Register idx, Register jdx,
5392                                              Register carry, Register product,
5393                                              Register carry2) {
5394   //   jlong carry, x[], y[], z[];
5395   //   int kdx = ystart+1;
5396   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
5397   //     huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
5398   //     z[kdx+idx+1] = (jlong)product;
5399   //     jlong carry2  = (jlong)(product &gt;&gt;&gt; 64);
5400   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
5401   //     z[kdx+idx] = (jlong)product;
5402   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
5403   //   }
5404   //   idx += 2;
5405   //   if (idx &gt; 0) {
5406   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
5407   //     z[kdx+idx] = (jlong)product;
5408   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
5409   //   }
5410   //
5411 
5412   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
5413 
5414   movl(jdx, idx);
5415   andl(jdx, 0xFFFFFFFC);
5416   shrl(jdx, 2);
5417 
5418   bind(L_third_loop);
5419   subl(jdx, 1);
5420   jcc(Assembler::negative, L_third_loop_exit);
5421   subl(idx, 4);
5422 
5423   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
5424   movq(carry2, rdx);
5425 
5426   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
5427   movq(carry, rdx);
5428   jmp(L_third_loop);
5429 
5430   bind (L_third_loop_exit);
5431 
5432   andl (idx, 0x3);
5433   jcc(Assembler::zero, L_post_third_loop_done);
5434 
5435   Label L_check_1;
5436   subl(idx, 2);
5437   jcc(Assembler::negative, L_check_1);
5438 
5439   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
5440   movq(carry, rdx);
5441 
5442   bind (L_check_1);
5443   addl (idx, 0x2);
5444   andl (idx, 0x1);
5445   subl(idx, 1);
5446   jcc(Assembler::negative, L_post_third_loop_done);
5447 
5448   movl(yz_idx, Address(y, idx, Address::times_4,  0));
5449   movq(product, x_xstart);
5450   mulq(yz_idx); // product(rax) * yz_idx -&gt; rdx:product(rax)
5451   movl(yz_idx, Address(z, idx, Address::times_4,  0));
5452 
5453   add2_with_carry(rdx, product, yz_idx, carry);
5454 
5455   movl(Address(z, idx, Address::times_4,  0), product);
5456   shrq(product, 32);
5457 
5458   shlq(rdx, 32);
5459   orq(product, rdx);
5460   movq(carry, product);
5461 
5462   bind(L_post_third_loop_done);
5463 }
5464 
5465 /**
5466  * Multiply 128 bit by 128 bit using BMI2. Unrolled inner loop.
5467  *
5468  */
5469 void MacroAssembler::multiply_128_x_128_bmi2_loop(Register y, Register z,
5470                                                   Register carry, Register carry2,
5471                                                   Register idx, Register jdx,
5472                                                   Register yz_idx1, Register yz_idx2,
5473                                                   Register tmp, Register tmp3, Register tmp4) {
5474   assert(UseBMI2Instructions, &quot;should be used only when BMI2 is available&quot;);
5475 
5476   //   jlong carry, x[], y[], z[];
5477   //   int kdx = ystart+1;
5478   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
5479   //     huge_128 tmp3 = (y[idx+1] * rdx) + z[kdx+idx+1] + carry;
5480   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
5481   //     huge_128 tmp4 = (y[idx]   * rdx) + z[kdx+idx] + carry2;
5482   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
5483   //     z[kdx+idx+1] = (jlong)tmp3;
5484   //     z[kdx+idx] = (jlong)tmp4;
5485   //   }
5486   //   idx += 2;
5487   //   if (idx &gt; 0) {
5488   //     yz_idx1 = (y[idx] * rdx) + z[kdx+idx] + carry;
5489   //     z[kdx+idx] = (jlong)yz_idx1;
5490   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
5491   //   }
5492   //
5493 
5494   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
5495 
5496   movl(jdx, idx);
5497   andl(jdx, 0xFFFFFFFC);
5498   shrl(jdx, 2);
5499 
5500   bind(L_third_loop);
5501   subl(jdx, 1);
5502   jcc(Assembler::negative, L_third_loop_exit);
5503   subl(idx, 4);
5504 
5505   movq(yz_idx1,  Address(y, idx, Address::times_4,  8));
5506   rorxq(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
5507   movq(yz_idx2, Address(y, idx, Address::times_4,  0));
5508   rorxq(yz_idx2, yz_idx2, 32);
5509 
5510   mulxq(tmp4, tmp3, yz_idx1);  //  yz_idx1 * rdx -&gt; tmp4:tmp3
5511   mulxq(carry2, tmp, yz_idx2); //  yz_idx2 * rdx -&gt; carry2:tmp
5512 
5513   movq(yz_idx1,  Address(z, idx, Address::times_4,  8));
5514   rorxq(yz_idx1, yz_idx1, 32);
5515   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
5516   rorxq(yz_idx2, yz_idx2, 32);
5517 
5518   if (VM_Version::supports_adx()) {
5519     adcxq(tmp3, carry);
5520     adoxq(tmp3, yz_idx1);
5521 
5522     adcxq(tmp4, tmp);
5523     adoxq(tmp4, yz_idx2);
5524 
5525     movl(carry, 0); // does not affect flags
5526     adcxq(carry2, carry);
5527     adoxq(carry2, carry);
5528   } else {
5529     add2_with_carry(tmp4, tmp3, carry, yz_idx1);
5530     add2_with_carry(carry2, tmp4, tmp, yz_idx2);
5531   }
5532   movq(carry, carry2);
5533 
5534   movl(Address(z, idx, Address::times_4, 12), tmp3);
5535   shrq(tmp3, 32);
5536   movl(Address(z, idx, Address::times_4,  8), tmp3);
5537 
5538   movl(Address(z, idx, Address::times_4,  4), tmp4);
5539   shrq(tmp4, 32);
5540   movl(Address(z, idx, Address::times_4,  0), tmp4);
5541 
5542   jmp(L_third_loop);
5543 
5544   bind (L_third_loop_exit);
5545 
5546   andl (idx, 0x3);
5547   jcc(Assembler::zero, L_post_third_loop_done);
5548 
5549   Label L_check_1;
5550   subl(idx, 2);
5551   jcc(Assembler::negative, L_check_1);
5552 
5553   movq(yz_idx1, Address(y, idx, Address::times_4,  0));
5554   rorxq(yz_idx1, yz_idx1, 32);
5555   mulxq(tmp4, tmp3, yz_idx1); //  yz_idx1 * rdx -&gt; tmp4:tmp3
5556   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
5557   rorxq(yz_idx2, yz_idx2, 32);
5558 
5559   add2_with_carry(tmp4, tmp3, carry, yz_idx2);
5560 
5561   movl(Address(z, idx, Address::times_4,  4), tmp3);
5562   shrq(tmp3, 32);
5563   movl(Address(z, idx, Address::times_4,  0), tmp3);
5564   movq(carry, tmp4);
5565 
5566   bind (L_check_1);
5567   addl (idx, 0x2);
5568   andl (idx, 0x1);
5569   subl(idx, 1);
5570   jcc(Assembler::negative, L_post_third_loop_done);
5571   movl(tmp4, Address(y, idx, Address::times_4,  0));
5572   mulxq(carry2, tmp3, tmp4);  //  tmp4 * rdx -&gt; carry2:tmp3
5573   movl(tmp4, Address(z, idx, Address::times_4,  0));
5574 
5575   add2_with_carry(carry2, tmp3, tmp4, carry);
5576 
5577   movl(Address(z, idx, Address::times_4,  0), tmp3);
5578   shrq(tmp3, 32);
5579 
5580   shlq(carry2, 32);
5581   orq(tmp3, carry2);
5582   movq(carry, tmp3);
5583 
5584   bind(L_post_third_loop_done);
5585 }
5586 
5587 /**
5588  * Code for BigInteger::multiplyToLen() instrinsic.
5589  *
5590  * rdi: x
5591  * rax: xlen
5592  * rsi: y
5593  * rcx: ylen
5594  * r8:  z
5595  * r11: zlen
5596  * r12: tmp1
5597  * r13: tmp2
5598  * r14: tmp3
5599  * r15: tmp4
5600  * rbx: tmp5
5601  *
5602  */
5603 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
5604                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {
5605   ShortBranchVerifier sbv(this);
5606   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);
5607 
5608   push(tmp1);
5609   push(tmp2);
5610   push(tmp3);
5611   push(tmp4);
5612   push(tmp5);
5613 
5614   push(xlen);
5615   push(zlen);
5616 
5617   const Register idx = tmp1;
5618   const Register kdx = tmp2;
5619   const Register xstart = tmp3;
5620 
5621   const Register y_idx = tmp4;
5622   const Register carry = tmp5;
5623   const Register product  = xlen;
5624   const Register x_xstart = zlen;  // reuse register
5625 
5626   // First Loop.
5627   //
5628   //  final static long LONG_MASK = 0xffffffffL;
5629   //  int xstart = xlen - 1;
5630   //  int ystart = ylen - 1;
5631   //  long carry = 0;
5632   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
5633   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
5634   //    z[kdx] = (int)product;
5635   //    carry = product &gt;&gt;&gt; 32;
5636   //  }
5637   //  z[xstart] = (int)carry;
5638   //
5639 
5640   movl(idx, ylen);      // idx = ylen;
5641   movl(kdx, zlen);      // kdx = xlen+ylen;
5642   xorq(carry, carry);   // carry = 0;
5643 
5644   Label L_done;
5645 
5646   movl(xstart, xlen);
5647   decrementl(xstart);
5648   jcc(Assembler::negative, L_done);
5649 
5650   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
5651 
5652   Label L_second_loop;
5653   testl(kdx, kdx);
5654   jcc(Assembler::zero, L_second_loop);
5655 
5656   Label L_carry;
5657   subl(kdx, 1);
5658   jcc(Assembler::zero, L_carry);
5659 
5660   movl(Address(z, kdx, Address::times_4,  0), carry);
5661   shrq(carry, 32);
5662   subl(kdx, 1);
5663 
5664   bind(L_carry);
5665   movl(Address(z, kdx, Address::times_4,  0), carry);
5666 
5667   // Second and third (nested) loops.
5668   //
5669   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
5670   //   carry = 0;
5671   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
5672   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
5673   //                    (z[k] &amp; LONG_MASK) + carry;
5674   //     z[k] = (int)product;
5675   //     carry = product &gt;&gt;&gt; 32;
5676   //   }
5677   //   z[i] = (int)carry;
5678   // }
5679   //
5680   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
5681 
5682   const Register jdx = tmp1;
5683 
5684   bind(L_second_loop);
5685   xorl(carry, carry);    // carry = 0;
5686   movl(jdx, ylen);       // j = ystart+1
5687 
5688   subl(xstart, 1);       // i = xstart-1;
5689   jcc(Assembler::negative, L_done);
5690 
5691   push (z);
5692 
5693   Label L_last_x;
5694   lea(z, Address(z, xstart, Address::times_4, 4)); // z = z + k - j
5695   subl(xstart, 1);       // i = xstart-1;
5696   jcc(Assembler::negative, L_last_x);
5697 
5698   if (UseBMI2Instructions) {
5699     movq(rdx,  Address(x, xstart, Address::times_4,  0));
5700     rorxq(rdx, rdx, 32); // convert big-endian to little-endian
5701   } else {
5702     movq(x_xstart, Address(x, xstart, Address::times_4,  0));
5703     rorq(x_xstart, 32);  // convert big-endian to little-endian
5704   }
5705 
5706   Label L_third_loop_prologue;
5707   bind(L_third_loop_prologue);
5708 
5709   push (x);
5710   push (xstart);
5711   push (ylen);
5712 
5713 
5714   if (UseBMI2Instructions) {
5715     multiply_128_x_128_bmi2_loop(y, z, carry, x, jdx, ylen, product, tmp2, x_xstart, tmp3, tmp4);
5716   } else { // !UseBMI2Instructions
5717     multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
5718   }
5719 
5720   pop(ylen);
5721   pop(xlen);
5722   pop(x);
5723   pop(z);
5724 
5725   movl(tmp3, xlen);
5726   addl(tmp3, 1);
5727   movl(Address(z, tmp3, Address::times_4,  0), carry);
5728   subl(tmp3, 1);
5729   jccb(Assembler::negative, L_done);
5730 
5731   shrq(carry, 32);
5732   movl(Address(z, tmp3, Address::times_4,  0), carry);
5733   jmp(L_second_loop);
5734 
5735   // Next infrequent code is moved outside loops.
5736   bind(L_last_x);
5737   if (UseBMI2Instructions) {
5738     movl(rdx, Address(x,  0));
5739   } else {
5740     movl(x_xstart, Address(x,  0));
5741   }
5742   jmp(L_third_loop_prologue);
5743 
5744   bind(L_done);
5745 
5746   pop(zlen);
5747   pop(xlen);
5748 
5749   pop(tmp5);
5750   pop(tmp4);
5751   pop(tmp3);
5752   pop(tmp2);
5753   pop(tmp1);
5754 }
5755 
5756 void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
5757   Register result, Register tmp1, Register tmp2, XMMRegister rymm0, XMMRegister rymm1, XMMRegister rymm2){
5758   assert(UseSSE42Intrinsics, &quot;SSE4.2 must be enabled.&quot;);
5759   Label VECTOR16_LOOP, VECTOR8_LOOP, VECTOR4_LOOP;
5760   Label VECTOR8_TAIL, VECTOR4_TAIL;
5761   Label VECTOR32_NOT_EQUAL, VECTOR16_NOT_EQUAL, VECTOR8_NOT_EQUAL, VECTOR4_NOT_EQUAL;
5762   Label SAME_TILL_END, DONE;
5763   Label BYTES_LOOP, BYTES_TAIL, BYTES_NOT_EQUAL;
5764 
5765   //scale is in rcx in both Win64 and Unix
5766   ShortBranchVerifier sbv(this);
5767 
5768   shlq(length);
5769   xorq(result, result);
5770 
5771   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp;
5772       VM_Version::supports_avx512vlbw()) {
5773     Label VECTOR64_LOOP, VECTOR64_NOT_EQUAL, VECTOR32_TAIL;
5774 
5775     cmpq(length, 64);
5776     jcc(Assembler::less, VECTOR32_TAIL);
5777 
5778     movq(tmp1, length);
5779     andq(tmp1, 0x3F);      // tail count
5780     andq(length, ~(0x3F)); //vector count
5781 
5782     bind(VECTOR64_LOOP);
5783     // AVX512 code to compare 64 byte vectors.
5784     evmovdqub(rymm0, Address(obja, result), Assembler::AVX_512bit);
5785     evpcmpeqb(k7, rymm0, Address(objb, result), Assembler::AVX_512bit);
5786     kortestql(k7, k7);
5787     jcc(Assembler::aboveEqual, VECTOR64_NOT_EQUAL);     // mismatch
5788     addq(result, 64);
5789     subq(length, 64);
5790     jccb(Assembler::notZero, VECTOR64_LOOP);
5791 
5792     //bind(VECTOR64_TAIL);
5793     testq(tmp1, tmp1);
5794     jcc(Assembler::zero, SAME_TILL_END);
5795 
5796     //bind(VECTOR64_TAIL);
5797     // AVX512 code to compare upto 63 byte vectors.
5798     mov64(tmp2, 0xFFFFFFFFFFFFFFFF);
5799     shlxq(tmp2, tmp2, tmp1);
5800     notq(tmp2);
5801     kmovql(k3, tmp2);
5802 
5803     evmovdqub(rymm0, k3, Address(obja, result), Assembler::AVX_512bit);
5804     evpcmpeqb(k7, k3, rymm0, Address(objb, result), Assembler::AVX_512bit);
5805 
5806     ktestql(k7, k3);
5807     jcc(Assembler::below, SAME_TILL_END);     // not mismatch
5808 
5809     bind(VECTOR64_NOT_EQUAL);
5810     kmovql(tmp1, k7);
5811     notq(tmp1);
5812     tzcntq(tmp1, tmp1);
5813     addq(result, tmp1);
5814     shrq(result);
5815     jmp(DONE);
5816     bind(VECTOR32_TAIL);
5817   }
5818 
5819   cmpq(length, 8);
5820   jcc(Assembler::equal, VECTOR8_LOOP);
5821   jcc(Assembler::less, VECTOR4_TAIL);
5822 
5823   if (UseAVX &gt;= 2) {
5824     Label VECTOR16_TAIL, VECTOR32_LOOP;
5825 
5826     cmpq(length, 16);
5827     jcc(Assembler::equal, VECTOR16_LOOP);
5828     jcc(Assembler::less, VECTOR8_LOOP);
5829 
5830     cmpq(length, 32);
5831     jccb(Assembler::less, VECTOR16_TAIL);
5832 
5833     subq(length, 32);
5834     bind(VECTOR32_LOOP);
5835     vmovdqu(rymm0, Address(obja, result));
5836     vmovdqu(rymm1, Address(objb, result));
5837     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_256bit);
5838     vptest(rymm2, rymm2);
5839     jcc(Assembler::notZero, VECTOR32_NOT_EQUAL);//mismatch found
5840     addq(result, 32);
5841     subq(length, 32);
5842     jcc(Assembler::greaterEqual, VECTOR32_LOOP);
5843     addq(length, 32);
5844     jcc(Assembler::equal, SAME_TILL_END);
5845     //falling through if less than 32 bytes left //close the branch here.
5846 
5847     bind(VECTOR16_TAIL);
5848     cmpq(length, 16);
5849     jccb(Assembler::less, VECTOR8_TAIL);
5850     bind(VECTOR16_LOOP);
5851     movdqu(rymm0, Address(obja, result));
5852     movdqu(rymm1, Address(objb, result));
5853     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_128bit);
5854     ptest(rymm2, rymm2);
5855     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
5856     addq(result, 16);
5857     subq(length, 16);
5858     jcc(Assembler::equal, SAME_TILL_END);
5859     //falling through if less than 16 bytes left
5860   } else {//regular intrinsics
5861 
5862     cmpq(length, 16);
5863     jccb(Assembler::less, VECTOR8_TAIL);
5864 
5865     subq(length, 16);
5866     bind(VECTOR16_LOOP);
5867     movdqu(rymm0, Address(obja, result));
5868     movdqu(rymm1, Address(objb, result));
5869     pxor(rymm0, rymm1);
5870     ptest(rymm0, rymm0);
5871     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
5872     addq(result, 16);
5873     subq(length, 16);
5874     jccb(Assembler::greaterEqual, VECTOR16_LOOP);
5875     addq(length, 16);
5876     jcc(Assembler::equal, SAME_TILL_END);
5877     //falling through if less than 16 bytes left
5878   }
5879 
5880   bind(VECTOR8_TAIL);
5881   cmpq(length, 8);
5882   jccb(Assembler::less, VECTOR4_TAIL);
5883   bind(VECTOR8_LOOP);
5884   movq(tmp1, Address(obja, result));
5885   movq(tmp2, Address(objb, result));
5886   xorq(tmp1, tmp2);
5887   testq(tmp1, tmp1);
5888   jcc(Assembler::notZero, VECTOR8_NOT_EQUAL);//mismatch found
5889   addq(result, 8);
5890   subq(length, 8);
5891   jcc(Assembler::equal, SAME_TILL_END);
5892   //falling through if less than 8 bytes left
5893 
5894   bind(VECTOR4_TAIL);
5895   cmpq(length, 4);
5896   jccb(Assembler::less, BYTES_TAIL);
5897   bind(VECTOR4_LOOP);
5898   movl(tmp1, Address(obja, result));
5899   xorl(tmp1, Address(objb, result));
5900   testl(tmp1, tmp1);
5901   jcc(Assembler::notZero, VECTOR4_NOT_EQUAL);//mismatch found
5902   addq(result, 4);
5903   subq(length, 4);
5904   jcc(Assembler::equal, SAME_TILL_END);
5905   //falling through if less than 4 bytes left
5906 
5907   bind(BYTES_TAIL);
5908   bind(BYTES_LOOP);
5909   load_unsigned_byte(tmp1, Address(obja, result));
5910   load_unsigned_byte(tmp2, Address(objb, result));
5911   xorl(tmp1, tmp2);
5912   testl(tmp1, tmp1);
5913   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5914   decq(length);
5915   jcc(Assembler::zero, SAME_TILL_END);
5916   incq(result);
5917   load_unsigned_byte(tmp1, Address(obja, result));
5918   load_unsigned_byte(tmp2, Address(objb, result));
5919   xorl(tmp1, tmp2);
5920   testl(tmp1, tmp1);
5921   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5922   decq(length);
5923   jcc(Assembler::zero, SAME_TILL_END);
5924   incq(result);
5925   load_unsigned_byte(tmp1, Address(obja, result));
5926   load_unsigned_byte(tmp2, Address(objb, result));
5927   xorl(tmp1, tmp2);
5928   testl(tmp1, tmp1);
5929   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5930   jmp(SAME_TILL_END);
5931 
5932   if (UseAVX &gt;= 2) {
5933     bind(VECTOR32_NOT_EQUAL);
5934     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_256bit);
5935     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_256bit);
5936     vpxor(rymm0, rymm0, rymm2, Assembler::AVX_256bit);
5937     vpmovmskb(tmp1, rymm0);
5938     bsfq(tmp1, tmp1);
5939     addq(result, tmp1);
5940     shrq(result);
5941     jmp(DONE);
5942   }
5943 
5944   bind(VECTOR16_NOT_EQUAL);
5945   if (UseAVX &gt;= 2) {
5946     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_128bit);
5947     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_128bit);
5948     pxor(rymm0, rymm2);
5949   } else {
5950     pcmpeqb(rymm2, rymm2);
5951     pxor(rymm0, rymm1);
5952     pcmpeqb(rymm0, rymm1);
5953     pxor(rymm0, rymm2);
5954   }
5955   pmovmskb(tmp1, rymm0);
5956   bsfq(tmp1, tmp1);
5957   addq(result, tmp1);
5958   shrq(result);
5959   jmpb(DONE);
5960 
5961   bind(VECTOR8_NOT_EQUAL);
5962   bind(VECTOR4_NOT_EQUAL);
5963   bsfq(tmp1, tmp1);
5964   shrq(tmp1, 3);
5965   addq(result, tmp1);
5966   bind(BYTES_NOT_EQUAL);
5967   shrq(result);
5968   jmpb(DONE);
5969 
5970   bind(SAME_TILL_END);
5971   mov64(result, -1);
5972 
5973   bind(DONE);
5974 }
5975 
5976 //Helper functions for square_to_len()
5977 
5978 /**
5979  * Store the squares of x[], right shifted one bit (divided by 2) into z[]
5980  * Preserves x and z and modifies rest of the registers.
5981  */
5982 void MacroAssembler::square_rshift(Register x, Register xlen, Register z, Register tmp1, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
5983   // Perform square and right shift by 1
5984   // Handle odd xlen case first, then for even xlen do the following
5985   // jlong carry = 0;
5986   // for (int j=0, i=0; j &lt; xlen; j+=2, i+=4) {
5987   //     huge_128 product = x[j:j+1] * x[j:j+1];
5988   //     z[i:i+1] = (carry &lt;&lt; 63) | (jlong)(product &gt;&gt;&gt; 65);
5989   //     z[i+2:i+3] = (jlong)(product &gt;&gt;&gt; 1);
5990   //     carry = (jlong)product;
5991   // }
5992 
5993   xorq(tmp5, tmp5);     // carry
5994   xorq(rdxReg, rdxReg);
5995   xorl(tmp1, tmp1);     // index for x
5996   xorl(tmp4, tmp4);     // index for z
5997 
5998   Label L_first_loop, L_first_loop_exit;
5999 
6000   testl(xlen, 1);
6001   jccb(Assembler::zero, L_first_loop); //jump if xlen is even
6002 
6003   // Square and right shift by 1 the odd element using 32 bit multiply
6004   movl(raxReg, Address(x, tmp1, Address::times_4, 0));
6005   imulq(raxReg, raxReg);
6006   shrq(raxReg, 1);
6007   adcq(tmp5, 0);
6008   movq(Address(z, tmp4, Address::times_4, 0), raxReg);
6009   incrementl(tmp1);
6010   addl(tmp4, 2);
6011 
6012   // Square and  right shift by 1 the rest using 64 bit multiply
6013   bind(L_first_loop);
6014   cmpptr(tmp1, xlen);
6015   jccb(Assembler::equal, L_first_loop_exit);
6016 
6017   // Square
6018   movq(raxReg, Address(x, tmp1, Address::times_4,  0));
6019   rorq(raxReg, 32);    // convert big-endian to little-endian
6020   mulq(raxReg);        // 64-bit multiply rax * rax -&gt; rdx:rax
6021 
6022   // Right shift by 1 and save carry
6023   shrq(tmp5, 1);       // rdx:rax:tmp5 = (tmp5:rdx:rax) &gt;&gt;&gt; 1
6024   rcrq(rdxReg, 1);
6025   rcrq(raxReg, 1);
6026   adcq(tmp5, 0);
6027 
6028   // Store result in z
6029   movq(Address(z, tmp4, Address::times_4, 0), rdxReg);
6030   movq(Address(z, tmp4, Address::times_4, 8), raxReg);
6031 
6032   // Update indices for x and z
6033   addl(tmp1, 2);
6034   addl(tmp4, 4);
6035   jmp(L_first_loop);
6036 
6037   bind(L_first_loop_exit);
6038 }
6039 
6040 
6041 /**
6042  * Perform the following multiply add operation using BMI2 instructions
6043  * carry:sum = sum + op1*op2 + carry
6044  * op2 should be in rdx
6045  * op2 is preserved, all other registers are modified
6046  */
6047 void MacroAssembler::multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry, Register tmp2) {
6048   // assert op2 is rdx
6049   mulxq(tmp2, op1, op1);  //  op1 * op2 -&gt; tmp2:op1
6050   addq(sum, carry);
6051   adcq(tmp2, 0);
6052   addq(sum, op1);
6053   adcq(tmp2, 0);
6054   movq(carry, tmp2);
6055 }
6056 
6057 /**
6058  * Perform the following multiply add operation:
6059  * carry:sum = sum + op1*op2 + carry
6060  * Preserves op1, op2 and modifies rest of registers
6061  */
6062 void MacroAssembler::multiply_add_64(Register sum, Register op1, Register op2, Register carry, Register rdxReg, Register raxReg) {
6063   // rdx:rax = op1 * op2
6064   movq(raxReg, op2);
6065   mulq(op1);
6066 
6067   //  rdx:rax = sum + carry + rdx:rax
6068   addq(sum, carry);
6069   adcq(rdxReg, 0);
6070   addq(sum, raxReg);
6071   adcq(rdxReg, 0);
6072 
6073   // carry:sum = rdx:sum
6074   movq(carry, rdxReg);
6075 }
6076 
6077 /**
6078  * Add 64 bit long carry into z[] with carry propogation.
6079  * Preserves z and carry register values and modifies rest of registers.
6080  *
6081  */
6082 void MacroAssembler::add_one_64(Register z, Register zlen, Register carry, Register tmp1) {
6083   Label L_fourth_loop, L_fourth_loop_exit;
6084 
6085   movl(tmp1, 1);
6086   subl(zlen, 2);
6087   addq(Address(z, zlen, Address::times_4, 0), carry);
6088 
6089   bind(L_fourth_loop);
6090   jccb(Assembler::carryClear, L_fourth_loop_exit);
6091   subl(zlen, 2);
6092   jccb(Assembler::negative, L_fourth_loop_exit);
6093   addq(Address(z, zlen, Address::times_4, 0), tmp1);
6094   jmp(L_fourth_loop);
6095   bind(L_fourth_loop_exit);
6096 }
6097 
6098 /**
6099  * Shift z[] left by 1 bit.
6100  * Preserves x, len, z and zlen registers and modifies rest of the registers.
6101  *
6102  */
6103 void MacroAssembler::lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {
6104 
6105   Label L_fifth_loop, L_fifth_loop_exit;
6106 
6107   // Fifth loop
6108   // Perform primitiveLeftShift(z, zlen, 1)
6109 
6110   const Register prev_carry = tmp1;
6111   const Register new_carry = tmp4;
6112   const Register value = tmp2;
6113   const Register zidx = tmp3;
6114 
6115   // int zidx, carry;
6116   // long value;
6117   // carry = 0;
6118   // for (zidx = zlen-2; zidx &gt;=0; zidx -= 2) {
6119   //    (carry:value)  = (z[i] &lt;&lt; 1) | carry ;
6120   //    z[i] = value;
6121   // }
6122 
6123   movl(zidx, zlen);
6124   xorl(prev_carry, prev_carry); // clear carry flag and prev_carry register
6125 
6126   bind(L_fifth_loop);
6127   decl(zidx);  // Use decl to preserve carry flag
6128   decl(zidx);
6129   jccb(Assembler::negative, L_fifth_loop_exit);
6130 
6131   if (UseBMI2Instructions) {
6132      movq(value, Address(z, zidx, Address::times_4, 0));
6133      rclq(value, 1);
6134      rorxq(value, value, 32);
6135      movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6136   }
6137   else {
6138     // clear new_carry
6139     xorl(new_carry, new_carry);
6140 
6141     // Shift z[i] by 1, or in previous carry and save new carry
6142     movq(value, Address(z, zidx, Address::times_4, 0));
6143     shlq(value, 1);
6144     adcl(new_carry, 0);
6145 
6146     orq(value, prev_carry);
6147     rorq(value, 0x20);
6148     movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6149 
6150     // Set previous carry = new carry
6151     movl(prev_carry, new_carry);
6152   }
6153   jmp(L_fifth_loop);
6154 
6155   bind(L_fifth_loop_exit);
6156 }
6157 
6158 
6159 /**
6160  * Code for BigInteger::squareToLen() intrinsic
6161  *
6162  * rdi: x
6163  * rsi: len
6164  * r8:  z
6165  * rcx: zlen
6166  * r12: tmp1
6167  * r13: tmp2
6168  * r14: tmp3
6169  * r15: tmp4
6170  * rbx: tmp5
6171  *
6172  */
6173 void MacroAssembler::square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6174 
6175   Label L_second_loop, L_second_loop_exit, L_third_loop, L_third_loop_exit, L_last_x, L_multiply;
6176   push(tmp1);
6177   push(tmp2);
6178   push(tmp3);
6179   push(tmp4);
6180   push(tmp5);
6181 
6182   // First loop
6183   // Store the squares, right shifted one bit (i.e., divided by 2).
6184   square_rshift(x, len, z, tmp1, tmp3, tmp4, tmp5, rdxReg, raxReg);
6185 
6186   // Add in off-diagonal sums.
6187   //
6188   // Second, third (nested) and fourth loops.
6189   // zlen +=2;
6190   // for (int xidx=len-2,zidx=zlen-4; xidx &gt; 0; xidx-=2,zidx-=4) {
6191   //    carry = 0;
6192   //    long op2 = x[xidx:xidx+1];
6193   //    for (int j=xidx-2,k=zidx; j &gt;= 0; j-=2) {
6194   //       k -= 2;
6195   //       long op1 = x[j:j+1];
6196   //       long sum = z[k:k+1];
6197   //       carry:sum = multiply_add_64(sum, op1, op2, carry, tmp_regs);
6198   //       z[k:k+1] = sum;
6199   //    }
6200   //    add_one_64(z, k, carry, tmp_regs);
6201   // }
6202 
6203   const Register carry = tmp5;
6204   const Register sum = tmp3;
6205   const Register op1 = tmp4;
6206   Register op2 = tmp2;
6207 
6208   push(zlen);
6209   push(len);
6210   addl(zlen,2);
6211   bind(L_second_loop);
6212   xorq(carry, carry);
6213   subl(zlen, 4);
6214   subl(len, 2);
6215   push(zlen);
6216   push(len);
6217   cmpl(len, 0);
6218   jccb(Assembler::lessEqual, L_second_loop_exit);
6219 
6220   // Multiply an array by one 64 bit long.
6221   if (UseBMI2Instructions) {
6222     op2 = rdxReg;
6223     movq(op2, Address(x, len, Address::times_4,  0));
6224     rorxq(op2, op2, 32);
6225   }
6226   else {
6227     movq(op2, Address(x, len, Address::times_4,  0));
6228     rorq(op2, 32);
6229   }
6230 
6231   bind(L_third_loop);
6232   decrementl(len);
6233   jccb(Assembler::negative, L_third_loop_exit);
6234   decrementl(len);
6235   jccb(Assembler::negative, L_last_x);
6236 
6237   movq(op1, Address(x, len, Address::times_4,  0));
6238   rorq(op1, 32);
6239 
6240   bind(L_multiply);
6241   subl(zlen, 2);
6242   movq(sum, Address(z, zlen, Address::times_4,  0));
6243 
6244   // Multiply 64 bit by 64 bit and add 64 bits lower half and upper 64 bits as carry.
6245   if (UseBMI2Instructions) {
6246     multiply_add_64_bmi2(sum, op1, op2, carry, tmp2);
6247   }
6248   else {
6249     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6250   }
6251 
6252   movq(Address(z, zlen, Address::times_4, 0), sum);
6253 
6254   jmp(L_third_loop);
6255   bind(L_third_loop_exit);
6256 
6257   // Fourth loop
6258   // Add 64 bit long carry into z with carry propogation.
6259   // Uses offsetted zlen.
6260   add_one_64(z, zlen, carry, tmp1);
6261 
6262   pop(len);
6263   pop(zlen);
6264   jmp(L_second_loop);
6265 
6266   // Next infrequent code is moved outside loops.
6267   bind(L_last_x);
6268   movl(op1, Address(x, 0));
6269   jmp(L_multiply);
6270 
6271   bind(L_second_loop_exit);
6272   pop(len);
6273   pop(zlen);
6274   pop(len);
6275   pop(zlen);
6276 
6277   // Fifth loop
6278   // Shift z left 1 bit.
6279   lshift_by_1(x, len, z, zlen, tmp1, tmp2, tmp3, tmp4);
6280 
6281   // z[zlen-1] |= x[len-1] &amp; 1;
6282   movl(tmp3, Address(x, len, Address::times_4, -4));
6283   andl(tmp3, 1);
6284   orl(Address(z, zlen, Address::times_4,  -4), tmp3);
6285 
6286   pop(tmp5);
6287   pop(tmp4);
6288   pop(tmp3);
6289   pop(tmp2);
6290   pop(tmp1);
6291 }
6292 
6293 /**
6294  * Helper function for mul_add()
6295  * Multiply the in[] by int k and add to out[] starting at offset offs using
6296  * 128 bit by 32 bit multiply and return the carry in tmp5.
6297  * Only quad int aligned length of in[] is operated on in this function.
6298  * k is in rdxReg for BMI2Instructions, for others it is in tmp2.
6299  * This function preserves out, in and k registers.
6300  * len and offset point to the appropriate index in &quot;in&quot; &amp; &quot;out&quot; correspondingly
6301  * tmp5 has the carry.
6302  * other registers are temporary and are modified.
6303  *
6304  */
6305 void MacroAssembler::mul_add_128_x_32_loop(Register out, Register in,
6306   Register offset, Register len, Register tmp1, Register tmp2, Register tmp3,
6307   Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6308 
6309   Label L_first_loop, L_first_loop_exit;
6310 
6311   movl(tmp1, len);
6312   shrl(tmp1, 2);
6313 
6314   bind(L_first_loop);
6315   subl(tmp1, 1);
6316   jccb(Assembler::negative, L_first_loop_exit);
6317 
6318   subl(len, 4);
6319   subl(offset, 4);
6320 
6321   Register op2 = tmp2;
6322   const Register sum = tmp3;
6323   const Register op1 = tmp4;
6324   const Register carry = tmp5;
6325 
6326   if (UseBMI2Instructions) {
6327     op2 = rdxReg;
6328   }
6329 
6330   movq(op1, Address(in, len, Address::times_4,  8));
6331   rorq(op1, 32);
6332   movq(sum, Address(out, offset, Address::times_4,  8));
6333   rorq(sum, 32);
6334   if (UseBMI2Instructions) {
6335     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6336   }
6337   else {
6338     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6339   }
6340   // Store back in big endian from little endian
6341   rorq(sum, 0x20);
6342   movq(Address(out, offset, Address::times_4,  8), sum);
6343 
6344   movq(op1, Address(in, len, Address::times_4,  0));
6345   rorq(op1, 32);
6346   movq(sum, Address(out, offset, Address::times_4,  0));
6347   rorq(sum, 32);
6348   if (UseBMI2Instructions) {
6349     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6350   }
6351   else {
6352     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6353   }
6354   // Store back in big endian from little endian
6355   rorq(sum, 0x20);
6356   movq(Address(out, offset, Address::times_4,  0), sum);
6357 
6358   jmp(L_first_loop);
6359   bind(L_first_loop_exit);
6360 }
6361 
6362 /**
6363  * Code for BigInteger::mulAdd() intrinsic
6364  *
6365  * rdi: out
6366  * rsi: in
6367  * r11: offs (out.length - offset)
6368  * rcx: len
6369  * r8:  k
6370  * r12: tmp1
6371  * r13: tmp2
6372  * r14: tmp3
6373  * r15: tmp4
6374  * rbx: tmp5
6375  * Multiply the in[] by word k and add to out[], return the carry in rax
6376  */
6377 void MacroAssembler::mul_add(Register out, Register in, Register offs,
6378    Register len, Register k, Register tmp1, Register tmp2, Register tmp3,
6379    Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6380 
6381   Label L_carry, L_last_in, L_done;
6382 
6383 // carry = 0;
6384 // for (int j=len-1; j &gt;= 0; j--) {
6385 //    long product = (in[j] &amp; LONG_MASK) * kLong +
6386 //                   (out[offs] &amp; LONG_MASK) + carry;
6387 //    out[offs--] = (int)product;
6388 //    carry = product &gt;&gt;&gt; 32;
6389 // }
6390 //
6391   push(tmp1);
6392   push(tmp2);
6393   push(tmp3);
6394   push(tmp4);
6395   push(tmp5);
6396 
6397   Register op2 = tmp2;
6398   const Register sum = tmp3;
6399   const Register op1 = tmp4;
6400   const Register carry =  tmp5;
6401 
6402   if (UseBMI2Instructions) {
6403     op2 = rdxReg;
6404     movl(op2, k);
6405   }
6406   else {
6407     movl(op2, k);
6408   }
6409 
6410   xorq(carry, carry);
6411 
6412   //First loop
6413 
6414   //Multiply in[] by k in a 4 way unrolled loop using 128 bit by 32 bit multiply
6415   //The carry is in tmp5
6416   mul_add_128_x_32_loop(out, in, offs, len, tmp1, tmp2, tmp3, tmp4, tmp5, rdxReg, raxReg);
6417 
6418   //Multiply the trailing in[] entry using 64 bit by 32 bit, if any
6419   decrementl(len);
6420   jccb(Assembler::negative, L_carry);
6421   decrementl(len);
6422   jccb(Assembler::negative, L_last_in);
6423 
6424   movq(op1, Address(in, len, Address::times_4,  0));
6425   rorq(op1, 32);
6426 
6427   subl(offs, 2);
6428   movq(sum, Address(out, offs, Address::times_4,  0));
6429   rorq(sum, 32);
6430 
6431   if (UseBMI2Instructions) {
6432     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6433   }
6434   else {
6435     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6436   }
6437 
6438   // Store back in big endian from little endian
6439   rorq(sum, 0x20);
6440   movq(Address(out, offs, Address::times_4,  0), sum);
6441 
6442   testl(len, len);
6443   jccb(Assembler::zero, L_carry);
6444 
6445   //Multiply the last in[] entry, if any
6446   bind(L_last_in);
6447   movl(op1, Address(in, 0));
6448   movl(sum, Address(out, offs, Address::times_4,  -4));
6449 
6450   movl(raxReg, k);
6451   mull(op1); //tmp4 * eax -&gt; edx:eax
6452   addl(sum, carry);
6453   adcl(rdxReg, 0);
6454   addl(sum, raxReg);
6455   adcl(rdxReg, 0);
6456   movl(carry, rdxReg);
6457 
6458   movl(Address(out, offs, Address::times_4,  -4), sum);
6459 
6460   bind(L_carry);
6461   //return tmp5/carry as carry in rax
6462   movl(rax, carry);
6463 
6464   bind(L_done);
6465   pop(tmp5);
6466   pop(tmp4);
6467   pop(tmp3);
6468   pop(tmp2);
6469   pop(tmp1);
6470 }
6471 #endif
6472 
6473 /**
6474  * Emits code to update CRC-32 with a byte value according to constants in table
6475  *
6476  * @param [in,out]crc   Register containing the crc.
6477  * @param [in]val       Register containing the byte to fold into the CRC.
6478  * @param [in]table     Register containing the table of crc constants.
6479  *
6480  * uint32_t crc;
6481  * val = crc_table[(val ^ crc) &amp; 0xFF];
6482  * crc = val ^ (crc &gt;&gt; 8);
6483  *
6484  */
6485 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
6486   xorl(val, crc);
6487   andl(val, 0xFF);
6488   shrl(crc, 8); // unsigned shift
6489   xorl(crc, Address(table, val, Address::times_4, 0));
6490 }
6491 
6492 /**
6493 * Fold four 128-bit data chunks
6494 */
6495 void MacroAssembler::fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
6496   evpclmulhdq(xtmp, xK, xcrc, Assembler::AVX_512bit); // [123:64]
6497   evpclmulldq(xcrc, xK, xcrc, Assembler::AVX_512bit); // [63:0]
6498   evpxorq(xcrc, xcrc, Address(buf, offset), Assembler::AVX_512bit /* vector_len */);
6499   evpxorq(xcrc, xcrc, xtmp, Assembler::AVX_512bit /* vector_len */);
6500 }
6501 
6502 /**
6503  * Fold 128-bit data chunk
6504  */
6505 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
6506   if (UseAVX &gt; 0) {
6507     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
6508     vpclmulldq(xcrc, xK, xcrc); // [63:0]
6509     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
6510     pxor(xcrc, xtmp);
6511   } else {
6512     movdqa(xtmp, xcrc);
6513     pclmulhdq(xtmp, xK);   // [123:64]
6514     pclmulldq(xcrc, xK);   // [63:0]
6515     pxor(xcrc, xtmp);
6516     movdqu(xtmp, Address(buf, offset));
6517     pxor(xcrc, xtmp);
6518   }
6519 }
6520 
6521 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
6522   if (UseAVX &gt; 0) {
6523     vpclmulhdq(xtmp, xK, xcrc);
6524     vpclmulldq(xcrc, xK, xcrc);
6525     pxor(xcrc, xbuf);
6526     pxor(xcrc, xtmp);
6527   } else {
6528     movdqa(xtmp, xcrc);
6529     pclmulhdq(xtmp, xK);
6530     pclmulldq(xcrc, xK);
6531     pxor(xcrc, xbuf);
6532     pxor(xcrc, xtmp);
6533   }
6534 }
6535 
6536 /**
6537  * 8-bit folds to compute 32-bit CRC
6538  *
6539  * uint64_t xcrc;
6540  * timesXtoThe32[xcrc &amp; 0xFF] ^ (xcrc &gt;&gt; 8);
6541  */
6542 void MacroAssembler::fold_8bit_crc32(XMMRegister xcrc, Register table, XMMRegister xtmp, Register tmp) {
6543   movdl(tmp, xcrc);
6544   andl(tmp, 0xFF);
6545   movdl(xtmp, Address(table, tmp, Address::times_4, 0));
6546   psrldq(xcrc, 1); // unsigned shift one byte
6547   pxor(xcrc, xtmp);
6548 }
6549 
6550 /**
6551  * uint32_t crc;
6552  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
6553  */
6554 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
6555   movl(tmp, crc);
6556   andl(tmp, 0xFF);
6557   shrl(crc, 8);
6558   xorl(crc, Address(table, tmp, Address::times_4, 0));
6559 }
6560 
6561 /**
6562  * @param crc   register containing existing CRC (32-bit)
6563  * @param buf   register pointing to input byte buffer (byte*)
6564  * @param len   register containing number of bytes
6565  * @param table register that will contain address of CRC table
6566  * @param tmp   scratch register
6567  */
6568 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp) {
6569   assert_different_registers(crc, buf, len, table, tmp, rax);
6570 
6571   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
6572   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
6573 
6574   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
6575   // context for the registers used, where all instructions below are using 128-bit mode
6576   // On EVEX without VL and BW, these instructions will all be AVX.
6577   lea(table, ExternalAddress(StubRoutines::crc_table_addr()));
6578   notl(crc); // ~crc
6579   cmpl(len, 16);
6580   jcc(Assembler::less, L_tail);
6581 
6582   // Align buffer to 16 bytes
6583   movl(tmp, buf);
6584   andl(tmp, 0xF);
6585   jccb(Assembler::zero, L_aligned);
6586   subl(tmp,  16);
6587   addl(len, tmp);
6588 
6589   align(4);
6590   BIND(L_align_loop);
6591   movsbl(rax, Address(buf, 0)); // load byte with sign extension
6592   update_byte_crc32(crc, rax, table);
6593   increment(buf);
6594   incrementl(tmp);
6595   jccb(Assembler::less, L_align_loop);
6596 
6597   BIND(L_aligned);
6598   movl(tmp, len); // save
6599   shrl(len, 4);
6600   jcc(Assembler::zero, L_tail_restore);
6601 
6602   // Fold crc into first bytes of vector
6603   movdqa(xmm1, Address(buf, 0));
6604   movdl(rax, xmm1);
6605   xorl(crc, rax);
6606   if (VM_Version::supports_sse4_1()) {
6607     pinsrd(xmm1, crc, 0);
6608   } else {
6609     pinsrw(xmm1, crc, 0);
6610     shrl(crc, 16);
6611     pinsrw(xmm1, crc, 1);
6612   }
6613   addptr(buf, 16);
6614   subl(len, 4); // len &gt; 0
6615   jcc(Assembler::less, L_fold_tail);
6616 
6617   movdqa(xmm2, Address(buf,  0));
6618   movdqa(xmm3, Address(buf, 16));
6619   movdqa(xmm4, Address(buf, 32));
6620   addptr(buf, 48);
6621   subl(len, 3);
6622   jcc(Assembler::lessEqual, L_fold_512b);
6623 
6624   // Fold total 512 bits of polynomial on each iteration,
6625   // 128 bits per each of 4 parallel streams.
6626   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));
6627 
6628   align(32);
6629   BIND(L_fold_512b_loop);
6630   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
6631   fold_128bit_crc32(xmm2, xmm0, xmm5, buf, 16);
6632   fold_128bit_crc32(xmm3, xmm0, xmm5, buf, 32);
6633   fold_128bit_crc32(xmm4, xmm0, xmm5, buf, 48);
6634   addptr(buf, 64);
6635   subl(len, 4);
6636   jcc(Assembler::greater, L_fold_512b_loop);
6637 
6638   // Fold 512 bits to 128 bits.
6639   BIND(L_fold_512b);
6640   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
6641   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm2);
6642   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm3);
6643   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm4);
6644 
6645   // Fold the rest of 128 bits data chunks
6646   BIND(L_fold_tail);
6647   addl(len, 3);
6648   jccb(Assembler::lessEqual, L_fold_128b);
6649   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
6650 
6651   BIND(L_fold_tail_loop);
6652   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
6653   addptr(buf, 16);
6654   decrementl(len);
6655   jccb(Assembler::greater, L_fold_tail_loop);
6656 
6657   // Fold 128 bits in xmm1 down into 32 bits in crc register.
6658   BIND(L_fold_128b);
6659   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));
6660   if (UseAVX &gt; 0) {
6661     vpclmulqdq(xmm2, xmm0, xmm1, 0x1);
6662     vpand(xmm3, xmm0, xmm2, 0 /* vector_len */);
6663     vpclmulqdq(xmm0, xmm0, xmm3, 0x1);
6664   } else {
6665     movdqa(xmm2, xmm0);
6666     pclmulqdq(xmm2, xmm1, 0x1);
6667     movdqa(xmm3, xmm0);
6668     pand(xmm3, xmm2);
6669     pclmulqdq(xmm0, xmm3, 0x1);
6670   }
6671   psrldq(xmm1, 8);
6672   psrldq(xmm2, 4);
6673   pxor(xmm0, xmm1);
6674   pxor(xmm0, xmm2);
6675 
6676   // 8 8-bit folds to compute 32-bit CRC.
6677   for (int j = 0; j &lt; 4; j++) {
6678     fold_8bit_crc32(xmm0, table, xmm1, rax);
6679   }
6680   movdl(crc, xmm0); // mov 32 bits to general register
6681   for (int j = 0; j &lt; 4; j++) {
6682     fold_8bit_crc32(crc, table, rax);
6683   }
6684 
6685   BIND(L_tail_restore);
6686   movl(len, tmp); // restore
6687   BIND(L_tail);
6688   andl(len, 0xf);
6689   jccb(Assembler::zero, L_exit);
6690 
6691   // Fold the rest of bytes
6692   align(4);
6693   BIND(L_tail_loop);
6694   movsbl(rax, Address(buf, 0)); // load byte with sign extension
6695   update_byte_crc32(crc, rax, table);
6696   increment(buf);
6697   decrementl(len);
6698   jccb(Assembler::greater, L_tail_loop);
6699 
6700   BIND(L_exit);
6701   notl(crc); // ~c
6702 }
6703 
6704 #ifdef _LP64
6705 // S. Gueron / Information Processing Letters 112 (2012) 184
6706 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
6707 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
6708 // Output: the 64-bit carry-less product of B * CONST
6709 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
6710                                      Register tmp1, Register tmp2, Register tmp3) {
6711   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
6712   if (n &gt; 0) {
6713     addq(tmp3, n * 256 * 8);
6714   }
6715   //    Q1 = TABLEExt[n][B &amp; 0xFF];
6716   movl(tmp1, in);
6717   andl(tmp1, 0x000000FF);
6718   shll(tmp1, 3);
6719   addq(tmp1, tmp3);
6720   movq(tmp1, Address(tmp1, 0));
6721 
6722   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
6723   movl(tmp2, in);
6724   shrl(tmp2, 8);
6725   andl(tmp2, 0x000000FF);
6726   shll(tmp2, 3);
6727   addq(tmp2, tmp3);
6728   movq(tmp2, Address(tmp2, 0));
6729 
6730   shlq(tmp2, 8);
6731   xorq(tmp1, tmp2);
6732 
6733   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
6734   movl(tmp2, in);
6735   shrl(tmp2, 16);
6736   andl(tmp2, 0x000000FF);
6737   shll(tmp2, 3);
6738   addq(tmp2, tmp3);
6739   movq(tmp2, Address(tmp2, 0));
6740 
6741   shlq(tmp2, 16);
6742   xorq(tmp1, tmp2);
6743 
6744   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
6745   shrl(in, 24);
6746   andl(in, 0x000000FF);
6747   shll(in, 3);
6748   addq(in, tmp3);
6749   movq(in, Address(in, 0));
6750 
6751   shlq(in, 24);
6752   xorq(in, tmp1);
6753   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
6754 }
6755 
6756 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
6757                                       Register in_out,
6758                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
6759                                       XMMRegister w_xtmp2,
6760                                       Register tmp1,
6761                                       Register n_tmp2, Register n_tmp3) {
6762   if (is_pclmulqdq_supported) {
6763     movdl(w_xtmp1, in_out); // modified blindly
6764 
6765     movl(tmp1, const_or_pre_comp_const_index);
6766     movdl(w_xtmp2, tmp1);
6767     pclmulqdq(w_xtmp1, w_xtmp2, 0);
6768 
6769     movdq(in_out, w_xtmp1);
6770   } else {
6771     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3);
6772   }
6773 }
6774 
6775 // Recombination Alternative 2: No bit-reflections
6776 // T1 = (CRC_A * U1) &lt;&lt; 1
6777 // T2 = (CRC_B * U2) &lt;&lt; 1
6778 // C1 = T1 &gt;&gt; 32
6779 // C2 = T2 &gt;&gt; 32
6780 // T1 = T1 &amp; 0xFFFFFFFF
6781 // T2 = T2 &amp; 0xFFFFFFFF
6782 // T1 = CRC32(0, T1)
6783 // T2 = CRC32(0, T2)
6784 // C1 = C1 ^ T1
6785 // C2 = C2 ^ T2
6786 // CRC = C1 ^ C2 ^ CRC_C
6787 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
6788                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
6789                                      Register tmp1, Register tmp2,
6790                                      Register n_tmp3) {
6791   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
6792   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
6793   shlq(in_out, 1);
6794   movl(tmp1, in_out);
6795   shrq(in_out, 32);
6796   xorl(tmp2, tmp2);
6797   crc32(tmp2, tmp1, 4);
6798   xorl(in_out, tmp2); // we don&#39;t care about upper 32 bit contents here
6799   shlq(in1, 1);
6800   movl(tmp1, in1);
6801   shrq(in1, 32);
6802   xorl(tmp2, tmp2);
6803   crc32(tmp2, tmp1, 4);
6804   xorl(in1, tmp2);
6805   xorl(in_out, in1);
6806   xorl(in_out, in2);
6807 }
6808 
6809 // Set N to predefined value
6810 // Subtract from a lenght of a buffer
6811 // execute in a loop:
6812 // CRC_A = 0xFFFFFFFF, CRC_B = 0, CRC_C = 0
6813 // for i = 1 to N do
6814 //  CRC_A = CRC32(CRC_A, A[i])
6815 //  CRC_B = CRC32(CRC_B, B[i])
6816 //  CRC_C = CRC32(CRC_C, C[i])
6817 // end for
6818 // Recombine
6819 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
6820                                        Register in_out1, Register in_out2, Register in_out3,
6821                                        Register tmp1, Register tmp2, Register tmp3,
6822                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
6823                                        Register tmp4, Register tmp5,
6824                                        Register n_tmp6) {
6825   Label L_processPartitions;
6826   Label L_processPartition;
6827   Label L_exit;
6828 
6829   bind(L_processPartitions);
6830   cmpl(in_out1, 3 * size);
6831   jcc(Assembler::less, L_exit);
6832     xorl(tmp1, tmp1);
6833     xorl(tmp2, tmp2);
6834     movq(tmp3, in_out2);
6835     addq(tmp3, size);
6836 
6837     bind(L_processPartition);
6838       crc32(in_out3, Address(in_out2, 0), 8);
6839       crc32(tmp1, Address(in_out2, size), 8);
6840       crc32(tmp2, Address(in_out2, size * 2), 8);
6841       addq(in_out2, 8);
6842       cmpq(in_out2, tmp3);
6843       jcc(Assembler::less, L_processPartition);
6844     crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
6845             w_xtmp1, w_xtmp2, w_xtmp3,
6846             tmp4, tmp5,
6847             n_tmp6);
6848     addq(in_out2, 2 * size);
6849     subl(in_out1, 3 * size);
6850     jmp(L_processPartitions);
6851 
6852   bind(L_exit);
6853 }
6854 #else
6855 void MacroAssembler::crc32c_ipl_alg4(Register in_out, uint32_t n,
6856                                      Register tmp1, Register tmp2, Register tmp3,
6857                                      XMMRegister xtmp1, XMMRegister xtmp2) {
6858   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
6859   if (n &gt; 0) {
6860     addl(tmp3, n * 256 * 8);
6861   }
6862   //    Q1 = TABLEExt[n][B &amp; 0xFF];
6863   movl(tmp1, in_out);
6864   andl(tmp1, 0x000000FF);
6865   shll(tmp1, 3);
6866   addl(tmp1, tmp3);
6867   movq(xtmp1, Address(tmp1, 0));
6868 
6869   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
6870   movl(tmp2, in_out);
6871   shrl(tmp2, 8);
6872   andl(tmp2, 0x000000FF);
6873   shll(tmp2, 3);
6874   addl(tmp2, tmp3);
6875   movq(xtmp2, Address(tmp2, 0));
6876 
6877   psllq(xtmp2, 8);
6878   pxor(xtmp1, xtmp2);
6879 
6880   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
6881   movl(tmp2, in_out);
6882   shrl(tmp2, 16);
6883   andl(tmp2, 0x000000FF);
6884   shll(tmp2, 3);
6885   addl(tmp2, tmp3);
6886   movq(xtmp2, Address(tmp2, 0));
6887 
6888   psllq(xtmp2, 16);
6889   pxor(xtmp1, xtmp2);
6890 
6891   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
6892   shrl(in_out, 24);
6893   andl(in_out, 0x000000FF);
6894   shll(in_out, 3);
6895   addl(in_out, tmp3);
6896   movq(xtmp2, Address(in_out, 0));
6897 
6898   psllq(xtmp2, 24);
6899   pxor(xtmp1, xtmp2); // Result in CXMM
6900   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
6901 }
6902 
6903 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
6904                                       Register in_out,
6905                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
6906                                       XMMRegister w_xtmp2,
6907                                       Register tmp1,
6908                                       Register n_tmp2, Register n_tmp3) {
6909   if (is_pclmulqdq_supported) {
6910     movdl(w_xtmp1, in_out);
6911 
6912     movl(tmp1, const_or_pre_comp_const_index);
6913     movdl(w_xtmp2, tmp1);
6914     pclmulqdq(w_xtmp1, w_xtmp2, 0);
6915     // Keep result in XMM since GPR is 32 bit in length
6916   } else {
6917     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3, w_xtmp1, w_xtmp2);
6918   }
6919 }
6920 
6921 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
6922                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
6923                                      Register tmp1, Register tmp2,
6924                                      Register n_tmp3) {
6925   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
6926   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
6927 
6928   psllq(w_xtmp1, 1);
6929   movdl(tmp1, w_xtmp1);
6930   psrlq(w_xtmp1, 32);
6931   movdl(in_out, w_xtmp1);
6932 
6933   xorl(tmp2, tmp2);
6934   crc32(tmp2, tmp1, 4);
6935   xorl(in_out, tmp2);
6936 
6937   psllq(w_xtmp2, 1);
6938   movdl(tmp1, w_xtmp2);
6939   psrlq(w_xtmp2, 32);
6940   movdl(in1, w_xtmp2);
6941 
6942   xorl(tmp2, tmp2);
6943   crc32(tmp2, tmp1, 4);
6944   xorl(in1, tmp2);
6945   xorl(in_out, in1);
6946   xorl(in_out, in2);
6947 }
6948 
6949 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
6950                                        Register in_out1, Register in_out2, Register in_out3,
6951                                        Register tmp1, Register tmp2, Register tmp3,
6952                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
6953                                        Register tmp4, Register tmp5,
6954                                        Register n_tmp6) {
6955   Label L_processPartitions;
6956   Label L_processPartition;
6957   Label L_exit;
6958 
6959   bind(L_processPartitions);
6960   cmpl(in_out1, 3 * size);
6961   jcc(Assembler::less, L_exit);
6962     xorl(tmp1, tmp1);
6963     xorl(tmp2, tmp2);
6964     movl(tmp3, in_out2);
6965     addl(tmp3, size);
6966 
6967     bind(L_processPartition);
6968       crc32(in_out3, Address(in_out2, 0), 4);
6969       crc32(tmp1, Address(in_out2, size), 4);
6970       crc32(tmp2, Address(in_out2, size*2), 4);
6971       crc32(in_out3, Address(in_out2, 0+4), 4);
6972       crc32(tmp1, Address(in_out2, size+4), 4);
6973       crc32(tmp2, Address(in_out2, size*2+4), 4);
6974       addl(in_out2, 8);
6975       cmpl(in_out2, tmp3);
6976       jcc(Assembler::less, L_processPartition);
6977 
6978         push(tmp3);
6979         push(in_out1);
6980         push(in_out2);
6981         tmp4 = tmp3;
6982         tmp5 = in_out1;
6983         n_tmp6 = in_out2;
6984 
6985       crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
6986             w_xtmp1, w_xtmp2, w_xtmp3,
6987             tmp4, tmp5,
6988             n_tmp6);
6989 
6990         pop(in_out2);
6991         pop(in_out1);
6992         pop(tmp3);
6993 
6994     addl(in_out2, 2 * size);
6995     subl(in_out1, 3 * size);
6996     jmp(L_processPartitions);
6997 
6998   bind(L_exit);
6999 }
7000 #endif //LP64
7001 
7002 #ifdef _LP64
7003 // Algorithm 2: Pipelined usage of the CRC32 instruction.
7004 // Input: A buffer I of L bytes.
7005 // Output: the CRC32C value of the buffer.
7006 // Notations:
7007 // Write L = 24N + r, with N = floor (L/24).
7008 // r = L mod 24 (0 &lt;= r &lt; 24).
7009 // Consider I as the concatenation of A|B|C|R, where A, B, C, each,
7010 // N quadwords, and R consists of r bytes.
7011 // A[j] = I [8j+7:8j], j= 0, 1, ..., N-1
7012 // B[j] = I [N + 8j+7:N + 8j], j= 0, 1, ..., N-1
7013 // C[j] = I [2N + 8j+7:2N + 8j], j= 0, 1, ..., N-1
7014 // if r &gt; 0 R[j] = I [3N +j], j= 0, 1, ...,r-1
7015 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7016                                           Register tmp1, Register tmp2, Register tmp3,
7017                                           Register tmp4, Register tmp5, Register tmp6,
7018                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7019                                           bool is_pclmulqdq_supported) {
7020   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7021   Label L_wordByWord;
7022   Label L_byteByByteProlog;
7023   Label L_byteByByte;
7024   Label L_exit;
7025 
7026   if (is_pclmulqdq_supported ) {
7027     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7028     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);
7029 
7030     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7031     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7032 
7033     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7034     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7035     assert((CRC32C_NUM_PRECOMPUTED_CONSTANTS - 1 ) == 5, &quot;Checking whether you declared all of the constants based on the number of \&quot;chunks\&quot;&quot;);
7036   } else {
7037     const_or_pre_comp_const_index[0] = 1;
7038     const_or_pre_comp_const_index[1] = 0;
7039 
7040     const_or_pre_comp_const_index[2] = 3;
7041     const_or_pre_comp_const_index[3] = 2;
7042 
7043     const_or_pre_comp_const_index[4] = 5;
7044     const_or_pre_comp_const_index[5] = 4;
7045    }
7046   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7047                     in2, in1, in_out,
7048                     tmp1, tmp2, tmp3,
7049                     w_xtmp1, w_xtmp2, w_xtmp3,
7050                     tmp4, tmp5,
7051                     tmp6);
7052   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7053                     in2, in1, in_out,
7054                     tmp1, tmp2, tmp3,
7055                     w_xtmp1, w_xtmp2, w_xtmp3,
7056                     tmp4, tmp5,
7057                     tmp6);
7058   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7059                     in2, in1, in_out,
7060                     tmp1, tmp2, tmp3,
7061                     w_xtmp1, w_xtmp2, w_xtmp3,
7062                     tmp4, tmp5,
7063                     tmp6);
7064   movl(tmp1, in2);
7065   andl(tmp1, 0x00000007);
7066   negl(tmp1);
7067   addl(tmp1, in2);
7068   addq(tmp1, in1);
7069 
7070   BIND(L_wordByWord);
7071   cmpq(in1, tmp1);
7072   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7073     crc32(in_out, Address(in1, 0), 4);
7074     addq(in1, 4);
7075     jmp(L_wordByWord);
7076 
7077   BIND(L_byteByByteProlog);
7078   andl(in2, 0x00000007);
7079   movl(tmp2, 1);
7080 
7081   BIND(L_byteByByte);
7082   cmpl(tmp2, in2);
7083   jccb(Assembler::greater, L_exit);
7084     crc32(in_out, Address(in1, 0), 1);
7085     incq(in1);
7086     incl(tmp2);
7087     jmp(L_byteByByte);
7088 
7089   BIND(L_exit);
7090 }
7091 #else
7092 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7093                                           Register tmp1, Register  tmp2, Register tmp3,
7094                                           Register tmp4, Register  tmp5, Register tmp6,
7095                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7096                                           bool is_pclmulqdq_supported) {
7097   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7098   Label L_wordByWord;
7099   Label L_byteByByteProlog;
7100   Label L_byteByByte;
7101   Label L_exit;
7102 
7103   if (is_pclmulqdq_supported) {
7104     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7105     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);
7106 
7107     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7108     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7109 
7110     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7111     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7112   } else {
7113     const_or_pre_comp_const_index[0] = 1;
7114     const_or_pre_comp_const_index[1] = 0;
7115 
7116     const_or_pre_comp_const_index[2] = 3;
7117     const_or_pre_comp_const_index[3] = 2;
7118 
7119     const_or_pre_comp_const_index[4] = 5;
7120     const_or_pre_comp_const_index[5] = 4;
7121   }
7122   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7123                     in2, in1, in_out,
7124                     tmp1, tmp2, tmp3,
7125                     w_xtmp1, w_xtmp2, w_xtmp3,
7126                     tmp4, tmp5,
7127                     tmp6);
7128   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7129                     in2, in1, in_out,
7130                     tmp1, tmp2, tmp3,
7131                     w_xtmp1, w_xtmp2, w_xtmp3,
7132                     tmp4, tmp5,
7133                     tmp6);
7134   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7135                     in2, in1, in_out,
7136                     tmp1, tmp2, tmp3,
7137                     w_xtmp1, w_xtmp2, w_xtmp3,
7138                     tmp4, tmp5,
7139                     tmp6);
7140   movl(tmp1, in2);
7141   andl(tmp1, 0x00000007);
7142   negl(tmp1);
7143   addl(tmp1, in2);
7144   addl(tmp1, in1);
7145 
7146   BIND(L_wordByWord);
7147   cmpl(in1, tmp1);
7148   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7149     crc32(in_out, Address(in1,0), 4);
7150     addl(in1, 4);
7151     jmp(L_wordByWord);
7152 
7153   BIND(L_byteByByteProlog);
7154   andl(in2, 0x00000007);
7155   movl(tmp2, 1);
7156 
7157   BIND(L_byteByByte);
7158   cmpl(tmp2, in2);
7159   jccb(Assembler::greater, L_exit);
7160     movb(tmp1, Address(in1, 0));
7161     crc32(in_out, tmp1, 1);
7162     incl(in1);
7163     incl(tmp2);
7164     jmp(L_byteByByte);
7165 
7166   BIND(L_exit);
7167 }
7168 #endif // LP64
7169 #undef BIND
7170 #undef BLOCK_COMMENT
7171 
7172 // Compress char[] array to byte[].
7173 //   ..\jdk\src\java.base\share\classes\java\lang\StringUTF16.java
7174 //   @HotSpotIntrinsicCandidate
7175 //   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
7176 //     for (int i = 0; i &lt; len; i++) {
7177 //       int c = src[srcOff++];
7178 //       if (c &gt;&gt;&gt; 8 != 0) {
7179 //         return 0;
7180 //       }
7181 //       dst[dstOff++] = (byte)c;
7182 //     }
7183 //     return len;
7184 //   }
7185 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
7186   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
7187   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
7188   Register tmp5, Register result) {
7189   Label copy_chars_loop, return_length, return_zero, done;
7190 
7191   // rsi: src
7192   // rdi: dst
7193   // rdx: len
7194   // rcx: tmp5
7195   // rax: result
7196 
7197   // rsi holds start addr of source char[] to be compressed
7198   // rdi holds start addr of destination byte[]
7199   // rdx holds length
7200 
7201   assert(len != result, &quot;&quot;);
7202 
7203   // save length for return
7204   push(len);
7205 
7206   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
7207     VM_Version::supports_avx512vlbw() &amp;&amp;
7208     VM_Version::supports_bmi2()) {
7209 
7210     Label copy_32_loop, copy_loop_tail, below_threshold;
7211 
7212     // alignment
7213     Label post_alignment;
7214 
7215     // if length of the string is less than 16, handle it in an old fashioned way
7216     testl(len, -32);
7217     jcc(Assembler::zero, below_threshold);
7218 
7219     // First check whether a character is compressable ( &lt;= 0xFF).
7220     // Create mask to test for Unicode chars inside zmm vector
7221     movl(result, 0x00FF);
7222     evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);
7223 
7224     testl(len, -64);
7225     jcc(Assembler::zero, post_alignment);
7226 
7227     movl(tmp5, dst);
7228     andl(tmp5, (32 - 1));
7229     negl(tmp5);
7230     andl(tmp5, (32 - 1));
7231 
7232     // bail out when there is nothing to be done
7233     testl(tmp5, 0xFFFFFFFF);
7234     jcc(Assembler::zero, post_alignment);
7235 
7236     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7237     movl(result, 0xFFFFFFFF);
7238     shlxl(result, result, tmp5);
7239     notl(result);
7240     kmovdl(k3, result);
7241 
7242     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7243     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7244     ktestd(k2, k3);
7245     jcc(Assembler::carryClear, return_zero);
7246 
7247     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7248 
7249     addptr(src, tmp5);
7250     addptr(src, tmp5);
7251     addptr(dst, tmp5);
7252     subl(len, tmp5);
7253 
7254     bind(post_alignment);
7255     // end of alignment
7256 
7257     movl(tmp5, len);
7258     andl(tmp5, (32 - 1));    // tail count (in chars)
7259     andl(len, ~(32 - 1));    // vector count (in chars)
7260     jcc(Assembler::zero, copy_loop_tail);
7261 
7262     lea(src, Address(src, len, Address::times_2));
7263     lea(dst, Address(dst, len, Address::times_1));
7264     negptr(len);
7265 
7266     bind(copy_32_loop);
7267     evmovdquw(tmp1Reg, Address(src, len, Address::times_2), Assembler::AVX_512bit);
7268     evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7269     kortestdl(k2, k2);
7270     jcc(Assembler::carryClear, return_zero);
7271 
7272     // All elements in current processed chunk are valid candidates for
7273     // compression. Write a truncated byte elements to the memory.
7274     evpmovwb(Address(dst, len, Address::times_1), tmp1Reg, Assembler::AVX_512bit);
7275     addptr(len, 32);
7276     jcc(Assembler::notZero, copy_32_loop);
7277 
7278     bind(copy_loop_tail);
7279     // bail out when there is nothing to be done
7280     testl(tmp5, 0xFFFFFFFF);
7281     jcc(Assembler::zero, return_length);
7282 
7283     movl(len, tmp5);
7284 
7285     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7286     movl(result, 0xFFFFFFFF);
7287     shlxl(result, result, len);
7288     notl(result);
7289 
7290     kmovdl(k3, result);
7291 
7292     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7293     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7294     ktestd(k2, k3);
7295     jcc(Assembler::carryClear, return_zero);
7296 
7297     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7298     jmp(return_length);
7299 
7300     bind(below_threshold);
7301   }
7302 
7303   if (UseSSE42Intrinsics) {
7304     Label copy_32_loop, copy_16, copy_tail;
7305 
7306     movl(result, len);
7307 
7308     movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vectors
7309 
7310     // vectored compression
7311     andl(len, 0xfffffff0);    // vector count (in chars)
7312     andl(result, 0x0000000f);    // tail count (in chars)
7313     testl(len, len);
7314     jcc(Assembler::zero, copy_16);
7315 
7316     // compress 16 chars per iter
7317     movdl(tmp1Reg, tmp5);
7318     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
7319     pxor(tmp4Reg, tmp4Reg);
7320 
7321     lea(src, Address(src, len, Address::times_2));
7322     lea(dst, Address(dst, len, Address::times_1));
7323     negptr(len);
7324 
7325     bind(copy_32_loop);
7326     movdqu(tmp2Reg, Address(src, len, Address::times_2));     // load 1st 8 characters
7327     por(tmp4Reg, tmp2Reg);
7328     movdqu(tmp3Reg, Address(src, len, Address::times_2, 16)); // load next 8 characters
7329     por(tmp4Reg, tmp3Reg);
7330     ptest(tmp4Reg, tmp1Reg);       // check for Unicode chars in next vector
7331     jcc(Assembler::notZero, return_zero);
7332     packuswb(tmp2Reg, tmp3Reg);    // only ASCII chars; compress each to 1 byte
7333     movdqu(Address(dst, len, Address::times_1), tmp2Reg);
7334     addptr(len, 16);
7335     jcc(Assembler::notZero, copy_32_loop);
7336 
7337     // compress next vector of 8 chars (if any)
7338     bind(copy_16);
7339     movl(len, result);
7340     andl(len, 0xfffffff8);    // vector count (in chars)
7341     andl(result, 0x00000007);    // tail count (in chars)
7342     testl(len, len);
7343     jccb(Assembler::zero, copy_tail);
7344 
7345     movdl(tmp1Reg, tmp5);
7346     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
7347     pxor(tmp3Reg, tmp3Reg);
7348 
7349     movdqu(tmp2Reg, Address(src, 0));
7350     ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in vector
7351     jccb(Assembler::notZero, return_zero);
7352     packuswb(tmp2Reg, tmp3Reg);    // only LATIN1 chars; compress each to 1 byte
7353     movq(Address(dst, 0), tmp2Reg);
7354     addptr(src, 16);
7355     addptr(dst, 8);
7356 
7357     bind(copy_tail);
7358     movl(len, result);
7359   }
7360   // compress 1 char per iter
7361   testl(len, len);
7362   jccb(Assembler::zero, return_length);
7363   lea(src, Address(src, len, Address::times_2));
7364   lea(dst, Address(dst, len, Address::times_1));
7365   negptr(len);
7366 
7367   bind(copy_chars_loop);
7368   load_unsigned_short(result, Address(src, len, Address::times_2));
7369   testl(result, 0xff00);      // check if Unicode char
7370   jccb(Assembler::notZero, return_zero);
7371   movb(Address(dst, len, Address::times_1), result);  // ASCII char; compress to 1 byte
7372   increment(len);
7373   jcc(Assembler::notZero, copy_chars_loop);
7374 
7375   // if compression succeeded, return length
7376   bind(return_length);
7377   pop(result);
7378   jmpb(done);
7379 
7380   // if compression failed, return 0
7381   bind(return_zero);
7382   xorl(result, result);
7383   addptr(rsp, wordSize);
7384 
7385   bind(done);
7386 }
7387 
7388 // Inflate byte[] array to char[].
7389 //   ..\jdk\src\java.base\share\classes\java\lang\StringLatin1.java
7390 //   @HotSpotIntrinsicCandidate
7391 //   private static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
7392 //     for (int i = 0; i &lt; len; i++) {
7393 //       dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
7394 //     }
7395 //   }
7396 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
7397   XMMRegister tmp1, Register tmp2) {
7398   Label copy_chars_loop, done, below_threshold, avx3_threshold;
7399   // rsi: src
7400   // rdi: dst
7401   // rdx: len
7402   // rcx: tmp2
7403 
7404   // rsi holds start addr of source byte[] to be inflated
7405   // rdi holds start addr of destination char[]
7406   // rdx holds length
7407   assert_different_registers(src, dst, len, tmp2);
7408   movl(tmp2, len);
7409   if ((UseAVX &gt; 2) &amp;&amp; // AVX512
7410     VM_Version::supports_avx512vlbw() &amp;&amp;
7411     VM_Version::supports_bmi2()) {
7412 
7413     Label copy_32_loop, copy_tail;
7414     Register tmp3_aliased = len;
7415 
7416     // if length of the string is less than 16, handle it in an old fashioned way
7417     testl(len, -16);
7418     jcc(Assembler::zero, below_threshold);
7419 
7420     testl(len, -1 * AVX3Threshold);
7421     jcc(Assembler::zero, avx3_threshold);
7422 
7423     // In order to use only one arithmetic operation for the main loop we use
7424     // this pre-calculation
7425     andl(tmp2, (32 - 1)); // tail count (in chars), 32 element wide loop
7426     andl(len, -32);     // vector count
7427     jccb(Assembler::zero, copy_tail);
7428 
7429     lea(src, Address(src, len, Address::times_1));
7430     lea(dst, Address(dst, len, Address::times_2));
7431     negptr(len);
7432 
7433 
7434     // inflate 32 chars per iter
7435     bind(copy_32_loop);
7436     vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_512bit);
7437     evmovdquw(Address(dst, len, Address::times_2), tmp1, Assembler::AVX_512bit);
7438     addptr(len, 32);
7439     jcc(Assembler::notZero, copy_32_loop);
7440 
7441     bind(copy_tail);
7442     // bail out when there is nothing to be done
7443     testl(tmp2, -1); // we don&#39;t destroy the contents of tmp2 here
7444     jcc(Assembler::zero, done);
7445 
7446     // ~(~0 &lt;&lt; length), where length is the # of remaining elements to process
7447     movl(tmp3_aliased, -1);
7448     shlxl(tmp3_aliased, tmp3_aliased, tmp2);
7449     notl(tmp3_aliased);
7450     kmovdl(k2, tmp3_aliased);
7451     evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);
7452     evmovdquw(Address(dst, 0), k2, tmp1, Assembler::AVX_512bit);
7453 
7454     jmp(done);
7455     bind(avx3_threshold);
7456   }
7457   if (UseSSE42Intrinsics) {
7458     Label copy_16_loop, copy_8_loop, copy_bytes, copy_new_tail, copy_tail;
7459 
7460     if (UseAVX &gt; 1) {
7461       andl(tmp2, (16 - 1));
7462       andl(len, -16);
7463       jccb(Assembler::zero, copy_new_tail);
7464     } else {
7465       andl(tmp2, 0x00000007);   // tail count (in chars)
7466       andl(len, 0xfffffff8);    // vector count (in chars)
7467       jccb(Assembler::zero, copy_tail);
7468     }
7469 
7470     // vectored inflation
7471     lea(src, Address(src, len, Address::times_1));
7472     lea(dst, Address(dst, len, Address::times_2));
7473     negptr(len);
7474 
7475     if (UseAVX &gt; 1) {
7476       bind(copy_16_loop);
7477       vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_256bit);
7478       vmovdqu(Address(dst, len, Address::times_2), tmp1);
7479       addptr(len, 16);
7480       jcc(Assembler::notZero, copy_16_loop);
7481 
7482       bind(below_threshold);
7483       bind(copy_new_tail);
7484       movl(len, tmp2);
7485       andl(tmp2, 0x00000007);
7486       andl(len, 0xFFFFFFF8);
7487       jccb(Assembler::zero, copy_tail);
7488 
7489       pmovzxbw(tmp1, Address(src, 0));
7490       movdqu(Address(dst, 0), tmp1);
7491       addptr(src, 8);
7492       addptr(dst, 2 * 8);
7493 
7494       jmp(copy_tail, true);
7495     }
7496 
7497     // inflate 8 chars per iter
7498     bind(copy_8_loop);
7499     pmovzxbw(tmp1, Address(src, len, Address::times_1));  // unpack to 8 words
7500     movdqu(Address(dst, len, Address::times_2), tmp1);
7501     addptr(len, 8);
7502     jcc(Assembler::notZero, copy_8_loop);
7503 
7504     bind(copy_tail);
7505     movl(len, tmp2);
7506 
7507     cmpl(len, 4);
7508     jccb(Assembler::less, copy_bytes);
7509 
7510     movdl(tmp1, Address(src, 0));  // load 4 byte chars
7511     pmovzxbw(tmp1, tmp1);
7512     movq(Address(dst, 0), tmp1);
7513     subptr(len, 4);
7514     addptr(src, 4);
7515     addptr(dst, 8);
7516 
7517     bind(copy_bytes);
7518   } else {
7519     bind(below_threshold);
7520   }
7521 
7522   testl(len, len);
7523   jccb(Assembler::zero, done);
7524   lea(src, Address(src, len, Address::times_1));
7525   lea(dst, Address(dst, len, Address::times_2));
7526   negptr(len);
7527 
7528   // inflate 1 char per iter
7529   bind(copy_chars_loop);
7530   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
7531   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
7532   increment(len);
7533   jcc(Assembler::notZero, copy_chars_loop);
7534 
7535   bind(done);
7536 }
7537 
7538 #ifdef _LP64
7539 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
7540   Label done;
7541   cvttss2sil(dst, src);
7542   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7543   cmpl(dst, 0x80000000); // float_sign_flip
7544   jccb(Assembler::notEqual, done);
7545   subptr(rsp, 8);
7546   movflt(Address(rsp, 0), src);
7547   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
7548   pop(dst);
7549   bind(done);
7550 }
7551 
7552 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
7553   Label done;
7554   cvttsd2sil(dst, src);
7555   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7556   cmpl(dst, 0x80000000); // float_sign_flip
7557   jccb(Assembler::notEqual, done);
7558   subptr(rsp, 8);
7559   movdbl(Address(rsp, 0), src);
7560   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
7561   pop(dst);
7562   bind(done);
7563 }
7564 
7565 void MacroAssembler::convert_f2l(Register dst, XMMRegister src) {
7566   Label done;
7567   cvttss2siq(dst, src);
7568   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
7569   jccb(Assembler::notEqual, done);
7570   subptr(rsp, 8);
7571   movflt(Address(rsp, 0), src);
7572   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
7573   pop(dst);
7574   bind(done);
7575 }
7576 
7577 void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {
7578   Label done;
7579   cvttsd2siq(dst, src);
7580   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
7581   jccb(Assembler::notEqual, done);
7582   subptr(rsp, 8);
7583   movdbl(Address(rsp, 0), src);
7584   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
7585   pop(dst);
7586   bind(done);
7587 }
7588 
7589 void MacroAssembler::cache_wb(Address line)
7590 {
7591   // 64 bit cpus always support clflush
7592   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
7593   bool optimized = VM_Version::supports_clflushopt();
7594   bool no_evict = VM_Version::supports_clwb();
7595 
7596   // prefer clwb (writeback without evict) otherwise
7597   // prefer clflushopt (potentially parallel writeback with evict)
7598   // otherwise fallback on clflush (serial writeback with evict)
7599 
7600   if (optimized) {
7601     if (no_evict) {
7602       clwb(line);
7603     } else {
7604       clflushopt(line);
7605     }
7606   } else {
7607     // no need for fence when using CLFLUSH
7608     clflush(line);
7609   }
7610 }
7611 
7612 void MacroAssembler::cache_wbsync(bool is_pre)
7613 {
7614   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
7615   bool optimized = VM_Version::supports_clflushopt();
7616   bool no_evict = VM_Version::supports_clwb();
7617 
7618   // pick the correct implementation
7619 
7620   if (!is_pre &amp;&amp; (optimized || no_evict)) {
7621     // need an sfence for post flush when using clflushopt or clwb
7622     // otherwise no no need for any synchroniaztion
7623 
7624     sfence();
7625   }
7626 }
7627 #endif // _LP64
7628 
7629 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
7630   switch (cond) {
7631     // Note some conditions are synonyms for others
7632     case Assembler::zero:         return Assembler::notZero;
7633     case Assembler::notZero:      return Assembler::zero;
7634     case Assembler::less:         return Assembler::greaterEqual;
7635     case Assembler::lessEqual:    return Assembler::greater;
7636     case Assembler::greater:      return Assembler::lessEqual;
7637     case Assembler::greaterEqual: return Assembler::less;
7638     case Assembler::below:        return Assembler::aboveEqual;
7639     case Assembler::belowEqual:   return Assembler::above;
7640     case Assembler::above:        return Assembler::belowEqual;
7641     case Assembler::aboveEqual:   return Assembler::below;
7642     case Assembler::overflow:     return Assembler::noOverflow;
7643     case Assembler::noOverflow:   return Assembler::overflow;
7644     case Assembler::negative:     return Assembler::positive;
7645     case Assembler::positive:     return Assembler::negative;
7646     case Assembler::parity:       return Assembler::noParity;
7647     case Assembler::noParity:     return Assembler::parity;
7648   }
7649   ShouldNotReachHere(); return Assembler::overflow;
7650 }
7651 
7652 SkipIfEqual::SkipIfEqual(
7653     MacroAssembler* masm, const bool* flag_addr, bool value) {
7654   _masm = masm;
7655   _masm-&gt;cmp8(ExternalAddress((address)flag_addr), value);
7656   _masm-&gt;jcc(Assembler::equal, _label);
7657 }
7658 
7659 SkipIfEqual::~SkipIfEqual() {
7660   _masm-&gt;bind(_label);
7661 }
7662 
7663 // 32-bit Windows has its own fast-path implementation
7664 // of get_thread
7665 #if !defined(WIN32) || defined(_LP64)
7666 
7667 // This is simply a call to Thread::current()
7668 void MacroAssembler::get_thread(Register thread) {
7669   if (thread != rax) {
7670     push(rax);
7671   }
7672   LP64_ONLY(push(rdi);)
7673   LP64_ONLY(push(rsi);)
7674   push(rdx);
7675   push(rcx);
7676 #ifdef _LP64
7677   push(r8);
7678   push(r9);
7679   push(r10);
7680   push(r11);
7681 #endif
7682 
7683   MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, Thread::current), 0);
7684 
7685 #ifdef _LP64
7686   pop(r11);
7687   pop(r10);
7688   pop(r9);
7689   pop(r8);
7690 #endif
7691   pop(rcx);
7692   pop(rdx);
7693   LP64_ONLY(pop(rsi);)
7694   LP64_ONLY(pop(rdi);)
7695   if (thread != rax) {
7696     mov(thread, rax);
7697     pop(rax);
7698   }
7699 }
7700 
7701 #endif // !WIN32 || _LP64
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
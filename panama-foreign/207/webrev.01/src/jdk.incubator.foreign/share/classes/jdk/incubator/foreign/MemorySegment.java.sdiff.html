<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/foreign/StdLibTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
594             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
595         }
596 
597         if (alignmentBytes &lt; 0 ||
598                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
599             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
600         }
601 
602         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
603     }
604 
605     /**
606      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
607      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
608      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
609      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
610      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
611      * (see {@link #ALL_ACCESS}).
612      * &lt;p&gt;
613      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
<span class="line-modified">614      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on</span>
615      * restricted methods, and use safe and supported functionalities, where possible.
616      *
617      * @param addr the desired base address
618      * @param bytesSize the desired size.
619      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
620      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
621      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
622      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
623      *                   the returned segment depends on memory which could be released if a certain object
624      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
625      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
626      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
627      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
628      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
629      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
630      * @throws NullPointerException if {@code addr == null}.
631      */
632     static MemorySegment ofNativeRestricted(MemoryAddress addr, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {
633         Objects.requireNonNull(addr);
634         if (bytesSize &lt;= 0) {
</pre>
</td>
<td>
<hr />
<pre>
594             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
595         }
596 
597         if (alignmentBytes &lt; 0 ||
598                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
599             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
600         }
601 
602         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
603     }
604 
605     /**
606      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
607      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
608      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
609      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
610      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
611      * (see {@link #ALL_ACCESS}).
612      * &lt;p&gt;
613      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
<span class="line-modified">614      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on</span>
615      * restricted methods, and use safe and supported functionalities, where possible.
616      *
617      * @param addr the desired base address
618      * @param bytesSize the desired size.
619      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
620      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
621      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
622      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
623      *                   the returned segment depends on memory which could be released if a certain object
624      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
625      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
626      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
627      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
628      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
629      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
630      * @throws NullPointerException if {@code addr == null}.
631      */
632     static MemorySegment ofNativeRestricted(MemoryAddress addr, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {
633         Objects.requireNonNull(addr);
634         if (bytesSize &lt;= 0) {
</pre>
</td>
</tr>
</table>
<center><a href="CSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/foreign/StdLibTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
@@ -154,10 +154,11 @@
             List<JavaFileObject> files = new ArrayList<>();
             files.add(builder.build());
             files.addAll(constantHelper.getClasses());
             files.add(fileFromString(pkgName,"RuntimeHelper", getRuntimeHelperSource()));
             files.add(getCstringFile(pkgName));
+            files.add(getCpointerFile(pkgName));
             files.addAll(getPrimitiveTypeFiles(pkgName));
             return files.toArray(new JavaFileObject[0]);
         } catch (IOException ex) {
             throw new UncheckedIOException(ex);
         } catch (URISyntaxException ex2) {
@@ -179,16 +180,24 @@
             ex.printStackTrace();
         }
     }
 
     private JavaFileObject getCstringFile(String pkgName) throws IOException, URISyntaxException {
-        var cstringFile = OutputFactory.class.getResource("resources/Cstring.java.template");
+        return getTemplateFile(pkgName, "Cstring", "resources/Cstring.java.template");
+    }
+
+    private JavaFileObject getCpointerFile(String pkgName) throws IOException, URISyntaxException {
+        return getTemplateFile(pkgName, "Cpointer", "resources/Cpointer.java.template");
+    }
+
+    private JavaFileObject getTemplateFile(String pkgName, String className, String path) throws IOException, URISyntaxException {
+        var cstringFile = OutputFactory.class.getResource(path);
         var lines = Files.readAllLines(Paths.get(cstringFile.toURI()));
         String pkgPrefix = pkgName.isEmpty()? "" : "package " + pkgName + ";\n";
         String contents =  pkgPrefix +
                 lines.stream().collect(Collectors.joining("\n"));
-        return fileFromString(pkgName,"Cstring", contents);
+        return fileFromString(pkgName,className, contents);
     }
 
     private List<JavaFileObject> getPrimitiveTypeFiles(String pkgName) throws IOException, URISyntaxException {
         var abi = SharedUtils.getSystemLinker();
         var cXJavaFile = OutputFactory.class.getResource("resources/C-X.java.template");
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/C-X.java.template b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/C-X.java.template
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/C-X.java.template
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/C-X.java.template
@@ -21,10 +21,15 @@
     public static final MemoryLayout LAYOUT = ${LAYOUT};
     public static final Class<?> CARRIER = ${CARRIER}.class;
     private static final VarHandle handle = LAYOUT.varHandle(CARRIER);
     private static final VarHandle arrayHandle = arrayHandle(LAYOUT, CARRIER);
 
+    public static MemoryAddress asArray(MemoryAddress addr, int numElements) {
+        return MemorySegment.ofNativeRestricted(addr, numElements * LAYOUT.byteSize(),
+               Thread.currentThread(), null, null).baseAddress();
+    }
+
     public static ${CARRIER} get(MemoryAddress addr) {
         return (${CARRIER}) handle.get(addr);
     }
 
     public static void set(MemoryAddress addr, ${CARRIER} value) {
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/Cpointer.java.template b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/Cpointer.java.template
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/Cpointer.java.template
@@ -0,0 +1,68 @@
+// Generated by jextract
+
+import java.lang.invoke.VarHandle;
+import jdk.incubator.foreign.NativeAllocationScope;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import static jdk.incubator.foreign.CSupport.C_POINTER;
+
+public final class Cpointer {
+    private static VarHandle arrayHandle(MemoryLayout elemLayout, Class<?> elemCarrier) {
+        return MemoryLayout.ofSequence(elemLayout)
+            .varHandle(elemCarrier, MemoryLayout.PathElement.sequenceElement());
+    }
+
+    public static final MemoryLayout LAYOUT = C_POINTER;
+    public static final Class<?> CARRIER = long.class;
+    private static final VarHandle handle = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(CARRIER));
+    private static final VarHandle arrayHandle = MemoryHandles.asAddressVarHandle(arrayHandle(LAYOUT, CARRIER));
+
+    public static MemoryAddress asArray(MemoryAddress addr, int numPointers) {
+        return MemorySegment.ofNativeRestricted(addr, numPointers * LAYOUT.byteSize(),
+               Thread.currentThread(), null, null).baseAddress();
+    }
+
+    public static MemoryAddress get(MemoryAddress addr) {
+        return (MemoryAddress) handle.get(addr);
+    }
+
+    public static void set(MemoryAddress addr, MemoryAddress value) {
+        handle.set(addr, value);
+    }
+
+    public static MemoryAddress get(MemoryAddress addr, long index) {
+        return (MemoryAddress) arrayHandle.get(addr, index);
+    }
+
+    public static void set(MemoryAddress addr, long index, MemoryAddress value) {
+        arrayHandle.set(addr, index, value);
+    }
+
+    public static MemorySegment allocate(MemoryAddress value) {
+        var seg = MemorySegment.allocateNative(LAYOUT);
+        handle.set(seg.baseAddress(), value);
+        return seg;
+    }
+
+    public static MemoryAddress allocate(MemoryAddress value, NativeAllocationScope scope) {
+        var addr = scope.allocate(LAYOUT);
+        handle.set(addr, value);
+        return addr;
+    }
+
+    public static MemorySegment allocateArray(int length) {
+        var arrLayout = MemoryLayout.ofSequence(length, LAYOUT);
+        return MemorySegment.allocateNative(arrLayout);
+    }
+
+    public static MemoryAddress allocateArray(int length, NativeAllocationScope scope) {
+        var arrLayout = MemoryLayout.ofSequence(length, LAYOUT);
+        return scope.allocate(arrLayout);
+    }
+
+    public static long sizeof() {
+        return LAYOUT.byteSize();
+    }
+}
diff a/test/jdk/tools/jextract/test8246341/LibTest8246341Test.java b/test/jdk/tools/jextract/test8246341/LibTest8246341Test.java
--- /dev/null
+++ b/test/jdk/tools/jextract/test8246341/LibTest8246341Test.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.util.stream.DoubleStream;
+import java.util.stream.IntStream;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.NativeAllocationScope;
+import org.testng.annotations.Test;
+import test.jextract.test8246341.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static test.jextract.test8246341.test8246341_h.*;
+
+/*
+ * @test
+ * @library ..
+ * @modules jdk.incubator.jextract
+ * @bug 8246341
+ * @summary jextract should generate simple allocation, access API for C primitive types
+ * @run driver JtregJextract -l Test8246341 -t test.jextract.test8246341 -- test8246341.h
+ * @run testng/othervm -Dforeign.restricted=permit LibTest8246341Test
+ */
+public class LibTest8246341Test {
+    @Test
+    public void testPointerArray() {
+        boolean[] callbackCalled = new boolean[1];
+        try (var callback = func$callback.allocate((argc, argv) -> {
+            callbackCalled[0] = true;
+            var addr = Cpointer.asArray(argv, argc);
+            assertEquals(argc, 4);
+            assertEquals(Cstring.toJavaString(Cpointer.get(addr, 0)), "java");
+            assertEquals(Cstring.toJavaString(Cpointer.get(addr, 1)), "python");
+            assertEquals(Cstring.toJavaString(Cpointer.get(addr, 2)), "javascript");
+            assertEquals(Cstring.toJavaString(Cpointer.get(addr, 3)), "c++");
+        })) {
+            func(callback.baseAddress());
+        }
+        assertTrue(callbackCalled[0]);
+    }
+
+    @Test
+    public void testPointerAllocate() {
+        try (var scope = NativeAllocationScope.boundedScope(Cpointer.sizeof())) {
+            var addr = Cpointer.allocate(MemoryAddress.NULL, scope);
+            fillin(addr);
+            assertEquals(Cstring.toJavaString(Cpointer.get(addr)), "hello world");
+        }
+
+        try (var seg = Cpointer.allocate(MemoryAddress.NULL)) {
+            var addr = seg.baseAddress();
+            fillin(addr);
+            assertEquals(Cstring.toJavaString(Cpointer.get(addr)), "hello world");
+        }
+    }
+}
diff a/test/jdk/tools/jextract/test8246341/libTest8246341.c b/test/jdk/tools/jextract/test8246341/libTest8246341.c
--- /dev/null
+++ b/test/jdk/tools/jextract/test8246341/libTest8246341.c
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "test8246341.h"
+
+#define NUM_STRINGS 4
+
+static char* table[NUM_STRINGS] = { "java", "python", "javascript", "c++" };
+static char* msg = "hello world";
+
+EXPORT void func(void (*callback)(int argc, char** argv)) {
+    callback(NUM_STRINGS, table);
+}
+
+EXPORT void fillin(char** pmsg) {
+    *pmsg = msg;
+}
diff a/test/jdk/tools/jextract/test8246341/test8246341.h b/test/jdk/tools/jextract/test8246341/test8246341.h
--- /dev/null
+++ b/test/jdk/tools/jextract/test8246341/test8246341.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+#ifdef _WIN64
+#define EXPORT __declspec(dllexport)
+#else
+#define EXPORT
+#endif
+
+EXPORT void func(void (*callback)(int argc, char** argv));
+EXPORT void fillin(char** pmsg);
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus

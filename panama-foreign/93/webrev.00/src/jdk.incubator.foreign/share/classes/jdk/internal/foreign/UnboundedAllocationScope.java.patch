diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java
@@ -23,20 +23,20 @@
  * questions.
  */
 
 package jdk.internal.foreign;
 
-import jdk.incubator.foreign.AllocationScope;
+import jdk.incubator.foreign.NativeAllocationScope;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.OptionalLong;
 import java.util.function.LongFunction;
 
-public class UnboundedAllocationScope extends AllocationScope {
+public class UnboundedAllocationScope extends NativeAllocationScope {
 
     private static final long BLOCK_SIZE = 4 * 1024;
 
     private final LongFunction<MemorySegment> segmentFactory;
     private final List<MemorySegment> usedSegments = new ArrayList<>();
@@ -59,10 +59,16 @@
         this.segment = segmentFactory.apply(BLOCK_SIZE);
     }
 
     @Override
     public MemoryAddress allocate(long bytesSize, long bytesAlignment) {
+        if (bytesSize > BLOCK_SIZE) {
+            MemorySegment segment = MemorySegment.allocateNative(bytesSize, bytesAlignment);
+            usedSegments.add(segment);
+            return segment.withAccessModes(MemorySegment.READ | MemorySegment.WRITE | MemorySegment.ACQUIRE)
+                    .baseAddress();
+        }
         for (int i = 0; i < 2; i++) {
             long min = ((MemoryAddressImpl) segment.baseAddress()).unsafeGetOffset();
             long start = Utils.alignUp(min + sp, bytesAlignment) - min;
             try {
                 MemorySegment slice = segment.asSlice(start, bytesSize)

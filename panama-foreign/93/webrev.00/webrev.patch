diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.incubator.foreign;
-
-import jdk.internal.foreign.BoundedAllocationScope;
-import jdk.internal.foreign.UnboundedAllocationScope;
-
-import java.lang.invoke.VarHandle;
-import java.util.OptionalLong;
-
-/**
- * This class provides a scope of given size, within which several allocations can be performed. An allocation scope can be backed
- * either by heap, or off-heap memory. Allocation scopes can be either <em>bounded</em> or <em>unbounded</em>, depending on whether the size
- * of the allocation scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,
- * using a <em>bounded</em> allocation scope will typically provide better performances than independently allocating the memory
- * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an <em>unbounded</em> allocation scope.
- * For this reason, using a bounded allocation scope is recommended in cases where programs might need to emulate native stack allocation.
- */
-public abstract class AllocationScope implements AutoCloseable {
-
-    /**
-     * If this allocation scope is bounded, returns the size, in bytes, of this allocation scope.
-     * @return the size, in bytes, of this allocation scope (if available).
-     */
-    public abstract OptionalLong byteSize();
-
-    /**
-     * Returns the number of allocated bytes in this allocation scope.
-     * @return the number of allocated bytes in this allocation scope.
-     */
-    public abstract long allocatedBytes();
-
-    /**
-     * Allocate a block of memory in this allocation scope with given layout and initialize it with given byte value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
-     * @param layout the layout of the block of memory to be allocated.
-     * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
-     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
-     * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.
-     */
-    public MemoryAddress allocate(MemoryLayout layout, byte value) {
-        VarHandle handle = layout.varHandle(byte.class);
-        MemoryAddress addr = allocate(layout);
-        handle.set(addr, value);
-        return addr;
-    }
-
-    /**
-     * Allocate a block of memory in this allocation scope with given layout and initialize it with given short value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
-     * @param layout the layout of the block of memory to be allocated.
-     * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
-     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
-     * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.
-     */
-    public MemoryAddress allocate(MemoryLayout layout, short value) {
-        VarHandle handle = layout.varHandle(short.class);
-        MemoryAddress addr = allocate(layout);
-        handle.set(addr, value);
-        return addr;
-    }
-
-    /**
-     * Allocate a block of memory in this allocation scope with given layout and initialize it with given int value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
-     * @param layout the layout of the block of memory to be allocated.
-     * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
-     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
-     * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.
-     */
-    public MemoryAddress allocate(MemoryLayout layout, int value) {
-        VarHandle handle = layout.varHandle(int.class);
-        MemoryAddress addr = allocate(layout);
-        handle.set(addr, value);
-        return addr;
-    }
-
-    /**
-     * Allocate a block of memory in this allocation scope with given layout and initialize it with given float value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
-     * @param layout the layout of the block of memory to be allocated.
-     * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
-     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
-     * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.
-     */
-    public MemoryAddress allocate(MemoryLayout layout, float value) {
-        VarHandle handle = layout.varHandle(float.class);
-        MemoryAddress addr = allocate(layout);
-        handle.set(addr, value);
-        return addr;
-    }
-
-    /**
-     * Allocate a block of memory in this allocation scope with given layout and initialize it with given long value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
-     * @param layout the layout of the block of memory to be allocated.
-     * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
-     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
-     * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.
-     */
-    public MemoryAddress allocate(MemoryLayout layout, long value) {
-        VarHandle handle = layout.varHandle(long.class);
-        MemoryAddress addr = allocate(layout);
-        handle.set(addr, value);
-        return addr;
-    }
-
-    /**
-     * Allocate a block of memory in this allocation scope with given layout and initialize it with given double value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
-     * @param layout the layout of the block of memory to be allocated.
-     * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
-     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
-     * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.
-     */
-    public MemoryAddress allocate(MemoryLayout layout, double value) {
-        VarHandle handle = layout.varHandle(double.class);
-        MemoryAddress addr = allocate(layout);
-        handle.set(addr, value);
-        return addr;
-    }
-
-    /**
-     * Allocate a block of memory in this allocation scope with given layout and initialize it with given address value.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
-     * address must conform to the layout alignment constraints.
-     * @param layout the layout of the block of memory to be allocated.
-     * @param value the value to be set on the newly allocated memory block.
-     * @return an address which points to the newly allocated memory block.
-     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
-     * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of an address value.
-     */
-    public MemoryAddress allocate(MemoryLayout layout, MemoryAddress value) {
-        VarHandle handle = MemoryHandles.asAddressVarHandle(layout.varHandle(carrierForSize(layout.byteSize())));
-        MemoryAddress addr = allocate(layout);
-        handle.set(addr, value);
-        return addr;
-    }
-
-    private static Class<?> carrierForSize(long size) {
-        return switch ((int)size) {
-            case 1 -> byte.class;
-            case 2 -> short.class;
-            case 4 -> int.class;
-            case 8 -> long.class;
-            default -> throw new IllegalArgumentException("Bad layout size: " + size);
-        };
-    }
-
-    /**
-     * Allocate a block of memory in this allocation scope with given layout. The address returned by this method is
-     * associated with a segment which cannot be closed. Moreover, the returned address must conform to the layout alignment constraints.
-     * @param layout the layout of the block of memory to be allocated.
-     * @return an address which points to the newly allocated memory block.
-     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
-     * {@code limit() - size() < layout.byteSize()}.
-     */
-    public MemoryAddress allocate(MemoryLayout layout) {
-        return allocate(layout.byteSize(), layout.byteAlignment());
-    }
-
-    /**
-     * Allocate a block of memory in this allocation scope with given size. The address returned by this method is
-     * associated with a segment which cannot be closed. Moreover, the returned address must be aligned to {@code size}.
-     * @param bytesSize the size (in bytes) of the block of memory to be allocated.
-     * @return an address which points to the newly allocated memory block.
-     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
-     * {@code limit() - size() < bytesSize}.
-     */
-    public MemoryAddress allocate(long bytesSize) {
-        return allocate(bytesSize, bytesSize);
-    }
-
-    /**
-     * Allocate a block of memory in this allocation scope with given size and alignment constraint.
-     * The address returned by this method is associated with a segment which cannot be closed. Moreover,
-     * the returned address must be aligned to {@code alignment}.
-     * @param bytesSize the size (in bytes) of the block of memory to be allocated.
-     * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.
-     * @return an address which points to the newly allocated memory block.
-     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
-     * {@code limit() - size() < bytesSize}.
-     */
-    public abstract MemoryAddress allocate(long bytesSize, long bytesAlignment);
-
-    /**
-     * Close this allocation scope; calling this method will render any address obtained through this allocation scope
-     * unusable and might release any backing memory resources associated with this allocation scope.
-     */
-    @Override
-    public abstract void close();
-
-    /**
-     * Creates a new bounded native allocation scope, backed by off-heap memory.
-     * @param size the size of the allocation scope.
-     * @return a new bounded native allocation scope, with given size (in bytes).
-     */
-    public static AllocationScope boundedNativeScope(long size) {
-        return new BoundedAllocationScope(MemorySegment.allocateNative(size));
-    }
-
-    /**
-     * Creates a new bounded heap allocation scope, backed by heap memory.
-     * @param size the size of the allocation scope.
-     * @return a new bounded heap allocation scope, with given size (in bytes).
-     */
-    public static AllocationScope boundedHeapScope(int size) {
-        return new BoundedAllocationScope(MemorySegment.ofArray(new byte[size]));
-    }
-
-    /**
-     * Creates a new unbounded native allocation scope, backed by off-heap memory.
-     * @return a new unbounded native allocation scope.
-     */
-    public static AllocationScope unboundedNativeScope() {
-        return new UnboundedAllocationScope(MemorySegment::allocateNative);
-    }
-
-    /**
-     * Creates a new unbounded heap allocation scope, backed by heap memory.
-     * @return a new unbounded heap allocation scope.
-     */
-    public static AllocationScope unboundedHeapScope() {
-        return new UnboundedAllocationScope((size) -> MemorySegment.ofArray(new byte[(int) size]));
-    }
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeAllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeAllocationScope.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeAllocationScope.java
@@ -0,0 +1,252 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.incubator.foreign;
+
+import jdk.internal.foreign.BoundedAllocationScope;
+import jdk.internal.foreign.UnboundedAllocationScope;
+
+import java.lang.invoke.VarHandle;
+import java.util.OptionalLong;
+
+/**
+ * This class provides a scope of given size, within which several allocations can be performed. An allocation scope is backed
+ * by off-heap memory. Allocation scopes can be either <em>bounded</em> or <em>unbounded</em>, depending on whether the size
+ * of the allocation scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,
+ * using a <em>bounded</em> allocation scope will typically provide better performances than independently allocating the memory
+ * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an <em>unbounded</em> allocation scope.
+ * For this reason, using a bounded allocation scope is recommended in cases where programs might need to emulate native stack allocation.
+ */
+public abstract class NativeAllocationScope implements AutoCloseable {
+
+    /**
+     * If this allocation scope is bounded, returns the size, in bytes, of this allocation scope.
+     * @return the size, in bytes, of this allocation scope (if available).
+     */
+    public abstract OptionalLong byteSize();
+
+    /**
+     * Returns the number of allocated bytes in this allocation scope.
+     * @return the number of allocated bytes in this allocation scope.
+     */
+    public abstract long allocatedBytes();
+
+    /**
+     * Allocate a block of memory in this allocation scope with given layout and initialize it with given byte value.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param layout the layout of the block of memory to be allocated.
+     * @param value the value to be set on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
+     * {@code limit() - size() < layout.byteSize()}.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.
+     */
+    public MemoryAddress allocate(MemoryLayout layout, byte value) {
+        VarHandle handle = layout.varHandle(byte.class);
+        MemoryAddress addr = allocate(layout);
+        handle.set(addr, value);
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this allocation scope with given layout and initialize it with given short value.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param layout the layout of the block of memory to be allocated.
+     * @param value the value to be set on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
+     * {@code limit() - size() < layout.byteSize()}.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.
+     */
+    public MemoryAddress allocate(MemoryLayout layout, short value) {
+        VarHandle handle = layout.varHandle(short.class);
+        MemoryAddress addr = allocate(layout);
+        handle.set(addr, value);
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this allocation scope with given layout and initialize it with given int value.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param layout the layout of the block of memory to be allocated.
+     * @param value the value to be set on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
+     * {@code limit() - size() < layout.byteSize()}.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.
+     */
+    public MemoryAddress allocate(MemoryLayout layout, int value) {
+        VarHandle handle = layout.varHandle(int.class);
+        MemoryAddress addr = allocate(layout);
+        handle.set(addr, value);
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this allocation scope with given layout and initialize it with given float value.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param layout the layout of the block of memory to be allocated.
+     * @param value the value to be set on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
+     * {@code limit() - size() < layout.byteSize()}.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.
+     */
+    public MemoryAddress allocate(MemoryLayout layout, float value) {
+        VarHandle handle = layout.varHandle(float.class);
+        MemoryAddress addr = allocate(layout);
+        handle.set(addr, value);
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this allocation scope with given layout and initialize it with given long value.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param layout the layout of the block of memory to be allocated.
+     * @param value the value to be set on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
+     * {@code limit() - size() < layout.byteSize()}.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.
+     */
+    public MemoryAddress allocate(MemoryLayout layout, long value) {
+        VarHandle handle = layout.varHandle(long.class);
+        MemoryAddress addr = allocate(layout);
+        handle.set(addr, value);
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this allocation scope with given layout and initialize it with given double value.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param layout the layout of the block of memory to be allocated.
+     * @param value the value to be set on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
+     * {@code limit() - size() < layout.byteSize()}.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.
+     */
+    public MemoryAddress allocate(MemoryLayout layout, double value) {
+        VarHandle handle = layout.varHandle(double.class);
+        MemoryAddress addr = allocate(layout);
+        handle.set(addr, value);
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this allocation scope with given layout and initialize it with given address value.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param layout the layout of the block of memory to be allocated.
+     * @param value the value to be set on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
+     * {@code limit() - size() < layout.byteSize()}.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of an address value.
+     */
+    public MemoryAddress allocate(MemoryLayout layout, MemoryAddress value) {
+        VarHandle handle = MemoryHandles.asAddressVarHandle(layout.varHandle(carrierForSize(layout.byteSize())));
+        MemoryAddress addr = allocate(layout);
+        handle.set(addr, value);
+        return addr;
+    }
+
+    private static Class<?> carrierForSize(long size) {
+        return switch ((int)size) {
+            case 1 -> byte.class;
+            case 2 -> short.class;
+            case 4 -> int.class;
+            case 8 -> long.class;
+            default -> throw new IllegalArgumentException("Bad layout size: " + size);
+        };
+    }
+
+    /**
+     * Allocate a block of memory in this allocation scope with given layout. The address returned by this method is
+     * associated with a segment which cannot be closed. Moreover, the returned address must conform to the layout alignment constraints.
+     * @param layout the layout of the block of memory to be allocated.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
+     * {@code limit() - size() < layout.byteSize()}.
+     */
+    public MemoryAddress allocate(MemoryLayout layout) {
+        return allocate(layout.byteSize(), layout.byteAlignment());
+    }
+
+    /**
+     * Allocate a block of memory in this allocation scope with given size. The address returned by this method is
+     * associated with a segment which cannot be closed. Moreover, the returned address must be aligned to {@code size}.
+     * @param bytesSize the size (in bytes) of the block of memory to be allocated.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
+     * {@code limit() - size() < bytesSize}.
+     */
+    public MemoryAddress allocate(long bytesSize) {
+        return allocate(bytesSize, bytesSize);
+    }
+
+    /**
+     * Allocate a block of memory in this allocation scope with given size and alignment constraint.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover,
+     * the returned address must be aligned to {@code alignment}.
+     * @param bytesSize the size (in bytes) of the block of memory to be allocated.
+     * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
+     * {@code limit() - size() < bytesSize}.
+     */
+    public abstract MemoryAddress allocate(long bytesSize, long bytesAlignment);
+
+    /**
+     * Close this allocation scope; calling this method will render any address obtained through this allocation scope
+     * unusable and might release any backing memory resources associated with this allocation scope.
+     */
+    @Override
+    public abstract void close();
+
+    /**
+     * Creates a new bounded allocation scope, backed by off-heap memory.
+     * @param size the size of the allocation scope.
+     * @return a new bounded allocation scope, with given size (in bytes).
+     */
+    public static NativeAllocationScope boundedScope(long size) {
+        return new BoundedAllocationScope(MemorySegment.allocateNative(size));
+    }
+
+    /**
+     * Creates a new unbounded allocation scope, backed by off-heap memory.
+     * @return a new unbounded allocation scope.
+     */
+    public static NativeAllocationScope unboundedScope() {
+        return new UnboundedAllocationScope(MemorySegment::allocateNative);
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/BoundedAllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/BoundedAllocationScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/BoundedAllocationScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/BoundedAllocationScope.java
@@ -23,17 +23,17 @@
  * questions.
  */
 
 package jdk.internal.foreign;
 
-import jdk.incubator.foreign.AllocationScope;
+import jdk.incubator.foreign.NativeAllocationScope;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
 import java.util.OptionalLong;
 
-public class BoundedAllocationScope extends AllocationScope {
+public class BoundedAllocationScope extends NativeAllocationScope {
     private final MemorySegment segment;
     private long sp = 0L;
 
     @Override
     public OptionalLong byteSize() {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/UnboundedAllocationScope.java
@@ -23,20 +23,20 @@
  * questions.
  */
 
 package jdk.internal.foreign;
 
-import jdk.incubator.foreign.AllocationScope;
+import jdk.incubator.foreign.NativeAllocationScope;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.OptionalLong;
 import java.util.function.LongFunction;
 
-public class UnboundedAllocationScope extends AllocationScope {
+public class UnboundedAllocationScope extends NativeAllocationScope {
 
     private static final long BLOCK_SIZE = 4 * 1024;
 
     private final LongFunction<MemorySegment> segmentFactory;
     private final List<MemorySegment> usedSegments = new ArrayList<>();
@@ -59,10 +59,16 @@
         this.segment = segmentFactory.apply(BLOCK_SIZE);
     }
 
     @Override
     public MemoryAddress allocate(long bytesSize, long bytesAlignment) {
+        if (bytesSize > BLOCK_SIZE) {
+            MemorySegment segment = MemorySegment.allocateNative(bytesSize, bytesAlignment);
+            usedSegments.add(segment);
+            return segment.withAccessModes(MemorySegment.READ | MemorySegment.WRITE | MemorySegment.ACQUIRE)
+                    .baseAddress();
+        }
         for (int i = 0; i < 2; i++) {
             long min = ((MemoryAddressImpl) segment.baseAddress()).unsafeGetOffset();
             long start = Utils.alignUp(min + sp, bytesAlignment) - min;
             try {
                 MemorySegment slice = segment.asSlice(start, bytesSize)
diff a/test/jdk/java/foreign/Cstring.java b/test/jdk/java/foreign/Cstring.java
--- a/test/jdk/java/foreign/Cstring.java
+++ b/test/jdk/java/foreign/Cstring.java
@@ -21,11 +21,11 @@
  * questions.
  */
 
 import java.lang.invoke.VarHandle;
 import java.nio.charset.Charset;
-import jdk.incubator.foreign.AllocationScope;
+import jdk.incubator.foreign.NativeAllocationScope;
 import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import static jdk.incubator.foreign.MemoryLayouts.C_CHAR;
@@ -55,11 +55,11 @@
         MemoryAddress addr = segment.baseAddress();
         copy(addr, bytes);
         return segment;
     }
 
-    private static MemoryAddress toCString(byte[] bytes, AllocationScope scope) {
+    private static MemoryAddress toCString(byte[] bytes, NativeAllocationScope scope) {
         MemoryLayout strLayout = MemoryLayout.ofSequence(bytes.length + 1, C_CHAR);
         MemoryAddress addr = scope.allocate(strLayout);
         copy(addr, bytes);
         return addr;
     }
@@ -78,15 +78,15 @@
 
     public static MemorySegment toCString(String str, Charset charset) {
          return toCString(str.getBytes(charset));
     }
 
-    public static MemoryAddress toCString(String str, AllocationScope scope) {
+    public static MemoryAddress toCString(String str, NativeAllocationScope scope) {
         return toCString(str.getBytes(), scope);
     }
 
-    public static MemoryAddress toCString(String str, Charset charset, AllocationScope scope) {
+    public static MemoryAddress toCString(String str, Charset charset, NativeAllocationScope scope) {
         return toCString(str.getBytes(charset), scope);
     }
 
     public static String toJavaString(MemoryAddress addr) {
         StringBuilder buf = new StringBuilder();
diff a/test/jdk/java/foreign/TestAllocationScope.java b/test/jdk/java/foreign/TestAllocationScope.java
--- a/test/jdk/java/foreign/TestAllocationScope.java
+++ b/test/jdk/java/foreign/TestAllocationScope.java
@@ -25,11 +25,11 @@
 /*
  * @test
  * @run testng TestAllocationScope
  */
 
-import jdk.incubator.foreign.AllocationScope;
+import jdk.incubator.foreign.NativeAllocationScope;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryAddress;
 
@@ -55,11 +55,11 @@
                 layout.withBitAlignment(layout.bitAlignment() * 8)
         };
         for (MemoryLayout alignedLayout : layouts) {
             List<MemoryAddress> addressList = new ArrayList<>();
             int elems = ELEMS / ((int)alignedLayout.byteAlignment() / (int)layout.byteAlignment());
-            try (AllocationScope scope = scopeFactory.make((int)alignedLayout.byteSize() * ELEMS)) {
+            try (NativeAllocationScope scope = scopeFactory.make((int)alignedLayout.byteSize() * ELEMS)) {
                 for (int i = 0 ; i < elems ; i++) {
                     MemoryAddress address = allocationFunction.allocate(scope, alignedLayout, value);
                     assertEquals(address.segment().byteSize(), alignedLayout.byteSize());
                     addressList.add(address);
                     VarHandle handle = handleFactory.apply(alignedLayout);
@@ -90,199 +90,107 @@
 
 
     @DataProvider(name = "allocationScopes")
     static Object[][] allocationScopes() {
         return new Object[][] {
-                { (byte)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_8_BE, byte.class,
-                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                { (byte)42, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_8_BE, byte.class,
+                        (AllocationFunction<Byte>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
-                { (short)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_16_BE, short.class,
-                        (AllocationFunction<Short>)AllocationScope::allocate,
+                { (short)42, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_16_BE, short.class,
+                        (AllocationFunction<Short>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
-                { 42, (ScopeFactory)AllocationScope::boundedHeapScope,
+                { 42, (ScopeFactory) NativeAllocationScope::boundedScope,
                         MemoryLayouts.BITS_32_BE, int.class,
-                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (AllocationFunction<Integer>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
-                { 42f, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_BE, float.class,
-                        (AllocationFunction<Float>)AllocationScope::allocate,
+                { 42f, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_32_BE, float.class,
+                        (AllocationFunction<Float>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
-                { 42L, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, long.class,
-                        (AllocationFunction<Long>)AllocationScope::allocate,
+                { 42L, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_64_BE, long.class,
+                        (AllocationFunction<Long>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
-                { 42d, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, double.class,
-                        (AllocationFunction<Double>)AllocationScope::allocate,
+                { 42d, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_64_BE, double.class,
+                        (AllocationFunction<Double>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_BE, MemoryAddress.class,
-                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                { MemoryAddress.ofLong(42), (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_64_BE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
 
-                { (byte)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_8_BE, byte.class,
-                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                { (byte)42, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_8_LE, byte.class,
+                        (AllocationFunction<Byte>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
-                { (short)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_16_BE, short.class,
-                        (AllocationFunction<Short>)AllocationScope::allocate,
+                { (short)42, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_16_LE, short.class,
+                        (AllocationFunction<Short>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
-                { 42, (ScopeFactory)AllocationScope::boundedNativeScope,
-                        MemoryLayouts.BITS_32_BE, int.class,
-                        (AllocationFunction<Integer>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
-                { 42f, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_BE, float.class,
-                        (AllocationFunction<Float>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
-                { 42L, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, long.class,
-                        (AllocationFunction<Long>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
-                { 42d, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, double.class,
-                        (AllocationFunction<Double>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_BE, MemoryAddress.class,
-                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
-
-                { (byte)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_8_LE, byte.class,
-                        (AllocationFunction<Byte>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
-                { (short)42, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_16_LE, short.class,
-                        (AllocationFunction<Short>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
-                { 42, (ScopeFactory)AllocationScope::boundedHeapScope,
-                        MemoryLayouts.BITS_32_LE, int.class,
-                        (AllocationFunction<Integer>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
-                { 42f, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_32_LE, float.class,
-                        (AllocationFunction<Float>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
-                { 42L, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, long.class,
-                        (AllocationFunction<Long>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
-                { 42d, (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, double.class,
-                        (AllocationFunction<Double>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedHeapScope, MemoryLayouts.BITS_64_LE, MemoryAddress.class,
-                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
-
-                { (byte)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_8_LE, byte.class,
-                        (AllocationFunction<Byte>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
-                { (short)42, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_16_LE, short.class,
-                        (AllocationFunction<Short>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
-                { 42, (ScopeFactory)AllocationScope::boundedNativeScope,
+                { 42, (ScopeFactory) NativeAllocationScope::boundedScope,
                         MemoryLayouts.BITS_32_LE, int.class,
-                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (AllocationFunction<Integer>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
-                { 42f, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_32_LE, float.class,
-                        (AllocationFunction<Float>)AllocationScope::allocate,
+                { 42f, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_32_LE, float.class,
+                        (AllocationFunction<Float>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
-                { 42L, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, long.class,
-                        (AllocationFunction<Long>)AllocationScope::allocate,
+                { 42L, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_64_LE, long.class,
+                        (AllocationFunction<Long>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
-                { 42d, (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, double.class,
-                        (AllocationFunction<Double>)AllocationScope::allocate,
+                { 42d, (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_64_LE, double.class,
+                        (AllocationFunction<Double>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
-                { MemoryAddress.ofLong(42), (ScopeFactory)AllocationScope::boundedNativeScope, MemoryLayouts.BITS_64_LE, MemoryAddress.class,
-                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                { MemoryAddress.ofLong(42), (ScopeFactory) NativeAllocationScope::boundedScope, MemoryLayouts.BITS_64_LE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
 
-                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_8_BE, byte.class,
-                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                { (byte)42, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_8_BE, byte.class,
+                        (AllocationFunction<Byte>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
-                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_16_BE, short.class,
-                        (AllocationFunction<Short>)AllocationScope::allocate,
+                { (short)42, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_16_BE, short.class,
+                        (AllocationFunction<Short>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
-                { 42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(),
+                { 42, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(),
                         MemoryLayouts.BITS_32_BE, int.class,
-                        (AllocationFunction<Integer>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
-                { 42f, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_32_BE, float.class,
-                        (AllocationFunction<Float>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
-                { 42L, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_BE, long.class,
-                        (AllocationFunction<Long>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
-                { 42d, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_BE, double.class,
-                        (AllocationFunction<Double>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_BE, MemoryAddress.class,
-                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
-
-                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_8_BE, byte.class,
-                        (AllocationFunction<Byte>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
-                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_16_BE, short.class,
-                        (AllocationFunction<Short>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
-                { 42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(),
-                        MemoryLayouts.BITS_32_BE, int.class,
-                        (AllocationFunction<Integer>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
-                { 42f, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_32_BE, float.class,
-                        (AllocationFunction<Float>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
-                { 42L, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_BE, long.class,
-                        (AllocationFunction<Long>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
-                { 42d, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_BE, double.class,
-                        (AllocationFunction<Double>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_BE, MemoryAddress.class,
-                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
-
-                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_8_LE, byte.class,
-                        (AllocationFunction<Byte>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
-                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_16_LE, short.class,
-                        (AllocationFunction<Short>)AllocationScope::allocate,
-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
-                { 42, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(),
-                        MemoryLayouts.BITS_32_LE, int.class,
-                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (AllocationFunction<Integer>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
-                { 42f, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_32_LE, float.class,
-                        (AllocationFunction<Float>)AllocationScope::allocate,
+                { 42f, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_32_BE, float.class,
+                        (AllocationFunction<Float>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
-                { 42L, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_LE, long.class,
-                        (AllocationFunction<Long>)AllocationScope::allocate,
+                { 42L, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_64_BE, long.class,
+                        (AllocationFunction<Long>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
-                { 42d, (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_LE, double.class,
-                        (AllocationFunction<Double>)AllocationScope::allocate,
+                { 42d, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_64_BE, double.class,
+                        (AllocationFunction<Double>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedHeapScope(), MemoryLayouts.BITS_64_LE, MemoryAddress.class,
-                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                { MemoryAddress.ofLong(42), (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_64_BE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
 
-                { (byte)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_8_LE, byte.class,
-                        (AllocationFunction<Byte>)AllocationScope::allocate,
+                { (byte)42, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_8_LE, byte.class,
+                        (AllocationFunction<Byte>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },
-                { (short)42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_16_LE, short.class,
-                        (AllocationFunction<Short>)AllocationScope::allocate,
+                { (short)42, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_16_LE, short.class,
+                        (AllocationFunction<Short>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },
-                { 42, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(),
+                { 42, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(),
                         MemoryLayouts.BITS_32_LE, int.class,
-                        (AllocationFunction<Integer>)AllocationScope::allocate,
+                        (AllocationFunction<Integer>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },
-                { 42f, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_32_LE, float.class,
-                        (AllocationFunction<Float>)AllocationScope::allocate,
+                { 42f, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_32_LE, float.class,
+                        (AllocationFunction<Float>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },
-                { 42L, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_LE, long.class,
-                        (AllocationFunction<Long>)AllocationScope::allocate,
+                { 42L, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_64_LE, long.class,
+                        (AllocationFunction<Long>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },
-                { 42d, (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_LE, double.class,
-                        (AllocationFunction<Double>)AllocationScope::allocate,
+                { 42d, (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_64_LE, double.class,
+                        (AllocationFunction<Double>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },
-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> AllocationScope.unboundedNativeScope(), MemoryLayouts.BITS_64_LE, MemoryAddress.class,
-                        (AllocationFunction<MemoryAddress>)AllocationScope::allocate,
+                { MemoryAddress.ofLong(42), (ScopeFactory)size -> NativeAllocationScope.unboundedScope(), MemoryLayouts.BITS_64_LE, MemoryAddress.class,
+                        (AllocationFunction<MemoryAddress>) NativeAllocationScope::allocate,
                         (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },
         };
     }
 
     interface AllocationFunction<X> {
-        MemoryAddress allocate(AllocationScope scope, MemoryLayout layout, X value);
+        MemoryAddress allocate(NativeAllocationScope scope, MemoryLayout layout, X value);
     }
 
     interface ScopeFactory {
-        AllocationScope make(int size);
+        NativeAllocationScope make(int size);
     }
 }

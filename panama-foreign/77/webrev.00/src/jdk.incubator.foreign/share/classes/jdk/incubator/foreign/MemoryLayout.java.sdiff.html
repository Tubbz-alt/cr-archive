<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryAddress.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PaddingLayout.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.LayoutPath;
 29 import jdk.internal.foreign.LayoutPath.PathElementImpl.PathKind;
 30 import jdk.internal.foreign.Utils;
 31 
 32 import java.lang.constant.Constable;
 33 import java.lang.constant.DynamicConstantDesc;
 34 import java.lang.invoke.VarHandle;
 35 import java.nio.ByteOrder;
 36 import java.util.EnumSet;
 37 import java.util.List;
 38 import java.util.Objects;
 39 import java.util.Optional;
 40 import java.util.OptionalLong;
 41 import java.util.Set;
 42 import java.util.function.Function;
 43 import java.util.function.UnaryOperator;

 44 
 45 /**
 46  * A memory layout can be used to describe the contents of a memory segment in a &lt;em&gt;language neutral&lt;/em&gt; fashion.
 47  * There are two leaves in the layout hierarchy, &lt;em&gt;value layouts&lt;/em&gt;, which are used to represent values of given size and kind (see
 48  * {@link ValueLayout}) and &lt;em&gt;padding layouts&lt;/em&gt; which are used, as the name suggests, to represent a portion of a memory
 49  * segment whose contents should be ignored, and which are primarily present for alignment reasons (see {@link MemoryLayout#ofPaddingBits(long)}).
 50  * Some common value layout constants are defined in the {@link MemoryLayouts} class.
 51  * &lt;p&gt;
 52  * More complex layouts can be derived from simpler ones: a &lt;em&gt;sequence layout&lt;/em&gt; denotes a repetition of one or more
 53  * element layout (see {@link SequenceLayout}); a &lt;em&gt;group layout&lt;/em&gt; denotes an aggregation of (typically) heterogeneous
 54  * member layouts (see {@link GroupLayout}).
 55  * &lt;p&gt;
 56  * All implementations of this interface must be &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;;
 57  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
 58  * instances of {@code MemoryLayout} may have unpredictable results and should be avoided. The {@code equals} method should
 59  * be used for comparisons.
 60  * &lt;p&gt;
 61  * Non-platform classes should not implement {@linkplain MemoryLayout} directly.
 62  *
 63  * &lt;h2&gt;&lt;a id = &quot;layout-align&quot;&gt;Size, alignment and byte order&lt;/a&gt;&lt;/h2&gt;
</pre>
<hr />
<pre>
267      * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),
268      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.
269      *
270      * @return the layout alignment constraint, in bytes.
271      * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.
272      */
273     default long byteAlignment() {
274         return Utils.bitsToBytesOrThrow(bitAlignment(),
275                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte alignment; bit alignment is not a multiple of 8&quot;));
276     }
277 
278     /**
279      * Creates a new layout which features the desired alignment constraint.
280      *
281      * @param bitAlignment the layout alignment constraint, expressed in bits.
282      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
283      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it&#39;s less than than 8.
284      */
285     MemoryLayout withBitAlignment(long bitAlignment);
286 
























287     /**
288      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
289      * layout.
290      *
291      * @apiNote if the layout path has one (or more) free dimensions,
292      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
293      *
294      * @param elements the layout path elements.
295      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
296      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
297      * layout path contains one or more path elements that select multiple sequence element indices
298      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
299      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
300      */
301     default long offset(PathElement... elements) {
302         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
303     }
304 
305     /**
306      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
</pre>
<hr />
<pre>
453 
454         /**
455          * Returns a path element which selects an unspecified element layout from a given sequence layout.
456          * If a path with free dimensions {@code n} is combined with the path element returned by this method,
457          * the number of free dimensions of the resulting path will be {@code 1 + n}.
458          *
459          * @return a path element which selects an unspecified sequence element layout.
460          */
461         static PathElement sequenceElement() {
462             return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.SEQUENCE_ELEMENT,
463                                                   LayoutPath::sequenceElement);
464         }
465     }
466 
467     /**
468      * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified
469      * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of
470      * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional
471      * conditions must be satisfied:
472      * &lt;ul&gt;
<span class="line-modified">473      *     &lt;li&gt;two value layouts are considered equal if they have the same endianness (see {@link ValueLayout#order()})&lt;/li&gt;</span>
474      *     &lt;li&gt;two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and
475      *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal&lt;/li&gt;
476      *     &lt;li&gt;two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},
477      *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal&lt;/li&gt;
478      * &lt;/ul&gt;
479      *
480      * @param that the object to be compared for equality with this layout.
481      * @return {@code true} if the specified object is equal to this layout.
482      */
483     boolean equals(Object that);
484 
485     /**
486      * Returns the hash code value for this layout.
487      *
488      * @return the hash code value for this layout.
489      */
490     int hashCode();
491 
492     /**
493      * Returns a string representation of this layout.
</pre>
</td>
<td>
<hr />
<pre>
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.LayoutPath;
 29 import jdk.internal.foreign.LayoutPath.PathElementImpl.PathKind;
 30 import jdk.internal.foreign.Utils;
 31 
 32 import java.lang.constant.Constable;
 33 import java.lang.constant.DynamicConstantDesc;
 34 import java.lang.invoke.VarHandle;
 35 import java.nio.ByteOrder;
 36 import java.util.EnumSet;
 37 import java.util.List;
 38 import java.util.Objects;
 39 import java.util.Optional;
 40 import java.util.OptionalLong;
 41 import java.util.Set;
 42 import java.util.function.Function;
 43 import java.util.function.UnaryOperator;
<span class="line-added"> 44 import java.util.stream.Stream;</span>
 45 
 46 /**
 47  * A memory layout can be used to describe the contents of a memory segment in a &lt;em&gt;language neutral&lt;/em&gt; fashion.
 48  * There are two leaves in the layout hierarchy, &lt;em&gt;value layouts&lt;/em&gt;, which are used to represent values of given size and kind (see
 49  * {@link ValueLayout}) and &lt;em&gt;padding layouts&lt;/em&gt; which are used, as the name suggests, to represent a portion of a memory
 50  * segment whose contents should be ignored, and which are primarily present for alignment reasons (see {@link MemoryLayout#ofPaddingBits(long)}).
 51  * Some common value layout constants are defined in the {@link MemoryLayouts} class.
 52  * &lt;p&gt;
 53  * More complex layouts can be derived from simpler ones: a &lt;em&gt;sequence layout&lt;/em&gt; denotes a repetition of one or more
 54  * element layout (see {@link SequenceLayout}); a &lt;em&gt;group layout&lt;/em&gt; denotes an aggregation of (typically) heterogeneous
 55  * member layouts (see {@link GroupLayout}).
 56  * &lt;p&gt;
 57  * All implementations of this interface must be &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;;
 58  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
 59  * instances of {@code MemoryLayout} may have unpredictable results and should be avoided. The {@code equals} method should
 60  * be used for comparisons.
 61  * &lt;p&gt;
 62  * Non-platform classes should not implement {@linkplain MemoryLayout} directly.
 63  *
 64  * &lt;h2&gt;&lt;a id = &quot;layout-align&quot;&gt;Size, alignment and byte order&lt;/a&gt;&lt;/h2&gt;
</pre>
<hr />
<pre>
268      * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),
269      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.
270      *
271      * @return the layout alignment constraint, in bytes.
272      * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.
273      */
274     default long byteAlignment() {
275         return Utils.bitsToBytesOrThrow(bitAlignment(),
276                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte alignment; bit alignment is not a multiple of 8&quot;));
277     }
278 
279     /**
280      * Creates a new layout which features the desired alignment constraint.
281      *
282      * @param bitAlignment the layout alignment constraint, expressed in bits.
283      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
284      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it&#39;s less than than 8.
285      */
286     MemoryLayout withBitAlignment(long bitAlignment);
287 
<span class="line-added">288     /**</span>
<span class="line-added">289      * Returns the attribute with the given name if it exists, or an empty optional</span>
<span class="line-added">290      *</span>
<span class="line-added">291      * @param name the name of the attribute</span>
<span class="line-added">292      * @return the optional attribute</span>
<span class="line-added">293      */</span>
<span class="line-added">294     Optional&lt;Constable&gt; attribute(String name);</span>
<span class="line-added">295 </span>
<span class="line-added">296     /**</span>
<span class="line-added">297      * Returns a new MemoryLayout with the given additional attribute</span>
<span class="line-added">298      *</span>
<span class="line-added">299      * @param name the name of the attribute</span>
<span class="line-added">300      * @param value the value of the attribute</span>
<span class="line-added">301      * @return the new MemoryLayout</span>
<span class="line-added">302      */</span>
<span class="line-added">303     MemoryLayout withAttribute(String name, Constable value);</span>
<span class="line-added">304 </span>
<span class="line-added">305     /**</span>
<span class="line-added">306      * Returns a stream of the names of the attributes of this layout</span>
<span class="line-added">307      *</span>
<span class="line-added">308      * @return the stream of names</span>
<span class="line-added">309      */</span>
<span class="line-added">310     Stream&lt;String&gt; attributes();</span>
<span class="line-added">311 </span>
312     /**
313      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
314      * layout.
315      *
316      * @apiNote if the layout path has one (or more) free dimensions,
317      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
318      *
319      * @param elements the layout path elements.
320      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
321      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
322      * layout path contains one or more path elements that select multiple sequence element indices
323      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
324      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
325      */
326     default long offset(PathElement... elements) {
327         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
328     }
329 
330     /**
331      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
</pre>
<hr />
<pre>
478 
479         /**
480          * Returns a path element which selects an unspecified element layout from a given sequence layout.
481          * If a path with free dimensions {@code n} is combined with the path element returned by this method,
482          * the number of free dimensions of the resulting path will be {@code 1 + n}.
483          *
484          * @return a path element which selects an unspecified sequence element layout.
485          */
486         static PathElement sequenceElement() {
487             return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.SEQUENCE_ELEMENT,
488                                                   LayoutPath::sequenceElement);
489         }
490     }
491 
492     /**
493      * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified
494      * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of
495      * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional
496      * conditions must be satisfied:
497      * &lt;ul&gt;
<span class="line-modified">498      *     &lt;li&gt;two value layouts are considered equal if they have the same byte order (see {@link ValueLayout#order()})&lt;/li&gt;</span>
499      *     &lt;li&gt;two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and
500      *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal&lt;/li&gt;
501      *     &lt;li&gt;two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},
502      *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal&lt;/li&gt;
503      * &lt;/ul&gt;
504      *
505      * @param that the object to be compared for equality with this layout.
506      * @return {@code true} if the specified object is equal to this layout.
507      */
508     boolean equals(Object that);
509 
510     /**
511      * Returns the hash code value for this layout.
512      *
513      * @return the hash code value for this layout.
514      */
515     int hashCode();
516 
517     /**
518      * Returns a string representation of this layout.
</pre>
</td>
</tr>
</table>
<center><a href="MemoryAddress.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PaddingLayout.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
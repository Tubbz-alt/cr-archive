<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
    2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.
    8  *
    9  * This code is distributed in the hope that it will be useful, but WITHOUT
   10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12  * version 2 for more details (a copy is included in the LICENSE file that
   13  * accompanied this code).
   14  *
   15  * You should have received a copy of the GNU General Public License version
   16  * 2 along with this work; if not, write to the Free Software Foundation,
   17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18  *
   19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20  * or visit www.oracle.com if you need additional information or have any
   21  * questions.
   22  *
   23  */
   24 
   25 #include &quot;precompiled.hpp&quot;
   26 #include &quot;jvm.h&quot;
   27 #include &quot;asm/assembler.hpp&quot;
   28 #include &quot;asm/assembler.inline.hpp&quot;
   29 #include &quot;compiler/disassembler.hpp&quot;
   30 #include &quot;gc/shared/barrierSet.hpp&quot;
   31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
   32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
   33 #include &quot;interpreter/interpreter.hpp&quot;
   34 #include &quot;memory/resourceArea.hpp&quot;
   35 #include &quot;memory/universe.hpp&quot;
   36 #include &quot;oops/accessDecorators.hpp&quot;
   37 #include &quot;oops/compressedOops.inline.hpp&quot;
   38 #include &quot;oops/klass.inline.hpp&quot;
   39 #include &quot;prims/methodHandles.hpp&quot;
   40 #include &quot;runtime/biasedLocking.hpp&quot;
   41 #include &quot;runtime/flags/flagSetting.hpp&quot;
   42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
   43 #include &quot;runtime/objectMonitor.hpp&quot;
   44 #include &quot;runtime/os.hpp&quot;
   45 #include &quot;runtime/safepoint.hpp&quot;
   46 #include &quot;runtime/safepointMechanism.hpp&quot;
   47 #include &quot;runtime/sharedRuntime.hpp&quot;
   48 #include &quot;runtime/stubRoutines.hpp&quot;
   49 #include &quot;runtime/thread.hpp&quot;
   50 #include &quot;utilities/macros.hpp&quot;
   51 #include &quot;crc32c.h&quot;
   52 #ifdef COMPILER2
   53 #include &quot;opto/intrinsicnode.hpp&quot;
   54 #endif
   55 
   56 #ifdef PRODUCT
   57 #define BLOCK_COMMENT(str) /* nothing */
   58 #define STOP(error) stop(error)
   59 #else
   60 #define BLOCK_COMMENT(str) block_comment(str)
   61 #define STOP(error) block_comment(error); stop(error)
   62 #endif
   63 
   64 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
   65 
   66 #ifdef ASSERT
   67 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
   68 #endif
   69 
   70 static Assembler::Condition reverse[] = {
   71     Assembler::noOverflow     /* overflow      = 0x0 */ ,
   72     Assembler::overflow       /* noOverflow    = 0x1 */ ,
   73     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
   74     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
   75     Assembler::notZero        /* zero          = 0x4, equal         = 0x4 */ ,
   76     Assembler::zero           /* notZero       = 0x5, notEqual      = 0x5 */ ,
   77     Assembler::above          /* belowEqual    = 0x6 */ ,
   78     Assembler::belowEqual     /* above         = 0x7 */ ,
   79     Assembler::positive       /* negative      = 0x8 */ ,
   80     Assembler::negative       /* positive      = 0x9 */ ,
   81     Assembler::noParity       /* parity        = 0xa */ ,
   82     Assembler::parity         /* noParity      = 0xb */ ,
   83     Assembler::greaterEqual   /* less          = 0xc */ ,
   84     Assembler::less           /* greaterEqual  = 0xd */ ,
   85     Assembler::greater        /* lessEqual     = 0xe */ ,
   86     Assembler::lessEqual      /* greater       = 0xf, */
   87 
   88 };
   89 
   90 
   91 // Implementation of MacroAssembler
   92 
   93 // First all the versions that have distinct versions depending on 32/64 bit
   94 // Unless the difference is trivial (1 line or so).
   95 
   96 #ifndef _LP64
   97 
   98 // 32bit versions
   99 
  100 Address MacroAssembler::as_Address(AddressLiteral adr) {
  101   return Address(adr.target(), adr.rspec());
  102 }
  103 
  104 Address MacroAssembler::as_Address(ArrayAddress adr) {
  105   return Address::make_array(adr);
  106 }
  107 
  108 void MacroAssembler::call_VM_leaf_base(address entry_point,
  109                                        int number_of_arguments) {
  110   call(RuntimeAddress(entry_point));
  111   increment(rsp, number_of_arguments * wordSize);
  112 }
  113 
  114 void MacroAssembler::cmpklass(Address src1, Metadata* obj) {
  115   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
  116 }
  117 
  118 void MacroAssembler::cmpklass(Register src1, Metadata* obj) {
  119   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
  120 }
  121 
  122 void MacroAssembler::cmpoop_raw(Address src1, jobject obj) {
  123   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
  124 }
  125 
  126 void MacroAssembler::cmpoop_raw(Register src1, jobject obj) {
  127   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
  128 }
  129 
  130 void MacroAssembler::cmpoop(Address src1, jobject obj) {
  131   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  132   bs-&gt;obj_equals(this, src1, obj);
  133 }
  134 
  135 void MacroAssembler::cmpoop(Register src1, jobject obj) {
  136   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  137   bs-&gt;obj_equals(this, src1, obj);
  138 }
  139 
  140 void MacroAssembler::extend_sign(Register hi, Register lo) {
  141   // According to Intel Doc. AP-526, &quot;Integer Divide&quot;, p.18.
  142   if (VM_Version::is_P6() &amp;&amp; hi == rdx &amp;&amp; lo == rax) {
  143     cdql();
  144   } else {
  145     movl(hi, lo);
  146     sarl(hi, 31);
  147   }
  148 }
  149 
  150 void MacroAssembler::jC2(Register tmp, Label&amp; L) {
  151   // set parity bit if FPU flag C2 is set (via rax)
  152   save_rax(tmp);
  153   fwait(); fnstsw_ax();
  154   sahf();
  155   restore_rax(tmp);
  156   // branch
  157   jcc(Assembler::parity, L);
  158 }
  159 
  160 void MacroAssembler::jnC2(Register tmp, Label&amp; L) {
  161   // set parity bit if FPU flag C2 is set (via rax)
  162   save_rax(tmp);
  163   fwait(); fnstsw_ax();
  164   sahf();
  165   restore_rax(tmp);
  166   // branch
  167   jcc(Assembler::noParity, L);
  168 }
  169 
  170 // 32bit can do a case table jump in one instruction but we no longer allow the base
  171 // to be installed in the Address class
  172 void MacroAssembler::jump(ArrayAddress entry) {
  173   jmp(as_Address(entry));
  174 }
  175 
  176 // Note: y_lo will be destroyed
  177 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
  178   // Long compare for Java (semantics as described in JVM spec.)
  179   Label high, low, done;
  180 
  181   cmpl(x_hi, y_hi);
  182   jcc(Assembler::less, low);
  183   jcc(Assembler::greater, high);
  184   // x_hi is the return register
  185   xorl(x_hi, x_hi);
  186   cmpl(x_lo, y_lo);
  187   jcc(Assembler::below, low);
  188   jcc(Assembler::equal, done);
  189 
  190   bind(high);
  191   xorl(x_hi, x_hi);
  192   increment(x_hi);
  193   jmp(done);
  194 
  195   bind(low);
  196   xorl(x_hi, x_hi);
  197   decrementl(x_hi);
  198 
  199   bind(done);
  200 }
  201 
  202 void MacroAssembler::lea(Register dst, AddressLiteral src) {
  203     mov_literal32(dst, (int32_t)src.target(), src.rspec());
  204 }
  205 
  206 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
  207   // leal(dst, as_Address(adr));
  208   // see note in movl as to why we must use a move
  209   mov_literal32(dst, (int32_t) adr.target(), adr.rspec());
  210 }
  211 
  212 void MacroAssembler::leave() {
  213   mov(rsp, rbp);
  214   pop(rbp);
  215 }
  216 
  217 void MacroAssembler::lmul(int x_rsp_offset, int y_rsp_offset) {
  218   // Multiplication of two Java long values stored on the stack
  219   // as illustrated below. Result is in rdx:rax.
  220   //
  221   // rsp ---&gt; [  ??  ] \               \
  222   //            ....    | y_rsp_offset  |
  223   //          [ y_lo ] /  (in bytes)    | x_rsp_offset
  224   //          [ y_hi ]                  | (in bytes)
  225   //            ....                    |
  226   //          [ x_lo ]                 /
  227   //          [ x_hi ]
  228   //            ....
  229   //
  230   // Basic idea: lo(result) = lo(x_lo * y_lo)
  231   //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
  232   Address x_hi(rsp, x_rsp_offset + wordSize); Address x_lo(rsp, x_rsp_offset);
  233   Address y_hi(rsp, y_rsp_offset + wordSize); Address y_lo(rsp, y_rsp_offset);
  234   Label quick;
  235   // load x_hi, y_hi and check if quick
  236   // multiplication is possible
  237   movl(rbx, x_hi);
  238   movl(rcx, y_hi);
  239   movl(rax, rbx);
  240   orl(rbx, rcx);                                 // rbx, = 0 &lt;=&gt; x_hi = 0 and y_hi = 0
  241   jcc(Assembler::zero, quick);                   // if rbx, = 0 do quick multiply
  242   // do full multiplication
  243   // 1st step
  244   mull(y_lo);                                    // x_hi * y_lo
  245   movl(rbx, rax);                                // save lo(x_hi * y_lo) in rbx,
  246   // 2nd step
  247   movl(rax, x_lo);
  248   mull(rcx);                                     // x_lo * y_hi
  249   addl(rbx, rax);                                // add lo(x_lo * y_hi) to rbx,
  250   // 3rd step
  251   bind(quick);                                   // note: rbx, = 0 if quick multiply!
  252   movl(rax, x_lo);
  253   mull(y_lo);                                    // x_lo * y_lo
  254   addl(rdx, rbx);                                // correct hi(x_lo * y_lo)
  255 }
  256 
  257 void MacroAssembler::lneg(Register hi, Register lo) {
  258   negl(lo);
  259   adcl(hi, 0);
  260   negl(hi);
  261 }
  262 
  263 void MacroAssembler::lshl(Register hi, Register lo) {
  264   // Java shift left long support (semantics as described in JVM spec., p.305)
  265   // (basic idea for shift counts s &gt;= n: x &lt;&lt; s == (x &lt;&lt; n) &lt;&lt; (s - n))
  266   // shift value is in rcx !
  267   assert(hi != rcx, &quot;must not use rcx&quot;);
  268   assert(lo != rcx, &quot;must not use rcx&quot;);
  269   const Register s = rcx;                        // shift count
  270   const int      n = BitsPerWord;
  271   Label L;
  272   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
  273   cmpl(s, n);                                    // if (s &lt; n)
  274   jcc(Assembler::less, L);                       // else (s &gt;= n)
  275   movl(hi, lo);                                  // x := x &lt;&lt; n
  276   xorl(lo, lo);
  277   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
  278   bind(L);                                       // s (mod n) &lt; n
  279   shldl(hi, lo);                                 // x := x &lt;&lt; s
  280   shll(lo);
  281 }
  282 
  283 
  284 void MacroAssembler::lshr(Register hi, Register lo, bool sign_extension) {
  285   // Java shift right long support (semantics as described in JVM spec., p.306 &amp; p.310)
  286   // (basic idea for shift counts s &gt;= n: x &gt;&gt; s == (x &gt;&gt; n) &gt;&gt; (s - n))
  287   assert(hi != rcx, &quot;must not use rcx&quot;);
  288   assert(lo != rcx, &quot;must not use rcx&quot;);
  289   const Register s = rcx;                        // shift count
  290   const int      n = BitsPerWord;
  291   Label L;
  292   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
  293   cmpl(s, n);                                    // if (s &lt; n)
  294   jcc(Assembler::less, L);                       // else (s &gt;= n)
  295   movl(lo, hi);                                  // x := x &gt;&gt; n
  296   if (sign_extension) sarl(hi, 31);
  297   else                xorl(hi, hi);
  298   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
  299   bind(L);                                       // s (mod n) &lt; n
  300   shrdl(lo, hi);                                 // x := x &gt;&gt; s
  301   if (sign_extension) sarl(hi);
  302   else                shrl(hi);
  303 }
  304 
  305 void MacroAssembler::movoop(Register dst, jobject obj) {
  306   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
  307 }
  308 
  309 void MacroAssembler::movoop(Address dst, jobject obj) {
  310   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
  311 }
  312 
  313 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
  314   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
  315 }
  316 
  317 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
  318   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
  319 }
  320 
  321 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
  322   // scratch register is not used,
  323   // it is defined to match parameters of 64-bit version of this method.
  324   if (src.is_lval()) {
  325     mov_literal32(dst, (intptr_t)src.target(), src.rspec());
  326   } else {
  327     movl(dst, as_Address(src));
  328   }
  329 }
  330 
  331 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
  332   movl(as_Address(dst), src);
  333 }
  334 
  335 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
  336   movl(dst, as_Address(src));
  337 }
  338 
  339 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
  340 void MacroAssembler::movptr(Address dst, intptr_t src) {
  341   movl(dst, src);
  342 }
  343 
  344 
  345 void MacroAssembler::pop_callee_saved_registers() {
  346   pop(rcx);
  347   pop(rdx);
  348   pop(rdi);
  349   pop(rsi);
  350 }
  351 
  352 void MacroAssembler::push_callee_saved_registers() {
  353   push(rsi);
  354   push(rdi);
  355   push(rdx);
  356   push(rcx);
  357 }
  358 
  359 void MacroAssembler::pushoop(jobject obj) {
  360   push_literal32((int32_t)obj, oop_Relocation::spec_for_immediate());
  361 }
  362 
  363 void MacroAssembler::pushklass(Metadata* obj) {
  364   push_literal32((int32_t)obj, metadata_Relocation::spec_for_immediate());
  365 }
  366 
  367 void MacroAssembler::pushptr(AddressLiteral src) {
  368   if (src.is_lval()) {
  369     push_literal32((int32_t)src.target(), src.rspec());
  370   } else {
  371     pushl(as_Address(src));
  372   }
  373 }
  374 
  375 void MacroAssembler::set_word_if_not_zero(Register dst) {
  376   xorl(dst, dst);
  377   set_byte_if_not_zero(dst);
  378 }
  379 
  380 static void pass_arg0(MacroAssembler* masm, Register arg) {
  381   masm-&gt;push(arg);
  382 }
  383 
  384 static void pass_arg1(MacroAssembler* masm, Register arg) {
  385   masm-&gt;push(arg);
  386 }
  387 
  388 static void pass_arg2(MacroAssembler* masm, Register arg) {
  389   masm-&gt;push(arg);
  390 }
  391 
  392 static void pass_arg3(MacroAssembler* masm, Register arg) {
  393   masm-&gt;push(arg);
  394 }
  395 
  396 #ifndef PRODUCT
  397 extern &quot;C&quot; void findpc(intptr_t x);
  398 #endif
  399 
  400 void MacroAssembler::debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg) {
  401   // In order to get locks to work, we need to fake a in_VM state
  402   JavaThread* thread = JavaThread::current();
  403   JavaThreadState saved_state = thread-&gt;thread_state();
  404   thread-&gt;set_thread_state(_thread_in_vm);
  405   if (ShowMessageBoxOnError) {
  406     JavaThread* thread = JavaThread::current();
  407     JavaThreadState saved_state = thread-&gt;thread_state();
  408     thread-&gt;set_thread_state(_thread_in_vm);
  409     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
  410       ttyLocker ttyl;
  411       BytecodeCounter::print();
  412     }
  413     // To see where a verify_oop failed, get $ebx+40/X for this frame.
  414     // This is the value of eip which points to where verify_oop will return.
  415     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
  416       print_state32(rdi, rsi, rbp, rsp, rbx, rdx, rcx, rax, eip);
  417       BREAKPOINT;
  418     }
  419   }
  420   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
  421 }
  422 
  423 void MacroAssembler::print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip) {
  424   ttyLocker ttyl;
  425   FlagSetting fs(Debugging, true);
  426   tty-&gt;print_cr(&quot;eip = 0x%08x&quot;, eip);
  427 #ifndef PRODUCT
  428   if ((WizardMode || Verbose) &amp;&amp; PrintMiscellaneous) {
  429     tty-&gt;cr();
  430     findpc(eip);
  431     tty-&gt;cr();
  432   }
  433 #endif
  434 #define PRINT_REG(rax) \
  435   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, rax); }
  436   PRINT_REG(rax);
  437   PRINT_REG(rbx);
  438   PRINT_REG(rcx);
  439   PRINT_REG(rdx);
  440   PRINT_REG(rdi);
  441   PRINT_REG(rsi);
  442   PRINT_REG(rbp);
  443   PRINT_REG(rsp);
  444 #undef PRINT_REG
  445   // Print some words near top of staack.
  446   int* dump_sp = (int*) rsp;
  447   for (int col1 = 0; col1 &lt; 8; col1++) {
  448     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
  449     os::print_location(tty, *dump_sp++);
  450   }
  451   for (int row = 0; row &lt; 16; row++) {
  452     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
  453     for (int col = 0; col &lt; 8; col++) {
  454       tty-&gt;print(&quot; 0x%08x&quot;, *dump_sp++);
  455     }
  456     tty-&gt;cr();
  457   }
  458   // Print some instructions around pc:
  459   Disassembler::decode((address)eip-64, (address)eip);
  460   tty-&gt;print_cr(&quot;--------&quot;);
  461   Disassembler::decode((address)eip, (address)eip+32);
  462 }
  463 
  464 void MacroAssembler::stop(const char* msg) {
  465   ExternalAddress message((address)msg);
  466   // push address of message
  467   pushptr(message.addr());
  468   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
  469   pusha();                                            // push registers
  470   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
  471   hlt();
  472 }
  473 
  474 void MacroAssembler::warn(const char* msg) {
  475   push_CPU_state();
  476 
  477   ExternalAddress message((address) msg);
  478   // push address of message
  479   pushptr(message.addr());
  480 
  481   call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));
  482   addl(rsp, wordSize);       // discard argument
  483   pop_CPU_state();
  484 }
  485 
  486 void MacroAssembler::print_state() {
  487   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
  488   pusha();                                            // push registers
  489 
  490   push_CPU_state();
  491   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::print_state32)));
  492   pop_CPU_state();
  493 
  494   popa();
  495   addl(rsp, wordSize);
  496 }
  497 
  498 #else // _LP64
  499 
  500 // 64 bit versions
  501 
  502 Address MacroAssembler::as_Address(AddressLiteral adr) {
  503   // amd64 always does this as a pc-rel
  504   // we can be absolute or disp based on the instruction type
  505   // jmp/call are displacements others are absolute
  506   assert(!adr.is_lval(), &quot;must be rval&quot;);
  507   assert(reachable(adr), &quot;must be&quot;);
  508   return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());
  509 
  510 }
  511 
  512 Address MacroAssembler::as_Address(ArrayAddress adr) {
  513   AddressLiteral base = adr.base();
  514   lea(rscratch1, base);
  515   Address index = adr.index();
  516   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
  517   Address array(rscratch1, index._index, index._scale, index._disp);
  518   return array;
  519 }
  520 
  521 void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) {
  522   Label L, E;
  523 
  524 #ifdef _WIN64
  525   // Windows always allocates space for it&#39;s register args
  526   assert(num_args &lt;= 4, &quot;only register arguments supported&quot;);
  527   subq(rsp,  frame::arg_reg_save_area_bytes);
  528 #endif
  529 
  530   // Align stack if necessary
  531   testl(rsp, 15);
  532   jcc(Assembler::zero, L);
  533 
  534   subq(rsp, 8);
  535   {
  536     call(RuntimeAddress(entry_point));
  537   }
  538   addq(rsp, 8);
  539   jmp(E);
  540 
  541   bind(L);
  542   {
  543     call(RuntimeAddress(entry_point));
  544   }
  545 
  546   bind(E);
  547 
  548 #ifdef _WIN64
  549   // restore stack pointer
  550   addq(rsp, frame::arg_reg_save_area_bytes);
  551 #endif
  552 
  553 }
  554 
  555 void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {
  556   assert(!src2.is_lval(), &quot;should use cmpptr&quot;);
  557 
  558   if (reachable(src2)) {
  559     cmpq(src1, as_Address(src2));
  560   } else {
  561     lea(rscratch1, src2);
  562     Assembler::cmpq(src1, Address(rscratch1, 0));
  563   }
  564 }
  565 
  566 int MacroAssembler::corrected_idivq(Register reg) {
  567   // Full implementation of Java ldiv and lrem; checks for special
  568   // case as described in JVM spec., p.243 &amp; p.271.  The function
  569   // returns the (pc) offset of the idivl instruction - may be needed
  570   // for implicit exceptions.
  571   //
  572   //         normal case                           special case
  573   //
  574   // input : rax: dividend                         min_long
  575   //         reg: divisor   (may not be eax/edx)   -1
  576   //
  577   // output: rax: quotient  (= rax idiv reg)       min_long
  578   //         rdx: remainder (= rax irem reg)       0
  579   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax or rdx register&quot;);
  580   static const int64_t min_long = 0x8000000000000000;
  581   Label normal_case, special_case;
  582 
  583   // check for special case
  584   cmp64(rax, ExternalAddress((address) &amp;min_long));
  585   jcc(Assembler::notEqual, normal_case);
  586   xorl(rdx, rdx); // prepare rdx for possible special case (where
  587                   // remainder = 0)
  588   cmpq(reg, -1);
  589   jcc(Assembler::equal, special_case);
  590 
  591   // handle normal case
  592   bind(normal_case);
  593   cdqq();
  594   int idivq_offset = offset();
  595   idivq(reg);
  596 
  597   // normal and special case exit
  598   bind(special_case);
  599 
  600   return idivq_offset;
  601 }
  602 
  603 void MacroAssembler::decrementq(Register reg, int value) {
  604   if (value == min_jint) { subq(reg, value); return; }
  605   if (value &lt;  0) { incrementq(reg, -value); return; }
  606   if (value == 0) {                        ; return; }
  607   if (value == 1 &amp;&amp; UseIncDec) { decq(reg) ; return; }
  608   /* else */      { subq(reg, value)       ; return; }
  609 }
  610 
  611 void MacroAssembler::decrementq(Address dst, int value) {
  612   if (value == min_jint) { subq(dst, value); return; }
  613   if (value &lt;  0) { incrementq(dst, -value); return; }
  614   if (value == 0) {                        ; return; }
  615   if (value == 1 &amp;&amp; UseIncDec) { decq(dst) ; return; }
  616   /* else */      { subq(dst, value)       ; return; }
  617 }
  618 
  619 void MacroAssembler::incrementq(AddressLiteral dst) {
  620   if (reachable(dst)) {
  621     incrementq(as_Address(dst));
  622   } else {
  623     lea(rscratch1, dst);
  624     incrementq(Address(rscratch1, 0));
  625   }
  626 }
  627 
  628 void MacroAssembler::incrementq(Register reg, int value) {
  629   if (value == min_jint) { addq(reg, value); return; }
  630   if (value &lt;  0) { decrementq(reg, -value); return; }
  631   if (value == 0) {                        ; return; }
  632   if (value == 1 &amp;&amp; UseIncDec) { incq(reg) ; return; }
  633   /* else */      { addq(reg, value)       ; return; }
  634 }
  635 
  636 void MacroAssembler::incrementq(Address dst, int value) {
  637   if (value == min_jint) { addq(dst, value); return; }
  638   if (value &lt;  0) { decrementq(dst, -value); return; }
  639   if (value == 0) {                        ; return; }
  640   if (value == 1 &amp;&amp; UseIncDec) { incq(dst) ; return; }
  641   /* else */      { addq(dst, value)       ; return; }
  642 }
  643 
  644 // 32bit can do a case table jump in one instruction but we no longer allow the base
  645 // to be installed in the Address class
  646 void MacroAssembler::jump(ArrayAddress entry) {
  647   lea(rscratch1, entry.base());
  648   Address dispatch = entry.index();
  649   assert(dispatch._base == noreg, &quot;must be&quot;);
  650   dispatch._base = rscratch1;
  651   jmp(dispatch);
  652 }
  653 
  654 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
  655   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
  656   cmpq(x_lo, y_lo);
  657 }
  658 
  659 void MacroAssembler::lea(Register dst, AddressLiteral src) {
  660     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
  661 }
  662 
  663 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
  664   mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());
  665   movptr(dst, rscratch1);
  666 }
  667 
  668 void MacroAssembler::leave() {
  669   // %%% is this really better? Why not on 32bit too?
  670   emit_int8((unsigned char)0xC9); // LEAVE
  671 }
  672 
  673 void MacroAssembler::lneg(Register hi, Register lo) {
  674   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
  675   negq(lo);
  676 }
  677 
  678 void MacroAssembler::movoop(Register dst, jobject obj) {
  679   mov_literal64(dst, (intptr_t)obj, oop_Relocation::spec_for_immediate());
  680 }
  681 
  682 void MacroAssembler::movoop(Address dst, jobject obj) {
  683   mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());
  684   movq(dst, rscratch1);
  685 }
  686 
  687 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
  688   mov_literal64(dst, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
  689 }
  690 
  691 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
  692   mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
  693   movq(dst, rscratch1);
  694 }
  695 
  696 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
  697   if (src.is_lval()) {
  698     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
  699   } else {
  700     if (reachable(src)) {
  701       movq(dst, as_Address(src));
  702     } else {
  703       lea(scratch, src);
  704       movq(dst, Address(scratch, 0));
  705     }
  706   }
  707 }
  708 
  709 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
  710   movq(as_Address(dst), src);
  711 }
  712 
  713 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
  714   movq(dst, as_Address(src));
  715 }
  716 
  717 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
  718 void MacroAssembler::movptr(Address dst, intptr_t src) {
  719   mov64(rscratch1, src);
  720   movq(dst, rscratch1);
  721 }
  722 
  723 // These are mostly for initializing NULL
  724 void MacroAssembler::movptr(Address dst, int32_t src) {
  725   movslq(dst, src);
  726 }
  727 
  728 void MacroAssembler::movptr(Register dst, int32_t src) {
  729   mov64(dst, (intptr_t)src);
  730 }
  731 
  732 void MacroAssembler::pushoop(jobject obj) {
  733   movoop(rscratch1, obj);
  734   push(rscratch1);
  735 }
  736 
  737 void MacroAssembler::pushklass(Metadata* obj) {
  738   mov_metadata(rscratch1, obj);
  739   push(rscratch1);
  740 }
  741 
  742 void MacroAssembler::pushptr(AddressLiteral src) {
  743   lea(rscratch1, src);
  744   if (src.is_lval()) {
  745     push(rscratch1);
  746   } else {
  747     pushq(Address(rscratch1, 0));
  748   }
  749 }
  750 
  751 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
  752   // we must set sp to zero to clear frame
  753   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
  754   // must clear fp, so that compiled frames are not confused; it is
  755   // possible that we need it only for debugging
  756   if (clear_fp) {
  757     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
  758   }
  759 
  760   // Always clear the pc because it could have been set by make_walkable()
  761   movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
  762   vzeroupper();
  763 }
  764 
  765 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
  766                                          Register last_java_fp,
  767                                          address  last_java_pc) {
  768   vzeroupper();
  769   // determine last_java_sp register
  770   if (!last_java_sp-&gt;is_valid()) {
  771     last_java_sp = rsp;
  772   }
  773 
  774   // last_java_fp is optional
  775   if (last_java_fp-&gt;is_valid()) {
  776     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),
  777            last_java_fp);
  778   }
  779 
  780   // last_java_pc is optional
  781   if (last_java_pc != NULL) {
  782     Address java_pc(r15_thread,
  783                     JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
  784     lea(rscratch1, InternalAddress(last_java_pc));
  785     movptr(java_pc, rscratch1);
  786   }
  787 
  788   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
  789 }
  790 
  791 static void pass_arg0(MacroAssembler* masm, Register arg) {
  792   if (c_rarg0 != arg ) {
  793     masm-&gt;mov(c_rarg0, arg);
  794   }
  795 }
  796 
  797 static void pass_arg1(MacroAssembler* masm, Register arg) {
  798   if (c_rarg1 != arg ) {
  799     masm-&gt;mov(c_rarg1, arg);
  800   }
  801 }
  802 
  803 static void pass_arg2(MacroAssembler* masm, Register arg) {
  804   if (c_rarg2 != arg ) {
  805     masm-&gt;mov(c_rarg2, arg);
  806   }
  807 }
  808 
  809 static void pass_arg3(MacroAssembler* masm, Register arg) {
  810   if (c_rarg3 != arg ) {
  811     masm-&gt;mov(c_rarg3, arg);
  812   }
  813 }
  814 
  815 void MacroAssembler::stop(const char* msg) {
  816   if (ShowMessageBoxOnError) {
  817     address rip = pc();
  818     pusha(); // get regs on stack
  819     lea(c_rarg1, InternalAddress(rip));
  820     movq(c_rarg2, rsp); // pass pointer to regs array
  821   }
  822   lea(c_rarg0, ExternalAddress((address) msg));
  823   andq(rsp, -16); // align stack as required by ABI
  824   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
  825   hlt();
  826 }
  827 
  828 void MacroAssembler::warn(const char* msg) {
  829   push(rbp);
  830   movq(rbp, rsp);
  831   andq(rsp, -16);     // align stack as required by push_CPU_state and call
  832   push_CPU_state();   // keeps alignment at 16 bytes
  833   lea(c_rarg0, ExternalAddress((address) msg));
  834   lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));
  835   call(rax);
  836   pop_CPU_state();
  837   mov(rsp, rbp);
  838   pop(rbp);
  839 }
  840 
  841 void MacroAssembler::print_state() {
  842   address rip = pc();
  843   pusha();            // get regs on stack
  844   push(rbp);
  845   movq(rbp, rsp);
  846   andq(rsp, -16);     // align stack as required by push_CPU_state and call
  847   push_CPU_state();   // keeps alignment at 16 bytes
  848 
  849   lea(c_rarg0, InternalAddress(rip));
  850   lea(c_rarg1, Address(rbp, wordSize)); // pass pointer to regs array
  851   call_VM_leaf(CAST_FROM_FN_PTR(address, MacroAssembler::print_state64), c_rarg0, c_rarg1);
  852 
  853   pop_CPU_state();
  854   mov(rsp, rbp);
  855   pop(rbp);
  856   popa();
  857 }
  858 
  859 #ifndef PRODUCT
  860 extern &quot;C&quot; void findpc(intptr_t x);
  861 #endif
  862 
  863 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[]) {
  864   // In order to get locks to work, we need to fake a in_VM state
  865   if (ShowMessageBoxOnError) {
  866     JavaThread* thread = JavaThread::current();
  867     JavaThreadState saved_state = thread-&gt;thread_state();
  868     thread-&gt;set_thread_state(_thread_in_vm);
  869 #ifndef PRODUCT
  870     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
  871       ttyLocker ttyl;
  872       BytecodeCounter::print();
  873     }
  874 #endif
  875     // To see where a verify_oop failed, get $ebx+40/X for this frame.
  876     // XXX correct this offset for amd64
  877     // This is the value of eip which points to where verify_oop will return.
  878     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
  879       print_state64(pc, regs);
  880       BREAKPOINT;
  881     }
  882   }
  883   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
  884 }
  885 
  886 void MacroAssembler::print_state64(int64_t pc, int64_t regs[]) {
  887   ttyLocker ttyl;
  888   FlagSetting fs(Debugging, true);
  889   tty-&gt;print_cr(&quot;rip = 0x%016lx&quot;, (intptr_t)pc);
  890 #ifndef PRODUCT
  891   tty-&gt;cr();
  892   findpc(pc);
  893   tty-&gt;cr();
  894 #endif
  895 #define PRINT_REG(rax, value) \
  896   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, value); }
  897   PRINT_REG(rax, regs[15]);
  898   PRINT_REG(rbx, regs[12]);
  899   PRINT_REG(rcx, regs[14]);
  900   PRINT_REG(rdx, regs[13]);
  901   PRINT_REG(rdi, regs[8]);
  902   PRINT_REG(rsi, regs[9]);
  903   PRINT_REG(rbp, regs[10]);
  904   PRINT_REG(rsp, regs[11]);
  905   PRINT_REG(r8 , regs[7]);
  906   PRINT_REG(r9 , regs[6]);
  907   PRINT_REG(r10, regs[5]);
  908   PRINT_REG(r11, regs[4]);
  909   PRINT_REG(r12, regs[3]);
  910   PRINT_REG(r13, regs[2]);
  911   PRINT_REG(r14, regs[1]);
  912   PRINT_REG(r15, regs[0]);
  913 #undef PRINT_REG
  914   // Print some words near top of staack.
  915   int64_t* rsp = (int64_t*) regs[11];
  916   int64_t* dump_sp = rsp;
  917   for (int col1 = 0; col1 &lt; 8; col1++) {
  918     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
  919     os::print_location(tty, *dump_sp++);
  920   }
  921   for (int row = 0; row &lt; 25; row++) {
  922     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
  923     for (int col = 0; col &lt; 4; col++) {
  924       tty-&gt;print(&quot; 0x%016lx&quot;, (intptr_t)*dump_sp++);
  925     }
  926     tty-&gt;cr();
  927   }
  928   // Print some instructions around pc:
  929   Disassembler::decode((address)pc-64, (address)pc);
  930   tty-&gt;print_cr(&quot;--------&quot;);
  931   Disassembler::decode((address)pc, (address)pc+32);
  932 }
  933 
  934 #endif // _LP64
  935 
  936 // Now versions that are common to 32/64 bit
  937 
  938 void MacroAssembler::addptr(Register dst, int32_t imm32) {
  939   LP64_ONLY(addq(dst, imm32)) NOT_LP64(addl(dst, imm32));
  940 }
  941 
  942 void MacroAssembler::addptr(Register dst, Register src) {
  943   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
  944 }
  945 
  946 void MacroAssembler::addptr(Address dst, Register src) {
  947   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
  948 }
  949 
  950 void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {
  951   if (reachable(src)) {
  952     Assembler::addsd(dst, as_Address(src));
  953   } else {
  954     lea(rscratch1, src);
  955     Assembler::addsd(dst, Address(rscratch1, 0));
  956   }
  957 }
  958 
  959 void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {
  960   if (reachable(src)) {
  961     addss(dst, as_Address(src));
  962   } else {
  963     lea(rscratch1, src);
  964     addss(dst, Address(rscratch1, 0));
  965   }
  966 }
  967 
  968 void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {
  969   if (reachable(src)) {
  970     Assembler::addpd(dst, as_Address(src));
  971   } else {
  972     lea(rscratch1, src);
  973     Assembler::addpd(dst, Address(rscratch1, 0));
  974   }
  975 }
  976 
  977 void MacroAssembler::align(int modulus) {
  978   align(modulus, offset());
  979 }
  980 
  981 void MacroAssembler::align(int modulus, int target) {
  982   if (target % modulus != 0) {
  983     nop(modulus - (target % modulus));
  984   }
  985 }
  986 
  987 void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
  988   // Used in sign-masking with aligned address.
  989   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
  990   if (reachable(src)) {
  991     Assembler::andpd(dst, as_Address(src));
  992   } else {
  993     lea(scratch_reg, src);
  994     Assembler::andpd(dst, Address(scratch_reg, 0));
  995   }
  996 }
  997 
  998 void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
  999   // Used in sign-masking with aligned address.
 1000   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 1001   if (reachable(src)) {
 1002     Assembler::andps(dst, as_Address(src));
 1003   } else {
 1004     lea(scratch_reg, src);
 1005     Assembler::andps(dst, Address(scratch_reg, 0));
 1006   }
 1007 }
 1008 
 1009 void MacroAssembler::andptr(Register dst, int32_t imm32) {
 1010   LP64_ONLY(andq(dst, imm32)) NOT_LP64(andl(dst, imm32));
 1011 }
 1012 
 1013 void MacroAssembler::atomic_incl(Address counter_addr) {
 1014   lock();
 1015   incrementl(counter_addr);
 1016 }
 1017 
 1018 void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {
 1019   if (reachable(counter_addr)) {
 1020     atomic_incl(as_Address(counter_addr));
 1021   } else {
 1022     lea(scr, counter_addr);
 1023     atomic_incl(Address(scr, 0));
 1024   }
 1025 }
 1026 
 1027 #ifdef _LP64
 1028 void MacroAssembler::atomic_incq(Address counter_addr) {
 1029   lock();
 1030   incrementq(counter_addr);
 1031 }
 1032 
 1033 void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {
 1034   if (reachable(counter_addr)) {
 1035     atomic_incq(as_Address(counter_addr));
 1036   } else {
 1037     lea(scr, counter_addr);
 1038     atomic_incq(Address(scr, 0));
 1039   }
 1040 }
 1041 #endif
 1042 
 1043 // Writes to stack successive pages until offset reached to check for
 1044 // stack overflow + shadow pages.  This clobbers tmp.
 1045 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
 1046   movptr(tmp, rsp);
 1047   // Bang stack for total size given plus shadow page size.
 1048   // Bang one page at a time because large size can bang beyond yellow and
 1049   // red zones.
 1050   Label loop;
 1051   bind(loop);
 1052   movl(Address(tmp, (-os::vm_page_size())), size );
 1053   subptr(tmp, os::vm_page_size());
 1054   subl(size, os::vm_page_size());
 1055   jcc(Assembler::greater, loop);
 1056 
 1057   // Bang down shadow pages too.
 1058   // At this point, (tmp-0) is the last address touched, so don&#39;t
 1059   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
 1060   // was post-decremented.)  Skip this address by starting at i=1, and
 1061   // touch a few more pages below.  N.B.  It is important to touch all
 1062   // the way down including all pages in the shadow zone.
 1063   for (int i = 1; i &lt; ((int)JavaThread::stack_shadow_zone_size() / os::vm_page_size()); i++) {
 1064     // this could be any sized move but this is can be a debugging crumb
 1065     // so the bigger the better.
 1066     movptr(Address(tmp, (-i*os::vm_page_size())), size );
 1067   }
 1068 }
 1069 
 1070 void MacroAssembler::reserved_stack_check() {
 1071     // testing if reserved zone needs to be enabled
 1072     Label no_reserved_zone_enabling;
 1073     Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 1074     NOT_LP64(get_thread(rsi);)
 1075 
 1076     cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));
 1077     jcc(Assembler::below, no_reserved_zone_enabling);
 1078 
 1079     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);
 1080     jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
 1081     should_not_reach_here();
 1082 
 1083     bind(no_reserved_zone_enabling);
 1084 }
 1085 
 1086 int MacroAssembler::biased_locking_enter(Register lock_reg,
 1087                                          Register obj_reg,
 1088                                          Register swap_reg,
 1089                                          Register tmp_reg,
 1090                                          bool swap_reg_contains_mark,
 1091                                          Label&amp; done,
 1092                                          Label* slow_case,
 1093                                          BiasedLockingCounters* counters) {
 1094   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 1095   assert(swap_reg == rax, &quot;swap_reg must be rax for cmpxchgq&quot;);
 1096   assert(tmp_reg != noreg, &quot;tmp_reg must be supplied&quot;);
 1097   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);
 1098   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
 1099   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
 1100   NOT_LP64( Address saved_mark_addr(lock_reg, 0); )
 1101 
 1102   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL) {
 1103     counters = BiasedLocking::counters();
 1104   }
 1105   // Biased locking
 1106   // See whether the lock is currently biased toward our thread and
 1107   // whether the epoch is still valid
 1108   // Note that the runtime guarantees sufficient alignment of JavaThread
 1109   // pointers to allow age to be placed into low bits
 1110   // First check to see whether biasing is even enabled for this object
 1111   Label cas_label;
 1112   int null_check_offset = -1;
 1113   if (!swap_reg_contains_mark) {
 1114     null_check_offset = offset();
 1115     movptr(swap_reg, mark_addr);
 1116   }
 1117   movptr(tmp_reg, swap_reg);
 1118   andptr(tmp_reg, markWord::biased_lock_mask_in_place);
 1119   cmpptr(tmp_reg, markWord::biased_lock_pattern);
 1120   jcc(Assembler::notEqual, cas_label);
 1121   // The bias pattern is present in the object&#39;s header. Need to check
 1122   // whether the bias owner and the epoch are both still current.
 1123 #ifndef _LP64
 1124   // Note that because there is no current thread register on x86_32 we
 1125   // need to store off the mark word we read out of the object to
 1126   // avoid reloading it and needing to recheck invariants below. This
 1127   // store is unfortunate but it makes the overall code shorter and
 1128   // simpler.
 1129   movptr(saved_mark_addr, swap_reg);
 1130 #endif
 1131   if (swap_reg_contains_mark) {
 1132     null_check_offset = offset();
 1133   }
 1134   load_prototype_header(tmp_reg, obj_reg);
 1135 #ifdef _LP64
 1136   orptr(tmp_reg, r15_thread);
 1137   xorptr(tmp_reg, swap_reg);
 1138   Register header_reg = tmp_reg;
 1139 #else
 1140   xorptr(tmp_reg, swap_reg);
 1141   get_thread(swap_reg);
 1142   xorptr(swap_reg, tmp_reg);
 1143   Register header_reg = swap_reg;
 1144 #endif
 1145   andptr(header_reg, ~((int) markWord::age_mask_in_place));
 1146   if (counters != NULL) {
 1147     cond_inc32(Assembler::zero,
 1148                ExternalAddress((address) counters-&gt;biased_lock_entry_count_addr()));
 1149   }
 1150   jcc(Assembler::equal, done);
 1151 
 1152   Label try_revoke_bias;
 1153   Label try_rebias;
 1154 
 1155   // At this point we know that the header has the bias pattern and
 1156   // that we are not the bias owner in the current epoch. We need to
 1157   // figure out more details about the state of the header in order to
 1158   // know what operations can be legally performed on the object&#39;s
 1159   // header.
 1160 
 1161   // If the low three bits in the xor result aren&#39;t clear, that means
 1162   // the prototype header is no longer biased and we have to revoke
 1163   // the bias on this object.
 1164   testptr(header_reg, markWord::biased_lock_mask_in_place);
 1165   jccb(Assembler::notZero, try_revoke_bias);
 1166 
 1167   // Biasing is still enabled for this data type. See whether the
 1168   // epoch of the current bias is still valid, meaning that the epoch
 1169   // bits of the mark word are equal to the epoch bits of the
 1170   // prototype header. (Note that the prototype header&#39;s epoch bits
 1171   // only change at a safepoint.) If not, attempt to rebias the object
 1172   // toward the current thread. Note that we must be absolutely sure
 1173   // that the current epoch is invalid in order to do this because
 1174   // otherwise the manipulations it performs on the mark word are
 1175   // illegal.
 1176   testptr(header_reg, markWord::epoch_mask_in_place);
 1177   jccb(Assembler::notZero, try_rebias);
 1178 
 1179   // The epoch of the current bias is still valid but we know nothing
 1180   // about the owner; it might be set or it might be clear. Try to
 1181   // acquire the bias of the object using an atomic operation. If this
 1182   // fails we will go in to the runtime to revoke the object&#39;s bias.
 1183   // Note that we first construct the presumed unbiased header so we
 1184   // don&#39;t accidentally blow away another thread&#39;s valid bias.
 1185   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
 1186   andptr(swap_reg,
 1187          markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
 1188 #ifdef _LP64
 1189   movptr(tmp_reg, swap_reg);
 1190   orptr(tmp_reg, r15_thread);
 1191 #else
 1192   get_thread(tmp_reg);
 1193   orptr(tmp_reg, swap_reg);
 1194 #endif
 1195   lock();
 1196   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
 1197   // If the biasing toward our thread failed, this means that
 1198   // another thread succeeded in biasing it toward itself and we
 1199   // need to revoke that bias. The revocation will occur in the
 1200   // interpreter runtime in the slow case.
 1201   if (counters != NULL) {
 1202     cond_inc32(Assembler::zero,
 1203                ExternalAddress((address) counters-&gt;anonymously_biased_lock_entry_count_addr()));
 1204   }
 1205   if (slow_case != NULL) {
 1206     jcc(Assembler::notZero, *slow_case);
 1207   }
 1208   jmp(done);
 1209 
 1210   bind(try_rebias);
 1211   // At this point we know the epoch has expired, meaning that the
 1212   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
 1213   // circumstances _only_, we are allowed to use the current header&#39;s
 1214   // value as the comparison value when doing the cas to acquire the
 1215   // bias in the current epoch. In other words, we allow transfer of
 1216   // the bias from one thread to another directly in this situation.
 1217   //
 1218   // FIXME: due to a lack of registers we currently blow away the age
 1219   // bits in this situation. Should attempt to preserve them.
 1220   load_prototype_header(tmp_reg, obj_reg);
 1221 #ifdef _LP64
 1222   orptr(tmp_reg, r15_thread);
 1223 #else
 1224   get_thread(swap_reg);
 1225   orptr(tmp_reg, swap_reg);
 1226   movptr(swap_reg, saved_mark_addr);
 1227 #endif
 1228   lock();
 1229   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
 1230   // If the biasing toward our thread failed, then another thread
 1231   // succeeded in biasing it toward itself and we need to revoke that
 1232   // bias. The revocation will occur in the runtime in the slow case.
 1233   if (counters != NULL) {
 1234     cond_inc32(Assembler::zero,
 1235                ExternalAddress((address) counters-&gt;rebiased_lock_entry_count_addr()));
 1236   }
 1237   if (slow_case != NULL) {
 1238     jcc(Assembler::notZero, *slow_case);
 1239   }
 1240   jmp(done);
 1241 
 1242   bind(try_revoke_bias);
 1243   // The prototype mark in the klass doesn&#39;t have the bias bit set any
 1244   // more, indicating that objects of this data type are not supposed
 1245   // to be biased any more. We are going to try to reset the mark of
 1246   // this object to the prototype value and fall through to the
 1247   // CAS-based locking scheme. Note that if our CAS fails, it means
 1248   // that another thread raced us for the privilege of revoking the
 1249   // bias of this particular object, so it&#39;s okay to continue in the
 1250   // normal locking code.
 1251   //
 1252   // FIXME: due to a lack of registers we currently blow away the age
 1253   // bits in this situation. Should attempt to preserve them.
 1254   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
 1255   load_prototype_header(tmp_reg, obj_reg);
 1256   lock();
 1257   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
 1258   // Fall through to the normal CAS-based lock, because no matter what
 1259   // the result of the above CAS, some thread must have succeeded in
 1260   // removing the bias bit from the object&#39;s header.
 1261   if (counters != NULL) {
 1262     cond_inc32(Assembler::zero,
 1263                ExternalAddress((address) counters-&gt;revoked_lock_entry_count_addr()));
 1264   }
 1265 
 1266   bind(cas_label);
 1267 
 1268   return null_check_offset;
 1269 }
 1270 
 1271 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
 1272   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 1273 
 1274   // Check for biased locking unlock case, which is a no-op
 1275   // Note: we do not have to check the thread ID for two reasons.
 1276   // First, the interpreter checks for IllegalMonitorStateException at
 1277   // a higher level. Second, if the bias was revoked while we held the
 1278   // lock, the object could not be rebiased toward another thread, so
 1279   // the bias bit would be clear.
 1280   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 1281   andptr(temp_reg, markWord::biased_lock_mask_in_place);
 1282   cmpptr(temp_reg, markWord::biased_lock_pattern);
 1283   jcc(Assembler::equal, done);
 1284 }
 1285 
 1286 #ifdef COMPILER2
 1287 
 1288 #if INCLUDE_RTM_OPT
 1289 
 1290 // Update rtm_counters based on abort status
 1291 // input: abort_status
 1292 //        rtm_counters (RTMLockingCounters*)
 1293 // flags are killed
 1294 void MacroAssembler::rtm_counters_update(Register abort_status, Register rtm_counters) {
 1295 
 1296   atomic_incptr(Address(rtm_counters, RTMLockingCounters::abort_count_offset()));
 1297   if (PrintPreciseRTMLockingStatistics) {
 1298     for (int i = 0; i &lt; RTMLockingCounters::ABORT_STATUS_LIMIT; i++) {
 1299       Label check_abort;
 1300       testl(abort_status, (1&lt;&lt;i));
 1301       jccb(Assembler::equal, check_abort);
 1302       atomic_incptr(Address(rtm_counters, RTMLockingCounters::abortX_count_offset() + (i * sizeof(uintx))));
 1303       bind(check_abort);
 1304     }
 1305   }
 1306 }
 1307 
 1308 // Branch if (random &amp; (count-1) != 0), count is 2^n
 1309 // tmp, scr and flags are killed
 1310 void MacroAssembler::branch_on_random_using_rdtsc(Register tmp, Register scr, int count, Label&amp; brLabel) {
 1311   assert(tmp == rax, &quot;&quot;);
 1312   assert(scr == rdx, &quot;&quot;);
 1313   rdtsc(); // modifies EDX:EAX
 1314   andptr(tmp, count-1);
 1315   jccb(Assembler::notZero, brLabel);
 1316 }
 1317 
 1318 // Perform abort ratio calculation, set no_rtm bit if high ratio
 1319 // input:  rtm_counters_Reg (RTMLockingCounters* address)
 1320 // tmpReg, rtm_counters_Reg and flags are killed
 1321 void MacroAssembler::rtm_abort_ratio_calculation(Register tmpReg,
 1322                                                  Register rtm_counters_Reg,
 1323                                                  RTMLockingCounters* rtm_counters,
 1324                                                  Metadata* method_data) {
 1325   Label L_done, L_check_always_rtm1, L_check_always_rtm2;
 1326 
 1327   if (RTMLockingCalculationDelay &gt; 0) {
 1328     // Delay calculation
 1329     movptr(tmpReg, ExternalAddress((address) RTMLockingCounters::rtm_calculation_flag_addr()), tmpReg);
 1330     testptr(tmpReg, tmpReg);
 1331     jccb(Assembler::equal, L_done);
 1332   }
 1333   // Abort ratio calculation only if abort_count &gt; RTMAbortThreshold
 1334   //   Aborted transactions = abort_count * 100
 1335   //   All transactions = total_count *  RTMTotalCountIncrRate
 1336   //   Set no_rtm bit if (Aborted transactions &gt;= All transactions * RTMAbortRatio)
 1337 
 1338   movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::abort_count_offset()));
 1339   cmpptr(tmpReg, RTMAbortThreshold);
 1340   jccb(Assembler::below, L_check_always_rtm2);
 1341   imulptr(tmpReg, tmpReg, 100);
 1342 
 1343   Register scrReg = rtm_counters_Reg;
 1344   movptr(scrReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));
 1345   imulptr(scrReg, scrReg, RTMTotalCountIncrRate);
 1346   imulptr(scrReg, scrReg, RTMAbortRatio);
 1347   cmpptr(tmpReg, scrReg);
 1348   jccb(Assembler::below, L_check_always_rtm1);
 1349   if (method_data != NULL) {
 1350     // set rtm_state to &quot;no rtm&quot; in MDO
 1351     mov_metadata(tmpReg, method_data);
 1352     lock();
 1353     orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), NoRTM);
 1354   }
 1355   jmpb(L_done);
 1356   bind(L_check_always_rtm1);
 1357   // Reload RTMLockingCounters* address
 1358   lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));
 1359   bind(L_check_always_rtm2);
 1360   movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));
 1361   cmpptr(tmpReg, RTMLockingThreshold / RTMTotalCountIncrRate);
 1362   jccb(Assembler::below, L_done);
 1363   if (method_data != NULL) {
 1364     // set rtm_state to &quot;always rtm&quot; in MDO
 1365     mov_metadata(tmpReg, method_data);
 1366     lock();
 1367     orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), UseRTM);
 1368   }
 1369   bind(L_done);
 1370 }
 1371 
 1372 // Update counters and perform abort ratio calculation
 1373 // input:  abort_status_Reg
 1374 // rtm_counters_Reg, flags are killed
 1375 void MacroAssembler::rtm_profiling(Register abort_status_Reg,
 1376                                    Register rtm_counters_Reg,
 1377                                    RTMLockingCounters* rtm_counters,
 1378                                    Metadata* method_data,
 1379                                    bool profile_rtm) {
 1380 
 1381   assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);
 1382   // update rtm counters based on rax value at abort
 1383   // reads abort_status_Reg, updates flags
 1384   lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));
 1385   rtm_counters_update(abort_status_Reg, rtm_counters_Reg);
 1386   if (profile_rtm) {
 1387     // Save abort status because abort_status_Reg is used by following code.
 1388     if (RTMRetryCount &gt; 0) {
 1389       push(abort_status_Reg);
 1390     }
 1391     assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);
 1392     rtm_abort_ratio_calculation(abort_status_Reg, rtm_counters_Reg, rtm_counters, method_data);
 1393     // restore abort status
 1394     if (RTMRetryCount &gt; 0) {
 1395       pop(abort_status_Reg);
 1396     }
 1397   }
 1398 }
 1399 
 1400 // Retry on abort if abort&#39;s status is 0x6: can retry (0x2) | memory conflict (0x4)
 1401 // inputs: retry_count_Reg
 1402 //       : abort_status_Reg
 1403 // output: retry_count_Reg decremented by 1
 1404 // flags are killed
 1405 void MacroAssembler::rtm_retry_lock_on_abort(Register retry_count_Reg, Register abort_status_Reg, Label&amp; retryLabel) {
 1406   Label doneRetry;
 1407   assert(abort_status_Reg == rax, &quot;&quot;);
 1408   // The abort reason bits are in eax (see all states in rtmLocking.hpp)
 1409   // 0x6 = conflict on which we can retry (0x2) | memory conflict (0x4)
 1410   // if reason is in 0x6 and retry count != 0 then retry
 1411   andptr(abort_status_Reg, 0x6);
 1412   jccb(Assembler::zero, doneRetry);
 1413   testl(retry_count_Reg, retry_count_Reg);
 1414   jccb(Assembler::zero, doneRetry);
 1415   pause();
 1416   decrementl(retry_count_Reg);
 1417   jmp(retryLabel);
 1418   bind(doneRetry);
 1419 }
 1420 
 1421 // Spin and retry if lock is busy,
 1422 // inputs: box_Reg (monitor address)
 1423 //       : retry_count_Reg
 1424 // output: retry_count_Reg decremented by 1
 1425 //       : clear z flag if retry count exceeded
 1426 // tmp_Reg, scr_Reg, flags are killed
 1427 void MacroAssembler::rtm_retry_lock_on_busy(Register retry_count_Reg, Register box_Reg,
 1428                                             Register tmp_Reg, Register scr_Reg, Label&amp; retryLabel) {
 1429   Label SpinLoop, SpinExit, doneRetry;
 1430   int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);
 1431 
 1432   testl(retry_count_Reg, retry_count_Reg);
 1433   jccb(Assembler::zero, doneRetry);
 1434   decrementl(retry_count_Reg);
 1435   movptr(scr_Reg, RTMSpinLoopCount);
 1436 
 1437   bind(SpinLoop);
 1438   pause();
 1439   decrementl(scr_Reg);
 1440   jccb(Assembler::lessEqual, SpinExit);
 1441   movptr(tmp_Reg, Address(box_Reg, owner_offset));
 1442   testptr(tmp_Reg, tmp_Reg);
 1443   jccb(Assembler::notZero, SpinLoop);
 1444 
 1445   bind(SpinExit);
 1446   jmp(retryLabel);
 1447   bind(doneRetry);
 1448   incrementl(retry_count_Reg); // clear z flag
 1449 }
 1450 
 1451 // Use RTM for normal stack locks
 1452 // Input: objReg (object to lock)
 1453 void MacroAssembler::rtm_stack_locking(Register objReg, Register tmpReg, Register scrReg,
 1454                                        Register retry_on_abort_count_Reg,
 1455                                        RTMLockingCounters* stack_rtm_counters,
 1456                                        Metadata* method_data, bool profile_rtm,
 1457                                        Label&amp; DONE_LABEL, Label&amp; IsInflated) {
 1458   assert(UseRTMForStackLocks, &quot;why call this otherwise?&quot;);
 1459   assert(!UseBiasedLocking, &quot;Biased locking is not supported with RTM locking&quot;);
 1460   assert(tmpReg == rax, &quot;&quot;);
 1461   assert(scrReg == rdx, &quot;&quot;);
 1462   Label L_rtm_retry, L_decrement_retry, L_on_abort;
 1463 
 1464   if (RTMRetryCount &gt; 0) {
 1465     movl(retry_on_abort_count_Reg, RTMRetryCount); // Retry on abort
 1466     bind(L_rtm_retry);
 1467   }
 1468   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));
 1469   testptr(tmpReg, markWord::monitor_value);  // inflated vs stack-locked|neutral|biased
 1470   jcc(Assembler::notZero, IsInflated);
 1471 
 1472   if (PrintPreciseRTMLockingStatistics || profile_rtm) {
 1473     Label L_noincrement;
 1474     if (RTMTotalCountIncrRate &gt; 1) {
 1475       // tmpReg, scrReg and flags are killed
 1476       branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);
 1477     }
 1478     assert(stack_rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);
 1479     atomic_incptr(ExternalAddress((address)stack_rtm_counters-&gt;total_count_addr()), scrReg);
 1480     bind(L_noincrement);
 1481   }
 1482   xbegin(L_on_abort);
 1483   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));       // fetch markword
 1484   andptr(tmpReg, markWord::biased_lock_mask_in_place); // look at 3 lock bits
 1485   cmpptr(tmpReg, markWord::unlocked_value);            // bits = 001 unlocked
 1486   jcc(Assembler::equal, DONE_LABEL);        // all done if unlocked
 1487 
 1488   Register abort_status_Reg = tmpReg; // status of abort is stored in RAX
 1489   if (UseRTMXendForLockBusy) {
 1490     xend();
 1491     movptr(abort_status_Reg, 0x2);   // Set the abort status to 2 (so we can retry)
 1492     jmp(L_decrement_retry);
 1493   }
 1494   else {
 1495     xabort(0);
 1496   }
 1497   bind(L_on_abort);
 1498   if (PrintPreciseRTMLockingStatistics || profile_rtm) {
 1499     rtm_profiling(abort_status_Reg, scrReg, stack_rtm_counters, method_data, profile_rtm);
 1500   }
 1501   bind(L_decrement_retry);
 1502   if (RTMRetryCount &gt; 0) {
 1503     // retry on lock abort if abort status is &#39;can retry&#39; (0x2) or &#39;memory conflict&#39; (0x4)
 1504     rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);
 1505   }
 1506 }
 1507 
 1508 // Use RTM for inflating locks
 1509 // inputs: objReg (object to lock)
 1510 //         boxReg (on-stack box address (displaced header location) - KILLED)
 1511 //         tmpReg (ObjectMonitor address + markWord::monitor_value)
 1512 void MacroAssembler::rtm_inflated_locking(Register objReg, Register boxReg, Register tmpReg,
 1513                                           Register scrReg, Register retry_on_busy_count_Reg,
 1514                                           Register retry_on_abort_count_Reg,
 1515                                           RTMLockingCounters* rtm_counters,
 1516                                           Metadata* method_data, bool profile_rtm,
 1517                                           Label&amp; DONE_LABEL) {
 1518   assert(UseRTMLocking, &quot;why call this otherwise?&quot;);
 1519   assert(tmpReg == rax, &quot;&quot;);
 1520   assert(scrReg == rdx, &quot;&quot;);
 1521   Label L_rtm_retry, L_decrement_retry, L_on_abort;
 1522   int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);
 1523 
 1524   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.
 1525   movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));
 1526   movptr(boxReg, tmpReg); // Save ObjectMonitor address
 1527 
 1528   if (RTMRetryCount &gt; 0) {
 1529     movl(retry_on_busy_count_Reg, RTMRetryCount);  // Retry on lock busy
 1530     movl(retry_on_abort_count_Reg, RTMRetryCount); // Retry on abort
 1531     bind(L_rtm_retry);
 1532   }
 1533   if (PrintPreciseRTMLockingStatistics || profile_rtm) {
 1534     Label L_noincrement;
 1535     if (RTMTotalCountIncrRate &gt; 1) {
 1536       // tmpReg, scrReg and flags are killed
 1537       branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);
 1538     }
 1539     assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);
 1540     atomic_incptr(ExternalAddress((address)rtm_counters-&gt;total_count_addr()), scrReg);
 1541     bind(L_noincrement);
 1542   }
 1543   xbegin(L_on_abort);
 1544   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));
 1545   movptr(tmpReg, Address(tmpReg, owner_offset));
 1546   testptr(tmpReg, tmpReg);
 1547   jcc(Assembler::zero, DONE_LABEL);
 1548   if (UseRTMXendForLockBusy) {
 1549     xend();
 1550     jmp(L_decrement_retry);
 1551   }
 1552   else {
 1553     xabort(0);
 1554   }
 1555   bind(L_on_abort);
 1556   Register abort_status_Reg = tmpReg; // status of abort is stored in RAX
 1557   if (PrintPreciseRTMLockingStatistics || profile_rtm) {
 1558     rtm_profiling(abort_status_Reg, scrReg, rtm_counters, method_data, profile_rtm);
 1559   }
 1560   if (RTMRetryCount &gt; 0) {
 1561     // retry on lock abort if abort status is &#39;can retry&#39; (0x2) or &#39;memory conflict&#39; (0x4)
 1562     rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);
 1563   }
 1564 
 1565   movptr(tmpReg, Address(boxReg, owner_offset)) ;
 1566   testptr(tmpReg, tmpReg) ;
 1567   jccb(Assembler::notZero, L_decrement_retry) ;
 1568 
 1569   // Appears unlocked - try to swing _owner from null to non-null.
 1570   // Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.
 1571 #ifdef _LP64
 1572   Register threadReg = r15_thread;
 1573 #else
 1574   get_thread(scrReg);
 1575   Register threadReg = scrReg;
 1576 #endif
 1577   lock();
 1578   cmpxchgptr(threadReg, Address(boxReg, owner_offset)); // Updates tmpReg
 1579 
 1580   if (RTMRetryCount &gt; 0) {
 1581     // success done else retry
 1582     jccb(Assembler::equal, DONE_LABEL) ;
 1583     bind(L_decrement_retry);
 1584     // Spin and retry if lock is busy.
 1585     rtm_retry_lock_on_busy(retry_on_busy_count_Reg, boxReg, tmpReg, scrReg, L_rtm_retry);
 1586   }
 1587   else {
 1588     bind(L_decrement_retry);
 1589   }
 1590 }
 1591 
 1592 #endif //  INCLUDE_RTM_OPT
 1593 
 1594 // fast_lock and fast_unlock used by C2
 1595 
 1596 // Because the transitions from emitted code to the runtime
 1597 // monitorenter/exit helper stubs are so slow it&#39;s critical that
 1598 // we inline both the stack-locking fast path and the inflated fast path.
 1599 //
 1600 // See also: cmpFastLock and cmpFastUnlock.
 1601 //
 1602 // What follows is a specialized inline transliteration of the code
 1603 // in enter() and exit(). If we&#39;re concerned about I$ bloat another
 1604 // option would be to emit TrySlowEnter and TrySlowExit methods
 1605 // at startup-time.  These methods would accept arguments as
 1606 // (rax,=Obj, rbx=Self, rcx=box, rdx=Scratch) and return success-failure
 1607 // indications in the icc.ZFlag.  fast_lock and fast_unlock would simply
 1608 // marshal the arguments and emit calls to TrySlowEnter and TrySlowExit.
 1609 // In practice, however, the # of lock sites is bounded and is usually small.
 1610 // Besides the call overhead, TrySlowEnter and TrySlowExit might suffer
 1611 // if the processor uses simple bimodal branch predictors keyed by EIP
 1612 // Since the helper routines would be called from multiple synchronization
 1613 // sites.
 1614 //
 1615 // An even better approach would be write &quot;MonitorEnter()&quot; and &quot;MonitorExit()&quot;
 1616 // in java - using j.u.c and unsafe - and just bind the lock and unlock sites
 1617 // to those specialized methods.  That&#39;d give us a mostly platform-independent
 1618 // implementation that the JITs could optimize and inline at their pleasure.
 1619 // Done correctly, the only time we&#39;d need to cross to native could would be
 1620 // to park() or unpark() threads.  We&#39;d also need a few more unsafe operators
 1621 // to (a) prevent compiler-JIT reordering of non-volatile accesses, and
 1622 // (b) explicit barriers or fence operations.
 1623 //
 1624 // TODO:
 1625 //
 1626 // *  Arrange for C2 to pass &quot;Self&quot; into fast_lock and fast_unlock in one of the registers (scr).
 1627 //    This avoids manifesting the Self pointer in the fast_lock and fast_unlock terminals.
 1628 //    Given TLAB allocation, Self is usually manifested in a register, so passing it into
 1629 //    the lock operators would typically be faster than reifying Self.
 1630 //
 1631 // *  Ideally I&#39;d define the primitives as:
 1632 //       fast_lock   (nax Obj, nax box, EAX tmp, nax scr) where box, tmp and scr are KILLED.
 1633 //       fast_unlock (nax Obj, EAX box, nax tmp) where box and tmp are KILLED
 1634 //    Unfortunately ADLC bugs prevent us from expressing the ideal form.
 1635 //    Instead, we&#39;re stuck with a rather awkward and brittle register assignments below.
 1636 //    Furthermore the register assignments are overconstrained, possibly resulting in
 1637 //    sub-optimal code near the synchronization site.
 1638 //
 1639 // *  Eliminate the sp-proximity tests and just use &quot;== Self&quot; tests instead.
 1640 //    Alternately, use a better sp-proximity test.
 1641 //
 1642 // *  Currently ObjectMonitor._Owner can hold either an sp value or a (THREAD *) value.
 1643 //    Either one is sufficient to uniquely identify a thread.
 1644 //    TODO: eliminate use of sp in _owner and use get_thread(tr) instead.
 1645 //
 1646 // *  Intrinsify notify() and notifyAll() for the common cases where the
 1647 //    object is locked by the calling thread but the waitlist is empty.
 1648 //    avoid the expensive JNI call to JVM_Notify() and JVM_NotifyAll().
 1649 //
 1650 // *  use jccb and jmpb instead of jcc and jmp to improve code density.
 1651 //    But beware of excessive branch density on AMD Opterons.
 1652 //
 1653 // *  Both fast_lock and fast_unlock set the ICC.ZF to indicate success
 1654 //    or failure of the fast path.  If the fast path fails then we pass
 1655 //    control to the slow path, typically in C.  In fast_lock and
 1656 //    fast_unlock we often branch to DONE_LABEL, just to find that C2
 1657 //    will emit a conditional branch immediately after the node.
 1658 //    So we have branches to branches and lots of ICC.ZF games.
 1659 //    Instead, it might be better to have C2 pass a &quot;FailureLabel&quot;
 1660 //    into fast_lock and fast_unlock.  In the case of success, control
 1661 //    will drop through the node.  ICC.ZF is undefined at exit.
 1662 //    In the case of failure, the node will branch directly to the
 1663 //    FailureLabel
 1664 
 1665 
 1666 // obj: object to lock
 1667 // box: on-stack box address (displaced header location) - KILLED
 1668 // rax,: tmp -- KILLED
 1669 // scr: tmp -- KILLED
 1670 void MacroAssembler::fast_lock(Register objReg, Register boxReg, Register tmpReg,
 1671                                Register scrReg, Register cx1Reg, Register cx2Reg,
 1672                                BiasedLockingCounters* counters,
 1673                                RTMLockingCounters* rtm_counters,
 1674                                RTMLockingCounters* stack_rtm_counters,
 1675                                Metadata* method_data,
 1676                                bool use_rtm, bool profile_rtm) {
 1677   // Ensure the register assignments are disjoint
 1678   assert(tmpReg == rax, &quot;&quot;);
 1679 
 1680   if (use_rtm) {
 1681     assert_different_registers(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg);
 1682   } else {
 1683     assert(cx1Reg == noreg, &quot;&quot;);
 1684     assert(cx2Reg == noreg, &quot;&quot;);
 1685     assert_different_registers(objReg, boxReg, tmpReg, scrReg);
 1686   }
 1687 
 1688   if (counters != NULL) {
 1689     atomic_incl(ExternalAddress((address)counters-&gt;total_entry_count_addr()), scrReg);
 1690   }
 1691 
 1692   // Possible cases that we&#39;ll encounter in fast_lock
 1693   // ------------------------------------------------
 1694   // * Inflated
 1695   //    -- unlocked
 1696   //    -- Locked
 1697   //       = by self
 1698   //       = by other
 1699   // * biased
 1700   //    -- by Self
 1701   //    -- by other
 1702   // * neutral
 1703   // * stack-locked
 1704   //    -- by self
 1705   //       = sp-proximity test hits
 1706   //       = sp-proximity test generates false-negative
 1707   //    -- by other
 1708   //
 1709 
 1710   Label IsInflated, DONE_LABEL;
 1711 
 1712   // it&#39;s stack-locked, biased or neutral
 1713   // TODO: optimize away redundant LDs of obj-&gt;mark and improve the markword triage
 1714   // order to reduce the number of conditional branches in the most common cases.
 1715   // Beware -- there&#39;s a subtle invariant that fetch of the markword
 1716   // at [FETCH], below, will never observe a biased encoding (*101b).
 1717   // If this invariant is not held we risk exclusion (safety) failure.
 1718   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
 1719     biased_locking_enter(boxReg, objReg, tmpReg, scrReg, false, DONE_LABEL, NULL, counters);
 1720   }
 1721 
 1722 #if INCLUDE_RTM_OPT
 1723   if (UseRTMForStackLocks &amp;&amp; use_rtm) {
 1724     rtm_stack_locking(objReg, tmpReg, scrReg, cx2Reg,
 1725                       stack_rtm_counters, method_data, profile_rtm,
 1726                       DONE_LABEL, IsInflated);
 1727   }
 1728 #endif // INCLUDE_RTM_OPT
 1729 
 1730   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));          // [FETCH]
 1731   testptr(tmpReg, markWord::monitor_value); // inflated vs stack-locked|neutral|biased
 1732   jccb(Assembler::notZero, IsInflated);
 1733 
 1734   // Attempt stack-locking ...
 1735   orptr (tmpReg, markWord::unlocked_value);
 1736   movptr(Address(boxReg, 0), tmpReg);          // Anticipate successful CAS
 1737   lock();
 1738   cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      // Updates tmpReg
 1739   if (counters != NULL) {
 1740     cond_inc32(Assembler::equal,
 1741                ExternalAddress((address)counters-&gt;fast_path_entry_count_addr()));
 1742   }
 1743   jcc(Assembler::equal, DONE_LABEL);           // Success
 1744 
 1745   // Recursive locking.
 1746   // The object is stack-locked: markword contains stack pointer to BasicLock.
 1747   // Locked by current thread if difference with current SP is less than one page.
 1748   subptr(tmpReg, rsp);
 1749   // Next instruction set ZFlag == 1 (Success) if difference is less then one page.
 1750   andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );
 1751   movptr(Address(boxReg, 0), tmpReg);
 1752   if (counters != NULL) {
 1753     cond_inc32(Assembler::equal,
 1754                ExternalAddress((address)counters-&gt;fast_path_entry_count_addr()));
 1755   }
 1756   jmp(DONE_LABEL);
 1757 
 1758   bind(IsInflated);
 1759   // The object is inflated. tmpReg contains pointer to ObjectMonitor* + markWord::monitor_value
 1760 
 1761 #if INCLUDE_RTM_OPT
 1762   // Use the same RTM locking code in 32- and 64-bit VM.
 1763   if (use_rtm) {
 1764     rtm_inflated_locking(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg,
 1765                          rtm_counters, method_data, profile_rtm, DONE_LABEL);
 1766   } else {
 1767 #endif // INCLUDE_RTM_OPT
 1768 
 1769 #ifndef _LP64
 1770   // The object is inflated.
 1771 
 1772   // boxReg refers to the on-stack BasicLock in the current frame.
 1773   // We&#39;d like to write:
 1774   //   set box-&gt;_displaced_header = markWord::unused_mark().  Any non-0 value suffices.
 1775   // This is convenient but results a ST-before-CAS penalty.  The following CAS suffers
 1776   // additional latency as we have another ST in the store buffer that must drain.
 1777 
 1778   // avoid ST-before-CAS
 1779   // register juggle because we need tmpReg for cmpxchgptr below
 1780   movptr(scrReg, boxReg);
 1781   movptr(boxReg, tmpReg);                   // consider: LEA box, [tmp-2]
 1782 
 1783   // Optimistic form: consider XORL tmpReg,tmpReg
 1784   movptr(tmpReg, NULL_WORD);
 1785 
 1786   // Appears unlocked - try to swing _owner from null to non-null.
 1787   // Ideally, I&#39;d manifest &quot;Self&quot; with get_thread and then attempt
 1788   // to CAS the register containing Self into m-&gt;Owner.
 1789   // But we don&#39;t have enough registers, so instead we can either try to CAS
 1790   // rsp or the address of the box (in scr) into &amp;m-&gt;owner.  If the CAS succeeds
 1791   // we later store &quot;Self&quot; into m-&gt;Owner.  Transiently storing a stack address
 1792   // (rsp or the address of the box) into  m-&gt;owner is harmless.
 1793   // Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.
 1794   lock();
 1795   cmpxchgptr(scrReg, Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
 1796   movptr(Address(scrReg, 0), 3);          // box-&gt;_displaced_header = 3
 1797   // If we weren&#39;t able to swing _owner from NULL to the BasicLock
 1798   // then take the slow path.
 1799   jccb  (Assembler::notZero, DONE_LABEL);
 1800   // update _owner from BasicLock to thread
 1801   get_thread (scrReg);                    // beware: clobbers ICCs
 1802   movptr(Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), scrReg);
 1803   xorptr(boxReg, boxReg);                 // set icc.ZFlag = 1 to indicate success
 1804 
 1805   // If the CAS fails we can either retry or pass control to the slow path.
 1806   // We use the latter tactic.
 1807   // Pass the CAS result in the icc.ZFlag into DONE_LABEL
 1808   // If the CAS was successful ...
 1809   //   Self has acquired the lock
 1810   //   Invariant: m-&gt;_recursions should already be 0, so we don&#39;t need to explicitly set it.
 1811   // Intentional fall-through into DONE_LABEL ...
 1812 #else // _LP64
 1813   // It&#39;s inflated and we use scrReg for ObjectMonitor* in this section.
 1814   movq(scrReg, tmpReg);
 1815   xorq(tmpReg, tmpReg);
 1816   lock();
 1817   cmpxchgptr(r15_thread, Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
 1818   // Unconditionally set box-&gt;_displaced_header = markWord::unused_mark().
 1819   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.
 1820   movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));
 1821   // Intentional fall-through into DONE_LABEL ...
 1822   // Propagate ICC.ZF from CAS above into DONE_LABEL.
 1823 #endif // _LP64
 1824 #if INCLUDE_RTM_OPT
 1825   } // use_rtm()
 1826 #endif
 1827   // DONE_LABEL is a hot target - we&#39;d really like to place it at the
 1828   // start of cache line by padding with NOPs.
 1829   // See the AMD and Intel software optimization manuals for the
 1830   // most efficient &quot;long&quot; NOP encodings.
 1831   // Unfortunately none of our alignment mechanisms suffice.
 1832   bind(DONE_LABEL);
 1833 
 1834   // At DONE_LABEL the icc ZFlag is set as follows ...
 1835   // fast_unlock uses the same protocol.
 1836   // ZFlag == 1 -&gt; Success
 1837   // ZFlag == 0 -&gt; Failure - force control through the slow path
 1838 }
 1839 
 1840 // obj: object to unlock
 1841 // box: box address (displaced header location), killed.  Must be EAX.
 1842 // tmp: killed, cannot be obj nor box.
 1843 //
 1844 // Some commentary on balanced locking:
 1845 //
 1846 // fast_lock and fast_unlock are emitted only for provably balanced lock sites.
 1847 // Methods that don&#39;t have provably balanced locking are forced to run in the
 1848 // interpreter - such methods won&#39;t be compiled to use fast_lock and fast_unlock.
 1849 // The interpreter provides two properties:
 1850 // I1:  At return-time the interpreter automatically and quietly unlocks any
 1851 //      objects acquired the current activation (frame).  Recall that the
 1852 //      interpreter maintains an on-stack list of locks currently held by
 1853 //      a frame.
 1854 // I2:  If a method attempts to unlock an object that is not held by the
 1855 //      the frame the interpreter throws IMSX.
 1856 //
 1857 // Lets say A(), which has provably balanced locking, acquires O and then calls B().
 1858 // B() doesn&#39;t have provably balanced locking so it runs in the interpreter.
 1859 // Control returns to A() and A() unlocks O.  By I1 and I2, above, we know that O
 1860 // is still locked by A().
 1861 //
 1862 // The only other source of unbalanced locking would be JNI.  The &quot;Java Native Interface:
 1863 // Programmer&#39;s Guide and Specification&quot; claims that an object locked by jni_monitorenter
 1864 // should not be unlocked by &quot;normal&quot; java-level locking and vice-versa.  The specification
 1865 // doesn&#39;t specify what will occur if a program engages in such mixed-mode locking, however.
 1866 // Arguably given that the spec legislates the JNI case as undefined our implementation
 1867 // could reasonably *avoid* checking owner in fast_unlock().
 1868 // In the interest of performance we elide m-&gt;Owner==Self check in unlock.
 1869 // A perfectly viable alternative is to elide the owner check except when
 1870 // Xcheck:jni is enabled.
 1871 
 1872 void MacroAssembler::fast_unlock(Register objReg, Register boxReg, Register tmpReg, bool use_rtm) {
 1873   assert(boxReg == rax, &quot;&quot;);
 1874   assert_different_registers(objReg, boxReg, tmpReg);
 1875 
 1876   Label DONE_LABEL, Stacked, CheckSucc;
 1877 
 1878   // Critically, the biased locking test must have precedence over
 1879   // and appear before the (box-&gt;dhw == 0) recursive stack-lock test.
 1880   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
 1881     biased_locking_exit(objReg, tmpReg, DONE_LABEL);
 1882   }
 1883 
 1884 #if INCLUDE_RTM_OPT
 1885   if (UseRTMForStackLocks &amp;&amp; use_rtm) {
 1886     assert(!UseBiasedLocking, &quot;Biased locking is not supported with RTM locking&quot;);
 1887     Label L_regular_unlock;
 1888     movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // fetch markword
 1889     andptr(tmpReg, markWord::biased_lock_mask_in_place);              // look at 3 lock bits
 1890     cmpptr(tmpReg, markWord::unlocked_value);                         // bits = 001 unlocked
 1891     jccb(Assembler::notEqual, L_regular_unlock);                      // if !HLE RegularLock
 1892     xend();                                                           // otherwise end...
 1893     jmp(DONE_LABEL);                                                  // ... and we&#39;re done
 1894     bind(L_regular_unlock);
 1895   }
 1896 #endif
 1897 
 1898   cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   // Examine the displaced header
 1899   jcc   (Assembler::zero, DONE_LABEL);                              // 0 indicates recursive stack-lock
 1900   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Examine the object&#39;s markword
 1901   testptr(tmpReg, markWord::monitor_value);                         // Inflated?
 1902   jccb  (Assembler::zero, Stacked);
 1903 
 1904   // It&#39;s inflated.
 1905 #if INCLUDE_RTM_OPT
 1906   if (use_rtm) {
 1907     Label L_regular_inflated_unlock;
 1908     int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);
 1909     movptr(boxReg, Address(tmpReg, owner_offset));
 1910     testptr(boxReg, boxReg);
 1911     jccb(Assembler::notZero, L_regular_inflated_unlock);
 1912     xend();
 1913     jmpb(DONE_LABEL);
 1914     bind(L_regular_inflated_unlock);
 1915   }
 1916 #endif
 1917 
 1918   // Despite our balanced locking property we still check that m-&gt;_owner == Self
 1919   // as java routines or native JNI code called by this thread might
 1920   // have released the lock.
 1921   // Refer to the comments in synchronizer.cpp for how we might encode extra
 1922   // state in _succ so we can avoid fetching EntryList|cxq.
 1923   //
 1924   // I&#39;d like to add more cases in fast_lock() and fast_unlock() --
 1925   // such as recursive enter and exit -- but we have to be wary of
 1926   // I$ bloat, T$ effects and BP$ effects.
 1927   //
 1928   // If there&#39;s no contention try a 1-0 exit.  That is, exit without
 1929   // a costly MEMBAR or CAS.  See synchronizer.cpp for details on how
 1930   // we detect and recover from the race that the 1-0 exit admits.
 1931   //
 1932   // Conceptually fast_unlock() must execute a STST|LDST &quot;release&quot; barrier
 1933   // before it STs null into _owner, releasing the lock.  Updates
 1934   // to data protected by the critical section must be visible before
 1935   // we drop the lock (and thus before any other thread could acquire
 1936   // the lock and observe the fields protected by the lock).
 1937   // IA32&#39;s memory-model is SPO, so STs are ordered with respect to
 1938   // each other and there&#39;s no need for an explicit barrier (fence).
 1939   // See also http://gee.cs.oswego.edu/dl/jmm/cookbook.html.
 1940 #ifndef _LP64
 1941   get_thread (boxReg);
 1942 
 1943   // Note that we could employ various encoding schemes to reduce
 1944   // the number of loads below (currently 4) to just 2 or 3.
 1945   // Refer to the comments in synchronizer.cpp.
 1946   // In practice the chain of fetches doesn&#39;t seem to impact performance, however.
 1947   xorptr(boxReg, boxReg);
 1948   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));
 1949   jccb  (Assembler::notZero, DONE_LABEL);
 1950   movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));
 1951   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));
 1952   jccb  (Assembler::notZero, CheckSucc);
 1953   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);
 1954   jmpb  (DONE_LABEL);
 1955 
 1956   bind (Stacked);
 1957   // It&#39;s not inflated and it&#39;s not recursively stack-locked and it&#39;s not biased.
 1958   // It must be stack-locked.
 1959   // Try to reset the header to displaced header.
 1960   // The &quot;box&quot; value on the stack is stable, so we can reload
 1961   // and be assured we observe the same value as above.
 1962   movptr(tmpReg, Address(boxReg, 0));
 1963   lock();
 1964   cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Uses RAX which is box
 1965   // Intention fall-thru into DONE_LABEL
 1966 
 1967   // DONE_LABEL is a hot target - we&#39;d really like to place it at the
 1968   // start of cache line by padding with NOPs.
 1969   // See the AMD and Intel software optimization manuals for the
 1970   // most efficient &quot;long&quot; NOP encodings.
 1971   // Unfortunately none of our alignment mechanisms suffice.
 1972   bind (CheckSucc);
 1973 #else // _LP64
 1974   // It&#39;s inflated
 1975   xorptr(boxReg, boxReg);
 1976   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));
 1977   jccb  (Assembler::notZero, DONE_LABEL);
 1978   movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));
 1979   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));
 1980   jccb  (Assembler::notZero, CheckSucc);
 1981   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.
 1982   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);
 1983   jmpb  (DONE_LABEL);
 1984 
 1985   // Try to avoid passing control into the slow_path ...
 1986   Label LSuccess, LGoSlowPath ;
 1987   bind  (CheckSucc);
 1988 
 1989   // The following optional optimization can be elided if necessary
 1990   // Effectively: if (succ == null) goto slow path
 1991   // The code reduces the window for a race, however,
 1992   // and thus benefits performance.
 1993   cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);
 1994   jccb  (Assembler::zero, LGoSlowPath);
 1995 
 1996   xorptr(boxReg, boxReg);
 1997   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.
 1998   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);
 1999 
 2000   // Memory barrier/fence
 2001   // Dekker pivot point -- fulcrum : ST Owner; MEMBAR; LD Succ
 2002   // Instead of MFENCE we use a dummy locked add of 0 to the top-of-stack.
 2003   // This is faster on Nehalem and AMD Shanghai/Barcelona.
 2004   // See https://blogs.oracle.com/dave/entry/instruction_selection_for_volatile_fences
 2005   // We might also restructure (ST Owner=0;barrier;LD _Succ) to
 2006   // (mov box,0; xchgq box, &amp;m-&gt;Owner; LD _succ) .
 2007   lock(); addl(Address(rsp, 0), 0);
 2008 
 2009   cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);
 2010   jccb  (Assembler::notZero, LSuccess);
 2011 
 2012   // Rare inopportune interleaving - race.
 2013   // The successor vanished in the small window above.
 2014   // The lock is contended -- (cxq|EntryList) != null -- and there&#39;s no apparent successor.
 2015   // We need to ensure progress and succession.
 2016   // Try to reacquire the lock.
 2017   // If that fails then the new owner is responsible for succession and this
 2018   // thread needs to take no further action and can exit via the fast path (success).
 2019   // If the re-acquire succeeds then pass control into the slow path.
 2020   // As implemented, this latter mode is horrible because we generated more
 2021   // coherence traffic on the lock *and* artifically extended the critical section
 2022   // length while by virtue of passing control into the slow path.
 2023 
 2024   // box is really RAX -- the following CMPXCHG depends on that binding
 2025   // cmpxchg R,[M] is equivalent to rax = CAS(M,rax,R)
 2026   lock();
 2027   cmpxchgptr(r15_thread, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
 2028   // There&#39;s no successor so we tried to regrab the lock.
 2029   // If that didn&#39;t work, then another thread grabbed the
 2030   // lock so we&#39;re done (and exit was a success).
 2031   jccb  (Assembler::notEqual, LSuccess);
 2032   // Intentional fall-through into slow path
 2033 
 2034   bind  (LGoSlowPath);
 2035   orl   (boxReg, 1);                      // set ICC.ZF=0 to indicate failure
 2036   jmpb  (DONE_LABEL);
 2037 
 2038   bind  (LSuccess);
 2039   testl (boxReg, 0);                      // set ICC.ZF=1 to indicate success
 2040   jmpb  (DONE_LABEL);
 2041 
 2042   bind  (Stacked);
 2043   movptr(tmpReg, Address (boxReg, 0));      // re-fetch
 2044   lock();
 2045   cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Uses RAX which is box
 2046 
 2047 #endif
 2048   bind(DONE_LABEL);
 2049 }
 2050 #endif // COMPILER2
 2051 
 2052 void MacroAssembler::c2bool(Register x) {
 2053   // implements x == 0 ? 0 : 1
 2054   // note: must only look at least-significant byte of x
 2055   //       since C-style booleans are stored in one byte
 2056   //       only! (was bug)
 2057   andl(x, 0xFF);
 2058   setb(Assembler::notZero, x);
 2059 }
 2060 
 2061 // Wouldn&#39;t need if AddressLiteral version had new name
 2062 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
 2063   Assembler::call(L, rtype);
 2064 }
 2065 
 2066 void MacroAssembler::call(Register entry) {
 2067   Assembler::call(entry);
 2068 }
 2069 
 2070 void MacroAssembler::call(AddressLiteral entry) {
 2071   if (reachable(entry)) {
 2072     Assembler::call_literal(entry.target(), entry.rspec());
 2073   } else {
 2074     lea(rscratch1, entry);
 2075     Assembler::call(rscratch1);
 2076   }
 2077 }
 2078 
 2079 void MacroAssembler::ic_call(address entry, jint method_index) {
 2080   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
 2081   movptr(rax, (intptr_t)Universe::non_oop_word());
 2082   call(AddressLiteral(entry, rh));
 2083 }
 2084 
 2085 // Implementation of call_VM versions
 2086 
 2087 void MacroAssembler::call_VM(Register oop_result,
 2088                              address entry_point,
 2089                              bool check_exceptions) {
 2090   Label C, E;
 2091   call(C, relocInfo::none);
 2092   jmp(E);
 2093 
 2094   bind(C);
 2095   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
 2096   ret(0);
 2097 
 2098   bind(E);
 2099 }
 2100 
 2101 void MacroAssembler::call_VM(Register oop_result,
 2102                              address entry_point,
 2103                              Register arg_1,
 2104                              bool check_exceptions) {
 2105   Label C, E;
 2106   call(C, relocInfo::none);
 2107   jmp(E);
 2108 
 2109   bind(C);
 2110   pass_arg1(this, arg_1);
 2111   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
 2112   ret(0);
 2113 
 2114   bind(E);
 2115 }
 2116 
 2117 void MacroAssembler::call_VM(Register oop_result,
 2118                              address entry_point,
 2119                              Register arg_1,
 2120                              Register arg_2,
 2121                              bool check_exceptions) {
 2122   Label C, E;
 2123   call(C, relocInfo::none);
 2124   jmp(E);
 2125 
 2126   bind(C);
 2127 
 2128   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2129 
 2130   pass_arg2(this, arg_2);
 2131   pass_arg1(this, arg_1);
 2132   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
 2133   ret(0);
 2134 
 2135   bind(E);
 2136 }
 2137 
 2138 void MacroAssembler::call_VM(Register oop_result,
 2139                              address entry_point,
 2140                              Register arg_1,
 2141                              Register arg_2,
 2142                              Register arg_3,
 2143                              bool check_exceptions) {
 2144   Label C, E;
 2145   call(C, relocInfo::none);
 2146   jmp(E);
 2147 
 2148   bind(C);
 2149 
 2150   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
 2151   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
 2152   pass_arg3(this, arg_3);
 2153 
 2154   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2155   pass_arg2(this, arg_2);
 2156 
 2157   pass_arg1(this, arg_1);
 2158   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
 2159   ret(0);
 2160 
 2161   bind(E);
 2162 }
 2163 
 2164 void MacroAssembler::call_VM(Register oop_result,
 2165                              Register last_java_sp,
 2166                              address entry_point,
 2167                              int number_of_arguments,
 2168                              bool check_exceptions) {
 2169   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
 2170   call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 2171 }
 2172 
 2173 void MacroAssembler::call_VM(Register oop_result,
 2174                              Register last_java_sp,
 2175                              address entry_point,
 2176                              Register arg_1,
 2177                              bool check_exceptions) {
 2178   pass_arg1(this, arg_1);
 2179   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 2180 }
 2181 
 2182 void MacroAssembler::call_VM(Register oop_result,
 2183                              Register last_java_sp,
 2184                              address entry_point,
 2185                              Register arg_1,
 2186                              Register arg_2,
 2187                              bool check_exceptions) {
 2188 
 2189   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2190   pass_arg2(this, arg_2);
 2191   pass_arg1(this, arg_1);
 2192   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 2193 }
 2194 
 2195 void MacroAssembler::call_VM(Register oop_result,
 2196                              Register last_java_sp,
 2197                              address entry_point,
 2198                              Register arg_1,
 2199                              Register arg_2,
 2200                              Register arg_3,
 2201                              bool check_exceptions) {
 2202   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
 2203   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
 2204   pass_arg3(this, arg_3);
 2205   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2206   pass_arg2(this, arg_2);
 2207   pass_arg1(this, arg_1);
 2208   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 2209 }
 2210 
 2211 void MacroAssembler::super_call_VM(Register oop_result,
 2212                                    Register last_java_sp,
 2213                                    address entry_point,
 2214                                    int number_of_arguments,
 2215                                    bool check_exceptions) {
 2216   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
 2217   MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 2218 }
 2219 
 2220 void MacroAssembler::super_call_VM(Register oop_result,
 2221                                    Register last_java_sp,
 2222                                    address entry_point,
 2223                                    Register arg_1,
 2224                                    bool check_exceptions) {
 2225   pass_arg1(this, arg_1);
 2226   super_call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 2227 }
 2228 
 2229 void MacroAssembler::super_call_VM(Register oop_result,
 2230                                    Register last_java_sp,
 2231                                    address entry_point,
 2232                                    Register arg_1,
 2233                                    Register arg_2,
 2234                                    bool check_exceptions) {
 2235 
 2236   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2237   pass_arg2(this, arg_2);
 2238   pass_arg1(this, arg_1);
 2239   super_call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 2240 }
 2241 
 2242 void MacroAssembler::super_call_VM(Register oop_result,
 2243                                    Register last_java_sp,
 2244                                    address entry_point,
 2245                                    Register arg_1,
 2246                                    Register arg_2,
 2247                                    Register arg_3,
 2248                                    bool check_exceptions) {
 2249   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
 2250   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
 2251   pass_arg3(this, arg_3);
 2252   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2253   pass_arg2(this, arg_2);
 2254   pass_arg1(this, arg_1);
 2255   super_call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 2256 }
 2257 
 2258 void MacroAssembler::call_VM_base(Register oop_result,
 2259                                   Register java_thread,
 2260                                   Register last_java_sp,
 2261                                   address  entry_point,
 2262                                   int      number_of_arguments,
 2263                                   bool     check_exceptions) {
 2264   // determine java_thread register
 2265   if (!java_thread-&gt;is_valid()) {
 2266 #ifdef _LP64
 2267     java_thread = r15_thread;
 2268 #else
 2269     java_thread = rdi;
 2270     get_thread(java_thread);
 2271 #endif // LP64
 2272   }
 2273   // determine last_java_sp register
 2274   if (!last_java_sp-&gt;is_valid()) {
 2275     last_java_sp = rsp;
 2276   }
 2277   // debugging support
 2278   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 2279   LP64_ONLY(assert(java_thread == r15_thread, &quot;unexpected register&quot;));
 2280 #ifdef ASSERT
 2281   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
 2282   // r12 is the heapbase.
 2283   LP64_ONLY(if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);)
 2284 #endif // ASSERT
 2285 
 2286   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
 2287   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
 2288 
 2289   // push java thread (becomes first argument of C function)
 2290 
 2291   NOT_LP64(push(java_thread); number_of_arguments++);
 2292   LP64_ONLY(mov(c_rarg0, r15_thread));
 2293 
 2294   // set last Java frame before call
 2295   assert(last_java_sp != rbp, &quot;can&#39;t use ebp/rbp&quot;);
 2296 
 2297   // Only interpreter should have to set fp
 2298   set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);
 2299 
 2300   // do the call, remove parameters
 2301   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments);
 2302 
 2303   // restore the thread (cannot use the pushed argument since arguments
 2304   // may be overwritten by C code generated by an optimizing compiler);
 2305   // however can use the register value directly if it is callee saved.
 2306   if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {
 2307     // rdi &amp; rsi (also r15) are callee saved -&gt; nothing to do
 2308 #ifdef ASSERT
 2309     guarantee(java_thread != rax, &quot;change this code&quot;);
 2310     push(rax);
 2311     { Label L;
 2312       get_thread(rax);
 2313       cmpptr(java_thread, rax);
 2314       jcc(Assembler::equal, L);
 2315       STOP(&quot;MacroAssembler::call_VM_base: rdi not callee saved?&quot;);
 2316       bind(L);
 2317     }
 2318     pop(rax);
 2319 #endif
 2320   } else {
 2321     get_thread(java_thread);
 2322   }
 2323   // reset last Java frame
 2324   // Only interpreter should have to clear fp
 2325   reset_last_Java_frame(java_thread, true);
 2326 
 2327    // C++ interp handles this in the interpreter
 2328   check_and_handle_popframe(java_thread);
 2329   check_and_handle_earlyret(java_thread);
 2330 
 2331   if (check_exceptions) {
 2332     // check for pending exceptions (java_thread is set upon return)
 2333     cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
 2334 #ifndef _LP64
 2335     jump_cc(Assembler::notEqual,
 2336             RuntimeAddress(StubRoutines::forward_exception_entry()));
 2337 #else
 2338     // This used to conditionally jump to forward_exception however it is
 2339     // possible if we relocate that the branch will not reach. So we must jump
 2340     // around so we can always reach
 2341 
 2342     Label ok;
 2343     jcc(Assembler::equal, ok);
 2344     jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
 2345     bind(ok);
 2346 #endif // LP64
 2347   }
 2348 
 2349   // get oop result if there is one and reset the value in the thread
 2350   if (oop_result-&gt;is_valid()) {
 2351     get_vm_result(oop_result, java_thread);
 2352   }
 2353 }
 2354 
 2355 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
 2356 
 2357   // Calculate the value for last_Java_sp
 2358   // somewhat subtle. call_VM does an intermediate call
 2359   // which places a return address on the stack just under the
 2360   // stack pointer as the user finsihed with it. This allows
 2361   // use to retrieve last_Java_pc from last_Java_sp[-1].
 2362   // On 32bit we then have to push additional args on the stack to accomplish
 2363   // the actual requested call. On 64bit call_VM only can use register args
 2364   // so the only extra space is the return address that call_VM created.
 2365   // This hopefully explains the calculations here.
 2366 
 2367 #ifdef _LP64
 2368   // We&#39;ve pushed one address, correct last_Java_sp
 2369   lea(rax, Address(rsp, wordSize));
 2370 #else
 2371   lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));
 2372 #endif // LP64
 2373 
 2374   call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);
 2375 
 2376 }
 2377 
 2378 // Use this method when MacroAssembler version of call_VM_leaf_base() should be called from Interpreter.
 2379 void MacroAssembler::call_VM_leaf0(address entry_point) {
 2380   MacroAssembler::call_VM_leaf_base(entry_point, 0);
 2381 }
 2382 
 2383 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
 2384   call_VM_leaf_base(entry_point, number_of_arguments);
 2385 }
 2386 
 2387 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
 2388   pass_arg0(this, arg_0);
 2389   call_VM_leaf(entry_point, 1);
 2390 }
 2391 
 2392 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
 2393 
 2394   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
 2395   pass_arg1(this, arg_1);
 2396   pass_arg0(this, arg_0);
 2397   call_VM_leaf(entry_point, 2);
 2398 }
 2399 
 2400 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
 2401   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
 2402   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2403   pass_arg2(this, arg_2);
 2404   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
 2405   pass_arg1(this, arg_1);
 2406   pass_arg0(this, arg_0);
 2407   call_VM_leaf(entry_point, 3);
 2408 }
 2409 
 2410 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
 2411   pass_arg0(this, arg_0);
 2412   MacroAssembler::call_VM_leaf_base(entry_point, 1);
 2413 }
 2414 
 2415 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
 2416 
 2417   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
 2418   pass_arg1(this, arg_1);
 2419   pass_arg0(this, arg_0);
 2420   MacroAssembler::call_VM_leaf_base(entry_point, 2);
 2421 }
 2422 
 2423 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
 2424   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
 2425   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2426   pass_arg2(this, arg_2);
 2427   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
 2428   pass_arg1(this, arg_1);
 2429   pass_arg0(this, arg_0);
 2430   MacroAssembler::call_VM_leaf_base(entry_point, 3);
 2431 }
 2432 
 2433 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
 2434   LP64_ONLY(assert(arg_0 != c_rarg3, &quot;smashed arg&quot;));
 2435   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
 2436   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
 2437   pass_arg3(this, arg_3);
 2438   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
 2439   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2440   pass_arg2(this, arg_2);
 2441   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
 2442   pass_arg1(this, arg_1);
 2443   pass_arg0(this, arg_0);
 2444   MacroAssembler::call_VM_leaf_base(entry_point, 4);
 2445 }
 2446 
 2447 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
 2448   movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
 2449   movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);
 2450   verify_oop_msg(oop_result, &quot;broken oop in call_VM_base&quot;);
 2451 }
 2452 
 2453 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
 2454   movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
 2455   movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);
 2456 }
 2457 
 2458 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
 2459 }
 2460 
 2461 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
 2462 }
 2463 
 2464 void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {
 2465   if (reachable(src1)) {
 2466     cmpl(as_Address(src1), imm);
 2467   } else {
 2468     lea(rscratch1, src1);
 2469     cmpl(Address(rscratch1, 0), imm);
 2470   }
 2471 }
 2472 
 2473 void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {
 2474   assert(!src2.is_lval(), &quot;use cmpptr&quot;);
 2475   if (reachable(src2)) {
 2476     cmpl(src1, as_Address(src2));
 2477   } else {
 2478     lea(rscratch1, src2);
 2479     cmpl(src1, Address(rscratch1, 0));
 2480   }
 2481 }
 2482 
 2483 void MacroAssembler::cmp32(Register src1, int32_t imm) {
 2484   Assembler::cmpl(src1, imm);
 2485 }
 2486 
 2487 void MacroAssembler::cmp32(Register src1, Address src2) {
 2488   Assembler::cmpl(src1, src2);
 2489 }
 2490 
 2491 void MacroAssembler::cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
 2492   ucomisd(opr1, opr2);
 2493 
 2494   Label L;
 2495   if (unordered_is_less) {
 2496     movl(dst, -1);
 2497     jcc(Assembler::parity, L);
 2498     jcc(Assembler::below , L);
 2499     movl(dst, 0);
 2500     jcc(Assembler::equal , L);
 2501     increment(dst);
 2502   } else { // unordered is greater
 2503     movl(dst, 1);
 2504     jcc(Assembler::parity, L);
 2505     jcc(Assembler::above , L);
 2506     movl(dst, 0);
 2507     jcc(Assembler::equal , L);
 2508     decrementl(dst);
 2509   }
 2510   bind(L);
 2511 }
 2512 
 2513 void MacroAssembler::cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
 2514   ucomiss(opr1, opr2);
 2515 
 2516   Label L;
 2517   if (unordered_is_less) {
 2518     movl(dst, -1);
 2519     jcc(Assembler::parity, L);
 2520     jcc(Assembler::below , L);
 2521     movl(dst, 0);
 2522     jcc(Assembler::equal , L);
 2523     increment(dst);
 2524   } else { // unordered is greater
 2525     movl(dst, 1);
 2526     jcc(Assembler::parity, L);
 2527     jcc(Assembler::above , L);
 2528     movl(dst, 0);
 2529     jcc(Assembler::equal , L);
 2530     decrementl(dst);
 2531   }
 2532   bind(L);
 2533 }
 2534 
 2535 
 2536 void MacroAssembler::cmp8(AddressLiteral src1, int imm) {
 2537   if (reachable(src1)) {
 2538     cmpb(as_Address(src1), imm);
 2539   } else {
 2540     lea(rscratch1, src1);
 2541     cmpb(Address(rscratch1, 0), imm);
 2542   }
 2543 }
 2544 
 2545 void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {
 2546 #ifdef _LP64
 2547   if (src2.is_lval()) {
 2548     movptr(rscratch1, src2);
 2549     Assembler::cmpq(src1, rscratch1);
 2550   } else if (reachable(src2)) {
 2551     cmpq(src1, as_Address(src2));
 2552   } else {
 2553     lea(rscratch1, src2);
 2554     Assembler::cmpq(src1, Address(rscratch1, 0));
 2555   }
 2556 #else
 2557   if (src2.is_lval()) {
 2558     cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
 2559   } else {
 2560     cmpl(src1, as_Address(src2));
 2561   }
 2562 #endif // _LP64
 2563 }
 2564 
 2565 void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {
 2566   assert(src2.is_lval(), &quot;not a mem-mem compare&quot;);
 2567 #ifdef _LP64
 2568   // moves src2&#39;s literal address
 2569   movptr(rscratch1, src2);
 2570   Assembler::cmpq(src1, rscratch1);
 2571 #else
 2572   cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
 2573 #endif // _LP64
 2574 }
 2575 
 2576 void MacroAssembler::cmpoop(Register src1, Register src2) {
 2577   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 2578   bs-&gt;obj_equals(this, src1, src2);
 2579 }
 2580 
 2581 void MacroAssembler::cmpoop(Register src1, Address src2) {
 2582   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 2583   bs-&gt;obj_equals(this, src1, src2);
 2584 }
 2585 
 2586 #ifdef _LP64
 2587 void MacroAssembler::cmpoop(Register src1, jobject src2) {
 2588   movoop(rscratch1, src2);
 2589   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 2590   bs-&gt;obj_equals(this, src1, rscratch1);
 2591 }
 2592 #endif
 2593 
 2594 void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {
 2595   if (reachable(adr)) {
 2596     lock();
 2597     cmpxchgptr(reg, as_Address(adr));
 2598   } else {
 2599     lea(rscratch1, adr);
 2600     lock();
 2601     cmpxchgptr(reg, Address(rscratch1, 0));
 2602   }
 2603 }
 2604 
 2605 void MacroAssembler::cmpxchgptr(Register reg, Address adr) {
 2606   LP64_ONLY(cmpxchgq(reg, adr)) NOT_LP64(cmpxchgl(reg, adr));
 2607 }
 2608 
 2609 void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {
 2610   if (reachable(src)) {
 2611     Assembler::comisd(dst, as_Address(src));
 2612   } else {
 2613     lea(rscratch1, src);
 2614     Assembler::comisd(dst, Address(rscratch1, 0));
 2615   }
 2616 }
 2617 
 2618 void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {
 2619   if (reachable(src)) {
 2620     Assembler::comiss(dst, as_Address(src));
 2621   } else {
 2622     lea(rscratch1, src);
 2623     Assembler::comiss(dst, Address(rscratch1, 0));
 2624   }
 2625 }
 2626 
 2627 
 2628 void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {
 2629   Condition negated_cond = negate_condition(cond);
 2630   Label L;
 2631   jcc(negated_cond, L);
 2632   pushf(); // Preserve flags
 2633   atomic_incl(counter_addr);
 2634   popf();
 2635   bind(L);
 2636 }
 2637 
 2638 int MacroAssembler::corrected_idivl(Register reg) {
 2639   // Full implementation of Java idiv and irem; checks for
 2640   // special case as described in JVM spec., p.243 &amp; p.271.
 2641   // The function returns the (pc) offset of the idivl
 2642   // instruction - may be needed for implicit exceptions.
 2643   //
 2644   //         normal case                           special case
 2645   //
 2646   // input : rax,: dividend                         min_int
 2647   //         reg: divisor   (may not be rax,/rdx)   -1
 2648   //
 2649   // output: rax,: quotient  (= rax, idiv reg)       min_int
 2650   //         rdx: remainder (= rax, irem reg)       0
 2651   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax, or rdx register&quot;);
 2652   const int min_int = 0x80000000;
 2653   Label normal_case, special_case;
 2654 
 2655   // check for special case
 2656   cmpl(rax, min_int);
 2657   jcc(Assembler::notEqual, normal_case);
 2658   xorl(rdx, rdx); // prepare rdx for possible special case (where remainder = 0)
 2659   cmpl(reg, -1);
 2660   jcc(Assembler::equal, special_case);
 2661 
 2662   // handle normal case
 2663   bind(normal_case);
 2664   cdql();
 2665   int idivl_offset = offset();
 2666   idivl(reg);
 2667 
 2668   // normal and special case exit
 2669   bind(special_case);
 2670 
 2671   return idivl_offset;
 2672 }
 2673 
 2674 
 2675 
 2676 void MacroAssembler::decrementl(Register reg, int value) {
 2677   if (value == min_jint) {subl(reg, value) ; return; }
 2678   if (value &lt;  0) { incrementl(reg, -value); return; }
 2679   if (value == 0) {                        ; return; }
 2680   if (value == 1 &amp;&amp; UseIncDec) { decl(reg) ; return; }
 2681   /* else */      { subl(reg, value)       ; return; }
 2682 }
 2683 
 2684 void MacroAssembler::decrementl(Address dst, int value) {
 2685   if (value == min_jint) {subl(dst, value) ; return; }
 2686   if (value &lt;  0) { incrementl(dst, -value); return; }
 2687   if (value == 0) {                        ; return; }
 2688   if (value == 1 &amp;&amp; UseIncDec) { decl(dst) ; return; }
 2689   /* else */      { subl(dst, value)       ; return; }
 2690 }
 2691 
 2692 void MacroAssembler::division_with_shift (Register reg, int shift_value) {
 2693   assert (shift_value &gt; 0, &quot;illegal shift value&quot;);
 2694   Label _is_positive;
 2695   testl (reg, reg);
 2696   jcc (Assembler::positive, _is_positive);
 2697   int offset = (1 &lt;&lt; shift_value) - 1 ;
 2698 
 2699   if (offset == 1) {
 2700     incrementl(reg);
 2701   } else {
 2702     addl(reg, offset);
 2703   }
 2704 
 2705   bind (_is_positive);
 2706   sarl(reg, shift_value);
 2707 }
 2708 
 2709 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
 2710   if (reachable(src)) {
 2711     Assembler::divsd(dst, as_Address(src));
 2712   } else {
 2713     lea(rscratch1, src);
 2714     Assembler::divsd(dst, Address(rscratch1, 0));
 2715   }
 2716 }
 2717 
 2718 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
 2719   if (reachable(src)) {
 2720     Assembler::divss(dst, as_Address(src));
 2721   } else {
 2722     lea(rscratch1, src);
 2723     Assembler::divss(dst, Address(rscratch1, 0));
 2724   }
 2725 }
 2726 
 2727 void MacroAssembler::enter() {
 2728   push(rbp);
 2729   mov(rbp, rsp);
 2730 }
 2731 
 2732 // A 5 byte nop that is safe for patching (see patch_verified_entry)
 2733 void MacroAssembler::fat_nop() {
 2734   if (UseAddressNop) {
 2735     addr_nop_5();
 2736   } else {
 2737     emit_int8(0x26); // es:
 2738     emit_int8(0x2e); // cs:
 2739     emit_int8(0x64); // fs:
 2740     emit_int8(0x65); // gs:
 2741     emit_int8((unsigned char)0x90);
 2742   }
 2743 }
 2744 
 2745 #ifndef _LP64
 2746 void MacroAssembler::fcmp(Register tmp) {
 2747   fcmp(tmp, 1, true, true);
 2748 }
 2749 
 2750 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
 2751   assert(!pop_right || pop_left, &quot;usage error&quot;);
 2752   if (VM_Version::supports_cmov()) {
 2753     assert(tmp == noreg, &quot;unneeded temp&quot;);
 2754     if (pop_left) {
 2755       fucomip(index);
 2756     } else {
 2757       fucomi(index);
 2758     }
 2759     if (pop_right) {
 2760       fpop();
 2761     }
 2762   } else {
 2763     assert(tmp != noreg, &quot;need temp&quot;);
 2764     if (pop_left) {
 2765       if (pop_right) {
 2766         fcompp();
 2767       } else {
 2768         fcomp(index);
 2769       }
 2770     } else {
 2771       fcom(index);
 2772     }
 2773     // convert FPU condition into eflags condition via rax,
 2774     save_rax(tmp);
 2775     fwait(); fnstsw_ax();
 2776     sahf();
 2777     restore_rax(tmp);
 2778   }
 2779   // condition codes set as follows:
 2780   //
 2781   // CF (corresponds to C0) if x &lt; y
 2782   // PF (corresponds to C2) if unordered
 2783   // ZF (corresponds to C3) if x = y
 2784 }
 2785 
 2786 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {
 2787   fcmp2int(dst, unordered_is_less, 1, true, true);
 2788 }
 2789 
 2790 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {
 2791   fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);
 2792   Label L;
 2793   if (unordered_is_less) {
 2794     movl(dst, -1);
 2795     jcc(Assembler::parity, L);
 2796     jcc(Assembler::below , L);
 2797     movl(dst, 0);
 2798     jcc(Assembler::equal , L);
 2799     increment(dst);
 2800   } else { // unordered is greater
 2801     movl(dst, 1);
 2802     jcc(Assembler::parity, L);
 2803     jcc(Assembler::above , L);
 2804     movl(dst, 0);
 2805     jcc(Assembler::equal , L);
 2806     decrementl(dst);
 2807   }
 2808   bind(L);
 2809 }
 2810 
 2811 void MacroAssembler::fld_d(AddressLiteral src) {
 2812   fld_d(as_Address(src));
 2813 }
 2814 
 2815 void MacroAssembler::fld_s(AddressLiteral src) {
 2816   fld_s(as_Address(src));
 2817 }
 2818 
<a name="1" id="anc1"></a>



 2819 void MacroAssembler::fldcw(AddressLiteral src) {
 2820   Assembler::fldcw(as_Address(src));
 2821 }
 2822 
 2823 void MacroAssembler::fpop() {
 2824   ffree();
 2825   fincstp();
 2826 }
 2827 
 2828 void MacroAssembler::fremr(Register tmp) {
 2829   save_rax(tmp);
 2830   { Label L;
 2831     bind(L);
 2832     fprem();
 2833     fwait(); fnstsw_ax();
 2834     sahf();
 2835     jcc(Assembler::parity, L);
 2836   }
 2837   restore_rax(tmp);
 2838   // Result is in ST0.
 2839   // Note: fxch &amp; fpop to get rid of ST1
 2840   // (otherwise FPU stack could overflow eventually)
 2841   fxch(1);
 2842   fpop();
 2843 }
 2844 
 2845 void MacroAssembler::empty_FPU_stack() {
 2846   if (VM_Version::supports_mmx()) {
 2847     emms();
 2848   } else {
 2849     for (int i = 8; i-- &gt; 0; ) ffree(i);
 2850   }
 2851 }
 2852 #endif // !LP64
 2853 
 2854 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
 2855   if (reachable(src)) {
 2856     Assembler::mulpd(dst, as_Address(src));
 2857   } else {
 2858     lea(rscratch1, src);
 2859     Assembler::mulpd(dst, Address(rscratch1, 0));
 2860   }
 2861 }
 2862 
 2863 void MacroAssembler::load_float(Address src) {
 2864 #ifdef _LP64
 2865   movflt(xmm0, src);
 2866 #else
 2867   if (UseSSE &gt;= 1) {
 2868     movflt(xmm0, src);
 2869   } else {
 2870     fld_s(src);
 2871   }
 2872 #endif // LP64
 2873 }
 2874 
 2875 void MacroAssembler::store_float(Address dst) {
 2876 #ifdef _LP64
 2877   movflt(dst, xmm0);
 2878 #else
 2879   if (UseSSE &gt;= 1) {
 2880     movflt(dst, xmm0);
 2881   } else {
 2882     fstp_s(dst);
 2883   }
 2884 #endif // LP64
 2885 }
 2886 
 2887 void MacroAssembler::load_double(Address src) {
 2888 #ifdef _LP64
 2889   movdbl(xmm0, src);
 2890 #else
 2891   if (UseSSE &gt;= 2) {
 2892     movdbl(xmm0, src);
 2893   } else {
 2894     fld_d(src);
 2895   }
 2896 #endif // LP64
 2897 }
 2898 
 2899 void MacroAssembler::store_double(Address dst) {
 2900 #ifdef _LP64
 2901   movdbl(dst, xmm0);
 2902 #else
 2903   if (UseSSE &gt;= 2) {
 2904     movdbl(dst, xmm0);
 2905   } else {
 2906     fstp_d(dst);
 2907   }
 2908 #endif // LP64
 2909 }
 2910 
 2911 // dst = c = a * b + c
 2912 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2913   Assembler::vfmadd231sd(c, a, b);
 2914   if (dst != c) {
 2915     movdbl(dst, c);
 2916   }
 2917 }
 2918 
 2919 // dst = c = a * b + c
 2920 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2921   Assembler::vfmadd231ss(c, a, b);
 2922   if (dst != c) {
 2923     movflt(dst, c);
 2924   }
 2925 }
 2926 
 2927 // dst = c = a * b + c
 2928 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
 2929   Assembler::vfmadd231pd(c, a, b, vector_len);
 2930   if (dst != c) {
 2931     vmovdqu(dst, c);
 2932   }
 2933 }
 2934 
 2935 // dst = c = a * b + c
 2936 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
 2937   Assembler::vfmadd231ps(c, a, b, vector_len);
 2938   if (dst != c) {
 2939     vmovdqu(dst, c);
 2940   }
 2941 }
 2942 
 2943 // dst = c = a * b + c
 2944 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
 2945   Assembler::vfmadd231pd(c, a, b, vector_len);
 2946   if (dst != c) {
 2947     vmovdqu(dst, c);
 2948   }
 2949 }
 2950 
 2951 // dst = c = a * b + c
 2952 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
 2953   Assembler::vfmadd231ps(c, a, b, vector_len);
 2954   if (dst != c) {
 2955     vmovdqu(dst, c);
 2956   }
 2957 }
 2958 
 2959 void MacroAssembler::incrementl(AddressLiteral dst) {
 2960   if (reachable(dst)) {
 2961     incrementl(as_Address(dst));
 2962   } else {
 2963     lea(rscratch1, dst);
 2964     incrementl(Address(rscratch1, 0));
 2965   }
 2966 }
 2967 
 2968 void MacroAssembler::incrementl(ArrayAddress dst) {
 2969   incrementl(as_Address(dst));
 2970 }
 2971 
 2972 void MacroAssembler::incrementl(Register reg, int value) {
 2973   if (value == min_jint) {addl(reg, value) ; return; }
 2974   if (value &lt;  0) { decrementl(reg, -value); return; }
 2975   if (value == 0) {                        ; return; }
 2976   if (value == 1 &amp;&amp; UseIncDec) { incl(reg) ; return; }
 2977   /* else */      { addl(reg, value)       ; return; }
 2978 }
 2979 
 2980 void MacroAssembler::incrementl(Address dst, int value) {
 2981   if (value == min_jint) {addl(dst, value) ; return; }
 2982   if (value &lt;  0) { decrementl(dst, -value); return; }
 2983   if (value == 0) {                        ; return; }
 2984   if (value == 1 &amp;&amp; UseIncDec) { incl(dst) ; return; }
 2985   /* else */      { addl(dst, value)       ; return; }
 2986 }
 2987 
 2988 void MacroAssembler::jump(AddressLiteral dst) {
 2989   if (reachable(dst)) {
 2990     jmp_literal(dst.target(), dst.rspec());
 2991   } else {
 2992     lea(rscratch1, dst);
 2993     jmp(rscratch1);
 2994   }
 2995 }
 2996 
 2997 void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {
 2998   if (reachable(dst)) {
 2999     InstructionMark im(this);
 3000     relocate(dst.reloc());
 3001     const int short_size = 2;
 3002     const int long_size = 6;
 3003     int offs = (intptr_t)dst.target() - ((intptr_t)pc());
 3004     if (dst.reloc() == relocInfo::none &amp;&amp; is8bit(offs - short_size)) {
 3005       // 0111 tttn #8-bit disp
 3006       emit_int8(0x70 | cc);
 3007       emit_int8((offs - short_size) &amp; 0xFF);
 3008     } else {
 3009       // 0000 1111 1000 tttn #32-bit disp
 3010       emit_int8(0x0F);
 3011       emit_int8((unsigned char)(0x80 | cc));
 3012       emit_int32(offs - long_size);
 3013     }
 3014   } else {
 3015 #ifdef ASSERT
 3016     warning(&quot;reversing conditional branch&quot;);
 3017 #endif /* ASSERT */
 3018     Label skip;
 3019     jccb(reverse[cc], skip);
 3020     lea(rscratch1, dst);
 3021     Assembler::jmp(rscratch1);
 3022     bind(skip);
 3023   }
 3024 }
 3025 
<a name="2" id="anc2"></a><span class="line-added"> 3026 void MacroAssembler::fld_x(AddressLiteral src) {</span>
<span class="line-added"> 3027   Assembler::fld_x(as_Address(src));</span>
<span class="line-added"> 3028 }</span>
<span class="line-added"> 3029 </span>
 3030 void MacroAssembler::ldmxcsr(AddressLiteral src) {
 3031   if (reachable(src)) {
 3032     Assembler::ldmxcsr(as_Address(src));
 3033   } else {
 3034     lea(rscratch1, src);
 3035     Assembler::ldmxcsr(Address(rscratch1, 0));
 3036   }
 3037 }
 3038 
 3039 int MacroAssembler::load_signed_byte(Register dst, Address src) {
 3040   int off;
 3041   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
 3042     off = offset();
 3043     movsbl(dst, src); // movsxb
 3044   } else {
 3045     off = load_unsigned_byte(dst, src);
 3046     shll(dst, 24);
 3047     sarl(dst, 24);
 3048   }
 3049   return off;
 3050 }
 3051 
 3052 // Note: load_signed_short used to be called load_signed_word.
 3053 // Although the &#39;w&#39; in x86 opcodes refers to the term &quot;word&quot; in the assembler
 3054 // manual, which means 16 bits, that usage is found nowhere in HotSpot code.
 3055 // The term &quot;word&quot; in HotSpot means a 32- or 64-bit machine word.
 3056 int MacroAssembler::load_signed_short(Register dst, Address src) {
 3057   int off;
 3058   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
 3059     // This is dubious to me since it seems safe to do a signed 16 =&gt; 64 bit
 3060     // version but this is what 64bit has always done. This seems to imply
 3061     // that users are only using 32bits worth.
 3062     off = offset();
 3063     movswl(dst, src); // movsxw
 3064   } else {
 3065     off = load_unsigned_short(dst, src);
 3066     shll(dst, 16);
 3067     sarl(dst, 16);
 3068   }
 3069   return off;
 3070 }
 3071 
 3072 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
 3073   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
 3074   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
 3075   int off;
 3076   if (LP64_ONLY(true || ) VM_Version::is_P6() || src.uses(dst)) {
 3077     off = offset();
 3078     movzbl(dst, src); // movzxb
 3079   } else {
 3080     xorl(dst, dst);
 3081     off = offset();
 3082     movb(dst, src);
 3083   }
 3084   return off;
 3085 }
 3086 
 3087 // Note: load_unsigned_short used to be called load_unsigned_word.
 3088 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
 3089   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
 3090   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
 3091   int off;
 3092   if (LP64_ONLY(true ||) VM_Version::is_P6() || src.uses(dst)) {
 3093     off = offset();
 3094     movzwl(dst, src); // movzxw
 3095   } else {
 3096     xorl(dst, dst);
 3097     off = offset();
 3098     movw(dst, src);
 3099   }
 3100   return off;
 3101 }
 3102 
 3103 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
 3104   switch (size_in_bytes) {
 3105 #ifndef _LP64
 3106   case  8:
 3107     assert(dst2 != noreg, &quot;second dest register required&quot;);
 3108     movl(dst,  src);
 3109     movl(dst2, src.plus_disp(BytesPerInt));
 3110     break;
 3111 #else
 3112   case  8:  movq(dst, src); break;
 3113 #endif
 3114   case  4:  movl(dst, src); break;
 3115   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
 3116   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
 3117   default:  ShouldNotReachHere();
 3118   }
 3119 }
 3120 
 3121 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
 3122   switch (size_in_bytes) {
 3123 #ifndef _LP64
 3124   case  8:
 3125     assert(src2 != noreg, &quot;second source register required&quot;);
 3126     movl(dst,                        src);
 3127     movl(dst.plus_disp(BytesPerInt), src2);
 3128     break;
 3129 #else
 3130   case  8:  movq(dst, src); break;
 3131 #endif
 3132   case  4:  movl(dst, src); break;
 3133   case  2:  movw(dst, src); break;
 3134   case  1:  movb(dst, src); break;
 3135   default:  ShouldNotReachHere();
 3136   }
 3137 }
 3138 
 3139 void MacroAssembler::mov32(AddressLiteral dst, Register src) {
 3140   if (reachable(dst)) {
 3141     movl(as_Address(dst), src);
 3142   } else {
 3143     lea(rscratch1, dst);
 3144     movl(Address(rscratch1, 0), src);
 3145   }
 3146 }
 3147 
 3148 void MacroAssembler::mov32(Register dst, AddressLiteral src) {
 3149   if (reachable(src)) {
 3150     movl(dst, as_Address(src));
 3151   } else {
 3152     lea(rscratch1, src);
 3153     movl(dst, Address(rscratch1, 0));
 3154   }
 3155 }
 3156 
 3157 // C++ bool manipulation
 3158 
 3159 void MacroAssembler::movbool(Register dst, Address src) {
 3160   if(sizeof(bool) == 1)
 3161     movb(dst, src);
 3162   else if(sizeof(bool) == 2)
 3163     movw(dst, src);
 3164   else if(sizeof(bool) == 4)
 3165     movl(dst, src);
 3166   else
 3167     // unsupported
 3168     ShouldNotReachHere();
 3169 }
 3170 
 3171 void MacroAssembler::movbool(Address dst, bool boolconst) {
 3172   if(sizeof(bool) == 1)
 3173     movb(dst, (int) boolconst);
 3174   else if(sizeof(bool) == 2)
 3175     movw(dst, (int) boolconst);
 3176   else if(sizeof(bool) == 4)
 3177     movl(dst, (int) boolconst);
 3178   else
 3179     // unsupported
 3180     ShouldNotReachHere();
 3181 }
 3182 
 3183 void MacroAssembler::movbool(Address dst, Register src) {
 3184   if(sizeof(bool) == 1)
 3185     movb(dst, src);
 3186   else if(sizeof(bool) == 2)
 3187     movw(dst, src);
 3188   else if(sizeof(bool) == 4)
 3189     movl(dst, src);
 3190   else
 3191     // unsupported
 3192     ShouldNotReachHere();
 3193 }
 3194 
 3195 void MacroAssembler::movbyte(ArrayAddress dst, int src) {
 3196   movb(as_Address(dst), src);
 3197 }
 3198 
 3199 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
 3200   if (reachable(src)) {
 3201     movdl(dst, as_Address(src));
 3202   } else {
 3203     lea(rscratch1, src);
 3204     movdl(dst, Address(rscratch1, 0));
 3205   }
 3206 }
 3207 
 3208 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
 3209   if (reachable(src)) {
 3210     movq(dst, as_Address(src));
 3211   } else {
 3212     lea(rscratch1, src);
 3213     movq(dst, Address(rscratch1, 0));
 3214   }
 3215 }
 3216 
 3217 #ifdef COMPILER2
 3218 void MacroAssembler::setvectmask(Register dst, Register src) {
 3219   guarantee(PostLoopMultiversioning, &quot;must be&quot;);
 3220   Assembler::movl(dst, 1);
 3221   Assembler::shlxl(dst, dst, src);
 3222   Assembler::decl(dst);
 3223   Assembler::kmovdl(k1, dst);
 3224   Assembler::movl(dst, src);
 3225 }
 3226 
 3227 void MacroAssembler::restorevectmask() {
 3228   guarantee(PostLoopMultiversioning, &quot;must be&quot;);
 3229   Assembler::knotwl(k1, k0);
 3230 }
 3231 #endif // COMPILER2
 3232 
 3233 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
 3234   if (reachable(src)) {
 3235     if (UseXmmLoadAndClearUpper) {
 3236       movsd (dst, as_Address(src));
 3237     } else {
 3238       movlpd(dst, as_Address(src));
 3239     }
 3240   } else {
 3241     lea(rscratch1, src);
 3242     if (UseXmmLoadAndClearUpper) {
 3243       movsd (dst, Address(rscratch1, 0));
 3244     } else {
 3245       movlpd(dst, Address(rscratch1, 0));
 3246     }
 3247   }
 3248 }
 3249 
 3250 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
 3251   if (reachable(src)) {
 3252     movss(dst, as_Address(src));
 3253   } else {
 3254     lea(rscratch1, src);
 3255     movss(dst, Address(rscratch1, 0));
 3256   }
 3257 }
 3258 
 3259 void MacroAssembler::movptr(Register dst, Register src) {
 3260   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
 3261 }
 3262 
 3263 void MacroAssembler::movptr(Register dst, Address src) {
 3264   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
 3265 }
 3266 
 3267 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 3268 void MacroAssembler::movptr(Register dst, intptr_t src) {
 3269   LP64_ONLY(mov64(dst, src)) NOT_LP64(movl(dst, src));
 3270 }
 3271 
 3272 void MacroAssembler::movptr(Address dst, Register src) {
 3273   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
 3274 }
 3275 
 3276 void MacroAssembler::movdqu(Address dst, XMMRegister src) {
 3277     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3278     Assembler::movdqu(dst, src);
 3279 }
 3280 
 3281 void MacroAssembler::movdqu(XMMRegister dst, Address src) {
 3282     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3283     Assembler::movdqu(dst, src);
 3284 }
 3285 
 3286 void MacroAssembler::movdqu(XMMRegister dst, XMMRegister src) {
 3287     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3288     Assembler::movdqu(dst, src);
 3289 }
 3290 
 3291 void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {
 3292   if (reachable(src)) {
 3293     movdqu(dst, as_Address(src));
 3294   } else {
 3295     lea(scratchReg, src);
 3296     movdqu(dst, Address(scratchReg, 0));
 3297   }
 3298 }
 3299 
 3300 void MacroAssembler::vmovdqu(Address dst, XMMRegister src) {
 3301     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3302     Assembler::vmovdqu(dst, src);
 3303 }
 3304 
 3305 void MacroAssembler::vmovdqu(XMMRegister dst, Address src) {
 3306     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3307     Assembler::vmovdqu(dst, src);
 3308 }
 3309 
 3310 void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src) {
 3311     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3312     Assembler::vmovdqu(dst, src);
 3313 }
 3314 
 3315 void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 3316   if (reachable(src)) {
 3317     vmovdqu(dst, as_Address(src));
 3318   }
 3319   else {
 3320     lea(scratch_reg, src);
 3321     vmovdqu(dst, Address(scratch_reg, 0));
 3322   }
 3323 }
 3324 
 3325 void MacroAssembler::evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {
 3326   if (reachable(src)) {
 3327     Assembler::evmovdquq(dst, as_Address(src), vector_len);
 3328   } else {
 3329     lea(rscratch, src);
 3330     Assembler::evmovdquq(dst, Address(rscratch, 0), vector_len);
 3331   }
 3332 }
 3333 
 3334 void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {
 3335   if (reachable(src)) {
 3336     Assembler::movdqa(dst, as_Address(src));
 3337   } else {
 3338     lea(rscratch1, src);
 3339     Assembler::movdqa(dst, Address(rscratch1, 0));
 3340   }
 3341 }
 3342 
 3343 void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {
 3344   if (reachable(src)) {
 3345     Assembler::movsd(dst, as_Address(src));
 3346   } else {
 3347     lea(rscratch1, src);
 3348     Assembler::movsd(dst, Address(rscratch1, 0));
 3349   }
 3350 }
 3351 
 3352 void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {
 3353   if (reachable(src)) {
 3354     Assembler::movss(dst, as_Address(src));
 3355   } else {
 3356     lea(rscratch1, src);
 3357     Assembler::movss(dst, Address(rscratch1, 0));
 3358   }
 3359 }
 3360 
 3361 void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {
 3362   if (reachable(src)) {
 3363     Assembler::mulsd(dst, as_Address(src));
 3364   } else {
 3365     lea(rscratch1, src);
 3366     Assembler::mulsd(dst, Address(rscratch1, 0));
 3367   }
 3368 }
 3369 
 3370 void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {
 3371   if (reachable(src)) {
 3372     Assembler::mulss(dst, as_Address(src));
 3373   } else {
 3374     lea(rscratch1, src);
 3375     Assembler::mulss(dst, Address(rscratch1, 0));
 3376   }
 3377 }
 3378 
 3379 void MacroAssembler::null_check(Register reg, int offset) {
 3380   if (needs_explicit_null_check(offset)) {
 3381     // provoke OS NULL exception if reg = NULL by
 3382     // accessing M[reg] w/o changing any (non-CC) registers
 3383     // NOTE: cmpl is plenty here to provoke a segv
 3384     cmpptr(rax, Address(reg, 0));
 3385     // Note: should probably use testl(rax, Address(reg, 0));
 3386     //       may be shorter code (however, this version of
 3387     //       testl needs to be implemented first)
 3388   } else {
 3389     // nothing to do, (later) access of M[reg + offset]
 3390     // will provoke OS NULL exception if reg = NULL
 3391   }
 3392 }
 3393 
 3394 void MacroAssembler::os_breakpoint() {
 3395   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
 3396   // (e.g., MSVC can&#39;t call ps() otherwise)
 3397   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
 3398 }
 3399 
 3400 void MacroAssembler::unimplemented(const char* what) {
 3401   const char* buf = NULL;
 3402   {
 3403     ResourceMark rm;
 3404     stringStream ss;
 3405     ss.print(&quot;unimplemented: %s&quot;, what);
 3406     buf = code_string(ss.as_string());
 3407   }
 3408   stop(buf);
 3409 }
 3410 
 3411 #ifdef _LP64
 3412 #define XSTATE_BV 0x200
 3413 #endif
 3414 
 3415 void MacroAssembler::pop_CPU_state() {
 3416   pop_FPU_state();
 3417   pop_IU_state();
 3418 }
 3419 
 3420 void MacroAssembler::pop_FPU_state() {
 3421 #ifndef _LP64
 3422   frstor(Address(rsp, 0));
 3423 #else
 3424   fxrstor(Address(rsp, 0));
 3425 #endif
 3426   addptr(rsp, FPUStateSizeInWords * wordSize);
 3427 }
 3428 
 3429 void MacroAssembler::pop_IU_state() {
 3430   popa();
 3431   LP64_ONLY(addq(rsp, 8));
 3432   popf();
 3433 }
 3434 
 3435 // Save Integer and Float state
 3436 // Warning: Stack must be 16 byte aligned (64bit)
 3437 void MacroAssembler::push_CPU_state() {
 3438   push_IU_state();
 3439   push_FPU_state();
 3440 }
 3441 
 3442 void MacroAssembler::push_FPU_state() {
 3443   subptr(rsp, FPUStateSizeInWords * wordSize);
 3444 #ifndef _LP64
 3445   fnsave(Address(rsp, 0));
 3446   fwait();
 3447 #else
 3448   fxsave(Address(rsp, 0));
 3449 #endif // LP64
 3450 }
 3451 
 3452 void MacroAssembler::push_IU_state() {
 3453   // Push flags first because pusha kills them
 3454   pushf();
 3455   // Make sure rsp stays 16-byte aligned
 3456   LP64_ONLY(subq(rsp, 8));
 3457   pusha();
 3458 }
 3459 
 3460 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
 3461   if (!java_thread-&gt;is_valid()) {
 3462     java_thread = rdi;
 3463     get_thread(java_thread);
 3464   }
 3465   // we must set sp to zero to clear frame
 3466   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
 3467   if (clear_fp) {
 3468     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
 3469   }
 3470 
 3471   // Always clear the pc because it could have been set by make_walkable()
 3472   movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
 3473 
 3474   vzeroupper();
 3475 }
 3476 
 3477 void MacroAssembler::restore_rax(Register tmp) {
 3478   if (tmp == noreg) pop(rax);
 3479   else if (tmp != rax) mov(rax, tmp);
 3480 }
 3481 
 3482 void MacroAssembler::round_to(Register reg, int modulus) {
 3483   addptr(reg, modulus - 1);
 3484   andptr(reg, -modulus);
 3485 }
 3486 
 3487 void MacroAssembler::save_rax(Register tmp) {
 3488   if (tmp == noreg) push(rax);
 3489   else if (tmp != rax) mov(tmp, rax);
 3490 }
 3491 
 3492 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
 3493   if (SafepointMechanism::uses_thread_local_poll()) {
 3494 #ifdef _LP64
 3495     assert(thread_reg == r15_thread, &quot;should be&quot;);
 3496 #else
 3497     if (thread_reg == noreg) {
 3498       thread_reg = temp_reg;
 3499       get_thread(thread_reg);
 3500     }
 3501 #endif
 3502     testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
 3503     jcc(Assembler::notZero, slow_path); // handshake bit set implies poll
 3504   } else {
 3505     cmp32(ExternalAddress(SafepointSynchronize::address_of_state()),
 3506         SafepointSynchronize::_not_synchronized);
 3507     jcc(Assembler::notEqual, slow_path);
 3508   }
 3509 }
 3510 
 3511 // Calls to C land
 3512 //
 3513 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
 3514 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
 3515 // has to be reset to 0. This is required to allow proper stack traversal.
 3516 void MacroAssembler::set_last_Java_frame(Register java_thread,
 3517                                          Register last_java_sp,
 3518                                          Register last_java_fp,
 3519                                          address  last_java_pc) {
 3520   vzeroupper();
 3521   // determine java_thread register
 3522   if (!java_thread-&gt;is_valid()) {
 3523     java_thread = rdi;
 3524     get_thread(java_thread);
 3525   }
 3526   // determine last_java_sp register
 3527   if (!last_java_sp-&gt;is_valid()) {
 3528     last_java_sp = rsp;
 3529   }
 3530 
 3531   // last_java_fp is optional
 3532 
 3533   if (last_java_fp-&gt;is_valid()) {
 3534     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);
 3535   }
 3536 
 3537   // last_java_pc is optional
 3538 
 3539   if (last_java_pc != NULL) {
 3540     lea(Address(java_thread,
 3541                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),
 3542         InternalAddress(last_java_pc));
 3543 
 3544   }
 3545   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
 3546 }
 3547 
 3548 void MacroAssembler::shlptr(Register dst, int imm8) {
 3549   LP64_ONLY(shlq(dst, imm8)) NOT_LP64(shll(dst, imm8));
 3550 }
 3551 
 3552 void MacroAssembler::shrptr(Register dst, int imm8) {
 3553   LP64_ONLY(shrq(dst, imm8)) NOT_LP64(shrl(dst, imm8));
 3554 }
 3555 
 3556 void MacroAssembler::sign_extend_byte(Register reg) {
 3557   if (LP64_ONLY(true ||) (VM_Version::is_P6() &amp;&amp; reg-&gt;has_byte_register())) {
 3558     movsbl(reg, reg); // movsxb
 3559   } else {
 3560     shll(reg, 24);
 3561     sarl(reg, 24);
 3562   }
 3563 }
 3564 
 3565 void MacroAssembler::sign_extend_short(Register reg) {
 3566   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
 3567     movswl(reg, reg); // movsxw
 3568   } else {
 3569     shll(reg, 16);
 3570     sarl(reg, 16);
 3571   }
 3572 }
 3573 
 3574 void MacroAssembler::testl(Register dst, AddressLiteral src) {
 3575   assert(reachable(src), &quot;Address should be reachable&quot;);
 3576   testl(dst, as_Address(src));
 3577 }
 3578 
 3579 void MacroAssembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
 3580   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3581   Assembler::pcmpeqb(dst, src);
 3582 }
 3583 
 3584 void MacroAssembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
 3585   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3586   Assembler::pcmpeqw(dst, src);
 3587 }
 3588 
 3589 void MacroAssembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
 3590   assert((dst-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3591   Assembler::pcmpestri(dst, src, imm8);
 3592 }
 3593 
 3594 void MacroAssembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
 3595   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3596   Assembler::pcmpestri(dst, src, imm8);
 3597 }
 3598 
 3599 void MacroAssembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
 3600   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3601   Assembler::pmovzxbw(dst, src);
 3602 }
 3603 
 3604 void MacroAssembler::pmovzxbw(XMMRegister dst, Address src) {
 3605   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3606   Assembler::pmovzxbw(dst, src);
 3607 }
 3608 
 3609 void MacroAssembler::pmovmskb(Register dst, XMMRegister src) {
 3610   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3611   Assembler::pmovmskb(dst, src);
 3612 }
 3613 
 3614 void MacroAssembler::ptest(XMMRegister dst, XMMRegister src) {
 3615   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3616   Assembler::ptest(dst, src);
 3617 }
 3618 
 3619 void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {
 3620   if (reachable(src)) {
 3621     Assembler::sqrtsd(dst, as_Address(src));
 3622   } else {
 3623     lea(rscratch1, src);
 3624     Assembler::sqrtsd(dst, Address(rscratch1, 0));
 3625   }
 3626 }
 3627 
 3628 void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {
 3629   if (reachable(src)) {
 3630     Assembler::sqrtss(dst, as_Address(src));
 3631   } else {
 3632     lea(rscratch1, src);
 3633     Assembler::sqrtss(dst, Address(rscratch1, 0));
 3634   }
 3635 }
 3636 
 3637 void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {
 3638   if (reachable(src)) {
 3639     Assembler::subsd(dst, as_Address(src));
 3640   } else {
 3641     lea(rscratch1, src);
 3642     Assembler::subsd(dst, Address(rscratch1, 0));
 3643   }
 3644 }
 3645 
 3646 void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {
 3647   if (reachable(src)) {
 3648     Assembler::roundsd(dst, as_Address(src), rmode);
 3649   } else {
 3650     lea(scratch_reg, src);
 3651     Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);
 3652   }
 3653 }
 3654 
 3655 void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {
 3656   if (reachable(src)) {
 3657     Assembler::subss(dst, as_Address(src));
 3658   } else {
 3659     lea(rscratch1, src);
 3660     Assembler::subss(dst, Address(rscratch1, 0));
 3661   }
 3662 }
 3663 
 3664 void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {
 3665   if (reachable(src)) {
 3666     Assembler::ucomisd(dst, as_Address(src));
 3667   } else {
 3668     lea(rscratch1, src);
 3669     Assembler::ucomisd(dst, Address(rscratch1, 0));
 3670   }
 3671 }
 3672 
 3673 void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {
 3674   if (reachable(src)) {
 3675     Assembler::ucomiss(dst, as_Address(src));
 3676   } else {
 3677     lea(rscratch1, src);
 3678     Assembler::ucomiss(dst, Address(rscratch1, 0));
 3679   }
 3680 }
 3681 
 3682 void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 3683   // Used in sign-bit flipping with aligned address.
 3684   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 3685   if (reachable(src)) {
 3686     Assembler::xorpd(dst, as_Address(src));
 3687   } else {
 3688     lea(scratch_reg, src);
 3689     Assembler::xorpd(dst, Address(scratch_reg, 0));
 3690   }
 3691 }
 3692 
 3693 void MacroAssembler::xorpd(XMMRegister dst, XMMRegister src) {
 3694   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
 3695     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
 3696   }
 3697   else {
 3698     Assembler::xorpd(dst, src);
 3699   }
 3700 }
 3701 
 3702 void MacroAssembler::xorps(XMMRegister dst, XMMRegister src) {
 3703   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
 3704     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
 3705   } else {
 3706     Assembler::xorps(dst, src);
 3707   }
 3708 }
 3709 
 3710 void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 3711   // Used in sign-bit flipping with aligned address.
 3712   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 3713   if (reachable(src)) {
 3714     Assembler::xorps(dst, as_Address(src));
 3715   } else {
 3716     lea(scratch_reg, src);
 3717     Assembler::xorps(dst, Address(scratch_reg, 0));
 3718   }
 3719 }
 3720 
 3721 void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {
 3722   // Used in sign-bit flipping with aligned address.
 3723   bool aligned_adr = (((intptr_t)src.target() &amp; 15) == 0);
 3724   assert((UseAVX &gt; 0) || aligned_adr, &quot;SSE mode requires address alignment 16 bytes&quot;);
 3725   if (reachable(src)) {
 3726     Assembler::pshufb(dst, as_Address(src));
 3727   } else {
 3728     lea(rscratch1, src);
 3729     Assembler::pshufb(dst, Address(rscratch1, 0));
 3730   }
 3731 }
 3732 
 3733 // AVX 3-operands instructions
 3734 
 3735 void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3736   if (reachable(src)) {
 3737     vaddsd(dst, nds, as_Address(src));
 3738   } else {
 3739     lea(rscratch1, src);
 3740     vaddsd(dst, nds, Address(rscratch1, 0));
 3741   }
 3742 }
 3743 
 3744 void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3745   if (reachable(src)) {
 3746     vaddss(dst, nds, as_Address(src));
 3747   } else {
 3748     lea(rscratch1, src);
 3749     vaddss(dst, nds, Address(rscratch1, 0));
 3750   }
 3751 }
 3752 
 3753 void MacroAssembler::vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {
 3754   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
 3755   if (reachable(src)) {
 3756     Assembler::vpaddd(dst, nds, as_Address(src), vector_len);
 3757   } else {
 3758     lea(rscratch, src);
 3759     Assembler::vpaddd(dst, nds, Address(rscratch, 0), vector_len);
 3760   }
 3761 }
 3762 
 3763 void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
 3764   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
 3765   vandps(dst, nds, negate_field, vector_len);
 3766 }
 3767 
 3768 void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
 3769   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
 3770   vandpd(dst, nds, negate_field, vector_len);
 3771 }
 3772 
 3773 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3774   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3775   Assembler::vpaddb(dst, nds, src, vector_len);
 3776 }
 3777 
 3778 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
 3779   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3780   Assembler::vpaddb(dst, nds, src, vector_len);
 3781 }
 3782 
 3783 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3784   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3785   Assembler::vpaddw(dst, nds, src, vector_len);
 3786 }
 3787 
 3788 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
 3789   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3790   Assembler::vpaddw(dst, nds, src, vector_len);
 3791 }
 3792 
 3793 void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 3794   if (reachable(src)) {
 3795     Assembler::vpand(dst, nds, as_Address(src), vector_len);
 3796   } else {
 3797     lea(scratch_reg, src);
 3798     Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);
 3799   }
 3800 }
 3801 
 3802 void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
 3803   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3804   Assembler::vpbroadcastw(dst, src, vector_len);
 3805 }
 3806 
 3807 void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3808   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3809   Assembler::vpcmpeqb(dst, nds, src, vector_len);
 3810 }
 3811 
 3812 void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3813   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3814   Assembler::vpcmpeqw(dst, nds, src, vector_len);
 3815 }
 3816 
 3817 void MacroAssembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
 3818   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3819   Assembler::vpmovzxbw(dst, src, vector_len);
 3820 }
 3821 
 3822 void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {
 3823   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3824   Assembler::vpmovmskb(dst, src);
 3825 }
 3826 
 3827 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3828   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3829   Assembler::vpmullw(dst, nds, src, vector_len);
 3830 }
 3831 
 3832 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
 3833   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3834   Assembler::vpmullw(dst, nds, src, vector_len);
 3835 }
 3836 
 3837 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3838   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3839   Assembler::vpsubb(dst, nds, src, vector_len);
 3840 }
 3841 
 3842 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
 3843   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3844   Assembler::vpsubb(dst, nds, src, vector_len);
 3845 }
 3846 
 3847 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3848   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3849   Assembler::vpsubw(dst, nds, src, vector_len);
 3850 }
 3851 
 3852 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
 3853   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3854   Assembler::vpsubw(dst, nds, src, vector_len);
 3855 }
 3856 
 3857 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
 3858   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3859   Assembler::vpsraw(dst, nds, shift, vector_len);
 3860 }
 3861 
 3862 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
 3863   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3864   Assembler::vpsraw(dst, nds, shift, vector_len);
 3865 }
 3866 
 3867 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
 3868   assert(UseAVX &gt; 2,&quot;&quot;);
 3869   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
 3870      vector_len = 2;
 3871   }
 3872   Assembler::evpsraq(dst, nds, shift, vector_len);
 3873 }
 3874 
 3875 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
 3876   assert(UseAVX &gt; 2,&quot;&quot;);
 3877   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
 3878      vector_len = 2;
 3879   }
 3880   Assembler::evpsraq(dst, nds, shift, vector_len);
 3881 }
 3882 
 3883 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
 3884   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3885   Assembler::vpsrlw(dst, nds, shift, vector_len);
 3886 }
 3887 
 3888 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
 3889   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3890   Assembler::vpsrlw(dst, nds, shift, vector_len);
 3891 }
 3892 
 3893 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
 3894   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3895   Assembler::vpsllw(dst, nds, shift, vector_len);
 3896 }
 3897 
 3898 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
 3899   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3900   Assembler::vpsllw(dst, nds, shift, vector_len);
 3901 }
 3902 
 3903 void MacroAssembler::vptest(XMMRegister dst, XMMRegister src) {
 3904   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3905   Assembler::vptest(dst, src);
 3906 }
 3907 
 3908 void MacroAssembler::punpcklbw(XMMRegister dst, XMMRegister src) {
 3909   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3910   Assembler::punpcklbw(dst, src);
 3911 }
 3912 
 3913 void MacroAssembler::pshufd(XMMRegister dst, Address src, int mode) {
 3914   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3915   Assembler::pshufd(dst, src, mode);
 3916 }
 3917 
 3918 void MacroAssembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
 3919   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3920   Assembler::pshuflw(dst, src, mode);
 3921 }
 3922 
 3923 void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 3924   if (reachable(src)) {
 3925     vandpd(dst, nds, as_Address(src), vector_len);
 3926   } else {
 3927     lea(scratch_reg, src);
 3928     vandpd(dst, nds, Address(scratch_reg, 0), vector_len);
 3929   }
 3930 }
 3931 
 3932 void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 3933   if (reachable(src)) {
 3934     vandps(dst, nds, as_Address(src), vector_len);
 3935   } else {
 3936     lea(scratch_reg, src);
 3937     vandps(dst, nds, Address(scratch_reg, 0), vector_len);
 3938   }
 3939 }
 3940 
 3941 void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3942   if (reachable(src)) {
 3943     vdivsd(dst, nds, as_Address(src));
 3944   } else {
 3945     lea(rscratch1, src);
 3946     vdivsd(dst, nds, Address(rscratch1, 0));
 3947   }
 3948 }
 3949 
 3950 void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3951   if (reachable(src)) {
 3952     vdivss(dst, nds, as_Address(src));
 3953   } else {
 3954     lea(rscratch1, src);
 3955     vdivss(dst, nds, Address(rscratch1, 0));
 3956   }
 3957 }
 3958 
 3959 void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3960   if (reachable(src)) {
 3961     vmulsd(dst, nds, as_Address(src));
 3962   } else {
 3963     lea(rscratch1, src);
 3964     vmulsd(dst, nds, Address(rscratch1, 0));
 3965   }
 3966 }
 3967 
 3968 void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3969   if (reachable(src)) {
 3970     vmulss(dst, nds, as_Address(src));
 3971   } else {
 3972     lea(rscratch1, src);
 3973     vmulss(dst, nds, Address(rscratch1, 0));
 3974   }
 3975 }
 3976 
 3977 void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3978   if (reachable(src)) {
 3979     vsubsd(dst, nds, as_Address(src));
 3980   } else {
 3981     lea(rscratch1, src);
 3982     vsubsd(dst, nds, Address(rscratch1, 0));
 3983   }
 3984 }
 3985 
 3986 void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3987   if (reachable(src)) {
 3988     vsubss(dst, nds, as_Address(src));
 3989   } else {
 3990     lea(rscratch1, src);
 3991     vsubss(dst, nds, Address(rscratch1, 0));
 3992   }
 3993 }
 3994 
 3995 void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3996   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
 3997   vxorps(dst, nds, src, Assembler::AVX_128bit);
 3998 }
 3999 
 4000 void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 4001   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
 4002   vxorpd(dst, nds, src, Assembler::AVX_128bit);
 4003 }
 4004 
 4005 void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 4006   if (reachable(src)) {
 4007     vxorpd(dst, nds, as_Address(src), vector_len);
 4008   } else {
 4009     lea(scratch_reg, src);
 4010     vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);
 4011   }
 4012 }
 4013 
 4014 void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 4015   if (reachable(src)) {
 4016     vxorps(dst, nds, as_Address(src), vector_len);
 4017   } else {
 4018     lea(scratch_reg, src);
 4019     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
 4020   }
 4021 }
 4022 
 4023 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 4024   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
 4025     if (reachable(src)) {
 4026       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
 4027     } else {
 4028       lea(scratch_reg, src);
 4029       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
 4030     }
 4031   }
 4032   else {
 4033     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
 4034   }
 4035 }
 4036 
 4037 //-------------------------------------------------------------------------------------------
 4038 #ifdef COMPILER2
 4039 // Generic instructions support for use in .ad files C2 code generation
 4040 
 4041 void MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, Register scr) {
 4042   if (dst != src) {
 4043     movdqu(dst, src);
 4044   }
 4045   if (opcode == Op_AbsVD) {
 4046     andpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), scr);
 4047   } else {
 4048     assert((opcode == Op_NegVD),&quot;opcode should be Op_NegD&quot;);
 4049     xorpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), scr);
 4050   }
 4051 }
 4052 
 4053 void MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {
 4054   if (opcode == Op_AbsVD) {
 4055     vandpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), vector_len, scr);
 4056   } else {
 4057     assert((opcode == Op_NegVD),&quot;opcode should be Op_NegD&quot;);
 4058     vxorpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vector_len, scr);
 4059   }
 4060 }
 4061 
 4062 void MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, Register scr) {
 4063   if (dst != src) {
 4064     movdqu(dst, src);
 4065   }
 4066   if (opcode == Op_AbsVF) {
 4067     andps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), scr);
 4068   } else {
 4069     assert((opcode == Op_NegVF),&quot;opcode should be Op_NegF&quot;);
 4070     xorps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), scr);
 4071   }
 4072 }
 4073 
 4074 void MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {
 4075   if (opcode == Op_AbsVF) {
 4076     vandps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), vector_len, scr);
 4077   } else {
 4078     assert((opcode == Op_NegVF),&quot;opcode should be Op_NegF&quot;);
 4079     vxorps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vector_len, scr);
 4080   }
 4081 }
 4082 
 4083 void MacroAssembler::vextendbw(bool sign, XMMRegister dst, XMMRegister src) {
 4084   if (sign) {
 4085     pmovsxbw(dst, src);
 4086   } else {
 4087     pmovzxbw(dst, src);
 4088   }
 4089 }
 4090 
 4091 void MacroAssembler::vextendbw(bool sign, XMMRegister dst, XMMRegister src, int vector_len) {
 4092   if (sign) {
 4093     vpmovsxbw(dst, src, vector_len);
 4094   } else {
 4095     vpmovzxbw(dst, src, vector_len);
 4096   }
 4097 }
 4098 
 4099 void MacroAssembler::vshiftd(int opcode, XMMRegister dst, XMMRegister src) {
 4100   if (opcode == Op_RShiftVI) {
 4101     psrad(dst, src);
 4102   } else if (opcode == Op_LShiftVI) {
 4103     pslld(dst, src);
 4104   } else {
 4105     assert((opcode == Op_URShiftVI),&quot;opcode should be Op_URShiftVI&quot;);
 4106     psrld(dst, src);
 4107   }
 4108 }
 4109 
 4110 void MacroAssembler::vshiftd(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 4111   if (opcode == Op_RShiftVI) {
 4112     vpsrad(dst, nds, src, vector_len);
 4113   } else if (opcode == Op_LShiftVI) {
 4114     vpslld(dst, nds, src, vector_len);
 4115   } else {
 4116     assert((opcode == Op_URShiftVI),&quot;opcode should be Op_URShiftVI&quot;);
 4117     vpsrld(dst, nds, src, vector_len);
 4118   }
 4119 }
 4120 
 4121 void MacroAssembler::vshiftw(int opcode, XMMRegister dst, XMMRegister src) {
 4122   if ((opcode == Op_RShiftVS) || (opcode == Op_RShiftVB)) {
 4123     psraw(dst, src);
 4124   } else if ((opcode == Op_LShiftVS) || (opcode == Op_LShiftVB)) {
 4125     psllw(dst, src);
 4126   } else {
 4127     assert(((opcode == Op_URShiftVS) || (opcode == Op_URShiftVB)),&quot;opcode should be one of Op_URShiftVS or Op_URShiftVB&quot;);
 4128     psrlw(dst, src);
 4129   }
 4130 }
 4131 
 4132 void MacroAssembler::vshiftw(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 4133   if ((opcode == Op_RShiftVS) || (opcode == Op_RShiftVB)) {
 4134     vpsraw(dst, nds, src, vector_len);
 4135   } else if ((opcode == Op_LShiftVS) || (opcode == Op_LShiftVB)) {
 4136     vpsllw(dst, nds, src, vector_len);
 4137   } else {
 4138     assert(((opcode == Op_URShiftVS) || (opcode == Op_URShiftVB)),&quot;opcode should be one of Op_URShiftVS or Op_URShiftVB&quot;);
 4139     vpsrlw(dst, nds, src, vector_len);
 4140   }
 4141 }
 4142 
 4143 void MacroAssembler::vshiftq(int opcode, XMMRegister dst, XMMRegister src) {
 4144   if (opcode == Op_RShiftVL) {
 4145     psrlq(dst, src);  // using srl to implement sra on pre-avs512 systems
 4146   } else if (opcode == Op_LShiftVL) {
 4147     psllq(dst, src);
 4148   } else {
 4149     assert((opcode == Op_URShiftVL),&quot;opcode should be Op_URShiftVL&quot;);
 4150     psrlq(dst, src);
 4151   }
 4152 }
 4153 
 4154 void MacroAssembler::vshiftq(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 4155   if (opcode == Op_RShiftVL) {
 4156     evpsraq(dst, nds, src, vector_len);
 4157   } else if (opcode == Op_LShiftVL) {
 4158     vpsllq(dst, nds, src, vector_len);
 4159   } else {
 4160     assert((opcode == Op_URShiftVL),&quot;opcode should be Op_URShiftVL&quot;);
 4161     vpsrlq(dst, nds, src, vector_len);
 4162   }
 4163 }
 4164 
 4165 // Reductions for vectors of ints, longs, floats, and doubles.
 4166 
 4167 void MacroAssembler::reduce_operation_128(int opcode, XMMRegister dst, XMMRegister src) {
 4168   int vector_len = Assembler::AVX_128bit;
 4169 
 4170   switch (opcode) {
 4171     case Op_AndReductionV:  pand(dst, src); break;
 4172     case Op_OrReductionV:   por (dst, src); break;
 4173     case Op_XorReductionV:  pxor(dst, src); break;
 4174 
 4175     case Op_AddReductionVF: addss(dst, src); break;
 4176     case Op_AddReductionVD: addsd(dst, src); break;
 4177     case Op_AddReductionVI: paddd(dst, src); break;
 4178     case Op_AddReductionVL: paddq(dst, src); break;
 4179 
 4180     case Op_MulReductionVF: mulss(dst, src); break;
 4181     case Op_MulReductionVD: mulsd(dst, src); break;
 4182     case Op_MulReductionVI: pmulld(dst, src); break;
 4183     case Op_MulReductionVL: vpmullq(dst, dst, src, vector_len); break;
 4184 
 4185     default: assert(false, &quot;wrong opcode&quot;);
 4186   }
 4187 }
 4188 
 4189 void MacroAssembler::reduce_operation_256(int opcode, XMMRegister dst,  XMMRegister src1, XMMRegister src2) {
 4190   int vector_len = Assembler::AVX_256bit;
 4191 
 4192   switch (opcode) {
 4193     case Op_AndReductionV:  vpand(dst, src1, src2, vector_len); break;
 4194     case Op_OrReductionV:   vpor (dst, src1, src2, vector_len); break;
 4195     case Op_XorReductionV:  vpxor(dst, src1, src2, vector_len); break;
 4196 
 4197     case Op_AddReductionVI: vpaddd(dst, src1, src2, vector_len); break;
 4198     case Op_AddReductionVL: vpaddq(dst, src1, src2, vector_len); break;
 4199 
 4200     case Op_MulReductionVI: vpmulld(dst, src1, src2, vector_len); break;
 4201     case Op_MulReductionVL: vpmullq(dst, src1, src2, vector_len); break;
 4202 
 4203     default: assert(false, &quot;wrong opcode&quot;);
 4204   }
 4205 }
 4206 
 4207 void MacroAssembler::reduce_fp(int opcode, int vlen,
 4208                                XMMRegister dst, XMMRegister src,
 4209                                XMMRegister vtmp1, XMMRegister vtmp2) {
 4210   switch (opcode) {
 4211     case Op_AddReductionVF:
 4212     case Op_MulReductionVF:
 4213       reduceF(opcode, vlen, dst, src, vtmp1, vtmp2);
 4214       break;
 4215 
 4216     case Op_AddReductionVD:
 4217     case Op_MulReductionVD:
 4218       reduceD(opcode, vlen, dst, src, vtmp1, vtmp2);
 4219       break;
 4220 
 4221     default: assert(false, &quot;wrong opcode&quot;);
 4222   }
 4223 }
 4224 
 4225 void MacroAssembler::reduceI(int opcode, int vlen,
 4226                              Register dst, Register src1, XMMRegister src2,
 4227                              XMMRegister vtmp1, XMMRegister vtmp2) {
 4228   switch (vlen) {
 4229     case  2: reduce2I (opcode, dst, src1, src2, vtmp1, vtmp2); break;
 4230     case  4: reduce4I (opcode, dst, src1, src2, vtmp1, vtmp2); break;
 4231     case  8: reduce8I (opcode, dst, src1, src2, vtmp1, vtmp2); break;
 4232     case 16: reduce16I(opcode, dst, src1, src2, vtmp1, vtmp2); break;
 4233 
 4234     default: assert(false, &quot;wrong vector length&quot;);
 4235   }
 4236 }
 4237 
 4238 #ifdef _LP64
 4239 void MacroAssembler::reduceL(int opcode, int vlen,
 4240                              Register dst, Register src1, XMMRegister src2,
 4241                              XMMRegister vtmp1, XMMRegister vtmp2) {
 4242   switch (vlen) {
 4243     case 2: reduce2L(opcode, dst, src1, src2, vtmp1, vtmp2); break;
 4244     case 4: reduce4L(opcode, dst, src1, src2, vtmp1, vtmp2); break;
 4245     case 8: reduce8L(opcode, dst, src1, src2, vtmp1, vtmp2); break;
 4246 
 4247     default: assert(false, &quot;wrong vector length&quot;);
 4248   }
 4249 }
 4250 #endif // _LP64
 4251 
 4252 void MacroAssembler::reduceF(int opcode, int vlen, XMMRegister dst, XMMRegister src, XMMRegister vtmp1, XMMRegister vtmp2) {
 4253   switch (vlen) {
 4254     case 2:
 4255       assert(vtmp2 == xnoreg, &quot;&quot;);
 4256       reduce2F(opcode, dst, src, vtmp1);
 4257       break;
 4258     case 4:
 4259       assert(vtmp2 == xnoreg, &quot;&quot;);
 4260       reduce4F(opcode, dst, src, vtmp1);
 4261       break;
 4262     case 8:
 4263       reduce8F(opcode, dst, src, vtmp1, vtmp2);
 4264       break;
 4265     case 16:
 4266       reduce16F(opcode, dst, src, vtmp1, vtmp2);
 4267       break;
 4268     default: assert(false, &quot;wrong vector length&quot;);
 4269   }
 4270 }
 4271 
 4272 void MacroAssembler::reduceD(int opcode, int vlen, XMMRegister dst, XMMRegister src, XMMRegister vtmp1, XMMRegister vtmp2) {
 4273   switch (vlen) {
 4274     case 2:
 4275       assert(vtmp2 == xnoreg, &quot;&quot;);
 4276       reduce2D(opcode, dst, src, vtmp1);
 4277       break;
 4278     case 4:
 4279       reduce4D(opcode, dst, src, vtmp1, vtmp2);
 4280       break;
 4281     case 8:
 4282       reduce8D(opcode, dst, src, vtmp1, vtmp2);
 4283       break;
 4284     default: assert(false, &quot;wrong vector length&quot;);
 4285   }
 4286 }
 4287 
 4288 void MacroAssembler::reduce2I(int opcode, Register dst, Register src1, XMMRegister src2, XMMRegister vtmp1, XMMRegister vtmp2) {
 4289   if (opcode == Op_AddReductionVI) {
 4290     if (vtmp1 != src2) {
 4291       movdqu(vtmp1, src2);
 4292     }
 4293     phaddd(vtmp1, vtmp1);
 4294   } else {
 4295     pshufd(vtmp1, src2, 0x1);
 4296     reduce_operation_128(opcode, vtmp1, src2);
 4297   }
 4298   movdl(vtmp2, src1);
 4299   reduce_operation_128(opcode, vtmp1, vtmp2);
 4300   movdl(dst, vtmp1);
 4301 }
 4302 
 4303 void MacroAssembler::reduce4I(int opcode, Register dst, Register src1, XMMRegister src2, XMMRegister vtmp1, XMMRegister vtmp2) {
 4304   if (opcode == Op_AddReductionVI) {
 4305     if (vtmp1 != src2) {
 4306       movdqu(vtmp1, src2);
 4307     }
 4308     phaddd(vtmp1, src2);
 4309     reduce2I(opcode, dst, src1, vtmp1, vtmp1, vtmp2);
 4310   } else {
 4311     pshufd(vtmp2, src2, 0xE);
 4312     reduce_operation_128(opcode, vtmp2, src2);
 4313     reduce2I(opcode, dst, src1, vtmp2, vtmp1, vtmp2);
 4314   }
 4315 }
 4316 
 4317 void MacroAssembler::reduce8I(int opcode, Register dst, Register src1, XMMRegister src2, XMMRegister vtmp1, XMMRegister vtmp2) {
 4318   if (opcode == Op_AddReductionVI) {
 4319     vphaddd(vtmp1, src2, src2, Assembler::AVX_256bit);
 4320     vextracti128_high(vtmp2, vtmp1);
 4321     vpaddd(vtmp1, vtmp1, vtmp2, Assembler::AVX_128bit);
 4322     reduce2I(opcode, dst, src1, vtmp1, vtmp1, vtmp2);
 4323   } else {
 4324     vextracti128_high(vtmp1, src2);
 4325     reduce_operation_128(opcode, vtmp1, src2);
 4326     reduce4I(opcode, dst, src1, vtmp1, vtmp1, vtmp2);
 4327   }
 4328 }
 4329 
 4330 void MacroAssembler::reduce16I(int opcode, Register dst, Register src1, XMMRegister src2, XMMRegister vtmp1, XMMRegister vtmp2) {
 4331   vextracti64x4_high(vtmp2, src2);
 4332   reduce_operation_256(opcode, vtmp2, vtmp2, src2);
 4333   reduce8I(opcode, dst, src1, vtmp2, vtmp1, vtmp2);
 4334 }
 4335 
 4336 #ifdef _LP64
 4337 void MacroAssembler::reduce2L(int opcode, Register dst, Register src1, XMMRegister src2, XMMRegister vtmp1, XMMRegister vtmp2) {
 4338   pshufd(vtmp2, src2, 0xE);
 4339   reduce_operation_128(opcode, vtmp2, src2);
 4340   movdq(vtmp1, src1);
 4341   reduce_operation_128(opcode, vtmp1, vtmp2);
 4342   movdq(dst, vtmp1);
 4343 }
 4344 
 4345 void MacroAssembler::reduce4L(int opcode, Register dst, Register src1, XMMRegister src2, XMMRegister vtmp1, XMMRegister vtmp2) {
 4346   vextracti128_high(vtmp1, src2);
 4347   reduce_operation_128(opcode, vtmp1, src2);
 4348   reduce2L(opcode, dst, src1, vtmp1, vtmp1, vtmp2);
 4349 }
 4350 
 4351 void MacroAssembler::reduce8L(int opcode, Register dst, Register src1, XMMRegister src2, XMMRegister vtmp1, XMMRegister vtmp2) {
 4352   vextracti64x4_high(vtmp2, src2);
 4353   reduce_operation_256(opcode, vtmp2, vtmp2, src2);
 4354   reduce4L(opcode, dst, src1, vtmp2, vtmp1, vtmp2);
 4355 }
 4356 #endif // _LP64
 4357 
 4358 void MacroAssembler::reduce2F(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp) {
 4359   reduce_operation_128(opcode, dst, src);
 4360   pshufd(vtmp, src, 0x1);
 4361   reduce_operation_128(opcode, dst, vtmp);
 4362 }
 4363 
 4364 void MacroAssembler::reduce4F(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp) {
 4365   reduce2F(opcode, dst, src, vtmp);
 4366   pshufd(vtmp, src, 0x2);
 4367   reduce_operation_128(opcode, dst, vtmp);
 4368   pshufd(vtmp, src, 0x3);
 4369   reduce_operation_128(opcode, dst, vtmp);
 4370 }
 4371 
 4372 void MacroAssembler::reduce8F(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp1, XMMRegister vtmp2) {
 4373   reduce4F(opcode, dst, src, vtmp2);
 4374   vextractf128_high(vtmp2, src);
 4375   reduce4F(opcode, dst, vtmp2, vtmp1);
 4376 }
 4377 
 4378 void MacroAssembler::reduce16F(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp1, XMMRegister vtmp2) {
 4379   reduce8F(opcode, dst, src, vtmp1, vtmp2);
 4380   vextracti64x4_high(vtmp1, src);
 4381   reduce8F(opcode, dst, vtmp1, vtmp1, vtmp2);
 4382 }
 4383 
 4384 void MacroAssembler::reduce2D(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp) {
 4385   reduce_operation_128(opcode, dst, src);
 4386   pshufd(vtmp, src, 0xE);
 4387   reduce_operation_128(opcode, dst, vtmp);
 4388 }
 4389 
 4390 void MacroAssembler::reduce4D(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp1, XMMRegister vtmp2) {
 4391   reduce2D(opcode, dst, src, vtmp2);
 4392   vextractf128_high(vtmp2, src);
 4393   reduce2D(opcode, dst, vtmp2, vtmp1);
 4394 }
 4395 
 4396 void MacroAssembler::reduce8D(int opcode, XMMRegister dst, XMMRegister src, XMMRegister vtmp1, XMMRegister vtmp2) {
 4397   reduce4D(opcode, dst, src, vtmp1, vtmp2);
 4398   vextracti64x4_high(vtmp1, src);
 4399   reduce4D(opcode, dst, vtmp1, vtmp1, vtmp2);
 4400 }
 4401 #endif
 4402 
 4403 //-------------------------------------------------------------------------------------------
 4404 
 4405 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
 4406   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
 4407   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
 4408   // The inverted mask is sign-extended
 4409   andptr(possibly_jweak, inverted_jweak_mask);
 4410 }
 4411 
 4412 void MacroAssembler::resolve_jobject(Register value,
 4413                                      Register thread,
 4414                                      Register tmp) {
 4415   assert_different_registers(value, thread, tmp);
 4416   Label done, not_weak;
 4417   testptr(value, value);
 4418   jcc(Assembler::zero, done);                // Use NULL as-is.
 4419   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
 4420   jcc(Assembler::zero, not_weak);
 4421   // Resolve jweak.
 4422   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
 4423                  value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);
 4424   verify_oop(value);
 4425   jmp(done);
 4426   bind(not_weak);
 4427   // Resolve (untagged) jobject.
 4428   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
 4429   verify_oop(value);
 4430   bind(done);
 4431 }
 4432 
 4433 void MacroAssembler::subptr(Register dst, int32_t imm32) {
 4434   LP64_ONLY(subq(dst, imm32)) NOT_LP64(subl(dst, imm32));
 4435 }
 4436 
 4437 // Force generation of a 4 byte immediate value even if it fits into 8bit
 4438 void MacroAssembler::subptr_imm32(Register dst, int32_t imm32) {
 4439   LP64_ONLY(subq_imm32(dst, imm32)) NOT_LP64(subl_imm32(dst, imm32));
 4440 }
 4441 
 4442 void MacroAssembler::subptr(Register dst, Register src) {
 4443   LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src));
 4444 }
 4445 
 4446 // C++ bool manipulation
 4447 void MacroAssembler::testbool(Register dst) {
 4448   if(sizeof(bool) == 1)
 4449     testb(dst, 0xff);
 4450   else if(sizeof(bool) == 2) {
 4451     // testw implementation needed for two byte bools
 4452     ShouldNotReachHere();
 4453   } else if(sizeof(bool) == 4)
 4454     testl(dst, dst);
 4455   else
 4456     // unsupported
 4457     ShouldNotReachHere();
 4458 }
 4459 
 4460 void MacroAssembler::testptr(Register dst, Register src) {
 4461   LP64_ONLY(testq(dst, src)) NOT_LP64(testl(dst, src));
 4462 }
 4463 
 4464 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
 4465 void MacroAssembler::tlab_allocate(Register thread, Register obj,
 4466                                    Register var_size_in_bytes,
 4467                                    int con_size_in_bytes,
 4468                                    Register t1,
 4469                                    Register t2,
 4470                                    Label&amp; slow_case) {
 4471   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 4472   bs-&gt;tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
 4473 }
 4474 
 4475 // Defines obj, preserves var_size_in_bytes
 4476 void MacroAssembler::eden_allocate(Register thread, Register obj,
 4477                                    Register var_size_in_bytes,
 4478                                    int con_size_in_bytes,
 4479                                    Register t1,
 4480                                    Label&amp; slow_case) {
 4481   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 4482   bs-&gt;eden_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
 4483 }
 4484 
 4485 // Preserves the contents of address, destroys the contents length_in_bytes and temp.
 4486 void MacroAssembler::zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp) {
 4487   assert(address != length_in_bytes &amp;&amp; address != temp &amp;&amp; temp != length_in_bytes, &quot;registers must be different&quot;);
 4488   assert((offset_in_bytes &amp; (BytesPerWord - 1)) == 0, &quot;offset must be a multiple of BytesPerWord&quot;);
 4489   Label done;
 4490 
 4491   testptr(length_in_bytes, length_in_bytes);
 4492   jcc(Assembler::zero, done);
 4493 
 4494   // initialize topmost word, divide index by 2, check if odd and test if zero
 4495   // note: for the remaining code to work, index must be a multiple of BytesPerWord
 4496 #ifdef ASSERT
 4497   {
 4498     Label L;
 4499     testptr(length_in_bytes, BytesPerWord - 1);
 4500     jcc(Assembler::zero, L);
 4501     stop(&quot;length must be a multiple of BytesPerWord&quot;);
 4502     bind(L);
 4503   }
 4504 #endif
 4505   Register index = length_in_bytes;
 4506   xorptr(temp, temp);    // use _zero reg to clear memory (shorter code)
 4507   if (UseIncDec) {
 4508     shrptr(index, 3);  // divide by 8/16 and set carry flag if bit 2 was set
 4509   } else {
 4510     shrptr(index, 2);  // use 2 instructions to avoid partial flag stall
 4511     shrptr(index, 1);
 4512   }
 4513 #ifndef _LP64
 4514   // index could have not been a multiple of 8 (i.e., bit 2 was set)
 4515   {
 4516     Label even;
 4517     // note: if index was a multiple of 8, then it cannot
 4518     //       be 0 now otherwise it must have been 0 before
 4519     //       =&gt; if it is even, we don&#39;t need to check for 0 again
 4520     jcc(Assembler::carryClear, even);
 4521     // clear topmost word (no jump would be needed if conditional assignment worked here)
 4522     movptr(Address(address, index, Address::times_8, offset_in_bytes - 0*BytesPerWord), temp);
 4523     // index could be 0 now, must check again
 4524     jcc(Assembler::zero, done);
 4525     bind(even);
 4526   }
 4527 #endif // !_LP64
 4528   // initialize remaining object fields: index is a multiple of 2 now
 4529   {
 4530     Label loop;
 4531     bind(loop);
 4532     movptr(Address(address, index, Address::times_8, offset_in_bytes - 1*BytesPerWord), temp);
 4533     NOT_LP64(movptr(Address(address, index, Address::times_8, offset_in_bytes - 2*BytesPerWord), temp);)
 4534     decrement(index);
 4535     jcc(Assembler::notZero, loop);
 4536   }
 4537 
 4538   bind(done);
 4539 }
 4540 
 4541 // Look up the method for a megamorphic invokeinterface call.
 4542 // The target method is determined by &lt;intf_klass, itable_index&gt;.
 4543 // The receiver klass is in recv_klass.
 4544 // On success, the result will be in method_result, and execution falls through.
 4545 // On failure, execution transfers to the given label.
 4546 void MacroAssembler::lookup_interface_method(Register recv_klass,
 4547                                              Register intf_klass,
 4548                                              RegisterOrConstant itable_index,
 4549                                              Register method_result,
 4550                                              Register scan_temp,
 4551                                              Label&amp; L_no_such_interface,
 4552                                              bool return_method) {
 4553   assert_different_registers(recv_klass, intf_klass, scan_temp);
 4554   assert_different_registers(method_result, intf_klass, scan_temp);
 4555   assert(recv_klass != method_result || !return_method,
 4556          &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
 4557 
 4558   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
 4559          &quot;caller must use same register for non-constant itable index as for method&quot;);
 4560 
 4561   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
 4562   int vtable_base = in_bytes(Klass::vtable_start_offset());
 4563   int itentry_off = itableMethodEntry::method_offset_in_bytes();
 4564   int scan_step   = itableOffsetEntry::size() * wordSize;
 4565   int vte_size    = vtableEntry::size_in_bytes();
 4566   Address::ScaleFactor times_vte_scale = Address::times_ptr;
 4567   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
 4568 
 4569   movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
 4570 
 4571   // %%% Could store the aligned, prescaled offset in the klassoop.
 4572   lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
 4573 
 4574   if (return_method) {
 4575     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
 4576     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
 4577     lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
 4578   }
 4579 
 4580   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
 4581   //   if (scan-&gt;interface() == intf) {
 4582   //     result = (klass + scan-&gt;offset() + itable_index);
 4583   //   }
 4584   // }
 4585   Label search, found_method;
 4586 
 4587   for (int peel = 1; peel &gt;= 0; peel--) {
 4588     movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
 4589     cmpptr(intf_klass, method_result);
 4590 
 4591     if (peel) {
 4592       jccb(Assembler::equal, found_method);
 4593     } else {
 4594       jccb(Assembler::notEqual, search);
 4595       // (invert the test to fall through to found_method...)
 4596     }
 4597 
 4598     if (!peel)  break;
 4599 
 4600     bind(search);
 4601 
 4602     // Check that the previous entry is non-null.  A null entry means that
 4603     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
 4604     // same as when the caller was compiled.
 4605     testptr(method_result, method_result);
 4606     jcc(Assembler::zero, L_no_such_interface);
 4607     addptr(scan_temp, scan_step);
 4608   }
 4609 
 4610   bind(found_method);
 4611 
 4612   if (return_method) {
 4613     // Got a hit.
 4614     movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
 4615     movptr(method_result, Address(recv_klass, scan_temp, Address::times_1));
 4616   }
 4617 }
 4618 
 4619 
 4620 // virtual method calling
 4621 void MacroAssembler::lookup_virtual_method(Register recv_klass,
 4622                                            RegisterOrConstant vtable_index,
 4623                                            Register method_result) {
 4624   const int base = in_bytes(Klass::vtable_start_offset());
 4625   assert(vtableEntry::size() * wordSize == wordSize, &quot;else adjust the scaling in the code below&quot;);
 4626   Address vtable_entry_addr(recv_klass,
 4627                             vtable_index, Address::times_ptr,
 4628                             base + vtableEntry::method_offset_in_bytes());
 4629   movptr(method_result, vtable_entry_addr);
 4630 }
 4631 
 4632 
 4633 void MacroAssembler::check_klass_subtype(Register sub_klass,
 4634                            Register super_klass,
 4635                            Register temp_reg,
 4636                            Label&amp; L_success) {
 4637   Label L_failure;
 4638   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
 4639   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
 4640   bind(L_failure);
 4641 }
 4642 
 4643 
 4644 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
 4645                                                    Register super_klass,
 4646                                                    Register temp_reg,
 4647                                                    Label* L_success,
 4648                                                    Label* L_failure,
 4649                                                    Label* L_slow_path,
 4650                                         RegisterOrConstant super_check_offset) {
 4651   assert_different_registers(sub_klass, super_klass, temp_reg);
 4652   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
 4653   if (super_check_offset.is_register()) {
 4654     assert_different_registers(sub_klass, super_klass,
 4655                                super_check_offset.as_register());
 4656   } else if (must_load_sco) {
 4657     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
 4658   }
 4659 
 4660   Label L_fallthrough;
 4661   int label_nulls = 0;
 4662   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
 4663   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
 4664   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
 4665   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
 4666 
 4667   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
 4668   int sco_offset = in_bytes(Klass::super_check_offset_offset());
 4669   Address super_check_offset_addr(super_klass, sco_offset);
 4670 
 4671   // Hacked jcc, which &quot;knows&quot; that L_fallthrough, at least, is in
 4672   // range of a jccb.  If this routine grows larger, reconsider at
 4673   // least some of these.
 4674 #define local_jcc(assembler_cond, label)                                \
 4675   if (&amp;(label) == &amp;L_fallthrough)  jccb(assembler_cond, label);         \
 4676   else                             jcc( assembler_cond, label) /*omit semi*/
 4677 
 4678   // Hacked jmp, which may only be used just before L_fallthrough.
 4679 #define final_jmp(label)                                                \
 4680   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
 4681   else                            jmp(label)                /*omit semi*/
 4682 
 4683   // If the pointers are equal, we are done (e.g., String[] elements).
 4684   // This self-check enables sharing of secondary supertype arrays among
 4685   // non-primary types such as array-of-interface.  Otherwise, each such
 4686   // type would need its own customized SSA.
 4687   // We move this check to the front of the fast path because many
 4688   // type checks are in fact trivially successful in this manner,
 4689   // so we get a nicely predicted branch right at the start of the check.
 4690   cmpptr(sub_klass, super_klass);
 4691   local_jcc(Assembler::equal, *L_success);
 4692 
 4693   // Check the supertype display:
 4694   if (must_load_sco) {
 4695     // Positive movl does right thing on LP64.
 4696     movl(temp_reg, super_check_offset_addr);
 4697     super_check_offset = RegisterOrConstant(temp_reg);
 4698   }
 4699   Address super_check_addr(sub_klass, super_check_offset, Address::times_1, 0);
 4700   cmpptr(super_klass, super_check_addr); // load displayed supertype
 4701 
 4702   // This check has worked decisively for primary supers.
 4703   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
 4704   // (Secondary supers are interfaces and very deeply nested subtypes.)
 4705   // This works in the same check above because of a tricky aliasing
 4706   // between the super_cache and the primary super display elements.
 4707   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
 4708   // Note that the cache is updated below if it does not help us find
 4709   // what we need immediately.
 4710   // So if it was a primary super, we can just fail immediately.
 4711   // Otherwise, it&#39;s the slow path for us (no success at this point).
 4712 
 4713   if (super_check_offset.is_register()) {
 4714     local_jcc(Assembler::equal, *L_success);
 4715     cmpl(super_check_offset.as_register(), sc_offset);
 4716     if (L_failure == &amp;L_fallthrough) {
 4717       local_jcc(Assembler::equal, *L_slow_path);
 4718     } else {
 4719       local_jcc(Assembler::notEqual, *L_failure);
 4720       final_jmp(*L_slow_path);
 4721     }
 4722   } else if (super_check_offset.as_constant() == sc_offset) {
 4723     // Need a slow path; fast failure is impossible.
 4724     if (L_slow_path == &amp;L_fallthrough) {
 4725       local_jcc(Assembler::equal, *L_success);
 4726     } else {
 4727       local_jcc(Assembler::notEqual, *L_slow_path);
 4728       final_jmp(*L_success);
 4729     }
 4730   } else {
 4731     // No slow path; it&#39;s a fast decision.
 4732     if (L_failure == &amp;L_fallthrough) {
 4733       local_jcc(Assembler::equal, *L_success);
 4734     } else {
 4735       local_jcc(Assembler::notEqual, *L_failure);
 4736       final_jmp(*L_success);
 4737     }
 4738   }
 4739 
 4740   bind(L_fallthrough);
 4741 
 4742 #undef local_jcc
 4743 #undef final_jmp
 4744 }
 4745 
 4746 
 4747 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
 4748                                                    Register super_klass,
 4749                                                    Register temp_reg,
 4750                                                    Register temp2_reg,
 4751                                                    Label* L_success,
 4752                                                    Label* L_failure,
 4753                                                    bool set_cond_codes) {
 4754   assert_different_registers(sub_klass, super_klass, temp_reg);
 4755   if (temp2_reg != noreg)
 4756     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg);
 4757 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
 4758 
 4759   Label L_fallthrough;
 4760   int label_nulls = 0;
 4761   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
 4762   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
 4763   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
 4764 
 4765   // a couple of useful fields in sub_klass:
 4766   int ss_offset = in_bytes(Klass::secondary_supers_offset());
 4767   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
 4768   Address secondary_supers_addr(sub_klass, ss_offset);
 4769   Address super_cache_addr(     sub_klass, sc_offset);
 4770 
 4771   // Do a linear scan of the secondary super-klass chain.
 4772   // This code is rarely used, so simplicity is a virtue here.
 4773   // The repne_scan instruction uses fixed registers, which we must spill.
 4774   // Don&#39;t worry too much about pre-existing connections with the input regs.
 4775 
 4776   assert(sub_klass != rax, &quot;killed reg&quot;); // killed by mov(rax, super)
 4777   assert(sub_klass != rcx, &quot;killed reg&quot;); // killed by lea(rcx, &amp;pst_counter)
 4778 
 4779   // Get super_klass value into rax (even if it was in rdi or rcx).
 4780   bool pushed_rax = false, pushed_rcx = false, pushed_rdi = false;
 4781   if (super_klass != rax || UseCompressedOops) {
 4782     if (!IS_A_TEMP(rax)) { push(rax); pushed_rax = true; }
 4783     mov(rax, super_klass);
 4784   }
 4785   if (!IS_A_TEMP(rcx)) { push(rcx); pushed_rcx = true; }
 4786   if (!IS_A_TEMP(rdi)) { push(rdi); pushed_rdi = true; }
 4787 
 4788 #ifndef PRODUCT
 4789   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
 4790   ExternalAddress pst_counter_addr((address) pst_counter);
 4791   NOT_LP64(  incrementl(pst_counter_addr) );
 4792   LP64_ONLY( lea(rcx, pst_counter_addr) );
 4793   LP64_ONLY( incrementl(Address(rcx, 0)) );
 4794 #endif //PRODUCT
 4795 
 4796   // We will consult the secondary-super array.
 4797   movptr(rdi, secondary_supers_addr);
 4798   // Load the array length.  (Positive movl does right thing on LP64.)
 4799   movl(rcx, Address(rdi, Array&lt;Klass*&gt;::length_offset_in_bytes()));
 4800   // Skip to start of data.
 4801   addptr(rdi, Array&lt;Klass*&gt;::base_offset_in_bytes());
 4802 
 4803   // Scan RCX words at [RDI] for an occurrence of RAX.
 4804   // Set NZ/Z based on last compare.
 4805   // Z flag value will not be set by &#39;repne&#39; if RCX == 0 since &#39;repne&#39; does
 4806   // not change flags (only scas instruction which is repeated sets flags).
 4807   // Set Z = 0 (not equal) before &#39;repne&#39; to indicate that class was not found.
 4808 
 4809     testptr(rax,rax); // Set Z = 0
 4810     repne_scan();
 4811 
 4812   // Unspill the temp. registers:
 4813   if (pushed_rdi)  pop(rdi);
 4814   if (pushed_rcx)  pop(rcx);
 4815   if (pushed_rax)  pop(rax);
 4816 
 4817   if (set_cond_codes) {
 4818     // Special hack for the AD files:  rdi is guaranteed non-zero.
 4819     assert(!pushed_rdi, &quot;rdi must be left non-NULL&quot;);
 4820     // Also, the condition codes are properly set Z/NZ on succeed/failure.
 4821   }
 4822 
 4823   if (L_failure == &amp;L_fallthrough)
 4824         jccb(Assembler::notEqual, *L_failure);
 4825   else  jcc(Assembler::notEqual, *L_failure);
 4826 
 4827   // Success.  Cache the super we found and proceed in triumph.
 4828   movptr(super_cache_addr, super_klass);
 4829 
 4830   if (L_success != &amp;L_fallthrough) {
 4831     jmp(*L_success);
 4832   }
 4833 
 4834 #undef IS_A_TEMP
 4835 
 4836   bind(L_fallthrough);
 4837 }
 4838 
 4839 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
 4840   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
 4841 
 4842   Label L_fallthrough;
 4843   if (L_fast_path == NULL) {
 4844     L_fast_path = &amp;L_fallthrough;
 4845   } else if (L_slow_path == NULL) {
 4846     L_slow_path = &amp;L_fallthrough;
 4847   }
 4848 
 4849   // Fast path check: class is fully initialized
 4850   cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
 4851   jcc(Assembler::equal, *L_fast_path);
 4852 
 4853   // Fast path check: current thread is initializer thread
 4854   cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));
 4855   if (L_slow_path == &amp;L_fallthrough) {
 4856     jcc(Assembler::equal, *L_fast_path);
 4857     bind(*L_slow_path);
 4858   } else if (L_fast_path == &amp;L_fallthrough) {
 4859     jcc(Assembler::notEqual, *L_slow_path);
 4860     bind(*L_fast_path);
 4861   } else {
 4862     Unimplemented();
 4863   }
 4864 }
 4865 
 4866 void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
 4867   if (VM_Version::supports_cmov()) {
 4868     cmovl(cc, dst, src);
 4869   } else {
 4870     Label L;
 4871     jccb(negate_condition(cc), L);
 4872     movl(dst, src);
 4873     bind(L);
 4874   }
 4875 }
 4876 
 4877 void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
 4878   if (VM_Version::supports_cmov()) {
 4879     cmovl(cc, dst, src);
 4880   } else {
 4881     Label L;
 4882     jccb(negate_condition(cc), L);
 4883     movl(dst, src);
 4884     bind(L);
 4885   }
 4886 }
 4887 
 4888 void MacroAssembler::_verify_oop(Register reg, const char* s, const char* file, int line) {
 4889   if (!VerifyOops) return;
 4890 
 4891   // Pass register number to verify_oop_subroutine
 4892   const char* b = NULL;
 4893   {
 4894     ResourceMark rm;
 4895     stringStream ss;
 4896     ss.print(&quot;verify_oop: %s: %s (%s:%d)&quot;, reg-&gt;name(), s, file, line);
 4897     b = code_string(ss.as_string());
 4898   }
 4899   BLOCK_COMMENT(&quot;verify_oop {&quot;);
 4900 #ifdef _LP64
 4901   push(rscratch1);                    // save r10, trashed by movptr()
 4902 #endif
 4903   push(rax);                          // save rax,
 4904   push(reg);                          // pass register argument
 4905   ExternalAddress buffer((address) b);
 4906   // avoid using pushptr, as it modifies scratch registers
 4907   // and our contract is not to modify anything
 4908   movptr(rax, buffer.addr());
 4909   push(rax);
 4910   // call indirectly to solve generation ordering problem
 4911   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
 4912   call(rax);
 4913   // Caller pops the arguments (oop, message) and restores rax, r10
 4914   BLOCK_COMMENT(&quot;} verify_oop&quot;);
 4915 }
 4916 
 4917 
 4918 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
 4919                                                       Register tmp,
 4920                                                       int offset) {
 4921   intptr_t value = *delayed_value_addr;
 4922   if (value != 0)
 4923     return RegisterOrConstant(value + offset);
 4924 
 4925   // load indirectly to solve generation ordering problem
 4926   movptr(tmp, ExternalAddress((address) delayed_value_addr));
 4927 
 4928 #ifdef ASSERT
 4929   { Label L;
 4930     testptr(tmp, tmp);
 4931     if (WizardMode) {
 4932       const char* buf = NULL;
 4933       {
 4934         ResourceMark rm;
 4935         stringStream ss;
 4936         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
 4937         buf = code_string(ss.as_string());
 4938       }
 4939       jcc(Assembler::notZero, L);
 4940       STOP(buf);
 4941     } else {
 4942       jccb(Assembler::notZero, L);
 4943       hlt();
 4944     }
 4945     bind(L);
 4946   }
 4947 #endif
 4948 
 4949   if (offset != 0)
 4950     addptr(tmp, offset);
 4951 
 4952   return RegisterOrConstant(tmp);
 4953 }
 4954 
 4955 
 4956 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
 4957                                          int extra_slot_offset) {
 4958   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
 4959   int stackElementSize = Interpreter::stackElementSize;
 4960   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
 4961 #ifdef ASSERT
 4962   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
 4963   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
 4964 #endif
 4965   Register             scale_reg    = noreg;
 4966   Address::ScaleFactor scale_factor = Address::no_scale;
 4967   if (arg_slot.is_constant()) {
 4968     offset += arg_slot.as_constant() * stackElementSize;
 4969   } else {
 4970     scale_reg    = arg_slot.as_register();
 4971     scale_factor = Address::times(stackElementSize);
 4972   }
 4973   offset += wordSize;           // return PC is on stack
 4974   return Address(rsp, scale_reg, scale_factor, offset);
 4975 }
 4976 
 4977 
 4978 void MacroAssembler::_verify_oop_addr(Address addr, const char* s, const char* file, int line) {
 4979   if (!VerifyOops) return;
 4980 
 4981   // Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);
 4982   // Pass register number to verify_oop_subroutine
 4983   const char* b = NULL;
 4984   {
 4985     ResourceMark rm;
 4986     stringStream ss;
 4987     ss.print(&quot;verify_oop_addr: %s (%s:%d)&quot;, s, file, line);
 4988     b = code_string(ss.as_string());
 4989   }
 4990 #ifdef _LP64
 4991   push(rscratch1);                    // save r10, trashed by movptr()
 4992 #endif
 4993   push(rax);                          // save rax,
 4994   // addr may contain rsp so we will have to adjust it based on the push
 4995   // we just did (and on 64 bit we do two pushes)
 4996   // NOTE: 64bit seemed to have had a bug in that it did movq(addr, rax); which
 4997   // stores rax into addr which is backwards of what was intended.
 4998   if (addr.uses(rsp)) {
 4999     lea(rax, addr);
 5000     pushptr(Address(rax, LP64_ONLY(2 *) BytesPerWord));
 5001   } else {
 5002     pushptr(addr);
 5003   }
 5004 
 5005   ExternalAddress buffer((address) b);
 5006   // pass msg argument
 5007   // avoid using pushptr, as it modifies scratch registers
 5008   // and our contract is not to modify anything
 5009   movptr(rax, buffer.addr());
 5010   push(rax);
 5011 
 5012   // call indirectly to solve generation ordering problem
 5013   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
 5014   call(rax);
 5015   // Caller pops the arguments (addr, message) and restores rax, r10.
 5016 }
 5017 
 5018 void MacroAssembler::verify_tlab() {
 5019 #ifdef ASSERT
 5020   if (UseTLAB &amp;&amp; VerifyOops) {
 5021     Label next, ok;
 5022     Register t1 = rsi;
 5023     Register thread_reg = NOT_LP64(rbx) LP64_ONLY(r15_thread);
 5024 
 5025     push(t1);
 5026     NOT_LP64(push(thread_reg));
 5027     NOT_LP64(get_thread(thread_reg));
 5028 
 5029     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
 5030     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_start_offset())));
 5031     jcc(Assembler::aboveEqual, next);
 5032     STOP(&quot;assert(top &gt;= start)&quot;);
 5033     should_not_reach_here();
 5034 
 5035     bind(next);
 5036     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_end_offset())));
 5037     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
 5038     jcc(Assembler::aboveEqual, ok);
 5039     STOP(&quot;assert(top &lt;= end)&quot;);
 5040     should_not_reach_here();
 5041 
 5042     bind(ok);
 5043     NOT_LP64(pop(thread_reg));
 5044     pop(t1);
 5045   }
 5046 #endif
 5047 }
 5048 
 5049 class ControlWord {
 5050  public:
 5051   int32_t _value;
 5052 
 5053   int  rounding_control() const        { return  (_value &gt;&gt; 10) &amp; 3      ; }
 5054   int  precision_control() const       { return  (_value &gt;&gt;  8) &amp; 3      ; }
 5055   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
 5056   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
 5057   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
 5058   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
 5059   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
 5060   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
 5061 
 5062   void print() const {
 5063     // rounding control
 5064     const char* rc;
 5065     switch (rounding_control()) {
 5066       case 0: rc = &quot;round near&quot;; break;
 5067       case 1: rc = &quot;round down&quot;; break;
 5068       case 2: rc = &quot;round up  &quot;; break;
 5069       case 3: rc = &quot;chop      &quot;; break;
 5070     };
 5071     // precision control
 5072     const char* pc;
 5073     switch (precision_control()) {
 5074       case 0: pc = &quot;24 bits &quot;; break;
 5075       case 1: pc = &quot;reserved&quot;; break;
 5076       case 2: pc = &quot;53 bits &quot;; break;
 5077       case 3: pc = &quot;64 bits &quot;; break;
 5078     };
 5079     // flags
 5080     char f[9];
 5081     f[0] = &#39; &#39;;
 5082     f[1] = &#39; &#39;;
 5083     f[2] = (precision   ()) ? &#39;P&#39; : &#39;p&#39;;
 5084     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;u&#39;;
 5085     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;o&#39;;
 5086     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;z&#39;;
 5087     f[6] = (denormalized()) ? &#39;D&#39; : &#39;d&#39;;
 5088     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;i&#39;;
 5089     f[8] = &#39;\x0&#39;;
 5090     // output
 5091     printf(&quot;%04x  masks = %s, %s, %s&quot;, _value &amp; 0xFFFF, f, rc, pc);
 5092   }
 5093 
 5094 };
 5095 
 5096 class StatusWord {
 5097  public:
 5098   int32_t _value;
 5099 
 5100   bool busy() const                    { return ((_value &gt;&gt; 15) &amp; 1) != 0; }
 5101   bool C3() const                      { return ((_value &gt;&gt; 14) &amp; 1) != 0; }
 5102   bool C2() const                      { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
 5103   bool C1() const                      { return ((_value &gt;&gt;  9) &amp; 1) != 0; }
 5104   bool C0() const                      { return ((_value &gt;&gt;  8) &amp; 1) != 0; }
 5105   int  top() const                     { return  (_value &gt;&gt; 11) &amp; 7      ; }
 5106   bool error_status() const            { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
 5107   bool stack_fault() const             { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
 5108   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
 5109   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
 5110   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
 5111   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
 5112   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
 5113   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
 5114 
 5115   void print() const {
 5116     // condition codes
 5117     char c[5];
 5118     c[0] = (C3()) ? &#39;3&#39; : &#39;-&#39;;
 5119     c[1] = (C2()) ? &#39;2&#39; : &#39;-&#39;;
 5120     c[2] = (C1()) ? &#39;1&#39; : &#39;-&#39;;
 5121     c[3] = (C0()) ? &#39;0&#39; : &#39;-&#39;;
 5122     c[4] = &#39;\x0&#39;;
 5123     // flags
 5124     char f[9];
 5125     f[0] = (error_status()) ? &#39;E&#39; : &#39;-&#39;;
 5126     f[1] = (stack_fault ()) ? &#39;S&#39; : &#39;-&#39;;
 5127     f[2] = (precision   ()) ? &#39;P&#39; : &#39;-&#39;;
 5128     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;-&#39;;
 5129     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;-&#39;;
 5130     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;-&#39;;
 5131     f[6] = (denormalized()) ? &#39;D&#39; : &#39;-&#39;;
 5132     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;-&#39;;
 5133     f[8] = &#39;\x0&#39;;
 5134     // output
 5135     printf(&quot;%04x  flags = %s, cc =  %s, top = %d&quot;, _value &amp; 0xFFFF, f, c, top());
 5136   }
 5137 
 5138 };
 5139 
 5140 class TagWord {
 5141  public:
 5142   int32_t _value;
 5143 
 5144   int tag_at(int i) const              { return (_value &gt;&gt; (i*2)) &amp; 3; }
 5145 
 5146   void print() const {
 5147     printf(&quot;%04x&quot;, _value &amp; 0xFFFF);
 5148   }
 5149 
 5150 };
 5151 
 5152 class FPU_Register {
 5153  public:
 5154   int32_t _m0;
 5155   int32_t _m1;
 5156   int16_t _ex;
 5157 
 5158   bool is_indefinite() const           {
 5159     return _ex == -1 &amp;&amp; _m1 == (int32_t)0xC0000000 &amp;&amp; _m0 == 0;
 5160   }
 5161 
 5162   void print() const {
 5163     char  sign = (_ex &lt; 0) ? &#39;-&#39; : &#39;+&#39;;
 5164     const char* kind = (_ex == 0x7FFF || _ex == (int16_t)-1) ? &quot;NaN&quot; : &quot;   &quot;;
 5165     printf(&quot;%c%04hx.%08x%08x  %s&quot;, sign, _ex, _m1, _m0, kind);
 5166   };
 5167 
 5168 };
 5169 
 5170 class FPU_State {
 5171  public:
 5172   enum {
 5173     register_size       = 10,
 5174     number_of_registers =  8,
 5175     register_mask       =  7
 5176   };
 5177 
 5178   ControlWord  _control_word;
 5179   StatusWord   _status_word;
 5180   TagWord      _tag_word;
 5181   int32_t      _error_offset;
 5182   int32_t      _error_selector;
 5183   int32_t      _data_offset;
 5184   int32_t      _data_selector;
 5185   int8_t       _register[register_size * number_of_registers];
 5186 
 5187   int tag_for_st(int i) const          { return _tag_word.tag_at((_status_word.top() + i) &amp; register_mask); }
 5188   FPU_Register* st(int i) const        { return (FPU_Register*)&amp;_register[register_size * i]; }
 5189 
 5190   const char* tag_as_string(int tag) const {
 5191     switch (tag) {
 5192       case 0: return &quot;valid&quot;;
 5193       case 1: return &quot;zero&quot;;
 5194       case 2: return &quot;special&quot;;
 5195       case 3: return &quot;empty&quot;;
 5196     }
 5197     ShouldNotReachHere();
 5198     return NULL;
 5199   }
 5200 
 5201   void print() const {
 5202     // print computation registers
 5203     { int t = _status_word.top();
 5204       for (int i = 0; i &lt; number_of_registers; i++) {
 5205         int j = (i - t) &amp; register_mask;
 5206         printf(&quot;%c r%d = ST%d = &quot;, (j == 0 ? &#39;*&#39; : &#39; &#39;), i, j);
 5207         st(j)-&gt;print();
 5208         printf(&quot; %s\n&quot;, tag_as_string(_tag_word.tag_at(i)));
 5209       }
 5210     }
 5211     printf(&quot;\n&quot;);
 5212     // print control registers
 5213     printf(&quot;ctrl = &quot;); _control_word.print(); printf(&quot;\n&quot;);
 5214     printf(&quot;stat = &quot;); _status_word .print(); printf(&quot;\n&quot;);
 5215     printf(&quot;tags = &quot;); _tag_word    .print(); printf(&quot;\n&quot;);
 5216   }
 5217 
 5218 };
 5219 
 5220 class Flag_Register {
 5221  public:
 5222   int32_t _value;
 5223 
 5224   bool overflow() const                { return ((_value &gt;&gt; 11) &amp; 1) != 0; }
 5225   bool direction() const               { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
 5226   bool sign() const                    { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
 5227   bool zero() const                    { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
 5228   bool auxiliary_carry() const         { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
 5229   bool parity() const                  { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
 5230   bool carry() const                   { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
 5231 
 5232   void print() const {
 5233     // flags
 5234     char f[8];
 5235     f[0] = (overflow       ()) ? &#39;O&#39; : &#39;-&#39;;
 5236     f[1] = (direction      ()) ? &#39;D&#39; : &#39;-&#39;;
 5237     f[2] = (sign           ()) ? &#39;S&#39; : &#39;-&#39;;
 5238     f[3] = (zero           ()) ? &#39;Z&#39; : &#39;-&#39;;
 5239     f[4] = (auxiliary_carry()) ? &#39;A&#39; : &#39;-&#39;;
 5240     f[5] = (parity         ()) ? &#39;P&#39; : &#39;-&#39;;
 5241     f[6] = (carry          ()) ? &#39;C&#39; : &#39;-&#39;;
 5242     f[7] = &#39;\x0&#39;;
 5243     // output
 5244     printf(&quot;%08x  flags = %s&quot;, _value, f);
 5245   }
 5246 
 5247 };
 5248 
 5249 class IU_Register {
 5250  public:
 5251   int32_t _value;
 5252 
 5253   void print() const {
 5254     printf(&quot;%08x  %11d&quot;, _value, _value);
 5255   }
 5256 
 5257 };
 5258 
 5259 class IU_State {
 5260  public:
 5261   Flag_Register _eflags;
 5262   IU_Register   _rdi;
 5263   IU_Register   _rsi;
 5264   IU_Register   _rbp;
 5265   IU_Register   _rsp;
 5266   IU_Register   _rbx;
 5267   IU_Register   _rdx;
 5268   IU_Register   _rcx;
 5269   IU_Register   _rax;
 5270 
 5271   void print() const {
 5272     // computation registers
 5273     printf(&quot;rax,  = &quot;); _rax.print(); printf(&quot;\n&quot;);
 5274     printf(&quot;rbx,  = &quot;); _rbx.print(); printf(&quot;\n&quot;);
 5275     printf(&quot;rcx  = &quot;); _rcx.print(); printf(&quot;\n&quot;);
 5276     printf(&quot;rdx  = &quot;); _rdx.print(); printf(&quot;\n&quot;);
 5277     printf(&quot;rdi  = &quot;); _rdi.print(); printf(&quot;\n&quot;);
 5278     printf(&quot;rsi  = &quot;); _rsi.print(); printf(&quot;\n&quot;);
 5279     printf(&quot;rbp,  = &quot;); _rbp.print(); printf(&quot;\n&quot;);
 5280     printf(&quot;rsp  = &quot;); _rsp.print(); printf(&quot;\n&quot;);
 5281     printf(&quot;\n&quot;);
 5282     // control registers
 5283     printf(&quot;flgs = &quot;); _eflags.print(); printf(&quot;\n&quot;);
 5284   }
 5285 };
 5286 
 5287 
 5288 class CPU_State {
 5289  public:
 5290   FPU_State _fpu_state;
 5291   IU_State  _iu_state;
 5292 
 5293   void print() const {
 5294     printf(&quot;--------------------------------------------------\n&quot;);
 5295     _iu_state .print();
 5296     printf(&quot;\n&quot;);
 5297     _fpu_state.print();
 5298     printf(&quot;--------------------------------------------------\n&quot;);
 5299   }
 5300 
 5301 };
 5302 
 5303 
 5304 static void _print_CPU_state(CPU_State* state) {
 5305   state-&gt;print();
 5306 };
 5307 
 5308 
 5309 void MacroAssembler::print_CPU_state() {
 5310   push_CPU_state();
 5311   push(rsp);                // pass CPU state
 5312   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _print_CPU_state)));
 5313   addptr(rsp, wordSize);       // discard argument
 5314   pop_CPU_state();
 5315 }
 5316 
 5317 
 5318 #ifndef _LP64
 5319 static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {
 5320   static int counter = 0;
 5321   FPU_State* fs = &amp;state-&gt;_fpu_state;
 5322   counter++;
 5323   // For leaf calls, only verify that the top few elements remain empty.
 5324   // We only need 1 empty at the top for C2 code.
 5325   if( stack_depth &lt; 0 ) {
 5326     if( fs-&gt;tag_for_st(7) != 3 ) {
 5327       printf(&quot;FPR7 not empty\n&quot;);
 5328       state-&gt;print();
 5329       assert(false, &quot;error&quot;);
 5330       return false;
 5331     }
 5332     return true;                // All other stack states do not matter
 5333   }
 5334 
 5335   assert((fs-&gt;_control_word._value &amp; 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,
 5336          &quot;bad FPU control word&quot;);
 5337 
 5338   // compute stack depth
 5339   int i = 0;
 5340   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i)  &lt; 3) i++;
 5341   int d = i;
 5342   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i) == 3) i++;
 5343   // verify findings
 5344   if (i != FPU_State::number_of_registers) {
 5345     // stack not contiguous
 5346     printf(&quot;%s: stack not contiguous at ST%d\n&quot;, s, i);
 5347     state-&gt;print();
 5348     assert(false, &quot;error&quot;);
 5349     return false;
 5350   }
 5351   // check if computed stack depth corresponds to expected stack depth
 5352   if (stack_depth &lt; 0) {
 5353     // expected stack depth is -stack_depth or less
 5354     if (d &gt; -stack_depth) {
 5355       // too many elements on the stack
 5356       printf(&quot;%s: &lt;= %d stack elements expected but found %d\n&quot;, s, -stack_depth, d);
 5357       state-&gt;print();
 5358       assert(false, &quot;error&quot;);
 5359       return false;
 5360     }
 5361   } else {
 5362     // expected stack depth is stack_depth
 5363     if (d != stack_depth) {
 5364       // wrong stack depth
 5365       printf(&quot;%s: %d stack elements expected but found %d\n&quot;, s, stack_depth, d);
 5366       state-&gt;print();
 5367       assert(false, &quot;error&quot;);
 5368       return false;
 5369     }
 5370   }
 5371   // everything is cool
 5372   return true;
 5373 }
 5374 
 5375 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {
 5376   if (!VerifyFPU) return;
 5377   push_CPU_state();
 5378   push(rsp);                // pass CPU state
 5379   ExternalAddress msg((address) s);
 5380   // pass message string s
 5381   pushptr(msg.addr());
 5382   push(stack_depth);        // pass stack depth
 5383   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));
 5384   addptr(rsp, 3 * wordSize);   // discard arguments
 5385   // check for error
 5386   { Label L;
 5387     testl(rax, rax);
 5388     jcc(Assembler::notZero, L);
 5389     int3();                  // break if error condition
 5390     bind(L);
 5391   }
 5392   pop_CPU_state();
 5393 }
 5394 #endif // _LP64
 5395 
 5396 void MacroAssembler::restore_cpu_control_state_after_jni() {
 5397   // Either restore the MXCSR register after returning from the JNI Call
 5398   // or verify that it wasn&#39;t changed (with -Xcheck:jni flag).
 5399   if (VM_Version::supports_sse()) {
 5400     if (RestoreMXCSROnJNICalls) {
 5401       ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));
 5402     } else if (CheckJNICalls) {
 5403       call(RuntimeAddress(StubRoutines::x86::verify_mxcsr_entry()));
 5404     }
 5405   }
 5406   // Clear upper bits of YMM registers to avoid SSE &lt;-&gt; AVX transition penalty.
 5407   vzeroupper();
 5408   // Reset k1 to 0xffff.
 5409 
 5410 #ifdef COMPILER2
 5411   if (PostLoopMultiversioning &amp;&amp; VM_Version::supports_evex()) {
 5412     push(rcx);
 5413     movl(rcx, 0xffff);
 5414     kmovwl(k1, rcx);
 5415     pop(rcx);
 5416   }
 5417 #endif // COMPILER2
 5418 
 5419 #ifndef _LP64
 5420   // Either restore the x87 floating pointer control word after returning
 5421   // from the JNI call or verify that it wasn&#39;t changed.
 5422   if (CheckJNICalls) {
 5423     call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));
 5424   }
 5425 #endif // _LP64
 5426 }
 5427 
 5428 // ((OopHandle)result).resolve();
 5429 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
 5430   assert_different_registers(result, tmp);
 5431 
 5432   // Only 64 bit platforms support GCs that require a tmp register
 5433   // Only IN_HEAP loads require a thread_tmp register
 5434   // OopHandle::resolve is an indirection like jobject.
 5435   access_load_at(T_OBJECT, IN_NATIVE,
 5436                  result, Address(result, 0), tmp, /*tmp_thread*/noreg);
 5437 }
 5438 
 5439 // ((WeakHandle)result).resolve();
 5440 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
 5441   assert_different_registers(rresult, rtmp);
 5442   Label resolved;
 5443 
 5444   // A null weak handle resolves to null.
 5445   cmpptr(rresult, 0);
 5446   jcc(Assembler::equal, resolved);
 5447 
 5448   // Only 64 bit platforms support GCs that require a tmp register
 5449   // Only IN_HEAP loads require a thread_tmp register
 5450   // WeakHandle::resolve is an indirection like jweak.
 5451   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
 5452                  rresult, Address(rresult, 0), rtmp, /*tmp_thread*/noreg);
 5453   bind(resolved);
 5454 }
 5455 
 5456 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
 5457   // get mirror
 5458   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
 5459   load_method_holder(mirror, method);
 5460   movptr(mirror, Address(mirror, mirror_offset));
 5461   resolve_oop_handle(mirror, tmp);
 5462 }
 5463 
 5464 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
 5465   load_method_holder(rresult, rmethod);
 5466   movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
 5467 }
 5468 
 5469 void MacroAssembler::load_method_holder(Register holder, Register method) {
 5470   movptr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
 5471   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
 5472   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
 5473 }
 5474 
 5475 void MacroAssembler::load_klass(Register dst, Register src) {
 5476 #ifdef _LP64
 5477   if (UseCompressedClassPointers) {
 5478     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
 5479     decode_klass_not_null(dst);
 5480   } else
 5481 #endif
 5482     movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
 5483 }
 5484 
 5485 void MacroAssembler::load_prototype_header(Register dst, Register src) {
 5486   load_klass(dst, src);
 5487   movptr(dst, Address(dst, Klass::prototype_header_offset()));
 5488 }
 5489 
 5490 void MacroAssembler::store_klass(Register dst, Register src) {
 5491 #ifdef _LP64
 5492   if (UseCompressedClassPointers) {
 5493     encode_klass_not_null(src);
 5494     movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
 5495   } else
 5496 #endif
 5497     movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
 5498 }
 5499 
 5500 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 5501                                     Register tmp1, Register thread_tmp) {
 5502   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 5503   decorators = AccessInternal::decorator_fixup(decorators);
 5504   bool as_raw = (decorators &amp; AS_RAW) != 0;
 5505   if (as_raw) {
 5506     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
 5507   } else {
 5508     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
 5509   }
 5510 }
 5511 
 5512 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 5513                                      Register tmp1, Register tmp2) {
 5514   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 5515   decorators = AccessInternal::decorator_fixup(decorators);
 5516   bool as_raw = (decorators &amp; AS_RAW) != 0;
 5517   if (as_raw) {
 5518     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2);
 5519   } else {
 5520     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, tmp2);
 5521   }
 5522 }
 5523 
 5524 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
 5525   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
 5526   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
 5527     decorators |= ACCESS_READ | ACCESS_WRITE;
 5528   }
 5529   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 5530   return bs-&gt;resolve(this, decorators, obj);
 5531 }
 5532 
 5533 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
 5534                                    Register thread_tmp, DecoratorSet decorators) {
 5535   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
 5536 }
 5537 
 5538 // Doesn&#39;t do verfication, generates fixed size code
 5539 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
 5540                                             Register thread_tmp, DecoratorSet decorators) {
 5541   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
 5542 }
 5543 
 5544 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
 5545                                     Register tmp2, DecoratorSet decorators) {
 5546   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2);
 5547 }
 5548 
 5549 // Used for storing NULLs.
 5550 void MacroAssembler::store_heap_oop_null(Address dst) {
 5551   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);
 5552 }
 5553 
 5554 #ifdef _LP64
 5555 void MacroAssembler::store_klass_gap(Register dst, Register src) {
 5556   if (UseCompressedClassPointers) {
 5557     // Store to klass gap in destination
 5558     movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
 5559   }
 5560 }
 5561 
 5562 #ifdef ASSERT
 5563 void MacroAssembler::verify_heapbase(const char* msg) {
 5564   assert (UseCompressedOops, &quot;should be compressed&quot;);
 5565   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5566   if (CheckCompressedOops) {
 5567     Label ok;
 5568     push(rscratch1); // cmpptr trashes rscratch1
 5569     cmpptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
 5570     jcc(Assembler::equal, ok);
 5571     STOP(msg);
 5572     bind(ok);
 5573     pop(rscratch1);
 5574   }
 5575 }
 5576 #endif
 5577 
 5578 // Algorithm must match oop.inline.hpp encode_heap_oop.
 5579 void MacroAssembler::encode_heap_oop(Register r) {
 5580 #ifdef ASSERT
 5581   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
 5582 #endif
 5583   verify_oop_msg(r, &quot;broken oop in encode_heap_oop&quot;);
 5584   if (CompressedOops::base() == NULL) {
 5585     if (CompressedOops::shift() != 0) {
 5586       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5587       shrq(r, LogMinObjAlignmentInBytes);
 5588     }
 5589     return;
 5590   }
 5591   testq(r, r);
 5592   cmovq(Assembler::equal, r, r12_heapbase);
 5593   subq(r, r12_heapbase);
 5594   shrq(r, LogMinObjAlignmentInBytes);
 5595 }
 5596 
 5597 void MacroAssembler::encode_heap_oop_not_null(Register r) {
 5598 #ifdef ASSERT
 5599   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
 5600   if (CheckCompressedOops) {
 5601     Label ok;
 5602     testq(r, r);
 5603     jcc(Assembler::notEqual, ok);
 5604     STOP(&quot;null oop passed to encode_heap_oop_not_null&quot;);
 5605     bind(ok);
 5606   }
 5607 #endif
 5608   verify_oop_msg(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
 5609   if (CompressedOops::base() != NULL) {
 5610     subq(r, r12_heapbase);
 5611   }
 5612   if (CompressedOops::shift() != 0) {
 5613     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5614     shrq(r, LogMinObjAlignmentInBytes);
 5615   }
 5616 }
 5617 
 5618 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
 5619 #ifdef ASSERT
 5620   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
 5621   if (CheckCompressedOops) {
 5622     Label ok;
 5623     testq(src, src);
 5624     jcc(Assembler::notEqual, ok);
 5625     STOP(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
 5626     bind(ok);
 5627   }
 5628 #endif
 5629   verify_oop_msg(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
 5630   if (dst != src) {
 5631     movq(dst, src);
 5632   }
 5633   if (CompressedOops::base() != NULL) {
 5634     subq(dst, r12_heapbase);
 5635   }
 5636   if (CompressedOops::shift() != 0) {
 5637     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5638     shrq(dst, LogMinObjAlignmentInBytes);
 5639   }
 5640 }
 5641 
 5642 void  MacroAssembler::decode_heap_oop(Register r) {
 5643 #ifdef ASSERT
 5644   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
 5645 #endif
 5646   if (CompressedOops::base() == NULL) {
 5647     if (CompressedOops::shift() != 0) {
 5648       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5649       shlq(r, LogMinObjAlignmentInBytes);
 5650     }
 5651   } else {
 5652     Label done;
 5653     shlq(r, LogMinObjAlignmentInBytes);
 5654     jccb(Assembler::equal, done);
 5655     addq(r, r12_heapbase);
 5656     bind(done);
 5657   }
 5658   verify_oop_msg(r, &quot;broken oop in decode_heap_oop&quot;);
 5659 }
 5660 
 5661 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
 5662   // Note: it will change flags
 5663   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5664   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5665   // Cannot assert, unverified entry point counts instructions (see .ad file)
 5666   // vtableStubs also counts instructions in pd_code_size_limit.
 5667   // Also do not verify_oop as this is called by verify_oop.
 5668   if (CompressedOops::shift() != 0) {
 5669     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5670     shlq(r, LogMinObjAlignmentInBytes);
 5671     if (CompressedOops::base() != NULL) {
 5672       addq(r, r12_heapbase);
 5673     }
 5674   } else {
 5675     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
 5676   }
 5677 }
 5678 
 5679 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
 5680   // Note: it will change flags
 5681   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5682   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5683   // Cannot assert, unverified entry point counts instructions (see .ad file)
 5684   // vtableStubs also counts instructions in pd_code_size_limit.
 5685   // Also do not verify_oop as this is called by verify_oop.
 5686   if (CompressedOops::shift() != 0) {
 5687     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5688     if (LogMinObjAlignmentInBytes == Address::times_8) {
 5689       leaq(dst, Address(r12_heapbase, src, Address::times_8, 0));
 5690     } else {
 5691       if (dst != src) {
 5692         movq(dst, src);
 5693       }
 5694       shlq(dst, LogMinObjAlignmentInBytes);
 5695       if (CompressedOops::base() != NULL) {
 5696         addq(dst, r12_heapbase);
 5697       }
 5698     }
 5699   } else {
 5700     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
 5701     if (dst != src) {
 5702       movq(dst, src);
 5703     }
 5704   }
 5705 }
 5706 
 5707 void MacroAssembler::encode_klass_not_null(Register r) {
 5708   if (CompressedKlassPointers::base() != NULL) {
 5709     // Use r12 as a scratch register in which to temporarily load the narrow_klass_base.
 5710     assert(r != r12_heapbase, &quot;Encoding a klass in r12&quot;);
 5711     mov64(r12_heapbase, (int64_t)CompressedKlassPointers::base());
 5712     subq(r, r12_heapbase);
 5713   }
 5714   if (CompressedKlassPointers::shift() != 0) {
 5715     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
 5716     shrq(r, LogKlassAlignmentInBytes);
 5717   }
 5718   if (CompressedKlassPointers::base() != NULL) {
 5719     reinit_heapbase();
 5720   }
 5721 }
 5722 
 5723 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
 5724   if (dst == src) {
 5725     encode_klass_not_null(src);
 5726   } else {
 5727     if (CompressedKlassPointers::base() != NULL) {
 5728       mov64(dst, (int64_t)CompressedKlassPointers::base());
 5729       negq(dst);
 5730       addq(dst, src);
 5731     } else {
 5732       movptr(dst, src);
 5733     }
 5734     if (CompressedKlassPointers::shift() != 0) {
 5735       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
 5736       shrq(dst, LogKlassAlignmentInBytes);
 5737     }
 5738   }
 5739 }
 5740 
 5741 // Function instr_size_for_decode_klass_not_null() counts the instructions
 5742 // generated by decode_klass_not_null(register r) and reinit_heapbase(),
 5743 // when (Universe::heap() != NULL).  Hence, if the instructions they
 5744 // generate change, then this method needs to be updated.
 5745 int MacroAssembler::instr_size_for_decode_klass_not_null() {
 5746   assert (UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
 5747   if (CompressedKlassPointers::base() != NULL) {
 5748     // mov64 + addq + shlq? + mov64  (for reinit_heapbase()).
 5749     return (CompressedKlassPointers::shift() == 0 ? 20 : 24);
 5750   } else {
 5751     // longest load decode klass function, mov64, leaq
 5752     return 16;
 5753   }
 5754 }
 5755 
 5756 // !!! If the instructions that get generated here change then function
 5757 // instr_size_for_decode_klass_not_null() needs to get updated.
 5758 void  MacroAssembler::decode_klass_not_null(Register r) {
 5759   // Note: it will change flags
 5760   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5761   assert(r != r12_heapbase, &quot;Decoding a klass in r12&quot;);
 5762   // Cannot assert, unverified entry point counts instructions (see .ad file)
 5763   // vtableStubs also counts instructions in pd_code_size_limit.
 5764   // Also do not verify_oop as this is called by verify_oop.
 5765   if (CompressedKlassPointers::shift() != 0) {
 5766     assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
 5767     shlq(r, LogKlassAlignmentInBytes);
 5768   }
 5769   // Use r12 as a scratch register in which to temporarily load the narrow_klass_base.
 5770   if (CompressedKlassPointers::base() != NULL) {
 5771     mov64(r12_heapbase, (int64_t)CompressedKlassPointers::base());
 5772     addq(r, r12_heapbase);
 5773     reinit_heapbase();
 5774   }
 5775 }
 5776 
 5777 void  MacroAssembler::decode_klass_not_null(Register dst, Register src) {
 5778   // Note: it will change flags
 5779   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5780   if (dst == src) {
 5781     decode_klass_not_null(dst);
 5782   } else {
 5783     // Cannot assert, unverified entry point counts instructions (see .ad file)
 5784     // vtableStubs also counts instructions in pd_code_size_limit.
 5785     // Also do not verify_oop as this is called by verify_oop.
 5786     mov64(dst, (int64_t)CompressedKlassPointers::base());
 5787     if (CompressedKlassPointers::shift() != 0) {
 5788       assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
 5789       assert(LogKlassAlignmentInBytes == Address::times_8, &quot;klass not aligned on 64bits?&quot;);
 5790       leaq(dst, Address(dst, src, Address::times_8, 0));
 5791     } else {
 5792       addq(dst, src);
 5793     }
 5794   }
 5795 }
 5796 
 5797 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
 5798   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5799   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5800   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5801   int oop_index = oop_recorder()-&gt;find_index(obj);
 5802   RelocationHolder rspec = oop_Relocation::spec(oop_index);
 5803   mov_narrow_oop(dst, oop_index, rspec);
 5804 }
 5805 
 5806 void  MacroAssembler::set_narrow_oop(Address dst, jobject obj) {
 5807   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5808   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5809   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5810   int oop_index = oop_recorder()-&gt;find_index(obj);
 5811   RelocationHolder rspec = oop_Relocation::spec(oop_index);
 5812   mov_narrow_oop(dst, oop_index, rspec);
 5813 }
 5814 
 5815 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
 5816   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5817   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5818   int klass_index = oop_recorder()-&gt;find_index(k);
 5819   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 5820   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
 5821 }
 5822 
 5823 void  MacroAssembler::set_narrow_klass(Address dst, Klass* k) {
 5824   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5825   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5826   int klass_index = oop_recorder()-&gt;find_index(k);
 5827   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 5828   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
 5829 }
 5830 
 5831 void  MacroAssembler::cmp_narrow_oop(Register dst, jobject obj) {
 5832   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5833   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5834   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5835   int oop_index = oop_recorder()-&gt;find_index(obj);
 5836   RelocationHolder rspec = oop_Relocation::spec(oop_index);
 5837   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
 5838 }
 5839 
 5840 void  MacroAssembler::cmp_narrow_oop(Address dst, jobject obj) {
 5841   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5842   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5843   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5844   int oop_index = oop_recorder()-&gt;find_index(obj);
 5845   RelocationHolder rspec = oop_Relocation::spec(oop_index);
 5846   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
 5847 }
 5848 
 5849 void  MacroAssembler::cmp_narrow_klass(Register dst, Klass* k) {
 5850   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5851   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5852   int klass_index = oop_recorder()-&gt;find_index(k);
 5853   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 5854   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
 5855 }
 5856 
 5857 void  MacroAssembler::cmp_narrow_klass(Address dst, Klass* k) {
 5858   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5859   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5860   int klass_index = oop_recorder()-&gt;find_index(k);
 5861   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 5862   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
 5863 }
 5864 
 5865 void MacroAssembler::reinit_heapbase() {
 5866   if (UseCompressedOops || UseCompressedClassPointers) {
 5867     if (Universe::heap() != NULL) {
 5868       if (CompressedOops::base() == NULL) {
 5869         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
 5870       } else {
 5871         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
 5872       }
 5873     } else {
 5874       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
 5875     }
 5876   }
 5877 }
 5878 
 5879 #endif // _LP64
 5880 
 5881 // C2 compiled method&#39;s prolog code.
 5882 void MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {
 5883 
 5884   // WARNING: Initial instruction MUST be 5 bytes or longer so that
 5885   // NativeJump::patch_verified_entry will be able to patch out the entry
 5886   // code safely. The push to verify stack depth is ok at 5 bytes,
 5887   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
 5888   // stack bang then we must use the 6 byte frame allocation even if
 5889   // we have no frame. :-(
 5890   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
 5891 
 5892   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
 5893   // Remove word for return addr
 5894   framesize -= wordSize;
 5895   stack_bang_size -= wordSize;
 5896 
 5897   // Calls to C2R adapters often do not accept exceptional returns.
 5898   // We require that their callers must bang for them.  But be careful, because
 5899   // some VM calls (such as call site linkage) can use several kilobytes of
 5900   // stack.  But the stack safety zone should account for that.
 5901   // See bugs 4446381, 4468289, 4497237.
 5902   if (stack_bang_size &gt; 0) {
 5903     generate_stack_overflow_check(stack_bang_size);
 5904 
 5905     // We always push rbp, so that on return to interpreter rbp, will be
 5906     // restored correctly and we can correct the stack.
 5907     push(rbp);
 5908     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
 5909     if (PreserveFramePointer) {
 5910       mov(rbp, rsp);
 5911     }
 5912     // Remove word for ebp
 5913     framesize -= wordSize;
 5914 
 5915     // Create frame
 5916     if (framesize) {
 5917       subptr(rsp, framesize);
 5918     }
 5919   } else {
 5920     // Create frame (force generation of a 4 byte immediate value)
 5921     subptr_imm32(rsp, framesize);
 5922 
 5923     // Save RBP register now.
 5924     framesize -= wordSize;
 5925     movptr(Address(rsp, framesize), rbp);
 5926     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
 5927     if (PreserveFramePointer) {
 5928       movptr(rbp, rsp);
 5929       if (framesize &gt; 0) {
 5930         addptr(rbp, framesize);
 5931       }
 5932     }
 5933   }
 5934 
 5935   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
 5936     framesize -= wordSize;
 5937     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
 5938   }
 5939 
 5940 #ifndef _LP64
 5941   // If method sets FPU control word do it now
 5942   if (fp_mode_24b) {
 5943     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 5944   }
 5945   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
 5946     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
 5947   }
 5948 #endif
 5949 
 5950 #ifdef ASSERT
 5951   if (VerifyStackAtCalls) {
 5952     Label L;
 5953     push(rax);
 5954     mov(rax, rsp);
 5955     andptr(rax, StackAlignmentInBytes-1);
 5956     cmpptr(rax, StackAlignmentInBytes-wordSize);
 5957     pop(rax);
 5958     jcc(Assembler::equal, L);
 5959     STOP(&quot;Stack is not properly aligned!&quot;);
 5960     bind(L);
 5961   }
 5962 #endif
 5963 
 5964   if (!is_stub) {
 5965     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 5966     bs-&gt;nmethod_entry_barrier(this);
 5967   }
 5968 }
 5969 
 5970 // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
 5971 void MacroAssembler::xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp) {
 5972   // cnt - number of qwords (8-byte words).
 5973   // base - start address, qword aligned.
 5974   Label L_zero_64_bytes, L_loop, L_sloop, L_tail, L_end;
 5975   if (UseAVX &gt;= 2) {
 5976     vpxor(xtmp, xtmp, xtmp, AVX_256bit);
 5977   } else {
 5978     pxor(xtmp, xtmp);
 5979   }
 5980   jmp(L_zero_64_bytes);
 5981 
 5982   BIND(L_loop);
 5983   if (UseAVX &gt;= 2) {
 5984     vmovdqu(Address(base,  0), xtmp);
 5985     vmovdqu(Address(base, 32), xtmp);
 5986   } else {
 5987     movdqu(Address(base,  0), xtmp);
 5988     movdqu(Address(base, 16), xtmp);
 5989     movdqu(Address(base, 32), xtmp);
 5990     movdqu(Address(base, 48), xtmp);
 5991   }
 5992   addptr(base, 64);
 5993 
 5994   BIND(L_zero_64_bytes);
 5995   subptr(cnt, 8);
 5996   jccb(Assembler::greaterEqual, L_loop);
 5997   addptr(cnt, 4);
 5998   jccb(Assembler::less, L_tail);
 5999   // Copy trailing 32 bytes
 6000   if (UseAVX &gt;= 2) {
 6001     vmovdqu(Address(base, 0), xtmp);
 6002   } else {
 6003     movdqu(Address(base,  0), xtmp);
 6004     movdqu(Address(base, 16), xtmp);
 6005   }
 6006   addptr(base, 32);
 6007   subptr(cnt, 4);
 6008 
 6009   BIND(L_tail);
 6010   addptr(cnt, 4);
 6011   jccb(Assembler::lessEqual, L_end);
 6012   decrement(cnt);
 6013 
 6014   BIND(L_sloop);
 6015   movq(Address(base, 0), xtmp);
 6016   addptr(base, 8);
 6017   decrement(cnt);
 6018   jccb(Assembler::greaterEqual, L_sloop);
 6019   BIND(L_end);
 6020 }
 6021 
 6022 void MacroAssembler::clear_mem(Register base, Register cnt, Register tmp, XMMRegister xtmp, bool is_large) {
 6023   // cnt - number of qwords (8-byte words).
 6024   // base - start address, qword aligned.
 6025   // is_large - if optimizers know cnt is larger than InitArrayShortSize
 6026   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
 6027   assert(tmp==rax,   &quot;tmp register must be eax for rep stos&quot;);
 6028   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
 6029   assert(InitArrayShortSize % BytesPerLong == 0,
 6030     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
 6031 
 6032   Label DONE;
 6033 
 6034   if (!is_large || !UseXMMForObjInit) {
 6035     xorptr(tmp, tmp);
 6036   }
 6037 
 6038   if (!is_large) {
 6039     Label LOOP, LONG;
 6040     cmpptr(cnt, InitArrayShortSize/BytesPerLong);
 6041     jccb(Assembler::greater, LONG);
 6042 
 6043     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
 6044 
 6045     decrement(cnt);
 6046     jccb(Assembler::negative, DONE); // Zero length
 6047 
 6048     // Use individual pointer-sized stores for small counts:
 6049     BIND(LOOP);
 6050     movptr(Address(base, cnt, Address::times_ptr), tmp);
 6051     decrement(cnt);
 6052     jccb(Assembler::greaterEqual, LOOP);
 6053     jmpb(DONE);
 6054 
 6055     BIND(LONG);
 6056   }
 6057 
 6058   // Use longer rep-prefixed ops for non-small counts:
 6059   if (UseFastStosb) {
 6060     shlptr(cnt, 3); // convert to number of bytes
 6061     rep_stosb();
 6062   } else if (UseXMMForObjInit) {
 6063     movptr(tmp, base);
 6064     xmm_clear_mem(tmp, cnt, xtmp);
 6065   } else {
 6066     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
 6067     rep_stos();
 6068   }
 6069 
 6070   BIND(DONE);
 6071 }
 6072 
 6073 #ifdef COMPILER2
 6074 
 6075 // IndexOf for constant substrings with size &gt;= 8 chars
 6076 // which don&#39;t need to be loaded through stack.
 6077 void MacroAssembler::string_indexofC8(Register str1, Register str2,
 6078                                       Register cnt1, Register cnt2,
 6079                                       int int_cnt2,  Register result,
 6080                                       XMMRegister vec, Register tmp,
 6081                                       int ae) {
 6082   ShortBranchVerifier sbv(this);
 6083   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);
 6084   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);
 6085 
 6086   // This method uses the pcmpestri instruction with bound registers
 6087   //   inputs:
 6088   //     xmm - substring
 6089   //     rax - substring length (elements count)
 6090   //     mem - scanned string
 6091   //     rdx - string length (elements count)
 6092   //     0xd - mode: 1100 (substring search) + 01 (unsigned shorts)
 6093   //     0xc - mode: 1100 (substring search) + 00 (unsigned bytes)
 6094   //   outputs:
 6095   //     rcx - matched index in string
 6096   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);
 6097   int mode   = (ae == StrIntrinsicNode::LL) ? 0x0c : 0x0d; // bytes or shorts
 6098   int stride = (ae == StrIntrinsicNode::LL) ? 16 : 8; //UU, UL -&gt; 8
 6099   Address::ScaleFactor scale1 = (ae == StrIntrinsicNode::LL) ? Address::times_1 : Address::times_2;
 6100   Address::ScaleFactor scale2 = (ae == StrIntrinsicNode::UL) ? Address::times_1 : scale1;
 6101 
 6102   Label RELOAD_SUBSTR, SCAN_TO_SUBSTR, SCAN_SUBSTR,
 6103         RET_FOUND, RET_NOT_FOUND, EXIT, FOUND_SUBSTR,
 6104         MATCH_SUBSTR_HEAD, RELOAD_STR, FOUND_CANDIDATE;
 6105 
 6106   // Note, inline_string_indexOf() generates checks:
 6107   // if (substr.count &gt; string.count) return -1;
 6108   // if (substr.count == 0) return 0;
 6109   assert(int_cnt2 &gt;= stride, &quot;this code is used only for cnt2 &gt;= 8 chars&quot;);
 6110 
 6111   // Load substring.
 6112   if (ae == StrIntrinsicNode::UL) {
 6113     pmovzxbw(vec, Address(str2, 0));
 6114   } else {
 6115     movdqu(vec, Address(str2, 0));
 6116   }
 6117   movl(cnt2, int_cnt2);
 6118   movptr(result, str1); // string addr
 6119 
 6120   if (int_cnt2 &gt; stride) {
 6121     jmpb(SCAN_TO_SUBSTR);
 6122 
 6123     // Reload substr for rescan, this code
 6124     // is executed only for large substrings (&gt; 8 chars)
 6125     bind(RELOAD_SUBSTR);
 6126     if (ae == StrIntrinsicNode::UL) {
 6127       pmovzxbw(vec, Address(str2, 0));
 6128     } else {
 6129       movdqu(vec, Address(str2, 0));
 6130     }
 6131     negptr(cnt2); // Jumped here with negative cnt2, convert to positive
 6132 
 6133     bind(RELOAD_STR);
 6134     // We came here after the beginning of the substring was
 6135     // matched but the rest of it was not so we need to search
 6136     // again. Start from the next element after the previous match.
 6137 
 6138     // cnt2 is number of substring reminding elements and
 6139     // cnt1 is number of string reminding elements when cmp failed.
 6140     // Restored cnt1 = cnt1 - cnt2 + int_cnt2
 6141     subl(cnt1, cnt2);
 6142     addl(cnt1, int_cnt2);
 6143     movl(cnt2, int_cnt2); // Now restore cnt2
 6144 
 6145     decrementl(cnt1);     // Shift to next element
 6146     cmpl(cnt1, cnt2);
 6147     jcc(Assembler::negative, RET_NOT_FOUND);  // Left less then substring
 6148 
 6149     addptr(result, (1&lt;&lt;scale1));
 6150 
 6151   } // (int_cnt2 &gt; 8)
 6152 
 6153   // Scan string for start of substr in 16-byte vectors
 6154   bind(SCAN_TO_SUBSTR);
 6155   pcmpestri(vec, Address(result, 0), mode);
 6156   jccb(Assembler::below, FOUND_CANDIDATE);   // CF == 1
 6157   subl(cnt1, stride);
 6158   jccb(Assembler::lessEqual, RET_NOT_FOUND); // Scanned full string
 6159   cmpl(cnt1, cnt2);
 6160   jccb(Assembler::negative, RET_NOT_FOUND);  // Left less then substring
 6161   addptr(result, 16);
 6162   jmpb(SCAN_TO_SUBSTR);
 6163 
 6164   // Found a potential substr
 6165   bind(FOUND_CANDIDATE);
 6166   // Matched whole vector if first element matched (tmp(rcx) == 0).
 6167   if (int_cnt2 == stride) {
 6168     jccb(Assembler::overflow, RET_FOUND);    // OF == 1
 6169   } else { // int_cnt2 &gt; 8
 6170     jccb(Assembler::overflow, FOUND_SUBSTR);
 6171   }
 6172   // After pcmpestri tmp(rcx) contains matched element index
 6173   // Compute start addr of substr
 6174   lea(result, Address(result, tmp, scale1));
 6175 
 6176   // Make sure string is still long enough
 6177   subl(cnt1, tmp);
 6178   cmpl(cnt1, cnt2);
 6179   if (int_cnt2 == stride) {
 6180     jccb(Assembler::greaterEqual, SCAN_TO_SUBSTR);
 6181   } else { // int_cnt2 &gt; 8
 6182     jccb(Assembler::greaterEqual, MATCH_SUBSTR_HEAD);
 6183   }
 6184   // Left less then substring.
 6185 
 6186   bind(RET_NOT_FOUND);
 6187   movl(result, -1);
 6188   jmp(EXIT);
 6189 
 6190   if (int_cnt2 &gt; stride) {
 6191     // This code is optimized for the case when whole substring
 6192     // is matched if its head is matched.
 6193     bind(MATCH_SUBSTR_HEAD);
 6194     pcmpestri(vec, Address(result, 0), mode);
 6195     // Reload only string if does not match
 6196     jcc(Assembler::noOverflow, RELOAD_STR); // OF == 0
 6197 
 6198     Label CONT_SCAN_SUBSTR;
 6199     // Compare the rest of substring (&gt; 8 chars).
 6200     bind(FOUND_SUBSTR);
 6201     // First 8 chars are already matched.
 6202     negptr(cnt2);
 6203     addptr(cnt2, stride);
 6204 
 6205     bind(SCAN_SUBSTR);
 6206     subl(cnt1, stride);
 6207     cmpl(cnt2, -stride); // Do not read beyond substring
 6208     jccb(Assembler::lessEqual, CONT_SCAN_SUBSTR);
 6209     // Back-up strings to avoid reading beyond substring:
 6210     // cnt1 = cnt1 - cnt2 + 8
 6211     addl(cnt1, cnt2); // cnt2 is negative
 6212     addl(cnt1, stride);
 6213     movl(cnt2, stride); negptr(cnt2);
 6214     bind(CONT_SCAN_SUBSTR);
 6215     if (int_cnt2 &lt; (int)G) {
 6216       int tail_off1 = int_cnt2&lt;&lt;scale1;
 6217       int tail_off2 = int_cnt2&lt;&lt;scale2;
 6218       if (ae == StrIntrinsicNode::UL) {
 6219         pmovzxbw(vec, Address(str2, cnt2, scale2, tail_off2));
 6220       } else {
 6221         movdqu(vec, Address(str2, cnt2, scale2, tail_off2));
 6222       }
 6223       pcmpestri(vec, Address(result, cnt2, scale1, tail_off1), mode);
 6224     } else {
 6225       // calculate index in register to avoid integer overflow (int_cnt2*2)
 6226       movl(tmp, int_cnt2);
 6227       addptr(tmp, cnt2);
 6228       if (ae == StrIntrinsicNode::UL) {
 6229         pmovzxbw(vec, Address(str2, tmp, scale2, 0));
 6230       } else {
 6231         movdqu(vec, Address(str2, tmp, scale2, 0));
 6232       }
 6233       pcmpestri(vec, Address(result, tmp, scale1, 0), mode);
 6234     }
 6235     // Need to reload strings pointers if not matched whole vector
 6236     jcc(Assembler::noOverflow, RELOAD_SUBSTR); // OF == 0
 6237     addptr(cnt2, stride);
 6238     jcc(Assembler::negative, SCAN_SUBSTR);
 6239     // Fall through if found full substring
 6240 
 6241   } // (int_cnt2 &gt; 8)
 6242 
 6243   bind(RET_FOUND);
 6244   // Found result if we matched full small substring.
 6245   // Compute substr offset
 6246   subptr(result, str1);
 6247   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
 6248     shrl(result, 1); // index
 6249   }
 6250   bind(EXIT);
 6251 
 6252 } // string_indexofC8
 6253 
 6254 // Small strings are loaded through stack if they cross page boundary.
 6255 void MacroAssembler::string_indexof(Register str1, Register str2,
 6256                                     Register cnt1, Register cnt2,
 6257                                     int int_cnt2,  Register result,
 6258                                     XMMRegister vec, Register tmp,
 6259                                     int ae) {
 6260   ShortBranchVerifier sbv(this);
 6261   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);
 6262   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);
 6263 
 6264   //
 6265   // int_cnt2 is length of small (&lt; 8 chars) constant substring
 6266   // or (-1) for non constant substring in which case its length
 6267   // is in cnt2 register.
 6268   //
 6269   // Note, inline_string_indexOf() generates checks:
 6270   // if (substr.count &gt; string.count) return -1;
 6271   // if (substr.count == 0) return 0;
 6272   //
 6273   int stride = (ae == StrIntrinsicNode::LL) ? 16 : 8; //UU, UL -&gt; 8
 6274   assert(int_cnt2 == -1 || (0 &lt; int_cnt2 &amp;&amp; int_cnt2 &lt; stride), &quot;should be != 0&quot;);
 6275   // This method uses the pcmpestri instruction with bound registers
 6276   //   inputs:
 6277   //     xmm - substring
 6278   //     rax - substring length (elements count)
 6279   //     mem - scanned string
 6280   //     rdx - string length (elements count)
 6281   //     0xd - mode: 1100 (substring search) + 01 (unsigned shorts)
 6282   //     0xc - mode: 1100 (substring search) + 00 (unsigned bytes)
 6283   //   outputs:
 6284   //     rcx - matched index in string
 6285   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);
 6286   int mode = (ae == StrIntrinsicNode::LL) ? 0x0c : 0x0d; // bytes or shorts
 6287   Address::ScaleFactor scale1 = (ae == StrIntrinsicNode::LL) ? Address::times_1 : Address::times_2;
 6288   Address::ScaleFactor scale2 = (ae == StrIntrinsicNode::UL) ? Address::times_1 : scale1;
 6289 
 6290   Label RELOAD_SUBSTR, SCAN_TO_SUBSTR, SCAN_SUBSTR, ADJUST_STR,
 6291         RET_FOUND, RET_NOT_FOUND, CLEANUP, FOUND_SUBSTR,
 6292         FOUND_CANDIDATE;
 6293 
 6294   { //========================================================
 6295     // We don&#39;t know where these strings are located
 6296     // and we can&#39;t read beyond them. Load them through stack.
 6297     Label BIG_STRINGS, CHECK_STR, COPY_SUBSTR, COPY_STR;
 6298 
 6299     movptr(tmp, rsp); // save old SP
 6300 
 6301     if (int_cnt2 &gt; 0) {     // small (&lt; 8 chars) constant substring
 6302       if (int_cnt2 == (1&gt;&gt;scale2)) { // One byte
 6303         assert((ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL), &quot;Only possible for latin1 encoding&quot;);
 6304         load_unsigned_byte(result, Address(str2, 0));
 6305         movdl(vec, result); // move 32 bits
 6306       } else if (ae == StrIntrinsicNode::LL &amp;&amp; int_cnt2 == 3) {  // Three bytes
 6307         // Not enough header space in 32-bit VM: 12+3 = 15.
 6308         movl(result, Address(str2, -1));
 6309         shrl(result, 8);
 6310         movdl(vec, result); // move 32 bits
 6311       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (2&gt;&gt;scale2)) {  // One char
 6312         load_unsigned_short(result, Address(str2, 0));
 6313         movdl(vec, result); // move 32 bits
 6314       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (4&gt;&gt;scale2)) { // Two chars
 6315         movdl(vec, Address(str2, 0)); // move 32 bits
 6316       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (8&gt;&gt;scale2)) { // Four chars
 6317         movq(vec, Address(str2, 0));  // move 64 bits
 6318       } else { // cnt2 = { 3, 5, 6, 7 } || (ae == StrIntrinsicNode::UL &amp;&amp; cnt2 ={2, ..., 7})
 6319         // Array header size is 12 bytes in 32-bit VM
 6320         // + 6 bytes for 3 chars == 18 bytes,
 6321         // enough space to load vec and shift.
 6322         assert(HeapWordSize*TypeArrayKlass::header_size() &gt;= 12,&quot;sanity&quot;);
 6323         if (ae == StrIntrinsicNode::UL) {
 6324           int tail_off = int_cnt2-8;
 6325           pmovzxbw(vec, Address(str2, tail_off));
 6326           psrldq(vec, -2*tail_off);
 6327         }
 6328         else {
 6329           int tail_off = int_cnt2*(1&lt;&lt;scale2);
 6330           movdqu(vec, Address(str2, tail_off-16));
 6331           psrldq(vec, 16-tail_off);
 6332         }
 6333       }
 6334     } else { // not constant substring
 6335       cmpl(cnt2, stride);
 6336       jccb(Assembler::aboveEqual, BIG_STRINGS); // Both strings are big enough
 6337 
 6338       // We can read beyond string if srt+16 does not cross page boundary
 6339       // since heaps are aligned and mapped by pages.
 6340       assert(os::vm_page_size() &lt; (int)G, &quot;default page should be small&quot;);
 6341       movl(result, str2); // We need only low 32 bits
 6342       andl(result, (os::vm_page_size()-1));
 6343       cmpl(result, (os::vm_page_size()-16));
 6344       jccb(Assembler::belowEqual, CHECK_STR);
 6345 
 6346       // Move small strings to stack to allow load 16 bytes into vec.
 6347       subptr(rsp, 16);
 6348       int stk_offset = wordSize-(1&lt;&lt;scale2);
 6349       push(cnt2);
 6350 
 6351       bind(COPY_SUBSTR);
 6352       if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL) {
 6353         load_unsigned_byte(result, Address(str2, cnt2, scale2, -1));
 6354         movb(Address(rsp, cnt2, scale2, stk_offset), result);
 6355       } else if (ae == StrIntrinsicNode::UU) {
 6356         load_unsigned_short(result, Address(str2, cnt2, scale2, -2));
 6357         movw(Address(rsp, cnt2, scale2, stk_offset), result);
 6358       }
 6359       decrement(cnt2);
 6360       jccb(Assembler::notZero, COPY_SUBSTR);
 6361 
 6362       pop(cnt2);
 6363       movptr(str2, rsp);  // New substring address
 6364     } // non constant
 6365 
 6366     bind(CHECK_STR);
 6367     cmpl(cnt1, stride);
 6368     jccb(Assembler::aboveEqual, BIG_STRINGS);
 6369 
 6370     // Check cross page boundary.
 6371     movl(result, str1); // We need only low 32 bits
 6372     andl(result, (os::vm_page_size()-1));
 6373     cmpl(result, (os::vm_page_size()-16));
 6374     jccb(Assembler::belowEqual, BIG_STRINGS);
 6375 
 6376     subptr(rsp, 16);
 6377     int stk_offset = -(1&lt;&lt;scale1);
 6378     if (int_cnt2 &lt; 0) { // not constant
 6379       push(cnt2);
 6380       stk_offset += wordSize;
 6381     }
 6382     movl(cnt2, cnt1);
 6383 
 6384     bind(COPY_STR);
 6385     if (ae == StrIntrinsicNode::LL) {
 6386       load_unsigned_byte(result, Address(str1, cnt2, scale1, -1));
 6387       movb(Address(rsp, cnt2, scale1, stk_offset), result);
 6388     } else {
 6389       load_unsigned_short(result, Address(str1, cnt2, scale1, -2));
 6390       movw(Address(rsp, cnt2, scale1, stk_offset), result);
 6391     }
 6392     decrement(cnt2);
 6393     jccb(Assembler::notZero, COPY_STR);
 6394 
 6395     if (int_cnt2 &lt; 0) { // not constant
 6396       pop(cnt2);
 6397     }
 6398     movptr(str1, rsp);  // New string address
 6399 
 6400     bind(BIG_STRINGS);
 6401     // Load substring.
 6402     if (int_cnt2 &lt; 0) { // -1
 6403       if (ae == StrIntrinsicNode::UL) {
 6404         pmovzxbw(vec, Address(str2, 0));
 6405       } else {
 6406         movdqu(vec, Address(str2, 0));
 6407       }
 6408       push(cnt2);       // substr count
 6409       push(str2);       // substr addr
 6410       push(str1);       // string addr
 6411     } else {
 6412       // Small (&lt; 8 chars) constant substrings are loaded already.
 6413       movl(cnt2, int_cnt2);
 6414     }
 6415     push(tmp);  // original SP
 6416 
 6417   } // Finished loading
 6418 
 6419   //========================================================
 6420   // Start search
 6421   //
 6422 
 6423   movptr(result, str1); // string addr
 6424 
 6425   if (int_cnt2  &lt; 0) {  // Only for non constant substring
 6426     jmpb(SCAN_TO_SUBSTR);
 6427 
 6428     // SP saved at sp+0
 6429     // String saved at sp+1*wordSize
 6430     // Substr saved at sp+2*wordSize
 6431     // Substr count saved at sp+3*wordSize
 6432 
 6433     // Reload substr for rescan, this code
 6434     // is executed only for large substrings (&gt; 8 chars)
 6435     bind(RELOAD_SUBSTR);
 6436     movptr(str2, Address(rsp, 2*wordSize));
 6437     movl(cnt2, Address(rsp, 3*wordSize));
 6438     if (ae == StrIntrinsicNode::UL) {
 6439       pmovzxbw(vec, Address(str2, 0));
 6440     } else {
 6441       movdqu(vec, Address(str2, 0));
 6442     }
 6443     // We came here after the beginning of the substring was
 6444     // matched but the rest of it was not so we need to search
 6445     // again. Start from the next element after the previous match.
 6446     subptr(str1, result); // Restore counter
 6447     if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
 6448       shrl(str1, 1);
 6449     }
 6450     addl(cnt1, str1);
 6451     decrementl(cnt1);   // Shift to next element
 6452     cmpl(cnt1, cnt2);
 6453     jcc(Assembler::negative, RET_NOT_FOUND);  // Left less then substring
 6454 
 6455     addptr(result, (1&lt;&lt;scale1));
 6456   } // non constant
 6457 
 6458   // Scan string for start of substr in 16-byte vectors
 6459   bind(SCAN_TO_SUBSTR);
 6460   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);
 6461   pcmpestri(vec, Address(result, 0), mode);
 6462   jccb(Assembler::below, FOUND_CANDIDATE);   // CF == 1
 6463   subl(cnt1, stride);
 6464   jccb(Assembler::lessEqual, RET_NOT_FOUND); // Scanned full string
 6465   cmpl(cnt1, cnt2);
 6466   jccb(Assembler::negative, RET_NOT_FOUND);  // Left less then substring
 6467   addptr(result, 16);
 6468 
 6469   bind(ADJUST_STR);
 6470   cmpl(cnt1, stride); // Do not read beyond string
 6471   jccb(Assembler::greaterEqual, SCAN_TO_SUBSTR);
 6472   // Back-up string to avoid reading beyond string.
 6473   lea(result, Address(result, cnt1, scale1, -16));
 6474   movl(cnt1, stride);
 6475   jmpb(SCAN_TO_SUBSTR);
 6476 
 6477   // Found a potential substr
 6478   bind(FOUND_CANDIDATE);
 6479   // After pcmpestri tmp(rcx) contains matched element index
 6480 
 6481   // Make sure string is still long enough
 6482   subl(cnt1, tmp);
 6483   cmpl(cnt1, cnt2);
 6484   jccb(Assembler::greaterEqual, FOUND_SUBSTR);
 6485   // Left less then substring.
 6486 
 6487   bind(RET_NOT_FOUND);
 6488   movl(result, -1);
 6489   jmp(CLEANUP);
 6490 
 6491   bind(FOUND_SUBSTR);
 6492   // Compute start addr of substr
 6493   lea(result, Address(result, tmp, scale1));
 6494   if (int_cnt2 &gt; 0) { // Constant substring
 6495     // Repeat search for small substring (&lt; 8 chars)
 6496     // from new point without reloading substring.
 6497     // Have to check that we don&#39;t read beyond string.
 6498     cmpl(tmp, stride-int_cnt2);
 6499     jccb(Assembler::greater, ADJUST_STR);
 6500     // Fall through if matched whole substring.
 6501   } else { // non constant
 6502     assert(int_cnt2 == -1, &quot;should be != 0&quot;);
 6503 
 6504     addl(tmp, cnt2);
 6505     // Found result if we matched whole substring.
 6506     cmpl(tmp, stride);
 6507     jcc(Assembler::lessEqual, RET_FOUND);
 6508 
 6509     // Repeat search for small substring (&lt;= 8 chars)
 6510     // from new point &#39;str1&#39; without reloading substring.
 6511     cmpl(cnt2, stride);
 6512     // Have to check that we don&#39;t read beyond string.
 6513     jccb(Assembler::lessEqual, ADJUST_STR);
 6514 
 6515     Label CHECK_NEXT, CONT_SCAN_SUBSTR, RET_FOUND_LONG;
 6516     // Compare the rest of substring (&gt; 8 chars).
 6517     movptr(str1, result);
 6518 
 6519     cmpl(tmp, cnt2);
 6520     // First 8 chars are already matched.
 6521     jccb(Assembler::equal, CHECK_NEXT);
 6522 
 6523     bind(SCAN_SUBSTR);
 6524     pcmpestri(vec, Address(str1, 0), mode);
 6525     // Need to reload strings pointers if not matched whole vector
 6526     jcc(Assembler::noOverflow, RELOAD_SUBSTR); // OF == 0
 6527 
 6528     bind(CHECK_NEXT);
 6529     subl(cnt2, stride);
 6530     jccb(Assembler::lessEqual, RET_FOUND_LONG); // Found full substring
 6531     addptr(str1, 16);
 6532     if (ae == StrIntrinsicNode::UL) {
 6533       addptr(str2, 8);
 6534     } else {
 6535       addptr(str2, 16);
 6536     }
 6537     subl(cnt1, stride);
 6538     cmpl(cnt2, stride); // Do not read beyond substring
 6539     jccb(Assembler::greaterEqual, CONT_SCAN_SUBSTR);
 6540     // Back-up strings to avoid reading beyond substring.
 6541 
 6542     if (ae == StrIntrinsicNode::UL) {
 6543       lea(str2, Address(str2, cnt2, scale2, -8));
 6544       lea(str1, Address(str1, cnt2, scale1, -16));
 6545     } else {
 6546       lea(str2, Address(str2, cnt2, scale2, -16));
 6547       lea(str1, Address(str1, cnt2, scale1, -16));
 6548     }
 6549     subl(cnt1, cnt2);
 6550     movl(cnt2, stride);
 6551     addl(cnt1, stride);
 6552     bind(CONT_SCAN_SUBSTR);
 6553     if (ae == StrIntrinsicNode::UL) {
 6554       pmovzxbw(vec, Address(str2, 0));
 6555     } else {
 6556       movdqu(vec, Address(str2, 0));
 6557     }
 6558     jmp(SCAN_SUBSTR);
 6559 
 6560     bind(RET_FOUND_LONG);
 6561     movptr(str1, Address(rsp, wordSize));
 6562   } // non constant
 6563 
 6564   bind(RET_FOUND);
 6565   // Compute substr offset
 6566   subptr(result, str1);
 6567   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
 6568     shrl(result, 1); // index
 6569   }
 6570   bind(CLEANUP);
 6571   pop(rsp); // restore SP
 6572 
 6573 } // string_indexof
 6574 
 6575 void MacroAssembler::string_indexof_char(Register str1, Register cnt1, Register ch, Register result,
 6576                                          XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp) {
 6577   ShortBranchVerifier sbv(this);
 6578   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);
 6579 
 6580   int stride = 8;
 6581 
 6582   Label FOUND_CHAR, SCAN_TO_CHAR, SCAN_TO_CHAR_LOOP,
 6583         SCAN_TO_8_CHAR, SCAN_TO_8_CHAR_LOOP, SCAN_TO_16_CHAR_LOOP,
 6584         RET_NOT_FOUND, SCAN_TO_8_CHAR_INIT,
 6585         FOUND_SEQ_CHAR, DONE_LABEL;
 6586 
 6587   movptr(result, str1);
 6588   if (UseAVX &gt;= 2) {
 6589     cmpl(cnt1, stride);
 6590     jcc(Assembler::less, SCAN_TO_CHAR);
 6591     cmpl(cnt1, 2*stride);
 6592     jcc(Assembler::less, SCAN_TO_8_CHAR_INIT);
 6593     movdl(vec1, ch);
 6594     vpbroadcastw(vec1, vec1, Assembler::AVX_256bit);
 6595     vpxor(vec2, vec2);
 6596     movl(tmp, cnt1);
 6597     andl(tmp, 0xFFFFFFF0);  //vector count (in chars)
 6598     andl(cnt1,0x0000000F);  //tail count (in chars)
 6599 
 6600     bind(SCAN_TO_16_CHAR_LOOP);
 6601     vmovdqu(vec3, Address(result, 0));
 6602     vpcmpeqw(vec3, vec3, vec1, 1);
 6603     vptest(vec2, vec3);
 6604     jcc(Assembler::carryClear, FOUND_CHAR);
 6605     addptr(result, 32);
 6606     subl(tmp, 2*stride);
 6607     jcc(Assembler::notZero, SCAN_TO_16_CHAR_LOOP);
 6608     jmp(SCAN_TO_8_CHAR);
 6609     bind(SCAN_TO_8_CHAR_INIT);
 6610     movdl(vec1, ch);
 6611     pshuflw(vec1, vec1, 0x00);
 6612     pshufd(vec1, vec1, 0);
 6613     pxor(vec2, vec2);
 6614   }
 6615   bind(SCAN_TO_8_CHAR);
 6616   cmpl(cnt1, stride);
 6617   jcc(Assembler::less, SCAN_TO_CHAR);
 6618   if (UseAVX &lt; 2) {
 6619     movdl(vec1, ch);
 6620     pshuflw(vec1, vec1, 0x00);
 6621     pshufd(vec1, vec1, 0);
 6622     pxor(vec2, vec2);
 6623   }
 6624   movl(tmp, cnt1);
 6625   andl(tmp, 0xFFFFFFF8);  //vector count (in chars)
 6626   andl(cnt1,0x00000007);  //tail count (in chars)
 6627 
 6628   bind(SCAN_TO_8_CHAR_LOOP);
 6629   movdqu(vec3, Address(result, 0));
 6630   pcmpeqw(vec3, vec1);
 6631   ptest(vec2, vec3);
 6632   jcc(Assembler::carryClear, FOUND_CHAR);
 6633   addptr(result, 16);
 6634   subl(tmp, stride);
 6635   jcc(Assembler::notZero, SCAN_TO_8_CHAR_LOOP);
 6636   bind(SCAN_TO_CHAR);
 6637   testl(cnt1, cnt1);
 6638   jcc(Assembler::zero, RET_NOT_FOUND);
 6639   bind(SCAN_TO_CHAR_LOOP);
 6640   load_unsigned_short(tmp, Address(result, 0));
 6641   cmpl(ch, tmp);
 6642   jccb(Assembler::equal, FOUND_SEQ_CHAR);
 6643   addptr(result, 2);
 6644   subl(cnt1, 1);
 6645   jccb(Assembler::zero, RET_NOT_FOUND);
 6646   jmp(SCAN_TO_CHAR_LOOP);
 6647 
 6648   bind(RET_NOT_FOUND);
 6649   movl(result, -1);
 6650   jmpb(DONE_LABEL);
 6651 
 6652   bind(FOUND_CHAR);
 6653   if (UseAVX &gt;= 2) {
 6654     vpmovmskb(tmp, vec3);
 6655   } else {
 6656     pmovmskb(tmp, vec3);
 6657   }
 6658   bsfl(ch, tmp);
 6659   addl(result, ch);
 6660 
 6661   bind(FOUND_SEQ_CHAR);
 6662   subptr(result, str1);
 6663   shrl(result, 1);
 6664 
 6665   bind(DONE_LABEL);
 6666 } // string_indexof_char
 6667 
 6668 // helper function for string_compare
 6669 void MacroAssembler::load_next_elements(Register elem1, Register elem2, Register str1, Register str2,
 6670                                         Address::ScaleFactor scale, Address::ScaleFactor scale1,
 6671                                         Address::ScaleFactor scale2, Register index, int ae) {
 6672   if (ae == StrIntrinsicNode::LL) {
 6673     load_unsigned_byte(elem1, Address(str1, index, scale, 0));
 6674     load_unsigned_byte(elem2, Address(str2, index, scale, 0));
 6675   } else if (ae == StrIntrinsicNode::UU) {
 6676     load_unsigned_short(elem1, Address(str1, index, scale, 0));
 6677     load_unsigned_short(elem2, Address(str2, index, scale, 0));
 6678   } else {
 6679     load_unsigned_byte(elem1, Address(str1, index, scale1, 0));
 6680     load_unsigned_short(elem2, Address(str2, index, scale2, 0));
 6681   }
 6682 }
 6683 
 6684 // Compare strings, used for char[] and byte[].
 6685 void MacroAssembler::string_compare(Register str1, Register str2,
 6686                                     Register cnt1, Register cnt2, Register result,
 6687                                     XMMRegister vec1, int ae) {
 6688   ShortBranchVerifier sbv(this);
 6689   Label LENGTH_DIFF_LABEL, POP_LABEL, DONE_LABEL, WHILE_HEAD_LABEL;
 6690   Label COMPARE_WIDE_VECTORS_LOOP_FAILED;  // used only _LP64 &amp;&amp; AVX3
 6691   int stride, stride2, adr_stride, adr_stride1, adr_stride2;
 6692   int stride2x2 = 0x40;
 6693   Address::ScaleFactor scale = Address::no_scale;
 6694   Address::ScaleFactor scale1 = Address::no_scale;
 6695   Address::ScaleFactor scale2 = Address::no_scale;
 6696 
 6697   if (ae != StrIntrinsicNode::LL) {
 6698     stride2x2 = 0x20;
 6699   }
 6700 
 6701   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
 6702     shrl(cnt2, 1);
 6703   }
 6704   // Compute the minimum of the string lengths and the
 6705   // difference of the string lengths (stack).
 6706   // Do the conditional move stuff
 6707   movl(result, cnt1);
 6708   subl(cnt1, cnt2);
 6709   push(cnt1);
 6710   cmov32(Assembler::lessEqual, cnt2, result);    // cnt2 = min(cnt1, cnt2)
 6711 
 6712   // Is the minimum length zero?
 6713   testl(cnt2, cnt2);
 6714   jcc(Assembler::zero, LENGTH_DIFF_LABEL);
 6715   if (ae == StrIntrinsicNode::LL) {
 6716     // Load first bytes
 6717     load_unsigned_byte(result, Address(str1, 0));  // result = str1[0]
 6718     load_unsigned_byte(cnt1, Address(str2, 0));    // cnt1   = str2[0]
 6719   } else if (ae == StrIntrinsicNode::UU) {
 6720     // Load first characters
 6721     load_unsigned_short(result, Address(str1, 0));
 6722     load_unsigned_short(cnt1, Address(str2, 0));
 6723   } else {
 6724     load_unsigned_byte(result, Address(str1, 0));
 6725     load_unsigned_short(cnt1, Address(str2, 0));
 6726   }
 6727   subl(result, cnt1);
 6728   jcc(Assembler::notZero,  POP_LABEL);
 6729 
 6730   if (ae == StrIntrinsicNode::UU) {
 6731     // Divide length by 2 to get number of chars
 6732     shrl(cnt2, 1);
 6733   }
 6734   cmpl(cnt2, 1);
 6735   jcc(Assembler::equal, LENGTH_DIFF_LABEL);
 6736 
 6737   // Check if the strings start at the same location and setup scale and stride
 6738   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6739     cmpptr(str1, str2);
 6740     jcc(Assembler::equal, LENGTH_DIFF_LABEL);
 6741     if (ae == StrIntrinsicNode::LL) {
 6742       scale = Address::times_1;
 6743       stride = 16;
 6744     } else {
 6745       scale = Address::times_2;
 6746       stride = 8;
 6747     }
 6748   } else {
 6749     scale1 = Address::times_1;
 6750     scale2 = Address::times_2;
 6751     // scale not used
 6752     stride = 8;
 6753   }
 6754 
 6755   if (UseAVX &gt;= 2 &amp;&amp; UseSSE42Intrinsics) {
 6756     Label COMPARE_WIDE_VECTORS, VECTOR_NOT_EQUAL, COMPARE_WIDE_TAIL, COMPARE_SMALL_STR;
 6757     Label COMPARE_WIDE_VECTORS_LOOP, COMPARE_16_CHARS, COMPARE_INDEX_CHAR;
 6758     Label COMPARE_WIDE_VECTORS_LOOP_AVX2;
 6759     Label COMPARE_TAIL_LONG;
 6760     Label COMPARE_WIDE_VECTORS_LOOP_AVX3;  // used only _LP64 &amp;&amp; AVX3
 6761 
 6762     int pcmpmask = 0x19;
 6763     if (ae == StrIntrinsicNode::LL) {
 6764       pcmpmask &amp;= ~0x01;
 6765     }
 6766 
 6767     // Setup to compare 16-chars (32-bytes) vectors,
 6768     // start from first character again because it has aligned address.
 6769     if (ae == StrIntrinsicNode::LL) {
 6770       stride2 = 32;
 6771     } else {
 6772       stride2 = 16;
 6773     }
 6774     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6775       adr_stride = stride &lt;&lt; scale;
 6776     } else {
 6777       adr_stride1 = 8;  //stride &lt;&lt; scale1;
 6778       adr_stride2 = 16; //stride &lt;&lt; scale2;
 6779     }
 6780 
 6781     assert(result == rax &amp;&amp; cnt2 == rdx &amp;&amp; cnt1 == rcx, &quot;pcmpestri&quot;);
 6782     // rax and rdx are used by pcmpestri as elements counters
 6783     movl(result, cnt2);
 6784     andl(cnt2, ~(stride2-1));   // cnt2 holds the vector count
 6785     jcc(Assembler::zero, COMPARE_TAIL_LONG);
 6786 
 6787     // fast path : compare first 2 8-char vectors.
 6788     bind(COMPARE_16_CHARS);
 6789     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6790       movdqu(vec1, Address(str1, 0));
 6791     } else {
 6792       pmovzxbw(vec1, Address(str1, 0));
 6793     }
 6794     pcmpestri(vec1, Address(str2, 0), pcmpmask);
 6795     jccb(Assembler::below, COMPARE_INDEX_CHAR);
 6796 
 6797     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6798       movdqu(vec1, Address(str1, adr_stride));
 6799       pcmpestri(vec1, Address(str2, adr_stride), pcmpmask);
 6800     } else {
 6801       pmovzxbw(vec1, Address(str1, adr_stride1));
 6802       pcmpestri(vec1, Address(str2, adr_stride2), pcmpmask);
 6803     }
 6804     jccb(Assembler::aboveEqual, COMPARE_WIDE_VECTORS);
 6805     addl(cnt1, stride);
 6806 
 6807     // Compare the characters at index in cnt1
 6808     bind(COMPARE_INDEX_CHAR); // cnt1 has the offset of the mismatching character
 6809     load_next_elements(result, cnt2, str1, str2, scale, scale1, scale2, cnt1, ae);
 6810     subl(result, cnt2);
 6811     jmp(POP_LABEL);
 6812 
 6813     // Setup the registers to start vector comparison loop
 6814     bind(COMPARE_WIDE_VECTORS);
 6815     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6816       lea(str1, Address(str1, result, scale));
 6817       lea(str2, Address(str2, result, scale));
 6818     } else {
 6819       lea(str1, Address(str1, result, scale1));
 6820       lea(str2, Address(str2, result, scale2));
 6821     }
 6822     subl(result, stride2);
 6823     subl(cnt2, stride2);
 6824     jcc(Assembler::zero, COMPARE_WIDE_TAIL);
 6825     negptr(result);
 6826 
 6827     //  In a loop, compare 16-chars (32-bytes) at once using (vpxor+vptest)
 6828     bind(COMPARE_WIDE_VECTORS_LOOP);
 6829 
 6830 #ifdef _LP64
 6831     if ((AVX3Threshold == 0) &amp;&amp; VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop
 6832       cmpl(cnt2, stride2x2);
 6833       jccb(Assembler::below, COMPARE_WIDE_VECTORS_LOOP_AVX2);
 6834       testl(cnt2, stride2x2-1);   // cnt2 holds the vector count
 6835       jccb(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP_AVX2);   // means we cannot subtract by 0x40
 6836 
 6837       bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop
 6838       if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6839         evmovdquq(vec1, Address(str1, result, scale), Assembler::AVX_512bit);
 6840         evpcmpeqb(k7, vec1, Address(str2, result, scale), Assembler::AVX_512bit); // k7 == 11..11, if operands equal, otherwise k7 has some 0
 6841       } else {
 6842         vpmovzxbw(vec1, Address(str1, result, scale1), Assembler::AVX_512bit);
 6843         evpcmpeqb(k7, vec1, Address(str2, result, scale2), Assembler::AVX_512bit); // k7 == 11..11, if operands equal, otherwise k7 has some 0
 6844       }
 6845       kortestql(k7, k7);
 6846       jcc(Assembler::aboveEqual, COMPARE_WIDE_VECTORS_LOOP_FAILED);     // miscompare
 6847       addptr(result, stride2x2);  // update since we already compared at this addr
 6848       subl(cnt2, stride2x2);      // and sub the size too
 6849       jccb(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP_AVX3);
 6850 
 6851       vpxor(vec1, vec1);
 6852       jmpb(COMPARE_WIDE_TAIL);
 6853     }//if (VM_Version::supports_avx512vlbw())
 6854 #endif // _LP64
 6855 
 6856 
 6857     bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);
 6858     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6859       vmovdqu(vec1, Address(str1, result, scale));
 6860       vpxor(vec1, Address(str2, result, scale));
 6861     } else {
 6862       vpmovzxbw(vec1, Address(str1, result, scale1), Assembler::AVX_256bit);
 6863       vpxor(vec1, Address(str2, result, scale2));
 6864     }
 6865     vptest(vec1, vec1);
 6866     jcc(Assembler::notZero, VECTOR_NOT_EQUAL);
 6867     addptr(result, stride2);
 6868     subl(cnt2, stride2);
 6869     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP);
 6870     // clean upper bits of YMM registers
 6871     vpxor(vec1, vec1);
 6872 
 6873     // compare wide vectors tail
 6874     bind(COMPARE_WIDE_TAIL);
 6875     testptr(result, result);
 6876     jcc(Assembler::zero, LENGTH_DIFF_LABEL);
 6877 
 6878     movl(result, stride2);
 6879     movl(cnt2, result);
 6880     negptr(result);
 6881     jmp(COMPARE_WIDE_VECTORS_LOOP_AVX2);
 6882 
 6883     // Identifies the mismatching (higher or lower)16-bytes in the 32-byte vectors.
 6884     bind(VECTOR_NOT_EQUAL);
 6885     // clean upper bits of YMM registers
 6886     vpxor(vec1, vec1);
 6887     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6888       lea(str1, Address(str1, result, scale));
 6889       lea(str2, Address(str2, result, scale));
 6890     } else {
 6891       lea(str1, Address(str1, result, scale1));
 6892       lea(str2, Address(str2, result, scale2));
 6893     }
 6894     jmp(COMPARE_16_CHARS);
 6895 
 6896     // Compare tail chars, length between 1 to 15 chars
 6897     bind(COMPARE_TAIL_LONG);
 6898     movl(cnt2, result);
 6899     cmpl(cnt2, stride);
 6900     jcc(Assembler::less, COMPARE_SMALL_STR);
 6901 
 6902     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6903       movdqu(vec1, Address(str1, 0));
 6904     } else {
 6905       pmovzxbw(vec1, Address(str1, 0));
 6906     }
 6907     pcmpestri(vec1, Address(str2, 0), pcmpmask);
 6908     jcc(Assembler::below, COMPARE_INDEX_CHAR);
 6909     subptr(cnt2, stride);
 6910     jcc(Assembler::zero, LENGTH_DIFF_LABEL);
 6911     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6912       lea(str1, Address(str1, result, scale));
 6913       lea(str2, Address(str2, result, scale));
 6914     } else {
 6915       lea(str1, Address(str1, result, scale1));
 6916       lea(str2, Address(str2, result, scale2));
 6917     }
 6918     negptr(cnt2);
 6919     jmpb(WHILE_HEAD_LABEL);
 6920 
 6921     bind(COMPARE_SMALL_STR);
 6922   } else if (UseSSE42Intrinsics) {
 6923     Label COMPARE_WIDE_VECTORS, VECTOR_NOT_EQUAL, COMPARE_TAIL;
 6924     int pcmpmask = 0x19;
 6925     // Setup to compare 8-char (16-byte) vectors,
 6926     // start from first character again because it has aligned address.
 6927     movl(result, cnt2);
 6928     andl(cnt2, ~(stride - 1));   // cnt2 holds the vector count
 6929     if (ae == StrIntrinsicNode::LL) {
 6930       pcmpmask &amp;= ~0x01;
 6931     }
 6932     jcc(Assembler::zero, COMPARE_TAIL);
 6933     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6934       lea(str1, Address(str1, result, scale));
 6935       lea(str2, Address(str2, result, scale));
 6936     } else {
 6937       lea(str1, Address(str1, result, scale1));
 6938       lea(str2, Address(str2, result, scale2));
 6939     }
 6940     negptr(result);
 6941 
 6942     // pcmpestri
 6943     //   inputs:
 6944     //     vec1- substring
 6945     //     rax - negative string length (elements count)
 6946     //     mem - scanned string
 6947     //     rdx - string length (elements count)
 6948     //     pcmpmask - cmp mode: 11000 (string compare with negated result)
 6949     //               + 00 (unsigned bytes) or  + 01 (unsigned shorts)
 6950     //   outputs:
 6951     //     rcx - first mismatched element index
 6952     assert(result == rax &amp;&amp; cnt2 == rdx &amp;&amp; cnt1 == rcx, &quot;pcmpestri&quot;);
 6953 
 6954     bind(COMPARE_WIDE_VECTORS);
 6955     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6956       movdqu(vec1, Address(str1, result, scale));
 6957       pcmpestri(vec1, Address(str2, result, scale), pcmpmask);
 6958     } else {
 6959       pmovzxbw(vec1, Address(str1, result, scale1));
 6960       pcmpestri(vec1, Address(str2, result, scale2), pcmpmask);
 6961     }
 6962     // After pcmpestri cnt1(rcx) contains mismatched element index
 6963 
 6964     jccb(Assembler::below, VECTOR_NOT_EQUAL);  // CF==1
 6965     addptr(result, stride);
 6966     subptr(cnt2, stride);
 6967     jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);
 6968 
 6969     // compare wide vectors tail
 6970     testptr(result, result);
 6971     jcc(Assembler::zero, LENGTH_DIFF_LABEL);
 6972 
 6973     movl(cnt2, stride);
 6974     movl(result, stride);
 6975     negptr(result);
 6976     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6977       movdqu(vec1, Address(str1, result, scale));
 6978       pcmpestri(vec1, Address(str2, result, scale), pcmpmask);
 6979     } else {
 6980       pmovzxbw(vec1, Address(str1, result, scale1));
 6981       pcmpestri(vec1, Address(str2, result, scale2), pcmpmask);
 6982     }
 6983     jccb(Assembler::aboveEqual, LENGTH_DIFF_LABEL);
 6984 
 6985     // Mismatched characters in the vectors
 6986     bind(VECTOR_NOT_EQUAL);
 6987     addptr(cnt1, result);
 6988     load_next_elements(result, cnt2, str1, str2, scale, scale1, scale2, cnt1, ae);
 6989     subl(result, cnt2);
 6990     jmpb(POP_LABEL);
 6991 
 6992     bind(COMPARE_TAIL); // limit is zero
 6993     movl(cnt2, result);
 6994     // Fallthru to tail compare
 6995   }
 6996   // Shift str2 and str1 to the end of the arrays, negate min
 6997   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6998     lea(str1, Address(str1, cnt2, scale));
 6999     lea(str2, Address(str2, cnt2, scale));
 7000   } else {
 7001     lea(str1, Address(str1, cnt2, scale1));
 7002     lea(str2, Address(str2, cnt2, scale2));
 7003   }
 7004   decrementl(cnt2);  // first character was compared already
 7005   negptr(cnt2);
 7006 
 7007   // Compare the rest of the elements
 7008   bind(WHILE_HEAD_LABEL);
 7009   load_next_elements(result, cnt1, str1, str2, scale, scale1, scale2, cnt2, ae);
 7010   subl(result, cnt1);
 7011   jccb(Assembler::notZero, POP_LABEL);
 7012   increment(cnt2);
 7013   jccb(Assembler::notZero, WHILE_HEAD_LABEL);
 7014 
 7015   // Strings are equal up to min length.  Return the length difference.
 7016   bind(LENGTH_DIFF_LABEL);
 7017   pop(result);
 7018   if (ae == StrIntrinsicNode::UU) {
 7019     // Divide diff by 2 to get number of chars
 7020     sarl(result, 1);
 7021   }
 7022   jmpb(DONE_LABEL);
 7023 
 7024 #ifdef _LP64
 7025   if (VM_Version::supports_avx512vlbw()) {
 7026 
 7027     bind(COMPARE_WIDE_VECTORS_LOOP_FAILED);
 7028 
 7029     kmovql(cnt1, k7);
 7030     notq(cnt1);
 7031     bsfq(cnt2, cnt1);
 7032     if (ae != StrIntrinsicNode::LL) {
 7033       // Divide diff by 2 to get number of chars
 7034       sarl(cnt2, 1);
 7035     }
 7036     addq(result, cnt2);
 7037     if (ae == StrIntrinsicNode::LL) {
 7038       load_unsigned_byte(cnt1, Address(str2, result));
 7039       load_unsigned_byte(result, Address(str1, result));
 7040     } else if (ae == StrIntrinsicNode::UU) {
 7041       load_unsigned_short(cnt1, Address(str2, result, scale));
 7042       load_unsigned_short(result, Address(str1, result, scale));
 7043     } else {
 7044       load_unsigned_short(cnt1, Address(str2, result, scale2));
 7045       load_unsigned_byte(result, Address(str1, result, scale1));
 7046     }
 7047     subl(result, cnt1);
 7048     jmpb(POP_LABEL);
 7049   }//if (VM_Version::supports_avx512vlbw())
 7050 #endif // _LP64
 7051 
 7052   // Discard the stored length difference
 7053   bind(POP_LABEL);
 7054   pop(cnt1);
 7055 
 7056   // That&#39;s it
 7057   bind(DONE_LABEL);
 7058   if(ae == StrIntrinsicNode::UL) {
 7059     negl(result);
 7060   }
 7061 
 7062 }
 7063 
 7064 // Search for Non-ASCII character (Negative byte value) in a byte array,
 7065 // return true if it has any and false otherwise.
 7066 //   ..\jdk\src\java.base\share\classes\java\lang\StringCoding.java
 7067 //   @HotSpotIntrinsicCandidate
 7068 //   private static boolean hasNegatives(byte[] ba, int off, int len) {
 7069 //     for (int i = off; i &lt; off + len; i++) {
 7070 //       if (ba[i] &lt; 0) {
 7071 //         return true;
 7072 //       }
 7073 //     }
 7074 //     return false;
 7075 //   }
 7076 void MacroAssembler::has_negatives(Register ary1, Register len,
 7077   Register result, Register tmp1,
 7078   XMMRegister vec1, XMMRegister vec2) {
 7079   // rsi: byte array
 7080   // rcx: len
 7081   // rax: result
 7082   ShortBranchVerifier sbv(this);
 7083   assert_different_registers(ary1, len, result, tmp1);
 7084   assert_different_registers(vec1, vec2);
 7085   Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;
 7086 
 7087   // len == 0
 7088   testl(len, len);
 7089   jcc(Assembler::zero, FALSE_LABEL);
 7090 
 7091   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
 7092     VM_Version::supports_avx512vlbw() &amp;&amp;
 7093     VM_Version::supports_bmi2()) {
 7094 
 7095     Label test_64_loop, test_tail;
 7096     Register tmp3_aliased = len;
 7097 
 7098     movl(tmp1, len);
 7099     vpxor(vec2, vec2, vec2, Assembler::AVX_512bit);
 7100 
 7101     andl(tmp1, 64 - 1);   // tail count (in chars) 0x3F
 7102     andl(len, ~(64 - 1));    // vector count (in chars)
 7103     jccb(Assembler::zero, test_tail);
 7104 
 7105     lea(ary1, Address(ary1, len, Address::times_1));
 7106     negptr(len);
 7107 
 7108     bind(test_64_loop);
 7109     // Check whether our 64 elements of size byte contain negatives
 7110     evpcmpgtb(k2, vec2, Address(ary1, len, Address::times_1), Assembler::AVX_512bit);
 7111     kortestql(k2, k2);
 7112     jcc(Assembler::notZero, TRUE_LABEL);
 7113 
 7114     addptr(len, 64);
 7115     jccb(Assembler::notZero, test_64_loop);
 7116 
 7117 
 7118     bind(test_tail);
 7119     // bail out when there is nothing to be done
 7120     testl(tmp1, -1);
 7121     jcc(Assembler::zero, FALSE_LABEL);
 7122 
 7123     // ~(~0 &lt;&lt; len) applied up to two times (for 32-bit scenario)
 7124 #ifdef _LP64
 7125     mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);
 7126     shlxq(tmp3_aliased, tmp3_aliased, tmp1);
 7127     notq(tmp3_aliased);
 7128     kmovql(k3, tmp3_aliased);
 7129 #else
 7130     Label k_init;
 7131     jmp(k_init);
 7132 
 7133     // We could not read 64-bits from a general purpose register thus we move
 7134     // data required to compose 64 1&#39;s to the instruction stream
 7135     // We emit 64 byte wide series of elements from 0..63 which later on would
 7136     // be used as a compare targets with tail count contained in tmp1 register.
 7137     // Result would be a k register having tmp1 consecutive number or 1
 7138     // counting from least significant bit.
 7139     address tmp = pc();
 7140     emit_int64(0x0706050403020100);
 7141     emit_int64(0x0F0E0D0C0B0A0908);
 7142     emit_int64(0x1716151413121110);
 7143     emit_int64(0x1F1E1D1C1B1A1918);
 7144     emit_int64(0x2726252423222120);
 7145     emit_int64(0x2F2E2D2C2B2A2928);
 7146     emit_int64(0x3736353433323130);
 7147     emit_int64(0x3F3E3D3C3B3A3938);
 7148 
 7149     bind(k_init);
 7150     lea(len, InternalAddress(tmp));
 7151     // create mask to test for negative byte inside a vector
 7152     evpbroadcastb(vec1, tmp1, Assembler::AVX_512bit);
 7153     evpcmpgtb(k3, vec1, Address(len, 0), Assembler::AVX_512bit);
 7154 
 7155 #endif
 7156     evpcmpgtb(k2, k3, vec2, Address(ary1, 0), Assembler::AVX_512bit);
 7157     ktestq(k2, k3);
 7158     jcc(Assembler::notZero, TRUE_LABEL);
 7159 
 7160     jmp(FALSE_LABEL);
 7161   } else {
 7162     movl(result, len); // copy
 7163 
 7164     if (UseAVX &gt;= 2 &amp;&amp; UseSSE &gt;= 2) {
 7165       // With AVX2, use 32-byte vector compare
 7166       Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;
 7167 
 7168       // Compare 32-byte vectors
 7169       andl(result, 0x0000001f);  //   tail count (in bytes)
 7170       andl(len, 0xffffffe0);   // vector count (in bytes)
 7171       jccb(Assembler::zero, COMPARE_TAIL);
 7172 
 7173       lea(ary1, Address(ary1, len, Address::times_1));
 7174       negptr(len);
 7175 
 7176       movl(tmp1, 0x80808080);   // create mask to test for Unicode chars in vector
 7177       movdl(vec2, tmp1);
 7178       vpbroadcastd(vec2, vec2, Assembler::AVX_256bit);
 7179 
 7180       bind(COMPARE_WIDE_VECTORS);
 7181       vmovdqu(vec1, Address(ary1, len, Address::times_1));
 7182       vptest(vec1, vec2);
 7183       jccb(Assembler::notZero, TRUE_LABEL);
 7184       addptr(len, 32);
 7185       jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);
 7186 
 7187       testl(result, result);
 7188       jccb(Assembler::zero, FALSE_LABEL);
 7189 
 7190       vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));
 7191       vptest(vec1, vec2);
 7192       jccb(Assembler::notZero, TRUE_LABEL);
 7193       jmpb(FALSE_LABEL);
 7194 
 7195       bind(COMPARE_TAIL); // len is zero
 7196       movl(len, result);
 7197       // Fallthru to tail compare
 7198     } else if (UseSSE42Intrinsics) {
 7199       // With SSE4.2, use double quad vector compare
 7200       Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;
 7201 
 7202       // Compare 16-byte vectors
 7203       andl(result, 0x0000000f);  //   tail count (in bytes)
 7204       andl(len, 0xfffffff0);   // vector count (in bytes)
 7205       jcc(Assembler::zero, COMPARE_TAIL);
 7206 
 7207       lea(ary1, Address(ary1, len, Address::times_1));
 7208       negptr(len);
 7209 
 7210       movl(tmp1, 0x80808080);
 7211       movdl(vec2, tmp1);
 7212       pshufd(vec2, vec2, 0);
 7213 
 7214       bind(COMPARE_WIDE_VECTORS);
 7215       movdqu(vec1, Address(ary1, len, Address::times_1));
 7216       ptest(vec1, vec2);
 7217       jcc(Assembler::notZero, TRUE_LABEL);
 7218       addptr(len, 16);
 7219       jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);
 7220 
 7221       testl(result, result);
 7222       jcc(Assembler::zero, FALSE_LABEL);
 7223 
 7224       movdqu(vec1, Address(ary1, result, Address::times_1, -16));
 7225       ptest(vec1, vec2);
 7226       jccb(Assembler::notZero, TRUE_LABEL);
 7227       jmpb(FALSE_LABEL);
 7228 
 7229       bind(COMPARE_TAIL); // len is zero
 7230       movl(len, result);
 7231       // Fallthru to tail compare
 7232     }
 7233   }
 7234   // Compare 4-byte vectors
 7235   andl(len, 0xfffffffc); // vector count (in bytes)
 7236   jccb(Assembler::zero, COMPARE_CHAR);
 7237 
 7238   lea(ary1, Address(ary1, len, Address::times_1));
 7239   negptr(len);
 7240 
 7241   bind(COMPARE_VECTORS);
 7242   movl(tmp1, Address(ary1, len, Address::times_1));
 7243   andl(tmp1, 0x80808080);
 7244   jccb(Assembler::notZero, TRUE_LABEL);
 7245   addptr(len, 4);
 7246   jcc(Assembler::notZero, COMPARE_VECTORS);
 7247 
 7248   // Compare trailing char (final 2 bytes), if any
 7249   bind(COMPARE_CHAR);
 7250   testl(result, 0x2);   // tail  char
 7251   jccb(Assembler::zero, COMPARE_BYTE);
 7252   load_unsigned_short(tmp1, Address(ary1, 0));
 7253   andl(tmp1, 0x00008080);
 7254   jccb(Assembler::notZero, TRUE_LABEL);
 7255   subptr(result, 2);
 7256   lea(ary1, Address(ary1, 2));
 7257 
 7258   bind(COMPARE_BYTE);
 7259   testl(result, 0x1);   // tail  byte
 7260   jccb(Assembler::zero, FALSE_LABEL);
 7261   load_unsigned_byte(tmp1, Address(ary1, 0));
 7262   andl(tmp1, 0x00000080);
 7263   jccb(Assembler::notEqual, TRUE_LABEL);
 7264   jmpb(FALSE_LABEL);
 7265 
 7266   bind(TRUE_LABEL);
 7267   movl(result, 1);   // return true
 7268   jmpb(DONE);
 7269 
 7270   bind(FALSE_LABEL);
 7271   xorl(result, result); // return false
 7272 
 7273   // That&#39;s it
 7274   bind(DONE);
 7275   if (UseAVX &gt;= 2 &amp;&amp; UseSSE &gt;= 2) {
 7276     // clean upper bits of YMM registers
 7277     vpxor(vec1, vec1);
 7278     vpxor(vec2, vec2);
 7279   }
 7280 }
 7281 // Compare char[] or byte[] arrays aligned to 4 bytes or substrings.
 7282 void MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,
 7283                                    Register limit, Register result, Register chr,
 7284                                    XMMRegister vec1, XMMRegister vec2, bool is_char) {
 7285   ShortBranchVerifier sbv(this);
 7286   Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;
 7287 
 7288   int length_offset  = arrayOopDesc::length_offset_in_bytes();
 7289   int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);
 7290 
 7291   if (is_array_equ) {
 7292     // Check the input args
 7293     cmpoop(ary1, ary2);
 7294     jcc(Assembler::equal, TRUE_LABEL);
 7295 
 7296     // Need additional checks for arrays_equals.
 7297     testptr(ary1, ary1);
 7298     jcc(Assembler::zero, FALSE_LABEL);
 7299     testptr(ary2, ary2);
 7300     jcc(Assembler::zero, FALSE_LABEL);
 7301 
 7302     // Check the lengths
 7303     movl(limit, Address(ary1, length_offset));
 7304     cmpl(limit, Address(ary2, length_offset));
 7305     jcc(Assembler::notEqual, FALSE_LABEL);
 7306   }
 7307 
 7308   // count == 0
 7309   testl(limit, limit);
 7310   jcc(Assembler::zero, TRUE_LABEL);
 7311 
 7312   if (is_array_equ) {
 7313     // Load array address
 7314     lea(ary1, Address(ary1, base_offset));
 7315     lea(ary2, Address(ary2, base_offset));
 7316   }
 7317 
 7318   if (is_array_equ &amp;&amp; is_char) {
 7319     // arrays_equals when used for char[].
 7320     shll(limit, 1);      // byte count != 0
 7321   }
 7322   movl(result, limit); // copy
 7323 
 7324   if (UseAVX &gt;= 2) {
 7325     // With AVX2, use 32-byte vector compare
 7326     Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;
 7327 
 7328     // Compare 32-byte vectors
 7329     andl(result, 0x0000001f);  //   tail count (in bytes)
 7330     andl(limit, 0xffffffe0);   // vector count (in bytes)
 7331     jcc(Assembler::zero, COMPARE_TAIL);
 7332 
 7333     lea(ary1, Address(ary1, limit, Address::times_1));
 7334     lea(ary2, Address(ary2, limit, Address::times_1));
 7335     negptr(limit);
 7336 
 7337 #ifdef _LP64
 7338     if ((AVX3Threshold == 0) &amp;&amp; VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop
 7339       Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;
 7340 
 7341       cmpl(limit, -64);
 7342       jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);
 7343 
 7344       bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop
 7345 
 7346       evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);
 7347       evpcmpeqb(k7, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);
 7348       kortestql(k7, k7);
 7349       jcc(Assembler::aboveEqual, FALSE_LABEL);     // miscompare
 7350       addptr(limit, 64);  // update since we already compared at this addr
 7351       cmpl(limit, -64);
 7352       jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);
 7353 
 7354       // At this point we may still need to compare -limit+result bytes.
 7355       // We could execute the next two instruction and just continue via non-wide path:
 7356       //  cmpl(limit, 0);
 7357       //  jcc(Assembler::equal, COMPARE_TAIL);  // true
 7358       // But since we stopped at the points ary{1,2}+limit which are
 7359       // not farther than 64 bytes from the ends of arrays ary{1,2}+result
 7360       // (|limit| &lt;= 32 and result &lt; 32),
 7361       // we may just compare the last 64 bytes.
 7362       //
 7363       addptr(result, -64);   // it is safe, bc we just came from this area
 7364       evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);
 7365       evpcmpeqb(k7, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);
 7366       kortestql(k7, k7);
 7367       jcc(Assembler::aboveEqual, FALSE_LABEL);     // miscompare
 7368 
 7369       jmp(TRUE_LABEL);
 7370 
 7371       bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);
 7372 
 7373     }//if (VM_Version::supports_avx512vlbw())
 7374 #endif //_LP64
 7375     bind(COMPARE_WIDE_VECTORS);
 7376     vmovdqu(vec1, Address(ary1, limit, Address::times_1));
 7377     vmovdqu(vec2, Address(ary2, limit, Address::times_1));
 7378     vpxor(vec1, vec2);
 7379 
 7380     vptest(vec1, vec1);
 7381     jcc(Assembler::notZero, FALSE_LABEL);
 7382     addptr(limit, 32);
 7383     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);
 7384 
 7385     testl(result, result);
 7386     jcc(Assembler::zero, TRUE_LABEL);
 7387 
 7388     vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));
 7389     vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));
 7390     vpxor(vec1, vec2);
 7391 
 7392     vptest(vec1, vec1);
 7393     jccb(Assembler::notZero, FALSE_LABEL);
 7394     jmpb(TRUE_LABEL);
 7395 
 7396     bind(COMPARE_TAIL); // limit is zero
 7397     movl(limit, result);
 7398     // Fallthru to tail compare
 7399   } else if (UseSSE42Intrinsics) {
 7400     // With SSE4.2, use double quad vector compare
 7401     Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;
 7402 
 7403     // Compare 16-byte vectors
 7404     andl(result, 0x0000000f);  //   tail count (in bytes)
 7405     andl(limit, 0xfffffff0);   // vector count (in bytes)
 7406     jcc(Assembler::zero, COMPARE_TAIL);
 7407 
 7408     lea(ary1, Address(ary1, limit, Address::times_1));
 7409     lea(ary2, Address(ary2, limit, Address::times_1));
 7410     negptr(limit);
 7411 
 7412     bind(COMPARE_WIDE_VECTORS);
 7413     movdqu(vec1, Address(ary1, limit, Address::times_1));
 7414     movdqu(vec2, Address(ary2, limit, Address::times_1));
 7415     pxor(vec1, vec2);
 7416 
 7417     ptest(vec1, vec1);
 7418     jcc(Assembler::notZero, FALSE_LABEL);
 7419     addptr(limit, 16);
 7420     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);
 7421 
 7422     testl(result, result);
 7423     jcc(Assembler::zero, TRUE_LABEL);
 7424 
 7425     movdqu(vec1, Address(ary1, result, Address::times_1, -16));
 7426     movdqu(vec2, Address(ary2, result, Address::times_1, -16));
 7427     pxor(vec1, vec2);
 7428 
 7429     ptest(vec1, vec1);
 7430     jccb(Assembler::notZero, FALSE_LABEL);
 7431     jmpb(TRUE_LABEL);
 7432 
 7433     bind(COMPARE_TAIL); // limit is zero
 7434     movl(limit, result);
 7435     // Fallthru to tail compare
 7436   }
 7437 
 7438   // Compare 4-byte vectors
 7439   andl(limit, 0xfffffffc); // vector count (in bytes)
 7440   jccb(Assembler::zero, COMPARE_CHAR);
 7441 
 7442   lea(ary1, Address(ary1, limit, Address::times_1));
 7443   lea(ary2, Address(ary2, limit, Address::times_1));
 7444   negptr(limit);
 7445 
 7446   bind(COMPARE_VECTORS);
 7447   movl(chr, Address(ary1, limit, Address::times_1));
 7448   cmpl(chr, Address(ary2, limit, Address::times_1));
 7449   jccb(Assembler::notEqual, FALSE_LABEL);
 7450   addptr(limit, 4);
 7451   jcc(Assembler::notZero, COMPARE_VECTORS);
 7452 
 7453   // Compare trailing char (final 2 bytes), if any
 7454   bind(COMPARE_CHAR);
 7455   testl(result, 0x2);   // tail  char
 7456   jccb(Assembler::zero, COMPARE_BYTE);
 7457   load_unsigned_short(chr, Address(ary1, 0));
 7458   load_unsigned_short(limit, Address(ary2, 0));
 7459   cmpl(chr, limit);
 7460   jccb(Assembler::notEqual, FALSE_LABEL);
 7461 
 7462   if (is_array_equ &amp;&amp; is_char) {
 7463     bind(COMPARE_BYTE);
 7464   } else {
 7465     lea(ary1, Address(ary1, 2));
 7466     lea(ary2, Address(ary2, 2));
 7467 
 7468     bind(COMPARE_BYTE);
 7469     testl(result, 0x1);   // tail  byte
 7470     jccb(Assembler::zero, TRUE_LABEL);
 7471     load_unsigned_byte(chr, Address(ary1, 0));
 7472     load_unsigned_byte(limit, Address(ary2, 0));
 7473     cmpl(chr, limit);
 7474     jccb(Assembler::notEqual, FALSE_LABEL);
 7475   }
 7476   bind(TRUE_LABEL);
 7477   movl(result, 1);   // return true
 7478   jmpb(DONE);
 7479 
 7480   bind(FALSE_LABEL);
 7481   xorl(result, result); // return false
 7482 
 7483   // That&#39;s it
 7484   bind(DONE);
 7485   if (UseAVX &gt;= 2) {
 7486     // clean upper bits of YMM registers
 7487     vpxor(vec1, vec1);
 7488     vpxor(vec2, vec2);
 7489   }
 7490 }
 7491 
 7492 #endif
 7493 
 7494 void MacroAssembler::generate_fill(BasicType t, bool aligned,
 7495                                    Register to, Register value, Register count,
 7496                                    Register rtmp, XMMRegister xtmp) {
 7497   ShortBranchVerifier sbv(this);
 7498   assert_different_registers(to, value, count, rtmp);
 7499   Label L_exit;
 7500   Label L_fill_2_bytes, L_fill_4_bytes;
 7501 
 7502   int shift = -1;
 7503   switch (t) {
 7504     case T_BYTE:
 7505       shift = 2;
 7506       break;
 7507     case T_SHORT:
 7508       shift = 1;
 7509       break;
 7510     case T_INT:
 7511       shift = 0;
 7512       break;
 7513     default: ShouldNotReachHere();
 7514   }
 7515 
 7516   if (t == T_BYTE) {
 7517     andl(value, 0xff);
 7518     movl(rtmp, value);
 7519     shll(rtmp, 8);
 7520     orl(value, rtmp);
 7521   }
 7522   if (t == T_SHORT) {
 7523     andl(value, 0xffff);
 7524   }
 7525   if (t == T_BYTE || t == T_SHORT) {
 7526     movl(rtmp, value);
 7527     shll(rtmp, 16);
 7528     orl(value, rtmp);
 7529   }
 7530 
 7531   cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) fill by element
 7532   jcc(Assembler::below, L_fill_4_bytes); // use unsigned cmp
 7533   if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {
 7534     Label L_skip_align2;
 7535     // align source address at 4 bytes address boundary
 7536     if (t == T_BYTE) {
 7537       Label L_skip_align1;
 7538       // One byte misalignment happens only for byte arrays
 7539       testptr(to, 1);
 7540       jccb(Assembler::zero, L_skip_align1);
 7541       movb(Address(to, 0), value);
 7542       increment(to);
 7543       decrement(count);
 7544       BIND(L_skip_align1);
 7545     }
 7546     // Two bytes misalignment happens only for byte and short (char) arrays
 7547     testptr(to, 2);
 7548     jccb(Assembler::zero, L_skip_align2);
 7549     movw(Address(to, 0), value);
 7550     addptr(to, 2);
 7551     subl(count, 1&lt;&lt;(shift-1));
 7552     BIND(L_skip_align2);
 7553   }
 7554   if (UseSSE &lt; 2) {
 7555     Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
 7556     // Fill 32-byte chunks
 7557     subl(count, 8 &lt;&lt; shift);
 7558     jcc(Assembler::less, L_check_fill_8_bytes);
 7559     align(16);
 7560 
 7561     BIND(L_fill_32_bytes_loop);
 7562 
 7563     for (int i = 0; i &lt; 32; i += 4) {
 7564       movl(Address(to, i), value);
 7565     }
 7566 
 7567     addptr(to, 32);
 7568     subl(count, 8 &lt;&lt; shift);
 7569     jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
 7570     BIND(L_check_fill_8_bytes);
 7571     addl(count, 8 &lt;&lt; shift);
 7572     jccb(Assembler::zero, L_exit);
 7573     jmpb(L_fill_8_bytes);
 7574 
 7575     //
 7576     // length is too short, just fill qwords
 7577     //
 7578     BIND(L_fill_8_bytes_loop);
 7579     movl(Address(to, 0), value);
 7580     movl(Address(to, 4), value);
 7581     addptr(to, 8);
 7582     BIND(L_fill_8_bytes);
 7583     subl(count, 1 &lt;&lt; (shift + 1));
 7584     jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
 7585     // fall through to fill 4 bytes
 7586   } else {
 7587     Label L_fill_32_bytes;
 7588     if (!UseUnalignedLoadStores) {
 7589       // align to 8 bytes, we know we are 4 byte aligned to start
 7590       testptr(to, 4);
 7591       jccb(Assembler::zero, L_fill_32_bytes);
 7592       movl(Address(to, 0), value);
 7593       addptr(to, 4);
 7594       subl(count, 1&lt;&lt;shift);
 7595     }
 7596     BIND(L_fill_32_bytes);
 7597     {
 7598       assert( UseSSE &gt;= 2, &quot;supported cpu only&quot; );
 7599       Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
 7600       movdl(xtmp, value);
 7601       if (UseAVX &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
 7602         Label L_check_fill_32_bytes;
 7603         if (UseAVX &gt; 2) {
 7604           // Fill 64-byte chunks
 7605           Label L_fill_64_bytes_loop_avx3, L_check_fill_64_bytes_avx2;
 7606 
 7607           // If number of bytes to fill &lt; AVX3Threshold, perform fill using AVX2
 7608           cmpl(count, AVX3Threshold);
 7609           jccb(Assembler::below, L_check_fill_64_bytes_avx2);
 7610 
 7611           vpbroadcastd(xtmp, xtmp, Assembler::AVX_512bit);
 7612 
 7613           subl(count, 16 &lt;&lt; shift);
 7614           jccb(Assembler::less, L_check_fill_32_bytes);
 7615           align(16);
 7616 
 7617           BIND(L_fill_64_bytes_loop_avx3);
 7618           evmovdqul(Address(to, 0), xtmp, Assembler::AVX_512bit);
 7619           addptr(to, 64);
 7620           subl(count, 16 &lt;&lt; shift);
 7621           jcc(Assembler::greaterEqual, L_fill_64_bytes_loop_avx3);
 7622           jmpb(L_check_fill_32_bytes);
 7623 
 7624           BIND(L_check_fill_64_bytes_avx2);
 7625         }
 7626         // Fill 64-byte chunks
 7627         Label L_fill_64_bytes_loop;
 7628         vpbroadcastd(xtmp, xtmp, Assembler::AVX_256bit);
 7629 
 7630         subl(count, 16 &lt;&lt; shift);
 7631         jcc(Assembler::less, L_check_fill_32_bytes);
 7632         align(16);
 7633 
 7634         BIND(L_fill_64_bytes_loop);
 7635         vmovdqu(Address(to, 0), xtmp);
 7636         vmovdqu(Address(to, 32), xtmp);
 7637         addptr(to, 64);
 7638         subl(count, 16 &lt;&lt; shift);
 7639         jcc(Assembler::greaterEqual, L_fill_64_bytes_loop);
 7640 
 7641         BIND(L_check_fill_32_bytes);
 7642         addl(count, 8 &lt;&lt; shift);
 7643         jccb(Assembler::less, L_check_fill_8_bytes);
 7644         vmovdqu(Address(to, 0), xtmp);
 7645         addptr(to, 32);
 7646         subl(count, 8 &lt;&lt; shift);
 7647 
 7648         BIND(L_check_fill_8_bytes);
 7649         // clean upper bits of YMM registers
 7650         movdl(xtmp, value);
 7651         pshufd(xtmp, xtmp, 0);
 7652       } else {
 7653         // Fill 32-byte chunks
 7654         pshufd(xtmp, xtmp, 0);
 7655 
 7656         subl(count, 8 &lt;&lt; shift);
 7657         jcc(Assembler::less, L_check_fill_8_bytes);
 7658         align(16);
 7659 
 7660         BIND(L_fill_32_bytes_loop);
 7661 
 7662         if (UseUnalignedLoadStores) {
 7663           movdqu(Address(to, 0), xtmp);
 7664           movdqu(Address(to, 16), xtmp);
 7665         } else {
 7666           movq(Address(to, 0), xtmp);
 7667           movq(Address(to, 8), xtmp);
 7668           movq(Address(to, 16), xtmp);
 7669           movq(Address(to, 24), xtmp);
 7670         }
 7671 
 7672         addptr(to, 32);
 7673         subl(count, 8 &lt;&lt; shift);
 7674         jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
 7675 
 7676         BIND(L_check_fill_8_bytes);
 7677       }
 7678       addl(count, 8 &lt;&lt; shift);
 7679       jccb(Assembler::zero, L_exit);
 7680       jmpb(L_fill_8_bytes);
 7681 
 7682       //
 7683       // length is too short, just fill qwords
 7684       //
 7685       BIND(L_fill_8_bytes_loop);
 7686       movq(Address(to, 0), xtmp);
 7687       addptr(to, 8);
 7688       BIND(L_fill_8_bytes);
 7689       subl(count, 1 &lt;&lt; (shift + 1));
 7690       jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
 7691     }
 7692   }
 7693   // fill trailing 4 bytes
 7694   BIND(L_fill_4_bytes);
 7695   testl(count, 1&lt;&lt;shift);
 7696   jccb(Assembler::zero, L_fill_2_bytes);
 7697   movl(Address(to, 0), value);
 7698   if (t == T_BYTE || t == T_SHORT) {
 7699     Label L_fill_byte;
 7700     addptr(to, 4);
 7701     BIND(L_fill_2_bytes);
 7702     // fill trailing 2 bytes
 7703     testl(count, 1&lt;&lt;(shift-1));
 7704     jccb(Assembler::zero, L_fill_byte);
 7705     movw(Address(to, 0), value);
 7706     if (t == T_BYTE) {
 7707       addptr(to, 2);
 7708       BIND(L_fill_byte);
 7709       // fill trailing byte
 7710       testl(count, 1);
 7711       jccb(Assembler::zero, L_exit);
 7712       movb(Address(to, 0), value);
 7713     } else {
 7714       BIND(L_fill_byte);
 7715     }
 7716   } else {
 7717     BIND(L_fill_2_bytes);
 7718   }
 7719   BIND(L_exit);
 7720 }
 7721 
 7722 // encode char[] to byte[] in ISO_8859_1
 7723    //@HotSpotIntrinsicCandidate
 7724    //private static int implEncodeISOArray(byte[] sa, int sp,
 7725    //byte[] da, int dp, int len) {
 7726    //  int i = 0;
 7727    //  for (; i &lt; len; i++) {
 7728    //    char c = StringUTF16.getChar(sa, sp++);
 7729    //    if (c &gt; &#39;\u00FF&#39;)
 7730    //      break;
 7731    //    da[dp++] = (byte)c;
 7732    //  }
 7733    //  return i;
 7734    //}
 7735 void MacroAssembler::encode_iso_array(Register src, Register dst, Register len,
 7736   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
 7737   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
 7738   Register tmp5, Register result) {
 7739 
 7740   // rsi: src
 7741   // rdi: dst
 7742   // rdx: len
 7743   // rcx: tmp5
 7744   // rax: result
 7745   ShortBranchVerifier sbv(this);
 7746   assert_different_registers(src, dst, len, tmp5, result);
 7747   Label L_done, L_copy_1_char, L_copy_1_char_exit;
 7748 
 7749   // set result
 7750   xorl(result, result);
 7751   // check for zero length
 7752   testl(len, len);
 7753   jcc(Assembler::zero, L_done);
 7754 
 7755   movl(result, len);
 7756 
 7757   // Setup pointers
 7758   lea(src, Address(src, len, Address::times_2)); // char[]
 7759   lea(dst, Address(dst, len, Address::times_1)); // byte[]
 7760   negptr(len);
 7761 
 7762   if (UseSSE42Intrinsics || UseAVX &gt;= 2) {
 7763     Label L_copy_8_chars, L_copy_8_chars_exit;
 7764     Label L_chars_16_check, L_copy_16_chars, L_copy_16_chars_exit;
 7765 
 7766     if (UseAVX &gt;= 2) {
 7767       Label L_chars_32_check, L_copy_32_chars, L_copy_32_chars_exit;
 7768       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
 7769       movdl(tmp1Reg, tmp5);
 7770       vpbroadcastd(tmp1Reg, tmp1Reg, Assembler::AVX_256bit);
 7771       jmp(L_chars_32_check);
 7772 
 7773       bind(L_copy_32_chars);
 7774       vmovdqu(tmp3Reg, Address(src, len, Address::times_2, -64));
 7775       vmovdqu(tmp4Reg, Address(src, len, Address::times_2, -32));
 7776       vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
 7777       vptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
 7778       jccb(Assembler::notZero, L_copy_32_chars_exit);
 7779       vpackuswb(tmp3Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
 7780       vpermq(tmp4Reg, tmp3Reg, 0xD8, /* vector_len */ 1);
 7781       vmovdqu(Address(dst, len, Address::times_1, -32), tmp4Reg);
 7782 
 7783       bind(L_chars_32_check);
 7784       addptr(len, 32);
 7785       jcc(Assembler::lessEqual, L_copy_32_chars);
 7786 
 7787       bind(L_copy_32_chars_exit);
 7788       subptr(len, 16);
 7789       jccb(Assembler::greater, L_copy_16_chars_exit);
 7790 
 7791     } else if (UseSSE42Intrinsics) {
 7792       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
 7793       movdl(tmp1Reg, tmp5);
 7794       pshufd(tmp1Reg, tmp1Reg, 0);
 7795       jmpb(L_chars_16_check);
 7796     }
 7797 
 7798     bind(L_copy_16_chars);
 7799     if (UseAVX &gt;= 2) {
 7800       vmovdqu(tmp2Reg, Address(src, len, Address::times_2, -32));
 7801       vptest(tmp2Reg, tmp1Reg);
 7802       jcc(Assembler::notZero, L_copy_16_chars_exit);
 7803       vpackuswb(tmp2Reg, tmp2Reg, tmp1Reg, /* vector_len */ 1);
 7804       vpermq(tmp3Reg, tmp2Reg, 0xD8, /* vector_len */ 1);
 7805     } else {
 7806       if (UseAVX &gt; 0) {
 7807         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
 7808         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
 7809         vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 0);
 7810       } else {
 7811         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
 7812         por(tmp2Reg, tmp3Reg);
 7813         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
 7814         por(tmp2Reg, tmp4Reg);
 7815       }
 7816       ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
 7817       jccb(Assembler::notZero, L_copy_16_chars_exit);
 7818       packuswb(tmp3Reg, tmp4Reg);
 7819     }
 7820     movdqu(Address(dst, len, Address::times_1, -16), tmp3Reg);
 7821 
 7822     bind(L_chars_16_check);
 7823     addptr(len, 16);
 7824     jcc(Assembler::lessEqual, L_copy_16_chars);
 7825 
 7826     bind(L_copy_16_chars_exit);
 7827     if (UseAVX &gt;= 2) {
 7828       // clean upper bits of YMM registers
 7829       vpxor(tmp2Reg, tmp2Reg);
 7830       vpxor(tmp3Reg, tmp3Reg);
 7831       vpxor(tmp4Reg, tmp4Reg);
 7832       movdl(tmp1Reg, tmp5);
 7833       pshufd(tmp1Reg, tmp1Reg, 0);
 7834     }
 7835     subptr(len, 8);
 7836     jccb(Assembler::greater, L_copy_8_chars_exit);
 7837 
 7838     bind(L_copy_8_chars);
 7839     movdqu(tmp3Reg, Address(src, len, Address::times_2, -16));
 7840     ptest(tmp3Reg, tmp1Reg);
 7841     jccb(Assembler::notZero, L_copy_8_chars_exit);
 7842     packuswb(tmp3Reg, tmp1Reg);
 7843     movq(Address(dst, len, Address::times_1, -8), tmp3Reg);
 7844     addptr(len, 8);
 7845     jccb(Assembler::lessEqual, L_copy_8_chars);
 7846 
 7847     bind(L_copy_8_chars_exit);
 7848     subptr(len, 8);
 7849     jccb(Assembler::zero, L_done);
 7850   }
 7851 
 7852   bind(L_copy_1_char);
 7853   load_unsigned_short(tmp5, Address(src, len, Address::times_2, 0));
 7854   testl(tmp5, 0xff00);      // check if Unicode char
 7855   jccb(Assembler::notZero, L_copy_1_char_exit);
 7856   movb(Address(dst, len, Address::times_1, 0), tmp5);
 7857   addptr(len, 1);
 7858   jccb(Assembler::less, L_copy_1_char);
 7859 
 7860   bind(L_copy_1_char_exit);
 7861   addptr(result, len); // len is negative count of not processed elements
 7862 
 7863   bind(L_done);
 7864 }
 7865 
 7866 #ifdef _LP64
 7867 /**
 7868  * Helper for multiply_to_len().
 7869  */
 7870 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
 7871   addq(dest_lo, src1);
 7872   adcq(dest_hi, 0);
 7873   addq(dest_lo, src2);
 7874   adcq(dest_hi, 0);
 7875 }
 7876 
 7877 /**
 7878  * Multiply 64 bit by 64 bit first loop.
 7879  */
 7880 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
 7881                                            Register y, Register y_idx, Register z,
 7882                                            Register carry, Register product,
 7883                                            Register idx, Register kdx) {
 7884   //
 7885   //  jlong carry, x[], y[], z[];
 7886   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
 7887   //    huge_128 product = y[idx] * x[xstart] + carry;
 7888   //    z[kdx] = (jlong)product;
 7889   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
 7890   //  }
 7891   //  z[xstart] = carry;
 7892   //
 7893 
 7894   Label L_first_loop, L_first_loop_exit;
 7895   Label L_one_x, L_one_y, L_multiply;
 7896 
 7897   decrementl(xstart);
 7898   jcc(Assembler::negative, L_one_x);
 7899 
 7900   movq(x_xstart, Address(x, xstart, Address::times_4,  0));
 7901   rorq(x_xstart, 32); // convert big-endian to little-endian
 7902 
 7903   bind(L_first_loop);
 7904   decrementl(idx);
 7905   jcc(Assembler::negative, L_first_loop_exit);
 7906   decrementl(idx);
 7907   jcc(Assembler::negative, L_one_y);
 7908   movq(y_idx, Address(y, idx, Address::times_4,  0));
 7909   rorq(y_idx, 32); // convert big-endian to little-endian
 7910   bind(L_multiply);
 7911   movq(product, x_xstart);
 7912   mulq(y_idx); // product(rax) * y_idx -&gt; rdx:rax
 7913   addq(product, carry);
 7914   adcq(rdx, 0);
 7915   subl(kdx, 2);
 7916   movl(Address(z, kdx, Address::times_4,  4), product);
 7917   shrq(product, 32);
 7918   movl(Address(z, kdx, Address::times_4,  0), product);
 7919   movq(carry, rdx);
 7920   jmp(L_first_loop);
 7921 
 7922   bind(L_one_y);
 7923   movl(y_idx, Address(y,  0));
 7924   jmp(L_multiply);
 7925 
 7926   bind(L_one_x);
 7927   movl(x_xstart, Address(x,  0));
 7928   jmp(L_first_loop);
 7929 
 7930   bind(L_first_loop_exit);
 7931 }
 7932 
 7933 /**
 7934  * Multiply 64 bit by 64 bit and add 128 bit.
 7935  */
 7936 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y, Register z,
 7937                                             Register yz_idx, Register idx,
 7938                                             Register carry, Register product, int offset) {
 7939   //     huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
 7940   //     z[kdx] = (jlong)product;
 7941 
 7942   movq(yz_idx, Address(y, idx, Address::times_4,  offset));
 7943   rorq(yz_idx, 32); // convert big-endian to little-endian
 7944   movq(product, x_xstart);
 7945   mulq(yz_idx);     // product(rax) * yz_idx -&gt; rdx:product(rax)
 7946   movq(yz_idx, Address(z, idx, Address::times_4,  offset));
 7947   rorq(yz_idx, 32); // convert big-endian to little-endian
 7948 
 7949   add2_with_carry(rdx, product, carry, yz_idx);
 7950 
 7951   movl(Address(z, idx, Address::times_4,  offset+4), product);
 7952   shrq(product, 32);
 7953   movl(Address(z, idx, Address::times_4,  offset), product);
 7954 
 7955 }
 7956 
 7957 /**
 7958  * Multiply 128 bit by 128 bit. Unrolled inner loop.
 7959  */
 7960 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
 7961                                              Register yz_idx, Register idx, Register jdx,
 7962                                              Register carry, Register product,
 7963                                              Register carry2) {
 7964   //   jlong carry, x[], y[], z[];
 7965   //   int kdx = ystart+1;
 7966   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
 7967   //     huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
 7968   //     z[kdx+idx+1] = (jlong)product;
 7969   //     jlong carry2  = (jlong)(product &gt;&gt;&gt; 64);
 7970   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
 7971   //     z[kdx+idx] = (jlong)product;
 7972   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
 7973   //   }
 7974   //   idx += 2;
 7975   //   if (idx &gt; 0) {
 7976   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
 7977   //     z[kdx+idx] = (jlong)product;
 7978   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
 7979   //   }
 7980   //
 7981 
 7982   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
 7983 
 7984   movl(jdx, idx);
 7985   andl(jdx, 0xFFFFFFFC);
 7986   shrl(jdx, 2);
 7987 
 7988   bind(L_third_loop);
 7989   subl(jdx, 1);
 7990   jcc(Assembler::negative, L_third_loop_exit);
 7991   subl(idx, 4);
 7992 
 7993   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
 7994   movq(carry2, rdx);
 7995 
 7996   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
 7997   movq(carry, rdx);
 7998   jmp(L_third_loop);
 7999 
 8000   bind (L_third_loop_exit);
 8001 
 8002   andl (idx, 0x3);
 8003   jcc(Assembler::zero, L_post_third_loop_done);
 8004 
 8005   Label L_check_1;
 8006   subl(idx, 2);
 8007   jcc(Assembler::negative, L_check_1);
 8008 
 8009   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
 8010   movq(carry, rdx);
 8011 
 8012   bind (L_check_1);
 8013   addl (idx, 0x2);
 8014   andl (idx, 0x1);
 8015   subl(idx, 1);
 8016   jcc(Assembler::negative, L_post_third_loop_done);
 8017 
 8018   movl(yz_idx, Address(y, idx, Address::times_4,  0));
 8019   movq(product, x_xstart);
 8020   mulq(yz_idx); // product(rax) * yz_idx -&gt; rdx:product(rax)
 8021   movl(yz_idx, Address(z, idx, Address::times_4,  0));
 8022 
 8023   add2_with_carry(rdx, product, yz_idx, carry);
 8024 
 8025   movl(Address(z, idx, Address::times_4,  0), product);
 8026   shrq(product, 32);
 8027 
 8028   shlq(rdx, 32);
 8029   orq(product, rdx);
 8030   movq(carry, product);
 8031 
 8032   bind(L_post_third_loop_done);
 8033 }
 8034 
 8035 /**
 8036  * Multiply 128 bit by 128 bit using BMI2. Unrolled inner loop.
 8037  *
 8038  */
 8039 void MacroAssembler::multiply_128_x_128_bmi2_loop(Register y, Register z,
 8040                                                   Register carry, Register carry2,
 8041                                                   Register idx, Register jdx,
 8042                                                   Register yz_idx1, Register yz_idx2,
 8043                                                   Register tmp, Register tmp3, Register tmp4) {
 8044   assert(UseBMI2Instructions, &quot;should be used only when BMI2 is available&quot;);
 8045 
 8046   //   jlong carry, x[], y[], z[];
 8047   //   int kdx = ystart+1;
 8048   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
 8049   //     huge_128 tmp3 = (y[idx+1] * rdx) + z[kdx+idx+1] + carry;
 8050   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
 8051   //     huge_128 tmp4 = (y[idx]   * rdx) + z[kdx+idx] + carry2;
 8052   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
 8053   //     z[kdx+idx+1] = (jlong)tmp3;
 8054   //     z[kdx+idx] = (jlong)tmp4;
 8055   //   }
 8056   //   idx += 2;
 8057   //   if (idx &gt; 0) {
 8058   //     yz_idx1 = (y[idx] * rdx) + z[kdx+idx] + carry;
 8059   //     z[kdx+idx] = (jlong)yz_idx1;
 8060   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
 8061   //   }
 8062   //
 8063 
 8064   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
 8065 
 8066   movl(jdx, idx);
 8067   andl(jdx, 0xFFFFFFFC);
 8068   shrl(jdx, 2);
 8069 
 8070   bind(L_third_loop);
 8071   subl(jdx, 1);
 8072   jcc(Assembler::negative, L_third_loop_exit);
 8073   subl(idx, 4);
 8074 
 8075   movq(yz_idx1,  Address(y, idx, Address::times_4,  8));
 8076   rorxq(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
 8077   movq(yz_idx2, Address(y, idx, Address::times_4,  0));
 8078   rorxq(yz_idx2, yz_idx2, 32);
 8079 
 8080   mulxq(tmp4, tmp3, yz_idx1);  //  yz_idx1 * rdx -&gt; tmp4:tmp3
 8081   mulxq(carry2, tmp, yz_idx2); //  yz_idx2 * rdx -&gt; carry2:tmp
 8082 
 8083   movq(yz_idx1,  Address(z, idx, Address::times_4,  8));
 8084   rorxq(yz_idx1, yz_idx1, 32);
 8085   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
 8086   rorxq(yz_idx2, yz_idx2, 32);
 8087 
 8088   if (VM_Version::supports_adx()) {
 8089     adcxq(tmp3, carry);
 8090     adoxq(tmp3, yz_idx1);
 8091 
 8092     adcxq(tmp4, tmp);
 8093     adoxq(tmp4, yz_idx2);
 8094 
 8095     movl(carry, 0); // does not affect flags
 8096     adcxq(carry2, carry);
 8097     adoxq(carry2, carry);
 8098   } else {
 8099     add2_with_carry(tmp4, tmp3, carry, yz_idx1);
 8100     add2_with_carry(carry2, tmp4, tmp, yz_idx2);
 8101   }
 8102   movq(carry, carry2);
 8103 
 8104   movl(Address(z, idx, Address::times_4, 12), tmp3);
 8105   shrq(tmp3, 32);
 8106   movl(Address(z, idx, Address::times_4,  8), tmp3);
 8107 
 8108   movl(Address(z, idx, Address::times_4,  4), tmp4);
 8109   shrq(tmp4, 32);
 8110   movl(Address(z, idx, Address::times_4,  0), tmp4);
 8111 
 8112   jmp(L_third_loop);
 8113 
 8114   bind (L_third_loop_exit);
 8115 
 8116   andl (idx, 0x3);
 8117   jcc(Assembler::zero, L_post_third_loop_done);
 8118 
 8119   Label L_check_1;
 8120   subl(idx, 2);
 8121   jcc(Assembler::negative, L_check_1);
 8122 
 8123   movq(yz_idx1, Address(y, idx, Address::times_4,  0));
 8124   rorxq(yz_idx1, yz_idx1, 32);
 8125   mulxq(tmp4, tmp3, yz_idx1); //  yz_idx1 * rdx -&gt; tmp4:tmp3
 8126   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
 8127   rorxq(yz_idx2, yz_idx2, 32);
 8128 
 8129   add2_with_carry(tmp4, tmp3, carry, yz_idx2);
 8130 
 8131   movl(Address(z, idx, Address::times_4,  4), tmp3);
 8132   shrq(tmp3, 32);
 8133   movl(Address(z, idx, Address::times_4,  0), tmp3);
 8134   movq(carry, tmp4);
 8135 
 8136   bind (L_check_1);
 8137   addl (idx, 0x2);
 8138   andl (idx, 0x1);
 8139   subl(idx, 1);
 8140   jcc(Assembler::negative, L_post_third_loop_done);
 8141   movl(tmp4, Address(y, idx, Address::times_4,  0));
 8142   mulxq(carry2, tmp3, tmp4);  //  tmp4 * rdx -&gt; carry2:tmp3
 8143   movl(tmp4, Address(z, idx, Address::times_4,  0));
 8144 
 8145   add2_with_carry(carry2, tmp3, tmp4, carry);
 8146 
 8147   movl(Address(z, idx, Address::times_4,  0), tmp3);
 8148   shrq(tmp3, 32);
 8149 
 8150   shlq(carry2, 32);
 8151   orq(tmp3, carry2);
 8152   movq(carry, tmp3);
 8153 
 8154   bind(L_post_third_loop_done);
 8155 }
 8156 
 8157 /**
 8158  * Code for BigInteger::multiplyToLen() instrinsic.
 8159  *
 8160  * rdi: x
 8161  * rax: xlen
 8162  * rsi: y
 8163  * rcx: ylen
 8164  * r8:  z
 8165  * r11: zlen
 8166  * r12: tmp1
 8167  * r13: tmp2
 8168  * r14: tmp3
 8169  * r15: tmp4
 8170  * rbx: tmp5
 8171  *
 8172  */
 8173 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
 8174                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {
 8175   ShortBranchVerifier sbv(this);
 8176   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);
 8177 
 8178   push(tmp1);
 8179   push(tmp2);
 8180   push(tmp3);
 8181   push(tmp4);
 8182   push(tmp5);
 8183 
 8184   push(xlen);
 8185   push(zlen);
 8186 
 8187   const Register idx = tmp1;
 8188   const Register kdx = tmp2;
 8189   const Register xstart = tmp3;
 8190 
 8191   const Register y_idx = tmp4;
 8192   const Register carry = tmp5;
 8193   const Register product  = xlen;
 8194   const Register x_xstart = zlen;  // reuse register
 8195 
 8196   // First Loop.
 8197   //
 8198   //  final static long LONG_MASK = 0xffffffffL;
 8199   //  int xstart = xlen - 1;
 8200   //  int ystart = ylen - 1;
 8201   //  long carry = 0;
 8202   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
 8203   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
 8204   //    z[kdx] = (int)product;
 8205   //    carry = product &gt;&gt;&gt; 32;
 8206   //  }
 8207   //  z[xstart] = (int)carry;
 8208   //
 8209 
 8210   movl(idx, ylen);      // idx = ylen;
 8211   movl(kdx, zlen);      // kdx = xlen+ylen;
 8212   xorq(carry, carry);   // carry = 0;
 8213 
 8214   Label L_done;
 8215 
 8216   movl(xstart, xlen);
 8217   decrementl(xstart);
 8218   jcc(Assembler::negative, L_done);
 8219 
 8220   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
 8221 
 8222   Label L_second_loop;
 8223   testl(kdx, kdx);
 8224   jcc(Assembler::zero, L_second_loop);
 8225 
 8226   Label L_carry;
 8227   subl(kdx, 1);
 8228   jcc(Assembler::zero, L_carry);
 8229 
 8230   movl(Address(z, kdx, Address::times_4,  0), carry);
 8231   shrq(carry, 32);
 8232   subl(kdx, 1);
 8233 
 8234   bind(L_carry);
 8235   movl(Address(z, kdx, Address::times_4,  0), carry);
 8236 
 8237   // Second and third (nested) loops.
 8238   //
 8239   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
 8240   //   carry = 0;
 8241   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
 8242   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
 8243   //                    (z[k] &amp; LONG_MASK) + carry;
 8244   //     z[k] = (int)product;
 8245   //     carry = product &gt;&gt;&gt; 32;
 8246   //   }
 8247   //   z[i] = (int)carry;
 8248   // }
 8249   //
 8250   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
 8251 
 8252   const Register jdx = tmp1;
 8253 
 8254   bind(L_second_loop);
 8255   xorl(carry, carry);    // carry = 0;
 8256   movl(jdx, ylen);       // j = ystart+1
 8257 
 8258   subl(xstart, 1);       // i = xstart-1;
 8259   jcc(Assembler::negative, L_done);
 8260 
 8261   push (z);
 8262 
 8263   Label L_last_x;
 8264   lea(z, Address(z, xstart, Address::times_4, 4)); // z = z + k - j
 8265   subl(xstart, 1);       // i = xstart-1;
 8266   jcc(Assembler::negative, L_last_x);
 8267 
 8268   if (UseBMI2Instructions) {
 8269     movq(rdx,  Address(x, xstart, Address::times_4,  0));
 8270     rorxq(rdx, rdx, 32); // convert big-endian to little-endian
 8271   } else {
 8272     movq(x_xstart, Address(x, xstart, Address::times_4,  0));
 8273     rorq(x_xstart, 32);  // convert big-endian to little-endian
 8274   }
 8275 
 8276   Label L_third_loop_prologue;
 8277   bind(L_third_loop_prologue);
 8278 
 8279   push (x);
 8280   push (xstart);
 8281   push (ylen);
 8282 
 8283 
 8284   if (UseBMI2Instructions) {
 8285     multiply_128_x_128_bmi2_loop(y, z, carry, x, jdx, ylen, product, tmp2, x_xstart, tmp3, tmp4);
 8286   } else { // !UseBMI2Instructions
 8287     multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
 8288   }
 8289 
 8290   pop(ylen);
 8291   pop(xlen);
 8292   pop(x);
 8293   pop(z);
 8294 
 8295   movl(tmp3, xlen);
 8296   addl(tmp3, 1);
 8297   movl(Address(z, tmp3, Address::times_4,  0), carry);
 8298   subl(tmp3, 1);
 8299   jccb(Assembler::negative, L_done);
 8300 
 8301   shrq(carry, 32);
 8302   movl(Address(z, tmp3, Address::times_4,  0), carry);
 8303   jmp(L_second_loop);
 8304 
 8305   // Next infrequent code is moved outside loops.
 8306   bind(L_last_x);
 8307   if (UseBMI2Instructions) {
 8308     movl(rdx, Address(x,  0));
 8309   } else {
 8310     movl(x_xstart, Address(x,  0));
 8311   }
 8312   jmp(L_third_loop_prologue);
 8313 
 8314   bind(L_done);
 8315 
 8316   pop(zlen);
 8317   pop(xlen);
 8318 
 8319   pop(tmp5);
 8320   pop(tmp4);
 8321   pop(tmp3);
 8322   pop(tmp2);
 8323   pop(tmp1);
 8324 }
 8325 
 8326 void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
 8327   Register result, Register tmp1, Register tmp2, XMMRegister rymm0, XMMRegister rymm1, XMMRegister rymm2){
 8328   assert(UseSSE42Intrinsics, &quot;SSE4.2 must be enabled.&quot;);
 8329   Label VECTOR16_LOOP, VECTOR8_LOOP, VECTOR4_LOOP;
 8330   Label VECTOR8_TAIL, VECTOR4_TAIL;
 8331   Label VECTOR32_NOT_EQUAL, VECTOR16_NOT_EQUAL, VECTOR8_NOT_EQUAL, VECTOR4_NOT_EQUAL;
 8332   Label SAME_TILL_END, DONE;
 8333   Label BYTES_LOOP, BYTES_TAIL, BYTES_NOT_EQUAL;
 8334 
 8335   //scale is in rcx in both Win64 and Unix
 8336   ShortBranchVerifier sbv(this);
 8337 
 8338   shlq(length);
 8339   xorq(result, result);
 8340 
 8341   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp;
 8342       VM_Version::supports_avx512vlbw()) {
 8343     Label VECTOR64_LOOP, VECTOR64_NOT_EQUAL, VECTOR32_TAIL;
 8344 
 8345     cmpq(length, 64);
 8346     jcc(Assembler::less, VECTOR32_TAIL);
 8347 
 8348     movq(tmp1, length);
 8349     andq(tmp1, 0x3F);      // tail count
 8350     andq(length, ~(0x3F)); //vector count
 8351 
 8352     bind(VECTOR64_LOOP);
 8353     // AVX512 code to compare 64 byte vectors.
 8354     evmovdqub(rymm0, Address(obja, result), Assembler::AVX_512bit);
 8355     evpcmpeqb(k7, rymm0, Address(objb, result), Assembler::AVX_512bit);
 8356     kortestql(k7, k7);
 8357     jcc(Assembler::aboveEqual, VECTOR64_NOT_EQUAL);     // mismatch
 8358     addq(result, 64);
 8359     subq(length, 64);
 8360     jccb(Assembler::notZero, VECTOR64_LOOP);
 8361 
 8362     //bind(VECTOR64_TAIL);
 8363     testq(tmp1, tmp1);
 8364     jcc(Assembler::zero, SAME_TILL_END);
 8365 
 8366     //bind(VECTOR64_TAIL);
 8367     // AVX512 code to compare upto 63 byte vectors.
 8368     mov64(tmp2, 0xFFFFFFFFFFFFFFFF);
 8369     shlxq(tmp2, tmp2, tmp1);
 8370     notq(tmp2);
 8371     kmovql(k3, tmp2);
 8372 
 8373     evmovdqub(rymm0, k3, Address(obja, result), Assembler::AVX_512bit);
 8374     evpcmpeqb(k7, k3, rymm0, Address(objb, result), Assembler::AVX_512bit);
 8375 
 8376     ktestql(k7, k3);
 8377     jcc(Assembler::below, SAME_TILL_END);     // not mismatch
 8378 
 8379     bind(VECTOR64_NOT_EQUAL);
 8380     kmovql(tmp1, k7);
 8381     notq(tmp1);
 8382     tzcntq(tmp1, tmp1);
 8383     addq(result, tmp1);
 8384     shrq(result);
 8385     jmp(DONE);
 8386     bind(VECTOR32_TAIL);
 8387   }
 8388 
 8389   cmpq(length, 8);
 8390   jcc(Assembler::equal, VECTOR8_LOOP);
 8391   jcc(Assembler::less, VECTOR4_TAIL);
 8392 
 8393   if (UseAVX &gt;= 2) {
 8394     Label VECTOR16_TAIL, VECTOR32_LOOP;
 8395 
 8396     cmpq(length, 16);
 8397     jcc(Assembler::equal, VECTOR16_LOOP);
 8398     jcc(Assembler::less, VECTOR8_LOOP);
 8399 
 8400     cmpq(length, 32);
 8401     jccb(Assembler::less, VECTOR16_TAIL);
 8402 
 8403     subq(length, 32);
 8404     bind(VECTOR32_LOOP);
 8405     vmovdqu(rymm0, Address(obja, result));
 8406     vmovdqu(rymm1, Address(objb, result));
 8407     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_256bit);
 8408     vptest(rymm2, rymm2);
 8409     jcc(Assembler::notZero, VECTOR32_NOT_EQUAL);//mismatch found
 8410     addq(result, 32);
 8411     subq(length, 32);
 8412     jcc(Assembler::greaterEqual, VECTOR32_LOOP);
 8413     addq(length, 32);
 8414     jcc(Assembler::equal, SAME_TILL_END);
 8415     //falling through if less than 32 bytes left //close the branch here.
 8416 
 8417     bind(VECTOR16_TAIL);
 8418     cmpq(length, 16);
 8419     jccb(Assembler::less, VECTOR8_TAIL);
 8420     bind(VECTOR16_LOOP);
 8421     movdqu(rymm0, Address(obja, result));
 8422     movdqu(rymm1, Address(objb, result));
 8423     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_128bit);
 8424     ptest(rymm2, rymm2);
 8425     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
 8426     addq(result, 16);
 8427     subq(length, 16);
 8428     jcc(Assembler::equal, SAME_TILL_END);
 8429     //falling through if less than 16 bytes left
 8430   } else {//regular intrinsics
 8431 
 8432     cmpq(length, 16);
 8433     jccb(Assembler::less, VECTOR8_TAIL);
 8434 
 8435     subq(length, 16);
 8436     bind(VECTOR16_LOOP);
 8437     movdqu(rymm0, Address(obja, result));
 8438     movdqu(rymm1, Address(objb, result));
 8439     pxor(rymm0, rymm1);
 8440     ptest(rymm0, rymm0);
 8441     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
 8442     addq(result, 16);
 8443     subq(length, 16);
 8444     jccb(Assembler::greaterEqual, VECTOR16_LOOP);
 8445     addq(length, 16);
 8446     jcc(Assembler::equal, SAME_TILL_END);
 8447     //falling through if less than 16 bytes left
 8448   }
 8449 
 8450   bind(VECTOR8_TAIL);
 8451   cmpq(length, 8);
 8452   jccb(Assembler::less, VECTOR4_TAIL);
 8453   bind(VECTOR8_LOOP);
 8454   movq(tmp1, Address(obja, result));
 8455   movq(tmp2, Address(objb, result));
 8456   xorq(tmp1, tmp2);
 8457   testq(tmp1, tmp1);
 8458   jcc(Assembler::notZero, VECTOR8_NOT_EQUAL);//mismatch found
 8459   addq(result, 8);
 8460   subq(length, 8);
 8461   jcc(Assembler::equal, SAME_TILL_END);
 8462   //falling through if less than 8 bytes left
 8463 
 8464   bind(VECTOR4_TAIL);
 8465   cmpq(length, 4);
 8466   jccb(Assembler::less, BYTES_TAIL);
 8467   bind(VECTOR4_LOOP);
 8468   movl(tmp1, Address(obja, result));
 8469   xorl(tmp1, Address(objb, result));
 8470   testl(tmp1, tmp1);
 8471   jcc(Assembler::notZero, VECTOR4_NOT_EQUAL);//mismatch found
 8472   addq(result, 4);
 8473   subq(length, 4);
 8474   jcc(Assembler::equal, SAME_TILL_END);
 8475   //falling through if less than 4 bytes left
 8476 
 8477   bind(BYTES_TAIL);
 8478   bind(BYTES_LOOP);
 8479   load_unsigned_byte(tmp1, Address(obja, result));
 8480   load_unsigned_byte(tmp2, Address(objb, result));
 8481   xorl(tmp1, tmp2);
 8482   testl(tmp1, tmp1);
 8483   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
 8484   decq(length);
 8485   jcc(Assembler::zero, SAME_TILL_END);
 8486   incq(result);
 8487   load_unsigned_byte(tmp1, Address(obja, result));
 8488   load_unsigned_byte(tmp2, Address(objb, result));
 8489   xorl(tmp1, tmp2);
 8490   testl(tmp1, tmp1);
 8491   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
 8492   decq(length);
 8493   jcc(Assembler::zero, SAME_TILL_END);
 8494   incq(result);
 8495   load_unsigned_byte(tmp1, Address(obja, result));
 8496   load_unsigned_byte(tmp2, Address(objb, result));
 8497   xorl(tmp1, tmp2);
 8498   testl(tmp1, tmp1);
 8499   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
 8500   jmp(SAME_TILL_END);
 8501 
 8502   if (UseAVX &gt;= 2) {
 8503     bind(VECTOR32_NOT_EQUAL);
 8504     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_256bit);
 8505     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_256bit);
 8506     vpxor(rymm0, rymm0, rymm2, Assembler::AVX_256bit);
 8507     vpmovmskb(tmp1, rymm0);
 8508     bsfq(tmp1, tmp1);
 8509     addq(result, tmp1);
 8510     shrq(result);
 8511     jmp(DONE);
 8512   }
 8513 
 8514   bind(VECTOR16_NOT_EQUAL);
 8515   if (UseAVX &gt;= 2) {
 8516     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_128bit);
 8517     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_128bit);
 8518     pxor(rymm0, rymm2);
 8519   } else {
 8520     pcmpeqb(rymm2, rymm2);
 8521     pxor(rymm0, rymm1);
 8522     pcmpeqb(rymm0, rymm1);
 8523     pxor(rymm0, rymm2);
 8524   }
 8525   pmovmskb(tmp1, rymm0);
 8526   bsfq(tmp1, tmp1);
 8527   addq(result, tmp1);
 8528   shrq(result);
 8529   jmpb(DONE);
 8530 
 8531   bind(VECTOR8_NOT_EQUAL);
 8532   bind(VECTOR4_NOT_EQUAL);
 8533   bsfq(tmp1, tmp1);
 8534   shrq(tmp1, 3);
 8535   addq(result, tmp1);
 8536   bind(BYTES_NOT_EQUAL);
 8537   shrq(result);
 8538   jmpb(DONE);
 8539 
 8540   bind(SAME_TILL_END);
 8541   mov64(result, -1);
 8542 
 8543   bind(DONE);
 8544 }
 8545 
 8546 //Helper functions for square_to_len()
 8547 
 8548 /**
 8549  * Store the squares of x[], right shifted one bit (divided by 2) into z[]
 8550  * Preserves x and z and modifies rest of the registers.
 8551  */
 8552 void MacroAssembler::square_rshift(Register x, Register xlen, Register z, Register tmp1, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
 8553   // Perform square and right shift by 1
 8554   // Handle odd xlen case first, then for even xlen do the following
 8555   // jlong carry = 0;
 8556   // for (int j=0, i=0; j &lt; xlen; j+=2, i+=4) {
 8557   //     huge_128 product = x[j:j+1] * x[j:j+1];
 8558   //     z[i:i+1] = (carry &lt;&lt; 63) | (jlong)(product &gt;&gt;&gt; 65);
 8559   //     z[i+2:i+3] = (jlong)(product &gt;&gt;&gt; 1);
 8560   //     carry = (jlong)product;
 8561   // }
 8562 
 8563   xorq(tmp5, tmp5);     // carry
 8564   xorq(rdxReg, rdxReg);
 8565   xorl(tmp1, tmp1);     // index for x
 8566   xorl(tmp4, tmp4);     // index for z
 8567 
 8568   Label L_first_loop, L_first_loop_exit;
 8569 
 8570   testl(xlen, 1);
 8571   jccb(Assembler::zero, L_first_loop); //jump if xlen is even
 8572 
 8573   // Square and right shift by 1 the odd element using 32 bit multiply
 8574   movl(raxReg, Address(x, tmp1, Address::times_4, 0));
 8575   imulq(raxReg, raxReg);
 8576   shrq(raxReg, 1);
 8577   adcq(tmp5, 0);
 8578   movq(Address(z, tmp4, Address::times_4, 0), raxReg);
 8579   incrementl(tmp1);
 8580   addl(tmp4, 2);
 8581 
 8582   // Square and  right shift by 1 the rest using 64 bit multiply
 8583   bind(L_first_loop);
 8584   cmpptr(tmp1, xlen);
 8585   jccb(Assembler::equal, L_first_loop_exit);
 8586 
 8587   // Square
 8588   movq(raxReg, Address(x, tmp1, Address::times_4,  0));
 8589   rorq(raxReg, 32);    // convert big-endian to little-endian
 8590   mulq(raxReg);        // 64-bit multiply rax * rax -&gt; rdx:rax
 8591 
 8592   // Right shift by 1 and save carry
 8593   shrq(tmp5, 1);       // rdx:rax:tmp5 = (tmp5:rdx:rax) &gt;&gt;&gt; 1
 8594   rcrq(rdxReg, 1);
 8595   rcrq(raxReg, 1);
 8596   adcq(tmp5, 0);
 8597 
 8598   // Store result in z
 8599   movq(Address(z, tmp4, Address::times_4, 0), rdxReg);
 8600   movq(Address(z, tmp4, Address::times_4, 8), raxReg);
 8601 
 8602   // Update indices for x and z
 8603   addl(tmp1, 2);
 8604   addl(tmp4, 4);
 8605   jmp(L_first_loop);
 8606 
 8607   bind(L_first_loop_exit);
 8608 }
 8609 
 8610 
 8611 /**
 8612  * Perform the following multiply add operation using BMI2 instructions
 8613  * carry:sum = sum + op1*op2 + carry
 8614  * op2 should be in rdx
 8615  * op2 is preserved, all other registers are modified
 8616  */
 8617 void MacroAssembler::multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry, Register tmp2) {
 8618   // assert op2 is rdx
 8619   mulxq(tmp2, op1, op1);  //  op1 * op2 -&gt; tmp2:op1
 8620   addq(sum, carry);
 8621   adcq(tmp2, 0);
 8622   addq(sum, op1);
 8623   adcq(tmp2, 0);
 8624   movq(carry, tmp2);
 8625 }
 8626 
 8627 /**
 8628  * Perform the following multiply add operation:
 8629  * carry:sum = sum + op1*op2 + carry
 8630  * Preserves op1, op2 and modifies rest of registers
 8631  */
 8632 void MacroAssembler::multiply_add_64(Register sum, Register op1, Register op2, Register carry, Register rdxReg, Register raxReg) {
 8633   // rdx:rax = op1 * op2
 8634   movq(raxReg, op2);
 8635   mulq(op1);
 8636 
 8637   //  rdx:rax = sum + carry + rdx:rax
 8638   addq(sum, carry);
 8639   adcq(rdxReg, 0);
 8640   addq(sum, raxReg);
 8641   adcq(rdxReg, 0);
 8642 
 8643   // carry:sum = rdx:sum
 8644   movq(carry, rdxReg);
 8645 }
 8646 
 8647 /**
 8648  * Add 64 bit long carry into z[] with carry propogation.
 8649  * Preserves z and carry register values and modifies rest of registers.
 8650  *
 8651  */
 8652 void MacroAssembler::add_one_64(Register z, Register zlen, Register carry, Register tmp1) {
 8653   Label L_fourth_loop, L_fourth_loop_exit;
 8654 
 8655   movl(tmp1, 1);
 8656   subl(zlen, 2);
 8657   addq(Address(z, zlen, Address::times_4, 0), carry);
 8658 
 8659   bind(L_fourth_loop);
 8660   jccb(Assembler::carryClear, L_fourth_loop_exit);
 8661   subl(zlen, 2);
 8662   jccb(Assembler::negative, L_fourth_loop_exit);
 8663   addq(Address(z, zlen, Address::times_4, 0), tmp1);
 8664   jmp(L_fourth_loop);
 8665   bind(L_fourth_loop_exit);
 8666 }
 8667 
 8668 /**
 8669  * Shift z[] left by 1 bit.
 8670  * Preserves x, len, z and zlen registers and modifies rest of the registers.
 8671  *
 8672  */
 8673 void MacroAssembler::lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {
 8674 
 8675   Label L_fifth_loop, L_fifth_loop_exit;
 8676 
 8677   // Fifth loop
 8678   // Perform primitiveLeftShift(z, zlen, 1)
 8679 
 8680   const Register prev_carry = tmp1;
 8681   const Register new_carry = tmp4;
 8682   const Register value = tmp2;
 8683   const Register zidx = tmp3;
 8684 
 8685   // int zidx, carry;
 8686   // long value;
 8687   // carry = 0;
 8688   // for (zidx = zlen-2; zidx &gt;=0; zidx -= 2) {
 8689   //    (carry:value)  = (z[i] &lt;&lt; 1) | carry ;
 8690   //    z[i] = value;
 8691   // }
 8692 
 8693   movl(zidx, zlen);
 8694   xorl(prev_carry, prev_carry); // clear carry flag and prev_carry register
 8695 
 8696   bind(L_fifth_loop);
 8697   decl(zidx);  // Use decl to preserve carry flag
 8698   decl(zidx);
 8699   jccb(Assembler::negative, L_fifth_loop_exit);
 8700 
 8701   if (UseBMI2Instructions) {
 8702      movq(value, Address(z, zidx, Address::times_4, 0));
 8703      rclq(value, 1);
 8704      rorxq(value, value, 32);
 8705      movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
 8706   }
 8707   else {
 8708     // clear new_carry
 8709     xorl(new_carry, new_carry);
 8710 
 8711     // Shift z[i] by 1, or in previous carry and save new carry
 8712     movq(value, Address(z, zidx, Address::times_4, 0));
 8713     shlq(value, 1);
 8714     adcl(new_carry, 0);
 8715 
 8716     orq(value, prev_carry);
 8717     rorq(value, 0x20);
 8718     movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
 8719 
 8720     // Set previous carry = new carry
 8721     movl(prev_carry, new_carry);
 8722   }
 8723   jmp(L_fifth_loop);
 8724 
 8725   bind(L_fifth_loop_exit);
 8726 }
 8727 
 8728 
 8729 /**
 8730  * Code for BigInteger::squareToLen() intrinsic
 8731  *
 8732  * rdi: x
 8733  * rsi: len
 8734  * r8:  z
 8735  * rcx: zlen
 8736  * r12: tmp1
 8737  * r13: tmp2
 8738  * r14: tmp3
 8739  * r15: tmp4
 8740  * rbx: tmp5
 8741  *
 8742  */
 8743 void MacroAssembler::square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
 8744 
 8745   Label L_second_loop, L_second_loop_exit, L_third_loop, L_third_loop_exit, L_last_x, L_multiply;
 8746   push(tmp1);
 8747   push(tmp2);
 8748   push(tmp3);
 8749   push(tmp4);
 8750   push(tmp5);
 8751 
 8752   // First loop
 8753   // Store the squares, right shifted one bit (i.e., divided by 2).
 8754   square_rshift(x, len, z, tmp1, tmp3, tmp4, tmp5, rdxReg, raxReg);
 8755 
 8756   // Add in off-diagonal sums.
 8757   //
 8758   // Second, third (nested) and fourth loops.
 8759   // zlen +=2;
 8760   // for (int xidx=len-2,zidx=zlen-4; xidx &gt; 0; xidx-=2,zidx-=4) {
 8761   //    carry = 0;
 8762   //    long op2 = x[xidx:xidx+1];
 8763   //    for (int j=xidx-2,k=zidx; j &gt;= 0; j-=2) {
 8764   //       k -= 2;
 8765   //       long op1 = x[j:j+1];
 8766   //       long sum = z[k:k+1];
 8767   //       carry:sum = multiply_add_64(sum, op1, op2, carry, tmp_regs);
 8768   //       z[k:k+1] = sum;
 8769   //    }
 8770   //    add_one_64(z, k, carry, tmp_regs);
 8771   // }
 8772 
 8773   const Register carry = tmp5;
 8774   const Register sum = tmp3;
 8775   const Register op1 = tmp4;
 8776   Register op2 = tmp2;
 8777 
 8778   push(zlen);
 8779   push(len);
 8780   addl(zlen,2);
 8781   bind(L_second_loop);
 8782   xorq(carry, carry);
 8783   subl(zlen, 4);
 8784   subl(len, 2);
 8785   push(zlen);
 8786   push(len);
 8787   cmpl(len, 0);
 8788   jccb(Assembler::lessEqual, L_second_loop_exit);
 8789 
 8790   // Multiply an array by one 64 bit long.
 8791   if (UseBMI2Instructions) {
 8792     op2 = rdxReg;
 8793     movq(op2, Address(x, len, Address::times_4,  0));
 8794     rorxq(op2, op2, 32);
 8795   }
 8796   else {
 8797     movq(op2, Address(x, len, Address::times_4,  0));
 8798     rorq(op2, 32);
 8799   }
 8800 
 8801   bind(L_third_loop);
 8802   decrementl(len);
 8803   jccb(Assembler::negative, L_third_loop_exit);
 8804   decrementl(len);
 8805   jccb(Assembler::negative, L_last_x);
 8806 
 8807   movq(op1, Address(x, len, Address::times_4,  0));
 8808   rorq(op1, 32);
 8809 
 8810   bind(L_multiply);
 8811   subl(zlen, 2);
 8812   movq(sum, Address(z, zlen, Address::times_4,  0));
 8813 
 8814   // Multiply 64 bit by 64 bit and add 64 bits lower half and upper 64 bits as carry.
 8815   if (UseBMI2Instructions) {
 8816     multiply_add_64_bmi2(sum, op1, op2, carry, tmp2);
 8817   }
 8818   else {
 8819     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
 8820   }
 8821 
 8822   movq(Address(z, zlen, Address::times_4, 0), sum);
 8823 
 8824   jmp(L_third_loop);
 8825   bind(L_third_loop_exit);
 8826 
 8827   // Fourth loop
 8828   // Add 64 bit long carry into z with carry propogation.
 8829   // Uses offsetted zlen.
 8830   add_one_64(z, zlen, carry, tmp1);
 8831 
 8832   pop(len);
 8833   pop(zlen);
 8834   jmp(L_second_loop);
 8835 
 8836   // Next infrequent code is moved outside loops.
 8837   bind(L_last_x);
 8838   movl(op1, Address(x, 0));
 8839   jmp(L_multiply);
 8840 
 8841   bind(L_second_loop_exit);
 8842   pop(len);
 8843   pop(zlen);
 8844   pop(len);
 8845   pop(zlen);
 8846 
 8847   // Fifth loop
 8848   // Shift z left 1 bit.
 8849   lshift_by_1(x, len, z, zlen, tmp1, tmp2, tmp3, tmp4);
 8850 
 8851   // z[zlen-1] |= x[len-1] &amp; 1;
 8852   movl(tmp3, Address(x, len, Address::times_4, -4));
 8853   andl(tmp3, 1);
 8854   orl(Address(z, zlen, Address::times_4,  -4), tmp3);
 8855 
 8856   pop(tmp5);
 8857   pop(tmp4);
 8858   pop(tmp3);
 8859   pop(tmp2);
 8860   pop(tmp1);
 8861 }
 8862 
 8863 /**
 8864  * Helper function for mul_add()
 8865  * Multiply the in[] by int k and add to out[] starting at offset offs using
 8866  * 128 bit by 32 bit multiply and return the carry in tmp5.
 8867  * Only quad int aligned length of in[] is operated on in this function.
 8868  * k is in rdxReg for BMI2Instructions, for others it is in tmp2.
 8869  * This function preserves out, in and k registers.
 8870  * len and offset point to the appropriate index in &quot;in&quot; &amp; &quot;out&quot; correspondingly
 8871  * tmp5 has the carry.
 8872  * other registers are temporary and are modified.
 8873  *
 8874  */
 8875 void MacroAssembler::mul_add_128_x_32_loop(Register out, Register in,
 8876   Register offset, Register len, Register tmp1, Register tmp2, Register tmp3,
 8877   Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
 8878 
 8879   Label L_first_loop, L_first_loop_exit;
 8880 
 8881   movl(tmp1, len);
 8882   shrl(tmp1, 2);
 8883 
 8884   bind(L_first_loop);
 8885   subl(tmp1, 1);
 8886   jccb(Assembler::negative, L_first_loop_exit);
 8887 
 8888   subl(len, 4);
 8889   subl(offset, 4);
 8890 
 8891   Register op2 = tmp2;
 8892   const Register sum = tmp3;
 8893   const Register op1 = tmp4;
 8894   const Register carry = tmp5;
 8895 
 8896   if (UseBMI2Instructions) {
 8897     op2 = rdxReg;
 8898   }
 8899 
 8900   movq(op1, Address(in, len, Address::times_4,  8));
 8901   rorq(op1, 32);
 8902   movq(sum, Address(out, offset, Address::times_4,  8));
 8903   rorq(sum, 32);
 8904   if (UseBMI2Instructions) {
 8905     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
 8906   }
 8907   else {
 8908     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
 8909   }
 8910   // Store back in big endian from little endian
 8911   rorq(sum, 0x20);
 8912   movq(Address(out, offset, Address::times_4,  8), sum);
 8913 
 8914   movq(op1, Address(in, len, Address::times_4,  0));
 8915   rorq(op1, 32);
 8916   movq(sum, Address(out, offset, Address::times_4,  0));
 8917   rorq(sum, 32);
 8918   if (UseBMI2Instructions) {
 8919     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
 8920   }
 8921   else {
 8922     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
 8923   }
 8924   // Store back in big endian from little endian
 8925   rorq(sum, 0x20);
 8926   movq(Address(out, offset, Address::times_4,  0), sum);
 8927 
 8928   jmp(L_first_loop);
 8929   bind(L_first_loop_exit);
 8930 }
 8931 
 8932 /**
 8933  * Code for BigInteger::mulAdd() intrinsic
 8934  *
 8935  * rdi: out
 8936  * rsi: in
 8937  * r11: offs (out.length - offset)
 8938  * rcx: len
 8939  * r8:  k
 8940  * r12: tmp1
 8941  * r13: tmp2
 8942  * r14: tmp3
 8943  * r15: tmp4
 8944  * rbx: tmp5
 8945  * Multiply the in[] by word k and add to out[], return the carry in rax
 8946  */
 8947 void MacroAssembler::mul_add(Register out, Register in, Register offs,
 8948    Register len, Register k, Register tmp1, Register tmp2, Register tmp3,
 8949    Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
 8950 
 8951   Label L_carry, L_last_in, L_done;
 8952 
 8953 // carry = 0;
 8954 // for (int j=len-1; j &gt;= 0; j--) {
 8955 //    long product = (in[j] &amp; LONG_MASK) * kLong +
 8956 //                   (out[offs] &amp; LONG_MASK) + carry;
 8957 //    out[offs--] = (int)product;
 8958 //    carry = product &gt;&gt;&gt; 32;
 8959 // }
 8960 //
 8961   push(tmp1);
 8962   push(tmp2);
 8963   push(tmp3);
 8964   push(tmp4);
 8965   push(tmp5);
 8966 
 8967   Register op2 = tmp2;
 8968   const Register sum = tmp3;
 8969   const Register op1 = tmp4;
 8970   const Register carry =  tmp5;
 8971 
 8972   if (UseBMI2Instructions) {
 8973     op2 = rdxReg;
 8974     movl(op2, k);
 8975   }
 8976   else {
 8977     movl(op2, k);
 8978   }
 8979 
 8980   xorq(carry, carry);
 8981 
 8982   //First loop
 8983 
 8984   //Multiply in[] by k in a 4 way unrolled loop using 128 bit by 32 bit multiply
 8985   //The carry is in tmp5
 8986   mul_add_128_x_32_loop(out, in, offs, len, tmp1, tmp2, tmp3, tmp4, tmp5, rdxReg, raxReg);
 8987 
 8988   //Multiply the trailing in[] entry using 64 bit by 32 bit, if any
 8989   decrementl(len);
 8990   jccb(Assembler::negative, L_carry);
 8991   decrementl(len);
 8992   jccb(Assembler::negative, L_last_in);
 8993 
 8994   movq(op1, Address(in, len, Address::times_4,  0));
 8995   rorq(op1, 32);
 8996 
 8997   subl(offs, 2);
 8998   movq(sum, Address(out, offs, Address::times_4,  0));
 8999   rorq(sum, 32);
 9000 
 9001   if (UseBMI2Instructions) {
 9002     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
 9003   }
 9004   else {
 9005     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
 9006   }
 9007 
 9008   // Store back in big endian from little endian
 9009   rorq(sum, 0x20);
 9010   movq(Address(out, offs, Address::times_4,  0), sum);
 9011 
 9012   testl(len, len);
 9013   jccb(Assembler::zero, L_carry);
 9014 
 9015   //Multiply the last in[] entry, if any
 9016   bind(L_last_in);
 9017   movl(op1, Address(in, 0));
 9018   movl(sum, Address(out, offs, Address::times_4,  -4));
 9019 
 9020   movl(raxReg, k);
 9021   mull(op1); //tmp4 * eax -&gt; edx:eax
 9022   addl(sum, carry);
 9023   adcl(rdxReg, 0);
 9024   addl(sum, raxReg);
 9025   adcl(rdxReg, 0);
 9026   movl(carry, rdxReg);
 9027 
 9028   movl(Address(out, offs, Address::times_4,  -4), sum);
 9029 
 9030   bind(L_carry);
 9031   //return tmp5/carry as carry in rax
 9032   movl(rax, carry);
 9033 
 9034   bind(L_done);
 9035   pop(tmp5);
 9036   pop(tmp4);
 9037   pop(tmp3);
 9038   pop(tmp2);
 9039   pop(tmp1);
 9040 }
 9041 #endif
 9042 
 9043 /**
 9044  * Emits code to update CRC-32 with a byte value according to constants in table
 9045  *
 9046  * @param [in,out]crc   Register containing the crc.
 9047  * @param [in]val       Register containing the byte to fold into the CRC.
 9048  * @param [in]table     Register containing the table of crc constants.
 9049  *
 9050  * uint32_t crc;
 9051  * val = crc_table[(val ^ crc) &amp; 0xFF];
 9052  * crc = val ^ (crc &gt;&gt; 8);
 9053  *
 9054  */
 9055 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
 9056   xorl(val, crc);
 9057   andl(val, 0xFF);
 9058   shrl(crc, 8); // unsigned shift
 9059   xorl(crc, Address(table, val, Address::times_4, 0));
 9060 }
 9061 
 9062 /**
 9063 * Fold four 128-bit data chunks
 9064 */
 9065 void MacroAssembler::fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
 9066   evpclmulhdq(xtmp, xK, xcrc, Assembler::AVX_512bit); // [123:64]
 9067   evpclmulldq(xcrc, xK, xcrc, Assembler::AVX_512bit); // [63:0]
 9068   evpxorq(xcrc, xcrc, Address(buf, offset), Assembler::AVX_512bit /* vector_len */);
 9069   evpxorq(xcrc, xcrc, xtmp, Assembler::AVX_512bit /* vector_len */);
 9070 }
 9071 
 9072 /**
 9073  * Fold 128-bit data chunk
 9074  */
 9075 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
 9076   if (UseAVX &gt; 0) {
 9077     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
 9078     vpclmulldq(xcrc, xK, xcrc); // [63:0]
 9079     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
 9080     pxor(xcrc, xtmp);
 9081   } else {
 9082     movdqa(xtmp, xcrc);
 9083     pclmulhdq(xtmp, xK);   // [123:64]
 9084     pclmulldq(xcrc, xK);   // [63:0]
 9085     pxor(xcrc, xtmp);
 9086     movdqu(xtmp, Address(buf, offset));
 9087     pxor(xcrc, xtmp);
 9088   }
 9089 }
 9090 
 9091 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
 9092   if (UseAVX &gt; 0) {
 9093     vpclmulhdq(xtmp, xK, xcrc);
 9094     vpclmulldq(xcrc, xK, xcrc);
 9095     pxor(xcrc, xbuf);
 9096     pxor(xcrc, xtmp);
 9097   } else {
 9098     movdqa(xtmp, xcrc);
 9099     pclmulhdq(xtmp, xK);
 9100     pclmulldq(xcrc, xK);
 9101     pxor(xcrc, xbuf);
 9102     pxor(xcrc, xtmp);
 9103   }
 9104 }
 9105 
 9106 /**
 9107  * 8-bit folds to compute 32-bit CRC
 9108  *
 9109  * uint64_t xcrc;
 9110  * timesXtoThe32[xcrc &amp; 0xFF] ^ (xcrc &gt;&gt; 8);
 9111  */
 9112 void MacroAssembler::fold_8bit_crc32(XMMRegister xcrc, Register table, XMMRegister xtmp, Register tmp) {
 9113   movdl(tmp, xcrc);
 9114   andl(tmp, 0xFF);
 9115   movdl(xtmp, Address(table, tmp, Address::times_4, 0));
 9116   psrldq(xcrc, 1); // unsigned shift one byte
 9117   pxor(xcrc, xtmp);
 9118 }
 9119 
 9120 /**
 9121  * uint32_t crc;
 9122  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
 9123  */
 9124 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
 9125   movl(tmp, crc);
 9126   andl(tmp, 0xFF);
 9127   shrl(crc, 8);
 9128   xorl(crc, Address(table, tmp, Address::times_4, 0));
 9129 }
 9130 
 9131 /**
 9132  * @param crc   register containing existing CRC (32-bit)
 9133  * @param buf   register pointing to input byte buffer (byte*)
 9134  * @param len   register containing number of bytes
 9135  * @param table register that will contain address of CRC table
 9136  * @param tmp   scratch register
 9137  */
 9138 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp) {
 9139   assert_different_registers(crc, buf, len, table, tmp, rax);
 9140 
 9141   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
 9142   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
 9143 
 9144   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
 9145   // context for the registers used, where all instructions below are using 128-bit mode
 9146   // On EVEX without VL and BW, these instructions will all be AVX.
 9147   lea(table, ExternalAddress(StubRoutines::crc_table_addr()));
 9148   notl(crc); // ~crc
 9149   cmpl(len, 16);
 9150   jcc(Assembler::less, L_tail);
 9151 
 9152   // Align buffer to 16 bytes
 9153   movl(tmp, buf);
 9154   andl(tmp, 0xF);
 9155   jccb(Assembler::zero, L_aligned);
 9156   subl(tmp,  16);
 9157   addl(len, tmp);
 9158 
 9159   align(4);
 9160   BIND(L_align_loop);
 9161   movsbl(rax, Address(buf, 0)); // load byte with sign extension
 9162   update_byte_crc32(crc, rax, table);
 9163   increment(buf);
 9164   incrementl(tmp);
 9165   jccb(Assembler::less, L_align_loop);
 9166 
 9167   BIND(L_aligned);
 9168   movl(tmp, len); // save
 9169   shrl(len, 4);
 9170   jcc(Assembler::zero, L_tail_restore);
 9171 
 9172   // Fold crc into first bytes of vector
 9173   movdqa(xmm1, Address(buf, 0));
 9174   movdl(rax, xmm1);
 9175   xorl(crc, rax);
 9176   if (VM_Version::supports_sse4_1()) {
 9177     pinsrd(xmm1, crc, 0);
 9178   } else {
 9179     pinsrw(xmm1, crc, 0);
 9180     shrl(crc, 16);
 9181     pinsrw(xmm1, crc, 1);
 9182   }
 9183   addptr(buf, 16);
 9184   subl(len, 4); // len &gt; 0
 9185   jcc(Assembler::less, L_fold_tail);
 9186 
 9187   movdqa(xmm2, Address(buf,  0));
 9188   movdqa(xmm3, Address(buf, 16));
 9189   movdqa(xmm4, Address(buf, 32));
 9190   addptr(buf, 48);
 9191   subl(len, 3);
 9192   jcc(Assembler::lessEqual, L_fold_512b);
 9193 
 9194   // Fold total 512 bits of polynomial on each iteration,
 9195   // 128 bits per each of 4 parallel streams.
 9196   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));
 9197 
 9198   align(32);
 9199   BIND(L_fold_512b_loop);
 9200   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
 9201   fold_128bit_crc32(xmm2, xmm0, xmm5, buf, 16);
 9202   fold_128bit_crc32(xmm3, xmm0, xmm5, buf, 32);
 9203   fold_128bit_crc32(xmm4, xmm0, xmm5, buf, 48);
 9204   addptr(buf, 64);
 9205   subl(len, 4);
 9206   jcc(Assembler::greater, L_fold_512b_loop);
 9207 
 9208   // Fold 512 bits to 128 bits.
 9209   BIND(L_fold_512b);
 9210   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
 9211   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm2);
 9212   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm3);
 9213   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm4);
 9214 
 9215   // Fold the rest of 128 bits data chunks
 9216   BIND(L_fold_tail);
 9217   addl(len, 3);
 9218   jccb(Assembler::lessEqual, L_fold_128b);
 9219   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
 9220 
 9221   BIND(L_fold_tail_loop);
 9222   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
 9223   addptr(buf, 16);
 9224   decrementl(len);
 9225   jccb(Assembler::greater, L_fold_tail_loop);
 9226 
 9227   // Fold 128 bits in xmm1 down into 32 bits in crc register.
 9228   BIND(L_fold_128b);
 9229   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));
 9230   if (UseAVX &gt; 0) {
 9231     vpclmulqdq(xmm2, xmm0, xmm1, 0x1);
 9232     vpand(xmm3, xmm0, xmm2, 0 /* vector_len */);
 9233     vpclmulqdq(xmm0, xmm0, xmm3, 0x1);
 9234   } else {
 9235     movdqa(xmm2, xmm0);
 9236     pclmulqdq(xmm2, xmm1, 0x1);
 9237     movdqa(xmm3, xmm0);
 9238     pand(xmm3, xmm2);
 9239     pclmulqdq(xmm0, xmm3, 0x1);
 9240   }
 9241   psrldq(xmm1, 8);
 9242   psrldq(xmm2, 4);
 9243   pxor(xmm0, xmm1);
 9244   pxor(xmm0, xmm2);
 9245 
 9246   // 8 8-bit folds to compute 32-bit CRC.
 9247   for (int j = 0; j &lt; 4; j++) {
 9248     fold_8bit_crc32(xmm0, table, xmm1, rax);
 9249   }
 9250   movdl(crc, xmm0); // mov 32 bits to general register
 9251   for (int j = 0; j &lt; 4; j++) {
 9252     fold_8bit_crc32(crc, table, rax);
 9253   }
 9254 
 9255   BIND(L_tail_restore);
 9256   movl(len, tmp); // restore
 9257   BIND(L_tail);
 9258   andl(len, 0xf);
 9259   jccb(Assembler::zero, L_exit);
 9260 
 9261   // Fold the rest of bytes
 9262   align(4);
 9263   BIND(L_tail_loop);
 9264   movsbl(rax, Address(buf, 0)); // load byte with sign extension
 9265   update_byte_crc32(crc, rax, table);
 9266   increment(buf);
 9267   decrementl(len);
 9268   jccb(Assembler::greater, L_tail_loop);
 9269 
 9270   BIND(L_exit);
 9271   notl(crc); // ~c
 9272 }
 9273 
 9274 #ifdef _LP64
 9275 // S. Gueron / Information Processing Letters 112 (2012) 184
 9276 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
 9277 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
 9278 // Output: the 64-bit carry-less product of B * CONST
 9279 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
 9280                                      Register tmp1, Register tmp2, Register tmp3) {
 9281   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
 9282   if (n &gt; 0) {
 9283     addq(tmp3, n * 256 * 8);
 9284   }
 9285   //    Q1 = TABLEExt[n][B &amp; 0xFF];
 9286   movl(tmp1, in);
 9287   andl(tmp1, 0x000000FF);
 9288   shll(tmp1, 3);
 9289   addq(tmp1, tmp3);
 9290   movq(tmp1, Address(tmp1, 0));
 9291 
 9292   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
 9293   movl(tmp2, in);
 9294   shrl(tmp2, 8);
 9295   andl(tmp2, 0x000000FF);
 9296   shll(tmp2, 3);
 9297   addq(tmp2, tmp3);
 9298   movq(tmp2, Address(tmp2, 0));
 9299 
 9300   shlq(tmp2, 8);
 9301   xorq(tmp1, tmp2);
 9302 
 9303   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
 9304   movl(tmp2, in);
 9305   shrl(tmp2, 16);
 9306   andl(tmp2, 0x000000FF);
 9307   shll(tmp2, 3);
 9308   addq(tmp2, tmp3);
 9309   movq(tmp2, Address(tmp2, 0));
 9310 
 9311   shlq(tmp2, 16);
 9312   xorq(tmp1, tmp2);
 9313 
 9314   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
 9315   shrl(in, 24);
 9316   andl(in, 0x000000FF);
 9317   shll(in, 3);
 9318   addq(in, tmp3);
 9319   movq(in, Address(in, 0));
 9320 
 9321   shlq(in, 24);
 9322   xorq(in, tmp1);
 9323   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
 9324 }
 9325 
 9326 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
 9327                                       Register in_out,
 9328                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
 9329                                       XMMRegister w_xtmp2,
 9330                                       Register tmp1,
 9331                                       Register n_tmp2, Register n_tmp3) {
 9332   if (is_pclmulqdq_supported) {
 9333     movdl(w_xtmp1, in_out); // modified blindly
 9334 
 9335     movl(tmp1, const_or_pre_comp_const_index);
 9336     movdl(w_xtmp2, tmp1);
 9337     pclmulqdq(w_xtmp1, w_xtmp2, 0);
 9338 
 9339     movdq(in_out, w_xtmp1);
 9340   } else {
 9341     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3);
 9342   }
 9343 }
 9344 
 9345 // Recombination Alternative 2: No bit-reflections
 9346 // T1 = (CRC_A * U1) &lt;&lt; 1
 9347 // T2 = (CRC_B * U2) &lt;&lt; 1
 9348 // C1 = T1 &gt;&gt; 32
 9349 // C2 = T2 &gt;&gt; 32
 9350 // T1 = T1 &amp; 0xFFFFFFFF
 9351 // T2 = T2 &amp; 0xFFFFFFFF
 9352 // T1 = CRC32(0, T1)
 9353 // T2 = CRC32(0, T2)
 9354 // C1 = C1 ^ T1
 9355 // C2 = C2 ^ T2
 9356 // CRC = C1 ^ C2 ^ CRC_C
 9357 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
 9358                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9359                                      Register tmp1, Register tmp2,
 9360                                      Register n_tmp3) {
 9361   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
 9362   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
 9363   shlq(in_out, 1);
 9364   movl(tmp1, in_out);
 9365   shrq(in_out, 32);
 9366   xorl(tmp2, tmp2);
 9367   crc32(tmp2, tmp1, 4);
 9368   xorl(in_out, tmp2); // we don&#39;t care about upper 32 bit contents here
 9369   shlq(in1, 1);
 9370   movl(tmp1, in1);
 9371   shrq(in1, 32);
 9372   xorl(tmp2, tmp2);
 9373   crc32(tmp2, tmp1, 4);
 9374   xorl(in1, tmp2);
 9375   xorl(in_out, in1);
 9376   xorl(in_out, in2);
 9377 }
 9378 
 9379 // Set N to predefined value
 9380 // Subtract from a lenght of a buffer
 9381 // execute in a loop:
 9382 // CRC_A = 0xFFFFFFFF, CRC_B = 0, CRC_C = 0
 9383 // for i = 1 to N do
 9384 //  CRC_A = CRC32(CRC_A, A[i])
 9385 //  CRC_B = CRC32(CRC_B, B[i])
 9386 //  CRC_C = CRC32(CRC_C, C[i])
 9387 // end for
 9388 // Recombine
 9389 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
 9390                                        Register in_out1, Register in_out2, Register in_out3,
 9391                                        Register tmp1, Register tmp2, Register tmp3,
 9392                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9393                                        Register tmp4, Register tmp5,
 9394                                        Register n_tmp6) {
 9395   Label L_processPartitions;
 9396   Label L_processPartition;
 9397   Label L_exit;
 9398 
 9399   bind(L_processPartitions);
 9400   cmpl(in_out1, 3 * size);
 9401   jcc(Assembler::less, L_exit);
 9402     xorl(tmp1, tmp1);
 9403     xorl(tmp2, tmp2);
 9404     movq(tmp3, in_out2);
 9405     addq(tmp3, size);
 9406 
 9407     bind(L_processPartition);
 9408       crc32(in_out3, Address(in_out2, 0), 8);
 9409       crc32(tmp1, Address(in_out2, size), 8);
 9410       crc32(tmp2, Address(in_out2, size * 2), 8);
 9411       addq(in_out2, 8);
 9412       cmpq(in_out2, tmp3);
 9413       jcc(Assembler::less, L_processPartition);
 9414     crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
 9415             w_xtmp1, w_xtmp2, w_xtmp3,
 9416             tmp4, tmp5,
 9417             n_tmp6);
 9418     addq(in_out2, 2 * size);
 9419     subl(in_out1, 3 * size);
 9420     jmp(L_processPartitions);
 9421 
 9422   bind(L_exit);
 9423 }
 9424 #else
 9425 void MacroAssembler::crc32c_ipl_alg4(Register in_out, uint32_t n,
 9426                                      Register tmp1, Register tmp2, Register tmp3,
 9427                                      XMMRegister xtmp1, XMMRegister xtmp2) {
 9428   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
 9429   if (n &gt; 0) {
 9430     addl(tmp3, n * 256 * 8);
 9431   }
 9432   //    Q1 = TABLEExt[n][B &amp; 0xFF];
 9433   movl(tmp1, in_out);
 9434   andl(tmp1, 0x000000FF);
 9435   shll(tmp1, 3);
 9436   addl(tmp1, tmp3);
 9437   movq(xtmp1, Address(tmp1, 0));
 9438 
 9439   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
 9440   movl(tmp2, in_out);
 9441   shrl(tmp2, 8);
 9442   andl(tmp2, 0x000000FF);
 9443   shll(tmp2, 3);
 9444   addl(tmp2, tmp3);
 9445   movq(xtmp2, Address(tmp2, 0));
 9446 
 9447   psllq(xtmp2, 8);
 9448   pxor(xtmp1, xtmp2);
 9449 
 9450   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
 9451   movl(tmp2, in_out);
 9452   shrl(tmp2, 16);
 9453   andl(tmp2, 0x000000FF);
 9454   shll(tmp2, 3);
 9455   addl(tmp2, tmp3);
 9456   movq(xtmp2, Address(tmp2, 0));
 9457 
 9458   psllq(xtmp2, 16);
 9459   pxor(xtmp1, xtmp2);
 9460 
 9461   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
 9462   shrl(in_out, 24);
 9463   andl(in_out, 0x000000FF);
 9464   shll(in_out, 3);
 9465   addl(in_out, tmp3);
 9466   movq(xtmp2, Address(in_out, 0));
 9467 
 9468   psllq(xtmp2, 24);
 9469   pxor(xtmp1, xtmp2); // Result in CXMM
 9470   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
 9471 }
 9472 
 9473 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
 9474                                       Register in_out,
 9475                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
 9476                                       XMMRegister w_xtmp2,
 9477                                       Register tmp1,
 9478                                       Register n_tmp2, Register n_tmp3) {
 9479   if (is_pclmulqdq_supported) {
 9480     movdl(w_xtmp1, in_out);
 9481 
 9482     movl(tmp1, const_or_pre_comp_const_index);
 9483     movdl(w_xtmp2, tmp1);
 9484     pclmulqdq(w_xtmp1, w_xtmp2, 0);
 9485     // Keep result in XMM since GPR is 32 bit in length
 9486   } else {
 9487     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3, w_xtmp1, w_xtmp2);
 9488   }
 9489 }
 9490 
 9491 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
 9492                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9493                                      Register tmp1, Register tmp2,
 9494                                      Register n_tmp3) {
 9495   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
 9496   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
 9497 
 9498   psllq(w_xtmp1, 1);
 9499   movdl(tmp1, w_xtmp1);
 9500   psrlq(w_xtmp1, 32);
 9501   movdl(in_out, w_xtmp1);
 9502 
 9503   xorl(tmp2, tmp2);
 9504   crc32(tmp2, tmp1, 4);
 9505   xorl(in_out, tmp2);
 9506 
 9507   psllq(w_xtmp2, 1);
 9508   movdl(tmp1, w_xtmp2);
 9509   psrlq(w_xtmp2, 32);
 9510   movdl(in1, w_xtmp2);
 9511 
 9512   xorl(tmp2, tmp2);
 9513   crc32(tmp2, tmp1, 4);
 9514   xorl(in1, tmp2);
 9515   xorl(in_out, in1);
 9516   xorl(in_out, in2);
 9517 }
 9518 
 9519 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
 9520                                        Register in_out1, Register in_out2, Register in_out3,
 9521                                        Register tmp1, Register tmp2, Register tmp3,
 9522                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9523                                        Register tmp4, Register tmp5,
 9524                                        Register n_tmp6) {
 9525   Label L_processPartitions;
 9526   Label L_processPartition;
 9527   Label L_exit;
 9528 
 9529   bind(L_processPartitions);
 9530   cmpl(in_out1, 3 * size);
 9531   jcc(Assembler::less, L_exit);
 9532     xorl(tmp1, tmp1);
 9533     xorl(tmp2, tmp2);
 9534     movl(tmp3, in_out2);
 9535     addl(tmp3, size);
 9536 
 9537     bind(L_processPartition);
 9538       crc32(in_out3, Address(in_out2, 0), 4);
 9539       crc32(tmp1, Address(in_out2, size), 4);
 9540       crc32(tmp2, Address(in_out2, size*2), 4);
 9541       crc32(in_out3, Address(in_out2, 0+4), 4);
 9542       crc32(tmp1, Address(in_out2, size+4), 4);
 9543       crc32(tmp2, Address(in_out2, size*2+4), 4);
 9544       addl(in_out2, 8);
 9545       cmpl(in_out2, tmp3);
 9546       jcc(Assembler::less, L_processPartition);
 9547 
 9548         push(tmp3);
 9549         push(in_out1);
 9550         push(in_out2);
 9551         tmp4 = tmp3;
 9552         tmp5 = in_out1;
 9553         n_tmp6 = in_out2;
 9554 
 9555       crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
 9556             w_xtmp1, w_xtmp2, w_xtmp3,
 9557             tmp4, tmp5,
 9558             n_tmp6);
 9559 
 9560         pop(in_out2);
 9561         pop(in_out1);
 9562         pop(tmp3);
 9563 
 9564     addl(in_out2, 2 * size);
 9565     subl(in_out1, 3 * size);
 9566     jmp(L_processPartitions);
 9567 
 9568   bind(L_exit);
 9569 }
 9570 #endif //LP64
 9571 
 9572 #ifdef _LP64
 9573 // Algorithm 2: Pipelined usage of the CRC32 instruction.
 9574 // Input: A buffer I of L bytes.
 9575 // Output: the CRC32C value of the buffer.
 9576 // Notations:
 9577 // Write L = 24N + r, with N = floor (L/24).
 9578 // r = L mod 24 (0 &lt;= r &lt; 24).
 9579 // Consider I as the concatenation of A|B|C|R, where A, B, C, each,
 9580 // N quadwords, and R consists of r bytes.
 9581 // A[j] = I [8j+7:8j], j= 0, 1, ..., N-1
 9582 // B[j] = I [N + 8j+7:N + 8j], j= 0, 1, ..., N-1
 9583 // C[j] = I [2N + 8j+7:2N + 8j], j= 0, 1, ..., N-1
 9584 // if r &gt; 0 R[j] = I [3N +j], j= 0, 1, ...,r-1
 9585 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
 9586                                           Register tmp1, Register tmp2, Register tmp3,
 9587                                           Register tmp4, Register tmp5, Register tmp6,
 9588                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9589                                           bool is_pclmulqdq_supported) {
 9590   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
 9591   Label L_wordByWord;
 9592   Label L_byteByByteProlog;
 9593   Label L_byteByByte;
 9594   Label L_exit;
 9595 
 9596   if (is_pclmulqdq_supported ) {
 9597     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
 9598     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);
 9599 
 9600     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
 9601     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
 9602 
 9603     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
 9604     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
 9605     assert((CRC32C_NUM_PRECOMPUTED_CONSTANTS - 1 ) == 5, &quot;Checking whether you declared all of the constants based on the number of \&quot;chunks\&quot;&quot;);
 9606   } else {
 9607     const_or_pre_comp_const_index[0] = 1;
 9608     const_or_pre_comp_const_index[1] = 0;
 9609 
 9610     const_or_pre_comp_const_index[2] = 3;
 9611     const_or_pre_comp_const_index[3] = 2;
 9612 
 9613     const_or_pre_comp_const_index[4] = 5;
 9614     const_or_pre_comp_const_index[5] = 4;
 9615    }
 9616   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
 9617                     in2, in1, in_out,
 9618                     tmp1, tmp2, tmp3,
 9619                     w_xtmp1, w_xtmp2, w_xtmp3,
 9620                     tmp4, tmp5,
 9621                     tmp6);
 9622   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
 9623                     in2, in1, in_out,
 9624                     tmp1, tmp2, tmp3,
 9625                     w_xtmp1, w_xtmp2, w_xtmp3,
 9626                     tmp4, tmp5,
 9627                     tmp6);
 9628   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
 9629                     in2, in1, in_out,
 9630                     tmp1, tmp2, tmp3,
 9631                     w_xtmp1, w_xtmp2, w_xtmp3,
 9632                     tmp4, tmp5,
 9633                     tmp6);
 9634   movl(tmp1, in2);
 9635   andl(tmp1, 0x00000007);
 9636   negl(tmp1);
 9637   addl(tmp1, in2);
 9638   addq(tmp1, in1);
 9639 
 9640   BIND(L_wordByWord);
 9641   cmpq(in1, tmp1);
 9642   jcc(Assembler::greaterEqual, L_byteByByteProlog);
 9643     crc32(in_out, Address(in1, 0), 4);
 9644     addq(in1, 4);
 9645     jmp(L_wordByWord);
 9646 
 9647   BIND(L_byteByByteProlog);
 9648   andl(in2, 0x00000007);
 9649   movl(tmp2, 1);
 9650 
 9651   BIND(L_byteByByte);
 9652   cmpl(tmp2, in2);
 9653   jccb(Assembler::greater, L_exit);
 9654     crc32(in_out, Address(in1, 0), 1);
 9655     incq(in1);
 9656     incl(tmp2);
 9657     jmp(L_byteByByte);
 9658 
 9659   BIND(L_exit);
 9660 }
 9661 #else
 9662 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
 9663                                           Register tmp1, Register  tmp2, Register tmp3,
 9664                                           Register tmp4, Register  tmp5, Register tmp6,
 9665                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9666                                           bool is_pclmulqdq_supported) {
 9667   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
 9668   Label L_wordByWord;
 9669   Label L_byteByByteProlog;
 9670   Label L_byteByByte;
 9671   Label L_exit;
 9672 
 9673   if (is_pclmulqdq_supported) {
 9674     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
 9675     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);
 9676 
 9677     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
 9678     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
 9679 
 9680     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
 9681     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
 9682   } else {
 9683     const_or_pre_comp_const_index[0] = 1;
 9684     const_or_pre_comp_const_index[1] = 0;
 9685 
 9686     const_or_pre_comp_const_index[2] = 3;
 9687     const_or_pre_comp_const_index[3] = 2;
 9688 
 9689     const_or_pre_comp_const_index[4] = 5;
 9690     const_or_pre_comp_const_index[5] = 4;
 9691   }
 9692   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
 9693                     in2, in1, in_out,
 9694                     tmp1, tmp2, tmp3,
 9695                     w_xtmp1, w_xtmp2, w_xtmp3,
 9696                     tmp4, tmp5,
 9697                     tmp6);
 9698   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
 9699                     in2, in1, in_out,
 9700                     tmp1, tmp2, tmp3,
 9701                     w_xtmp1, w_xtmp2, w_xtmp3,
 9702                     tmp4, tmp5,
 9703                     tmp6);
 9704   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
 9705                     in2, in1, in_out,
 9706                     tmp1, tmp2, tmp3,
 9707                     w_xtmp1, w_xtmp2, w_xtmp3,
 9708                     tmp4, tmp5,
 9709                     tmp6);
 9710   movl(tmp1, in2);
 9711   andl(tmp1, 0x00000007);
 9712   negl(tmp1);
 9713   addl(tmp1, in2);
 9714   addl(tmp1, in1);
 9715 
 9716   BIND(L_wordByWord);
 9717   cmpl(in1, tmp1);
 9718   jcc(Assembler::greaterEqual, L_byteByByteProlog);
 9719     crc32(in_out, Address(in1,0), 4);
 9720     addl(in1, 4);
 9721     jmp(L_wordByWord);
 9722 
 9723   BIND(L_byteByByteProlog);
 9724   andl(in2, 0x00000007);
 9725   movl(tmp2, 1);
 9726 
 9727   BIND(L_byteByByte);
 9728   cmpl(tmp2, in2);
 9729   jccb(Assembler::greater, L_exit);
 9730     movb(tmp1, Address(in1, 0));
 9731     crc32(in_out, tmp1, 1);
 9732     incl(in1);
 9733     incl(tmp2);
 9734     jmp(L_byteByByte);
 9735 
 9736   BIND(L_exit);
 9737 }
 9738 #endif // LP64
 9739 #undef BIND
 9740 #undef BLOCK_COMMENT
 9741 
 9742 // Compress char[] array to byte[].
 9743 //   ..\jdk\src\java.base\share\classes\java\lang\StringUTF16.java
 9744 //   @HotSpotIntrinsicCandidate
 9745 //   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
 9746 //     for (int i = 0; i &lt; len; i++) {
 9747 //       int c = src[srcOff++];
 9748 //       if (c &gt;&gt;&gt; 8 != 0) {
 9749 //         return 0;
 9750 //       }
 9751 //       dst[dstOff++] = (byte)c;
 9752 //     }
 9753 //     return len;
 9754 //   }
 9755 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
 9756   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
 9757   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
 9758   Register tmp5, Register result) {
 9759   Label copy_chars_loop, return_length, return_zero, done;
 9760 
 9761   // rsi: src
 9762   // rdi: dst
 9763   // rdx: len
 9764   // rcx: tmp5
 9765   // rax: result
 9766 
 9767   // rsi holds start addr of source char[] to be compressed
 9768   // rdi holds start addr of destination byte[]
 9769   // rdx holds length
 9770 
 9771   assert(len != result, &quot;&quot;);
 9772 
 9773   // save length for return
 9774   push(len);
 9775 
 9776   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
 9777     VM_Version::supports_avx512vlbw() &amp;&amp;
 9778     VM_Version::supports_bmi2()) {
 9779 
 9780     Label copy_32_loop, copy_loop_tail, below_threshold;
 9781 
 9782     // alignment
 9783     Label post_alignment;
 9784 
 9785     // if length of the string is less than 16, handle it in an old fashioned way
 9786     testl(len, -32);
 9787     jcc(Assembler::zero, below_threshold);
 9788 
 9789     // First check whether a character is compressable ( &lt;= 0xFF).
 9790     // Create mask to test for Unicode chars inside zmm vector
 9791     movl(result, 0x00FF);
 9792     evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);
 9793 
 9794     testl(len, -64);
 9795     jcc(Assembler::zero, post_alignment);
 9796 
 9797     movl(tmp5, dst);
 9798     andl(tmp5, (32 - 1));
 9799     negl(tmp5);
 9800     andl(tmp5, (32 - 1));
 9801 
 9802     // bail out when there is nothing to be done
 9803     testl(tmp5, 0xFFFFFFFF);
 9804     jcc(Assembler::zero, post_alignment);
 9805 
 9806     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
 9807     movl(result, 0xFFFFFFFF);
 9808     shlxl(result, result, tmp5);
 9809     notl(result);
 9810     kmovdl(k3, result);
 9811 
 9812     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
 9813     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
 9814     ktestd(k2, k3);
 9815     jcc(Assembler::carryClear, return_zero);
 9816 
 9817     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
 9818 
 9819     addptr(src, tmp5);
 9820     addptr(src, tmp5);
 9821     addptr(dst, tmp5);
 9822     subl(len, tmp5);
 9823 
 9824     bind(post_alignment);
 9825     // end of alignment
 9826 
 9827     movl(tmp5, len);
 9828     andl(tmp5, (32 - 1));    // tail count (in chars)
 9829     andl(len, ~(32 - 1));    // vector count (in chars)
 9830     jcc(Assembler::zero, copy_loop_tail);
 9831 
 9832     lea(src, Address(src, len, Address::times_2));
 9833     lea(dst, Address(dst, len, Address::times_1));
 9834     negptr(len);
 9835 
 9836     bind(copy_32_loop);
 9837     evmovdquw(tmp1Reg, Address(src, len, Address::times_2), Assembler::AVX_512bit);
 9838     evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
 9839     kortestdl(k2, k2);
 9840     jcc(Assembler::carryClear, return_zero);
 9841 
 9842     // All elements in current processed chunk are valid candidates for
 9843     // compression. Write a truncated byte elements to the memory.
 9844     evpmovwb(Address(dst, len, Address::times_1), tmp1Reg, Assembler::AVX_512bit);
 9845     addptr(len, 32);
 9846     jcc(Assembler::notZero, copy_32_loop);
 9847 
 9848     bind(copy_loop_tail);
 9849     // bail out when there is nothing to be done
 9850     testl(tmp5, 0xFFFFFFFF);
 9851     jcc(Assembler::zero, return_length);
 9852 
 9853     movl(len, tmp5);
 9854 
 9855     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
 9856     movl(result, 0xFFFFFFFF);
 9857     shlxl(result, result, len);
 9858     notl(result);
 9859 
 9860     kmovdl(k3, result);
 9861 
 9862     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
 9863     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
 9864     ktestd(k2, k3);
 9865     jcc(Assembler::carryClear, return_zero);
 9866 
 9867     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
 9868     jmp(return_length);
 9869 
 9870     bind(below_threshold);
 9871   }
 9872 
 9873   if (UseSSE42Intrinsics) {
 9874     Label copy_32_loop, copy_16, copy_tail;
 9875 
 9876     movl(result, len);
 9877 
 9878     movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vectors
 9879 
 9880     // vectored compression
 9881     andl(len, 0xfffffff0);    // vector count (in chars)
 9882     andl(result, 0x0000000f);    // tail count (in chars)
 9883     testl(len, len);
 9884     jcc(Assembler::zero, copy_16);
 9885 
 9886     // compress 16 chars per iter
 9887     movdl(tmp1Reg, tmp5);
 9888     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
 9889     pxor(tmp4Reg, tmp4Reg);
 9890 
 9891     lea(src, Address(src, len, Address::times_2));
 9892     lea(dst, Address(dst, len, Address::times_1));
 9893     negptr(len);
 9894 
 9895     bind(copy_32_loop);
 9896     movdqu(tmp2Reg, Address(src, len, Address::times_2));     // load 1st 8 characters
 9897     por(tmp4Reg, tmp2Reg);
 9898     movdqu(tmp3Reg, Address(src, len, Address::times_2, 16)); // load next 8 characters
 9899     por(tmp4Reg, tmp3Reg);
 9900     ptest(tmp4Reg, tmp1Reg);       // check for Unicode chars in next vector
 9901     jcc(Assembler::notZero, return_zero);
 9902     packuswb(tmp2Reg, tmp3Reg);    // only ASCII chars; compress each to 1 byte
 9903     movdqu(Address(dst, len, Address::times_1), tmp2Reg);
 9904     addptr(len, 16);
 9905     jcc(Assembler::notZero, copy_32_loop);
 9906 
 9907     // compress next vector of 8 chars (if any)
 9908     bind(copy_16);
 9909     movl(len, result);
 9910     andl(len, 0xfffffff8);    // vector count (in chars)
 9911     andl(result, 0x00000007);    // tail count (in chars)
 9912     testl(len, len);
 9913     jccb(Assembler::zero, copy_tail);
 9914 
 9915     movdl(tmp1Reg, tmp5);
 9916     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
 9917     pxor(tmp3Reg, tmp3Reg);
 9918 
 9919     movdqu(tmp2Reg, Address(src, 0));
 9920     ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in vector
 9921     jccb(Assembler::notZero, return_zero);
 9922     packuswb(tmp2Reg, tmp3Reg);    // only LATIN1 chars; compress each to 1 byte
 9923     movq(Address(dst, 0), tmp2Reg);
 9924     addptr(src, 16);
 9925     addptr(dst, 8);
 9926 
 9927     bind(copy_tail);
 9928     movl(len, result);
 9929   }
 9930   // compress 1 char per iter
 9931   testl(len, len);
 9932   jccb(Assembler::zero, return_length);
 9933   lea(src, Address(src, len, Address::times_2));
 9934   lea(dst, Address(dst, len, Address::times_1));
 9935   negptr(len);
 9936 
 9937   bind(copy_chars_loop);
 9938   load_unsigned_short(result, Address(src, len, Address::times_2));
 9939   testl(result, 0xff00);      // check if Unicode char
 9940   jccb(Assembler::notZero, return_zero);
 9941   movb(Address(dst, len, Address::times_1), result);  // ASCII char; compress to 1 byte
 9942   increment(len);
 9943   jcc(Assembler::notZero, copy_chars_loop);
 9944 
 9945   // if compression succeeded, return length
 9946   bind(return_length);
 9947   pop(result);
 9948   jmpb(done);
 9949 
 9950   // if compression failed, return 0
 9951   bind(return_zero);
 9952   xorl(result, result);
 9953   addptr(rsp, wordSize);
 9954 
 9955   bind(done);
 9956 }
 9957 
 9958 // Inflate byte[] array to char[].
 9959 //   ..\jdk\src\java.base\share\classes\java\lang\StringLatin1.java
 9960 //   @HotSpotIntrinsicCandidate
 9961 //   private static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
 9962 //     for (int i = 0; i &lt; len; i++) {
 9963 //       dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
 9964 //     }
 9965 //   }
 9966 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
 9967   XMMRegister tmp1, Register tmp2) {
 9968   Label copy_chars_loop, done, below_threshold, avx3_threshold;
 9969   // rsi: src
 9970   // rdi: dst
 9971   // rdx: len
 9972   // rcx: tmp2
 9973 
 9974   // rsi holds start addr of source byte[] to be inflated
 9975   // rdi holds start addr of destination char[]
 9976   // rdx holds length
 9977   assert_different_registers(src, dst, len, tmp2);
 9978   movl(tmp2, len);
 9979   if ((UseAVX &gt; 2) &amp;&amp; // AVX512
 9980     VM_Version::supports_avx512vlbw() &amp;&amp;
 9981     VM_Version::supports_bmi2()) {
 9982 
 9983     Label copy_32_loop, copy_tail;
 9984     Register tmp3_aliased = len;
 9985 
 9986     // if length of the string is less than 16, handle it in an old fashioned way
 9987     testl(len, -16);
 9988     jcc(Assembler::zero, below_threshold);
 9989 
 9990     testl(len, -1 * AVX3Threshold);
 9991     jcc(Assembler::zero, avx3_threshold);
 9992 
 9993     // In order to use only one arithmetic operation for the main loop we use
 9994     // this pre-calculation
 9995     andl(tmp2, (32 - 1)); // tail count (in chars), 32 element wide loop
 9996     andl(len, -32);     // vector count
 9997     jccb(Assembler::zero, copy_tail);
 9998 
 9999     lea(src, Address(src, len, Address::times_1));
10000     lea(dst, Address(dst, len, Address::times_2));
10001     negptr(len);
10002 
10003 
10004     // inflate 32 chars per iter
10005     bind(copy_32_loop);
10006     vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_512bit);
10007     evmovdquw(Address(dst, len, Address::times_2), tmp1, Assembler::AVX_512bit);
10008     addptr(len, 32);
10009     jcc(Assembler::notZero, copy_32_loop);
10010 
10011     bind(copy_tail);
10012     // bail out when there is nothing to be done
10013     testl(tmp2, -1); // we don&#39;t destroy the contents of tmp2 here
10014     jcc(Assembler::zero, done);
10015 
10016     // ~(~0 &lt;&lt; length), where length is the # of remaining elements to process
10017     movl(tmp3_aliased, -1);
10018     shlxl(tmp3_aliased, tmp3_aliased, tmp2);
10019     notl(tmp3_aliased);
10020     kmovdl(k2, tmp3_aliased);
10021     evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);
10022     evmovdquw(Address(dst, 0), k2, tmp1, Assembler::AVX_512bit);
10023 
10024     jmp(done);
10025     bind(avx3_threshold);
10026   }
10027   if (UseSSE42Intrinsics) {
10028     Label copy_16_loop, copy_8_loop, copy_bytes, copy_new_tail, copy_tail;
10029 
10030     if (UseAVX &gt; 1) {
10031       andl(tmp2, (16 - 1));
10032       andl(len, -16);
10033       jccb(Assembler::zero, copy_new_tail);
10034     } else {
10035       andl(tmp2, 0x00000007);   // tail count (in chars)
10036       andl(len, 0xfffffff8);    // vector count (in chars)
10037       jccb(Assembler::zero, copy_tail);
10038     }
10039 
10040     // vectored inflation
10041     lea(src, Address(src, len, Address::times_1));
10042     lea(dst, Address(dst, len, Address::times_2));
10043     negptr(len);
10044 
10045     if (UseAVX &gt; 1) {
10046       bind(copy_16_loop);
10047       vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_256bit);
10048       vmovdqu(Address(dst, len, Address::times_2), tmp1);
10049       addptr(len, 16);
10050       jcc(Assembler::notZero, copy_16_loop);
10051 
10052       bind(below_threshold);
10053       bind(copy_new_tail);
10054       movl(len, tmp2);
10055       andl(tmp2, 0x00000007);
10056       andl(len, 0xFFFFFFF8);
10057       jccb(Assembler::zero, copy_tail);
10058 
10059       pmovzxbw(tmp1, Address(src, 0));
10060       movdqu(Address(dst, 0), tmp1);
10061       addptr(src, 8);
10062       addptr(dst, 2 * 8);
10063 
10064       jmp(copy_tail, true);
10065     }
10066 
10067     // inflate 8 chars per iter
10068     bind(copy_8_loop);
10069     pmovzxbw(tmp1, Address(src, len, Address::times_1));  // unpack to 8 words
10070     movdqu(Address(dst, len, Address::times_2), tmp1);
10071     addptr(len, 8);
10072     jcc(Assembler::notZero, copy_8_loop);
10073 
10074     bind(copy_tail);
10075     movl(len, tmp2);
10076 
10077     cmpl(len, 4);
10078     jccb(Assembler::less, copy_bytes);
10079 
10080     movdl(tmp1, Address(src, 0));  // load 4 byte chars
10081     pmovzxbw(tmp1, tmp1);
10082     movq(Address(dst, 0), tmp1);
10083     subptr(len, 4);
10084     addptr(src, 4);
10085     addptr(dst, 8);
10086 
10087     bind(copy_bytes);
10088   } else {
10089     bind(below_threshold);
10090   }
10091 
10092   testl(len, len);
10093   jccb(Assembler::zero, done);
10094   lea(src, Address(src, len, Address::times_1));
10095   lea(dst, Address(dst, len, Address::times_2));
10096   negptr(len);
10097 
10098   // inflate 1 char per iter
10099   bind(copy_chars_loop);
10100   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
10101   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
10102   increment(len);
10103   jcc(Assembler::notZero, copy_chars_loop);
10104 
10105   bind(done);
10106 }
10107 
10108 #ifdef _LP64
10109 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
10110   Label done;
10111   cvttss2sil(dst, src);
10112   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
10113   cmpl(dst, 0x80000000); // float_sign_flip
10114   jccb(Assembler::notEqual, done);
10115   subptr(rsp, 8);
10116   movflt(Address(rsp, 0), src);
10117   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
10118   pop(dst);
10119   bind(done);
10120 }
10121 
10122 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
10123   Label done;
10124   cvttsd2sil(dst, src);
10125   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
10126   cmpl(dst, 0x80000000); // float_sign_flip
10127   jccb(Assembler::notEqual, done);
10128   subptr(rsp, 8);
10129   movdbl(Address(rsp, 0), src);
10130   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
10131   pop(dst);
10132   bind(done);
10133 }
10134 
10135 void MacroAssembler::convert_f2l(Register dst, XMMRegister src) {
10136   Label done;
10137   cvttss2siq(dst, src);
10138   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
10139   jccb(Assembler::notEqual, done);
10140   subptr(rsp, 8);
10141   movflt(Address(rsp, 0), src);
10142   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
10143   pop(dst);
10144   bind(done);
10145 }
10146 
10147 void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {
10148   Label done;
10149   cvttsd2siq(dst, src);
10150   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
10151   jccb(Assembler::notEqual, done);
10152   subptr(rsp, 8);
10153   movdbl(Address(rsp, 0), src);
10154   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
10155   pop(dst);
10156   bind(done);
10157 }
10158 
10159 void MacroAssembler::cache_wb(Address line)
10160 {
10161   // 64 bit cpus always support clflush
10162   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
10163   bool optimized = VM_Version::supports_clflushopt();
10164   bool no_evict = VM_Version::supports_clwb();
10165 
10166   // prefer clwb (writeback without evict) otherwise
10167   // prefer clflushopt (potentially parallel writeback with evict)
10168   // otherwise fallback on clflush (serial writeback with evict)
10169 
10170   if (optimized) {
10171     if (no_evict) {
10172       clwb(line);
10173     } else {
10174       clflushopt(line);
10175     }
10176   } else {
10177     // no need for fence when using CLFLUSH
10178     clflush(line);
10179   }
10180 }
10181 
10182 void MacroAssembler::cache_wbsync(bool is_pre)
10183 {
10184   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
10185   bool optimized = VM_Version::supports_clflushopt();
10186   bool no_evict = VM_Version::supports_clwb();
10187 
10188   // pick the correct implementation
10189 
10190   if (!is_pre &amp;&amp; (optimized || no_evict)) {
10191     // need an sfence for post flush when using clflushopt or clwb
10192     // otherwise no no need for any synchroniaztion
10193 
10194     sfence();
10195   }
10196 }
10197 #endif // _LP64
10198 
10199 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
10200   switch (cond) {
10201     // Note some conditions are synonyms for others
10202     case Assembler::zero:         return Assembler::notZero;
10203     case Assembler::notZero:      return Assembler::zero;
10204     case Assembler::less:         return Assembler::greaterEqual;
10205     case Assembler::lessEqual:    return Assembler::greater;
10206     case Assembler::greater:      return Assembler::lessEqual;
10207     case Assembler::greaterEqual: return Assembler::less;
10208     case Assembler::below:        return Assembler::aboveEqual;
10209     case Assembler::belowEqual:   return Assembler::above;
10210     case Assembler::above:        return Assembler::belowEqual;
10211     case Assembler::aboveEqual:   return Assembler::below;
10212     case Assembler::overflow:     return Assembler::noOverflow;
10213     case Assembler::noOverflow:   return Assembler::overflow;
10214     case Assembler::negative:     return Assembler::positive;
10215     case Assembler::positive:     return Assembler::negative;
10216     case Assembler::parity:       return Assembler::noParity;
10217     case Assembler::noParity:     return Assembler::parity;
10218   }
10219   ShouldNotReachHere(); return Assembler::overflow;
10220 }
10221 
10222 SkipIfEqual::SkipIfEqual(
10223     MacroAssembler* masm, const bool* flag_addr, bool value) {
10224   _masm = masm;
10225   _masm-&gt;cmp8(ExternalAddress((address)flag_addr), value);
10226   _masm-&gt;jcc(Assembler::equal, _label);
10227 }
10228 
10229 SkipIfEqual::~SkipIfEqual() {
10230   _masm-&gt;bind(_label);
10231 }
10232 
10233 // 32-bit Windows has its own fast-path implementation
10234 // of get_thread
10235 #if !defined(WIN32) || defined(_LP64)
10236 
10237 // This is simply a call to Thread::current()
10238 void MacroAssembler::get_thread(Register thread) {
10239   if (thread != rax) {
10240     push(rax);
10241   }
10242   LP64_ONLY(push(rdi);)
10243   LP64_ONLY(push(rsi);)
10244   push(rdx);
10245   push(rcx);
10246 #ifdef _LP64
10247   push(r8);
10248   push(r9);
10249   push(r10);
10250   push(r11);
10251 #endif
10252 
10253   MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, Thread::current), 0);
10254 
10255 #ifdef _LP64
10256   pop(r11);
10257   pop(r10);
10258   pop(r9);
10259   pop(r8);
10260 #endif
10261   pop(rcx);
10262   pop(rdx);
10263   LP64_ONLY(pop(rsi);)
10264   LP64_ONLY(pop(rdi);)
10265   if (thread != rax) {
10266     mov(thread, rax);
10267     pop(rax);
10268   }
10269 }
10270 
10271 #endif // !WIN32 || _LP64
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
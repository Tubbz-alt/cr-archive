<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
167         checkAccessModes(accessModes);
168         return (accessModes() &amp; accessModes) == accessModes;
169     }
170 
171     private void checkAccessModes(int accessModes) {
172         if ((accessModes &amp; ~ACCESS_MASK) != 0) {
173             throw new IllegalArgumentException(&quot;Invalid access modes&quot;);
174         }
175     }
176 
177     @Override
178     public MemorySegment withOwnerThread(Thread newOwner) {
179         Objects.requireNonNull(newOwner);
180         checkValidState();
181         if (!isSet(HANDOFF)) {
182             throw unsupportedAccessMode(HANDOFF);
183         }
184         if (owner == newOwner) {
185             throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);
186         } else {
<span class="line-modified">187             return dup(0L, length, mask, newOwner, scope.dup());</span>





188         }
189     }
190 
191     @Override
192     public final void close() {
193         if (!isSet(CLOSE)) {
194             throw unsupportedAccessMode(CLOSE);
195         }
196         checkValidState();
197         closeNoCheck();
198     }
199 
200     private final void closeNoCheck() {
201         scope.close();
202     }
203 
204     final AbstractMemorySegmentImpl acquire() {
205         if (Thread.currentThread() != ownerThread() &amp;&amp; !isSet(ACQUIRE)) {
206             throw unsupportedAccessMode(ACQUIRE);
207         }
</pre>
</td>
<td>
<hr />
<pre>
167         checkAccessModes(accessModes);
168         return (accessModes() &amp; accessModes) == accessModes;
169     }
170 
171     private void checkAccessModes(int accessModes) {
172         if ((accessModes &amp; ~ACCESS_MASK) != 0) {
173             throw new IllegalArgumentException(&quot;Invalid access modes&quot;);
174         }
175     }
176 
177     @Override
178     public MemorySegment withOwnerThread(Thread newOwner) {
179         Objects.requireNonNull(newOwner);
180         checkValidState();
181         if (!isSet(HANDOFF)) {
182             throw unsupportedAccessMode(HANDOFF);
183         }
184         if (owner == newOwner) {
185             throw new IllegalArgumentException(&quot;Segment already owned by thread: &quot; + newOwner);
186         } else {
<span class="line-modified">187             try {</span>
<span class="line-added">188                 return dup(0L, length, mask, newOwner, scope.dup());</span>
<span class="line-added">189             } finally {</span>
<span class="line-added">190                 //flush read/writes to segment memory before returning the new segment</span>
<span class="line-added">191                 VarHandle.fullFence();</span>
<span class="line-added">192             }</span>
193         }
194     }
195 
196     @Override
197     public final void close() {
198         if (!isSet(CLOSE)) {
199             throw unsupportedAccessMode(CLOSE);
200         }
201         checkValidState();
202         closeNoCheck();
203     }
204 
205     private final void closeNoCheck() {
206         scope.close();
207     }
208 
209     final AbstractMemorySegmentImpl acquire() {
210         if (Thread.currentThread() != ownerThread() &amp;&amp; !isSet(ACQUIRE)) {
211             throw unsupportedAccessMode(ACQUIRE);
212         }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
116      *
117      * @return {@code true} if this scope is not closed yet.
118      */
119     final boolean isAliveThreadSafe() {
120         return ((int) STATE.getVolatile(this)) &lt; STATE_CLOSED;
121     }
122 
123     /**
124      * Checks that this scope is still alive.
125      * This method may only be called in &quot;owner&quot; thread.
126      *
127      * @throws IllegalStateException if this scope is already closed
128      */
129     final void checkAliveConfined() {
130         if (state == STATE_CLOSED) {
131             throw new IllegalStateException(&quot;This scope is already closed&quot;);
132         }
133     }
134 
135     private static final class Root extends MemoryScope {
<span class="line-modified">136         private final LongAdder acquires;</span>
<span class="line-modified">137         private final LongAdder releases;</span>
138         private final Object ref;
139         private final Runnable cleanupAction;
140 
<span class="line-modified">141         private Root(LongAdder acquires, LongAdder releases, Object ref, Runnable cleanupAction) {</span>
<span class="line-removed">142             this.acquires = acquires;</span>
<span class="line-removed">143             this.releases = releases;</span>
144             this.ref = ref;
145             this.cleanupAction = cleanupAction;
146         }
147 
<span class="line-removed">148         private Root(Object ref, Runnable cleanupAction) {</span>
<span class="line-removed">149             this(new LongAdder(), new LongAdder(), ref, cleanupAction);</span>
<span class="line-removed">150         }</span>
<span class="line-removed">151 </span>
152         @Override
153         MemoryScope acquire() {
154             // increment acquires 1st
155             acquires.increment();
156             // check state 2nd
<span class="line-modified">157             int state = (int) STATE.getVolatile(this);</span>
<span class="line-modified">158             while (state &gt; STATE_OPEN) {</span>
159                 if (state == STATE_CLOSED) {
160                     releases.increment();
161                     throw new IllegalStateException(&quot;This scope is already closed&quot;);
162                 }
163                 Thread.onSpinWait();
<span class="line-removed">164                 state = (int) STATE.getVolatile(this);</span>
165             }
166             return new Child();
167         }
168 
169         @Override
170         MemoryScope dup() { // always called in owner thread
171             return closeOrDup(false);
172         }
173 
174         @Override
175         void close() { // always called in owner thread
176             closeOrDup(true);
177         }
178 
179         private MemoryScope closeOrDup(boolean close) {
180             if (state == STATE_CLOSED) {
181                 throw new IllegalStateException(&quot;This scope is already closed&quot;);
182             }
<span class="line-modified">183             // pre-allocate duped scope so we don&#39;t get OOME later and be left with this scope closed;</span>
<span class="line-modified">184             // we only return this instance if releases.sum() == acquires.sum(), so both LongAdder(s)</span>
<span class="line-removed">185             // can be reused...</span>
<span class="line-removed">186             var duped = close ? null : new Root(acquires, releases, ref, cleanupAction);</span>
187             // modify state to STATE_CLOSING 1st
188             STATE.setVolatile(this, STATE_CLOSING);
189             // check for absence of active acquired children 2nd
190             // IMPORTANT: 1st sum releases, then sum acquires !!!
191             if (releases.sum() != acquires.sum()) {
192                 STATE.setVolatile(this, STATE_OPEN); // revert back to STATE_OPEN
193                 throw new IllegalStateException(&quot;Cannot close this scope as it has active acquired children&quot;);
194             }
195             // now that we made sure there&#39;s no active acquired children, we modify to STATE_CLOSED
196             STATE.setVolatile(this, STATE_CLOSED);
197             // do close or dup
198             if (close) {
199                 if (cleanupAction != null) {
200                     cleanupAction.run();
201                 }
202                 return null;
203             } else {
<span class="line-removed">204                 // assert releases.sum() == acquires.sum() &amp;&amp; state == STATE_CLOSED;</span>
205                 return duped;
206             }
207         }
208 
209         private final class Child extends MemoryScope {
210 
211             private Child() {
212             }
213 
214             @Override
215             MemoryScope acquire() {
216                 return Root.this.acquire();
217             }
218 
219             @Override
220             MemoryScope dup() { // always called in owner thread
221                 if (state == STATE_CLOSED) {
222                     throw new IllegalStateException(&quot;This scope is already closed&quot;);
223                 }
224                 // pre-allocate duped scope so we don&#39;t get OOME later and be left with this scope closed
</pre>
</td>
<td>
<hr />
<pre>
116      *
117      * @return {@code true} if this scope is not closed yet.
118      */
119     final boolean isAliveThreadSafe() {
120         return ((int) STATE.getVolatile(this)) &lt; STATE_CLOSED;
121     }
122 
123     /**
124      * Checks that this scope is still alive.
125      * This method may only be called in &quot;owner&quot; thread.
126      *
127      * @throws IllegalStateException if this scope is already closed
128      */
129     final void checkAliveConfined() {
130         if (state == STATE_CLOSED) {
131             throw new IllegalStateException(&quot;This scope is already closed&quot;);
132         }
133     }
134 
135     private static final class Root extends MemoryScope {
<span class="line-modified">136         private final LongAdder acquires = new LongAdder();</span>
<span class="line-modified">137         private final LongAdder releases = new LongAdder();</span>
138         private final Object ref;
139         private final Runnable cleanupAction;
140 
<span class="line-modified">141         private Root(Object ref, Runnable cleanupAction) {</span>


142             this.ref = ref;
143             this.cleanupAction = cleanupAction;
144         }
145 




146         @Override
147         MemoryScope acquire() {
148             // increment acquires 1st
149             acquires.increment();
150             // check state 2nd
<span class="line-modified">151             int state;</span>
<span class="line-modified">152             while ((state  = (int) STATE.getVolatile(this)) &gt; STATE_OPEN) {</span>
153                 if (state == STATE_CLOSED) {
154                     releases.increment();
155                     throw new IllegalStateException(&quot;This scope is already closed&quot;);
156                 }
157                 Thread.onSpinWait();

158             }
159             return new Child();
160         }
161 
162         @Override
163         MemoryScope dup() { // always called in owner thread
164             return closeOrDup(false);
165         }
166 
167         @Override
168         void close() { // always called in owner thread
169             closeOrDup(true);
170         }
171 
172         private MemoryScope closeOrDup(boolean close) {
173             if (state == STATE_CLOSED) {
174                 throw new IllegalStateException(&quot;This scope is already closed&quot;);
175             }
<span class="line-modified">176             // pre-allocate duped scope so we don&#39;t get OOME later and be left with this scope closed</span>
<span class="line-modified">177             var duped = close ? null : new Root(ref, cleanupAction);</span>


178             // modify state to STATE_CLOSING 1st
179             STATE.setVolatile(this, STATE_CLOSING);
180             // check for absence of active acquired children 2nd
181             // IMPORTANT: 1st sum releases, then sum acquires !!!
182             if (releases.sum() != acquires.sum()) {
183                 STATE.setVolatile(this, STATE_OPEN); // revert back to STATE_OPEN
184                 throw new IllegalStateException(&quot;Cannot close this scope as it has active acquired children&quot;);
185             }
186             // now that we made sure there&#39;s no active acquired children, we modify to STATE_CLOSED
187             STATE.setVolatile(this, STATE_CLOSED);
188             // do close or dup
189             if (close) {
190                 if (cleanupAction != null) {
191                     cleanupAction.run();
192                 }
193                 return null;
194             } else {

195                 return duped;
196             }
197         }
198 
199         private final class Child extends MemoryScope {
200 
201             private Child() {
202             }
203 
204             @Override
205             MemoryScope acquire() {
206                 return Root.this.acquire();
207             }
208 
209             @Override
210             MemoryScope dup() { // always called in owner thread
211                 if (state == STATE_CLOSED) {
212                     throw new IllegalStateException(&quot;This scope is already closed&quot;);
213                 }
214                 // pre-allocate duped scope so we don&#39;t get OOME later and be left with this scope closed
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
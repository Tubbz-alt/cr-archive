diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AllocationScope.java
@@ -61,11 +61,11 @@
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
      * @return an address which points to the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()) does not conform to the size of a byte value.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.
      */
     public MemoryAddress allocate(MemoryLayout layout, byte value) {
         VarHandle handle = layout.varHandle(byte.class);
         MemoryAddress addr = allocate(layout);
         handle.set(addr, value);
@@ -79,11 +79,11 @@
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
      * @return an address which points to the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()) does not conform to the size of a short value.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.
      */
     public MemoryAddress allocate(MemoryLayout layout, short value) {
         VarHandle handle = layout.varHandle(short.class);
         MemoryAddress addr = allocate(layout);
         handle.set(addr, value);
@@ -97,11 +97,11 @@
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
      * @return an address which points to the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()) does not conform to the size of a int value.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.
      */
     public MemoryAddress allocate(MemoryLayout layout, int value) {
         VarHandle handle = layout.varHandle(int.class);
         MemoryAddress addr = allocate(layout);
         handle.set(addr, value);
@@ -115,11 +115,11 @@
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
      * @return an address which points to the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()) does not conform to the size of a float value.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.
      */
     public MemoryAddress allocate(MemoryLayout layout, float value) {
         VarHandle handle = layout.varHandle(float.class);
         MemoryAddress addr = allocate(layout);
         handle.set(addr, value);
@@ -133,11 +133,11 @@
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
      * @return an address which points to the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()) does not conform to the size of a long value.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.
      */
     public MemoryAddress allocate(MemoryLayout layout, long value) {
         VarHandle handle = layout.varHandle(long.class);
         MemoryAddress addr = allocate(layout);
         handle.set(addr, value);
@@ -151,11 +151,11 @@
      * @param layout the layout of the block of memory to be allocated.
      * @param value the value to be set on the newly allocated memory block.
      * @return an address which points to the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()) does not conform to the size of a double value.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.
      */
     public MemoryAddress allocate(MemoryLayout layout, double value) {
         VarHandle handle = layout.varHandle(double.class);
         MemoryAddress addr = allocate(layout);
         handle.set(addr, value);
@@ -165,14 +165,15 @@
     /**
      * Allocate a block of memory in this allocation scope with given layout and initialize it with given address value.
      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
      * address must conform to the layout alignment constraints.
      * @param layout the layout of the block of memory to be allocated.
+     * @param value the value to be set on the newly allocated memory block.
      * @return an address which points to the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this allocation scope, that is, if
      * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()) does not conform to the size of an address value.
+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of an address value.
      */
     public MemoryAddress allocate(MemoryLayout layout, MemoryAddress value) {
         VarHandle handle = layout.varHandle(MemoryAddress.class);
         MemoryAddress addr = allocate(layout);
         handle.set(addr, value);
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -73,11 +73,11 @@
      */
     MemorySegment segment();
 
     /**
      * Reinterpret this address as an offset into the provided segment.
-     * @param segment
+     * @param segment the segment to be rebased
      * @return a new address pointing to the same memory location through the provided segment
      * @throws IllegalArgumentException if the provided segment is not a valid rebase target for this address. This
      * can happen, for instance, if an heap-based addressed is rebased to an off-heap memory segment.
      */
     MemoryAddress rebase(MemorySegment segment);
@@ -127,11 +127,10 @@
     }
 
     /**
      * A native memory address instance modelling the {@code NULL} pointer. This address is backed by a memory segment
      * which can be neither closed, nor dereferenced.
-     * @return the NULL memory address.
      */
     MemoryAddress NULL = MemorySegmentImpl.NOTHING.baseAddress();
 
     /**
      * Obtain a new memory address instance from given long address. The returned address is backed by a memory segment
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -186,11 +186,11 @@
     MemorySegment withAccessModes(int accessModes);
 
     /**
      * Does this segment support a given set of access modes?
      * @param accessModes an ORed mask of zero or more access modes.
-     * @return true, if the access modes in {@accessModes} are stricter than the ones supported by this segment.
+     * @return true, if the access modes in {@code accessModes} are stricter than the ones supported by this segment.
      */
     boolean hasAccessModes(int accessModes);
 
     /**
      * Returns the <a href="#access-modes">access modes</a> associated with this segment; the result is represented as ORed values from
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
@@ -198,8 +198,10 @@
         POINTER;
     }
 
     /**
      * Returns memory layout for the given native type if supported by the platform ABI.
+     * @param type the native type for which the layout is to be retrieved.
+     * @return the layout (if any) associated with {@code type}
      */
     public Optional<MemoryLayout> layoutFor(Type type);
 }

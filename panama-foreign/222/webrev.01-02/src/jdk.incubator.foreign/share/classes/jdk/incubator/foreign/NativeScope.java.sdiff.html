<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.incubator.foreign;
 28 
 29 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 30 import jdk.internal.foreign.AbstractNativeScope;

 31 import jdk.internal.misc.Unsafe;
 32 
 33 import java.lang.invoke.VarHandle;

 34 import java.nio.ByteOrder;
 35 import java.util.OptionalLong;

 36 
 37 /**
 38  * This class provides a scope of given size, within which several allocations can be performed. An native scope is backed
 39  * by off-heap memory. Native scopes can be either &lt;em&gt;bounded&lt;/em&gt; or &lt;em&gt;unbounded&lt;/em&gt;, depending on whether the size
 40  * of the native scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,
 41  * using a &lt;em&gt;bounded&lt;/em&gt; native scope will typically provide better performances than independently allocating the memory
 42  * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an &lt;em&gt;unbounded&lt;/em&gt; native scope.
 43  * For this reason, using a bounded native scope is recommended in cases where programs might need to emulate native stack allocation.
 44  * &lt;p&gt;
 45  * Allocation scopes are thread-confined (see {@link #ownerThread()}; as such, the resulting {@code MemoryAddress} instances
 46  * returned by the native scope will be backed by memory segments confined by the same owner thread as the native scope.
 47  * &lt;p&gt;
 48  * To allow for more usability, it is possible for an native scope to reclaim ownership of an existing memory segments
 49  * (see {@link #register(MemorySegment)}). This might be useful to allow one or more segments which were independently
 50  * created to share the same life-cycle as a given native scope - which in turns enables client to group all memory
 51  * allocation and usage under a single &lt;em&gt;try-with-resources block&lt;/em&gt;.
 52  */
 53 public abstract class NativeScope implements AutoCloseable {
 54 
 55     /**
</pre>
<hr />
<pre>
173      */
174     public MemoryAddress allocate(MemoryLayout layout, double value) {
175         VarHandle handle = layout.varHandle(double.class);
176         MemoryAddress addr = allocate(layout);
177         handle.set(addr, value);
178         return addr;
179     }
180 
181     /**
182      * Allocate a block of memory in this native scope with given layout and initialize it with given byte array.
183      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
184      * address must conform to the layout alignment constraints.
185      * @param elementLayout the element layout of the array to be allocated.
186      * @param array the array to be copied on the newly allocated memory block.
187      * @return an address which points to the newly allocated memory block.
188      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
189      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
190      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.
191      */
192     public MemoryAddress allocateArray(ValueLayout elementLayout, byte[] array) {
<span class="line-modified">193         if (elementLayout.byteSize() != 1) {</span>
<span class="line-removed">194             throw new IllegalArgumentException(&quot;Bad layout size&quot;);</span>
<span class="line-removed">195         }</span>
<span class="line-removed">196         MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));</span>
<span class="line-removed">197         addr.segment().copyFrom(MemorySegment.ofArray(array));</span>
<span class="line-removed">198         return addr;</span>
199     }
200 
201     /**
202      * Allocate a block of memory in this native scope with given layout and initialize it with given short array.
203      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
204      * address must conform to the layout alignment constraints.
205      * @param elementLayout the element layout of the array to be allocated.
206      * @param array the array to be copied on the newly allocated memory block.
207      * @return an address which points to the newly allocated memory block.
208      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
209      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
210      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.
211      */
212     public MemoryAddress allocateArray(ValueLayout elementLayout, short[] array) {
<span class="line-modified">213         if (elementLayout.byteSize() != 2) {</span>
<span class="line-removed">214             throw new IllegalArgumentException(&quot;Bad layout size&quot;);</span>
<span class="line-removed">215         }</span>
<span class="line-removed">216         MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));</span>
<span class="line-removed">217         if (elementLayout.order() == ByteOrder.nativeOrder()) {</span>
<span class="line-removed">218             addr.segment().copyFrom(MemorySegment.ofArray(array));</span>
<span class="line-removed">219         } else {</span>
<span class="line-removed">220             ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());</span>
<span class="line-removed">221         }</span>
<span class="line-removed">222         return addr;</span>
223     }
224 
225     /**
226      * Allocate a block of memory in this native scope with given layout and initialize it with given char array.
227      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
228      * address must conform to the layout alignment constraints.
229      * @param elementLayout the element layout of the array to be allocated.
230      * @param array the array to be copied on the newly allocated memory block.
231      * @return an address which points to the newly allocated memory block.
232      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
233      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
234      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.
235      */
236     public MemoryAddress allocateArray(ValueLayout elementLayout, char[] array) {
<span class="line-modified">237         if (elementLayout.byteSize() != 2) {</span>
<span class="line-removed">238             throw new IllegalArgumentException(&quot;Bad layout size&quot;);</span>
<span class="line-removed">239         }</span>
<span class="line-removed">240         MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));</span>
<span class="line-removed">241         if (elementLayout.order() == ByteOrder.nativeOrder()) {</span>
<span class="line-removed">242             addr.segment().copyFrom(MemorySegment.ofArray(array));</span>
<span class="line-removed">243         } else {</span>
<span class="line-removed">244             ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());</span>
<span class="line-removed">245         }</span>
<span class="line-removed">246         return addr;</span>
247     }
248 
249     /**
250      * Allocate a block of memory in this native scope with given layout and initialize it with given int array.
251      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
252      * address must conform to the layout alignment constraints.
253      * @param elementLayout the element layout of the array to be allocated.
254      * @param array the array to be copied on the newly allocated memory block.
255      * @return an address which points to the newly allocated memory block.
256      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
257      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
258      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.
259      */
260     public MemoryAddress allocateArray(ValueLayout elementLayout, int[] array) {
<span class="line-modified">261         if (elementLayout.byteSize() != 4) {</span>
<span class="line-removed">262             throw new IllegalArgumentException(&quot;Bad layout size&quot;);</span>
<span class="line-removed">263         }</span>
<span class="line-removed">264         MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));</span>
<span class="line-removed">265         if (elementLayout.order() == ByteOrder.nativeOrder()) {</span>
<span class="line-removed">266             addr.segment().copyFrom(MemorySegment.ofArray(array));</span>
<span class="line-removed">267         } else {</span>
<span class="line-removed">268             ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());</span>
<span class="line-removed">269         }</span>
<span class="line-removed">270         return addr;</span>
271     }
272 
273     /**
274      * Allocate a block of memory in this native scope with given layout and initialize it with given float array.
275      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
276      * address must conform to the layout alignment constraints.
277      * @param elementLayout the element layout of the array to be allocated.
278      * @param array the array to be copied on the newly allocated memory block.
279      * @return an address which points to the newly allocated memory block.
280      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
281      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
282      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.
283      */
284     public MemoryAddress allocateArray(ValueLayout elementLayout, float[] array) {
<span class="line-modified">285         if (elementLayout.byteSize() != 4) {</span>
<span class="line-removed">286             throw new IllegalArgumentException(&quot;Bad layout size&quot;);</span>
<span class="line-removed">287         }</span>
<span class="line-removed">288         MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));</span>
<span class="line-removed">289         if (elementLayout.order() == ByteOrder.nativeOrder()) {</span>
<span class="line-removed">290             addr.segment().copyFrom(MemorySegment.ofArray(array));</span>
<span class="line-removed">291         } else {</span>
<span class="line-removed">292             ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());</span>
<span class="line-removed">293         }</span>
<span class="line-removed">294         return addr;</span>
295     }
296 
297     /**
298      * Allocate a block of memory in this native scope with given layout and initialize it with given long array.
299      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
300      * address must conform to the layout alignment constraints.
301      * @param elementLayout the element layout of the array to be allocated.
302      * @param array the array to be copied on the newly allocated memory block.
303      * @return an address which points to the newly allocated memory block.
304      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
305      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
306      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.
307      */
308     public MemoryAddress allocateArray(ValueLayout elementLayout, long[] array) {
<span class="line-modified">309         if (elementLayout.byteSize() != 8) {</span>
<span class="line-removed">310             throw new IllegalArgumentException(&quot;Bad layout size&quot;);</span>
<span class="line-removed">311         }</span>
<span class="line-removed">312         MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));</span>
<span class="line-removed">313         if (elementLayout.order() == ByteOrder.nativeOrder()) {</span>
<span class="line-removed">314             addr.segment().copyFrom(MemorySegment.ofArray(array));</span>
<span class="line-removed">315         } else {</span>
<span class="line-removed">316             ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());</span>
<span class="line-removed">317         }</span>
<span class="line-removed">318         return addr;</span>
319     }
320 
321     /**
322      * Allocate a block of memory in this native scope with given layout and initialize it with given double array.
323      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
324      * address must conform to the layout alignment constraints.
325      * @param elementLayout the element layout of the array to be allocated.
326      * @param array the array to be copied on the newly allocated memory block.
327      * @return an address which points to the newly allocated memory block.
328      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
329      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
330      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.
331      */
332     public MemoryAddress allocateArray(ValueLayout elementLayout, double[] array) {
<span class="line-modified">333         if (elementLayout.byteSize() != 8) {</span>
<span class="line-modified">334             throw new IllegalArgumentException(&quot;Bad layout size&quot;);</span>
<span class="line-modified">335         }</span>
<span class="line-modified">336         MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));</span>
<span class="line-modified">337         if (elementLayout.order() == ByteOrder.nativeOrder()) {</span>
<span class="line-modified">338             addr.segment().copyFrom(MemorySegment.ofArray(array));</span>



339         } else {
<span class="line-modified">340             ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());</span>
341         }
342         return addr;
343     }
344 
345     /**
346      * Allocate a block of memory in this native scope with given layout. The address returned by this method is
347      * associated with a segment which cannot be closed. Moreover, the returned address must conform to the layout alignment constraints.
348      * @param layout the layout of the block of memory to be allocated.
349      * @return an address which points to the newly allocated memory block.
350      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
351      * {@code limit() - size() &lt; layout.byteSize()}.
352      */
353     public MemoryAddress allocate(MemoryLayout layout) {
354         return allocate(layout.byteSize(), layout.byteAlignment());
355     }
356 
357     /**
358      * Allocate a block of memory corresponding to an array with given element layout and size.
359      * The address returned by this method is associated with a segment which cannot be closed.
360      * Moreover, the returned address must conform to the layout alignment constraints. This is equivalent to the
</pre>
</td>
<td>
<hr />
<pre>
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 
 27 package jdk.incubator.foreign;
 28 
 29 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 30 import jdk.internal.foreign.AbstractNativeScope;
<span class="line-added"> 31 import jdk.internal.foreign.Utils;</span>
 32 import jdk.internal.misc.Unsafe;
 33 
 34 import java.lang.invoke.VarHandle;
<span class="line-added"> 35 import java.lang.reflect.Array;</span>
 36 import java.nio.ByteOrder;
 37 import java.util.OptionalLong;
<span class="line-added"> 38 import java.util.function.Function;</span>
 39 
 40 /**
 41  * This class provides a scope of given size, within which several allocations can be performed. An native scope is backed
 42  * by off-heap memory. Native scopes can be either &lt;em&gt;bounded&lt;/em&gt; or &lt;em&gt;unbounded&lt;/em&gt;, depending on whether the size
 43  * of the native scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,
 44  * using a &lt;em&gt;bounded&lt;/em&gt; native scope will typically provide better performances than independently allocating the memory
 45  * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an &lt;em&gt;unbounded&lt;/em&gt; native scope.
 46  * For this reason, using a bounded native scope is recommended in cases where programs might need to emulate native stack allocation.
 47  * &lt;p&gt;
 48  * Allocation scopes are thread-confined (see {@link #ownerThread()}; as such, the resulting {@code MemoryAddress} instances
 49  * returned by the native scope will be backed by memory segments confined by the same owner thread as the native scope.
 50  * &lt;p&gt;
 51  * To allow for more usability, it is possible for an native scope to reclaim ownership of an existing memory segments
 52  * (see {@link #register(MemorySegment)}). This might be useful to allow one or more segments which were independently
 53  * created to share the same life-cycle as a given native scope - which in turns enables client to group all memory
 54  * allocation and usage under a single &lt;em&gt;try-with-resources block&lt;/em&gt;.
 55  */
 56 public abstract class NativeScope implements AutoCloseable {
 57 
 58     /**
</pre>
<hr />
<pre>
176      */
177     public MemoryAddress allocate(MemoryLayout layout, double value) {
178         VarHandle handle = layout.varHandle(double.class);
179         MemoryAddress addr = allocate(layout);
180         handle.set(addr, value);
181         return addr;
182     }
183 
184     /**
185      * Allocate a block of memory in this native scope with given layout and initialize it with given byte array.
186      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
187      * address must conform to the layout alignment constraints.
188      * @param elementLayout the element layout of the array to be allocated.
189      * @param array the array to be copied on the newly allocated memory block.
190      * @return an address which points to the newly allocated memory block.
191      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
192      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
193      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.
194      */
195     public MemoryAddress allocateArray(ValueLayout elementLayout, byte[] array) {
<span class="line-modified">196         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);</span>





197     }
198 
199     /**
200      * Allocate a block of memory in this native scope with given layout and initialize it with given short array.
201      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
202      * address must conform to the layout alignment constraints.
203      * @param elementLayout the element layout of the array to be allocated.
204      * @param array the array to be copied on the newly allocated memory block.
205      * @return an address which points to the newly allocated memory block.
206      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
207      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
208      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.
209      */
210     public MemoryAddress allocateArray(ValueLayout elementLayout, short[] array) {
<span class="line-modified">211         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);</span>









212     }
213 
214     /**
215      * Allocate a block of memory in this native scope with given layout and initialize it with given char array.
216      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
217      * address must conform to the layout alignment constraints.
218      * @param elementLayout the element layout of the array to be allocated.
219      * @param array the array to be copied on the newly allocated memory block.
220      * @return an address which points to the newly allocated memory block.
221      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
222      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
223      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.
224      */
225     public MemoryAddress allocateArray(ValueLayout elementLayout, char[] array) {
<span class="line-modified">226         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);</span>









227     }
228 
229     /**
230      * Allocate a block of memory in this native scope with given layout and initialize it with given int array.
231      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
232      * address must conform to the layout alignment constraints.
233      * @param elementLayout the element layout of the array to be allocated.
234      * @param array the array to be copied on the newly allocated memory block.
235      * @return an address which points to the newly allocated memory block.
236      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
237      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
238      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.
239      */
240     public MemoryAddress allocateArray(ValueLayout elementLayout, int[] array) {
<span class="line-modified">241         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);</span>









242     }
243 
244     /**
245      * Allocate a block of memory in this native scope with given layout and initialize it with given float array.
246      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
247      * address must conform to the layout alignment constraints.
248      * @param elementLayout the element layout of the array to be allocated.
249      * @param array the array to be copied on the newly allocated memory block.
250      * @return an address which points to the newly allocated memory block.
251      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
252      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
253      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.
254      */
255     public MemoryAddress allocateArray(ValueLayout elementLayout, float[] array) {
<span class="line-modified">256         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);</span>









257     }
258 
259     /**
260      * Allocate a block of memory in this native scope with given layout and initialize it with given long array.
261      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
262      * address must conform to the layout alignment constraints.
263      * @param elementLayout the element layout of the array to be allocated.
264      * @param array the array to be copied on the newly allocated memory block.
265      * @return an address which points to the newly allocated memory block.
266      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
267      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
268      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.
269      */
270     public MemoryAddress allocateArray(ValueLayout elementLayout, long[] array) {
<span class="line-modified">271         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);</span>









272     }
273 
274     /**
275      * Allocate a block of memory in this native scope with given layout and initialize it with given double array.
276      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
277      * address must conform to the layout alignment constraints.
278      * @param elementLayout the element layout of the array to be allocated.
279      * @param array the array to be copied on the newly allocated memory block.
280      * @return an address which points to the newly allocated memory block.
281      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
282      * {@code limit() - size() &lt; (elementLayout.byteSize() * array.length)}.
283      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.
284      */
285     public MemoryAddress allocateArray(ValueLayout elementLayout, double[] array) {
<span class="line-modified">286         return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);</span>
<span class="line-modified">287     }</span>
<span class="line-modified">288 </span>
<span class="line-modified">289     private &lt;Z&gt; MemoryAddress copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,</span>
<span class="line-modified">290                                                         Function&lt;Z, MemorySegment&gt; heapSegmentFactory) {</span>
<span class="line-modified">291         Utils.checkPrimitiveCarrierCompat(array.getClass().componentType(), elementLayout);</span>
<span class="line-added">292         MemoryAddress addr = allocate(MemoryLayout.ofSequence(Array.getLength(array), elementLayout));</span>
<span class="line-added">293         if (elementLayout.byteSize() == 1 || (elementLayout.order() == ByteOrder.nativeOrder())) {</span>
<span class="line-added">294             addr.segment().copyFrom(heapSegmentFactory.apply(array));</span>
295         } else {
<span class="line-modified">296             ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());</span>
297         }
298         return addr;
299     }
300 
301     /**
302      * Allocate a block of memory in this native scope with given layout. The address returned by this method is
303      * associated with a segment which cannot be closed. Moreover, the returned address must conform to the layout alignment constraints.
304      * @param layout the layout of the block of memory to be allocated.
305      * @return an address which points to the newly allocated memory block.
306      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
307      * {@code limit() - size() &lt; layout.byteSize()}.
308      */
309     public MemoryAddress allocate(MemoryLayout layout) {
310         return allocate(layout.byteSize(), layout.byteAlignment());
311     }
312 
313     /**
314      * Allocate a block of memory corresponding to an array with given element layout and size.
315      * The address returned by this method is associated with a segment which cannot be closed.
316      * Moreover, the returned address must conform to the layout alignment constraints. This is equivalent to the
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
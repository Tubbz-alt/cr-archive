<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 import java.util.OptionalLong;
 36 
 37 /**
 38  * This class provides a scope of given size, within which several allocations can be performed. An native scope is backed
 39  * by off-heap memory. Native scopes can be either &lt;em&gt;bounded&lt;/em&gt; or &lt;em&gt;unbounded&lt;/em&gt;, depending on whether the size
 40  * of the native scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,
 41  * using a &lt;em&gt;bounded&lt;/em&gt; native scope will typically provide better performances than independently allocating the memory
 42  * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an &lt;em&gt;unbounded&lt;/em&gt; native scope.
 43  * For this reason, using a bounded native scope is recommended in cases where programs might need to emulate native stack allocation.
 44  * &lt;p&gt;
 45  * Allocation scopes are thread-confined (see {@link #ownerThread()}; as such, the resulting {@code MemoryAddress} instances
 46  * returned by the native scope will be backed by memory segments confined by the same owner thread as the native scope.
 47  * &lt;p&gt;
 48  * To allow for more usability, it is possible for an native scope to reclaim ownership of an existing memory segments
 49  * (see {@link #register(MemorySegment)}). This might be useful to allow one or more segments which were independently
 50  * created to share the same life-cycle as a given native scope - which in turns enables client to group all memory
 51  * allocation and usage under a single &lt;em&gt;try-with-resources block&lt;/em&gt;.
 52  */
 53 public abstract class NativeScope implements AutoCloseable {
 54 
<span class="line-removed"> 55     Unsafe unsafe = Unsafe.getUnsafe();</span>
<span class="line-removed"> 56 </span>
 57     /**
 58      * If this native scope is bounded, returns the size, in bytes, of this native scope.
 59      * @return the size, in bytes, of this native scope (if available).
 60      */
 61     public abstract OptionalLong byteSize();
 62 
 63     /**
 64      * The thread owning this native scope.
 65      * @return the thread owning this native scope.
 66      */
 67     public abstract Thread ownerThread();
 68 
 69     /**
 70      * Returns the number of allocated bytes in this native scope.
 71      * @return the number of allocated bytes in this native scope.
 72      */
 73     public abstract long allocatedBytes();
 74 
 75     /**
 76      * Allocate a block of memory in this native scope with given layout and initialize it with given byte value.
</pre>
<hr />
<pre>
339         if (elementLayout.order() == ByteOrder.nativeOrder()) {
340             addr.segment().copyFrom(MemorySegment.ofArray(array));
341         } else {
342             ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());
343         }
344         return addr;
345     }
346 
347     /**
348      * Allocate a block of memory in this native scope with given layout. The address returned by this method is
349      * associated with a segment which cannot be closed. Moreover, the returned address must conform to the layout alignment constraints.
350      * @param layout the layout of the block of memory to be allocated.
351      * @return an address which points to the newly allocated memory block.
352      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
353      * {@code limit() - size() &lt; layout.byteSize()}.
354      */
355     public MemoryAddress allocate(MemoryLayout layout) {
356         return allocate(layout.byteSize(), layout.byteAlignment());
357     }
358 



















359     /**
360      * Allocate a block of memory in this native scope with given size. The address returned by this method is
361      * associated with a segment which cannot be closed. Moreover, the returned address must be aligned to {@code size}.
362      * @param bytesSize the size (in bytes) of the block of memory to be allocated.
363      * @return an address which points to the newly allocated memory block.
364      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
365      * {@code limit() - size() &lt; bytesSize}.
366      */
367     public MemoryAddress allocate(long bytesSize) {
368         return allocate(bytesSize, bytesSize);
369     }
370 
371     /**
372      * Allocate a block of memory in this native scope with given size and alignment constraint.
373      * The address returned by this method is associated with a segment which cannot be closed. Moreover,
374      * the returned address must be aligned to {@code alignment}.
375      * @param bytesSize the size (in bytes) of the block of memory to be allocated.
376      * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.
377      * @return an address which points to the newly allocated memory block.
378      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
</pre>
</td>
<td>
<hr />
<pre>
 35 import java.util.OptionalLong;
 36 
 37 /**
 38  * This class provides a scope of given size, within which several allocations can be performed. An native scope is backed
 39  * by off-heap memory. Native scopes can be either &lt;em&gt;bounded&lt;/em&gt; or &lt;em&gt;unbounded&lt;/em&gt;, depending on whether the size
 40  * of the native scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,
 41  * using a &lt;em&gt;bounded&lt;/em&gt; native scope will typically provide better performances than independently allocating the memory
 42  * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an &lt;em&gt;unbounded&lt;/em&gt; native scope.
 43  * For this reason, using a bounded native scope is recommended in cases where programs might need to emulate native stack allocation.
 44  * &lt;p&gt;
 45  * Allocation scopes are thread-confined (see {@link #ownerThread()}; as such, the resulting {@code MemoryAddress} instances
 46  * returned by the native scope will be backed by memory segments confined by the same owner thread as the native scope.
 47  * &lt;p&gt;
 48  * To allow for more usability, it is possible for an native scope to reclaim ownership of an existing memory segments
 49  * (see {@link #register(MemorySegment)}). This might be useful to allow one or more segments which were independently
 50  * created to share the same life-cycle as a given native scope - which in turns enables client to group all memory
 51  * allocation and usage under a single &lt;em&gt;try-with-resources block&lt;/em&gt;.
 52  */
 53 public abstract class NativeScope implements AutoCloseable {
 54 


 55     /**
 56      * If this native scope is bounded, returns the size, in bytes, of this native scope.
 57      * @return the size, in bytes, of this native scope (if available).
 58      */
 59     public abstract OptionalLong byteSize();
 60 
 61     /**
 62      * The thread owning this native scope.
 63      * @return the thread owning this native scope.
 64      */
 65     public abstract Thread ownerThread();
 66 
 67     /**
 68      * Returns the number of allocated bytes in this native scope.
 69      * @return the number of allocated bytes in this native scope.
 70      */
 71     public abstract long allocatedBytes();
 72 
 73     /**
 74      * Allocate a block of memory in this native scope with given layout and initialize it with given byte value.
</pre>
<hr />
<pre>
337         if (elementLayout.order() == ByteOrder.nativeOrder()) {
338             addr.segment().copyFrom(MemorySegment.ofArray(array));
339         } else {
340             ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());
341         }
342         return addr;
343     }
344 
345     /**
346      * Allocate a block of memory in this native scope with given layout. The address returned by this method is
347      * associated with a segment which cannot be closed. Moreover, the returned address must conform to the layout alignment constraints.
348      * @param layout the layout of the block of memory to be allocated.
349      * @return an address which points to the newly allocated memory block.
350      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
351      * {@code limit() - size() &lt; layout.byteSize()}.
352      */
353     public MemoryAddress allocate(MemoryLayout layout) {
354         return allocate(layout.byteSize(), layout.byteAlignment());
355     }
356 
<span class="line-added">357     /**</span>
<span class="line-added">358      * Allocate a block of memory corresponding to an array with given element layout and size.</span>
<span class="line-added">359      * The address returned by this method is associated with a segment which cannot be closed.</span>
<span class="line-added">360      * Moreover, the returned address must conform to the layout alignment constraints. This is equivalent to the</span>
<span class="line-added">361      * following code:</span>
<span class="line-added">362      * &lt;pre&gt;{@code</span>
<span class="line-added">363     allocate(MemoryLayout.ofSequence(size, elementLayout));</span>
<span class="line-added">364      * }&lt;/pre&gt;</span>
<span class="line-added">365      * @param elementLayout the array element layout.</span>
<span class="line-added">366      * @param size the array size.</span>
<span class="line-added">367      * @return an address which points to the newly allocated memory block.</span>
<span class="line-added">368      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if</span>
<span class="line-added">369      * {@code limit() - size() &lt; (elementLayout.byteSize() * size)}.</span>
<span class="line-added">370      * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.</span>
<span class="line-added">371      */</span>
<span class="line-added">372     public MemoryAddress allocateArray(MemoryLayout elementLayout, long size) {</span>
<span class="line-added">373         return allocate(MemoryLayout.ofSequence(size, elementLayout));</span>
<span class="line-added">374     }</span>
<span class="line-added">375 </span>
376     /**
377      * Allocate a block of memory in this native scope with given size. The address returned by this method is
378      * associated with a segment which cannot be closed. Moreover, the returned address must be aligned to {@code size}.
379      * @param bytesSize the size (in bytes) of the block of memory to be allocated.
380      * @return an address which points to the newly allocated memory block.
381      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
382      * {@code limit() - size() &lt; bytesSize}.
383      */
384     public MemoryAddress allocate(long bytesSize) {
385         return allocate(bytesSize, bytesSize);
386     }
387 
388     /**
389      * Allocate a block of memory in this native scope with given size and alignment constraint.
390      * The address returned by this method is associated with a segment which cannot be closed. Moreover,
391      * the returned address must be aligned to {@code alignment}.
392      * @param bytesSize the size (in bytes) of the block of memory to be allocated.
393      * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.
394      * @return an address which points to the newly allocated memory block.
395      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
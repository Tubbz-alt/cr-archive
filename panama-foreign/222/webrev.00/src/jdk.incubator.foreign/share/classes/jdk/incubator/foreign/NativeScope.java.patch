diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/NativeScope.java
@@ -24,13 +24,16 @@
  *
  */
 
 package jdk.incubator.foreign;
 
+import jdk.internal.foreign.AbstractMemorySegmentImpl;
 import jdk.internal.foreign.AbstractNativeScope;
+import jdk.internal.misc.Unsafe;
 
 import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
 import java.util.OptionalLong;
 
 /**
  * This class provides a scope of given size, within which several allocations can be performed. An native scope is backed
  * by off-heap memory. Native scopes can be either <em>bounded</em> or <em>unbounded</em>, depending on whether the size
@@ -47,10 +50,12 @@
  * created to share the same life-cycle as a given native scope - which in turns enables client to group all memory
  * allocation and usage under a single <em>try-with-resources block</em>.
  */
 public abstract class NativeScope implements AutoCloseable {
 
+    Unsafe unsafe = Unsafe.getUnsafe();
+
     /**
      * If this native scope is bounded, returns the size, in bytes, of this native scope.
      * @return the size, in bytes, of this native scope (if available).
      */
     public abstract OptionalLong byteSize();
@@ -174,35 +179,171 @@
         handle.set(addr, value);
         return addr;
     }
 
     /**
-     * Allocate a block of memory in this native scope with given layout and initialize it with given address value.
+     * Allocate a block of memory in this native scope with given layout and initialize it with given byte array.
      * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
      * address must conform to the layout alignment constraints.
-     * @param layout the layout of the block of memory to be allocated.
-     * @param value the value to be set on the newly allocated memory block.
+     * @param elementLayout the element layout of the array to be allocated.
+     * @param array the array to be copied on the newly allocated memory block.
      * @return an address which points to the newly allocated memory block.
      * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
-     * {@code limit() - size() < layout.byteSize()}.
-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of an address value.
+     * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.
      */
-    public MemoryAddress allocate(MemoryLayout layout, MemoryAddress value) {
-        VarHandle handle = MemoryHandles.asAddressVarHandle(layout.varHandle(carrierForSize(layout.byteSize())));
-        MemoryAddress addr = allocate(layout);
-        handle.set(addr, value);
+    public MemoryAddress allocateArray(ValueLayout elementLayout, byte[] array) {
+        if (elementLayout.byteSize() != 1) {
+            throw new IllegalArgumentException("Bad layout size");
+        }
+        MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));
+        addr.segment().copyFrom(MemorySegment.ofArray(array));
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this native scope with given layout and initialize it with given short array.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param elementLayout the element layout of the array to be allocated.
+     * @param array the array to be copied on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
+     * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.
+     */
+    public MemoryAddress allocateArray(ValueLayout elementLayout, short[] array) {
+        if (elementLayout.byteSize() != 2) {
+            throw new IllegalArgumentException("Bad layout size");
+        }
+        MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));
+        if (elementLayout.order() == ByteOrder.nativeOrder()) {
+            addr.segment().copyFrom(MemorySegment.ofArray(array));
+        } else {
+            ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());
+        }
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this native scope with given layout and initialize it with given char array.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param elementLayout the element layout of the array to be allocated.
+     * @param array the array to be copied on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
+     * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.
+     */
+    public MemoryAddress allocateArray(ValueLayout elementLayout, char[] array) {
+        if (elementLayout.byteSize() != 2) {
+            throw new IllegalArgumentException("Bad layout size");
+        }
+        MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));
+        if (elementLayout.order() == ByteOrder.nativeOrder()) {
+            addr.segment().copyFrom(MemorySegment.ofArray(array));
+        } else {
+            ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());
+        }
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this native scope with given layout and initialize it with given int array.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param elementLayout the element layout of the array to be allocated.
+     * @param array the array to be copied on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
+     * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.
+     */
+    public MemoryAddress allocateArray(ValueLayout elementLayout, int[] array) {
+        if (elementLayout.byteSize() != 4) {
+            throw new IllegalArgumentException("Bad layout size");
+        }
+        MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));
+        if (elementLayout.order() == ByteOrder.nativeOrder()) {
+            addr.segment().copyFrom(MemorySegment.ofArray(array));
+        } else {
+            ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());
+        }
         return addr;
     }
 
-    private static Class<?> carrierForSize(long size) {
-        return switch ((int)size) {
-            case 1 -> byte.class;
-            case 2 -> short.class;
-            case 4 -> int.class;
-            case 8 -> long.class;
-            default -> throw new IllegalArgumentException("Bad layout size: " + size);
-        };
+    /**
+     * Allocate a block of memory in this native scope with given layout and initialize it with given float array.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param elementLayout the element layout of the array to be allocated.
+     * @param array the array to be copied on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
+     * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.
+     */
+    public MemoryAddress allocateArray(ValueLayout elementLayout, float[] array) {
+        if (elementLayout.byteSize() != 4) {
+            throw new IllegalArgumentException("Bad layout size");
+        }
+        MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));
+        if (elementLayout.order() == ByteOrder.nativeOrder()) {
+            addr.segment().copyFrom(MemorySegment.ofArray(array));
+        } else {
+            ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());
+        }
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this native scope with given layout and initialize it with given long array.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param elementLayout the element layout of the array to be allocated.
+     * @param array the array to be copied on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
+     * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.
+     */
+    public MemoryAddress allocateArray(ValueLayout elementLayout, long[] array) {
+        if (elementLayout.byteSize() != 8) {
+            throw new IllegalArgumentException("Bad layout size");
+        }
+        MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));
+        if (elementLayout.order() == ByteOrder.nativeOrder()) {
+            addr.segment().copyFrom(MemorySegment.ofArray(array));
+        } else {
+            ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());
+        }
+        return addr;
+    }
+
+    /**
+     * Allocate a block of memory in this native scope with given layout and initialize it with given double array.
+     * The address returned by this method is associated with a segment which cannot be closed. Moreover, the returned
+     * address must conform to the layout alignment constraints.
+     * @param elementLayout the element layout of the array to be allocated.
+     * @param array the array to be copied on the newly allocated memory block.
+     * @return an address which points to the newly allocated memory block.
+     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if
+     * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.
+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.
+     */
+    public MemoryAddress allocateArray(ValueLayout elementLayout, double[] array) {
+        if (elementLayout.byteSize() != 8) {
+            throw new IllegalArgumentException("Bad layout size");
+        }
+        MemoryAddress addr = allocate(MemoryLayout.ofSequence(array.length, elementLayout));
+        if (elementLayout.order() == ByteOrder.nativeOrder()) {
+            addr.segment().copyFrom(MemorySegment.ofArray(array));
+        } else {
+            ((AbstractMemorySegmentImpl)addr.segment()).copyFromSwap(MemorySegment.ofArray(array), elementLayout.byteSize());
+        }
+        return addr;
     }
 
     /**
      * Allocate a block of memory in this native scope with given layout. The address returned by this method is
      * associated with a segment which cannot be closed. Moreover, the returned address must conform to the layout alignment constraints.

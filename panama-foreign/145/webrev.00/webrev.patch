diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HeaderBuilder.java
@@ -108,17 +108,16 @@
         indent();
         sb.append("}\n");
         decrAlign();
     }
 
-    public void emitPrimitiveTypedef(Type.Primitive primType, String name) {
+    public void emitPrimitiveTypedef(Type.Primitive primType, String className) {
         Type.Primitive.Kind kind = primType.kind();
         if (primitiveKindSupported(kind)) {
             incrAlign();
             indent();
             sb.append(PUB_MODS);
-            String className = "C" + name;
             sb.append("class ");
             sb.append(className);
             sb.append(" extends ");
             sb.append("C" + kind.typeName().replace(" ", "_"));
             sb.append(" {\n");
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/OutputFactory.java
@@ -68,14 +68,23 @@
     protected final TypeTranslator typeTranslator = new TypeTranslator();
     private final String clsName;
     private final String pkgName;
     private StructBuilder structBuilder;
     private List<String> structSources = new ArrayList<>();
-    private Set<String> structClassNames = new HashSet<>();
-    private int structClassNameCount = 0;
-    private String uniqueStructClassName(String name) {
-        return structClassNames.add(name.toLowerCase())? name : (name + "$" + structClassNameCount++);
+    private Set<String> nestedClassNames = new HashSet<>();
+    private int nestedClassNameCount = 0;
+    /*
+     * We may have case-insensitive name collision! A C program may have
+     * defined structs/unions/typedefs with the names FooS, fooS, FoOs, fOOs.
+     * Because we map structs/unions/typedefs to nested classes of header classes,
+     * such a case-insensitive name collision is problematic. This is because in
+     * a case-insensitive file system javac will overwrite classes for
+     * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by
+     * generating unique case-insensitive names for nested classes.
+     */
+    private String uniqueNestedClassName(String name) {
+        return nestedClassNames.add(name.toLowerCase())? name : (name + "$" + nestedClassNameCount++);
     }
 
     // have we seen this Variable earlier?
     protected boolean variableSeen(Declaration.Variable tree) {
         return !variables.add(tree);
@@ -237,20 +246,11 @@
             //only add explicit struct layout if the struct is not to be flattened inside another struct
             switch (d.kind()) {
                 case STRUCT:
                 case UNION: {
                     structClass = true;
-                    /*
-                     * We may have case-insensitive name collision! A C program may have
-                     * defined structs with the names FooS, fooS, FoOs, fOOs. Because we
-                     * map structs and unions to nested classes of header classes, such
-                     * a case-insensitive name collision is problematic. This is because in
-                     * a case-insensitive file system javac will overwrite classes for
-                     * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by
-                     * generating unique case-insensitive names for classes.
-                     */
-                    String structClassName = uniqueStructClassName("C" + name);
+                    String structClassName = uniqueNestedClassName("C" + name);
                     this.structBuilder = new StructBuilder(structClassName, pkgName, constantHelper);
                     structBuilder.incrAlign();
                     structBuilder.classBegin();
                     structBuilder.addLayoutGetter(structClassName, d.layout().get());
                     break;
@@ -326,11 +326,11 @@
             Declaration.Scoped s = ((Type.Declared) type).tree();
             if (!s.name().equals(tree.name())) {
                 return visitScoped(s, tree);
             }
         } else if (type instanceof Type.Primitive) {
-             builder.emitPrimitiveTypedef((Type.Primitive)type, tree.name());
+             builder.emitPrimitiveTypedef((Type.Primitive)type, uniqueNestedClassName("C" + tree.name()));
         }
         return null;
     }
 
     @Override
diff a/test/jdk/tools/jextract/test8244412/test8244412.h b/test/jdk/tools/jextract/test8244412/test8244412.h
--- a/test/jdk/tools/jextract/test8244412/test8244412.h
+++ b/test/jdk/tools/jextract/test8244412/test8244412.h
@@ -20,5 +20,6 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 typedef long mysize_t;
+typedef long MYSIZE_T;
diff a/test/jdk/tools/jextract/typedefs.h b/test/jdk/tools/jextract/typedefs.h
--- a/test/jdk/tools/jextract/typedefs.h
+++ b/test/jdk/tools/jextract/typedefs.h
@@ -21,5 +21,6 @@
  * questions.
  */
 
 typedef char byte_t;
 typedef long size_t;
+typedef long SIZE_T;

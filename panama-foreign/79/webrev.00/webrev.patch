diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
@@ -24,52 +24,78 @@
  *
  */
 package jdk.incubator.foreign;
 
 import java.lang.constant.ClassDesc;
+import java.lang.constant.Constable;
 import java.lang.constant.ConstantDesc;
 import java.lang.constant.ConstantDescs;
 import java.lang.constant.DirectMethodHandleDesc;
 import java.lang.constant.DynamicConstantDesc;
 import java.lang.constant.MethodHandleDesc;
 import java.lang.constant.MethodTypeDesc;
 import java.nio.ByteOrder;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalLong;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static java.lang.constant.ConstantDescs.BSM_INVOKE;
+import static java.lang.constant.ConstantDescs.CD_String;
+import static java.lang.constant.ConstantDescs.CD_long;
 
 abstract class AbstractLayout implements MemoryLayout {
+    // memory layout attribute key for layout name
+    static final String NAME = "name";
+
     private final OptionalLong size;
     final long alignment;
-    private final Optional<String> name;
+    protected final Map<String, Constable> attributes;
 
-    public AbstractLayout(OptionalLong size, long alignment, Optional<String> name) {
+    public AbstractLayout(OptionalLong size, long alignment, Map<String, Constable> attributes) {
         this.size = size;
         this.alignment = alignment;
-        this.name = name;
-    }
-
-    Optional<String> optName() {
-        return name;
+        this.attributes = Collections.unmodifiableMap(attributes);
     }
 
     @Override
     public AbstractLayout withName(String name) {
-        return dup(alignment, Optional.of(name));
+        return withAttribute(NAME, name);
     }
 
     @Override
     public final Optional<String> name() {
-        return name;
+        return attribute(NAME).map(String.class::cast);
+    }
+
+    @Override
+    public Optional<Constable> attribute(String name) {
+        return Optional.ofNullable(attributes.get(name));
     }
 
-    abstract AbstractLayout dup(long alignment, Optional<String> name);
+    @Override
+    public Stream<String> attributes() {
+        return attributes.keySet().stream();
+    }
+
+    @Override
+    public AbstractLayout withAttribute(String name, Constable value) {
+        Map<String, Constable> newAttributes = new HashMap<>(attributes);
+        newAttributes.put(name, value);
+        return dup(alignment, newAttributes);
+    }
+
+    abstract AbstractLayout dup(long alignment, Map<String, Constable> annos);
 
     @Override
     public AbstractLayout withBitAlignment(long alignmentBits) {
         checkAlignment(alignmentBits);
-        return dup(alignmentBits, name);
+        return dup(alignmentBits, attributes);
     }
 
     void checkAlignment(long alignmentBitCount) {
         if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || //alignment must be a power of two
                 (alignmentBitCount < 8)) { //alignment must be greater than 8
@@ -109,26 +135,44 @@
     private static UnsupportedOperationException badSizeException() {
         return new UnsupportedOperationException("Cannot compute size of a layout which is, or depends on a sequence layout with unspecified size");
     }
 
     String decorateLayoutString(String s) {
-        if (name.isPresent()) {
-            s = String.format("%s(%s)", s, name.get());
+        if (name().isPresent()) {
+            s = String.format("%s(%s)", s, name().get());
         }
         if (!hasNaturalAlignment()) {
             s = alignment + "%" + s;
         }
+        if (!attributes.isEmpty()) {
+            s += attributes.entrySet().stream()
+                                      .map(e -> e.getKey() + "=" + e.getValue())
+                                      .collect(Collectors.joining(",", "[", "]"));
+        }
         return s;
     }
 
+    <T> DynamicConstantDesc<T> decorateLayoutConstant(DynamicConstantDesc<T> desc) {
+        if (!hasNaturalAlignment()) {
+            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, "withBitAlignment", desc.constantType(), MH_WITH_BIT_ALIGNMENT,
+                    desc, bitAlignment());
+        }
+        for (var e : attributes.entrySet()) {
+            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, "withAttribute", desc.constantType(), MH_WITH_ATTRIBUTE,
+                    desc, e.getKey(), e.getValue().describeConstable().orElseThrow());
+        }
+
+        return desc;
+    }
+
     boolean hasNaturalAlignment() {
         return size.isPresent() && size.getAsLong() == alignment;
     }
 
     @Override
     public int hashCode() {
-        return name.hashCode() << Long.hashCode(alignment);
+        return attributes.hashCode() << Long.hashCode(alignment);
     }
 
     @Override
     public boolean equals(Object other) {
         if (this == other) {
@@ -137,47 +181,55 @@
 
         if (!(other instanceof AbstractLayout)) {
             return false;
         }
 
-        return Objects.equals(name, ((AbstractLayout)other).name) &&
-                Objects.equals(alignment, ((AbstractLayout)other).alignment);
+        return Objects.equals(attributes, ((AbstractLayout) other).attributes) &&
+                Objects.equals(alignment, ((AbstractLayout) other).alignment);
     }
 
     /*** Helper constants for implementing Layout::describeConstable ***/
 
     static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL
             = ConstantDescs.ofConstantBootstrap(ConstantDescs.CD_ConstantBootstraps, "getStaticFinal",
             ConstantDescs.CD_Object, ConstantDescs.CD_Class);
 
-    static final ClassDesc CD_LAYOUT = MemoryLayout.class.describeConstable().get();
+    static final ClassDesc CD_MEMORY_LAYOUT = MemoryLayout.class.describeConstable().get();
 
     static final ClassDesc CD_VALUE_LAYOUT = ValueLayout.class.describeConstable().get();
 
     static final ClassDesc CD_SEQUENCE_LAYOUT = SequenceLayout.class.describeConstable().get();
 
     static final ClassDesc CD_GROUP_LAYOUT = GroupLayout.class.describeConstable().get();
 
     static final ClassDesc CD_BYTEORDER = ByteOrder.class.describeConstable().get();
 
+    static final ClassDesc CD_Constable = Constable.class.describeConstable().get();
+
     static final ConstantDesc BIG_ENDIAN = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "BIG_ENDIAN", CD_BYTEORDER, CD_BYTEORDER);
 
     static final ConstantDesc LITTLE_ENDIAN = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "LITTLE_ENDIAN", CD_BYTEORDER, CD_BYTEORDER);
 
-    static final MethodHandleDesc MH_PADDING = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofPaddingBits",
-                MethodTypeDesc.of(CD_LAYOUT, ConstantDescs.CD_long));
+    static final MethodHandleDesc MH_PADDING = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofPaddingBits",
+                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_long));
+
+    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofValueBits",
+                MethodTypeDesc.of(CD_VALUE_LAYOUT, CD_long, CD_BYTEORDER));
+
+    static final MethodHandleDesc MH_SIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofSequence",
+                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, CD_long, CD_MEMORY_LAYOUT));
 
-    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofValueBits",
-                MethodTypeDesc.of(CD_VALUE_LAYOUT, ConstantDescs.CD_long, CD_BYTEORDER));
+    static final MethodHandleDesc MH_UNSIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofSequence",
+                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, CD_MEMORY_LAYOUT));
 
-    static final MethodHandleDesc MH_SIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofSequence",
-                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, ConstantDescs.CD_long, CD_LAYOUT));
+    static final MethodHandleDesc MH_STRUCT = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofStruct",
+                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));
 
-    static final MethodHandleDesc MH_UNSIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofSequence",
-                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, CD_LAYOUT));
+    static final MethodHandleDesc MH_UNION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, "ofUnion",
+                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));
 
-    static final MethodHandleDesc MH_STRUCT = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofStruct",
-                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_LAYOUT.arrayType()));
+    static final MethodHandleDesc MH_WITH_BIT_ALIGNMENT = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, "withBitAlignment",
+                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_long));
 
-    static final MethodHandleDesc MH_UNION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofUnion",
-                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_LAYOUT.arrayType()));
+    static final MethodHandleDesc MH_WITH_ATTRIBUTE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, "withAttribute",
+                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_String, CD_Constable));
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Foreign.java
@@ -0,0 +1,114 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.incubator.foreign;
+
+import jdk.internal.foreign.InternalForeign;
+import jdk.internal.foreign.MemorySegmentImpl;
+
+/**
+ * A class containing various methods relating to native interop.
+ */
+public interface Foreign {
+
+    /**
+     * Get an instance of the {@linkplain Foreign} interface.
+     * <p>
+     * Access to this method must be explicitly enabled by setting the {@code jdk.incubator.foreign.Foreign} system
+     * property. The available values are {@code deny}, {@code warn}, {@code debug}, {@code permit}.
+     * <ul>
+     * <li>
+     * If set to {@code deny} an {@linkplain IllegalAccessError} will be thrown.
+     * <li>
+     * If set to {@code warn} a warning message will be written to the standard error stream.
+     * <li>
+     * If set to {@code debug} a debug message and a stack trace will be printed to the standard output stream.
+     * <li>
+     * If set to {@code permit} no special action will be taken.
+     * <li>
+     * If set to any other value an {@linkplain IllegalAccessError} will be thrown.
+     * </ul>
+     * <p>
+     * {@code deny} is the default value.
+     *
+     * @return an instance of {@linkplain Foreign}
+     * @throws IllegalAccessError if {@code jdk.incubator.foreign.Foreign} is set to {@code deny}
+     */
+    static Foreign getInstance() throws IllegalAccessError {
+        return InternalForeign.getInstance();
+    }
+
+    /**
+     * Returns the absolute address represented by the given off-heap memory address as a {@code long}.
+     * <p>
+     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
+     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
+     * restricted methods, and use safe and supported functionalities, where possible.
+     *
+     * @param address the address to turn into a {@code long}
+     * @return the address as a {@code long}
+     * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
+     * @throws IllegalStateException if the given address is not an off-heap address
+     */
+    long asLong(MemoryAddress address) throws IllegalAccessError;
+
+    /**
+     * Returns a new native memory segment with given base address and size. The returned segment has its own temporal
+     * bounds, and can therefore be closed; closing such a segment does <em>not</em> result in any resource being
+     * deallocated.
+     * <p>
+     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
+     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
+     * restricted methods, and use safe and supported functionalities, where possible.
+     * <p>
+     * This method allows for making an otherwise in-accessible memory region accessible. However, there
+     * is no guarantee that this memory is safe to access, or that the given size for the new segment is not too large,
+     * potentially resulting in out-of-bounds accesses. The developer is trusted to make the judgement that the use of the
+     * returned memory segment is safe.
+     *
+     * @param base the desired base address
+     * @param byteSize the desired size.
+     * @return a new native memory segment with given base address and size.
+     * @throws IllegalArgumentException if {@code base} does not encapsulate a native memory address.
+     * @throws IllegalAccessError if the permission jkd.incubator.foreign.restrictedMethods is set to 'deny'
+     */
+    MemorySegment ofNativeUnchecked(MemoryAddress base, long byteSize) throws IllegalAccessError;
+
+    /**
+     * Returns a non-confined memory segment that has the same spatial and temporal bounds as the provided segment.
+     * Since the returned segment can be effectively accessed by multiple threads in an unconstrained fashion,
+     * this method should be used with care, as it might lead to JVM crashes - e.g. in the case where a thread {@code A}
+     * closes a segment while another thread {@code B} is accessing it.
+     * <p>
+     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
+     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
+     * restricted methods, and use safe and supported functionalities, where possible.
+     * @param segment the segment from which an unconfined view is to be created.
+     * @return a non-confined memory segment that has the same spatial and temporal bounds as the provided segment.
+     */
+    MemorySegment asUnconfined(MemorySegment segment);
+
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/GroupLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/GroupLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/GroupLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/GroupLayout.java
@@ -23,16 +23,18 @@
  *  questions.
  *
  */
 package jdk.incubator.foreign;
 
+import java.lang.constant.Constable;
 import java.lang.constant.ConstantDesc;
 import java.lang.constant.ConstantDescs;
 import java.lang.constant.DynamicConstantDesc;
 import java.lang.constant.MethodHandleDesc;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalLong;
 import java.util.function.LongBinaryOperator;
 import java.util.stream.Collectors;
@@ -98,15 +100,15 @@
 
     private final Kind kind;
     private final List<MemoryLayout> elements;
 
     GroupLayout(Kind kind, List<MemoryLayout> elements) {
-        this(kind, elements, kind.alignof(elements), Optional.empty());
+        this(kind, elements, kind.alignof(elements), Map.of());
     }
 
-    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Optional<String> name) {
-        super(kind.sizeof(elements), alignment, name);
+    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Map<String, Constable> attributes) {
+        super(kind.sizeof(elements), alignment, attributes);
         this.kind = kind;
         this.elements = elements;
     }
 
     /**
@@ -166,12 +168,12 @@
     public int hashCode() {
         return Objects.hash(super.hashCode(), kind, elements);
     }
 
     @Override
-    GroupLayout dup(long alignment, Optional<String> name) {
-        return new GroupLayout(kind, elements, alignment, name);
+    GroupLayout dup(long alignment, Map<String, Constable> attributes) {
+        return new GroupLayout(kind, elements, alignment, attributes);
     }
 
     @Override
     boolean hasNaturalAlignment() {
         return alignment == kind.alignof(elements);
@@ -182,13 +184,13 @@
         ConstantDesc[] constants = new ConstantDesc[1 + elements.size()];
         constants[0] = kind.mhDesc;
         for (int i = 0 ; i < elements.size() ; i++) {
             constants[i + 1] = elements.get(i).describeConstable().get();
         }
-        return Optional.of(DynamicConstantDesc.ofNamed(
+        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(
                     ConstantDescs.BSM_INVOKE, kind.name().toLowerCase(),
-                CD_GROUP_LAYOUT, constants));
+                CD_GROUP_LAYOUT, constants)));
     }
 
     //hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout
     //but that causes issues with javadoc, see JDK-8224052
 
@@ -205,6 +207,14 @@
      */
     @Override
     public GroupLayout withBitAlignment(long alignmentBits) {
         return (GroupLayout)super.withBitAlignment(alignmentBits);
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public GroupLayout withAttribute(String name, Constable value) {
+        return (GroupLayout)super.withAttribute(name, value);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -25,10 +25,11 @@
  */
 
 package jdk.incubator.foreign;
 
 import jdk.internal.foreign.MemoryAddressImpl;
+import jdk.internal.foreign.MemorySegmentImpl;
 
 /**
  * A memory address encodes an offset within a given {@link MemorySegment}. Memory addresses are typically obtained
  * using the {@link MemorySegment#baseAddress()} method; such addresses can then be adjusted as required,
  * using {@link MemoryAddress#addOffset(long)}.
@@ -70,10 +71,19 @@
      * The memory segment this address belongs to.
      * @return The memory segment this address belongs to.
      */
     MemorySegment segment();
 
+    /**
+     * Reinterpret this address as an offset into the provided segment.
+     * @param segment the segment to be rebased
+     * @return a new address pointing to the same memory location through the provided segment
+     * @throws IllegalArgumentException if the provided segment is not a valid rebase target for this address. This
+     * can happen, for instance, if an heap-based addressed is rebased to an off-heap memory segment.
+     */
+    MemoryAddress rebase(MemorySegment segment);
+
     /**
      * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified
      * object is also an address, and it refers to the same memory location as this address.
      *
      * @apiNote two addresses might be considered equal despite their associated segments differ. This
@@ -114,6 +124,16 @@
      */
     static void copy(MemoryAddress src, MemoryAddress dst, long bytes) {
         MemoryAddressImpl.copy((MemoryAddressImpl)src, (MemoryAddressImpl)dst, bytes);
     }
 
+    /**
+     * Obtain a new memory address instance from given long address. The returned address is backed by a memory segment
+     * which can be neither closed, nor dereferenced.
+     * @param value the long address.
+     * @return the new memory address instance.
+     */
+    static MemoryAddress ofLong(long value) {
+        return MemorySegmentImpl.NOTHING.baseAddress().addOffset(value);
+    }
+
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
@@ -39,10 +39,11 @@
 import java.util.Optional;
 import java.util.OptionalLong;
 import java.util.Set;
 import java.util.function.Function;
 import java.util.function.UnaryOperator;
+import java.util.stream.Stream;
 
 /**
  * A memory layout can be used to describe the contents of a memory segment in a <em>language neutral</em> fashion.
  * There are two leaves in the layout hierarchy, <em>value layouts</em>, which are used to represent values of given size and kind (see
  * {@link ValueLayout}) and <em>padding layouts</em> which are used, as the name suggests, to represent a portion of a memory
@@ -282,10 +283,34 @@
      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than than 8.
      */
     MemoryLayout withBitAlignment(long bitAlignment);
 
+    /**
+     * Returns the attribute with the given name if it exists, or an empty optional
+     *
+     * @param name the name of the attribute
+     * @return the optional attribute
+     */
+    Optional<Constable> attribute(String name);
+
+    /**
+     * Returns a new MemoryLayout with the given additional attribute
+     *
+     * @param name the name of the attribute
+     * @param value the value of the attribute
+     * @return the new MemoryLayout
+     */
+    MemoryLayout withAttribute(String name, Constable value);
+
+    /**
+     * Returns a stream of the names of the attributes of this layout
+     *
+     * @return the stream of names
+     */
+    Stream<String> attributes();
+
     /**
      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
      * layout.
      *
      * @apiNote if the layout path has one (or more) free dimensions,
@@ -468,11 +493,11 @@
      * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified
      * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of
      * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional
      * conditions must be satisfied:
      * <ul>
-     *     <li>two value layouts are considered equal if they have the same endianness (see {@link ValueLayout#order()})</li>
+     *     <li>two value layouts are considered equal if they have the same byte order (see {@link ValueLayout#order()})</li>
      *     <li>two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and
      *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal</li>
      *     <li>two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},
      *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal</li>
      * </ul>
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/PaddingLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/PaddingLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/PaddingLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/PaddingLayout.java
@@ -23,12 +23,14 @@
  *  questions.
  *
  */
 package jdk.incubator.foreign;
 
+import java.lang.constant.Constable;
 import java.lang.constant.ConstantDescs;
 import java.lang.constant.DynamicConstantDesc;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalLong;
 
 /**
@@ -45,15 +47,15 @@
  * This class is immutable and thread-safe.
  */
 /* package-private */ final class PaddingLayout extends AbstractLayout implements MemoryLayout {
 
     PaddingLayout(long size) {
-        this(size, 1, Optional.empty());
+        this(size, 1, Map.of());
     }
 
-    PaddingLayout(long size, long alignment, Optional<String> name) {
-        super(OptionalLong.of(size), alignment, name);
+    PaddingLayout(long size, long alignment, Map<String, Constable> attributes) {
+        super(OptionalLong.of(size), alignment, attributes);
     }
 
     @Override
     public String toString() {
         return decorateLayoutString("x" + bitSize());
@@ -78,18 +80,23 @@
     public int hashCode() {
         return Objects.hash(super.hashCode(), bitSize());
     }
 
     @Override
-    PaddingLayout dup(long alignment, Optional<String> name) {
-        return new PaddingLayout(bitSize(), alignment, name);
+    PaddingLayout dup(long alignment, Map<String, Constable> attributes) {
+        return new PaddingLayout(bitSize(), alignment, attributes);
+    }
+
+    @Override
+    public boolean hasNaturalAlignment() {
+        return true;
     }
 
     @Override
     public Optional<DynamicConstantDesc<MemoryLayout>> describeConstable() {
-        return Optional.of(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "padding",
-                CD_LAYOUT, MH_PADDING, bitSize()));
+        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "padding",
+                CD_MEMORY_LAYOUT, MH_PADDING, bitSize())));
     }
 
     //hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout
     //but that causes issues with javadoc, see JDK-8224052
 
@@ -106,6 +113,14 @@
      */
     @Override
     public PaddingLayout withBitAlignment(long alignmentBits) {
         return (PaddingLayout)super.withBitAlignment(alignmentBits);
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public PaddingLayout withAttribute(String name, Constable value) {
+        return (PaddingLayout)super.withAttribute(name, value);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SequenceLayout.java
@@ -23,12 +23,14 @@
  *  questions.
  *
  */
 package jdk.incubator.foreign;
 
+import java.lang.constant.Constable;
 import java.lang.constant.ConstantDescs;
 import java.lang.constant.DynamicConstantDesc;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalLong;
 
 /**
@@ -64,17 +66,17 @@
 
     private final OptionalLong elemCount;
     private final MemoryLayout elementLayout;
 
     SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout) {
-        this(elemCount, elementLayout, elementLayout.bitAlignment(), Optional.empty());
+        this(elemCount, elementLayout, elementLayout.bitAlignment(), Map.of());
     }
 
-    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Optional<String> name) {
+    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Map<String, Constable> attributes) {
         super(elemCount.isPresent() && AbstractLayout.optSize(elementLayout).isPresent() ?
                 OptionalLong.of(elemCount.getAsLong() * elementLayout.bitSize()) :
-                OptionalLong.empty(), alignment, name);
+                OptionalLong.empty(), alignment, attributes);
         this.elemCount = elemCount;
         this.elementLayout = elementLayout;
     }
 
     /**
@@ -102,11 +104,11 @@
      * @return a new sequence with given element count.
      * @throws IllegalArgumentException if {@code elementCount < 0}.
      */
     public SequenceLayout withElementCount(long elementCount) {
         AbstractLayout.checkSize(elementCount, true);
-        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, name());
+        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, attributes);
     }
 
     @Override
     public String toString() {
         return decorateLayoutString(String.format("[%s:%s]",
@@ -132,26 +134,26 @@
     public int hashCode() {
         return Objects.hash(super.hashCode(), elemCount, elementLayout);
     }
 
     @Override
-    SequenceLayout dup(long alignment, Optional<String> name) {
-        return new SequenceLayout(elementCount(), elementLayout, alignment, name);
+    SequenceLayout dup(long alignment, Map<String, Constable> attributes) {
+        return new SequenceLayout(elementCount(), elementLayout, alignment, attributes);
     }
 
     @Override
     boolean hasNaturalAlignment() {
         return alignment == elementLayout.bitAlignment();
     }
 
     @Override
     public Optional<DynamicConstantDesc<SequenceLayout>> describeConstable() {
-        return elemCount.isPresent() ?
-                Optional.of(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
-                        CD_SEQUENCE_LAYOUT, MH_SIZED_SEQUENCE, elemCount.getAsLong(), elementLayout.describeConstable().get())) :
-                Optional.of(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
-                        CD_SEQUENCE_LAYOUT, MH_UNSIZED_SEQUENCE, elementLayout.describeConstable().get()));
+        return Optional.of(decorateLayoutConstant(elemCount.isPresent() ?
+                DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
+                        CD_SEQUENCE_LAYOUT, MH_SIZED_SEQUENCE, elemCount.getAsLong(), elementLayout.describeConstable().get()) :
+                DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
+                        CD_SEQUENCE_LAYOUT, MH_UNSIZED_SEQUENCE, elementLayout.describeConstable().get())));
     }
 
     //hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout
     //but that causes issues with javadoc, see JDK-8224052
 
@@ -168,6 +170,14 @@
      */
     @Override
     public SequenceLayout withBitAlignment(long alignmentBits) {
         return (SequenceLayout)super.withBitAlignment(alignmentBits);
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public SequenceLayout withAttribute(String name, Constable value) {
+        return (SequenceLayout)super.withAttribute(name, value);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ValueLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ValueLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ValueLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/ValueLayout.java
@@ -23,14 +23,15 @@
  *  questions.
  *
  */
 package jdk.incubator.foreign;
 
+import java.lang.constant.Constable;
 import java.lang.constant.ConstantDescs;
 import java.lang.constant.DynamicConstantDesc;
-import java.lang.constant.MethodHandleDesc;
 import java.nio.ByteOrder;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalLong;
 
 /**
@@ -50,15 +51,15 @@
 public final class ValueLayout extends AbstractLayout implements MemoryLayout {
 
     private final ByteOrder order;
 
     ValueLayout(ByteOrder order, long size) {
-        this(order, size, size, Optional.empty());
+        this(order, size, size, Map.of());
     }
 
-    ValueLayout(ByteOrder order, long size, long alignment, Optional<String> name) {
-        super(OptionalLong.of(size), alignment, name);
+    ValueLayout(ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {
+        super(OptionalLong.of(size), alignment, attributes);
         this.order = order;
     }
 
     /**
      * Returns the value's byte order.
@@ -74,11 +75,11 @@
      *
      * @param order the desired byte order.
      * @return a new value layout with given byte order.
      */
     public ValueLayout withOrder(ByteOrder order) {
-        return new ValueLayout(order, bitSize(), alignment, optName());
+        return new ValueLayout(order, bitSize(), alignment, attributes);
     }
 
     @Override
     public String toString() {
         return decorateLayoutString(String.format("%s%d",
@@ -107,18 +108,18 @@
     public int hashCode() {
         return Objects.hash(super.hashCode(), order, bitSize(), alignment);
     }
 
     @Override
-    ValueLayout dup(long alignment, Optional<String> name) {
-        return new ValueLayout(order, bitSize(), alignment, name);
+    ValueLayout dup(long alignment, Map<String, Constable> attributes) {
+        return new ValueLayout(order, bitSize(), alignment, attributes);
     }
 
     @Override
     public Optional<DynamicConstantDesc<ValueLayout>> describeConstable() {
-        return Optional.of(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
-                CD_VALUE_LAYOUT, MH_VALUE, bitSize(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN));
+        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, "value",
+                CD_VALUE_LAYOUT, MH_VALUE, bitSize(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN)));
     }
 
     //hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout
     //but that causes issues with javadoc, see JDK-8224052
 
@@ -135,6 +136,14 @@
      */
     @Override
     public ValueLayout withBitAlignment(long alignmentBits) {
         return (ValueLayout)super.withBitAlignment(alignmentBits);
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public ValueLayout withAttribute(String name, Constable value) {
+        return (ValueLayout)super.withAttribute(name, value);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/unsafe/ForeignUnsafe.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/unsafe/ForeignUnsafe.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/unsafe/ForeignUnsafe.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.incubator.foreign.unsafe;
-
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.internal.foreign.MemoryAddressImpl;
-import jdk.internal.foreign.MemorySegmentImpl;
-
-/**
- * Unsafe methods to allow interop between sun.misc.unsafe and memory access API.
- */
-public final class ForeignUnsafe {
-
-    private ForeignUnsafe() {
-        //just the one, please
-    }
-
-    // The following methods can be used in conjunction with the java.foreign API.
-
-    /**
-     * Obtain the base object (if any) associated with this address. This can be used in conjunction with
-     * {@link #getUnsafeOffset(MemoryAddress)} in order to obtain a base/offset addressing coordinate pair
-     * to be used with methods like {@link sun.misc.Unsafe#getInt(Object, long)} and the likes.
-     *
-     * @param address the address whose base object is to be obtained.
-     * @return the base object associated with the address, or {@code null}.
-     */
-    public static Object getUnsafeBase(MemoryAddress address) {
-        return ((MemoryAddressImpl)address).unsafeGetBase();
-    }
-
-    /**
-     * Obtain the offset associated with this address. If {@link #getUnsafeBase(MemoryAddress)} returns {@code null} on the passed
-     * address, then the offset is to be interpreted as the (absolute) numerical value associated said address.
-     * Alternatively, the offset represents the displacement of a field or an array element within the containing
-     * base object. This can be used in conjunction with {@link #getUnsafeBase(MemoryAddress)} in order to obtain a base/offset
-     * addressing coordinate pair to be used with methods like {@link sun.misc.Unsafe#getInt(Object, long)} and the likes.
-     *
-     * @param address the address whose offset is to be obtained.
-     * @return the offset associated with the address.
-     */
-    public static long getUnsafeOffset(MemoryAddress address) {
-        return ((MemoryAddressImpl)address).unsafeGetOffset();
-    }
-
-    /**
-     * Returns a non-confined memory segment that has the same spatial and temporal bounds as the provided segment.
-     * Since the returned segment can be effectively accessed by multiple threads in an unconstrained fashion,
-     * this method should be used with care, as it might lead to JVM crashes - e.g. in the case where a thread {@code A}
-     * closes a segment while another thread {@code B} is accessing it.
-     * @param segment the segment from which an unconfined view is to be created.
-     * @return a non-confined memory segment that has the same spatial and temporal bounds as the provided segment.
-     */
-    public static MemorySegment asUnconfined(MemorySegment segment) {
-        return ((MemorySegmentImpl)segment).asUnconfined();
-    }
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/InternalForeign.java
@@ -0,0 +1,87 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.foreign;
+
+import jdk.incubator.foreign.Foreign;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
+import sun.security.action.GetPropertyAction;
+
+public class InternalForeign implements Foreign {
+
+    private static final String foreignAccess
+            = GetPropertyAction.privilegedGetProperty("jdk.incubator.foreign.Foreign", "deny");
+    private static final InternalForeign INSTANCE = new InternalForeign();
+
+    private InternalForeign() {}
+
+    public static InternalForeign getInstance() {
+        checkRestrictedAccess();
+        return getInstancePrivileged();
+    }
+
+    public static InternalForeign getInstancePrivileged() {
+        return INSTANCE;
+    }
+
+    @Override
+    public long asLong(MemoryAddress address) throws IllegalAccessError {
+        return MemoryAddressImpl.addressof(address);
+    }
+
+    @Override
+    public MemorySegment ofNativeUnchecked(MemoryAddress base, long byteSize) throws IllegalAccessError {
+        return Utils.makeNativeSegmentUnchecked(base, byteSize);
+    }
+
+    @Override
+    public MemorySegment asUnconfined(MemorySegment segment) {
+        return ((MemorySegmentImpl)segment).asUnconfined();
+    }
+
+    private static void checkRestrictedAccess() {
+        switch (foreignAccess) {
+            case "deny" -> throwIllegalAccessError(foreignAccess);
+            case "warn" -> System.err.println("WARNING: Accessing jdk.incubator.foreign.Foreign.");
+            case "debug" -> {
+                StringBuilder sb = new StringBuilder("DEBUG: Accessing jdk.incubator.foreign.Foreign.");
+                StackWalker.getInstance().walk(s -> {
+                     s
+                     .forEach(f -> sb.append(System.lineSeparator()).append("\tat ").append(f));
+                    return null;
+                });
+                System.out.println(sb.toString());
+            }
+            case "permit" -> {}
+            default -> throwIllegalAccessError(foreignAccess);
+        }
+    }
+
+    private static void throwIllegalAccessError(String value) {
+        throw new IllegalAccessError("Can not access jdk.incubator.foreign.Foreign." +
+                " System property 'jdk.incubator.foreign.Foreign' is set to '" + value + "'");
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
@@ -31,28 +31,29 @@
 import sun.invoke.util.Wrapper;
 
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
+
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.function.ToLongFunction;
 import java.util.function.UnaryOperator;
 import java.util.stream.LongStream;
 
 /**
- * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout)},
+ * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout, ToLongFunction)},
  * a path can be constructed by selecting layout elements using the selector methods provided by this class
  * (see {@link #sequenceElement()}, {@link #sequenceElement(long)}, {@link #sequenceElement(long, long)}, {@link #groupElement(String)}).
  * Once a path has been fully constructed, clients can ask for the offset associated with the layout element selected
  * by the path (see {@link #offset}), or obtain a memory access var handle to access the selected layout element
  * given an address pointing to a segment associated with the root layout (see {@link #dereferenceHandle(Class)}).
  */
 public class LayoutPath {
 
-    private static JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();
+    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();
 
     private final MemoryLayout layout;
     private final long offset;
     private final LayoutPath enclosing;
     private final long[] strides;
@@ -239,11 +240,11 @@
         System.arraycopy(strides, 0, newStrides, 0, strides.length);
         newStrides[strides.length] = stride;
         return newStrides;
     }
 
-    private static long[] EMPTY_STRIDES = new long[0];
+    private static final long[] EMPTY_STRIDES = new long[0];
 
     /**
      * This class provides an immutable implementation for the {@code PathElement} interface. A path element implementation
      * is simply a pointer to one of the selector methods provided by the {@code LayoutPath} class.
      */
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -29,11 +29,10 @@
 import jdk.internal.misc.Unsafe;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
-import java.lang.ref.Reference;
 import java.util.Objects;
 
 /**
  * This class provides an immutable implementation for the {@code MemoryAddress} interface. This class contains information
  * about the segment this address is associated with, as well as an offset into such segment.
@@ -76,10 +75,20 @@
     @Override
     public MemoryAddress addOffset(long bytes) {
         return new MemoryAddressImpl(segment, offset + bytes);
     }
 
+    @Override
+    public MemoryAddress rebase(MemorySegment segment) {
+        MemorySegmentImpl segmentImpl = (MemorySegmentImpl)segment;
+        if (segmentImpl.base != this.segment.base) {
+            throw new IllegalArgumentException("Invalid rebase target: " + segment);
+        }
+        return new MemoryAddressImpl((MemorySegmentImpl)segment,
+                unsafeGetOffset() - ((MemoryAddressImpl)segment.baseAddress()).unsafeGetOffset());
+    }
+
     // MemoryAddressProxy methods
 
     public void checkAccess(long offset, long length, boolean readOnly) {
         segment.checkRange(MemoryAddressProxy.addOffsets(this.offset, offset, this), length, !readOnly);
     }
@@ -117,6 +126,16 @@
 
     @Override
     public String toString() {
         return "MemoryAddress{ region: " + segment + " offset=0x" + Long.toHexString(offset) + " }";
     }
+
+    // helper methods
+
+    public static long addressof(MemoryAddress address) {
+        MemoryAddressImpl addressImpl = (MemoryAddressImpl) address;
+        if (addressImpl.unsafeGetBase() != null) {
+            throw new IllegalStateException("Heap address!");
+        }
+        return addressImpl.unsafeGetOffset();
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
@@ -56,10 +56,12 @@
     final static int CLOSED = -1;
     final static int MAX_ACQUIRE = Integer.MAX_VALUE;
 
     final Runnable cleanupAction;
 
+    final static MemoryScope GLOBAL = new MemoryScope(null, null);
+
     public MemoryScope(Object ref, Runnable cleanupAction) {
         this.ref = ref;
         this.cleanupAction = cleanupAction;
     }
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemorySegmentImpl.java
@@ -68,10 +68,20 @@
     final static int SMALL = FIRST_RESERVED_FLAG;
 
     final static long NONCE = new Random().nextLong();
 
     final static int DEFAULT_MASK = READ | WRITE | CLOSE | ACQUIRE;
+    public static final MemorySegmentImpl NOTHING = new MemorySegmentImpl();
+
+    private MemorySegmentImpl() {
+        this.length = 0L;
+        this.mask = 0;
+        this.min = 0L;
+        this.base = null;
+        this.owner = null;
+        this.scope = MemoryScope.GLOBAL;
+    }
 
     public MemorySegmentImpl(long min, Object base, long length, Thread owner, MemoryScope scope) {
         this(min, base, length, DEFAULT_MASK, owner, scope);
     }
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -51,11 +51,11 @@
 /**
  * This class contains misc helper functions to support creation of memory segments.
  */
 public final class Utils {
 
-    private static Unsafe unsafe = Unsafe.getUnsafe();
+    private static final Unsafe unsafe = Unsafe.getUnsafe();
 
     private static final MethodHandle ADDRESS_FILTER;
 
     static {
         try {
@@ -107,10 +107,22 @@
             segment = segment.asSlice(delta, bytesSize);
         }
         return segment;
     }
 
+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress base, long bytesSize) {
+        if (((MemorySegmentImpl)base.segment()).base != null) {
+            throw new IllegalArgumentException("Not a native address: " + base);
+        }
+        return makeNativeSegmentUnchecked(((MemoryAddressImpl)base).unsafeGetOffset(), bytesSize);
+    }
+
+    public static MemorySegment makeNativeSegmentUnchecked(long min, long bytesSize) {
+        MemoryScope scope = new MemoryScope(null, null);
+        return new MemorySegmentImpl(min, null, bytesSize, Thread.currentThread(), scope);
+    }
+
     public static MemorySegment makeArraySegment(byte[] arr) {
         return makeArraySegment(arr, arr.length, Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE);
     }
 
     public static MemorySegment makeArraySegment(char[] arr) {
diff a/test/jdk/java/foreign/TestLayoutAttributes.java b/test/jdk/java/foreign/TestLayoutAttributes.java
--- /dev/null
+++ b/test/jdk/java/foreign/TestLayoutAttributes.java
@@ -0,0 +1,72 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ */
+
+/*
+ * @test
+ * @run testng TestLayoutAttributes
+ */
+
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
+import org.testng.annotations.Test;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+public class TestLayoutAttributes {
+
+    @Test
+    public void testAttribute() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withAttribute("MyAttribute", 10L);
+        assertEquals((long) ml.attribute("MyAttribute").orElseThrow(), 10L);
+    }
+
+    @Test
+    public void testAttributeNonExistent() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withAttribute("MyAttribute", 10L);
+        assertTrue(ml.attribute("Foo").isEmpty());
+    }
+
+    @Test
+    public void testNameAttribute() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withName("foo");
+        assertEquals(ml.name().orElseThrow(), "foo");
+        assertEquals(ml.attribute("name").orElseThrow(), "foo");
+    }
+
+    @Test
+    public void testAttributesStream() {
+        MemoryLayout ml = MemoryLayouts.BITS_32_LE
+                .withName("foo")
+                .withAttribute("MyAttribute", 10L);
+        List<String> attribs = ml.attributes().collect(Collectors.toList());
+        assertEquals(attribs, List.of("name", "MyAttribute"));
+    }
+
+}
diff a/test/jdk/java/foreign/TestLayoutConstants.java b/test/jdk/java/foreign/TestLayoutConstants.java
--- a/test/jdk/java/foreign/TestLayoutConstants.java
+++ b/test/jdk/java/foreign/TestLayoutConstants.java
@@ -89,8 +89,11 @@
                                 MemoryLayouts.BITS_32_BE)) },
                 { MemoryLayout.ofSequence(5,
                         MemoryLayout.ofStruct(
                                 MemoryLayouts.PAD_8,
                                 MemoryLayouts.BITS_32_BE)) },
+                { MemoryLayouts.BITS_32_LE.withName("myInt") },
+                { MemoryLayouts.BITS_32_LE.withBitAlignment(8) },
+                { MemoryLayouts.BITS_32_LE.withAttribute("xyz", "abc") },
         };
     }
 }
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -24,23 +24,23 @@
 
 /*
  * @test
  * @modules java.base/jdk.internal.misc
  *          jdk.incubator.foreign/jdk.incubator.foreign.unsafe
- * @run testng TestNative
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit TestNative
  */
 
-import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.Foreign;
+import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
-import jdk.incubator.foreign.unsafe.ForeignUnsafe;
-import jdk.internal.misc.Unsafe;
-import org.testng.annotations.*;
-
-import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
+import jdk.internal.misc.Unsafe;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -53,11 +53,11 @@
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Function;
 
-import static org.testng.Assert.*;
+import static org.testng.Assert.assertEquals;
 
 public class TestNative {
 
     static Unsafe UNSAFE;
 
@@ -116,11 +116,11 @@
         ByteBuffer bb = base.segment().asSlice(base.offset(), (int)layout.byteSize()).asByteBuffer();
         Z z = bufferFactory.apply(bb);
         for (long i = 0 ; i < nelems ; i++) {
             Object handleValue = handleExtractor.apply(base, i);
             Object bufferValue = nativeBufferExtractor.apply(z, (int)i);
-            Object rawValue = nativeRawExtractor.apply(ForeignUnsafe.getUnsafeOffset(base), (int)i);
+            Object rawValue = nativeRawExtractor.apply(Foreign.getInstance().asLong(base), (int)i);
             if (handleValue instanceof Number) {
                 assertEquals(((Number)handleValue).longValue(), i);
                 assertEquals(((Number)bufferValue).longValue(), i);
                 assertEquals(((Number)rawValue).longValue(), i);
             } else {
diff a/test/jdk/java/foreign/TestRebase.java b/test/jdk/java/foreign/TestRebase.java
--- /dev/null
+++ b/test/jdk/java/foreign/TestRebase.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+/*
+ * @test
+ * @run testng TestRebase
+ */
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemorySegment;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+
+import java.lang.invoke.VarHandle;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.IntFunction;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+public class TestRebase {
+
+    static VarHandle BYTE_VH = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
+
+    @Test(dataProvider = "slices")
+    public void testRebase(SegmentSlice s1, SegmentSlice s2) {
+        if (s1.contains(s2)) {
+            //check that an address and its rebased counterpart point to same element
+            MemoryAddress base = s2.segment.baseAddress();
+            MemoryAddress rebased = base.rebase(s1.segment);
+            for (int i = 0; i < s2.size(); i++) {
+                int expected = (int) BYTE_VH.get(base.addOffset(i));
+                int found = (int) BYTE_VH.get(rebased.addOffset(i));
+                assertEquals(found, expected);
+            }
+        } else if (s1.kind != s2.kind) {
+            // check that rebase s1 to s2 fails
+            try {
+                s1.segment.baseAddress().rebase(s2.segment);
+                fail("Rebase unexpectedly passed!");
+            } catch (IllegalArgumentException ex) {
+                assertTrue(true);
+            }
+        } else if (!s2.contains(s1)) {
+            //disjoint segments - check that rebased address is out of bounds
+            MemoryAddress base = s2.segment.baseAddress();
+            MemoryAddress rebased = base.rebase(s1.segment);
+            for (int i = 0; i < s2.size(); i++) {
+                BYTE_VH.get(base.addOffset(i));
+                try {
+                    BYTE_VH.get(rebased.addOffset(i));
+                    fail("Rebased address on a disjoint segment is not out of bounds!");
+                } catch (IndexOutOfBoundsException ex) {
+                    assertTrue(true);
+                }
+            }
+        }
+    }
+
+    static class SegmentSlice {
+
+        enum Kind {
+            NATIVE(MemorySegment::allocateNative),
+            ARRAY(i -> MemorySegment.ofArray(new byte[i]));
+
+            final IntFunction<MemorySegment> segmentFactory;
+
+            Kind(IntFunction<MemorySegment> segmentFactory) {
+                this.segmentFactory = segmentFactory;
+            }
+
+            MemorySegment makeSegment(int elems) {
+                return segmentFactory.apply(elems);
+            }
+        }
+
+        final Kind kind;
+        final int first;
+        final int last;
+        final MemorySegment segment;
+
+        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {
+            this.kind = kind;
+            this.first = first;
+            this.last = last;
+            this.segment = segment;
+        }
+
+        boolean contains(SegmentSlice other) {
+            return kind == other.kind &&
+                    first <= other.first &&
+                    last >= other.last;
+        }
+
+        int size() {
+            return last - first + 1;
+        }
+    }
+
+    @DataProvider(name = "slices")
+    static Object[][] slices() {
+        int[] sizes = { 16, 8, 4, 2, 1 };
+        List<SegmentSlice> slices = new ArrayList<>();
+        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {
+            //init root segment
+            MemorySegment segment = kind.makeSegment(16);
+            for (int i = 0 ; i < 16 ; i++) {
+                BYTE_VH.set(segment.baseAddress().addOffset(i), (byte)i);
+            }
+            //compute all slices
+            for (int size : sizes) {
+                for (int index = 0 ; index < 16 ; index += size) {
+                    MemorySegment slice = segment.asSlice(index, size);
+                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));
+                }
+            }
+        }
+        Object[][] sliceArray = new Object[slices.size() * slices.size()][];
+        for (int i = 0 ; i < slices.size() ; i++) {
+            for (int j = 0 ; j < slices.size() ; j++) {
+                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };
+            }
+        }
+        return sliceArray;
+    }
+}
diff a/test/jdk/java/foreign/TestSegments.java b/test/jdk/java/foreign/TestSegments.java
--- a/test/jdk/java/foreign/TestSegments.java
+++ b/test/jdk/java/foreign/TestSegments.java
@@ -28,27 +28,28 @@
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.nio.ByteOrder;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Spliterator;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.Consumer;
 import java.util.function.LongFunction;
 import java.util.stream.Stream;
 
-import org.testng.annotations.*;
-
-import static org.testng.Assert.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
 
 public class TestSegments {
 
     @Test(dataProvider = "badSizeAndAlignments", expectedExceptions = IllegalArgumentException.class)
     public void testBadAllocateAlign(long size, long align) {
@@ -96,10 +97,24 @@
                 assertEquals(0, (byte)byteHandle.get(segment.baseAddress(), i));
             }
         }
     }
 
+    @Test
+    public void testNothingSegmentAccess() {
+        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);
+        long[] values = { 0L, Integer.MAX_VALUE - 1, (long) Integer.MAX_VALUE + 1 };
+        for (long value : values) {
+            MemoryAddress addr = MemoryAddress.ofLong(value);
+            try {
+                longHandle.get(addr);
+            } catch (UnsupportedOperationException ex) {
+                assertTrue(ex.getMessage().contains("Required access mode"));
+            }
+        }
+    }
+
     @Test
     public void testSlices() {
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(10)) {
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -22,29 +22,28 @@
  *
  */
 
 /*
  * @test
- * @modules jdk.incubator.foreign/jdk.incubator.foreign.unsafe
- * @run testng TestSharedAccess
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit TestSharedAccess
  */
 
+import jdk.incubator.foreign.Foreign;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
-import jdk.incubator.foreign.unsafe.ForeignUnsafe;
-import org.testng.annotations.*;
+import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Spliterator;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.*;
+import static org.testng.Assert.assertEquals;
 
 public class TestSharedAccess {
 
     static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
 
@@ -97,11 +96,11 @@
     public void testSharedUnsafe() throws Throwable {
         try (MemorySegment s = MemorySegment.allocateNative(4)) {
             setInt(s.baseAddress(), 42);
             assertEquals(getInt(s.baseAddress()), 42);
             List<Thread> threads = new ArrayList<>();
-            MemorySegment sharedSegment = ForeignUnsafe.asUnconfined(s);
+            MemorySegment sharedSegment = Foreign.getInstance().asUnconfined(s);
             for (int i = 0 ; i < 1000 ; i++) {
                 threads.add(new Thread(() -> {
                     assertEquals(getInt(sharedSegment.baseAddress()), 42);
                 }));
             }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
104      * corresponding segments.
105      *
106      * @param that the object to be compared for equality with this address.
107      * @return {@code true} if the specified object is equal to this address.
108      */
109     @Override
110     boolean equals(Object that);
111 
112     /**
113      * Returns the hash code value for this address.
114      * @return the hash code value for this address.
115      */
116     @Override
117     int hashCode();
118 
119     /**
120      * Perform bulk copy from source address to target address. More specifically, the bytes at addresses {@code src}
121      * through {@code src.addOffset(bytes - 1)} are copied into addresses {@code dst} through {@code dst.addOffset(bytes - 1)}.
122      * If the source and address ranges overlap, then the copying is performed as if the bytes at addresses {@code src}
123      * through {@code src.addOffset(bytes - 1)} were first copied into a temporary segment with size {@code bytes},
<span class="line-modified">124      * and then the contents of the temporary segment were copied into the bytes at addresses {@code dst} through {@code dst.addOffset(bytes - 1)}.</span>






125      * @param src the source address.
126      * @param dst the target address.
127      * @param bytes the number of bytes to be copied.
128      * @throws IndexOutOfBoundsException if {@code bytes &lt; 0}, or if it is greater than the size of the segments
129      * associated with either {@code src} or {@code dst}.
130      * @throws IllegalStateException if either the source address or the target address belong to memory segments
131      * which have been already closed, or if access occurs from a thread other than the thread owning either segment.
132      * @throws UnsupportedOperationException if either {@code src} or {@code dst} do not feature required access modes;
133      * more specifically, {@code src} should be associated with a segment with {@link MemorySegment#READ} access mode,
134      * while {@code dst} should be associated with a segment with {@link MemorySegment#WRITE} access mode.
135      */
136     static void copy(MemoryAddress src, MemoryAddress dst, long bytes) {
137         MemoryAddressImpl.copy((MemoryAddressImpl)src, (MemoryAddressImpl)dst, bytes);
138     }
139 
140     /**
141      * The &lt;em&gt;unchecked&lt;/em&gt; memory address instance modelling the {@code NULL} address. This address is &lt;em&gt;not&lt;/em&gt; backed by
142      * a memory segment and hence it cannot be dereferenced.
143      */
144     MemoryAddress NULL = new MemoryAddressImpl( 0L);
</pre>
</td>
<td>
<hr />
<pre>
104      * corresponding segments.
105      *
106      * @param that the object to be compared for equality with this address.
107      * @return {@code true} if the specified object is equal to this address.
108      */
109     @Override
110     boolean equals(Object that);
111 
112     /**
113      * Returns the hash code value for this address.
114      * @return the hash code value for this address.
115      */
116     @Override
117     int hashCode();
118 
119     /**
120      * Perform bulk copy from source address to target address. More specifically, the bytes at addresses {@code src}
121      * through {@code src.addOffset(bytes - 1)} are copied into addresses {@code dst} through {@code dst.addOffset(bytes - 1)}.
122      * If the source and address ranges overlap, then the copying is performed as if the bytes at addresses {@code src}
123      * through {@code src.addOffset(bytes - 1)} were first copied into a temporary segment with size {@code bytes},
<span class="line-modified">124      * and then the contents of the temporary segment were copied into the bytes at addresses {@code dst} through</span>
<span class="line-added">125      * {@code dst.addOffset(bytes - 1)}.</span>
<span class="line-added">126      * &lt;p&gt;</span>
<span class="line-added">127      * The result of a bulk copy is unspecified if, in the uncommon case, the source and target address ranges do not</span>
<span class="line-added">128      * overlap, but refer to overlapping regions of the same backing storage using different addresses.  For example,</span>
<span class="line-added">129      * this may occur if the same file is {@link MemorySegment#mapFromPath mapped} to two segments.</span>
<span class="line-added">130      *</span>
131      * @param src the source address.
132      * @param dst the target address.
133      * @param bytes the number of bytes to be copied.
134      * @throws IndexOutOfBoundsException if {@code bytes &lt; 0}, or if it is greater than the size of the segments
135      * associated with either {@code src} or {@code dst}.
136      * @throws IllegalStateException if either the source address or the target address belong to memory segments
137      * which have been already closed, or if access occurs from a thread other than the thread owning either segment.
138      * @throws UnsupportedOperationException if either {@code src} or {@code dst} do not feature required access modes;
139      * more specifically, {@code src} should be associated with a segment with {@link MemorySegment#READ} access mode,
140      * while {@code dst} should be associated with a segment with {@link MemorySegment#WRITE} access mode.
141      */
142     static void copy(MemoryAddress src, MemoryAddress dst, long bytes) {
143         MemoryAddressImpl.copy((MemoryAddressImpl)src, (MemoryAddressImpl)dst, bytes);
144     }
145 
146     /**
147      * The &lt;em&gt;unchecked&lt;/em&gt; memory address instance modelling the {@code NULL} address. This address is &lt;em&gt;not&lt;/em&gt; backed by
148      * a memory segment and hence it cannot be dereferenced.
149      */
150     MemoryAddress NULL = new MemoryAddressImpl( 0L);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
379      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
380      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
381      */
382     ByteBuffer asByteBuffer();
383 
384     /**
385      * Copy the contents of this memory segment into a fresh byte array.
386      * @return a fresh byte array copy of this memory segment.
387      * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this
388      * segment&#39;s contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},
389      * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the
390      * thread owning this segment.
391      */
392     byte[] toByteArray();
393 
394     /**
395      * Creates a new buffer memory segment that models the memory associated with the given byte
396      * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
397      * and ends relative to the buffer&#39;s limit (exclusive).
398      * &lt;p&gt;
<span class="line-modified">399      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;, unless the given</span>
<span class="line-modified">400      * buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will</span>
401      * not feature the {@link #WRITE} access mode.
402      * &lt;p&gt;
403      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
404      * for the life-time of the segment.
405      *
406      * @param bb the byte buffer backing the buffer memory segment.
407      * @return a new buffer memory segment.
408      */
409     static MemorySegment ofByteBuffer(ByteBuffer bb) {
410         return AbstractMemorySegmentImpl.ofBuffer(bb);
411     }
412 
413     /**
414      * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
415      * &lt;p&gt;
416      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">417      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

418      *
419      * @param arr the primitive array backing the array memory segment.
420      * @return a new array memory segment.
421      */
422     static MemorySegment ofArray(byte[] arr) {
423         return HeapMemorySegmentImpl.makeArraySegment(arr);
424     }
425 
426     /**
427      * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
428      * &lt;p&gt;
429      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">430      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

431      *
432      * @param arr the primitive array backing the array memory segment.
433      * @return a new array memory segment.
434      */
435     static MemorySegment ofArray(char[] arr) {
436         return HeapMemorySegmentImpl.makeArraySegment(arr);
437     }
438 
439     /**
440      * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
441      * &lt;p&gt;
442      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">443      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

444      *
445      * @param arr the primitive array backing the array memory segment.
446      * @return a new array memory segment.
447      */
448     static MemorySegment ofArray(short[] arr) {
449         return HeapMemorySegmentImpl.makeArraySegment(arr);
450     }
451 
452     /**
453      * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
454      * &lt;p&gt;
455      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
456      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.
457      *
458      * @param arr the primitive array backing the array memory segment.
459      * @return a new array memory segment.
460      */
461     static MemorySegment ofArray(int[] arr) {
462         return HeapMemorySegmentImpl.makeArraySegment(arr);
463     }
464 
465     /**
466      * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
467      * &lt;p&gt;
468      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">469      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

470      *
471      * @param arr the primitive array backing the array memory segment.
472      * @return a new array memory segment.
473      */
474     static MemorySegment ofArray(float[] arr) {
475         return HeapMemorySegmentImpl.makeArraySegment(arr);
476     }
477 
478     /**
479      * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
480      * &lt;p&gt;
481      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">482      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

483      *
484      * @param arr the primitive array backing the array memory segment.
485      * @return a new array memory segment.
486      */
487     static MemorySegment ofArray(long[] arr) {
488         return HeapMemorySegmentImpl.makeArraySegment(arr);
489     }
490 
491     /**
492      * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
493      * &lt;p&gt;
494      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">495      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

496      *
497      * @param arr the primitive array backing the array memory segment.
498      * @return a new array memory segment.
499      */
500     static MemorySegment ofArray(double[] arr) {
501         return HeapMemorySegmentImpl.makeArraySegment(arr);
502     }
503 
504     /**
505      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
506      * &lt;p&gt;
507      * This is equivalent to the following code:
508      * &lt;blockquote&gt;&lt;pre&gt;{@code
509     allocateNative(layout.bytesSize(), layout.bytesAlignment());
510      * }&lt;/pre&gt;&lt;/blockquote&gt;
511      *
512      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
513      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
514      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
515      *
</pre>
<hr />
<pre>
527      * This is equivalent to the following code:
528      * &lt;blockquote&gt;&lt;pre&gt;{@code
529 allocateNative(bytesSize, 1);
530      * }&lt;/pre&gt;&lt;/blockquote&gt;
531      *
532      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
533      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
534      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
535      *
536      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
537      * @return a new native memory segment.
538      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
539      */
540     static MemorySegment allocateNative(long bytesSize) {
541         return allocateNative(bytesSize, 1);
542     }
543 
544     /**
545      * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
546      * &lt;p&gt;
<span class="line-modified">547      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;, unless the given mapping mode</span>
<span class="line-modified">548      * is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case the segment will not feature</span>
<span class="line-modified">549      * the {@link #WRITE} access mode.</span>
550      *
551      * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
552      * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
553      *
554      * @param path the path to the file to memory map.
555      * @param bytesOffset the offset (expressed in bytes) within the file at which the mapped segment is to start.
556      * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
557      * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode
558      *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).
559      * @return a new mapped memory segment.
560      * @throws IllegalArgumentException if {@code bytesOffset &lt; 0}.
561      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
562      * @throws UnsupportedOperationException if an unsupported map mode is specified.
563      * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
564      */
565     static MappedMemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
566         return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode);
567     }
568 
569     /**
570      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
<span class="line-modified">571      * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

572      *
573      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
574      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
575      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
576      *
577      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
578      * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
579      * @return a new native memory segment.
580      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}, {@code alignmentBytes &lt; 0}, or if {@code alignmentBytes}
581      * is not a power of 2.
582      */
583     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
584         if (bytesSize &lt;= 0) {
585             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
586         }
587 
588         if (alignmentBytes &lt; 0 ||
589                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
590             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
591         }
592 
593         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
594     }
595 
596     /**
597      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
598      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
599      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
600      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
<span class="line-modified">601      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

602      * &lt;p&gt;
603      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
604      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
605      * restricted methods, and use safe and supported functionalities, where possible.
606      *
607      * @param addr the desired base address
608      * @param bytesSize the desired size.
609      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
610      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
611      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
612      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
613      *                   the returned segment depends on memory which could be released if a certain object
614      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
615      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
616      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
617      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
618      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
619      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
620      * @throws NullPointerException if {@code addr == null}.
621      */
</pre>
<hr />
<pre>
649      * @see MemorySegment#accessModes()
650      * @see MemorySegment#withAccessModes(int)
651      */
652     int CLOSE = WRITE &lt;&lt; 1;
653 
654     /**
655      * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
656      * (see {@link #spliterator(MemorySegment, SequenceLayout)}).
657      * @see MemorySegment#accessModes()
658      * @see MemorySegment#withAccessModes(int)
659      */
660     int ACQUIRE = CLOSE &lt;&lt; 1;
661 
662     /**
663      * Handoff access mode; this segment support serial thread-confinement via thread ownership changes
664      * (see {@link #withOwnerThread(Thread)}).
665      * @see MemorySegment#accessModes()
666      * @see MemorySegment#withAccessModes(int)
667      */
668     int HANDOFF = ACQUIRE &lt;&lt; 1;







669 }
</pre>
</td>
<td>
<hr />
<pre>
379      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
380      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
381      */
382     ByteBuffer asByteBuffer();
383 
384     /**
385      * Copy the contents of this memory segment into a fresh byte array.
386      * @return a fresh byte array copy of this memory segment.
387      * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this
388      * segment&#39;s contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},
389      * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the
390      * thread owning this segment.
391      */
392     byte[] toByteArray();
393 
394     /**
395      * Creates a new buffer memory segment that models the memory associated with the given byte
396      * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
397      * and ends relative to the buffer&#39;s limit (exclusive).
398      * &lt;p&gt;
<span class="line-modified">399      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #ALL_ACCESS}),</span>
<span class="line-modified">400      * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will</span>
401      * not feature the {@link #WRITE} access mode.
402      * &lt;p&gt;
403      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
404      * for the life-time of the segment.
405      *
406      * @param bb the byte buffer backing the buffer memory segment.
407      * @return a new buffer memory segment.
408      */
409     static MemorySegment ofByteBuffer(ByteBuffer bb) {
410         return AbstractMemorySegmentImpl.ofBuffer(bb);
411     }
412 
413     /**
414      * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
415      * &lt;p&gt;
416      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">417      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">418      * (see {@link #ALL_ACCESS}).</span>
419      *
420      * @param arr the primitive array backing the array memory segment.
421      * @return a new array memory segment.
422      */
423     static MemorySegment ofArray(byte[] arr) {
424         return HeapMemorySegmentImpl.makeArraySegment(arr);
425     }
426 
427     /**
428      * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
429      * &lt;p&gt;
430      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">431      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">432      * (see {@link #ALL_ACCESS}).</span>
433      *
434      * @param arr the primitive array backing the array memory segment.
435      * @return a new array memory segment.
436      */
437     static MemorySegment ofArray(char[] arr) {
438         return HeapMemorySegmentImpl.makeArraySegment(arr);
439     }
440 
441     /**
442      * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
443      * &lt;p&gt;
444      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">445      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">446      * (see {@link #ALL_ACCESS}).</span>
447      *
448      * @param arr the primitive array backing the array memory segment.
449      * @return a new array memory segment.
450      */
451     static MemorySegment ofArray(short[] arr) {
452         return HeapMemorySegmentImpl.makeArraySegment(arr);
453     }
454 
455     /**
456      * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
457      * &lt;p&gt;
458      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
459      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.
460      *
461      * @param arr the primitive array backing the array memory segment.
462      * @return a new array memory segment.
463      */
464     static MemorySegment ofArray(int[] arr) {
465         return HeapMemorySegmentImpl.makeArraySegment(arr);
466     }
467 
468     /**
469      * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
470      * &lt;p&gt;
471      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">472      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">473      * (see {@link #ALL_ACCESS}).</span>
474      *
475      * @param arr the primitive array backing the array memory segment.
476      * @return a new array memory segment.
477      */
478     static MemorySegment ofArray(float[] arr) {
479         return HeapMemorySegmentImpl.makeArraySegment(arr);
480     }
481 
482     /**
483      * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
484      * &lt;p&gt;
485      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">486      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">487      * (see {@link #ALL_ACCESS}).</span>
488      *
489      * @param arr the primitive array backing the array memory segment.
490      * @return a new array memory segment.
491      */
492     static MemorySegment ofArray(long[] arr) {
493         return HeapMemorySegmentImpl.makeArraySegment(arr);
494     }
495 
496     /**
497      * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
498      * &lt;p&gt;
499      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">500      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">501      * (see {@link #ALL_ACCESS}).</span>
502      *
503      * @param arr the primitive array backing the array memory segment.
504      * @return a new array memory segment.
505      */
506     static MemorySegment ofArray(double[] arr) {
507         return HeapMemorySegmentImpl.makeArraySegment(arr);
508     }
509 
510     /**
511      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
512      * &lt;p&gt;
513      * This is equivalent to the following code:
514      * &lt;blockquote&gt;&lt;pre&gt;{@code
515     allocateNative(layout.bytesSize(), layout.bytesAlignment());
516      * }&lt;/pre&gt;&lt;/blockquote&gt;
517      *
518      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
519      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
520      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
521      *
</pre>
<hr />
<pre>
533      * This is equivalent to the following code:
534      * &lt;blockquote&gt;&lt;pre&gt;{@code
535 allocateNative(bytesSize, 1);
536      * }&lt;/pre&gt;&lt;/blockquote&gt;
537      *
538      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
539      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
540      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
541      *
542      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
543      * @return a new native memory segment.
544      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
545      */
546     static MemorySegment allocateNative(long bytesSize) {
547         return allocateNative(bytesSize, 1);
548     }
549 
550     /**
551      * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
552      * &lt;p&gt;
<span class="line-modified">553      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #ALL_ACCESS}),</span>
<span class="line-modified">554      * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case</span>
<span class="line-modified">555      * the segment will not feature the {@link #WRITE} access mode.</span>
556      *
557      * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
558      * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
559      *
560      * @param path the path to the file to memory map.
561      * @param bytesOffset the offset (expressed in bytes) within the file at which the mapped segment is to start.
562      * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
563      * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode
564      *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).
565      * @return a new mapped memory segment.
566      * @throws IllegalArgumentException if {@code bytesOffset &lt; 0}.
567      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
568      * @throws UnsupportedOperationException if an unsupported map mode is specified.
569      * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
570      */
571     static MappedMemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
572         return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode);
573     }
574 
575     /**
576      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
<span class="line-modified">577      * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">578      * (see {@link #ALL_ACCESS}).</span>
579      *
580      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
581      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
582      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
583      *
584      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
585      * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
586      * @return a new native memory segment.
587      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}, {@code alignmentBytes &lt; 0}, or if {@code alignmentBytes}
588      * is not a power of 2.
589      */
590     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
591         if (bytesSize &lt;= 0) {
592             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
593         }
594 
595         if (alignmentBytes &lt; 0 ||
596                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
597             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
598         }
599 
600         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
601     }
602 
603     /**
604      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
605      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
606      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
607      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
<span class="line-modified">608      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">609      * (see {@link #ALL_ACCESS}).</span>
610      * &lt;p&gt;
611      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
612      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
613      * restricted methods, and use safe and supported functionalities, where possible.
614      *
615      * @param addr the desired base address
616      * @param bytesSize the desired size.
617      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
618      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
619      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
620      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
621      *                   the returned segment depends on memory which could be released if a certain object
622      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
623      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
624      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
625      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
626      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
627      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
628      * @throws NullPointerException if {@code addr == null}.
629      */
</pre>
<hr />
<pre>
657      * @see MemorySegment#accessModes()
658      * @see MemorySegment#withAccessModes(int)
659      */
660     int CLOSE = WRITE &lt;&lt; 1;
661 
662     /**
663      * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
664      * (see {@link #spliterator(MemorySegment, SequenceLayout)}).
665      * @see MemorySegment#accessModes()
666      * @see MemorySegment#withAccessModes(int)
667      */
668     int ACQUIRE = CLOSE &lt;&lt; 1;
669 
670     /**
671      * Handoff access mode; this segment support serial thread-confinement via thread ownership changes
672      * (see {@link #withOwnerThread(Thread)}).
673      * @see MemorySegment#accessModes()
674      * @see MemorySegment#withAccessModes(int)
675      */
676     int HANDOFF = ACQUIRE &lt;&lt; 1;
<span class="line-added">677 </span>
<span class="line-added">678     /**</span>
<span class="line-added">679      * Default access mode; this is a union of all the access modes supported by memory segments.</span>
<span class="line-added">680      * @see MemorySegment#accessModes()</span>
<span class="line-added">681      * @see MemorySegment#withAccessModes(int)</span>
<span class="line-added">682      */</span>
<span class="line-added">683     int ALL_ACCESS = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;</span>
684 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -89,12 +89,12 @@
 
     abstract ByteBuffer makeByteBuffer();
 
     static int defaultAccessModes(long size) {
         return (enableSmallSegments && size < Integer.MAX_VALUE) ?
-                DEFAULT_ACCESS | SMALL :
-                DEFAULT_ACCESS;
+                ALL_ACCESS | SMALL :
+                ALL_ACCESS;
     }
 
     @Override
     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
         checkBounds(offset, newSize);
@@ -188,11 +188,11 @@
         return _bb;
     }
 
     @Override
     public final int accessModes() {
-        return mask & DEFAULT_ACCESS;
+        return mask & ALL_ACCESS;
     }
 
     @Override
     public final long byteSize() {
         return length;
@@ -212,21 +212,21 @@
     public AbstractMemorySegmentImpl withAccessModes(int accessModes) {
         checkAccessModes(accessModes);
         if ((~accessModes() & accessModes) != 0) {
             throw new IllegalArgumentException("Cannot acquire more access modes");
         }
-        return dup(0, length, (mask & ~DEFAULT_ACCESS) | accessModes, scope);
+        return dup(0, length, (mask & ~ALL_ACCESS) | accessModes, scope);
     }
 
     @Override
     public boolean hasAccessModes(int accessModes) {
         checkAccessModes(accessModes);
         return (accessModes() & accessModes) == accessModes;
     }
 
     private void checkAccessModes(int accessModes) {
-        if ((accessModes & ~DEFAULT_ACCESS) != 0) {
+        if ((accessModes & ~ALL_ACCESS) != 0) {
             throw new IllegalArgumentException("Invalid access modes");
         }
     }
 
     @Override

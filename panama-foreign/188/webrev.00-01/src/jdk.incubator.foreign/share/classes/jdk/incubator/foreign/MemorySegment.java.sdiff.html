<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
379      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
380      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
381      */
382     ByteBuffer asByteBuffer();
383 
384     /**
385      * Copy the contents of this memory segment into a fresh byte array.
386      * @return a fresh byte array copy of this memory segment.
387      * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this
388      * segment&#39;s contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},
389      * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the
390      * thread owning this segment.
391      */
392     byte[] toByteArray();
393 
394     /**
395      * Creates a new buffer memory segment that models the memory associated with the given byte
396      * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
397      * and ends relative to the buffer&#39;s limit (exclusive).
398      * &lt;p&gt;
<span class="line-modified">399      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #DEFAULT_ACCESS}),</span>
400      * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will
401      * not feature the {@link #WRITE} access mode.
402      * &lt;p&gt;
403      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
404      * for the life-time of the segment.
405      *
406      * @param bb the byte buffer backing the buffer memory segment.
407      * @return a new buffer memory segment.
408      */
409     static MemorySegment ofByteBuffer(ByteBuffer bb) {
410         return AbstractMemorySegmentImpl.ofBuffer(bb);
411     }
412 
413     /**
414      * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
415      * &lt;p&gt;
416      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
417      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">418      * (see {@link #DEFAULT_ACCESS}).</span>
419      *
420      * @param arr the primitive array backing the array memory segment.
421      * @return a new array memory segment.
422      */
423     static MemorySegment ofArray(byte[] arr) {
424         return HeapMemorySegmentImpl.makeArraySegment(arr);
425     }
426 
427     /**
428      * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
429      * &lt;p&gt;
430      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
431      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">432      * (see {@link #DEFAULT_ACCESS}).</span>
433      *
434      * @param arr the primitive array backing the array memory segment.
435      * @return a new array memory segment.
436      */
437     static MemorySegment ofArray(char[] arr) {
438         return HeapMemorySegmentImpl.makeArraySegment(arr);
439     }
440 
441     /**
442      * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
443      * &lt;p&gt;
444      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
445      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">446      * (see {@link #DEFAULT_ACCESS}).</span>
447      *
448      * @param arr the primitive array backing the array memory segment.
449      * @return a new array memory segment.
450      */
451     static MemorySegment ofArray(short[] arr) {
452         return HeapMemorySegmentImpl.makeArraySegment(arr);
453     }
454 
455     /**
456      * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
457      * &lt;p&gt;
458      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
459      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.
460      *
461      * @param arr the primitive array backing the array memory segment.
462      * @return a new array memory segment.
463      */
464     static MemorySegment ofArray(int[] arr) {
465         return HeapMemorySegmentImpl.makeArraySegment(arr);
466     }
467 
468     /**
469      * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
470      * &lt;p&gt;
471      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
472      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">473      * (see {@link #DEFAULT_ACCESS}).</span>
474      *
475      * @param arr the primitive array backing the array memory segment.
476      * @return a new array memory segment.
477      */
478     static MemorySegment ofArray(float[] arr) {
479         return HeapMemorySegmentImpl.makeArraySegment(arr);
480     }
481 
482     /**
483      * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
484      * &lt;p&gt;
485      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
486      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">487      * (see {@link #DEFAULT_ACCESS}).</span>
488      *
489      * @param arr the primitive array backing the array memory segment.
490      * @return a new array memory segment.
491      */
492     static MemorySegment ofArray(long[] arr) {
493         return HeapMemorySegmentImpl.makeArraySegment(arr);
494     }
495 
496     /**
497      * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
498      * &lt;p&gt;
499      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
500      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">501      * (see {@link #DEFAULT_ACCESS}).</span>
502      *
503      * @param arr the primitive array backing the array memory segment.
504      * @return a new array memory segment.
505      */
506     static MemorySegment ofArray(double[] arr) {
507         return HeapMemorySegmentImpl.makeArraySegment(arr);
508     }
509 
510     /**
511      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
512      * &lt;p&gt;
513      * This is equivalent to the following code:
514      * &lt;blockquote&gt;&lt;pre&gt;{@code
515     allocateNative(layout.bytesSize(), layout.bytesAlignment());
516      * }&lt;/pre&gt;&lt;/blockquote&gt;
517      *
518      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
519      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
520      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
521      *
</pre>
<hr />
<pre>
533      * This is equivalent to the following code:
534      * &lt;blockquote&gt;&lt;pre&gt;{@code
535 allocateNative(bytesSize, 1);
536      * }&lt;/pre&gt;&lt;/blockquote&gt;
537      *
538      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
539      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
540      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
541      *
542      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
543      * @return a new native memory segment.
544      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
545      */
546     static MemorySegment allocateNative(long bytesSize) {
547         return allocateNative(bytesSize, 1);
548     }
549 
550     /**
551      * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
552      * &lt;p&gt;
<span class="line-modified">553      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #DEFAULT_ACCESS}),</span>
554      * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case
555      * the segment will not feature the {@link #WRITE} access mode.
556      *
557      * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
558      * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
559      *
560      * @param path the path to the file to memory map.
561      * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
562      * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode
563      *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).
564      * @return a new mapped memory segment.
565      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
566      * @throws UnsupportedOperationException if an unsupported map mode is specified.
567      * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
568      */
569     static MappedMemorySegment mapFromPath(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
570         return MappedMemorySegmentImpl.makeMappedSegment(path, bytesSize, mapMode);
571     }
572 
573     /**
574      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
575      * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">576      * (see {@link #DEFAULT_ACCESS}).</span>
577      *
578      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
579      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
580      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
581      *
582      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
583      * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
584      * @return a new native memory segment.
585      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}, {@code alignmentBytes &lt; 0}, or if {@code alignmentBytes}
586      * is not a power of 2.
587      */
588     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
589         if (bytesSize &lt;= 0) {
590             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
591         }
592 
593         if (alignmentBytes &lt; 0 ||
594                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
595             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
596         }
597 
598         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
599     }
600 
601     /**
602      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
603      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
604      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
605      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
606      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">607      * (see {@link #DEFAULT_ACCESS}).</span>
608      * &lt;p&gt;
609      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
610      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
611      * restricted methods, and use safe and supported functionalities, where possible.
612      *
613      * @param addr the desired base address
614      * @param bytesSize the desired size.
615      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
616      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
617      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
618      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
619      *                   the returned segment depends on memory which could be released if a certain object
620      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
621      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
622      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
623      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
624      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
625      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
626      * @throws NullPointerException if {@code addr == null}.
627      */
</pre>
<hr />
<pre>
661      * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
662      * (see {@link #spliterator(MemorySegment, SequenceLayout)}).
663      * @see MemorySegment#accessModes()
664      * @see MemorySegment#withAccessModes(int)
665      */
666     int ACQUIRE = CLOSE &lt;&lt; 1;
667 
668     /**
669      * Handoff access mode; this segment support serial thread-confinement via thread ownership changes
670      * (see {@link #withOwnerThread(Thread)}).
671      * @see MemorySegment#accessModes()
672      * @see MemorySegment#withAccessModes(int)
673      */
674     int HANDOFF = ACQUIRE &lt;&lt; 1;
675 
676     /**
677      * Default access mode; this is a union of all the access modes supported by memory segments.
678      * @see MemorySegment#accessModes()
679      * @see MemorySegment#withAccessModes(int)
680      */
<span class="line-modified">681     int DEFAULT_ACCESS = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;</span>
682 }
</pre>
</td>
<td>
<hr />
<pre>
379      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
380      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
381      */
382     ByteBuffer asByteBuffer();
383 
384     /**
385      * Copy the contents of this memory segment into a fresh byte array.
386      * @return a fresh byte array copy of this memory segment.
387      * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this
388      * segment&#39;s contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},
389      * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the
390      * thread owning this segment.
391      */
392     byte[] toByteArray();
393 
394     /**
395      * Creates a new buffer memory segment that models the memory associated with the given byte
396      * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
397      * and ends relative to the buffer&#39;s limit (exclusive).
398      * &lt;p&gt;
<span class="line-modified">399      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #ALL_ACCESS}),</span>
400      * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will
401      * not feature the {@link #WRITE} access mode.
402      * &lt;p&gt;
403      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
404      * for the life-time of the segment.
405      *
406      * @param bb the byte buffer backing the buffer memory segment.
407      * @return a new buffer memory segment.
408      */
409     static MemorySegment ofByteBuffer(ByteBuffer bb) {
410         return AbstractMemorySegmentImpl.ofBuffer(bb);
411     }
412 
413     /**
414      * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
415      * &lt;p&gt;
416      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
417      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">418      * (see {@link #ALL_ACCESS}).</span>
419      *
420      * @param arr the primitive array backing the array memory segment.
421      * @return a new array memory segment.
422      */
423     static MemorySegment ofArray(byte[] arr) {
424         return HeapMemorySegmentImpl.makeArraySegment(arr);
425     }
426 
427     /**
428      * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
429      * &lt;p&gt;
430      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
431      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">432      * (see {@link #ALL_ACCESS}).</span>
433      *
434      * @param arr the primitive array backing the array memory segment.
435      * @return a new array memory segment.
436      */
437     static MemorySegment ofArray(char[] arr) {
438         return HeapMemorySegmentImpl.makeArraySegment(arr);
439     }
440 
441     /**
442      * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
443      * &lt;p&gt;
444      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
445      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">446      * (see {@link #ALL_ACCESS}).</span>
447      *
448      * @param arr the primitive array backing the array memory segment.
449      * @return a new array memory segment.
450      */
451     static MemorySegment ofArray(short[] arr) {
452         return HeapMemorySegmentImpl.makeArraySegment(arr);
453     }
454 
455     /**
456      * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
457      * &lt;p&gt;
458      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
459      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.
460      *
461      * @param arr the primitive array backing the array memory segment.
462      * @return a new array memory segment.
463      */
464     static MemorySegment ofArray(int[] arr) {
465         return HeapMemorySegmentImpl.makeArraySegment(arr);
466     }
467 
468     /**
469      * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
470      * &lt;p&gt;
471      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
472      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">473      * (see {@link #ALL_ACCESS}).</span>
474      *
475      * @param arr the primitive array backing the array memory segment.
476      * @return a new array memory segment.
477      */
478     static MemorySegment ofArray(float[] arr) {
479         return HeapMemorySegmentImpl.makeArraySegment(arr);
480     }
481 
482     /**
483      * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
484      * &lt;p&gt;
485      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
486      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">487      * (see {@link #ALL_ACCESS}).</span>
488      *
489      * @param arr the primitive array backing the array memory segment.
490      * @return a new array memory segment.
491      */
492     static MemorySegment ofArray(long[] arr) {
493         return HeapMemorySegmentImpl.makeArraySegment(arr);
494     }
495 
496     /**
497      * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
498      * &lt;p&gt;
499      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
500      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">501      * (see {@link #ALL_ACCESS}).</span>
502      *
503      * @param arr the primitive array backing the array memory segment.
504      * @return a new array memory segment.
505      */
506     static MemorySegment ofArray(double[] arr) {
507         return HeapMemorySegmentImpl.makeArraySegment(arr);
508     }
509 
510     /**
511      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
512      * &lt;p&gt;
513      * This is equivalent to the following code:
514      * &lt;blockquote&gt;&lt;pre&gt;{@code
515     allocateNative(layout.bytesSize(), layout.bytesAlignment());
516      * }&lt;/pre&gt;&lt;/blockquote&gt;
517      *
518      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
519      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
520      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
521      *
</pre>
<hr />
<pre>
533      * This is equivalent to the following code:
534      * &lt;blockquote&gt;&lt;pre&gt;{@code
535 allocateNative(bytesSize, 1);
536      * }&lt;/pre&gt;&lt;/blockquote&gt;
537      *
538      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
539      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
540      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
541      *
542      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
543      * @return a new native memory segment.
544      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
545      */
546     static MemorySegment allocateNative(long bytesSize) {
547         return allocateNative(bytesSize, 1);
548     }
549 
550     /**
551      * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
552      * &lt;p&gt;
<span class="line-modified">553      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #ALL_ACCESS}),</span>
554      * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case
555      * the segment will not feature the {@link #WRITE} access mode.
556      *
557      * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
558      * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
559      *
560      * @param path the path to the file to memory map.
561      * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
562      * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode
563      *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).
564      * @return a new mapped memory segment.
565      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
566      * @throws UnsupportedOperationException if an unsupported map mode is specified.
567      * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
568      */
569     static MappedMemorySegment mapFromPath(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
570         return MappedMemorySegmentImpl.makeMappedSegment(path, bytesSize, mapMode);
571     }
572 
573     /**
574      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
575      * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">576      * (see {@link #ALL_ACCESS}).</span>
577      *
578      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
579      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
580      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
581      *
582      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
583      * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
584      * @return a new native memory segment.
585      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}, {@code alignmentBytes &lt; 0}, or if {@code alignmentBytes}
586      * is not a power of 2.
587      */
588     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
589         if (bytesSize &lt;= 0) {
590             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
591         }
592 
593         if (alignmentBytes &lt; 0 ||
594                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
595             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
596         }
597 
598         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
599     }
600 
601     /**
602      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
603      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
604      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
605      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
606      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">607      * (see {@link #ALL_ACCESS}).</span>
608      * &lt;p&gt;
609      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
610      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
611      * restricted methods, and use safe and supported functionalities, where possible.
612      *
613      * @param addr the desired base address
614      * @param bytesSize the desired size.
615      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
616      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
617      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
618      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
619      *                   the returned segment depends on memory which could be released if a certain object
620      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
621      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
622      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
623      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
624      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
625      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
626      * @throws NullPointerException if {@code addr == null}.
627      */
</pre>
<hr />
<pre>
661      * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
662      * (see {@link #spliterator(MemorySegment, SequenceLayout)}).
663      * @see MemorySegment#accessModes()
664      * @see MemorySegment#withAccessModes(int)
665      */
666     int ACQUIRE = CLOSE &lt;&lt; 1;
667 
668     /**
669      * Handoff access mode; this segment support serial thread-confinement via thread ownership changes
670      * (see {@link #withOwnerThread(Thread)}).
671      * @see MemorySegment#accessModes()
672      * @see MemorySegment#withAccessModes(int)
673      */
674     int HANDOFF = ACQUIRE &lt;&lt; 1;
675 
676     /**
677      * Default access mode; this is a union of all the access modes supported by memory segments.
678      * @see MemorySegment#accessModes()
679      * @see MemorySegment#withAccessModes(int)
680      */
<span class="line-modified">681     int ALL_ACCESS = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;</span>
682 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
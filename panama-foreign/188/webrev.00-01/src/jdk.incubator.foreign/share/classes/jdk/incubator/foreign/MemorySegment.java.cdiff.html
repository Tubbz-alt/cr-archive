<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 394,11 ***</span>
      /**
       * Creates a new buffer memory segment that models the memory associated with the given byte
       * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
       * and ends relative to the buffer&#39;s limit (exclusive).
       * &lt;p&gt;
<span class="line-modified">!      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #DEFAULT_ACCESS}),</span>
       * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will
       * not feature the {@link #WRITE} access mode.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment.
<span class="line-new-header">--- 394,11 ---</span>
      /**
       * Creates a new buffer memory segment that models the memory associated with the given byte
       * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
       * and ends relative to the buffer&#39;s limit (exclusive).
       * &lt;p&gt;
<span class="line-modified">!      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #ALL_ACCESS}),</span>
       * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will
       * not feature the {@link #WRITE} access mode.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 413,11 ***</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #DEFAULT_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(byte[] arr) {
<span class="line-new-header">--- 413,11 ---</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(byte[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,11 ***</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #DEFAULT_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(char[] arr) {
<span class="line-new-header">--- 427,11 ---</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(char[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 441,11 ***</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #DEFAULT_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(short[] arr) {
<span class="line-new-header">--- 441,11 ---</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(short[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,11 ***</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #DEFAULT_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(float[] arr) {
<span class="line-new-header">--- 468,11 ---</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(float[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,11 ***</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #DEFAULT_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(long[] arr) {
<span class="line-new-header">--- 482,11 ---</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(long[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 496,11 ***</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #DEFAULT_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(double[] arr) {
<span class="line-new-header">--- 496,11 ---</span>
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(double[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,11 ***</span>
      }
  
      /**
       * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
       * &lt;p&gt;
<span class="line-modified">!      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #DEFAULT_ACCESS}),</span>
       * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case
       * the segment will not feature the {@link #WRITE} access mode.
       *
       * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
       * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
<span class="line-new-header">--- 548,11 ---</span>
      }
  
      /**
       * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
       * &lt;p&gt;
<span class="line-modified">!      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #ALL_ACCESS}),</span>
       * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case
       * the segment will not feature the {@link #WRITE} access mode.
       *
       * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
       * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,11 ***</span>
      }
  
      /**
       * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
       * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #DEFAULT_ACCESS}).</span>
       *
       * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
       * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
       * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
       *
<span class="line-new-header">--- 571,11 ---</span>
      }
  
      /**
       * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
       * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #ALL_ACCESS}).</span>
       *
       * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
       * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
       * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,11 ***</span>
       * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
       * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
       * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
       * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
       * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #DEFAULT_ACCESS}).</span>
       * &lt;p&gt;
       * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
       * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
       * restricted methods, and use safe and supported functionalities, where possible.
       *
<span class="line-new-header">--- 602,11 ---</span>
       * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
       * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
       * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
       * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
       * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;
<span class="line-modified">!      * (see {@link #ALL_ACCESS}).</span>
       * &lt;p&gt;
       * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
       * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
       * restricted methods, and use safe and supported functionalities, where possible.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,7 ***</span>
      /**
       * Default access mode; this is a union of all the access modes supported by memory segments.
       * @see MemorySegment#accessModes()
       * @see MemorySegment#withAccessModes(int)
       */
<span class="line-modified">!     int DEFAULT_ACCESS = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;</span>
  }
<span class="line-new-header">--- 676,7 ---</span>
      /**
       * Default access mode; this is a union of all the access modes supported by memory segments.
       * @see MemorySegment#accessModes()
       * @see MemorySegment#withAccessModes(int)
       */
<span class="line-modified">!     int ALL_ACCESS = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;</span>
  }
</pre>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
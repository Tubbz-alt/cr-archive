<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 394,12 ***</span>
      /**
       * Creates a new buffer memory segment that models the memory associated with the given byte
       * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
       * and ends relative to the buffer&#39;s limit (exclusive).
       * &lt;p&gt;
<span class="line-modified">!      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;, unless the given</span>
<span class="line-modified">!      * buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will</span>
       * not feature the {@link #WRITE} access mode.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment.
       *
<span class="line-new-header">--- 394,12 ---</span>
      /**
       * Creates a new buffer memory segment that models the memory associated with the given byte
       * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
       * and ends relative to the buffer&#39;s limit (exclusive).
       * &lt;p&gt;
<span class="line-modified">!      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #ALL_ACCESS}),</span>
<span class="line-modified">!      * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will</span>
       * not feature the {@link #WRITE} access mode.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
       * for the life-time of the segment.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 412,11 ***</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(byte[] arr) {
<span class="line-new-header">--- 412,12 ---</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">+      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(byte[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 425,11 ***</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(char[] arr) {
<span class="line-new-header">--- 426,12 ---</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">+      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(char[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 438,11 ***</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(short[] arr) {
<span class="line-new-header">--- 440,12 ---</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">+      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(short[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 464,11 ***</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(float[] arr) {
<span class="line-new-header">--- 467,12 ---</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">+      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(float[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 477,11 ***</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(long[] arr) {
<span class="line-new-header">--- 481,12 ---</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">+      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(long[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 490,11 ***</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(double[] arr) {
<span class="line-new-header">--- 495,12 ---</span>
  
      /**
       * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
       * &lt;p&gt;
       * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">!      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">+      * (see {@link #ALL_ACCESS}).</span>
       *
       * @param arr the primitive array backing the array memory segment.
       * @return a new array memory segment.
       */
      static MemorySegment ofArray(double[] arr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 542,13 ***</span>
      }
  
      /**
       * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
       * &lt;p&gt;
<span class="line-modified">!      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;, unless the given mapping mode</span>
<span class="line-modified">!      * is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case the segment will not feature</span>
<span class="line-modified">!      * the {@link #WRITE} access mode.</span>
       *
       * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
       * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
       *
       * @param path the path to the file to memory map.
<span class="line-new-header">--- 548,13 ---</span>
      }
  
      /**
       * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
       * &lt;p&gt;
<span class="line-modified">!      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #ALL_ACCESS}),</span>
<span class="line-modified">!      * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case</span>
<span class="line-modified">!      * the segment will not feature the {@link #WRITE} access mode.</span>
       *
       * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
       * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
       *
       * @param path the path to the file to memory map.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 564,11 ***</span>
          return MappedMemorySegmentImpl.makeMappedSegment(path, bytesSize, mapMode);
      }
  
      /**
       * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
<span class="line-modified">!      * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>
       *
       * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
       * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
       * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
       *
<span class="line-new-header">--- 570,12 ---</span>
          return MappedMemorySegmentImpl.makeMappedSegment(path, bytesSize, mapMode);
      }
  
      /**
       * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
<span class="line-modified">!      * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">+      * (see {@link #ALL_ACCESS}).</span>
       *
       * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
       * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
       * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 594,11 ***</span>
      /**
       * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
       * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
       * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
       * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
<span class="line-modified">!      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>
       * &lt;p&gt;
       * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
       * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
       * restricted methods, and use safe and supported functionalities, where possible.
       *
<span class="line-new-header">--- 601,12 ---</span>
      /**
       * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
       * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
       * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
       * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
<span class="line-modified">!      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">+      * (see {@link #ALL_ACCESS}).</span>
       * &lt;p&gt;
       * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
       * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
       * restricted methods, and use safe and supported functionalities, where possible.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 662,6 ***</span>
<span class="line-new-header">--- 670,13 ---</span>
       * (see {@link #withOwnerThread(Thread)}).
       * @see MemorySegment#accessModes()
       * @see MemorySegment#withAccessModes(int)
       */
      int HANDOFF = ACQUIRE &lt;&lt; 1;
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Default access mode; this is a union of all the access modes supported by memory segments.</span>
<span class="line-added">+      * @see MemorySegment#accessModes()</span>
<span class="line-added">+      * @see MemorySegment#withAccessModes(int)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     int ALL_ACCESS = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;</span>
  }
</pre>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
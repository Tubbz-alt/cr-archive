<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
379      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
380      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
381      */
382     ByteBuffer asByteBuffer();
383 
384     /**
385      * Copy the contents of this memory segment into a fresh byte array.
386      * @return a fresh byte array copy of this memory segment.
387      * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this
388      * segment&#39;s contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},
389      * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the
390      * thread owning this segment.
391      */
392     byte[] toByteArray();
393 
394     /**
395      * Creates a new buffer memory segment that models the memory associated with the given byte
396      * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
397      * and ends relative to the buffer&#39;s limit (exclusive).
398      * &lt;p&gt;
<span class="line-modified">399      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;, unless the given</span>
<span class="line-modified">400      * buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will</span>
401      * not feature the {@link #WRITE} access mode.
402      * &lt;p&gt;
403      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
404      * for the life-time of the segment.
405      *
406      * @param bb the byte buffer backing the buffer memory segment.
407      * @return a new buffer memory segment.
408      */
409     static MemorySegment ofByteBuffer(ByteBuffer bb) {
410         return AbstractMemorySegmentImpl.ofBuffer(bb);
411     }
412 
413     /**
414      * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
415      * &lt;p&gt;
416      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">417      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

418      *
419      * @param arr the primitive array backing the array memory segment.
420      * @return a new array memory segment.
421      */
422     static MemorySegment ofArray(byte[] arr) {
423         return HeapMemorySegmentImpl.makeArraySegment(arr);
424     }
425 
426     /**
427      * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
428      * &lt;p&gt;
429      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">430      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

431      *
432      * @param arr the primitive array backing the array memory segment.
433      * @return a new array memory segment.
434      */
435     static MemorySegment ofArray(char[] arr) {
436         return HeapMemorySegmentImpl.makeArraySegment(arr);
437     }
438 
439     /**
440      * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
441      * &lt;p&gt;
442      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">443      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

444      *
445      * @param arr the primitive array backing the array memory segment.
446      * @return a new array memory segment.
447      */
448     static MemorySegment ofArray(short[] arr) {
449         return HeapMemorySegmentImpl.makeArraySegment(arr);
450     }
451 
452     /**
453      * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
454      * &lt;p&gt;
455      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
456      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.
457      *
458      * @param arr the primitive array backing the array memory segment.
459      * @return a new array memory segment.
460      */
461     static MemorySegment ofArray(int[] arr) {
462         return HeapMemorySegmentImpl.makeArraySegment(arr);
463     }
464 
465     /**
466      * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
467      * &lt;p&gt;
468      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">469      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

470      *
471      * @param arr the primitive array backing the array memory segment.
472      * @return a new array memory segment.
473      */
474     static MemorySegment ofArray(float[] arr) {
475         return HeapMemorySegmentImpl.makeArraySegment(arr);
476     }
477 
478     /**
479      * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
480      * &lt;p&gt;
481      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">482      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

483      *
484      * @param arr the primitive array backing the array memory segment.
485      * @return a new array memory segment.
486      */
487     static MemorySegment ofArray(long[] arr) {
488         return HeapMemorySegmentImpl.makeArraySegment(arr);
489     }
490 
491     /**
492      * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
493      * &lt;p&gt;
494      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">495      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

496      *
497      * @param arr the primitive array backing the array memory segment.
498      * @return a new array memory segment.
499      */
500     static MemorySegment ofArray(double[] arr) {
501         return HeapMemorySegmentImpl.makeArraySegment(arr);
502     }
503 
504     /**
505      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
506      * &lt;p&gt;
507      * This is equivalent to the following code:
508      * &lt;blockquote&gt;&lt;pre&gt;{@code
509     allocateNative(layout.bytesSize(), layout.bytesAlignment());
510      * }&lt;/pre&gt;&lt;/blockquote&gt;
511      *
512      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
513      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
514      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
515      *
</pre>
<hr />
<pre>
527      * This is equivalent to the following code:
528      * &lt;blockquote&gt;&lt;pre&gt;{@code
529 allocateNative(bytesSize, 1);
530      * }&lt;/pre&gt;&lt;/blockquote&gt;
531      *
532      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
533      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
534      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
535      *
536      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
537      * @return a new native memory segment.
538      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
539      */
540     static MemorySegment allocateNative(long bytesSize) {
541         return allocateNative(bytesSize, 1);
542     }
543 
544     /**
545      * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
546      * &lt;p&gt;
<span class="line-modified">547      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;, unless the given mapping mode</span>
<span class="line-modified">548      * is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case the segment will not feature</span>
<span class="line-modified">549      * the {@link #WRITE} access mode.</span>
550      *
551      * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
552      * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
553      *
554      * @param path the path to the file to memory map.
555      * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
556      * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode
557      *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).
558      * @return a new mapped memory segment.
559      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
560      * @throws UnsupportedOperationException if an unsupported map mode is specified.
561      * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
562      */
563     static MappedMemorySegment mapFromPath(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
564         return MappedMemorySegmentImpl.makeMappedSegment(path, bytesSize, mapMode);
565     }
566 
567     /**
568      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
<span class="line-modified">569      * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

570      *
571      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
572      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
573      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
574      *
575      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
576      * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
577      * @return a new native memory segment.
578      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}, {@code alignmentBytes &lt; 0}, or if {@code alignmentBytes}
579      * is not a power of 2.
580      */
581     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
582         if (bytesSize &lt;= 0) {
583             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
584         }
585 
586         if (alignmentBytes &lt; 0 ||
587                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
588             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
589         }
590 
591         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
592     }
593 
594     /**
595      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
596      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
597      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
598      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
<span class="line-modified">599      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.</span>

600      * &lt;p&gt;
601      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
602      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
603      * restricted methods, and use safe and supported functionalities, where possible.
604      *
605      * @param addr the desired base address
606      * @param bytesSize the desired size.
607      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
608      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
609      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
610      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
611      *                   the returned segment depends on memory which could be released if a certain object
612      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
613      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
614      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
615      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
616      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
617      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
618      * @throws NullPointerException if {@code addr == null}.
619      */
</pre>
<hr />
<pre>
647      * @see MemorySegment#accessModes()
648      * @see MemorySegment#withAccessModes(int)
649      */
650     int CLOSE = WRITE &lt;&lt; 1;
651 
652     /**
653      * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
654      * (see {@link #spliterator(MemorySegment, SequenceLayout)}).
655      * @see MemorySegment#accessModes()
656      * @see MemorySegment#withAccessModes(int)
657      */
658     int ACQUIRE = CLOSE &lt;&lt; 1;
659 
660     /**
661      * Handoff access mode; this segment support serial thread-confinement via thread ownership changes
662      * (see {@link #withOwnerThread(Thread)}).
663      * @see MemorySegment#accessModes()
664      * @see MemorySegment#withAccessModes(int)
665      */
666     int HANDOFF = ACQUIRE &lt;&lt; 1;







667 }
</pre>
</td>
<td>
<hr />
<pre>
379      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
380      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
381      */
382     ByteBuffer asByteBuffer();
383 
384     /**
385      * Copy the contents of this memory segment into a fresh byte array.
386      * @return a fresh byte array copy of this memory segment.
387      * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this
388      * segment&#39;s contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},
389      * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the
390      * thread owning this segment.
391      */
392     byte[] toByteArray();
393 
394     /**
395      * Creates a new buffer memory segment that models the memory associated with the given byte
396      * buffer. The segment starts relative to the buffer&#39;s position (inclusive)
397      * and ends relative to the buffer&#39;s limit (exclusive).
398      * &lt;p&gt;
<span class="line-modified">399      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #ALL_ACCESS}),</span>
<span class="line-modified">400      * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will</span>
401      * not feature the {@link #WRITE} access mode.
402      * &lt;p&gt;
403      * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
404      * for the life-time of the segment.
405      *
406      * @param bb the byte buffer backing the buffer memory segment.
407      * @return a new buffer memory segment.
408      */
409     static MemorySegment ofByteBuffer(ByteBuffer bb) {
410         return AbstractMemorySegmentImpl.ofBuffer(bb);
411     }
412 
413     /**
414      * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
415      * &lt;p&gt;
416      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">417      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">418      * (see {@link #ALL_ACCESS}).</span>
419      *
420      * @param arr the primitive array backing the array memory segment.
421      * @return a new array memory segment.
422      */
423     static MemorySegment ofArray(byte[] arr) {
424         return HeapMemorySegmentImpl.makeArraySegment(arr);
425     }
426 
427     /**
428      * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
429      * &lt;p&gt;
430      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">431      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">432      * (see {@link #ALL_ACCESS}).</span>
433      *
434      * @param arr the primitive array backing the array memory segment.
435      * @return a new array memory segment.
436      */
437     static MemorySegment ofArray(char[] arr) {
438         return HeapMemorySegmentImpl.makeArraySegment(arr);
439     }
440 
441     /**
442      * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
443      * &lt;p&gt;
444      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">445      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">446      * (see {@link #ALL_ACCESS}).</span>
447      *
448      * @param arr the primitive array backing the array memory segment.
449      * @return a new array memory segment.
450      */
451     static MemorySegment ofArray(short[] arr) {
452         return HeapMemorySegmentImpl.makeArraySegment(arr);
453     }
454 
455     /**
456      * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
457      * &lt;p&gt;
458      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
459      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;.
460      *
461      * @param arr the primitive array backing the array memory segment.
462      * @return a new array memory segment.
463      */
464     static MemorySegment ofArray(int[] arr) {
465         return HeapMemorySegmentImpl.makeArraySegment(arr);
466     }
467 
468     /**
469      * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
470      * &lt;p&gt;
471      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">472      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">473      * (see {@link #ALL_ACCESS}).</span>
474      *
475      * @param arr the primitive array backing the array memory segment.
476      * @return a new array memory segment.
477      */
478     static MemorySegment ofArray(float[] arr) {
479         return HeapMemorySegmentImpl.makeArraySegment(arr);
480     }
481 
482     /**
483      * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
484      * &lt;p&gt;
485      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">486      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">487      * (see {@link #ALL_ACCESS}).</span>
488      *
489      * @param arr the primitive array backing the array memory segment.
490      * @return a new array memory segment.
491      */
492     static MemorySegment ofArray(long[] arr) {
493         return HeapMemorySegmentImpl.makeArraySegment(arr);
494     }
495 
496     /**
497      * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
498      * &lt;p&gt;
499      * The resulting memory segment keeps a reference to the backing array, to ensure it remains &lt;em&gt;reachable&lt;/em&gt;
<span class="line-modified">500      * for the life-time of the segment. The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">501      * (see {@link #ALL_ACCESS}).</span>
502      *
503      * @param arr the primitive array backing the array memory segment.
504      * @return a new array memory segment.
505      */
506     static MemorySegment ofArray(double[] arr) {
507         return HeapMemorySegmentImpl.makeArraySegment(arr);
508     }
509 
510     /**
511      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
512      * &lt;p&gt;
513      * This is equivalent to the following code:
514      * &lt;blockquote&gt;&lt;pre&gt;{@code
515     allocateNative(layout.bytesSize(), layout.bytesAlignment());
516      * }&lt;/pre&gt;&lt;/blockquote&gt;
517      *
518      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
519      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
520      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
521      *
</pre>
<hr />
<pre>
533      * This is equivalent to the following code:
534      * &lt;blockquote&gt;&lt;pre&gt;{@code
535 allocateNative(bytesSize, 1);
536      * }&lt;/pre&gt;&lt;/blockquote&gt;
537      *
538      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
539      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
540      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
541      *
542      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
543      * @return a new native memory segment.
544      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
545      */
546     static MemorySegment allocateNative(long bytesSize) {
547         return allocateNative(bytesSize, 1);
548     }
549 
550     /**
551      * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
552      * &lt;p&gt;
<span class="line-modified">553      * The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt; (see {@link #ALL_ACCESS}),</span>
<span class="line-modified">554      * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case</span>
<span class="line-modified">555      * the segment will not feature the {@link #WRITE} access mode.</span>
556      *
557      * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
558      * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
559      *
560      * @param path the path to the file to memory map.
561      * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
562      * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode
563      *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).
564      * @return a new mapped memory segment.
565      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}.
566      * @throws UnsupportedOperationException if an unsupported map mode is specified.
567      * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
568      */
569     static MappedMemorySegment mapFromPath(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
570         return MappedMemorySegmentImpl.makeMappedSegment(path, bytesSize, mapMode);
571     }
572 
573     /**
574      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
<span class="line-modified">575      * alignment constraint (in bytes). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">576      * (see {@link #ALL_ACCESS}).</span>
577      *
578      * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.
579      * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,
580      * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.
581      *
582      * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.
583      * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.
584      * @return a new native memory segment.
585      * @throws IllegalArgumentException if {@code bytesSize &lt; 0}, {@code alignmentBytes &lt; 0}, or if {@code alignmentBytes}
586      * is not a power of 2.
587      */
588     static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {
589         if (bytesSize &lt;= 0) {
590             throw new IllegalArgumentException(&quot;Invalid allocation size : &quot; + bytesSize);
591         }
592 
593         if (alignmentBytes &lt; 0 ||
594                 ((alignmentBytes &amp; (alignmentBytes - 1)) != 0L)) {
595             throw new IllegalArgumentException(&quot;Invalid alignment constraint : &quot; + alignmentBytes);
596         }
597 
598         return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);
599     }
600 
601     /**
602      * Returns a new native memory segment with given base address and size; the returned segment has its own temporal
603      * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
604      * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
605      * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
<span class="line-modified">606      * (often as a plain {@code long} value). The segment will feature all &lt;a href=&quot;#access-modes&quot;&gt;access modes&lt;/a&gt;</span>
<span class="line-added">607      * (see {@link #ALL_ACCESS}).</span>
608      * &lt;p&gt;
609      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
610      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
611      * restricted methods, and use safe and supported functionalities, where possible.
612      *
613      * @param addr the desired base address
614      * @param bytesSize the desired size.
615      * @param owner the desired owner thread. If {@code owner == null}, the returned segment is &lt;em&gt;not&lt;/em&gt; confined.
616      * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the
617      *                returned segment. If {@code cleanup == null}, no cleanup action is executed.
618      * @param attachment an object that must be kept alive by the returned segment; this can be useful when
619      *                   the returned segment depends on memory which could be released if a certain object
620      *                   is determined to be unreacheable. In most cases this will be set to {@code null}.
621      * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.
622      * @throws IllegalArgumentException if {@code bytesSize &lt;= 0}.
623      * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.
624      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
625      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
626      * @throws NullPointerException if {@code addr == null}.
627      */
</pre>
<hr />
<pre>
655      * @see MemorySegment#accessModes()
656      * @see MemorySegment#withAccessModes(int)
657      */
658     int CLOSE = WRITE &lt;&lt; 1;
659 
660     /**
661      * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
662      * (see {@link #spliterator(MemorySegment, SequenceLayout)}).
663      * @see MemorySegment#accessModes()
664      * @see MemorySegment#withAccessModes(int)
665      */
666     int ACQUIRE = CLOSE &lt;&lt; 1;
667 
668     /**
669      * Handoff access mode; this segment support serial thread-confinement via thread ownership changes
670      * (see {@link #withOwnerThread(Thread)}).
671      * @see MemorySegment#accessModes()
672      * @see MemorySegment#withAccessModes(int)
673      */
674     int HANDOFF = ACQUIRE &lt;&lt; 1;
<span class="line-added">675 </span>
<span class="line-added">676     /**</span>
<span class="line-added">677      * Default access mode; this is a union of all the access modes supported by memory segments.</span>
<span class="line-added">678      * @see MemorySegment#accessModes()</span>
<span class="line-added">679      * @see MemorySegment#withAccessModes(int)</span>
<span class="line-added">680      */</span>
<span class="line-added">681     int ALL_ACCESS = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;</span>
682 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
@@ -23,14 +23,18 @@
  *  questions.
  *
  */
 package jdk.incubator.foreign;
 
+import jdk.internal.foreign.AbstractMemorySegmentImpl;
 import jdk.internal.foreign.Utils;
 import jdk.internal.foreign.abi.SharedUtils;
 
+import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
+import java.nio.charset.Charset;
+import java.util.Objects;
 import java.util.function.Consumer;
 
 /**
  * A set of utilities for working with libraries using the C language/ABI
  */
@@ -522,6 +526,153 @@
          * The {@code T*} native type.
          */
         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
     }
+
+    private final static VarHandle byteArrHandle =
+            MemoryLayout.ofSequence(C_CHAR).varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
+
+    /**
+     * Convert a Java string into a null-terminated C string, using the given
+     * {@linkplain java.nio.charset.Charset charset}, storing the result into a
+     * new native memory segment.
+     * <p>
+     * This method always replaces malformed-input and unmappable-character
+     * sequences with this charset's default replacement byte array.  The
+     * {@link java.nio.charset.CharsetEncoder} class should be used when more
+     * control over the encoding process is required.
+     *
+     * @param str the Java string to be converted into a C string.
+     * @return a new native memory segment containing the converted C string.
+     * @throws NullPointerException if either {@code str == null}.
+     */
+    public static MemorySegment toCString(String str) {
+        Objects.requireNonNull(str);
+        return toCString(str.getBytes());
+    }
+
+    /**
+     * Convert a Java string into a null-terminated C string, using the
+     * platform's default charset, storing the result into a new native memory segment.
+     * <p>
+     * This method always replaces malformed-input and unmappable-character
+     * sequences with this charset's default replacement byte array.  The
+     * {@link java.nio.charset.CharsetEncoder} class should be used when more
+     * control over the encoding process is required.
+     *
+     * @param str the Java string to be converted into a C string.
+     * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
+     * @return a new native memory segment containing the converted C string.
+     * @throws NullPointerException if either {@code str == null} or {@code charset == null}.
+     */
+    public static MemorySegment toCString(String str, Charset charset) {
+        Objects.requireNonNull(str);
+        Objects.requireNonNull(charset);
+        return toCString(str.getBytes(charset));
+    }
+
+    /**
+     * Convert a Java string into a null-terminated C string, using the given
+     * {@linkplain java.nio.charset.Charset charset}, storing the result into a
+     * native memory segment allocated using the provided scope.
+     * <p>
+     * This method always replaces malformed-input and unmappable-character
+     * sequences with this charset's default replacement byte array.  The
+     * {@link java.nio.charset.CharsetEncoder} class should be used when more
+     * control over the encoding process is required.
+     *
+     * @param str the Java string to be converted into a C string.
+     * @param scope the scope to be used for the native segment allocation.
+     * @return a new native memory segment containing the converted C string.
+     * @throws NullPointerException if either {@code str == null} or {@code scope == null}.
+     */
+    public static MemoryAddress toCString(String str, NativeScope scope) {
+        Objects.requireNonNull(str);
+        Objects.requireNonNull(scope);
+        return toCString(str.getBytes(), scope);
+    }
+
+    /**
+     * Convert a Java string into a null-terminated C string, using the
+     * platform's default charset, storing the result into a new native memory segment
+     * native memory segment allocated using the provided scope.
+     * <p>
+     * This method always replaces malformed-input and unmappable-character
+     * sequences with this charset's default replacement byte array.  The
+     * {@link java.nio.charset.CharsetEncoder} class should be used when more
+     * control over the encoding process is required.
+     *
+     * @param str the Java string to be converted into a C string.
+     * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
+     * @param scope the scope to be used for the native segment allocation.
+     * @return a new native memory segment containing the converted C string.
+     * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.
+     */
+    public static MemoryAddress toCString(String str, Charset charset, NativeScope scope) {
+        Objects.requireNonNull(str);
+        Objects.requireNonNull(charset);
+        Objects.requireNonNull(scope);
+        return toCString(str.getBytes(charset), scope);
+    }
+
+    /**
+     * Convert a null-terminated C string stored at given address into a Java string.
+     * <p>
+     * This method is <em>restricted</em>. Restricted method are unsafe, and, if used incorrectly, their use might crash
+     * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
+     * restricted methods, and use safe and supported functionalities, where possible.
+     * @param addr the address at which the string is stored.
+     * @return a Java string with the contents of the null-terminated C string at given address.
+     * @throws NullPointerException if {@code addr == null}
+     * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
+     */
+    public static String toJavaStringRestricted(MemoryAddress addr) {
+        Utils.checkRestrictedAccess("CSupport.toJavaStringRestricted");
+        return toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING));
+    }
+
+    /**
+     * Convert a null-terminated C string stored at given address into a Java string.
+     * @param addr the address at which the string is stored.
+     * @return a Java string with the contents of the null-terminated C string at given address.
+     * @throws NullPointerException if {@code addr == null}
+     * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
+     * @throws IllegalStateException if the size of the native string is greater than the size of the segment
+     * associated with {@code addr}, or if {@code addr} is associated with a segment that is </em>not alive<em>.
+     */
+    public static String toJavaString(MemoryAddress addr) {
+        return toJavaStringInternal(addr);
+    }
+
+    private static String toJavaStringInternal(MemoryAddress addr) {
+        StringBuilder buf = new StringBuilder();
+        // iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)
+        for (int offset = 0 ; offset >= 0 ; offset++) {
+            byte curr = (byte) byteArrHandle.get(addr, (long)offset);
+            if (curr == 0) {
+                return buf.toString();
+            }
+            buf.append((char) curr);
+        }
+        throw new IllegalArgumentException("String too large");
+    }
+
+    private static void copy(MemoryAddress addr, byte[] bytes) {
+        var heapSegment = MemorySegment.ofArray(bytes);
+        addr.segment().copyFrom(heapSegment);
+        byteArrHandle.set(addr, (long)bytes.length, (byte)0);
+    }
+
+    private static MemorySegment toCString(byte[] bytes) {
+        MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
+        MemoryAddress addr = segment.baseAddress();
+        copy(addr, bytes);
+        return segment;
+    }
+
+    private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
+        MemoryAddress addr = scope.allocate(bytes.length + 1, 1L);
+        copy(addr, bytes);
+        return addr;
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -509,6 +509,30 @@
         @Override
         AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
             throw new UnsupportedOperationException();
         }
     };
+
+    public static final AbstractMemorySegmentImpl EVERYTHING = new AbstractMemorySegmentImpl(
+            Long.MAX_VALUE, READ | WRITE, MemoryScope.createUnchecked(null, null, null)
+    ) {
+        @Override
+        ByteBuffer makeByteBuffer() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        long min() {
+            return 0;
+        }
+
+        @Override
+        Object base() {
+            return null;
+        }
+
+        @Override
+        AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {
+            throw new UnsupportedOperationException();
+        }
+    };
 }
diff a/test/jdk/java/foreign/Cstring.java b/test/jdk/java/foreign/Cstring.java
--- a/test/jdk/java/foreign/Cstring.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-import java.lang.invoke.VarHandle;
-import java.nio.charset.Charset;
-import jdk.incubator.foreign.NativeScope;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-import static jdk.incubator.foreign.CSupport.C_CHAR;
-
-public final class Cstring {
-    // don't create!
-    private Cstring() {
-    }
-
-    private static VarHandle arrayHandle(MemoryLayout elemLayout, Class<?> elemCarrier) {
-        return MemoryLayout.ofSequence(elemLayout)
-                .varHandle(elemCarrier, MemoryLayout.PathElement.sequenceElement());
-    }
-    private final static VarHandle byteArrHandle = arrayHandle(C_CHAR, byte.class);
-
-    private static void copy(MemoryAddress addr, byte[] bytes) {
-        var heapSegment = MemorySegment.ofArray(bytes);
-        addr.segment().copyFrom(heapSegment);
-        byteArrHandle.set(addr, (long)bytes.length, (byte)0);
-    }
-
-    private static MemorySegment toCString(byte[] bytes) {
-        MemoryLayout strLayout = MemoryLayout.ofSequence(bytes.length + 1, C_CHAR);
-        MemorySegment segment = MemorySegment.allocateNative(strLayout);
-        MemoryAddress addr = segment.baseAddress();
-        copy(addr, bytes);
-        return segment;
-    }
-
-    private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
-        MemoryLayout strLayout = MemoryLayout.ofSequence(bytes.length + 1, C_CHAR);
-        MemoryAddress addr = scope.allocate(strLayout);
-        copy(addr, bytes);
-        return addr;
-    }
-
-    public static void copy(MemoryAddress addr, String str) {
-        copy(addr, str.getBytes());
-    }
-
-    public static void copy(MemoryAddress addr, String str, Charset charset) {
-        copy(addr, str.getBytes(charset));
-    }
-
-    public static MemorySegment toCString(String str) {
-         return toCString(str.getBytes());
-    }
-
-    public static MemorySegment toCString(String str, Charset charset) {
-         return toCString(str.getBytes(charset));
-    }
-
-    public static MemoryAddress toCString(String str, NativeScope scope) {
-        return toCString(str.getBytes(), scope);
-    }
-
-    public static MemoryAddress toCString(String str, Charset charset, NativeScope scope) {
-        return toCString(str.getBytes(charset), scope);
-    }
-
-    public static String toJavaString(MemoryAddress addr) {
-        StringBuilder buf = new StringBuilder();
-        MemoryAddress sizedAddr = addr.segment() != null ?
-                addr :
-                MemorySegment.ofNativeRestricted(addr, Long.MAX_VALUE, Thread.currentThread(),
-                        null, null).baseAddress();
-        byte curr = (byte) byteArrHandle.get(sizedAddr, 0);
-        long offset = 0;
-        while (curr != 0) {
-            buf.append((char) curr);
-            curr = (byte) byteArrHandle.get(sizedAddr, ++offset);
-        }
-        return buf.toString();
-    }
-}
diff a/test/jdk/java/foreign/StdLibTest.java b/test/jdk/java/foreign/StdLibTest.java
--- a/test/jdk/java/foreign/StdLibTest.java
+++ b/test/jdk/java/foreign/StdLibTest.java
@@ -225,11 +225,11 @@
                 char[] chars = s1.toCharArray();
                 for (long i = 0 ; i < chars.length ; i++) {
                     byteArrHandle.set(buf.baseAddress(), i, (byte)chars[(int)i]);
                 }
                 byteArrHandle.set(buf.baseAddress(), (long)chars.length, (byte)'\0');
-                return toJavaString(((MemoryAddress)strcat.invokeExact(buf.baseAddress(), other.baseAddress())).rebase(buf));
+                return toJavaStringRestricted(((MemoryAddress)strcat.invokeExact(buf.baseAddress(), other.baseAddress())));
             }
         }
 
         int strcmp(String s1, String s2) throws Throwable {
             try (MemorySegment ns1 = toCString(s1) ;
@@ -440,14 +440,6 @@
                                 //drop n
                                 perms.stream());
                     }).collect(Collectors.toCollection(LinkedHashSet::new));
         }
     }
-
-    static MemorySegment toCString(String value) {
-        return Cstring.toCString(value);
-    }
-
-    static String toJavaString(MemoryAddress address) {
-        return Cstring.toJavaString(address);
-    }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 

 28 import jdk.internal.foreign.Utils;
 29 import jdk.internal.foreign.abi.SharedUtils;
 30 

 31 import java.nio.ByteOrder;


 32 import java.util.function.Consumer;
 33 
 34 /**
 35  * A set of utilities for working with libraries using the C language/ABI
 36  */
 37 public class CSupport {
 38     /**
 39      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 40      * &lt;p&gt;
 41      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 42      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 43      * restricted methods, and use safe and supported functionalities, where possible.
 44      * @return a linker for this system.
 45      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 46      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 47      */
 48     public static ForeignLinker getSystemLinker() {
 49         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 50         return SharedUtils.getSystemLinker();
 51     }
</pre>
<hr />
<pre>
507                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
508 
509         /**
510          * The {@code double} native type.
511          */
512         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
513                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
514 
515         /**
516          * The {@code long double} native type.
517          */
518         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
519                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
520 
521         /**
522          * The {@code T*} native type.
523          */
524         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
525                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
526     }



















































































































































527 }
</pre>
</td>
<td>
<hr />
<pre>
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
<span class="line-added"> 28 import jdk.internal.foreign.AbstractMemorySegmentImpl;</span>
 29 import jdk.internal.foreign.Utils;
 30 import jdk.internal.foreign.abi.SharedUtils;
 31 
<span class="line-added"> 32 import java.lang.invoke.VarHandle;</span>
 33 import java.nio.ByteOrder;
<span class="line-added"> 34 import java.nio.charset.Charset;</span>
<span class="line-added"> 35 import java.util.Objects;</span>
 36 import java.util.function.Consumer;
 37 
 38 /**
 39  * A set of utilities for working with libraries using the C language/ABI
 40  */
 41 public class CSupport {
 42     /**
 43      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 44      * &lt;p&gt;
 45      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 46      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 47      * restricted methods, and use safe and supported functionalities, where possible.
 48      * @return a linker for this system.
 49      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 50      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 51      */
 52     public static ForeignLinker getSystemLinker() {
 53         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 54         return SharedUtils.getSystemLinker();
 55     }
</pre>
<hr />
<pre>
511                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
512 
513         /**
514          * The {@code double} native type.
515          */
516         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
517                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
518 
519         /**
520          * The {@code long double} native type.
521          */
522         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
523                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
524 
525         /**
526          * The {@code T*} native type.
527          */
528         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
529                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
530     }
<span class="line-added">531 </span>
<span class="line-added">532     private final static VarHandle byteArrHandle =</span>
<span class="line-added">533             MemoryLayout.ofSequence(C_CHAR).varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());</span>
<span class="line-added">534 </span>
<span class="line-added">535     /**</span>
<span class="line-added">536      * Convert a Java string into a null-terminated C string, using the given</span>
<span class="line-added">537      * {@linkplain java.nio.charset.Charset charset}, storing the result into a</span>
<span class="line-added">538      * new native memory segment.</span>
<span class="line-added">539      * &lt;p&gt;</span>
<span class="line-added">540      * This method always replaces malformed-input and unmappable-character</span>
<span class="line-added">541      * sequences with this charset&#39;s default replacement byte array.  The</span>
<span class="line-added">542      * {@link java.nio.charset.CharsetEncoder} class should be used when more</span>
<span class="line-added">543      * control over the encoding process is required.</span>
<span class="line-added">544      *</span>
<span class="line-added">545      * @param str the Java string to be converted into a C string.</span>
<span class="line-added">546      * @return a new native memory segment containing the converted C string.</span>
<span class="line-added">547      * @throws NullPointerException if either {@code str == null}.</span>
<span class="line-added">548      */</span>
<span class="line-added">549     public static MemorySegment toCString(String str) {</span>
<span class="line-added">550         Objects.requireNonNull(str);</span>
<span class="line-added">551         return toCString(str.getBytes());</span>
<span class="line-added">552     }</span>
<span class="line-added">553 </span>
<span class="line-added">554     /**</span>
<span class="line-added">555      * Convert a Java string into a null-terminated C string, using the</span>
<span class="line-added">556      * platform&#39;s default charset, storing the result into a new native memory segment.</span>
<span class="line-added">557      * &lt;p&gt;</span>
<span class="line-added">558      * This method always replaces malformed-input and unmappable-character</span>
<span class="line-added">559      * sequences with this charset&#39;s default replacement byte array.  The</span>
<span class="line-added">560      * {@link java.nio.charset.CharsetEncoder} class should be used when more</span>
<span class="line-added">561      * control over the encoding process is required.</span>
<span class="line-added">562      *</span>
<span class="line-added">563      * @param str the Java string to be converted into a C string.</span>
<span class="line-added">564      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.</span>
<span class="line-added">565      * @return a new native memory segment containing the converted C string.</span>
<span class="line-added">566      * @throws NullPointerException if either {@code str == null} or {@code charset == null}.</span>
<span class="line-added">567      */</span>
<span class="line-added">568     public static MemorySegment toCString(String str, Charset charset) {</span>
<span class="line-added">569         Objects.requireNonNull(str);</span>
<span class="line-added">570         Objects.requireNonNull(charset);</span>
<span class="line-added">571         return toCString(str.getBytes(charset));</span>
<span class="line-added">572     }</span>
<span class="line-added">573 </span>
<span class="line-added">574     /**</span>
<span class="line-added">575      * Convert a Java string into a null-terminated C string, using the given</span>
<span class="line-added">576      * {@linkplain java.nio.charset.Charset charset}, storing the result into a</span>
<span class="line-added">577      * native memory segment allocated using the provided scope.</span>
<span class="line-added">578      * &lt;p&gt;</span>
<span class="line-added">579      * This method always replaces malformed-input and unmappable-character</span>
<span class="line-added">580      * sequences with this charset&#39;s default replacement byte array.  The</span>
<span class="line-added">581      * {@link java.nio.charset.CharsetEncoder} class should be used when more</span>
<span class="line-added">582      * control over the encoding process is required.</span>
<span class="line-added">583      *</span>
<span class="line-added">584      * @param str the Java string to be converted into a C string.</span>
<span class="line-added">585      * @param scope the scope to be used for the native segment allocation.</span>
<span class="line-added">586      * @return a new native memory segment containing the converted C string.</span>
<span class="line-added">587      * @throws NullPointerException if either {@code str == null} or {@code scope == null}.</span>
<span class="line-added">588      */</span>
<span class="line-added">589     public static MemoryAddress toCString(String str, NativeScope scope) {</span>
<span class="line-added">590         Objects.requireNonNull(str);</span>
<span class="line-added">591         Objects.requireNonNull(scope);</span>
<span class="line-added">592         return toCString(str.getBytes(), scope);</span>
<span class="line-added">593     }</span>
<span class="line-added">594 </span>
<span class="line-added">595     /**</span>
<span class="line-added">596      * Convert a Java string into a null-terminated C string, using the</span>
<span class="line-added">597      * platform&#39;s default charset, storing the result into a new native memory segment</span>
<span class="line-added">598      * native memory segment allocated using the provided scope.</span>
<span class="line-added">599      * &lt;p&gt;</span>
<span class="line-added">600      * This method always replaces malformed-input and unmappable-character</span>
<span class="line-added">601      * sequences with this charset&#39;s default replacement byte array.  The</span>
<span class="line-added">602      * {@link java.nio.charset.CharsetEncoder} class should be used when more</span>
<span class="line-added">603      * control over the encoding process is required.</span>
<span class="line-added">604      *</span>
<span class="line-added">605      * @param str the Java string to be converted into a C string.</span>
<span class="line-added">606      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.</span>
<span class="line-added">607      * @param scope the scope to be used for the native segment allocation.</span>
<span class="line-added">608      * @return a new native memory segment containing the converted C string.</span>
<span class="line-added">609      * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.</span>
<span class="line-added">610      */</span>
<span class="line-added">611     public static MemoryAddress toCString(String str, Charset charset, NativeScope scope) {</span>
<span class="line-added">612         Objects.requireNonNull(str);</span>
<span class="line-added">613         Objects.requireNonNull(charset);</span>
<span class="line-added">614         Objects.requireNonNull(scope);</span>
<span class="line-added">615         return toCString(str.getBytes(charset), scope);</span>
<span class="line-added">616     }</span>
<span class="line-added">617 </span>
<span class="line-added">618     /**</span>
<span class="line-added">619      * Convert a null-terminated C string stored at given address into a Java string.</span>
<span class="line-added">620      * &lt;p&gt;</span>
<span class="line-added">621      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash</span>
<span class="line-added">622      * the JVM crash or, worse, silently result in memory corruption. Thus, clients should refrain from depending on</span>
<span class="line-added">623      * restricted methods, and use safe and supported functionalities, where possible.</span>
<span class="line-added">624      * @param addr the address at which the string is stored.</span>
<span class="line-added">625      * @return a Java string with the contents of the null-terminated C string at given address.</span>
<span class="line-added">626      * @throws NullPointerException if {@code addr == null}</span>
<span class="line-added">627      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.</span>
<span class="line-added">628      */</span>
<span class="line-added">629     public static String toJavaStringRestricted(MemoryAddress addr) {</span>
<span class="line-added">630         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);</span>
<span class="line-added">631         return toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING));</span>
<span class="line-added">632     }</span>
<span class="line-added">633 </span>
<span class="line-added">634     /**</span>
<span class="line-added">635      * Convert a null-terminated C string stored at given address into a Java string.</span>
<span class="line-added">636      * @param addr the address at which the string is stored.</span>
<span class="line-added">637      * @return a Java string with the contents of the null-terminated C string at given address.</span>
<span class="line-added">638      * @throws NullPointerException if {@code addr == null}</span>
<span class="line-added">639      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.</span>
<span class="line-added">640      * @throws IllegalStateException if the size of the native string is greater than the size of the segment</span>
<span class="line-added">641      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;/em&gt;not alive&lt;em&gt;.</span>
<span class="line-added">642      */</span>
<span class="line-added">643     public static String toJavaString(MemoryAddress addr) {</span>
<span class="line-added">644         return toJavaStringInternal(addr);</span>
<span class="line-added">645     }</span>
<span class="line-added">646 </span>
<span class="line-added">647     private static String toJavaStringInternal(MemoryAddress addr) {</span>
<span class="line-added">648         StringBuilder buf = new StringBuilder();</span>
<span class="line-added">649         // iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)</span>
<span class="line-added">650         for (int offset = 0 ; offset &gt;= 0 ; offset++) {</span>
<span class="line-added">651             byte curr = (byte) byteArrHandle.get(addr, (long)offset);</span>
<span class="line-added">652             if (curr == 0) {</span>
<span class="line-added">653                 return buf.toString();</span>
<span class="line-added">654             }</span>
<span class="line-added">655             buf.append((char) curr);</span>
<span class="line-added">656         }</span>
<span class="line-added">657         throw new IllegalArgumentException(&quot;String too large&quot;);</span>
<span class="line-added">658     }</span>
<span class="line-added">659 </span>
<span class="line-added">660     private static void copy(MemoryAddress addr, byte[] bytes) {</span>
<span class="line-added">661         var heapSegment = MemorySegment.ofArray(bytes);</span>
<span class="line-added">662         addr.segment().copyFrom(heapSegment);</span>
<span class="line-added">663         byteArrHandle.set(addr, (long)bytes.length, (byte)0);</span>
<span class="line-added">664     }</span>
<span class="line-added">665 </span>
<span class="line-added">666     private static MemorySegment toCString(byte[] bytes) {</span>
<span class="line-added">667         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);</span>
<span class="line-added">668         MemoryAddress addr = segment.baseAddress();</span>
<span class="line-added">669         copy(addr, bytes);</span>
<span class="line-added">670         return segment;</span>
<span class="line-added">671     }</span>
<span class="line-added">672 </span>
<span class="line-added">673     private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {</span>
<span class="line-added">674         MemoryAddress addr = scope.allocate(bytes.length + 1, 1L);</span>
<span class="line-added">675         copy(addr, bytes);</span>
<span class="line-added">676         return addr;</span>
<span class="line-added">677     }</span>
678 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
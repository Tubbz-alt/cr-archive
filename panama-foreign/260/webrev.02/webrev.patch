diff a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
--- a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
+++ b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
@@ -34,30 +34,23 @@
     final boolean be;
 
     /** access size (in bytes, computed from var handle carrier type) **/
     final long length;
 
-    /** access offset (in bytes); must be compatible with {@code alignmentMask} **/
-    final long offset;
-
     /** alignment constraint (in bytes, expressed as a bit mask) **/
     final long alignmentMask;
 
-    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long offset, long alignmentMask) {
+    /** if true, only the base part of the address will be checked for alignment **/
+    final boolean skipAlignmentMaskCheck;
+
+    MemoryAccessVarHandleBase(VarForm form, boolean skipOffetCheck, boolean be, long length, long alignmentMask) {
         super(form);
+        this.skipAlignmentMaskCheck = skipOffetCheck;
         this.be = be;
         this.length = length;
-        this.offset = offset;
         this.alignmentMask = alignmentMask;
     }
 
     static IllegalStateException newIllegalStateExceptionForMisalignedAccess(long address) {
         return new IllegalStateException("Misaligned access at address: " + address);
     }
-
-    /**
-     * Strides used for multi-dimensional access; each stride must be compatible with {@code alignmentMask}.
-     */
-    abstract long[] strides();
-
-    abstract Class<?> carrier();
 }
diff a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
--- a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleGenerator.java
+++ /dev/null
@@ -1,510 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.lang.invoke;
-
-import jdk.internal.access.foreign.MemoryAddressProxy;
-import jdk.internal.org.objectweb.asm.ClassReader;
-import jdk.internal.org.objectweb.asm.ClassWriter;
-import jdk.internal.org.objectweb.asm.ConstantDynamic;
-import jdk.internal.org.objectweb.asm.Handle;
-import jdk.internal.org.objectweb.asm.MethodVisitor;
-import jdk.internal.org.objectweb.asm.Opcodes;
-import jdk.internal.org.objectweb.asm.Type;
-import jdk.internal.org.objectweb.asm.util.TraceClassVisitor;
-import jdk.internal.vm.annotation.ForceInline;
-import sun.security.action.GetBooleanAction;
-import sun.security.action.GetPropertyAction;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.Arrays;
-import java.util.HashMap;
-
-import static jdk.internal.org.objectweb.asm.Opcodes.AALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;
-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.ASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.BIPUSH;
-import static jdk.internal.org.objectweb.asm.Opcodes.CHECKCAST;
-import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;
-import static jdk.internal.org.objectweb.asm.Opcodes.GETSTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_1;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_2;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_3;
-import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.LALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.LASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.LLOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.NEWARRAY;
-import static jdk.internal.org.objectweb.asm.Opcodes.PUTFIELD;
-import static jdk.internal.org.objectweb.asm.Opcodes.PUTSTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP;
-import static jdk.internal.org.objectweb.asm.Opcodes.SIPUSH;
-import static jdk.internal.org.objectweb.asm.Opcodes.T_LONG;
-import static jdk.internal.org.objectweb.asm.Opcodes.V14;
-
-class MemoryAccessVarHandleGenerator {
-    private static final String DEBUG_DUMP_CLASSES_DIR_PROPERTY = "jdk.internal.foreign.ClassGenerator.DEBUG_DUMP_CLASSES_DIR";
-
-    private static final boolean DEBUG =
-        GetBooleanAction.privilegedGetProperty("jdk.internal.foreign.ClassGenerator.DEBUG");
-
-    private static final Class<?> BASE_CLASS = MemoryAccessVarHandleBase.class;
-
-    private static final HashMap<Class<?>, Class<?>> helperClassCache;
-
-    private final static MethodType OFFSET_OP_TYPE;
-
-    private final static MethodHandle ADD_OFFSETS_HANDLE;
-    private final static MethodHandle MUL_OFFSETS_HANDLE;
-
-    static {
-        helperClassCache = new HashMap<>();
-        helperClassCache.put(byte.class, MemoryAccessVarHandleByteHelper.class);
-        helperClassCache.put(short.class, MemoryAccessVarHandleShortHelper.class);
-        helperClassCache.put(char.class, MemoryAccessVarHandleCharHelper.class);
-        helperClassCache.put(int.class, MemoryAccessVarHandleIntHelper.class);
-        helperClassCache.put(long.class, MemoryAccessVarHandleLongHelper.class);
-        helperClassCache.put(float.class, MemoryAccessVarHandleFloatHelper.class);
-        helperClassCache.put(double.class, MemoryAccessVarHandleDoubleHelper.class);
-
-        OFFSET_OP_TYPE = MethodType.methodType(long.class, long.class, long.class, MemoryAddressProxy.class);
-
-        try {
-            ADD_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "addOffsets", OFFSET_OP_TYPE);
-            MUL_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, "multiplyOffsets", OFFSET_OP_TYPE);
-        } catch (Throwable ex) {
-            throw new ExceptionInInitializerError(ex);
-        }
-    }
-
-    private static final File DEBUG_DUMP_CLASSES_DIR;
-
-    static {
-        String path = GetPropertyAction.privilegedGetProperty(DEBUG_DUMP_CLASSES_DIR_PROPERTY);
-        if (path == null) {
-            DEBUG_DUMP_CLASSES_DIR = null;
-        } else {
-            DEBUG_DUMP_CLASSES_DIR = new File(path);
-        }
-    }
-
-    private final String implClassName;
-    private final int dimensions;
-    private final Class<?> carrier;
-    private final Class<?> helperClass;
-    private final VarForm form;
-    private final Object[] classData;
-
-    MemoryAccessVarHandleGenerator(Class<?> carrier, int dims) {
-        this.dimensions = dims;
-        this.carrier = carrier;
-        Class<?>[] components = new Class<?>[dimensions];
-        Arrays.fill(components, long.class);
-        this.form = new VarForm(BASE_CLASS, MemoryAddressProxy.class, carrier, components);
-        this.helperClass = helperClassCache.get(carrier);
-        this.implClassName = helperClass.getName().replace('.', '/') + dimensions;
-        // live constants
-        Class<?>[] intermediate = new Class<?>[dimensions];
-        Arrays.fill(intermediate, long.class);
-        this.classData = new Object[] { carrier, intermediate, ADD_OFFSETS_HANDLE, MUL_OFFSETS_HANDLE };
-    }
-
-    /*
-     * Generate a VarHandle memory access factory.
-     * The factory has type (ZJJ[J)VarHandle.
-     */
-    MethodHandle generateHandleFactory() {
-        byte[] classBytes = generateClassBytes();
-        if (DEBUG_DUMP_CLASSES_DIR != null) {
-            debugWriteClassToFile(classBytes);
-        }
-        try {
-            MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClassWithClassData(classBytes, classData);
-            Class<?> implCls = lookup.lookupClass();
-            Class<?>[] components = new Class<?>[dimensions];
-            Arrays.fill(components, long.class);
-
-            VarForm form = new VarForm(implCls, MemoryAddressProxy.class, carrier, components);
-
-            MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
-            MethodHandle constr = lookup.findConstructor(implCls, constrType);
-            constr = MethodHandles.insertArguments(constr, 0, form);
-            return constr;
-        } catch (Throwable ex) {
-            debugPrintClass(classBytes);
-            throw new AssertionError(ex);
-        }
-    }
-
-    /*
-     * Generate a specialized VarHandle class for given carrier
-     * and access coordinates.
-     */
-    byte[] generateClassBytes() {
-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
-
-        if (DEBUG) {
-            System.out.println("Generating header implementation class");
-        }
-
-        cw.visit(V14, ACC_PUBLIC | ACC_SUPER, implClassName, null, Type.getInternalName(BASE_CLASS), null);
-
-        //add dimension fields
-        for (int i = 0; i < dimensions; i++) {
-            cw.visitField(ACC_PRIVATE | ACC_FINAL, "dim" + i, "J", null, null);
-        }
-
-        addStaticInitializer(cw);
-
-        addConstructor(cw);
-
-        addAccessModeTypeMethod(cw);
-
-        addStridesAccessor(cw);
-
-        addCarrierAccessor(cw);
-
-        for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {
-            addAccessModeMethodIfNeeded(mode, cw);
-        }
-
-        cw.visitEnd();
-        return cw.toByteArray();
-    }
-
-    void addStaticInitializer(ClassWriter cw) {
-        // carrier and intermediate
-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, "carrier", Class.class.descriptorString(), null, null);
-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, "intermediate", Class[].class.descriptorString(), null, null);
-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, "addHandle", MethodHandle.class.descriptorString(), null, null);
-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, "mulHandle", MethodHandle.class.descriptorString(), null, null);
-
-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
-        mv.visitCode();
-        // extract class data in static final fields
-        MethodType mtype = MethodType.methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);
-        Handle bsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), "classData",
-                    mtype.descriptorString(), false);
-        ConstantDynamic dynamic = new ConstantDynamic("classData", Object[].class.descriptorString(), bsm);
-        mv.visitLdcInsn(dynamic);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Object[].class));
-        mv.visitVarInsn(ASTORE, 0);
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitInsn(ICONST_0);
-        mv.visitInsn(AALOAD);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
-        mv.visitFieldInsn(PUTSTATIC, implClassName, "carrier", Class.class.descriptorString());
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitInsn(ICONST_1);
-        mv.visitInsn(AALOAD);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class[].class));
-        mv.visitFieldInsn(PUTSTATIC, implClassName, "intermediate", Class[].class.descriptorString());
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitInsn(ICONST_2);
-        mv.visitInsn(AALOAD);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
-        mv.visitFieldInsn(PUTSTATIC, implClassName, "addHandle", MethodHandle.class.descriptorString());
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitInsn(ICONST_3);
-        mv.visitInsn(AALOAD);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
-        mv.visitFieldInsn(PUTSTATIC, implClassName, "mulHandle", MethodHandle.class.descriptorString());
-        mv.visitInsn(Opcodes.RETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addConstructor(ClassWriter cw) {
-        MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);
-        MethodVisitor mv = cw.visitMethod(0, "<init>", constrType.toMethodDescriptorString(), null, null);
-        mv.visitCode();
-        //super call
-        mv.visitVarInsn(ALOAD, 0);
-        mv.visitVarInsn(ALOAD, 1);
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(VarForm.class));
-        mv.visitVarInsn(ILOAD, 2);
-        mv.visitVarInsn(LLOAD, 3);
-        mv.visitVarInsn(LLOAD, 5);
-        mv.visitVarInsn(LLOAD, 7);
-        mv.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(BASE_CLASS), "<init>",
-                MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class).toMethodDescriptorString(), false);
-        //init dimensions
-        for (int i = 0 ; i < dimensions ; i++) {
-            mv.visitVarInsn(ALOAD, 0);
-            mv.visitVarInsn(ALOAD, 9);
-            mv.visitLdcInsn(i);
-            mv.visitInsn(LALOAD);
-            mv.visitFieldInsn(PUTFIELD, implClassName, "dim" + i, "J");
-        }
-        mv.visitInsn(RETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addAccessModeTypeMethod(ClassWriter cw) {
-        MethodType modeMethType = MethodType.methodType(MethodType.class, VarHandle.AccessMode.class);
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "accessModeTypeUncached", modeMethType.toMethodDescriptorString(), null, null);
-        mv.visitCode();
-        mv.visitVarInsn(ALOAD, 1);
-        mv.visitFieldInsn(GETFIELD, Type.getInternalName(VarHandle.AccessMode.class), "at", VarHandle.AccessType.class.descriptorString());
-        mv.visitLdcInsn(Type.getType(MemoryAddressProxy.class));
-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));
-        mv.visitFieldInsn(GETSTATIC, implClassName, "carrier", Class.class.descriptorString());
-        mv.visitFieldInsn(GETSTATIC, implClassName, "intermediate", Class[].class.descriptorString());
-
-        mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(VarHandle.AccessType.class),
-                "accessModeType", MethodType.methodType(MethodType.class, Class.class, Class.class, Class[].class).toMethodDescriptorString(), false);
-
-        mv.visitInsn(ARETURN);
-
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addAccessModeMethodIfNeeded(VarHandle.AccessMode mode, ClassWriter cw) {
-        String methName = mode.methodName();
-        MethodType methType = form.getMethodType(mode.at.ordinal())
-                .insertParameterTypes(0, VarHandle.class);
-
-        try {
-            MethodType helperType = methType.insertParameterTypes(2, long.class);
-            if (dimensions > 0) {
-                helperType = helperType.dropParameterTypes(3, 3 + dimensions);
-            }
-            //try to resolve...
-            String helperMethodName = methName + "0";
-            MethodHandles.Lookup.IMPL_LOOKUP
-                    .findStatic(helperClass,
-                            helperMethodName,
-                            helperType);
-
-
-            MethodVisitor mv = cw.visitMethod(ACC_STATIC, methName, methType.toMethodDescriptorString(), null, null);
-            mv.visitAnnotation(Type.getDescriptor(ForceInline.class), true);
-            mv.visitCode();
-
-            mv.visitVarInsn(ALOAD, 0); // handle impl
-            mv.visitVarInsn(ALOAD, 1); // receiver
-
-            // offset calculation
-            int slot = 2;
-            mv.visitVarInsn(ALOAD, 0); // load recv
-            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(BASE_CLASS));
-            mv.visitFieldInsn(GETFIELD, Type.getInternalName(BASE_CLASS), "offset", "J");
-            for (int i = 0 ; i < dimensions ; i++) {
-                // load ADD MH
-                mv.visitFieldInsn(GETSTATIC, implClassName, "addHandle", MethodHandle.class.descriptorString());
-
-                //fixup stack so that ADD MH ends up bottom
-                mv.visitInsn(Opcodes.DUP_X2);
-                mv.visitInsn(Opcodes.POP);
-
-                // load MUL MH
-                mv.visitFieldInsn(GETSTATIC, implClassName, "mulHandle", MethodHandle.class.descriptorString());
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));
-
-                mv.visitVarInsn(ALOAD, 0); // load recv
-                mv.visitTypeInsn(CHECKCAST, implClassName);
-                mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
-                mv.visitVarInsn(LLOAD, slot);
-
-                mv.visitVarInsn(ALOAD, 1); // receiver
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
-
-                //MUL
-                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
-                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
-
-                mv.visitVarInsn(ALOAD, 1); // receiver
-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));
-
-                //ADD
-                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), "invokeExact",
-                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);
-                slot += 2;
-            }
-
-            for (int i = 2 + dimensions; i < methType.parameterCount() ; i++) {
-                Class<?> param = methType.parameterType(i);
-                mv.visitVarInsn(loadInsn(param), slot); // load index
-                slot += getSlotsForType(param);
-            }
-
-            //call helper
-            mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(helperClass), helperMethodName,
-                    helperType.toMethodDescriptorString(), false);
-
-            mv.visitInsn(returnInsn(helperType.returnType()));
-
-            mv.visitMaxs(0, 0);
-            mv.visitEnd();
-        } catch (ReflectiveOperationException ex) {
-            //not found, skip
-        }
-    }
-
-    void addStridesAccessor(ClassWriter cw) {
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "strides", "()[J", null, null);
-        mv.visitCode();
-        iConstInsn(mv, dimensions);
-        mv.visitIntInsn(NEWARRAY, T_LONG);
-
-        for (int i = 0 ; i < dimensions ; i++) {
-            mv.visitInsn(DUP);
-            iConstInsn(mv, i);
-            mv.visitVarInsn(ALOAD, 0);
-            mv.visitFieldInsn(GETFIELD, implClassName, "dim" + i, "J");
-            mv.visitInsn(LASTORE);
-        }
-
-        mv.visitInsn(ARETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    void addCarrierAccessor(ClassWriter cw) {
-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, "carrier", "()Ljava/lang/Class;", null, null);
-        mv.visitCode();
-        mv.visitFieldInsn(GETSTATIC, implClassName, "carrier", Class.class.descriptorString());
-        mv.visitInsn(ARETURN);
-        mv.visitMaxs(0, 0);
-        mv.visitEnd();
-    }
-
-    // shared code generation helpers
-
-    private static int getSlotsForType(Class<?> c) {
-        if (c == long.class || c == double.class) {
-            return 2;
-        }
-        return 1;
-    }
-
-    /**
-     * Emits an actual return instruction conforming to the given return type.
-     */
-    private int returnInsn(Class<?> type) {
-        return switch (LambdaForm.BasicType.basicType(type)) {
-            case I_TYPE -> Opcodes.IRETURN;
-            case J_TYPE -> Opcodes.LRETURN;
-            case F_TYPE -> Opcodes.FRETURN;
-            case D_TYPE -> Opcodes.DRETURN;
-            case L_TYPE -> Opcodes.ARETURN;
-            case V_TYPE -> RETURN;
-        };
-    }
-
-    private int loadInsn(Class<?> type) {
-        return switch (LambdaForm.BasicType.basicType(type)) {
-            case I_TYPE -> Opcodes.ILOAD;
-            case J_TYPE -> LLOAD;
-            case F_TYPE -> Opcodes.FLOAD;
-            case D_TYPE -> Opcodes.DLOAD;
-            case L_TYPE -> Opcodes.ALOAD;
-            case V_TYPE -> throw new IllegalStateException("Cannot load void");
-        };
-    }
-
-    private static void iConstInsn(MethodVisitor mv, int i) {
-        switch (i) {
-            case -1, 0, 1, 2, 3, 4, 5:
-                mv.visitInsn(ICONST_0 + i);
-                break;
-            default:
-                if(i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE) {
-                    mv.visitIntInsn(BIPUSH, i);
-                } else if (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {
-                    mv.visitIntInsn(SIPUSH, i);
-                } else {
-                    mv.visitLdcInsn(i);
-                }
-        }
-    }
-
-    // debug helpers
-
-    private static String debugPrintClass(byte[] classFile) {
-        ClassReader cr = new ClassReader(classFile);
-        StringWriter sw = new StringWriter();
-        cr.accept(new TraceClassVisitor(new PrintWriter(sw)), 0);
-        return sw.toString();
-    }
-
-    private void debugWriteClassToFile(byte[] classFile) {
-        File file = new File(DEBUG_DUMP_CLASSES_DIR, implClassName + ".class");
-
-        if (DEBUG) {
-            System.err.println("Dumping class " + implClassName + " to " + file);
-        }
-
-        try {
-            debugWriteDataToFile(classFile, file);
-        } catch (Exception e) {
-            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
-        }
-    }
-
-    private void debugWriteDataToFile(byte[] data, File file) {
-        if (file.exists()) {
-            file.delete();
-        }
-        if (file.exists()) {
-            throw new RuntimeException("Failed to remove pre-existing file " + file);
-        }
-
-        File parent = file.getParentFile();
-        if (!parent.exists()) {
-            parent.mkdirs();
-        }
-        if (!parent.exists()) {
-            throw new RuntimeException("Failed to create " + parent);
-        }
-        if (!parent.isDirectory()) {
-            throw new RuntimeException(parent + " is not a directory");
-        }
-
-        try (FileOutputStream fos = new FileOutputStream(file)) {
-            fos.write(data);
-        } catch (IOException e) {
-            throw new RuntimeException("Failed to write class " + implClassName + " to file " + file);
-        }
-    }
-}
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
@@ -1800,44 +1800,13 @@
                         .generateInvokersHolderClassBytes(className,
                                 invokerMethodTypes, callSiteMethodTypes);
             }
 
             @Override
-            public VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask,
-                                                   ByteOrder order, long offset, long[] strides) {
-                return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);
-            }
-
-            @Override
-            public Class<?> memoryAddressCarrier(VarHandle handle) {
-                return checkMemoryAccessHandle(handle).carrier();
-            }
-
-            @Override
-            public long memoryAddressAlignmentMask(VarHandle handle) {
-                return checkMemoryAccessHandle(handle).alignmentMask;
-            }
-
-            @Override
-            public ByteOrder memoryAddressByteOrder(VarHandle handle) {
-                return checkMemoryAccessHandle(handle).be ?
-                        ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
-            }
-
-            @Override
-            public long memoryAddressOffset(VarHandle handle) {
-                return checkMemoryAccessHandle(handle).offset;
-            }
-
-            @Override
-            public long[] memoryAddressStrides(VarHandle handle) {
-                return checkMemoryAccessHandle(handle).strides();
-            }
-
-            @Override
-            public boolean isMemoryAccessVarHandle(VarHandle handle) {
-                return asMemoryAccessVarHandle(handle) != null;
+            public VarHandle memoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,
+                                                   ByteOrder order) {
+                return VarHandles.makeMemoryAddressViewHandle(carrier, skipAlignmentMaskCheck, alignmentMask, order);
             }
 
             @Override
             public VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {
                 return VarHandles.filterValue(target, filterToTarget, filterFromTarget);
@@ -1865,30 +1834,10 @@
 
             @Override
             public VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
                 return VarHandles.insertCoordinates(target, pos, values);
             }
-
-            private MemoryAccessVarHandleBase asMemoryAccessVarHandle(VarHandle handle) {
-                if (handle instanceof MemoryAccessVarHandleBase) {
-                    return (MemoryAccessVarHandleBase)handle;
-                } else if (handle.target() instanceof MemoryAccessVarHandleBase) {
-                    // skip first adaptation, since we have to step over MemoryAddressProxy
-                    // see JDK-8237349
-                    return (MemoryAccessVarHandleBase)handle.target();
-                } else {
-                    return null;
-                }
-            }
-
-            private MemoryAccessVarHandleBase checkMemoryAccessHandle(VarHandle handle) {
-                MemoryAccessVarHandleBase base = asMemoryAccessVarHandle(handle);
-                if (base == null) {
-                    throw new IllegalArgumentException("Not a memory access varhandle: " + handle);
-                }
-                return base;
-            }
         });
     }
 
     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
     private static MethodHandle unboxResultHandle(Class<?> returnType) {
diff a/src/java.base/share/classes/java/lang/invoke/VarHandles.java b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
@@ -309,33 +309,39 @@
      *
      * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added
      * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.
      *
      * @param carrier the Java carrier type.
+     * @param skipAlignmentMaskCheck if true, only the base part of the address will be checked for alignment.
      * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.
      * @param byteOrder the byte order.
-     * @param offset a constant offset for the access.
-     * @param strides the scale factors with which to multiply given access coordinates.
      * @return the created VarHandle.
      */
-    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, long alignmentMask,
-                                                 ByteOrder byteOrder, long offset, long[] strides) {
+    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,
+                                                 ByteOrder byteOrder) {
         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
             throw new IllegalArgumentException("Invalid carrier: " + carrier.getName());
         }
         long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
 
-        Map<Integer, MethodHandle> carrierFactory = ADDRESS_FACTORIES.get(carrier);
-        MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
-                dims -> new MemoryAccessVarHandleGenerator(carrier, dims)
-                            .generateHandleFactory());
-
-        try {
-            return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));
-        } catch (Throwable ex) {
-            throw new IllegalStateException(ex);
+        if (carrier == byte.class) {
+            return maybeAdapt(new MemoryAccessVarHandleByteHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == char.class) {
+            return maybeAdapt(new MemoryAccessVarHandleCharHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == short.class) {
+            return maybeAdapt(new MemoryAccessVarHandleShortHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == int.class) {
+            return maybeAdapt(new MemoryAccessVarHandleIntHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == float.class) {
+            return maybeAdapt(new MemoryAccessVarHandleFloatHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == long.class) {
+            return maybeAdapt(new MemoryAccessVarHandleLongHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else if (carrier == double.class) {
+            return maybeAdapt(new MemoryAccessVarHandleDoubleHelper(skipAlignmentMaskCheck, be, size, alignmentMask));
+        } else {
+            throw new IllegalStateException("Cannot get here");
         }
     }
 
     private static VarHandle maybeAdapt(VarHandle target) {
         if (!VAR_HANDLE_IDENTITY_ADAPT) return target;
diff a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
--- a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
+++ b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
@@ -22,25 +22,36 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package java.lang.invoke;
 
-import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.vm.annotation.ForceInline;
 
 import java.util.Objects;
 
 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 
 #warn
 
-final class MemoryAccessVarHandle$Type$Helper {
+final class MemoryAccessVarHandle$Type$Helper extends MemoryAccessVarHandleBase {
 
     static final boolean BE = UNSAFE.isBigEndian();
 
     static final int VM_ALIGN = $BoxType$.BYTES - 1;
 
+    static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegmentProxy.class, $type$.class, long.class);
+
+    MemoryAccessVarHandle$Type$Helper(boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask) {
+        super(FORM, skipAlignmentMaskCheck, be, length, alignmentMask);
+    }
+
+    @Override
+    final MethodType accessModeTypeUncached(AccessMode accessMode) {
+        return accessMode.at.accessModeType(MemorySegmentProxy.class, $type$.class, long.class);
+    }
+
 #if[floatingPoint]
     @ForceInline
     static $rawType$ convEndian(boolean big, $type$ v) {
         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
@@ -64,309 +75,315 @@
     }
 #end[byte]
 #end[floatingPoint]
 
     @ForceInline
-    static MemoryAddressProxy checkAddress(Object obb, long offset, long length, boolean ro) {
-        MemoryAddressProxy oo = (MemoryAddressProxy)Objects.requireNonNull(obb);
+    static MemorySegmentProxy checkAddress(Object obb, long offset, long length, boolean ro) {
+        MemorySegmentProxy oo = (MemorySegmentProxy)Objects.requireNonNull(obb);
         oo.checkAccess(offset, length, ro);
         return oo;
     }
-    
+
     @ForceInline
-    static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {
-        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);
+    static long offset(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {
+        long address = offsetNoVMAlignCheck(skipAlignmentMaskCheck, bb, offset, alignmentMask);
         if ((address & VM_ALIGN) != 0) {
             throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
         }
         return address;
     }
 
     @ForceInline
-    static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {
+    static long offsetNoVMAlignCheck(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {
         long base = bb.unsafeGetOffset();
         long address = base + offset;
-        //note: the offset portion has already been aligned-checked, by construction
-        if ((base & alignmentMask) != 0) {
-            throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
+        if (skipAlignmentMaskCheck) {
+            //note: the offset portion has already been aligned-checked, by construction
+            if ((base & alignmentMask) != 0) {
+                throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
+            }
+        } else {
+            if ((address & alignmentMask) != 0) {
+                throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
+            }
         }
         return address;
     }
-    
+
     @ForceInline
-    static $type$ get0(VarHandle ob, Object obb, long base) {
+    static $type$ get(VarHandle ob, Object obb, long base) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
 #if[floatingPoint]
         $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 handle.be);
         return $Type$.$rawType$BitsTo$Type$(rawValue);
 #else[floatingPoint]
 #if[byte]
         return UNSAFE.get$Type$(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask));
 #else[byte]
         return UNSAFE.get$Type$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 handle.be);
 #end[byte]
 #end[floatingPoint]
     }
 
     @ForceInline
-    static void set0(VarHandle ob, Object obb, long base, $type$ value) {
+    static void set(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
 #if[floatingPoint]
         UNSAFE.put$RawType$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 $Type$.$type$ToRaw$RawType$Bits(value),
                 handle.be);
 #else[floatingPoint]
 #if[byte]
         UNSAFE.put$Type$(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 value);
 #else[byte]
         UNSAFE.put$Type$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 value,
                 handle.be);
 #end[byte]
 #end[floatingPoint]
     }
 
     @ForceInline
-    static $type$ getVolatile0(VarHandle ob, Object obb, long base) {
+    static $type$ getVolatile(VarHandle ob, Object obb, long base) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
         return convEndian(handle.be,
                           UNSAFE.get$RawType$Volatile(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));
     }
 
     @ForceInline
-    static void setVolatile0(VarHandle ob, Object obb, long base, $type$ value) {
+    static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         UNSAFE.put$RawType$Volatile(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, value));
     }
 
     @ForceInline
-    static $type$ getAcquire0(VarHandle ob, Object obb, long base) {
+    static $type$ getAcquire(VarHandle ob, Object obb, long base) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
         return convEndian(handle.be,
                           UNSAFE.get$RawType$Acquire(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));
     }
 
     @ForceInline
-    static void setRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+    static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         UNSAFE.put$RawType$Release(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, value));
     }
 
     @ForceInline
-    static $type$ getOpaque0(VarHandle ob, Object obb, long base) {
+    static $type$ getOpaque(VarHandle ob, Object obb, long base) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
         return convEndian(handle.be,
                           UNSAFE.get$RawType$Opaque(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask)));
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));
     }
 
     @ForceInline
-    static void setOpaque0(VarHandle ob, Object obb, long base, $type$ value) {
+    static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         UNSAFE.put$RawType$Opaque(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, value));
     }
 #if[CAS]
 
     @ForceInline
-    static boolean compareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.compareAndSet$RawType$(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
-    static $type$ compareAndExchange0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.compareAndExchange$RawType$(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
     }
 
     @ForceInline
-    static $type$ compareAndExchangeAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.compareAndExchange$RawType$Acquire(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
     }
 
     @ForceInline
-    static $type$ compareAndExchangeRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.compareAndExchange$RawType$Release(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
     }
 
     @ForceInline
-    static boolean weakCompareAndSetPlain0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$Plain(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
-    static boolean weakCompareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
-    static boolean weakCompareAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$Acquire(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
-    static boolean weakCompareAndSetRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
+    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$Release(
                 bb.unsafeGetBase(),
-                offset(bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
-    static $type$ getAndSet0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.getAndSet$RawType$(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, value)));
     }
 
     @ForceInline
-    static $type$ getAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.getAndSet$RawType$Acquire(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, value)));
     }
 
     @ForceInline
-    static $type$ getAndSetRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.getAndSet$RawType$Release(
                                   bb.unsafeGetBase(),
-                                  offset(bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, value)));
     }
 #end[CAS]
 #if[AtomicAdd]
 
     @ForceInline
-    static $type$ getAndAdd0(VarHandle ob, Object obb, long base, $type$ delta) {
+    static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndAdd$RawType$(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     delta);
         } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);
         }
     }
 
     @ForceInline
-    static $type$ getAndAddAcquire0(VarHandle ob, Object obb, long base, $type$ delta) {
+    static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndAdd$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     delta);
         } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);
         }
     }
 
     @ForceInline
-    static $type$ getAndAddRelease0(VarHandle ob, Object obb, long base, $type$ delta) {
+    static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndAdd$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     delta);
         } else {
-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);
         }
     }
 
     @ForceInline
-    static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {
+    static $type$ getAndAddConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ delta) {
         $type$ nativeExpectedValue, expectedValue;
         Object base = bb.unsafeGetBase();
         do {
             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
@@ -376,53 +393,53 @@
     }
 #end[AtomicAdd]
 #if[Bitwise]
 
     @ForceInline
-    static $type$ getAndBitwiseOr0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseOr$RawType$(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseOrRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseOr$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseOrAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseOr$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+    static $type$ getAndBitwiseOrConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
         $type$ nativeExpectedValue, expectedValue;
         Object base = bb.unsafeGetBase();
         do {
             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
@@ -430,53 +447,53 @@
                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
         return expectedValue;
     }
 
     @ForceInline
-    static $type$ getAndBitwiseAnd0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseAnd$RawType$(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseAndRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseAnd$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseAndAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+    static $type$ getAndBitwiseAndConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
         $type$ nativeExpectedValue, expectedValue;
         Object base = bb.unsafeGetBase();
         do {
             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
@@ -485,53 +502,53 @@
         return expectedValue;
     }
 
 
     @ForceInline
-    static $type$ getAndBitwiseXor0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseXor$RawType$(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseXorRelease0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseXor$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseXorAcquire0(VarHandle ob, Object obb, long base, $type$ value) {
+    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseXor$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
-    static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
+    static $type$ getAndBitwiseXorConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
         $type$ nativeExpectedValue, expectedValue;
         Object base = bb.unsafeGetBase();
         do {
             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
diff a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
@@ -113,48 +113,12 @@
     /**
      * Returns a var handle view of a given memory address.
      * Used by {@code jdk.internal.foreign.LayoutPath} and
      * {@code jdk.incubator.foreign.MemoryHandles}.
      */
-    VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask,
-                                    ByteOrder order, long offset, long[] strides);
-
-    /**
-     * Is {@code handle} a memory access varhandle?
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    boolean isMemoryAccessVarHandle(VarHandle handle);
-
-    /**
-     * Returns the carrier associated with a memory access var handle.
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    Class<?> memoryAddressCarrier(VarHandle handle);
-
-    /**
-     * Returns the alignment mask associated with a memory access var handle.
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    long memoryAddressAlignmentMask(VarHandle handle);
-
-    /**
-     * Returns the byte order associated with a memory access var handle.
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    ByteOrder memoryAddressByteOrder(VarHandle handle);
-
-    /**
-     * Returns the offset associated with a memory access var handle.
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    long memoryAddressOffset(VarHandle handle);
-
-    /**
-     * Returns the strides associated with a memory access var handle.
-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.
-     */
-    long[] memoryAddressStrides(VarHandle handle);
+    VarHandle memoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,
+                                    ByteOrder order);
 
     /**
      * Var handle carrier combinator.
      * Used by {@code jdk.incubator.foreign.MemoryHandles}.
      */
diff a/src/java.base/share/classes/jdk/internal/access/foreign/MemorySegmentProxy.java b/src/java.base/share/classes/jdk/internal/access/foreign/MemorySegmentProxy.java
--- a/src/java.base/share/classes/jdk/internal/access/foreign/MemorySegmentProxy.java
+++ b/src/java.base/share/classes/jdk/internal/access/foreign/MemorySegmentProxy.java
@@ -30,6 +30,72 @@
  * This proxy interface is required to allow instances of the {@code MemorySegment} interface (which is defined inside
  * an incubating module) to be accessed from the memory access var handles.
  */
 public interface MemorySegmentProxy {
     void checkValidState();
+
+    /**
+     * Check that memory access is within spatial and temporal bounds.
+     * @throws IllegalStateException if underlying segment has been closed already.
+     * @throws IndexOutOfBoundsException if access is out-of-bounds.
+     */
+    void checkAccess(long offset, long length, boolean readOnly);
+    long unsafeGetOffset();
+    Object unsafeGetBase();
+    boolean isSmall();
+
+    /* Helper functions for offset computations. These are required so that we can avoid issuing long opcodes
+     * (e.g. LMUL, LADD) when we're operating on 'small' segments (segments whose length can be expressed with an int).
+     * C2 BCE code is very sensitive to the kind of opcode being emitted, and this workaround allows us to rescue
+     * BCE when working with small segments. This workaround should be dropped when JDK-8223051 is resolved.
+     */
+
+    static long addOffsets(long op1, long op2, MemorySegmentProxy segmentProxy) {
+        if (segmentProxy.isSmall()) {
+            // force ints for BCE
+            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE
+                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {
+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);
+            }
+            int i1 = (int)op1;
+            int i2 = (int)op2;
+            try {
+                return Math.addExact(i1, i2);
+            } catch (ArithmeticException ex) {
+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);
+            }
+        } else {
+            try {
+                return Math.addExact(op1, op2);
+            } catch (ArithmeticException ex) {
+                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);
+            }
+        }
+    }
+
+    static long multiplyOffsets(long op1, long op2, MemorySegmentProxy segmentProxy) {
+        if (segmentProxy.isSmall()) {
+            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE
+                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {
+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);
+            }
+            // force ints for BCE
+            int i1 = (int)op1;
+            int i2 = (int)op2;
+            try {
+                return Math.multiplyExact(i1, i2);
+            } catch (ArithmeticException ex) {
+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);
+            }
+        } else {
+            try {
+                return Math.multiplyExact(op1, op2);
+            } catch (ArithmeticException ex) {
+                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);
+            }
+        }
+    }
+
+    private static IndexOutOfBoundsException overflowException(long min, long max) {
+        return new IndexOutOfBoundsException(String.format("Overflow occurred during offset computation ; offset exceeded range { %d .. %d }", min, max));
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAccess.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAccess.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAccess.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAccess.java
@@ -1,26 +1,26 @@
 package jdk.incubator.foreign;
 
-import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.vm.annotation.ForceInline;
 
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 
 /**
  * This class defines ready-made static accessors which can be used to dereference memory segments in many ways.
  * <p>
- * The most primitive accessors (see {@link #getIntAtOffset(MemoryAddress, long)} (MemoryAddress, long)}) take a <em>base</em> address and an offset (expressed in bytes).
+ * The most primitive accessors (see {@link #getIntAtOffset(MemorySegment, long)}) take a segment and an offset (expressed in bytes).
  * The final address at which the dereference will occur will be computed by offsetting the base address by
  * the specified offset, as if by calling {@link MemoryAddress#addOffset(long)} on the specified base address.
  * <p>
- * In cases where no offset is required, overloads are provided (see {@link #getInt(MemoryAddress)}) so that
+ * In cases where no offset is required, overloads are provided (see {@link #getInt(MemorySegment)}) so that
  * clients can omit the offset coordinate.
  * <p>
  * To help dereferencing in array-like use cases (e.g. where the layout of a given memory segment is a sequence
- * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemoryAddress, long)}),
- * which take an <em>base</em> address and a <em>logical</em> element index. The formula to obtain the byte offset {@code O} from an
+ * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemorySegment, long)}),
+ * which take a segment and a <em>logical</em> element index. The formula to obtain the byte offset {@code O} from an
  * index {@code I} is given by {@code O = I * S} where {@code S} is the size (expressed in bytes) of the element to
  * be dereferenced.
  */
 public final class MemoryAccess {
 
@@ -43,2002 +43,2002 @@
     private static final VarHandle long_BE_handle = indexedHandle(MemoryLayouts.BITS_64_BE, long.class);
     private static final VarHandle double_BE_handle = indexedHandle(MemoryLayouts.BITS_64_BE, double.class);
     private static final VarHandle address_handle = MemoryHandles.asAddressVarHandle((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle);
 
     /**
-     * Read a byte from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a byte from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);
-    byte value = (byte)handle.get(addr, offset);
+    byte value = (byte)handle.get(segment, offset);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByteAtOffset_LE(MemoryAddress addr, long offset) {
-        return (byte)byte_LE_handle.get(addr, offset);
+    public static byte getByteAtOffset_LE(MemorySegment segment, long offset) {
+        return (byte)byte_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a byte at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtOffset_LE(MemoryAddress addr, long offset, byte value) {
-        byte_LE_handle.set(addr, offset, value);
+    public static void setByteAtOffset_LE(MemorySegment segment, long offset, byte value) {
+        byte_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a char from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a char from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);
-    char value = (char)handle.get(addr, offset);
+    char value = (char)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a char value read from {@code segment}.
      */
-    public static char getCharAtOffset_LE(MemoryAddress addr, long offset) {
-        return (char)char_LE_handle.get(addr, offset);
+    public static char getCharAtOffset_LE(MemorySegment segment, long offset) {
+        return (char)char_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a char at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtOffset_LE(MemoryAddress addr, long offset, char value) {
-        char_LE_handle.set(addr, offset, value);
+    public static void setCharAtOffset_LE(MemorySegment segment, long offset, char value) {
+        char_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a short from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a short from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);
-    short value = (short)handle.get(addr, offset);
+    short value = (short)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShortAtOffset_LE(MemoryAddress addr, long offset) {
-        return (short)short_LE_handle.get(addr, offset);
+    public static short getShortAtOffset_LE(MemorySegment segment, long offset) {
+        return (short)short_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a short at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtOffset_LE(MemoryAddress addr, long offset, short value) {
-        short_LE_handle.set(addr, offset, value);
+    public static void setShortAtOffset_LE(MemorySegment segment, long offset, short value) {
+        short_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read an int from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read an int from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);
-    int value = (int)handle.get(addr, offset);
+    int value = (int)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return an int value read from {@code segment}.
      */
-    public static int getIntAtOffset_LE(MemoryAddress addr, long offset) {
-        return (int)int_LE_handle.get(addr, offset);
+    public static int getIntAtOffset_LE(MemorySegment segment, long offset) {
+        return (int)int_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes an int at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtOffset_LE(MemoryAddress addr, long offset, int value) {
-        int_LE_handle.set(addr, offset, value);
+    public static void setIntAtOffset_LE(MemorySegment segment, long offset, int value) {
+        int_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a float from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a float from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);
-    float value = (float)handle.get(addr, offset);
+    float value = (float)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloatAtOffset_LE(MemoryAddress addr, long offset) {
-        return (float)float_LE_handle.get(addr, offset);
+    public static float getFloatAtOffset_LE(MemorySegment segment, long offset) {
+        return (float)float_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a float at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtOffset_LE(MemoryAddress addr, long offset, float value) {
-        float_LE_handle.set(addr, offset, value);
+    public static void setFloatAtOffset_LE(MemorySegment segment, long offset, float value) {
+        float_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a long from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a long from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);
-    long value = (long)handle.get(addr, offset);
+    long value = (long)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLongAtOffset_LE(MemoryAddress addr, long offset) {
-        return (long)long_LE_handle.get(addr, offset);
+    public static long getLongAtOffset_LE(MemorySegment segment, long offset) {
+        return (long)long_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a long at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtOffset_LE(MemoryAddress addr, long offset, long value) {
-        long_LE_handle.set(addr, offset, value);
+    public static void setLongAtOffset_LE(MemorySegment segment, long offset, long value) {
+        long_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a double from given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a double from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);
-    double value = (double)handle.get(addr, offset);
+    double value = (double)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDoubleAtOffset_LE(MemoryAddress addr, long offset) {
-        return (double)double_LE_handle.get(addr, offset);
+    public static double getDoubleAtOffset_LE(MemorySegment segment, long offset) {
+        return (double)double_LE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a double at given address and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtOffset_LE(MemoryAddress addr, long offset, double value) {
-        double_LE_handle.set(addr, offset, value);
+    public static void setDoubleAtOffset_LE(MemorySegment segment, long offset, double value) {
+        double_LE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a byte from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a byte from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);
-    byte value = (byte)handle.get(addr, offset);
+    byte value = (byte)handle.get(segment, offset);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByteAtOffset_BE(MemoryAddress addr, long offset) {
-        return (byte)byte_BE_handle.get(addr, offset);
+    public static byte getByteAtOffset_BE(MemorySegment segment, long offset) {
+        return (byte)byte_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a byte at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtOffset_BE(MemoryAddress addr, long offset, byte value) {
-        byte_BE_handle.set(addr, offset, value);
+    public static void setByteAtOffset_BE(MemorySegment segment, long offset, byte value) {
+        byte_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a char from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a char from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);
-    char value = (char)handle.get(addr, offset);
+    char value = (char)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a char value read from {@code segment}.
      */
-    public static char getCharAtOffset_BE(MemoryAddress addr, long offset) {
-        return (char)char_BE_handle.get(addr, offset);
+    public static char getCharAtOffset_BE(MemorySegment segment, long offset) {
+        return (char)char_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a char at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtOffset_BE(MemoryAddress addr, long offset, char value) {
-        char_BE_handle.set(addr, offset, value);
+    public static void setCharAtOffset_BE(MemorySegment segment, long offset, char value) {
+        char_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a short from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a short from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);
-    short value = (short)handle.get(addr, offset);
+    short value = (short)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShortAtOffset_BE(MemoryAddress addr, long offset) {
-        return (short)short_BE_handle.get(addr, offset);
+    public static short getShortAtOffset_BE(MemorySegment segment, long offset) {
+        return (short)short_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a short at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtOffset_BE(MemoryAddress addr, long offset, short value) {
-        short_BE_handle.set(addr, offset, value);
+    public static void setShortAtOffset_BE(MemorySegment segment, long offset, short value) {
+        short_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read an int from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read an int from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);
-    int value = (int)handle.get(addr, offset);
+    int value = (int)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return an int value read from {@code segment}.
      */
-    public static int getIntAtOffset_BE(MemoryAddress addr, long offset) {
-        return (int)int_BE_handle.get(addr, offset);
+    public static int getIntAtOffset_BE(MemorySegment segment, long offset) {
+        return (int)int_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes an int at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtOffset_BE(MemoryAddress addr, long offset, int value) {
-        int_BE_handle.set(addr, offset, value);
+    public static void setIntAtOffset_BE(MemorySegment segment, long offset, int value) {
+        int_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a float from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a float from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);
-    float value = (float)handle.get(addr, offset);
+    float value = (float)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloatAtOffset_BE(MemoryAddress addr, long offset) {
-        return (float)float_BE_handle.get(addr, offset);
+    public static float getFloatAtOffset_BE(MemorySegment segment, long offset) {
+        return (float)float_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a float at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtOffset_BE(MemoryAddress addr, long offset, float value) {
-        float_BE_handle.set(addr, offset, value);
+    public static void setFloatAtOffset_BE(MemorySegment segment, long offset, float value) {
+        float_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a long from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a long from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);
-    long value = (long)handle.get(addr, offset);
+    long value = (long)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLongAtOffset_BE(MemoryAddress addr, long offset) {
-        return (long)long_BE_handle.get(addr, offset);
+    public static long getLongAtOffset_BE(MemorySegment segment, long offset) {
+        return (long)long_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a long at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtOffset_BE(MemoryAddress addr, long offset, long value) {
-        long_BE_handle.set(addr, offset, value);
+    public static void setLongAtOffset_BE(MemorySegment segment, long offset, long value) {
+        long_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a double from given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a double from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);
-    double value = (double)handle.get(addr, offset);
+    double value = (double)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDoubleAtOffset_BE(MemoryAddress addr, long offset) {
-        return (double)double_BE_handle.get(addr, offset);
+    public static double getDoubleAtOffset_BE(MemorySegment segment, long offset) {
+        return (double)double_BE_handle.get(segment, offset);
     }
 
     /**
-     * Writes a double at given address and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtOffset_BE(MemoryAddress addr, long offset, double value) {
-        double_BE_handle.set(addr, offset, value);
+    public static void setDoubleAtOffset_BE(MemorySegment segment, long offset, double value) {
+        double_BE_handle.set(segment, offset, value);
     }
 
     /**
-     * Read a byte from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a byte from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);
-    byte value = (byte)handle.get(addr, offset);
+    byte value = (byte)handle.get(segment, offset);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByteAtOffset(MemoryAddress addr, long offset) {
-        return (byte)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).get(addr, offset);
+    public static byte getByteAtOffset(MemorySegment segment, long offset) {
+        return (byte)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a byte at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a byte at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtOffset(MemoryAddress addr, long offset, byte value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).set(addr, offset, value);
+    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a char from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a char from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);
-    char value = (char)handle.get(addr, offset);
+    char value = (char)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a char value read from {@code segment}.
      */
-    public static char getCharAtOffset(MemoryAddress addr, long offset) {
-        return (char)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(addr, offset);
+    public static char getCharAtOffset(MemorySegment segment, long offset) {
+        return (char)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a char at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtOffset(MemoryAddress addr, long offset, char value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(addr, offset, value);
+    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a short from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a short from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);
-    short value = (short)handle.get(addr, offset);
+    short value = (short)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShortAtOffset(MemoryAddress addr, long offset) {
-        return (short)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(addr, offset);
+    public static short getShortAtOffset(MemorySegment segment, long offset) {
+        return (short)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a short at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtOffset(MemoryAddress addr, long offset, short value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(addr, offset, value);
+    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read an int from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read an int from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);
-    int value = (int)handle.get(addr, offset);
+    int value = (int)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return an int value read from {@code segment}.
      */
-    public static int getIntAtOffset(MemoryAddress addr, long offset) {
-        return (int)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(addr, offset);
+    public static int getIntAtOffset(MemorySegment segment, long offset) {
+        return (int)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes an int at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtOffset(MemoryAddress addr, long offset, int value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(addr, offset, value);
+    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a float from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a float from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);
-    float value = (float)handle.get(addr, offset);
+    float value = (float)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloatAtOffset(MemoryAddress addr, long offset) {
-        return (float)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(addr, offset);
+    public static float getFloatAtOffset(MemorySegment segment, long offset) {
+        return (float)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a float at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtOffset(MemoryAddress addr, long offset, float value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(addr, offset, value);
+    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a long from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a long from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);
-    long value = (long)handle.get(addr, offset);
+    long value = (long)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLongAtOffset(MemoryAddress addr, long offset) {
-        return (long)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(addr, offset);
+    public static long getLongAtOffset(MemorySegment segment, long offset) {
+        return (long)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a long at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtOffset(MemoryAddress addr, long offset, long value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(addr, offset, value);
+    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a double from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a double from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);
-    double value = (double)handle.get(addr, offset);
+    double value = (double)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDoubleAtOffset(MemoryAddress addr, long offset) {
-        return (double)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(addr, offset);
+    public static double getDoubleAtOffset(MemorySegment segment, long offset) {
+        return (double)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(segment, offset);
     }
 
     /**
-     * Writes a double at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtOffset(MemoryAddress addr, long offset, double value) {
-        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(addr, offset, value);
+    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {
+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(segment, offset, value);
     }
 
     /**
-     * Read a memory address from given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a memory address from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L));
-    MemoryAddress value = (MemoryAddress)handle.get(addr, offset);
+    MemoryAddress value = (MemoryAddress)handle.get(segment, offset);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
-     * @return a memory address read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
+     * @return a memory address read from {@code segment}.
      */
-    public static MemoryAddress getAddressAtOffset(MemoryAddress addr, long offset) {
-        return (MemoryAddress)address_handle.get(addr, offset);
+    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {
+        return (MemoryAddress)address_handle.get(segment, offset);
     }
 
     /**
-     * Writes a memory address at given address and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a memory address at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
     VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L));
-    handle.set(addr, offset, value);
+    handle.set(segment, offset, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param offset offset (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(offset)}.
+     * @param segment the segment to be dereferenced.
+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.
      * @param value the memory address to be written.
      */
-    public static void setAddressAtOffset(MemoryAddress addr, long offset, MemoryAddress value) {
-        address_handle.set(addr, offset, value);
+    public static void setAddressAtOffset(MemorySegment segment, long offset, MemoryAddress value) {
+        address_handle.set(segment, offset, value);
     }
 
-    private static VarHandle indexedHandle(MemoryLayout elementLayout, Class<?> carrier) {
-        return MemoryHandles.withStride(elementLayout.withBitAlignment(8).varHandle(carrier), 1L);
+    private static VarHandle indexedHandle(ValueLayout elementLayout, Class<?> carrier) {
+        return MemoryHandles.varHandle(carrier, 1, elementLayout.order());
     }
 
     /**
-     * Read a byte from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a byte from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset_LE(addr, 0L);
+    byte value = getByteAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByte_LE(MemoryAddress addr) {
-        return getByteAtOffset_LE(addr, 0L);
+    public static byte getByte_LE(MemorySegment segment) {
+        return getByteAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a byte at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a byte at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset_LE(addr, 0L, value);
+    setByteAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the byte value to be written.
      */
-    public static void setByte_LE(MemoryAddress addr, byte value) {
-        setByteAtOffset_LE(addr, 0L, value);
+    public static void setByte_LE(MemorySegment segment, byte value) {
+        setByteAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a char from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a char from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset_LE(addr, 0L);
+    char value = getCharAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a char value read from {@code segment}.
      */
-    public static char getChar_LE(MemoryAddress addr) {
-        return getCharAtOffset_LE(addr, 0L);
+    public static char getChar_LE(MemorySegment segment) {
+        return getCharAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a char at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a char at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset_LE(addr, 0L, value);
+    setCharAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the char value to be written.
      */
-    public static void setChar_LE(MemoryAddress addr, char value) {
-        setCharAtOffset_LE(addr, 0L, value);
+    public static void setChar_LE(MemorySegment segment, char value) {
+        setCharAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a short from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a short from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset_LE(addr, 0L);
+    short value = getShortAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShort_LE(MemoryAddress addr) {
-        return getShortAtOffset_LE(addr, 0L);
+    public static short getShort_LE(MemorySegment segment) {
+        return getShortAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a short at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a short at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset_LE(addr, 0L, value);
+    setShortAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the short value to be written.
      */
-    public static void setShort_LE(MemoryAddress addr, short value) {
-        setShortAtOffset_LE(addr, 0L, value);
+    public static void setShort_LE(MemorySegment segment, short value) {
+        setShortAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read an int from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read an int from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset_LE(addr, 0L);
+    int value = getIntAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return an int value read from {@code segment}.
      */
-    public static int getInt_LE(MemoryAddress addr) {
-        return getIntAtOffset_LE(addr, 0L);
+    public static int getInt_LE(MemorySegment segment) {
+        return getIntAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes an int at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes an int at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset_LE(addr, 0L, value);
+    setIntAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the int value to be written.
      */
-    public static void setInt_LE(MemoryAddress addr, int value) {
-        setIntAtOffset_LE(addr, 0L, value);
+    public static void setInt_LE(MemorySegment segment, int value) {
+        setIntAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a float from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a float from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset_LE(addr, 0L);
+    float value = getFloatAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloat_LE(MemoryAddress addr) {
-        return getFloatAtOffset_LE(addr, 0L);
+    public static float getFloat_LE(MemorySegment segment) {
+        return getFloatAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a float at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a float at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset_LE(addr, 0L, value);
+    setFloatAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the float value to be written.
      */
-    public static void setFloat_LE(MemoryAddress addr, float value) {
-        setFloatAtOffset_LE(addr, 0L, value);
+    public static void setFloat_LE(MemorySegment segment, float value) {
+        setFloatAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a long from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a long from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    long value = getLongAtOffset_LE(addr, 0L);
+    long value = getLongAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLong_LE(MemoryAddress addr) {
-        return getLongAtOffset_LE(addr, 0L);
+    public static long getLong_LE(MemorySegment segment) {
+        return getLongAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a long at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a long at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset_LE(addr, 0L, value);
+    setLongAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the long value to be written.
      */
-    public static void setLong_LE(MemoryAddress addr, long value) {
-        setLongAtOffset_LE(addr, 0L, value);
+    public static void setLong_LE(MemorySegment segment, long value) {
+        setLongAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a double from given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a double from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    double value = getDoubleAtOffset_LE(addr, 0L);
+    double value = getDoubleAtOffset_LE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDouble_LE(MemoryAddress addr) {
-        return getDoubleAtOffset_LE(addr, 0L);
+    public static double getDouble_LE(MemorySegment segment) {
+        return getDoubleAtOffset_LE(segment, 0L);
     }
 
     /**
-     * Writes a double at given address, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a double at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset_LE(addr, 0L, value);
+    setDoubleAtOffset_LE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the double value to be written.
      */
-    public static void setDouble_LE(MemoryAddress addr, double value) {
-        setDoubleAtOffset_LE(addr, 0L, value);
+    public static void setDouble_LE(MemorySegment segment, double value) {
+        setDoubleAtOffset_LE(segment, 0L, value);
     }
 
     /**
-     * Read a byte from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a byte from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset_BE(addr, 0L);
+    byte value = getByteAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByte_BE(MemoryAddress addr) {
-        return getByteAtOffset_BE(addr, 0L);
+    public static byte getByte_BE(MemorySegment segment) {
+        return getByteAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a byte at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a byte at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset_BE(addr, 0L, value);
+    setByteAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the byte value to be written.
      */
-    public static void setByte_BE(MemoryAddress addr, byte value) {
-        setByteAtOffset_BE(addr, 0L, value);
+    public static void setByte_BE(MemorySegment segment, byte value) {
+        setByteAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a char from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a char from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset_BE(addr, 0L);
+    char value = getCharAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a char value read from {@code segment}.
      */
-    public static char getChar_BE(MemoryAddress addr) {
-        return getCharAtOffset_BE(addr, 0L);
+    public static char getChar_BE(MemorySegment segment) {
+        return getCharAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a char at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a char at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset_BE(addr, 0L, value);
+    setCharAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the char value to be written.
      */
-    public static void setChar_BE(MemoryAddress addr, char value) {
-        setCharAtOffset_BE(addr, 0L, value);
+    public static void setChar_BE(MemorySegment segment, char value) {
+        setCharAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a short from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a short from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset_BE(addr, 0L);
+    short value = getShortAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShort_BE(MemoryAddress addr) {
-        return getShortAtOffset_BE(addr, 0L);
+    public static short getShort_BE(MemorySegment segment) {
+        return getShortAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a short at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a short at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset_BE(addr, 0L, value);
+    setShortAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the short value to be written.
      */
-    public static void setShort_BE(MemoryAddress addr, short value) {
-        setShortAtOffset_BE(addr, 0L, value);
+    public static void setShort_BE(MemorySegment segment, short value) {
+        setShortAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read an int from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read an int from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset_BE(addr, 0L);
+    int value = getIntAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return an int value read from {@code segment}.
      */
-    public static int getInt_BE(MemoryAddress addr) {
-        return getIntAtOffset_BE(addr, 0L);
+    public static int getInt_BE(MemorySegment segment) {
+        return getIntAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes an int at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes an int at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset_BE(addr, 0L, value);
+    setIntAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the int value to be written.
      */
-    public static void setInt_BE(MemoryAddress addr, int value) {
-        setIntAtOffset_BE(addr, 0L, value);
+    public static void setInt_BE(MemorySegment segment, int value) {
+        setIntAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a float from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a float from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset_BE(addr, 0L);
+    float value = getFloatAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloat_BE(MemoryAddress addr) {
-        return getFloatAtOffset_BE(addr, 0L);
+    public static float getFloat_BE(MemorySegment segment) {
+        return getFloatAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a float at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a float at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset_BE(addr, 0L, value);
+    setFloatAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the float value to be written.
      */
-    public static void setFloat_BE(MemoryAddress addr, float value) {
-        setFloatAtOffset_BE(addr, 0L, value);
+    public static void setFloat_BE(MemorySegment segment, float value) {
+        setFloatAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a long from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a long from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    long value = getLongAtOffset_BE(addr, 0L);
+    long value = getLongAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLong_BE(MemoryAddress addr) {
-        return getLongAtOffset_BE(addr, 0L);
+    public static long getLong_BE(MemorySegment segment) {
+        return getLongAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a long at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a long at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset_BE(addr, 0L, value);
+    setLongAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the long value to be written.
      */
-    public static void setLong_BE(MemoryAddress addr, long value) {
-        setLongAtOffset_BE(addr, 0L, value);
+    public static void setLong_BE(MemorySegment segment, long value) {
+        setLongAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a double from given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a double from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    double value = getDoubleAtOffset_BE(addr, 0L);
+    double value = getDoubleAtOffset_BE(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDouble_BE(MemoryAddress addr) {
-        return getDoubleAtOffset_BE(addr, 0L);
+    public static double getDouble_BE(MemorySegment segment) {
+        return getDoubleAtOffset_BE(segment, 0L);
     }
 
     /**
-     * Writes a double at given address, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a double at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset_BE(addr, 0L, value);
+    setDoubleAtOffset_BE(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the double value to be written.
      */
-    public static void setDouble_BE(MemoryAddress addr, double value) {
-        setDoubleAtOffset_BE(addr, 0L, value);
+    public static void setDouble_BE(MemorySegment segment, double value) {
+        setDoubleAtOffset_BE(segment, 0L, value);
     }
 
     /**
-     * Read a byte from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a byte from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset(addr, 0L);
+    byte value = getByteAtOffset(segment, 0L);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @return a byte value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a byte value read from {@code segment}.
      */
-    public static byte getByte(MemoryAddress addr) {
-        return getByteAtOffset(addr, 0L);
+    public static byte getByte(MemorySegment segment) {
+        return getByteAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a byte at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a byte at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset(addr, 0L, value);
+    setByteAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the byte value to be written.
      */
-    public static void setByte(MemoryAddress addr, byte value) {
-        setByteAtOffset(addr, 0L, value);
+    public static void setByte(MemorySegment segment, byte value) {
+        setByteAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a char from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset(addr, 0L);
+    char value = getCharAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a char value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a char value read from {@code segment}.
      */
-    public static char getChar(MemoryAddress addr) {
-        return getCharAtOffset(addr, 0L);
+    public static char getChar(MemorySegment segment) {
+        return getCharAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a char at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset(addr, 0L, value);
+    setCharAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the char value to be written.
      */
-    public static void setChar(MemoryAddress addr, char value) {
-        setCharAtOffset(addr, 0L, value);
+    public static void setChar(MemorySegment segment, char value) {
+        setCharAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a short from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset(addr, 0L);
+    short value = getShortAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a short value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a short value read from {@code segment}.
      */
-    public static short getShort(MemoryAddress addr) {
-        return getShortAtOffset(addr, 0L);
+    public static short getShort(MemorySegment segment) {
+        return getShortAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a short at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset(addr, 0L, value);
+    setShortAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the short value to be written.
      */
-    public static void setShort(MemoryAddress addr, short value) {
-        setShortAtOffset(addr, 0L, value);
+    public static void setShort(MemorySegment segment, short value) {
+        setShortAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read an int from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset(addr, 0L);
+    int value = getIntAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return an int value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return an int value read from {@code segment}.
      */
-    public static int getInt(MemoryAddress addr) {
-        return getIntAtOffset(addr, 0L);
+    public static int getInt(MemorySegment segment) {
+        return getIntAtOffset(segment, 0L);
     }
 
     /**
-     * Writes an int at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset(addr, 0L, value);
+    setIntAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the int value to be written.
      */
-    public static void setInt(MemoryAddress addr, int value) {
-        setIntAtOffset(addr, 0L, value);
+    public static void setInt(MemorySegment segment, int value) {
+        setIntAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a float from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset(addr, 0L);
+    float value = getFloatAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a float value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a float value read from {@code segment}.
      */
-    public static float getFloat(MemoryAddress addr) {
-        return getFloatAtOffset(addr, 0L);
+    public static float getFloat(MemorySegment segment) {
+        return getFloatAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a float at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset(addr, 0L, value);
+    setFloatAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the float value to be written.
      */
-    public static void setFloat(MemoryAddress addr, float value) {
-        setFloatAtOffset(addr, 0L, value);
+    public static void setFloat(MemorySegment segment, float value) {
+        setFloatAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a long from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    long value = getLongAtOffset(addr, 0L);
+    long value = getLongAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a long value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a long value read from {@code segment}.
      */
-    public static long getLong(MemoryAddress addr) {
-        return getLongAtOffset(addr, 0L);
+    public static long getLong(MemorySegment segment) {
+        return getLongAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a long at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a long at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset(addr, 0L, value);
+    setLongAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the long value to be written.
      */
-    public static void setLong(MemoryAddress addr, long value) {
-        setLongAtOffset(addr, 0L, value);
+    public static void setLong(MemorySegment segment, long value) {
+        setLongAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a double from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a double from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    double value = getDoubleAtOffset(addr, 0L);
+    double value = getDoubleAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a double value read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a double value read from {@code segment}.
      */
-    public static double getDouble(MemoryAddress addr) {
-        return getDoubleAtOffset(addr, 0L);
+    public static double getDouble(MemorySegment segment) {
+        return getDoubleAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a double at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a double at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset(addr, 0L, value);
+    setDoubleAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the double value to be written.
      */
-    public static void setDouble(MemoryAddress addr, double value) {
-        setDoubleAtOffset(addr, 0L, value);
+    public static void setDouble(MemorySegment segment, double value) {
+        setDoubleAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a memory address from given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a memory address from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    MemoryAddress value = getAddressAtOffset(addr, 0L);
+    MemoryAddress value = getAddressAtOffset(segment, 0L);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @return a memory address read from {@code addr} at the offset specified by {@code offset}.
+     * @param segment the segment to be dereferenced.
+     * @return a memory address read from {@code segment}.
      */
-    public static MemoryAddress getAddress(MemoryAddress addr) {
-        return getAddressAtOffset(addr, 0L);
+    public static MemoryAddress getAddress(MemorySegment segment) {
+        return getAddressAtOffset(segment, 0L);
     }
 
     /**
-     * Writes a memory address at given address, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a memory address at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setAddressAtOffset(addr, 0L, value);
+    setAddressAtOffset(segment, 0L, value);
      * }</pre></blockquote>
-     * @param addr base address.
+     * @param segment the segment to be dereferenced.
      * @param value the memory address to be written.
      */
-    public static void setAddress(MemoryAddress addr, MemoryAddress value) {
-        setAddressAtOffset(addr, 0L, value);
+    public static void setAddress(MemorySegment segment, MemoryAddress value) {
+        setAddressAtOffset(segment, 0L, value);
     }
 
     /**
-     * Read a byte from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a byte from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset_LE(addr, index);
+    byte value = getByteAtOffset_LE(segment, index);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
-     * @return a byte value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
+     * @return a byte value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static byte getByteAtIndex_LE(MemoryAddress addr, long index) {
-        return getByteAtOffset_LE(addr, index);
+    public static byte getByteAtIndex_LE(MemorySegment segment, long index) {
+        return getByteAtOffset_LE(segment, index);
     }
 
     /**
-     * Writes a byte at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a byte at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset_LE(addr, index, value);
+    setByteAtOffset_LE(segment, index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtIndex_LE(MemoryAddress addr, long index, byte value) {
-        setByteAtOffset_LE(addr, index, value);
+    public static void setByteAtIndex_LE(MemorySegment segment, long index, byte value) {
+        setByteAtOffset_LE(segment, index, value);
     }
 
     /**
-     * Read a char from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a char from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset_LE(addr, 2 * index);
+    char value = getCharAtOffset_LE(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a char value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a char value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static char getCharAtIndex_LE(MemoryAddress addr, long index) {
-        return getCharAtOffset_LE(addr, scale(addr, index, 2));
+    public static char getCharAtIndex_LE(MemorySegment segment, long index) {
+        return getCharAtOffset_LE(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a char at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset_LE(addr, 2 * index, value);
+    setCharAtOffset_LE(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtIndex_LE(MemoryAddress addr, long index, char value) {
-        setCharAtOffset_LE(addr, scale(addr, index, 2), value);
+    public static void setCharAtIndex_LE(MemorySegment segment, long index, char value) {
+        setCharAtOffset_LE(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read a short from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a short from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset_LE(addr, 2 * index);
+    short value = getShortAtOffset_LE(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a short value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a short value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static short getShortAtIndex_LE(MemoryAddress addr, long index) {
-        return getShortAtOffset_LE(addr, scale(addr, index, 2));
+    public static short getShortAtIndex_LE(MemorySegment segment, long index) {
+        return getShortAtOffset_LE(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a short at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset_LE(addr, 2 * index, value);
+    setShortAtOffset_LE(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtIndex_LE(MemoryAddress addr, long index, short value) {
-        setShortAtOffset_LE(addr, scale(addr, index, 2), value);
+    public static void setShortAtIndex_LE(MemorySegment segment, long index, short value) {
+        setShortAtOffset_LE(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read an int from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read an int from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset_LE(addr, 4 * index);
+    int value = getIntAtOffset_LE(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return an int value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return an int value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static int getIntAtIndex_LE(MemoryAddress addr, long index) {
-        return getIntAtOffset_LE(addr, scale(addr, index, 4));
+    public static int getIntAtIndex_LE(MemorySegment segment, long index) {
+        return getIntAtOffset_LE(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes an int at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset_LE(addr, 4 * index, value);
+    setIntAtOffset_LE(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtIndex_LE(MemoryAddress addr, long index, int value) {
-        setIntAtOffset_LE(addr, scale(addr, index, 4), value);
+    public static void setIntAtIndex_LE(MemorySegment segment, long index, int value) {
+        setIntAtOffset_LE(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a float from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a float from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset_LE(addr, 4 * index);
+    float value = getFloatAtOffset_LE(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return a float value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return a float value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static float getFloatAtIndex_LE(MemoryAddress addr, long index) {
-        return getFloatAtOffset_LE(addr, scale(addr, index, 4));
+    public static float getFloatAtIndex_LE(MemorySegment segment, long index) {
+        return getFloatAtOffset_LE(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes a float at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset_LE(addr, 4 * index, value);
+    setFloatAtOffset_LE(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtIndex_LE(MemoryAddress addr, long index, float value) {
-        setFloatAtOffset_LE(addr, scale(addr, index, 4), value);
+    public static void setFloatAtIndex_LE(MemorySegment segment, long index, float value) {
+        setFloatAtOffset_LE(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a long from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a long from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getLongAtOffset_LE(addr, 8 * index);
+    return getLongAtOffset_LE(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a long value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a long value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static long getLongAtIndex_LE(MemoryAddress addr, long index) {
-        return getLongAtOffset_LE(addr, scale(addr, index, 8));
+    public static long getLongAtIndex_LE(MemorySegment segment, long index) {
+        return getLongAtOffset_LE(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a long at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset_LE(addr, 8 * index, value);
+    setLongAtOffset_LE(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtIndex_LE(MemoryAddress addr, long index, long value) {
-        setLongAtOffset_LE(addr, scale(addr, index, 8), value);
+    public static void setLongAtIndex_LE(MemorySegment segment, long index, long value) {
+        setLongAtOffset_LE(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a double from given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Read a double from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getDoubleAtOffset_LE(addr, 8 * index);
+    return getDoubleAtOffset_LE(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a double value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a double value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static double getDoubleAtIndex_LE(MemoryAddress addr, long index) {
-        return getDoubleAtOffset_LE(addr, scale(addr, index, 8));
+    public static double getDoubleAtIndex_LE(MemorySegment segment, long index) {
+        return getDoubleAtOffset_LE(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a double at given address and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset_LE(addr, 8 * index, value);
+    setDoubleAtOffset_LE(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtIndex_LE(MemoryAddress addr, long index, double value) {
-        setDoubleAtOffset_LE(addr, scale(addr, index, 8), value);
+    public static void setDoubleAtIndex_LE(MemorySegment segment, long index, double value) {
+        setDoubleAtOffset_LE(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a byte from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a byte from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset_BE(addr, index);
+    byte value = getByteAtOffset_BE(segment, index);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
-     * @return a byte value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
+     * @return a byte value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static byte getByteAtIndex_BE(MemoryAddress addr, long index) {
-        return getByteAtOffset_BE(addr, index);
+    public static byte getByteAtIndex_BE(MemorySegment segment, long index) {
+        return getByteAtOffset_BE(segment, index);
     }
 
     /**
-     * Writes a byte at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a byte at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset_BE(addr, index, value);
+    setByteAtOffset_BE(segment, index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtIndex_BE(MemoryAddress addr, long index, byte value) {
-        setByteAtOffset_BE(addr, index, value);
+    public static void setByteAtIndex_BE(MemorySegment segment, long index, byte value) {
+        setByteAtOffset_BE(segment, index, value);
     }
 
     /**
-     * Read a char from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a char from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset_BE(addr, 2 * index);
+    char value = getCharAtOffset_BE(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a char value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a char value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static char getCharAtIndex_BE(MemoryAddress addr, long index) {
-        return getCharAtOffset_BE(addr, scale(addr, index, 2));
+    public static char getCharAtIndex_BE(MemorySegment segment, long index) {
+        return getCharAtOffset_BE(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a char at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset_BE(addr, 2 * index, value);
+    setCharAtOffset_BE(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtIndex_BE(MemoryAddress addr, long index, char value) {
-        setCharAtOffset_BE(addr, scale(addr, index, 2), value);
+    public static void setCharAtIndex_BE(MemorySegment segment, long index, char value) {
+        setCharAtOffset_BE(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read a short from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a short from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset_BE(addr, 2 * index);
+    short value = getShortAtOffset_BE(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a short value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a short value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static short getShortAtIndex_BE(MemoryAddress addr, long index) {
-        return getShortAtOffset_BE(addr, scale(addr, index, 2));
+    public static short getShortAtIndex_BE(MemorySegment segment, long index) {
+        return getShortAtOffset_BE(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a short at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset_BE(addr, 2 * index, value);
+    setShortAtOffset_BE(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtIndex_BE(MemoryAddress addr, long index, short value) {
-        setShortAtOffset_BE(addr, scale(addr, index, 2), value);
+    public static void setShortAtIndex_BE(MemorySegment segment, long index, short value) {
+        setShortAtOffset_BE(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read an int from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read an int from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset_BE(addr, 4 * index);
+    int value = getIntAtOffset_BE(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return an int value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return an int value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static int getIntAtIndex_BE(MemoryAddress addr, long index) {
-        return getIntAtOffset_BE(addr, scale(addr, index, 4));
+    public static int getIntAtIndex_BE(MemorySegment segment, long index) {
+        return getIntAtOffset_BE(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes an int at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset_BE(addr, 4 * index, value);
+    setIntAtOffset_BE(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtIndex_BE(MemoryAddress addr, long index, int value) {
-        setIntAtOffset_BE(addr, scale(addr, index, 4), value);
+    public static void setIntAtIndex_BE(MemorySegment segment, long index, int value) {
+        setIntAtOffset_BE(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a float from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a float from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset_BE(addr, 4 * index);
+    float value = getFloatAtOffset_BE(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return a float value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return a float value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static float getFloatAtIndex_BE(MemoryAddress addr, long index) {
-        return getFloatAtOffset_BE(addr, scale(addr, index, 4));
+    public static float getFloatAtIndex_BE(MemorySegment segment, long index) {
+        return getFloatAtOffset_BE(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes a float at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset_BE(addr, 4 * index, value);
+    setFloatAtOffset_BE(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtIndex_BE(MemoryAddress addr, long index, float value) {
-        setFloatAtOffset_BE(addr, scale(addr, index, 4), value);
+    public static void setFloatAtIndex_BE(MemorySegment segment, long index, float value) {
+        setFloatAtOffset_BE(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a long from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a long from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getLongAtOffset_BE(addr, 8 * index);
+    return getLongAtOffset_BE(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a long value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a long value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static long getLongAtIndex_BE(MemoryAddress addr, long index) {
-        return getLongAtOffset_BE(addr, scale(addr, index, 8));
+    public static long getLongAtIndex_BE(MemorySegment segment, long index) {
+        return getLongAtOffset_BE(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a long at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset_BE(addr, 8 * index, value);
+    setLongAtOffset_BE(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtIndex_BE(MemoryAddress addr, long index, long value) {
-        setLongAtOffset_BE(addr, scale(addr, index, 8), value);
+    public static void setLongAtIndex_BE(MemorySegment segment, long index, long value) {
+        setLongAtOffset_BE(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a double from given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Read a double from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getDoubleAtOffset_BE(addr, 8 * index);
+    return getDoubleAtOffset_BE(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a double value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a double value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static double getDoubleAtIndex_BE(MemoryAddress addr, long index) {
-        return getDoubleAtOffset_BE(addr, scale(addr, index, 8));
+    public static double getDoubleAtIndex_BE(MemorySegment segment, long index) {
+        return getDoubleAtOffset_BE(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a double at given address and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset_BE(addr, 8 * index, value);
+    setDoubleAtOffset_BE(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtIndex_BE(MemoryAddress addr, long index, double value) {
-        setDoubleAtOffset_BE(addr, scale(addr, index, 8), value);
+    public static void setDoubleAtIndex_BE(MemorySegment segment, long index, double value) {
+        setDoubleAtOffset_BE(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a byte from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a byte from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    byte value = getByteAtOffset(addr, index);
+    byte value = getByteAtOffset(segment, index);
      * }</pre></blockquote>
      *
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
-     * @return a byte value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
+     * @return a byte value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static byte getByteAtIndex(MemoryAddress addr, long index) {
-        return getByteAtOffset(addr, index);
+    public static byte getByteAtIndex(MemorySegment segment, long index) {
+        return getByteAtOffset(segment, index);
     }
 
     /**
-     * Writes a byte at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a byte at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setByteAtOffset(addr, index, value);
+    setByteAtOffset(segment, index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.
      * @param value the byte value to be written.
      */
-    public static void setByteAtIndex(MemoryAddress addr, long index, byte value) {
-        setByteAtOffset(addr, index, value);
+    public static void setByteAtIndex(MemorySegment segment, long index, byte value) {
+        setByteAtOffset(segment, index, value);
     }
 
     /**
-     * Read a char from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a char from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    char value = getCharAtOffset(addr, 2 * index);
+    char value = getCharAtOffset(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a char value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a char value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static char getCharAtIndex(MemoryAddress addr, long index) {
-        return getCharAtOffset(addr, scale(addr, index, 2));
+    public static char getCharAtIndex(MemorySegment segment, long index) {
+        return getCharAtOffset(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a char at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setCharAtOffset(addr, 2 * index, value);
+    setCharAtOffset(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the char value to be written.
      */
-    public static void setCharAtIndex(MemoryAddress addr, long index, char value) {
-        setCharAtOffset(addr, scale(addr, index, 2), value);
+    public static void setCharAtIndex(MemorySegment segment, long index, char value) {
+        setCharAtOffset(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read a short from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a short from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    short value = getShortAtOffset(addr, 2 * index);
+    short value = getShortAtOffset(segment, 2 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
-     * @return a short value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
+     * @return a short value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static short getShortAtIndex(MemoryAddress addr, long index) {
-        return getShortAtOffset(addr, scale(addr, index, 2));
+    public static short getShortAtIndex(MemorySegment segment, long index) {
+        return getShortAtOffset(segment, scale(segment, index, 2));
     }
 
     /**
-     * Writes a short at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setShortAtOffset(addr, 2 * index, value);
+    setShortAtOffset(segment, 2 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 2)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.
      * @param value the short value to be written.
      */
-    public static void setShortAtIndex(MemoryAddress addr, long index, short value) {
-        setShortAtOffset(addr, scale(addr, index, 2), value);
+    public static void setShortAtIndex(MemorySegment segment, long index, short value) {
+        setShortAtOffset(segment, scale(segment, index, 2), value);
     }
 
     /**
-     * Read an int from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read an int from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    int value = getIntAtOffset(addr, 4 * index);
+    int value = getIntAtOffset(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return an int value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return an int value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static int getIntAtIndex(MemoryAddress addr, long index) {
-        return getIntAtOffset(addr, scale(addr, index, 4));
+    public static int getIntAtIndex(MemorySegment segment, long index) {
+        return getIntAtOffset(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes an int at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setIntAtOffset(addr, 4 * index, value);
+    setIntAtOffset(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the int value to be written.
      */
-    public static void setIntAtIndex(MemoryAddress addr, long index, int value) {
-        setIntAtOffset(addr, scale(addr, index, 4), value);
+    public static void setIntAtIndex(MemorySegment segment, long index, int value) {
+        setIntAtOffset(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a float from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    float value = getFloatAtOffset(addr, 4 * index);
+    float value = getFloatAtOffset(segment, 4 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
-     * @return a float value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
+     * @return a float value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static float getFloatAtIndex(MemoryAddress addr, long index) {
-        return getFloatAtOffset(addr, scale(addr, index, 4));
+    public static float getFloatAtIndex(MemorySegment segment, long index) {
+        return getFloatAtOffset(segment, scale(segment, index, 4));
     }
 
     /**
-     * Writes a float at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setFloatAtOffset(addr, 4 * index, value);
+    setFloatAtOffset(segment, 4 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 4)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.
      * @param value the float value to be written.
      */
-    public static void setFloatAtIndex(MemoryAddress addr, long index, float value) {
-        setFloatAtOffset(addr, scale(addr, index, 4), value);
+    public static void setFloatAtIndex(MemorySegment segment, long index, float value) {
+        setFloatAtOffset(segment, scale(segment, index, 4), value);
     }
 
     /**
-     * Read a long from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a long from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getLongAtOffset(addr, 8 * index);
+    return getLongAtOffset(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a long value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a long value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static long getLongAtIndex(MemoryAddress addr, long index) {
-        return getLongAtOffset(addr, scale(addr, index, 8));
+    public static long getLongAtIndex(MemorySegment segment, long index) {
+        return getLongAtOffset(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a long at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setLongAtOffset(addr, 8 * index, value);
+    setLongAtOffset(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the long value to be written.
      */
-    public static void setLongAtIndex(MemoryAddress addr, long index, long value) {
-        setLongAtOffset(addr, scale(addr, index, 8), value);
+    public static void setLongAtIndex(MemorySegment segment, long index, long value) {
+        setLongAtOffset(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a double from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a double from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getDoubleAtOffset(addr, 8 * index);
+    return getDoubleAtOffset(segment, 8 * index);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a double value read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a double value read from {@code segment} at the element index specified by {@code index}.
      */
-    public static double getDoubleAtIndex(MemoryAddress addr, long index) {
-        return getDoubleAtOffset(addr, scale(addr, index, 8));
+    public static double getDoubleAtIndex(MemorySegment segment, long index) {
+        return getDoubleAtOffset(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a double at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setDoubleAtOffset(addr, 8 * index, value);
+    setDoubleAtOffset(segment, 8 * index, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the double value to be written.
      */
-    public static void setDoubleAtIndex(MemoryAddress addr, long index, double value) {
-        setDoubleAtOffset(addr, scale(addr, index, 8), value);
+    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {
+        setDoubleAtOffset(segment, scale(segment, index, 8), value);
     }
 
     /**
-     * Read a memory address from given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Read a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    return getAddressAtOffset(addr, index * 8);
+    return getAddressAtOffset(segment, index * 8);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
-     * @return a memory address read from {@code addr} at the element index specified by {@code index}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
+     * @return a memory address read from {@code segment} at the element index specified by {@code index}.
      */
-    public static MemoryAddress getAddressAtIndex(MemoryAddress addr, long index) {
-        return getAddressAtOffset(addr, scale(addr, index, 8));
+    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {
+        return getAddressAtOffset(segment, scale(segment, index, 8));
     }
 
     /**
-     * Writes a memory address at given address and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
+     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.
      * <p>
      * This is equivalent to the following code:
      * <blockquote><pre>{@code
-    setAddressAtOffset(addr, index * 8, value);
+    setAddressAtOffset(segment, index * 8, value);
      * }</pre></blockquote>
-     * @param addr base address.
-     * @param index element index (relative to {@code addr}). The final address of this read operation can be expressed as {@code addr.addOffset(index * 8)}.
+     * @param segment the segment to be dereferenced.
+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.
      * @param value the memory address to be written.
      */
-    public static void setAddressAtIndex(MemoryAddress addr, long index, MemoryAddress value) {
-        setAddressAtOffset(addr, scale(addr, index, 8), value);
+    public static void setAddressAtIndex(MemorySegment segment, long index, MemoryAddress value) {
+        setAddressAtOffset(segment, scale(segment, index, 8), value);
     }
 
     @ForceInline
-    private static long scale(MemoryAddress address, long index, int size) {
-        return MemoryAddressProxy.multiplyOffsets(index, size, (MemoryAddressProxy)address);
+    private static long scale(MemorySegment address, long index, int size) {
+        return MemorySegmentProxy.multiplyOffsets(index, size, (MemorySegmentProxy)address);
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -28,19 +28,13 @@
 
 import jdk.internal.foreign.MemoryAddressImpl;
 
 /**
  * A memory address models a reference into a memory location. Memory addresses are typically obtained using the
- * {@link MemorySegment#address()} method; such addresses are said to be <em>checked</em>, and can be expressed
- * as <em>offsets</em> into some underlying memory segment (see {@link #segment()} and {@link #segmentOffset()}).
- * Since checked memory addresses feature both spatial and temporal bounds, these addresses can <em>safely</em> be
- * dereferenced using a memory access var handle (see {@link MemoryHandles}).
- * <p>
- * If an address does not have any associated segment, it is said to be <em>unchecked</em>. Unchecked memory
- * addresses do not feature known spatial or temporal bounds; as such, attempting a memory dereference operation
- * using an unchecked memory address will result in a runtime exception. Unchecked addresses can be obtained
- * e.g. by calling the {@link #ofLong(long)} method.
+ * {@link MemorySegment#address()} method, and can refer to either off-heap or on-heap memory.
+ * Given an address, it is possible to compute its offset relative to a given segment, which can be useful
+ * when performing memory dereference operations using a memory access var handle (see {@link MemoryHandles}).
  * <p>
  * All implementations of this interface must be <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>;
  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
  * instances of {@code MemoryAddress} may have unpredictable results and should be avoided. The {@code equals} method should
  * be used for comparisons.
@@ -67,39 +61,36 @@
      * @return a new memory address with given offset from current one.
      */
     MemoryAddress addOffset(long offset);
 
     /**
-     * Returns the offset of this memory address into the underlying segment (if any).
-     * @return the offset of this memory address into the underlying segment (if any).
-     * @throws UnsupportedOperationException if no segment is associated with this memory address,
-     * e.g. if {@code segment() == null}.
+     * Returns the offset of this memory address into the given segment. More specifically, if both the segment's
+     * base address and this address are off-heap addresses, the result is computed as
+     * {@code this.toRawLongValue() - segment.address().toRawLongValue()}. Otherwise, if both addresses in the form
+     * {@code (B, O1)}, {@code (B, O2)}, where {@code B} is the same base heap object and {@code O1}, {@code O2}
+     * are byte offsets (relative to the base object) associated with this address and the segment's base address,
+     * the result is computed as {@code O1 - O2}.
+     * <p>
+     * If the segment's base address and this address are both heap addresses, but with different base objects, the result is undefined
+     * and an exception is thrown. Similarly, if the segment's base address is an heap address (resp. off-heap) and
+     * this address is an off-heap (resp. heap) address, the result is undefined and an exception is thrown.
+     * Otherwise, the result is a byte offset {@code SO}. If this address falls within the
+     * spatial bounds of the given segment, then {@code 0 <= SO < segment.byteSize()}; otherwise, {@code SO < 0 || SO > segment.byteSize()}.
+     * @return the offset of this memory address into the given segment.
+     * @param segment the segment relative to which this address offset should be computed
+     * @throws IllegalArgumentException if {@code segment} is not compatible with this address; this can happen, for instance,
+     * when {@code segment} models an heap memory region, while this address models an off-heap memory address.
      */
-    long segmentOffset();
+    long segmentOffset(MemorySegment segment);
 
     /**
      * Returns the raw long value associated to this memory address.
      * @return The raw long value associated to this memory address.
      * @throws UnsupportedOperationException if this memory address is associated with an heap segment.
      */
     long toRawLongValue();
 
-    /**
-     * Returns the memory segment (if any) this address belongs to.
-     * @return The memory segment this address belongs to, or {@code null} if no such segment exists.
-     */
-    MemorySegment segment();
-
-    /**
-     * Reinterpret this address as an offset into the provided segment.
-     * @param segment the segment to be rebased
-     * @return a new address pointing to the same memory location through the provided segment
-     * @throws IllegalArgumentException if the provided segment is not a valid rebase target for this address. This
-     * can happen, for instance, if an heap-based addressed is rebased to an off-heap memory segment.
-     */
-    MemoryAddress rebase(MemorySegment segment);
-
     /**
      * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified
      * object is also an address, and it refers to the same memory location as this address.
      *
      * @apiNote two addresses might be considered equal despite their associated segments differ. This
@@ -120,23 +111,20 @@
      */
     @Override
     int hashCode();
 
     /**
-     * The <em>unchecked</em> memory address instance modelling the {@code NULL} address. This address is <em>not</em> backed by
-     * a memory segment and hence it cannot be dereferenced.
+     * The off-heap memory address instance modelling the {@code NULL} address.
      */
-    MemoryAddress NULL = new MemoryAddressImpl( 0L);
+    MemoryAddress NULL = new MemoryAddressImpl(null,  0L);
 
     /**
-     * Obtain a new <em>unchecked</em> memory address instance from given long address. The returned address is <em>not</em> backed by
-     * a memory segment and hence it cannot be dereferenced.
+     * Obtain an off-heap memory address instance from given long address.
      * @param value the long address.
      * @return the new memory address instance.
      */
     static MemoryAddress ofLong(long value) {
         return value == 0 ?
                 NULL :
-                new MemoryAddressImpl(value);
+                new MemoryAddressImpl(null, value);
     }
-
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
@@ -44,48 +44,26 @@
  * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},
  * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type
  * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the
  * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways
  * to emulate different addressing modes. The var handles created by this class feature a <em>mandatory</em> coordinate type
- * (of type {@link MemoryAddress}), and zero or more {@code long} coordinate types, which can be used to emulate
- * multi-dimensional array indexing.
+ * (of type {@link MemorySegment}), and one {@code long} coordinate type, which represents the offset, in bytes, relative
+ * to the segment, at which dereference should occur.
  * <p>
  * As an example, consider the memory layout expressed by a {@link SequenceLayout} instance constructed as follows:
  * <blockquote><pre>{@code
-SequenceLayout seq = MemoryLayout.ofSequence(5,
-    MemoryLayout.ofStruct(
+GroupLayout seq = MemoryLayout.ofStruct(
         MemoryLayout.ofPaddingBits(32),
         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName("value")
-    ));
+));
  * }</pre></blockquote>
  * To access the member layout named {@code value}, we can construct a memory access var handle as follows:
  * <blockquote><pre>{@code
-VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); //(MemoryAddress) -> int
-handle = MemoryHandles.withOffset(handle, 4); //(MemoryAddress) -> int
-handle = MemoryHandles.withStride(handle, 8); //(MemoryAddress, long) -> int
+VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); //(MemorySegment, long) -> int
+handle = MemoryHandles.insertCoordinates(handle, 1, 4); //(MemorySegment) -> int
  * }</pre></blockquote>
  *
- * <h2>Addressing mode</h2>
- *
- * The final memory location accessed by a memory access var handle can be computed as follows:
- *
- * <blockquote><pre>{@code
-address = base + offset
- * }</pre></blockquote>
- *
- * where {@code base} denotes the address expressed by the {@link MemoryAddress} access coordinate, and {@code offset}
- * can be expressed in the following form:
- *
- * <blockquote><pre>{@code
-offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
- * }</pre></blockquote>
- *
- * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic</em> values provided as optional {@code long}
- * access coordinates, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are
- * <em>static</em> constants which are can be acquired through the {@link MemoryHandles#withOffset(VarHandle, long)}
- * and the {@link MemoryHandles#withStride(VarHandle, long)} combinators, respectively.
- *
  * <h2><a id="memaccess-mode"></a>Alignment and access modes</h2>
  *
  * A memory access var handle is associated with an access size {@code S} and an alignment constraint {@code B}
  * (both expressed in bytes). We say that a memory access operation is <em>fully aligned</em> if it occurs
  * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.
@@ -128,13 +106,10 @@
         //sorry, just the one!
     }
 
     private static final MethodHandle LONG_TO_ADDRESS;
     private static final MethodHandle ADDRESS_TO_LONG;
-    private static final MethodHandle ADD_OFFSET;
-    private static final MethodHandle ADD_STRIDE;
-
     private static final MethodHandle INT_TO_BYTE;
     private static final MethodHandle BYTE_TO_UNSIGNED_INT;
     private static final MethodHandle INT_TO_SHORT;
     private static final MethodHandle SHORT_TO_UNSIGNED_INT;
     private static final MethodHandle LONG_TO_BYTE;
@@ -148,16 +123,10 @@
         try {
             LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryHandles.class, "longToAddress",
                     MethodType.methodType(MemoryAddress.class, long.class));
             ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(MemoryHandles.class, "addressToLong",
                     MethodType.methodType(long.class, MemoryAddress.class));
-            ADD_OFFSET = MethodHandles.lookup().findStatic(MemoryHandles.class, "addOffset",
-                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class));
-
-            ADD_STRIDE = MethodHandles.lookup().findStatic(MemoryHandles.class, "addStride",
-                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class, long.class));
-
             INT_TO_BYTE = MethodHandles.explicitCastArguments(MethodHandles.identity(byte.class),
                     MethodType.methodType(byte.class, int.class));
             BYTE_TO_UNSIGNED_INT = MethodHandles.lookup().findStatic(Byte.class, "toUnsignedInt",
                     MethodType.methodType(int.class, byte.class));
             INT_TO_SHORT = MethodHandles.explicitCastArguments(MethodHandles.identity(short.class),
@@ -182,11 +151,11 @@
     }
 
     /**
      * Creates a memory access var handle with the given carrier type and byte order.
      *
-     * The resulting memory access var handle features a single {@link MemoryAddress} access coordinate,
+     * The resulting memory access var handle features a single {@link MemorySegment} access coordinate,
      * and its variable type is set by the given carrier type.
      *
      * The alignment constraint for the resulting memory access var handle is the same as the in memory size of the
      * carrier type, and the accessed offset is set at zero.
      *
@@ -207,11 +176,11 @@
     }
 
     /**
      * Creates a memory access var handle with the given carrier type, alignment constraint, and byte order.
      *
-     * The resulting memory access var handle features a single {@link MemoryAddress} access coordinate,
+     * The resulting memory access var handle features a single {@link MemorySegment} access coordinate,
      * and its variable type is set by the given carrier type.
      *
      * The accessed offset is zero.
      *
      * @apiNote the resulting var handle features certain <a href="#memaccess-mode">access mode restrictions</a>,
@@ -230,98 +199,15 @@
         if (alignmentBytes <= 0
                 || (alignmentBytes & (alignmentBytes - 1)) != 0) { // is power of 2?
             throw new IllegalArgumentException("Bad alignment: " + alignmentBytes);
         }
 
-        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, alignmentBytes - 1, byteOrder, 0, new long[]{}));
-    }
-
-    /**
-     * Returns a var handle that adds a <em>fixed</em> offset to the incoming {@link MemoryAddress} coordinate
-     * and then propagates such value to the target var handle. That is,
-     * when the returned var handle receives a memory address coordinate pointing at a memory location at
-     * offset <em>O</em>, a memory address coordinate pointing at a memory location at offset <em>O' + O</em>
-     * is created, and then passed to the target var handle.
-     *
-     * The returned var handle will feature the same type and access coordinates as the target var handle.
-     *
-     * @param target the target memory access handle to access after the offset adjustment.
-     * @param bytesOffset the offset, in bytes. Must be positive or zero.
-     * @return the adapted var handle.
-     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
-     */
-    public static VarHandle withOffset(VarHandle target, long bytesOffset) {
-        if (bytesOffset == 0) {
-            return target; //nothing to do
-        }
-
-        checkAddressFirstCoordinate(target);
-
-        if (JLI.isMemoryAccessVarHandle(target) &&
-                (bytesOffset & JLI.memoryAddressAlignmentMask(target)) == 0) {
-            //flatten
-            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
-                    JLI.memoryAddressCarrier(target),
-                    JLI.memoryAddressAlignmentMask(target),
-                    JLI.memoryAddressByteOrder(target),
-                    JLI.memoryAddressOffset(target) + bytesOffset,
-                    JLI.memoryAddressStrides(target)));
-        } else {
-            //slow path
-            VarHandle res = collectCoordinates(target, 0, ADD_OFFSET);
-            return insertCoordinates(res, 1, bytesOffset);
-        }
+        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, false, alignmentBytes - 1, byteOrder));
     }
 
     /**
-     * Returns a var handle which adds a <em>variable</em> offset to the incoming {@link MemoryAddress}
-     * access coordinate value and then propagates such value to the target var handle.
-     * That is, when the returned var handle receives a memory address coordinate pointing at a memory location at
-     * offset <em>O</em>, a new memory address coordinate pointing at a memory location at offset <em>(S * X) + O</em>
-     * is created, and then passed to the target var handle,
-     * where <em>S</em> is a constant <em>stride</em>, whereas <em>X</em> is a dynamic value that will be
-     * provided as an additional access coordinate (of type {@code long}).
-     *
-     * The returned var handle will feature the same type as the target var handle; an additional access coordinate
-     * of type {@code long} will be added to the access coordinate types of the target var handle at the position
-     * immediately following the leading access coordinate of type {@link MemoryAddress}.
-     *
-     * @param target the target memory access handle to access after the scale adjustment.
-     * @param bytesStride the stride, in bytes, by which to multiply the coordinate value.
-     * @return the adapted var handle.
-     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.
-     */
-    public static VarHandle withStride(VarHandle target, long bytesStride) {
-        if (bytesStride == 0) {
-            return dropCoordinates(target, 1, long.class); // dummy coordinate
-        }
-
-        checkAddressFirstCoordinate(target);
-
-        if (JLI.isMemoryAccessVarHandle(target) &&
-                (bytesStride & JLI.memoryAddressAlignmentMask(target)) == 0) {
-            //flatten
-            long[] strides = JLI.memoryAddressStrides(target);
-            long[] newStrides = new long[strides.length + 1];
-            System.arraycopy(strides, 0, newStrides, 1, strides.length);
-            newStrides[0] = bytesStride;
-
-            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
-                    JLI.memoryAddressCarrier(target),
-                    JLI.memoryAddressAlignmentMask(target),
-                    JLI.memoryAddressByteOrder(target),
-                    JLI.memoryAddressOffset(target),
-                    newStrides));
-        } else {
-            //slow path
-            VarHandle res = collectCoordinates(target, 0, ADD_STRIDE);
-            return insertCoordinates(res, 2, bytesStride);
-        }
-    }
-
-    /**
-     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemoryAddress}.
+     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemorySegment}.
      * That is, when calling {@link VarHandle#get(Object...)} on the returned var handle,
      * the read numeric value will be turned into a memory address (as if by calling {@link MemoryAddress#ofLong(long)});
      * similarly, when calling {@link VarHandle#set(Object...)}, the memory address to be set will be converted
      * into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to)
      * memory depends on the carrier of the original memory access var handle.
@@ -360,12 +246,12 @@
      * the case if modeled as a Java {@code short}. This is illustrated in the following example:
      * <blockquote><pre>{@code
     MemorySegment segment = MemorySegment.allocateNative(2);
     VarHandle SHORT_VH = MemoryLayouts.JAVA_SHORT.varHandle(short.class);
     VarHandle INT_VH = MemoryHandles.asUnsigned(SHORT_VH, int.class);
-    SHORT_VH.set(segment.address(), (short)-1);
-    INT_VH.get(segment.address()); // returns 65535
+    SHORT_VH.set(segment, (short)-1);
+    INT_VH.get(segment); // returns 65535
      * }</pre></blockquote>
      * <p>
      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var
      * handle, the incoming value (of type {@code adaptedType}) is converted by a
      * <i>narrowing primitive conversion</i> and then passed to the {@code
@@ -618,12 +504,12 @@
         return JLI.dropCoordinates(target, pos, valueTypes);
     }
 
     private static void checkAddressFirstCoordinate(VarHandle handle) {
         if (handle.coordinateTypes().size() < 1 ||
-                handle.coordinateTypes().get(0) != MemoryAddress.class) {
-            throw new IllegalArgumentException("Expected var handle with leading coordinate of type MemoryAddress");
+                handle.coordinateTypes().get(0) != MemorySegment.class) {
+            throw new IllegalArgumentException("Expected var handle with leading coordinate of type MemorySegment");
         }
     }
 
     private static void checkCarrier(Class<?> carrier) {
         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
@@ -660,14 +546,6 @@
     }
 
     private static long addressToLong(MemoryAddress value) {
         return value.toRawLongValue();
     }
-
-    private static MemoryAddress addOffset(MemoryAddress address, long offset) {
-        return address.addOffset(offset);
-    }
-
-    private static MemoryAddress addStride(MemoryAddress address, long index, long stride) {
-        return address.addOffset(index * stride);
-    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
@@ -368,10 +368,28 @@
     }
 
     /**
      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
      * where the path is considered rooted in this layout.
+     * <p>
+     * The final memory location accessed by the returned memory access var handle can be computed as follows:
+     *
+     * <blockquote><pre>{@code
+    address = base + offset
+     * }</pre></blockquote>
+     *
+     * where {@code base} denotes the base address expressed by the {@link MemorySegment} access coordinate
+     * (see {@link MemorySegment#address()} and {@link MemoryAddress#toRawLongValue()}) and {@code offset}
+     * can be expressed in the following form:
+     *
+     * <blockquote><pre>{@code
+    offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
+     * }</pre></blockquote>
+     *
+     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic</em> values provided as optional {@code long}
+     * access coordinates, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are
+     * <em>static</em> stride constants which are derived from the layout path.
      *
      * @apiNote the resulting var handle will feature an additional {@code long} access coordinate for every
      * unspecified sequence access component contained in this layout path. Moreover, the resulting var handle
      * features certain <a href="MemoryHandles.html#memaccess-mode">access mode restrictions</a>, which are common to all memory access var handles.
      *
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -174,10 +174,12 @@
     /**
      * The base memory address associated with this memory segment. The returned address is
      * a <em>checked</em> memory address and can therefore be used in dereference operations
      * (see {@link MemoryAddress}).
      * @return The base memory address.
+     * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
+     * thread owning this segment
      */
     @Override
     MemoryAddress address();
 
     /**
@@ -276,10 +278,31 @@
      * @return a new memory segment view with updated base/limit addresses.
      * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}
      */
     MemorySegment asSlice(long offset, long newSize);
 
+    /**
+     * Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
+     * and whose new size is computed by subtracting the specified offset from this segment size.
+     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.
+     * @return a new memory segment view with updated base/limit addresses.
+     * @throws IndexOutOfBoundsException if {@code offset < 0}, or {@code offset > byteSize()}.
+     */
+    MemorySegment asSlice(long offset);
+
+    /**
+     * Obtains a new memory segment view whose base address is the address passed as argument,
+     * and whose new size is computed by subtracting the address offset relative to this segment
+     * (see {@link MemoryAddress#segmentOffset(MemorySegment)}) from this segment size.
+     * @param address The new segment base offset (relative to the current segment base address), specified in bytes.
+     * @return a new memory segment view with updated base/limit addresses.
+     * @throws IndexOutOfBoundsException if {@code address.segmentOffset(this) < 0}, or {@code address.segmentOffset(this) > byteSize()}.
+     */
+    default MemorySegment asSlice(MemoryAddress address) {
+        return asSlice(address.segmentOffset(this));
+    }
+
     /**
      * Is this segment alive?
      * @return true, if the segment is alive.
      * @see MemorySegment#close()
      */
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
@@ -26,12 +26,13 @@
 
 /**
  * <p> Classes to support low-level, safe and efficient memory access.
  * <p>
  * The key abstractions introduced by this package are {@link jdk.incubator.foreign.MemorySegment} and {@link jdk.incubator.foreign.MemoryAddress}.
- * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which can
- * sometimes be expressed as an offset into a given segment. A memory address represents the main access coordinate of a memory access var handle, which can be obtained
+ * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which also can
+ * reside either inside or outside the Java heap (and can sometimes be expressed as an offset into a given segment).
+ * A memory segment represents the main access coordinate of a memory access var handle, which can be obtained
  * using the combinator methods defined in the {@link jdk.incubator.foreign.MemoryHandles} class. Finally, the {@link jdk.incubator.foreign.MemoryLayout} class
  * hierarchy enables description of <em>memory layouts</em> and basic operations such as computing the size in bytes of a given
  * layout, obtain its alignment requirements, and so on. Memory layouts also provide an alternate, more abstract way, to produce
  * memory access var handles, e.g. using <a href="MemoryLayout.html#layout-paths"><em>layout paths</em></a>.
  *
@@ -40,13 +41,12 @@
  *
  * <pre>{@code
 static final VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
 
 try (MemorySegment segment = MemorySegment.allocateNative(10 * 4)) {
-    MemoryAddress base = segment.address();
     for (long i = 0 ; i < 10 ; i++) {
-       intHandle.set(base.addOffset(i * 4), (int)i);
+       intHandle.set(base.asSlice(i * 4), (int)i);
     }
 }
  * }</pre>
  *
  * Here we create a var handle, namely {@code intHandle}, to manipulate values of the primitive type {@code int}, at
@@ -75,18 +75,18 @@
  * models such as this can be very convenient - clients do not have to remember to <em>close</em> a direct buffer - such models can also make it
  * hard for clients to ensure that the memory associated with a direct buffer has indeed been released.
  *
  * <h2><a id="safety"></a>Safety</h2>
  *
- * This API provides strong safety guarantees when it comes to memory access. First, when dereferencing a memory segment using
- * a memory address, such an address is validated (upon access), to make sure that it does not point to a memory location
- * which resides <em>outside</em> the boundaries of the memory segment it refers to. We call this guarantee <em>spatial safety</em>;
+ * This API provides strong safety guarantees when it comes to memory access. First, when dereferencing a memory segment,
+ * the access coordinates are validated (upon access), to make sure that access does not occur at an address which resides
+ * <em>outside</em> the boundaries of the memory segment used by the dereference operation. We call this guarantee <em>spatial safety</em>;
  * in other words, access to memory segments is bounds-checked, in the same way as array access is, as described in
  * Section {@jls 15.10.4} of <cite>The Java Language Specification</cite>.
  * <p>
- * Since memory segments can be closed (see above), a memory address is also validated (upon access) to make sure that
- * the segment it belongs to has not been closed prematurely. We call this guarantee <em>temporal safety</em>. Note that,
+ * Since memory segments can be closed (see above), segments are also validated (upon access) to make sure that
+ * the segment being accessed has not been closed prematurely. We call this guarantee <em>temporal safety</em>. Note that,
  * in the general case, guaranteeing temporal safety can be hard, as multiple threads could attempt to access and/or close
  * the same memory segment concurrently. The memory access API addresses this problem by imposing strong
  * <a href="MemorySegment.html#thread-confinement"><em>thread-confinement</em></a> guarantees on memory segments: each
  * memory segment is associated with an owner thread, which is the only thread that can either access or close the segment.
  * <p>
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -101,10 +101,16 @@
     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
         checkBounds(offset, newSize);
         return asSliceNoCheck(offset, newSize);
     }
 
+    @Override
+    public AbstractMemorySegmentImpl asSlice(long offset) {
+        checkBounds(offset, 0);
+        return asSliceNoCheck(offset, length - offset);
+    }
+
     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
         return dup(offset, newSize, mask, scope);
     }
 
     @SuppressWarnings("unchecked")
@@ -117,20 +123,20 @@
                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));
     }
 
     @Override
     public final MemorySegment fill(byte value){
-        checkRange(0, length, true);
+        checkAccess(0, length, false);
         UNSAFE.setMemory(base(), min(), length, value);
         return this;
     }
 
     public void copyFrom(MemorySegment src) {
         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;
         long size = that.byteSize();
-        checkRange(0, size, true);
-        that.checkRange(0, size, false);
+        checkAccess(0, size, false);
+        that.checkAccess(0, size, true);
         UNSAFE.copyMemory(
                 that.base(), that.min(),
                 base(), min(), size);
     }
 
@@ -141,19 +147,19 @@
     public long mismatch(MemorySegment other) {
         AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;
         final long thisSize = this.byteSize();
         final long thatSize = that.byteSize();
         final long length = Math.min(thisSize, thatSize);
-        this.checkRange(0, length, false);
-        that.checkRange(0, length, false);
+        this.checkAccess(0, length, true);
+        that.checkAccess(0, length, true);
         if (this == other) {
             return -1;
         }
 
         long i = 0;
         if (length > 7) {
-            if ((byte) BYTE_HANDLE.get(this.address(), 0) != (byte) BYTE_HANDLE.get(that.address(), 0)) {
+            if ((byte) BYTE_HANDLE.get(this, 0) != (byte) BYTE_HANDLE.get(that, 0)) {
                 return 0;
             }
             i = ArraysSupport.vectorizedMismatchLargeForBytes(
                     this.base(), this.min(),
                     that.base(), that.min(),
@@ -163,24 +169,23 @@
             }
             long remaining = ~i;
             assert remaining < 8 : "remaining greater than 7: " + remaining;
             i = length - remaining;
         }
-        MemoryAddress thisAddress = this.address();
-        MemoryAddress thatAddress = that.address();
         for (; i < length; i++) {
-            if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {
+            if ((byte) BYTE_HANDLE.get(this, i) != (byte) BYTE_HANDLE.get(that, i)) {
                 return i;
             }
         }
         return thisSize != thatSize ? length : -1;
     }
 
     @Override
     @ForceInline
     public final MemoryAddress address() {
-        return new MemoryAddressImpl(this, 0);
+        checkValidState();
+        return new MemoryAddressImpl(base(), min());
     }
 
     @Override
     public final ByteBuffer asByteBuffer() {
         if (!isSet(READ)) {
@@ -314,24 +319,36 @@
         MemorySegment arrSegment = segmentFactory.apply(arr);
         arrSegment.copyFrom(this);
         return arr;
     }
 
-    boolean isSmall() {
+    @Override
+    public boolean isSmall() {
         return isSet(SMALL);
     }
 
-    void checkRange(long offset, long length, boolean writeAccess) {
+    @Override
+    public void checkAccess(long offset, long length, boolean readOnly) {
         scope.checkValidState();
-        if (writeAccess && !isSet(WRITE)) {
+        if (!readOnly && !isSet(WRITE)) {
             throw unsupportedAccessMode(WRITE);
-        } else if (!writeAccess && !isSet(READ)) {
+        } else if (readOnly && !isSet(READ)) {
             throw unsupportedAccessMode(READ);
         }
         checkBounds(offset, length);
     }
 
+    @Override
+    public long unsafeGetOffset() {
+        return min();
+    }
+
+    @Override
+    public Object unsafeGetBase() {
+        return base();
+    }
+
     @Override
     public final void checkValidState() {
         scope.checkValidState();
     }
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LayoutPath.java
@@ -23,25 +23,32 @@
  *  questions.
  *
  */
 package jdk.internal.foreign;
 
+import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
 import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.internal.access.SharedSecrets;
-import sun.invoke.util.Wrapper;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
+import sun.invoke.util.Wrapper;
 
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.List;
 import java.util.function.ToLongFunction;
 import java.util.function.UnaryOperator;
-import java.util.stream.LongStream;
 
 /**
  * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout, ToLongFunction)},
  * a path can be constructed by selecting layout elements using the selector methods provided by this class
  * (see {@link #sequenceElement()}, {@link #sequenceElement(long)}, {@link #sequenceElement(long, long)}, {@link #groupElement(String)}).
@@ -51,10 +58,21 @@
  */
 public class LayoutPath {
 
     private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();
 
+    private static final MethodHandle ADD_STRIDE;
+
+    static {
+        try {
+            ADD_STRIDE = MethodHandles.lookup().findStatic(LayoutPath.class, "addStride",
+                    MethodType.methodType(long.class, MemorySegment.class, long.class, long.class, long.class));
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
     private final MemoryLayout layout;
     private final long offset;
     private final LayoutPath enclosing;
     private final long[] strides;
     private final long elementIndex;
@@ -139,16 +157,34 @@
             throw new IllegalArgumentException("Invalid carrier: " + carrier + ", for layout " + layout);
         }
 
         checkAlignment(this);
 
-        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(
-                carrier,
-                layout.byteAlignment() - 1, //mask
-                ((ValueLayout) layout).order(),
-                Utils.bitsToBytesOrThrow(offset, IllegalStateException::new),
-                LongStream.of(strides).map(s -> Utils.bitsToBytesOrThrow(s, IllegalStateException::new)).toArray()));
+        List<Class<?>> expectedCoordinates = new ArrayList<>();
+        Deque<Integer> perms = new ArrayDeque<>();
+        perms.addFirst(0);
+        expectedCoordinates.add(MemorySegment.class);
+
+        VarHandle handle = Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, true, layout.byteAlignment() - 1,
+                ((ValueLayout)layout).order()));
+
+        for (int i = 0 ; i < strides.length ; i++) {
+            expectedCoordinates.add(long.class);
+            perms.addFirst(0);
+            perms.addLast(i + 1);
+            //add stride
+            handle = MemoryHandles.collectCoordinates(handle, 1 + i,
+                    MethodHandles.insertArguments(ADD_STRIDE, 1, Utils.bitsToBytesOrThrow(strides[strides.length - 1 - i], IllegalStateException::new))); // MS, long, MS_n, long_n, long
+        }
+        //add offset
+        handle = MemoryHandles.insertCoordinates(handle, 1 + strides.length, Utils.bitsToBytesOrThrow(offset, IllegalStateException::new));
+
+        if (strides.length > 0) {
+            // remove duplicate MS args
+            handle = MemoryHandles.permuteCoordinates(handle, expectedCoordinates, perms.stream().mapToInt(i -> i).toArray());
+        }
+        return handle;
     }
 
     public MemoryLayout layout() {
         return layout;
     }
@@ -282,6 +318,11 @@
 
         public PathKind kind() {
             return kind;
         }
     }
+
+    private static long addStride(MemorySegment segment, long stride, long base, long index) {
+        return MemorySegmentProxy.addOffsets(base,
+                    MemorySegmentProxy.multiplyOffsets(stride, index, ((MemorySegmentProxy)segment)), (MemorySegmentProxy)segment);
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -23,114 +23,72 @@
  *  questions.
  *
  */
 package jdk.internal.foreign;
 
-import jdk.internal.access.foreign.MemoryAddressProxy;
-import jdk.internal.misc.Unsafe;
-
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
 import java.util.Objects;
 
 /**
  * This class provides an immutable implementation for the {@code MemoryAddress} interface. This class contains information
  * about the segment this address is associated with, as well as an offset into such segment.
  */
-public final class MemoryAddressImpl implements MemoryAddress, MemoryAddressProxy {
-
-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+public final class MemoryAddressImpl implements MemoryAddress {
 
-    private final AbstractMemorySegmentImpl segment;
+    private final Object base;
     private final long offset;
 
-    public MemoryAddressImpl(long offset) {
-        this.segment = AbstractMemorySegmentImpl.NOTHING;
-        this.offset = offset;
-    }
-
-    public MemoryAddressImpl(AbstractMemorySegmentImpl segment, long offset) {
-        this.segment = Objects.requireNonNull(segment);
+    public MemoryAddressImpl(Object base, long offset) {
+        this.base = base;
         this.offset = offset;
     }
 
     // MemoryAddress methods
 
     @Override
-    public long segmentOffset() {
-        if (segment() == null) {
-            throw new UnsupportedOperationException("Address does not have a segment");
+    public long segmentOffset(MemorySegment segment) {
+        Objects.requireNonNull(segment);
+        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
+        if (segmentImpl.base() != base) {
+            throw new IllegalArgumentException("Invalid segment: " + segment);
         }
-        return offset;
+        return offset - segmentImpl.min();
     }
 
     @Override
     public long toRawLongValue() {
-        if (unsafeGetBase() != null) {
+        if (base != null) {
             throw new UnsupportedOperationException("Not a native address");
         }
-        return unsafeGetOffset();
-    }
-
-    @Override
-    public MemorySegment segment() {
-        return segment != AbstractMemorySegmentImpl.NOTHING ?
-                segment : null;
+        return offset;
     }
 
     @Override
     public MemoryAddress addOffset(long bytes) {
-        return new MemoryAddressImpl(segment, offset + bytes);
+        return new MemoryAddressImpl(base, offset + bytes);
     }
 
-    @Override
-    public MemoryAddress rebase(MemorySegment segment) {
-        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
-        if (segmentImpl.base() != this.segment.base()) {
-            throw new IllegalArgumentException("Invalid rebase target: " + segment);
-        }
-        return new MemoryAddressImpl((AbstractMemorySegmentImpl)segment,
-                unsafeGetOffset() - ((MemoryAddressImpl)segment.address()).unsafeGetOffset());
-    }
-
-    // MemoryAddressProxy methods
-
-    public void checkAccess(long offset, long length, boolean readOnly) {
-        segment.checkRange(MemoryAddressProxy.addOffsets(this.offset, offset, this), length, !readOnly);
-    }
-
-    public long unsafeGetOffset() {
-        return segment.min() + offset;
-    }
-
-    public Object unsafeGetBase() {
-        return segment.base();
-    }
-
-    @Override
-    public boolean isSmall() {
-        return segment.isSmall();
-    }
     // Object methods
 
     @Override
     public int hashCode() {
-        return Objects.hash(unsafeGetBase(), unsafeGetOffset());
+        return Objects.hash(base, offset);
     }
 
     @Override
     public boolean equals(Object that) {
         if (that instanceof MemoryAddressImpl) {
             MemoryAddressImpl addr = (MemoryAddressImpl)that;
-            return Objects.equals(unsafeGetBase(), ((MemoryAddressImpl) that).unsafeGetBase()) &&
-                    unsafeGetOffset() == addr.unsafeGetOffset();
+            return Objects.equals(base, addr.base) &&
+                    offset == addr.offset;
         } else {
             return false;
         }
     }
 
     @Override
     public String toString() {
-        return "MemoryAddress{ region: " + segment + " offset=0x" + Long.toHexString(offset) + " }";
+        return "MemoryAddress{ base: " + base + " offset=0x" + Long.toHexString(offset) + " }";
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -26,11 +26,12 @@
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
-import jdk.internal.access.foreign.MemoryAddressProxy;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.misc.VM;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
@@ -48,12 +49,12 @@
 
     private static final MethodHandle ADDRESS_FILTER;
 
     static {
         try {
-            ADDRESS_FILTER = MethodHandles.lookup().findStatic(Utils.class, "filterAddress",
-                    MethodType.methodType(MemoryAddressProxy.class, MemoryAddress.class));
+            ADDRESS_FILTER = MethodHandles.lookup().findStatic(Utils.class, "filterSegment",
+                    MethodType.methodType(MemorySegmentProxy.class, MemorySegment.class));
         } catch (Throwable ex) {
             throw new ExceptionInInitializerError(ex);
         }
     }
 
@@ -73,12 +74,12 @@
         // This adaptation is required, otherwise the memory access var handle will have type MemoryAddressProxy,
         // and not MemoryAddress (which the user expects), which causes performance issues with asType() adaptations.
         return MemoryHandles.filterCoordinates(handle, 0, ADDRESS_FILTER);
     }
 
-    private static MemoryAddressProxy filterAddress(MemoryAddress addr) {
-        return (MemoryAddressImpl)addr;
+    private static MemorySegmentProxy filterSegment(MemorySegment segment) {
+        return (AbstractMemorySegmentImpl)segment;
     }
 
     public static void checkRestrictedAccess(String method) {
         switch (foreignRestrictedAccess) {
             case "deny" -> throwIllegalAccessError(foreignRestrictedAccess, method);
diff a/test/jdk/java/foreign/TestAdaptVarHandles.java b/test/jdk/java/foreign/TestAdaptVarHandles.java
--- a/test/jdk/java/foreign/TestAdaptVarHandles.java
+++ b/test/jdk/java/foreign/TestAdaptVarHandles.java
@@ -31,10 +31,11 @@
  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAdaptVarHandles
  */
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.ValueLayout;
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
@@ -68,11 +69,11 @@
                     MethodType.methodType(String.class, String.class, String.class, int.class));
             O2I = MethodHandles.explicitCastArguments(S2I, MethodType.methodType(int.class, Object.class));
             I2O = MethodHandles.explicitCastArguments(I2S, MethodType.methodType(Object.class, int.class));
             S2L = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "stringToLong", MethodType.methodType(long.class, String.class));
             S2L_EX = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "stringToLongException", MethodType.methodType(long.class, String.class));
-            BASE_ADDR = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "baseAddress", MethodType.methodType(MemoryAddress.class, MemorySegment.class));
+            BASE_ADDR = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "baseAddress", MethodType.methodType(MemorySegment.class, MemorySegment.class));
             SUM_OFFSETS = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "sumOffsets", MethodType.methodType(long.class, long.class, long.class));
             VOID_FILTER = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, "void_filter", MethodType.methodType(void.class, String.class));
 
             MethodHandle s2i_ex = MethodHandles.throwException(int.class, Throwable.class);
             s2i_ex = MethodHandles.insertArguments(s2i_ex, 0, new Throwable());
@@ -84,26 +85,33 @@
         } catch (Throwable ex) {
             throw new ExceptionInInitializerError();
         }
     }
 
+    static final VarHandle intHandleIndexed = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)
+            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
+
+    static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
+
+    static final VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);
+
     @Test
     public void testFilterValue() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, S2I, I2S);
-        i2SHandle.set(segment.address(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
+        i2SHandle.set(segment, "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment, "42");
         assertEquals(oldValue, "1");
-        String value = (String)i2SHandle.get(segment.address());
+        String value = (String)i2SHandle.get(segment);
         assertEquals(value, "43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment, "12", "42");
         assertEquals(oldValue, "12");
-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);
         assertEquals(value, "42");
     }
 
     @Test
     public void testFilterValueComposite() throws Throwable {
@@ -111,62 +119,59 @@
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         MethodHandle CTX_S2I = MethodHandles.dropArguments(S2I, 0, String.class, String.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, CTX_S2I, CTX_I2S);
         i2SHandle = MemoryHandles.insertCoordinates(i2SHandle, 1, "a", "b");
-        i2SHandle.set(segment.address(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
+        i2SHandle.set(segment, "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment, "42");
         assertEquals(oldValue, "ab1");
-        String value = (String)i2SHandle.get(segment.address());
+        String value = (String)i2SHandle.get(segment);
         assertEquals(value, "ab43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment, "12", "42");
         assertEquals(oldValue, "ab12");
-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);
         assertEquals(value, "ab42");
     }
 
     @Test
     public void testFilterValueLoose() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, O2I, I2O);
-        i2SHandle.set(segment.address(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
+        i2SHandle.set(segment, "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment, "42");
         assertEquals(oldValue, "1");
-        String value = (String)i2SHandle.get(segment.address());
+        String value = (String)i2SHandle.get(segment);
         assertEquals(value, "43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment, "12", "42");
         assertEquals(oldValue, "12");
-        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);
         assertEquals(value, "42");
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterNullTarget() {
         MemoryHandles.filterValue(null, S2I, I2S);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterNullUnbox() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterValue(intHandle, null, I2S);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterNullBox() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterValue(intHandle, S2I, null);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCarrier() {
-        VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);
         MemoryHandles.filterValue(floatHandle, S2I, I2S);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterUnboxArity() {
@@ -214,12 +219,11 @@
 
     @Test
     public void testFilterCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_longIndex = MemoryHandles.filterCoordinates(intHandle, 0, BASE_ADDR, S2L);
+        VarHandle intHandle_longIndex = MemoryHandles.filterCoordinates(intHandleIndexed, 0, BASE_ADDR, S2L);
         intHandle_longIndex.set(segment, "0", 1);
         int oldValue = (int)intHandle_longIndex.getAndAdd(segment, "0", 42);
         assertEquals(oldValue, 1);
         int value = (int)intHandle_longIndex.get(segment, "0");
         assertEquals(value, 43);
@@ -236,50 +240,43 @@
         MemoryHandles.filterCoordinates(null, 0, S2I);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterCoordinatesNullFilters() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterCoordinates(intHandle, 0, null);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCoordinatesNegativePos() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterCoordinates(intHandle, -1, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCoordinatesPosTooBig() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.filterCoordinates(intHandle, 1, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCoordinatesWrongFilterType() {
-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);
-        MemoryHandles.filterCoordinates(intHandle, 1, S2I);
+        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2I);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCoordinatesWrongFilterException() {
-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);
-        MemoryHandles.filterCoordinates(intHandle, 1, S2L_EX);
+        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2L_EX);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadFilterCoordinatesTooManyFilters() {
-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);
-        MemoryHandles.filterCoordinates(intHandle, 1, S2L, S2L);
+        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2L, S2L);
     }
 
     @Test
     public void testInsertCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandle, 0, segment.address(), 0L);
+        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandleIndexed, 0, segment, 0L);
         intHandle_longIndex.set(1);
         int oldValue = (int)intHandle_longIndex.getAndAdd(42);
         assertEquals(oldValue, 1);
         int value = (int)intHandle_longIndex.get();
         assertEquals(value, 43);
@@ -296,193 +293,170 @@
         MemoryHandles.insertCoordinates(null, 0, 42);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadInsertCoordinatesNullValues() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.insertCoordinates(intHandle, 0, null);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadInsertCoordinatesNegativePos() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.insertCoordinates(intHandle, -1, 42);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadInsertCoordinatesPosTooBig() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.insertCoordinates(intHandle, 1, 42);
     }
 
     @Test(expectedExceptions = ClassCastException.class)
     public void testBadInsertCoordinatesWrongCoordinateType() {
-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);
-        MemoryHandles.insertCoordinates(intHandle, 1, "Hello");
+        MemoryHandles.insertCoordinates(intHandleIndexed, 1, "Hello");
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadInsertCoordinatesTooManyValues() {
-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);
-        MemoryHandles.insertCoordinates(intHandle, 1, 0L, 0L);
+        MemoryHandles.insertCoordinates(intHandleIndexed, 1, 0L, 0L);
     }
 
     @Test
     public void testPermuteCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_swap = MemoryHandles.permuteCoordinates(intHandle,
-                List.of(long.class, MemoryAddress.class), 1, 0);
-        intHandle_swap.set(0L, segment.address(), 1);
-        int oldValue = (int)intHandle_swap.getAndAdd(0L, segment.address(), 42);
+        VarHandle intHandle_swap = MemoryHandles.permuteCoordinates(intHandleIndexed,
+                List.of(long.class, MemorySegment.class), 1, 0);
+        intHandle_swap.set(0L, segment, 1);
+        int oldValue = (int)intHandle_swap.getAndAdd(0L, segment, 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_swap.get(0L, segment.address());
+        int value = (int)intHandle_swap.get(0L, segment);
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_swap.compareAndSet(0L, segment.address(), 43, 12);
+        boolean swapped = (boolean)intHandle_swap.compareAndSet(0L, segment, 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_swap.compareAndExchange(0L, segment.address(), 12, 42);
+        oldValue = (int)intHandle_swap.compareAndExchange(0L, segment, 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_swap.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(0L, segment.address());
+        value = (int)intHandle_swap.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(0L, segment);
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadPermuteCoordinatesNullTarget() {
         MemoryHandles.permuteCoordinates(null, List.of());
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadPermuteCoordinatesNullCoordinates() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, null);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadPermuteCoordinatesNullReorder() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, List.of(int.class), null);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadPermuteCoordinatesTooManyCoordinates() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), new int[2]);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadPermuteCoordinatesTooFewCoordinates() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, List.of());
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadPermuteCoordinatesIndexTooBig() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), 3);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadPermuteCoordinatesIndexTooSmall() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), -1);
     }
 
     @Test
     public void testCollectCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_sum = MemoryHandles.collectCoordinates(intHandle, 1, SUM_OFFSETS);
-        intHandle_sum.set(segment.address(), -2L, 2L, 1);
-        int oldValue = (int)intHandle_sum.getAndAdd(segment.address(), -2L, 2L, 42);
+        VarHandle intHandle_sum = MemoryHandles.collectCoordinates(intHandleIndexed, 1, SUM_OFFSETS);
+        intHandle_sum.set(segment, -2L, 2L, 1);
+        int oldValue = (int)intHandle_sum.getAndAdd(segment, -2L, 2L, 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_sum.get(segment.address(), -2L, 2L);
+        int value = (int)intHandle_sum.get(segment, -2L, 2L);
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_sum.compareAndSet(segment.address(), -2L, 2L, 43, 12);
+        boolean swapped = (boolean)intHandle_sum.compareAndSet(segment, -2L, 2L, 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_sum.compareAndExchange(segment.address(), -2L, 2L, 12, 42);
+        oldValue = (int)intHandle_sum.compareAndExchange(segment, -2L, 2L, 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_sum.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address(), -2L, 2L);
+        value = (int)intHandle_sum.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, -2L, 2L);
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadCollectCoordinatesNullTarget() {
         MemoryHandles.collectCoordinates(null, 0, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadCollectCoordinatesNullFilters() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, 0, null);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadCollectCoordinatesNegativePos() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, -1, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadCollectCoordinatesPosTooBig() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, 1, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadCollectCoordinatesWrongFilterType() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, 0, SUM_OFFSETS);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadCollectCoordinatesWrongVoidFilterType() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, 0, VOID_FILTER);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadCollectCoordinatesWrongFilterException() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.collectCoordinates(intHandle, 0, S2L_EX);
     }
 
     @Test
     public void testDropCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_dummy = MemoryHandles.dropCoordinates(intHandle, 1, float.class, String.class);
-        intHandle_dummy.set(segment.address(), 1f, "hello", 0L, 1);
-        int oldValue = (int)intHandle_dummy.getAndAdd(segment.address(), 1f, "hello", 0L, 42);
+        VarHandle intHandle_dummy = MemoryHandles.dropCoordinates(intHandleIndexed, 1, float.class, String.class);
+        intHandle_dummy.set(segment, 1f, "hello", 0L, 1);
+        int oldValue = (int)intHandle_dummy.getAndAdd(segment, 1f, "hello", 0L, 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_dummy.get(segment.address(), 1f, "hello", 0L);
+        int value = (int)intHandle_dummy.get(segment, 1f, "hello", 0L);
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment.address(), 1f, "hello", 0L, 43, 12);
+        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment, 1f, "hello", 0L, 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_dummy.compareAndExchange(segment.address(), 1f, "hello", 0L, 12, 42);
+        oldValue = (int)intHandle_dummy.compareAndExchange(segment, 1f, "hello", 0L, 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address(), 1f, "hello", 0L);
+        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 1f, "hello", 0L);
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadDropCoordinatesNegativePos() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.dropCoordinates(intHandle, -1);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadDropCoordinatesPosTooBig() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.dropCoordinates(intHandle, 2);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadDropCoordinatesNullValueTypes() {
-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         MemoryHandles.dropCoordinates(intHandle, 1, null);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadDropCoordinatesNullTarget() {
@@ -505,12 +479,12 @@
 
     static long stringToLongException(String s) throws Throwable {
         return Long.valueOf(s);
     }
 
-    static MemoryAddress baseAddress(MemorySegment segment) {
-        return segment.address();
+    static MemorySegment baseAddress(MemorySegment segment) {
+        return segment;
     }
 
     static long sumOffsets(long l1, long l2) {
         return l1 + l2;
     }
diff a/test/jdk/java/foreign/TestAddressHandle.java b/test/jdk/java/foreign/TestAddressHandle.java
--- a/test/jdk/java/foreign/TestAddressHandle.java
+++ b/test/jdk/java/foreign/TestAddressHandle.java
@@ -59,96 +59,89 @@
         }
     }
 
     @Test(dataProvider = "addressHandles")
     public void testAddressHandle(VarHandle addrHandle, int byteSize) {
-        VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
+        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
-            MemoryAddress target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?
-                    segment.address().addOffset(8 - byteSize) :
-                    segment.address();
-            longHandle.set(segment.address(), 42L);
+            MemorySegment target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?
+                    segment.asSlice(8 - byteSize) :
+                    segment;
+            longHandle.set(segment, 42L);
             MemoryAddress address = (MemoryAddress)addrHandle.get(target);
             assertEquals(address.toRawLongValue(), 42L);
-            try {
-                longHandle.get(address); // check that address cannot be de-referenced
-                fail();
-            } catch (UnsupportedOperationException ex) {
-                assertTrue(true);
-            }
             addrHandle.set(target, address.addOffset(1));
-            long result = (long)longHandle.get(segment.address());
+            long result = (long)longHandle.get(segment);
             assertEquals(43L, result);
         }
     }
 
     @Test(dataProvider = "addressHandles")
     public void testNull(VarHandle addrHandle, int byteSize) {
-        VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
+        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
-            longHandle.set(segment.address(), 0L);
-            MemoryAddress address = (MemoryAddress)addrHandle.get(segment.address());
+            longHandle.set(segment, 0L);
+            MemoryAddress address = (MemoryAddress)addrHandle.get(segment);
             assertTrue(address == MemoryAddress.NULL);
         }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadAdaptFloat() {
-        VarHandle floatHandle = MemoryHandles.varHandle(float.class, ByteOrder.nativeOrder());
+        VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);
         MemoryHandles.asAddressVarHandle(floatHandle);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadAdaptDouble() {
-        VarHandle doubleHandle = MemoryHandles.varHandle(double.class, ByteOrder.nativeOrder());
+        VarHandle doubleHandle = MemoryLayouts.JAVA_DOUBLE.varHandle(double.class);
         MemoryHandles.asAddressVarHandle(doubleHandle);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadAdaptBoolean() {
-        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         VarHandle boolHandle = MemoryHandles.filterValue(intHandle, BOOL_TO_INT, INT_TO_BOOL);
         MemoryHandles.asAddressVarHandle(boolHandle);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadAdaptString() {
-        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
         VarHandle stringHandle = MemoryHandles.filterValue(intHandle, STRING_TO_INT, INT_TO_STRING);
         MemoryHandles.asAddressVarHandle(stringHandle);
     }
 
     @DataProvider(name = "addressHandles")
     static Object[][] addressHandles() {
         return new Object[][] {
                 // long
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder())), 8 },
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)), 8 },
+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)), 8 },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_LONG.varHandle(long.class)), 8 },
 
                 // int
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder())), 4 },
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)), 4 },
+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)), 4 },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_INT.varHandle(int.class)), 4 },
 
                 // short
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder())), 2 },
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)), 2 },
+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)), 2 },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_SHORT.varHandle(short.class)), 2 },
 
                 // char
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder())), 2 },
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)), 2 },
+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)), 2 },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_CHAR.varHandle(char.class)), 2 },
 
                 // byte
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder())), 1 },
-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)), 1 },
+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)), 1 },
                 { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_BYTE.varHandle(byte.class)), 1 }
         };
     }
 
+    static VarHandle at(VarHandle handle, long offset) {
+        return MemoryHandles.insertCoordinates(handle, 1, offset);
+    }
+
     static int boolToInt(boolean value) {
         return value ? 1 : 0;
     }
 
     static boolean intToBool(int value) {
diff a/test/jdk/java/foreign/TestArrays.java b/test/jdk/java/foreign/TestArrays.java
--- a/test/jdk/java/foreign/TestArrays.java
+++ b/test/jdk/java/foreign/TestArrays.java
@@ -37,10 +37,11 @@
 import java.lang.invoke.VarHandle;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Function;
+import java.util.function.ToIntFunction;
 
 import org.testng.annotations.*;
 
 import static jdk.incubator.foreign.MemorySegment.READ;
 import static org.testng.Assert.*;
@@ -81,31 +82,31 @@
     static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());
     static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());
     static VarHandle longHandle = longs.varHandle(long.class, PathElement.sequenceElement());
     static VarHandle doubleHandle = doubles.varHandle(double.class, PathElement.sequenceElement());
 
-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {
+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {
         for (long i = 0; i < seq.elementCount().getAsLong() ; i++) {
             handleSetter.accept(base, i);
         }
     }
 
-    static void checkBytes(MemoryAddress base, SequenceLayout layout, Function<MemorySegment, Object> arrayFactory, BiFunction<MemoryAddress, Long, Object> handleGetter) {
+    static void checkBytes(MemorySegment base, SequenceLayout layout, Function<MemorySegment, Object> arrayFactory, BiFunction<MemorySegment, Long, Object> handleGetter) {
         int nelems = (int)layout.elementCount().getAsLong();
-        Object arr = arrayFactory.apply(base.segment());
+        Object arr = arrayFactory.apply(base);
         for (int i = 0; i < nelems; i++) {
             Object found = handleGetter.apply(base, (long) i);
             Object expected = java.lang.reflect.Array.get(arr, i);
             assertEquals(expected, found);
         }
     }
 
     @Test(dataProvider = "arrays")
-    public void testArrays(Consumer<MemoryAddress> init, Consumer<MemoryAddress> checker, MemoryLayout layout) {
+    public void testArrays(Consumer<MemorySegment> init, Consumer<MemorySegment> checker, MemoryLayout layout) {
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            init.accept(segment.address());
-            checker.accept(segment.address());
+            init.accept(segment);
+            checker.accept(segment);
         }
     }
 
     @Test(dataProvider = "elemLayouts",
           expectedExceptions = UnsupportedOperationException.class)
@@ -150,38 +151,38 @@
         }
     }
 
     @DataProvider(name = "arrays")
     public Object[][] nativeAccessOps() {
-        Consumer<MemoryAddress> byteInitializer =
+        Consumer<MemorySegment> byteInitializer =
                 (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));
-        Consumer<MemoryAddress> charInitializer =
+        Consumer<MemorySegment> charInitializer =
                 (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));
-        Consumer<MemoryAddress> shortInitializer =
+        Consumer<MemorySegment> shortInitializer =
                 (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));
-        Consumer<MemoryAddress> intInitializer =
+        Consumer<MemorySegment> intInitializer =
                 (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));
-        Consumer<MemoryAddress> floatInitializer =
+        Consumer<MemorySegment> floatInitializer =
                 (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));
-        Consumer<MemoryAddress> longInitializer =
+        Consumer<MemorySegment> longInitializer =
                 (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));
-        Consumer<MemoryAddress> doubleInitializer =
+        Consumer<MemorySegment> doubleInitializer =
                 (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));
 
-        Consumer<MemoryAddress> byteChecker =
+        Consumer<MemorySegment> byteChecker =
                 (base) -> checkBytes(base, bytes, MemorySegment::toByteArray, (addr, pos) -> (byte)byteHandle.get(addr, pos));
-        Consumer<MemoryAddress> shortChecker =
+        Consumer<MemorySegment> shortChecker =
                 (base) -> checkBytes(base, shorts, MemorySegment::toShortArray, (addr, pos) -> (short)shortHandle.get(addr, pos));
-        Consumer<MemoryAddress> charChecker =
+        Consumer<MemorySegment> charChecker =
                 (base) -> checkBytes(base, chars, MemorySegment::toCharArray, (addr, pos) -> (char)charHandle.get(addr, pos));
-        Consumer<MemoryAddress> intChecker =
+        Consumer<MemorySegment> intChecker =
                 (base) -> checkBytes(base, ints, MemorySegment::toIntArray, (addr, pos) -> (int)intHandle.get(addr, pos));
-        Consumer<MemoryAddress> floatChecker =
+        Consumer<MemorySegment> floatChecker =
                 (base) -> checkBytes(base, floats, MemorySegment::toFloatArray, (addr, pos) -> (float)floatHandle.get(addr, pos));
-        Consumer<MemoryAddress> longChecker =
+        Consumer<MemorySegment> longChecker =
                 (base) -> checkBytes(base, longs, MemorySegment::toLongArray, (addr, pos) -> (long)longHandle.get(addr, pos));
-        Consumer<MemoryAddress> doubleChecker =
+        Consumer<MemorySegment> doubleChecker =
                 (base) -> checkBytes(base, doubles, MemorySegment::toDoubleArray, (addr, pos) -> (double)doubleHandle.get(addr, pos));
 
         return new Object[][]{
                 {byteInitializer, byteChecker, bytes},
                 {charInitializer, charChecker, chars},
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -2,13 +2,11 @@
  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
+ * published by the Free Software Foundation.
  *
  * This code is distributed in the hope that it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  * version 2 for more details (a copy is included in the LICENSE file that
@@ -133,46 +131,46 @@
     );
 
     static VarHandle indexHandle = tuples.varHandle(int.class, PathElement.sequenceElement(), PathElement.groupElement("index"));
     static VarHandle valueHandle = tuples.varHandle(float.class, PathElement.sequenceElement(), PathElement.groupElement("value"));
 
-    static void initTuples(MemoryAddress base, long count) {
+    static void initTuples(MemorySegment base, long count) {
         for (long i = 0; i < count ; i++) {
             indexHandle.set(base, i, (int)i);
             valueHandle.set(base, i, (float)(i / 500f));
         }
     }
 
-    static void checkTuples(MemoryAddress base, ByteBuffer bb, long count) {
+    static void checkTuples(MemorySegment base, ByteBuffer bb, long count) {
         for (long i = 0; i < count ; i++) {
             int index;
             float value;
             assertEquals(index = bb.getInt(), (int)indexHandle.get(base, i));
             assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, i));
             assertEquals(value, index / 500f);
         }
     }
 
-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {
+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {
         for (long i = 0; i < seq.elementCount().getAsLong() ; i++) {
             handleSetter.accept(base, i);
         }
     }
 
-    static <Z extends Buffer> void checkBytes(MemoryAddress base, SequenceLayout layout,
+    static <Z extends Buffer> void checkBytes(MemorySegment base, SequenceLayout layout,
                                               Function<ByteBuffer, Z> bufFactory,
-                                              BiFunction<MemoryAddress, Long, Object> handleExtractor,
+                                              BiFunction<MemorySegment, Long, Object> handleExtractor,
                                               Function<Z, Object> bufferExtractor) {
         long nelems = layout.elementCount().getAsLong();
         long elemSize = layout.elementLayout().byteSize();
         for (long i = 0 ; i < nelems ; i++) {
             long limit = nelems - i;
-            MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);
+            MemorySegment resizedSegment = base.asSlice(i * elemSize, limit * elemSize);
             ByteBuffer bb = resizedSegment.asByteBuffer();
             Z z = bufFactory.apply(bb);
             for (long j = i ; j < limit ; j++) {
-                Object handleValue = handleExtractor.apply(resizedSegment.address(), j - i);
+                Object handleValue = handleExtractor.apply(resizedSegment, j - i);
                 Object bufferValue = bufferExtractor.apply(z);
                 if (handleValue instanceof Number) {
                     assertEquals(((Number)handleValue).longValue(), j);
                     assertEquals(((Number)bufferValue).longValue(), j);
                 } else {
@@ -184,27 +182,25 @@
     }
 
     @Test
     public void testOffheap() {
         try (MemorySegment segment = MemorySegment.allocateNative(tuples)) {
-            MemoryAddress base = segment.address();
-            initTuples(base, tuples.elementCount().getAsLong());
+            initTuples(segment, tuples.elementCount().getAsLong());
 
             ByteBuffer bb = segment.asByteBuffer();
-            checkTuples(base, bb, tuples.elementCount().getAsLong());
+            checkTuples(segment, bb, tuples.elementCount().getAsLong());
         }
     }
 
     @Test
     public void testHeap() {
         byte[] arr = new byte[(int) tuples.byteSize()];
         MemorySegment region = MemorySegment.ofArray(arr);
-        MemoryAddress base = region.address();
-        initTuples(base, tuples.elementCount().getAsLong());
+        initTuples(region, tuples.elementCount().getAsLong());
 
         ByteBuffer bb = region.asByteBuffer();
-        checkTuples(base, bb, tuples.elementCount().getAsLong());
+        checkTuples(region, bb, tuples.elementCount().getAsLong());
     }
 
     @Test
     public void testChannel() throws Throwable {
         File f = new File("test.out");
@@ -213,22 +209,20 @@
 
         //write to channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -> {
                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
-                MemoryAddress base = segment.address();
-                initTuples(base, tuples.elementCount().getAsLong());
+                initTuples(segment, tuples.elementCount().getAsLong());
                 mbb.force();
             });
         }
 
         //read from channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -> {
                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
-                MemoryAddress base = segment.address();
-                checkTuples(base, mbb, tuples.elementCount().getAsLong());
+                checkTuples(segment, mbb, tuples.elementCount().getAsLong());
             });
         }
     }
 
     @Test
@@ -250,19 +244,17 @@
         f.createNewFile();
         f.deleteOnExit();
 
         //write to channel
         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
-            MemoryAddress base = segment.address();
-            initTuples(base, tuples.elementCount().getAsLong());
+            initTuples(segment, tuples.elementCount().getAsLong());
             segment.force();
         }
 
         //read from channel
         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
-            MemoryAddress base = segment.address();
-            checkTuples(base, segment.asByteBuffer(), tuples.elementCount().getAsLong());
+            checkTuples(segment, segment.asByteBuffer(), tuples.elementCount().getAsLong());
         }
     }
 
     @Test
     public void testMappedSegmentOffset() throws Throwable {
@@ -274,22 +266,20 @@
 
         // write one at a time
         for (int i = 0 ; i < tuples.byteSize() ; i += tupleLayout.byteSize()) {
             //write to channel
             try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
-                MemoryAddress base = segment.address();
-                initTuples(base, 1);
+                initTuples(segment, 1);
                 segment.force();
             }
         }
 
         // check one at a time
         for (int i = 0 ; i < tuples.byteSize() ; i += tupleLayout.byteSize()) {
             //read from channel
             try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
-                MemoryAddress base = segment.address();
-                checkTuples(base, segment.asByteBuffer(), 1);
+                checkTuples(segment, segment.asByteBuffer(), 1);
             }
         }
     }
 
     static void withMappedBuffer(FileChannel channel, FileChannel.MapMode mode, long pos, long size, Consumer<MappedByteBuffer> action) throws Throwable {
@@ -313,11 +303,10 @@
 
     @Test(dataProvider = "bufferOps")
     public void testScopedBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {
         Buffer bb;
         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
-            MemoryAddress base = segment.address();
             bb = bufferFactory.apply(segment.asByteBuffer());
         }
         //outside of scope!!
         for (Map.Entry<Method, Object[]> e : members.entrySet()) {
             if (!e.getKey().getName().contains("get") &&
@@ -379,65 +368,61 @@
     }
 
     @Test(dataProvider = "bufferOps")
     public void testDirectBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {
         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
-            MemoryAddress base = segment.address();
             Buffer bb = bufferFactory.apply(segment.asByteBuffer());
             assertTrue(bb.isDirect());
             DirectBuffer directBuffer = ((DirectBuffer)bb);
-            assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
+            assertEquals(directBuffer.address(), segment.address().toRawLongValue());
             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
             assertTrue(directBuffer.cleaner() == null);
         }
     }
 
     @Test(dataProvider="resizeOps")
-    public void testResizeOffheap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testResizeOffheap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress base = segment.address();
-            initializer.accept(base);
-            checker.accept(base);
+            initializer.accept(segment);
+            checker.accept(segment);
         }
     }
 
     @Test(dataProvider="resizeOps")
-    public void testResizeHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testResizeHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
-        MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).address();
+        MemorySegment base = MemorySegment.ofArray(new byte[capacity]);
         initializer.accept(base);
         checker.accept(base);
     }
 
     @Test(dataProvider="resizeOps")
-    public void testResizeBuffer(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testResizeBuffer(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
-        MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).address();
+        MemorySegment base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity]));
         initializer.accept(base);
         checker.accept(base);
     }
 
     @Test(dataProvider="resizeOps")
-    public void testResizeRoundtripHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testResizeRoundtripHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
         byte[] arr = new byte[capacity];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress first = segment.address();
-        initializer.accept(first);
-        MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).address();
+        initializer.accept(segment);
+        MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());
         checker.accept(second);
     }
 
     @Test(dataProvider="resizeOps")
-    public void testResizeRoundtripNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testResizeRoundtripNative(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress first = segment.address();
-            initializer.accept(first);
-            MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).address();
+            initializer.accept(segment);
+            MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());
             checker.accept(second);
         }
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
@@ -482,30 +467,30 @@
             assertEquals(segment.byteSize(), 0);
         }
     }
 
     @Test(dataProvider="resizeOps")
-    public void testCopyHeapToNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testCopyHeapToNative(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
-            initializer.accept(heapArray.address());
+            initializer.accept(heapArray);
             nativeArray.copyFrom(heapArray);
-            checker.accept(nativeArray.address());
+            checker.accept(nativeArray);
         }
     }
 
     @Test(dataProvider="resizeOps")
-    public void testCopyNativeToHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testCopyNativeToHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
-            initializer.accept(nativeArray.address());
+            initializer.accept(nativeArray);
             heapArray.copyFrom(nativeArray);
-            checker.accept(heapArray.address());
+            checker.accept(heapArray);
         }
     }
 
     @Test
     public void testDefaultAccessModesOfBuffer() {
@@ -553,11 +538,11 @@
         MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);
         MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());
 
         s1.close(); // memory freed
 
-        MemoryAccess.setInt(s2.address(), 10); // Dead access!
+        MemoryAccess.setInt(s2, 10); // Dead access!
     }
 
     @DataProvider(name = "bufferOps")
     public static Object[][] bufferOps() throws Throwable {
         return new Object[][]{
@@ -613,38 +598,38 @@
         return members;
     }
 
     @DataProvider(name = "resizeOps")
     public Object[][] resizeOps() {
-        Consumer<MemoryAddress> byteInitializer =
+        Consumer<MemorySegment> byteInitializer =
                 (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtIndex_BE(addr, pos, (byte)(long)pos));
-        Consumer<MemoryAddress> charInitializer =
+        Consumer<MemorySegment> charInitializer =
                 (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex_BE(addr, pos, (char)(long)pos));
-        Consumer<MemoryAddress> shortInitializer =
+        Consumer<MemorySegment> shortInitializer =
                 (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex_BE(addr, pos, (short)(long)pos));
-        Consumer<MemoryAddress> intInitializer =
+        Consumer<MemorySegment> intInitializer =
                 (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex_BE(addr, pos, (int)(long)pos));
-        Consumer<MemoryAddress> floatInitializer =
+        Consumer<MemorySegment> floatInitializer =
                 (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex_BE(addr, pos, (float)(long)pos));
-        Consumer<MemoryAddress> longInitializer =
-                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex_BE(addr, pos, pos));
-        Consumer<MemoryAddress> doubleInitializer =
+        Consumer<MemorySegment> longInitializer =
+                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex_BE(addr, pos, (long)pos));
+        Consumer<MemorySegment> doubleInitializer =
                 (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex_BE(addr, pos, (double)(long)pos));
 
-        Consumer<MemoryAddress> byteChecker =
+        Consumer<MemorySegment> byteChecker =
                 (base) -> checkBytes(base, bytes, Function.identity(), MemoryAccess::getByteAtIndex_BE, ByteBuffer::get);
-        Consumer<MemoryAddress> charChecker =
+        Consumer<MemorySegment> charChecker =
                 (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, MemoryAccess::getCharAtIndex_BE, CharBuffer::get);
-        Consumer<MemoryAddress> shortChecker =
+        Consumer<MemorySegment> shortChecker =
                 (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, MemoryAccess::getShortAtIndex_BE, ShortBuffer::get);
-        Consumer<MemoryAddress> intChecker =
+        Consumer<MemorySegment> intChecker =
                 (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, MemoryAccess::getIntAtIndex_BE, IntBuffer::get);
-        Consumer<MemoryAddress> floatChecker =
+        Consumer<MemorySegment> floatChecker =
                 (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, MemoryAccess::getFloatAtIndex_BE, FloatBuffer::get);
-        Consumer<MemoryAddress> longChecker =
+        Consumer<MemorySegment> longChecker =
                 (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, MemoryAccess::getLongAtIndex_BE, LongBuffer::get);
-        Consumer<MemoryAddress> doubleChecker =
+        Consumer<MemorySegment> doubleChecker =
                 (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, MemoryAccess::getDoubleAtIndex_BE, DoubleBuffer::get);
 
         return new Object[][]{
                 {byteChecker, byteInitializer, bytes},
                 {charChecker, charInitializer, chars},
diff a/test/jdk/java/foreign/TestLayouts.java b/test/jdk/java/foreign/TestLayouts.java
--- a/test/jdk/java/foreign/TestLayouts.java
+++ b/test/jdk/java/foreign/TestLayouts.java
@@ -62,18 +62,18 @@
         VarHandle array_elem_handle = layout.varHandle(double.class,
                 MemoryLayout.PathElement.groupElement("arr"),
                 MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(
                 layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement("arr")))) {
-            size_handle.set(segment.address(), 4);
+            size_handle.set(segment, 4);
             for (int i = 0 ; i < 4 ; i++) {
-                array_elem_handle.set(segment.address(), i, (double)i);
+                array_elem_handle.set(segment, i, (double)i);
             }
             //check
-            assertEquals(4, (int)size_handle.get(segment.address()));
+            assertEquals(4, (int)size_handle.get(segment));
             for (int i = 0 ; i < 4 ; i++) {
-                assertEquals((double)i, (double)array_elem_handle.get(segment.address(), i));
+                assertEquals((double)i, (double)array_elem_handle.get(segment, i));
             }
         }
     }
 
     @Test
@@ -88,18 +88,18 @@
                 MemoryLayout.PathElement.groupElement("arr"),
                 MemoryLayout.PathElement.sequenceElement(0),
                 MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(
                 layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement("arr"), MemoryLayout.PathElement.sequenceElement()))) {
-            size_handle.set(segment.address(), 4);
+            size_handle.set(segment, 4);
             for (int i = 0 ; i < 4 ; i++) {
-                array_elem_handle.set(segment.address(), i, (double)i);
+                array_elem_handle.set(segment, i, (double)i);
             }
             //check
-            assertEquals(4, (int)size_handle.get(segment.address()));
+            assertEquals(4, (int)size_handle.get(segment));
             for (int i = 0 ; i < 4 ; i++) {
-                assertEquals((double)i, (double)array_elem_handle.get(segment.address(), i));
+                assertEquals((double)i, (double)array_elem_handle.get(segment, i));
             }
         }
     }
 
     @Test
@@ -107,17 +107,17 @@
         MemoryLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
             VarHandle indexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
             // init segment
             for (int i = 0 ; i < 10 ; i++) {
-                indexHandle.set(segment.address(), (long)i, i);
+                indexHandle.set(segment, (long)i, i);
             }
             //check statically indexed handles
             for (int i = 0 ; i < 10 ; i++) {
                 VarHandle preindexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(i));
-                int expected = (int)indexHandle.get(segment.address(), (long)i);
-                int found = (int)preindexHandle.get(segment.address());
+                int expected = (int)indexHandle.get(segment, (long)i);
+                int found = (int)preindexHandle.get(segment);
                 assertEquals(expected, found);
             }
         }
     }
 
diff a/test/jdk/java/foreign/TestMemoryAccess.java b/test/jdk/java/foreign/TestMemoryAccess.java
--- a/test/jdk/java/foreign/TestMemoryAccess.java
+++ b/test/jdk/java/foreign/TestMemoryAccess.java
@@ -34,11 +34,11 @@
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
-import jdk.incubator.foreign.MemoryAddress;
+
 import java.lang.invoke.VarHandle;
 import java.util.function.Function;
 
 import org.testng.annotations.*;
 import static org.testng.Assert.*;
@@ -80,49 +80,47 @@
         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout));
         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);
     }
 
     private void testAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
-        MemoryAddress outer_address;
+        MemorySegment outer_segment;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.address();
             try {
-                checker.check(handle, addr);
+                checker.check(handle, segment);
                 if (isRO) {
                     throw new AssertionError(); //not ok, memory should be immutable
                 }
             } catch (UnsupportedOperationException ex) {
                 if (!isRO) {
                     throw new AssertionError(); //we should not have failed!
                 }
                 return;
             }
             try {
-                checker.check(handle, addr.addOffset(layout.byteSize()));
+                checker.check(handle, segment.asSlice(layout.byteSize()));
                 throw new AssertionError(); //not ok, out of bounds
             } catch (IndexOutOfBoundsException ex) {
                 //ok, should fail (out of bounds)
             }
-            outer_address = addr; //leak!
+            outer_segment = segment; //leak!
         }
         try {
-            checker.check(handle, outer_address);
+            checker.check(handle, outer_segment);
             throw new AssertionError(); //not ok, scope is closed
         } catch (IllegalStateException ex) {
             //ok, should fail (scope is closed)
         }
     }
 
     private void testArrayAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
-        MemoryAddress outer_address;
+        MemorySegment outer_segment;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.address();
             try {
                 for (int i = 0; i < seq.elementCount().getAsLong(); i++) {
-                    checker.check(handle, addr, i);
+                    checker.check(handle, segment, i);
                 }
                 if (isRO) {
                     throw new AssertionError(); //not ok, memory should be immutable
                 }
             } catch (UnsupportedOperationException ex) {
@@ -130,19 +128,19 @@
                     throw new AssertionError(); //we should not have failed!
                 }
                 return;
             }
             try {
-                checker.check(handle, addr, seq.elementCount().getAsLong());
+                checker.check(handle, segment, seq.elementCount().getAsLong());
                 throw new AssertionError(); //not ok, out of bounds
             } catch (IndexOutOfBoundsException ex) {
                 //ok, should fail (out of bounds)
             }
-            outer_address = addr; //leak!
+            outer_segment = segment; //leak!
         }
         try {
-            checker.check(handle, outer_address, 0);
+            checker.check(handle, outer_segment, 0);
             throw new AssertionError(); //not ok, scope is closed
         } catch (IllegalStateException ex) {
             //ok, should fail (scope is closed)
         }
     }
@@ -181,18 +179,17 @@
         ValueLayout l = MemoryLayouts.BITS_32_LE.withName("elem");
         l.varHandle(carrier);
     }
 
     private void testMatrixAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
-        MemoryAddress outer_address;
+        MemorySegment outer_segment;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.address();
             try {
                 for (int i = 0; i < seq.elementCount().getAsLong(); i++) {
                     for (int j = 0; j < ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
-                        checker.check(handle, addr, i, j);
+                        checker.check(handle, segment, i, j);
                     }
                 }
                 if (isRO) {
                     throw new AssertionError(); //not ok, memory should be immutable
                 }
@@ -201,20 +198,20 @@
                     throw new AssertionError(); //we should not have failed!
                 }
                 return;
             }
             try {
-                checker.check(handle, addr, seq.elementCount().getAsLong(),
+                checker.check(handle, segment, seq.elementCount().getAsLong(),
                         ((SequenceLayout)seq.elementLayout()).elementCount().getAsLong());
                 throw new AssertionError(); //not ok, out of bounds
             } catch (IndexOutOfBoundsException ex) {
                 //ok, should fail (out of bounds)
             }
-            outer_address = addr; //leak!
+            outer_segment = segment; //leak!
         }
         try {
-            checker.check(handle, outer_address, 0, 0);
+            checker.check(handle, outer_segment, 0, 0);
             throw new AssertionError(); //not ok, scope is closed
         } catch (IllegalStateException ex) {
             //ok, should fail (scope is closed)
         }
     }
@@ -259,45 +256,45 @@
                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },
         };
     }
 
     interface Checker {
-        void check(VarHandle handle, MemoryAddress addr);
+        void check(VarHandle handle, MemorySegment segment);
 
-        Checker BYTE = (handle, addr) -> {
-            handle.set(addr, (byte)42);
-            assertEquals(42, (byte)handle.get(addr));
+        Checker BYTE = (handle, segment) -> {
+            handle.set(segment, (byte)42);
+            assertEquals(42, (byte)handle.get(segment));
         };
 
-        Checker SHORT = (handle, addr) -> {
-            handle.set(addr, (short)42);
-            assertEquals(42, (short)handle.get(addr));
+        Checker SHORT = (handle, segment) -> {
+            handle.set(segment, (short)42);
+            assertEquals(42, (short)handle.get(segment));
         };
 
-        Checker CHAR = (handle, addr) -> {
-            handle.set(addr, (char)42);
-            assertEquals(42, (char)handle.get(addr));
+        Checker CHAR = (handle, segment) -> {
+            handle.set(segment, (char)42);
+            assertEquals(42, (char)handle.get(segment));
         };
 
-        Checker INT = (handle, addr) -> {
-            handle.set(addr, 42);
-            assertEquals(42, (int)handle.get(addr));
+        Checker INT = (handle, segment) -> {
+            handle.set(segment, 42);
+            assertEquals(42, (int)handle.get(segment));
         };
 
-        Checker LONG = (handle, addr) -> {
-            handle.set(addr, (long)42);
-            assertEquals(42, (long)handle.get(addr));
+        Checker LONG = (handle, segment) -> {
+            handle.set(segment, (long)42);
+            assertEquals(42, (long)handle.get(segment));
         };
 
-        Checker FLOAT = (handle, addr) -> {
-            handle.set(addr, (float)42);
-            assertEquals((float)42, (float)handle.get(addr));
+        Checker FLOAT = (handle, segment) -> {
+            handle.set(segment, (float)42);
+            assertEquals((float)42, (float)handle.get(segment));
         };
 
-        Checker DOUBLE = (handle, addr) -> {
-            handle.set(addr, (double)42);
-            assertEquals((double)42, (double)handle.get(addr));
+        Checker DOUBLE = (handle, segment) -> {
+            handle.set(segment, (double)42);
+            assertEquals((double)42, (double)handle.get(segment));
         };
     }
 
     @DataProvider(name = "arrayElements")
     public Object[][] createArrayData() {
@@ -336,45 +333,45 @@
                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },
         };
     }
 
     interface ArrayChecker {
-        void check(VarHandle handle, MemoryAddress addr, long index);
+        void check(VarHandle handle, MemorySegment segment, long index);
 
-        ArrayChecker BYTE = (handle, addr, i) -> {
-            handle.set(addr, i, (byte)i);
-            assertEquals(i, (byte)handle.get(addr, i));
+        ArrayChecker BYTE = (handle, segment, i) -> {
+            handle.set(segment, i, (byte)i);
+            assertEquals(i, (byte)handle.get(segment, i));
         };
 
-        ArrayChecker SHORT = (handle, addr, i) -> {
-            handle.set(addr, i, (short)i);
-            assertEquals(i, (short)handle.get(addr, i));
+        ArrayChecker SHORT = (handle, segment, i) -> {
+            handle.set(segment, i, (short)i);
+            assertEquals(i, (short)handle.get(segment, i));
         };
 
-        ArrayChecker CHAR = (handle, addr, i) -> {
-            handle.set(addr, i, (char)i);
-            assertEquals(i, (char)handle.get(addr, i));
+        ArrayChecker CHAR = (handle, segment, i) -> {
+            handle.set(segment, i, (char)i);
+            assertEquals(i, (char)handle.get(segment, i));
         };
 
-        ArrayChecker INT = (handle, addr, i) -> {
-            handle.set(addr, i, (int)i);
-            assertEquals(i, (int)handle.get(addr, i));
+        ArrayChecker INT = (handle, segment, i) -> {
+            handle.set(segment, i, (int)i);
+            assertEquals(i, (int)handle.get(segment, i));
         };
 
-        ArrayChecker LONG = (handle, addr, i) -> {
-            handle.set(addr, i, (long)i);
-            assertEquals(i, (long)handle.get(addr, i));
+        ArrayChecker LONG = (handle, segment, i) -> {
+            handle.set(segment, i, (long)i);
+            assertEquals(i, (long)handle.get(segment, i));
         };
 
-        ArrayChecker FLOAT = (handle, addr, i) -> {
-            handle.set(addr, i, (float)i);
-            assertEquals((float)i, (float)handle.get(addr, i));
+        ArrayChecker FLOAT = (handle, segment, i) -> {
+            handle.set(segment, i, (float)i);
+            assertEquals((float)i, (float)handle.get(segment, i));
         };
 
-        ArrayChecker DOUBLE = (handle, addr, i) -> {
-            handle.set(addr, i, (double)i);
-            assertEquals((double)i, (double)handle.get(addr, i));
+        ArrayChecker DOUBLE = (handle, segment, i) -> {
+            handle.set(segment, i, (double)i);
+            assertEquals((double)i, (double)handle.get(segment, i));
         };
     }
 
     @DataProvider(name = "matrixElements")
     public Object[][] createMatrixData() {
@@ -413,45 +410,45 @@
                 { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },
         };
     }
 
     interface MatrixChecker {
-        void check(VarHandle handle, MemoryAddress addr, long row, long col);
+        void check(VarHandle handle, MemorySegment segment, long row, long col);
 
-        MatrixChecker BYTE = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (byte)(r + c));
-            assertEquals(r + c, (byte)handle.get(addr, r, c));
+        MatrixChecker BYTE = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (byte)(r + c));
+            assertEquals(r + c, (byte)handle.get(segment, r, c));
         };
 
-        MatrixChecker SHORT = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (short)(r + c));
-            assertEquals(r + c, (short)handle.get(addr, r, c));
+        MatrixChecker SHORT = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (short)(r + c));
+            assertEquals(r + c, (short)handle.get(segment, r, c));
         };
 
-        MatrixChecker CHAR = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (char)(r + c));
-            assertEquals(r + c, (char)handle.get(addr, r, c));
+        MatrixChecker CHAR = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (char)(r + c));
+            assertEquals(r + c, (char)handle.get(segment, r, c));
         };
 
-        MatrixChecker INT = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (int)(r + c));
-            assertEquals(r + c, (int)handle.get(addr, r, c));
+        MatrixChecker INT = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (int)(r + c));
+            assertEquals(r + c, (int)handle.get(segment, r, c));
         };
 
-        MatrixChecker LONG = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, r + c);
-            assertEquals(r + c, (long)handle.get(addr, r, c));
+        MatrixChecker LONG = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, r + c);
+            assertEquals(r + c, (long)handle.get(segment, r, c));
         };
 
-        MatrixChecker FLOAT = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (float)(r + c));
-            assertEquals((float)(r + c), (float)handle.get(addr, r, c));
+        MatrixChecker FLOAT = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (float)(r + c));
+            assertEquals((float)(r + c), (float)handle.get(segment, r, c));
         };
 
-        MatrixChecker DOUBLE = (handle, addr, r, c) -> {
-            handle.set(addr, r, c, (double)(r + c));
-            assertEquals((double)(r + c), (double)handle.get(addr, r, c));
+        MatrixChecker DOUBLE = (handle, segment, r, c) -> {
+            handle.set(segment, r, c, (double)(r + c));
+            assertEquals((double)(r + c), (double)handle.get(segment, r, c));
         };
     }
 
     @DataProvider(name = "badCarriers")
     public Object[][] createBadCarriers() {
diff a/test/jdk/java/foreign/TestMemoryAlignment.java b/test/jdk/java/foreign/TestMemoryAlignment.java
--- a/test/jdk/java/foreign/TestMemoryAlignment.java
+++ b/test/jdk/java/foreign/TestMemoryAlignment.java
@@ -29,11 +29,10 @@
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
 import jdk.incubator.foreign.ValueLayout;
 import java.lang.invoke.VarHandle;
 import java.util.stream.LongStream;
@@ -49,13 +48,12 @@
         assertEquals(layout.bitAlignment(), 32);
         ValueLayout aligned = layout.withBitAlignment(align);
         assertEquals(aligned.bitAlignment(), align); //unreasonable alignment here, to make sure access throws
         VarHandle vh = aligned.varHandle(int.class);
         try (MemorySegment segment = MemorySegment.allocateNative(aligned)) {
-            MemoryAddress addr = segment.address();
-            vh.set(addr, -42);
-            int val = (int)vh.get(addr);
+            vh.set(segment, -42);
+            int val = (int)vh.get(segment);
             assertEquals(val, -42);
         }
     }
 
     @Test(dataProvider = "alignments")
@@ -65,12 +63,11 @@
         ValueLayout aligned = layout.withBitAlignment(align);
         MemoryLayout alignedGroup = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, aligned);
         assertEquals(alignedGroup.bitAlignment(), align);
         VarHandle vh = aligned.varHandle(int.class);
         try (MemorySegment segment = MemorySegment.allocateNative(alignedGroup)) {
-            MemoryAddress addr = segment.address();
-            vh.set(addr.addOffset(1L), -42);
+            vh.set(segment.asSlice(1L), -42);
             assertEquals(align, 8); //this is the only case where access is aligned
         } catch (IllegalStateException ex) {
             assertNotEquals(align, 8); //if align != 8, access is always unaligned
         }
     }
@@ -92,13 +89,12 @@
     public void testUnalignedSequence(long align) {
         SequenceLayout layout = MemoryLayout.ofSequence(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));
         try {
             VarHandle vh = layout.varHandle(int.class, PathElement.sequenceElement());
             try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-                MemoryAddress addr = segment.address();
                 for (long i = 0 ; i < 5 ; i++) {
-                    vh.set(addr, i, -42);
+                    vh.set(segment, i, -42);
                 }
             }
         } catch (UnsupportedOperationException ex) {
             assertTrue(align > 32); //if align > 32, access is always unaligned (for some elements)
         }
@@ -116,17 +112,16 @@
         assertEquals(g.bitAlignment(), 8);
         VarHandle vh_c = g.varHandle(byte.class, PathElement.groupElement("a"));
         VarHandle vh_s = g.varHandle(short.class, PathElement.groupElement("b"));
         VarHandle vh_i = g.varHandle(int.class, PathElement.groupElement("c"));
         try (MemorySegment segment = MemorySegment.allocateNative(g)) {
-            MemoryAddress addr = segment.address();
-            vh_c.set(addr, Byte.MIN_VALUE);
-            assertEquals(vh_c.get(addr), Byte.MIN_VALUE);
-            vh_s.set(addr, Short.MIN_VALUE);
-            assertEquals(vh_s.get(addr), Short.MIN_VALUE);
-            vh_i.set(addr, Integer.MIN_VALUE);
-            assertEquals(vh_i.get(addr), Integer.MIN_VALUE);
+            vh_c.set(segment, Byte.MIN_VALUE);
+            assertEquals(vh_c.get(segment), Byte.MIN_VALUE);
+            vh_s.set(segment, Short.MIN_VALUE);
+            assertEquals(vh_s.get(segment), Short.MIN_VALUE);
+            vh_i.set(segment, Integer.MIN_VALUE);
+            assertEquals(vh_i.get(segment), Integer.MIN_VALUE);
         }
     }
 
     @DataProvider(name = "alignments")
     public Object[][] createAlignments() {
diff a/test/jdk/java/foreign/TestMemoryCopy.java b/test/jdk/java/foreign/TestMemoryCopy.java
--- a/test/jdk/java/foreign/TestMemoryCopy.java
+++ b/test/jdk/java/foreign/TestMemoryCopy.java
@@ -25,11 +25,10 @@
 /*
  * @test
  * @run testng TestMemoryCopy
  */
 
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
@@ -44,25 +43,23 @@
 
     final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
 
     @Test(dataProvider = "slices")
     public void testCopy(SegmentSlice s1, SegmentSlice s2) {
-        MemoryAddress addr1 = s1.segment.address();
-        MemoryAddress addr2 = s2.segment.address();
         int size = Math.min(s1.size(), s2.size());
         //prepare source and target segments
         for (int i = 0 ; i < size ; i++) {
-            BYTE_HANDLE.set(addr2.addOffset(i), (byte)0);
+            BYTE_HANDLE.set(s2.segment.asSlice(i), (byte)0);
         }
         for (int i = 0 ; i < size ; i++) {
-            BYTE_HANDLE.set(addr1.addOffset(i), (byte) i);
+            BYTE_HANDLE.set(s1.segment.asSlice(i), (byte) i);
         }
         //perform copy
         s2.segment.copyFrom(s1.segment.asSlice(0, size));
         //check that copy actually worked
         for (int i = 0 ; i < size ; i++) {
-            assertEquals((byte)i, BYTE_HANDLE.get(addr2.addOffset(i)));
+            assertEquals((byte)i, BYTE_HANDLE.get(s2.segment.asSlice(i)));
         }
     }
 
     static class SegmentSlice {
 
diff a/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java b/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
--- a/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
+++ b/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
@@ -57,14 +57,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_8_BE;
         VarHandle byteHandle = layout.varHandle(byte.class);
         VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.address(), intValue);
+            intHandle.set(segment, intValue);
             int expectedIntValue = Byte.toUnsignedInt(byteValue);
-            assertEquals((int) intHandle.get(segment.address()), expectedIntValue);
-            assertEquals((byte) byteHandle.get(segment.address()), byteValue);
+            assertEquals((int) intHandle.get(segment), expectedIntValue);
+            assertEquals((byte) byteHandle.get(segment), byteValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToByteData")
     public Object[][] unsignedLongToByteData() {
@@ -79,14 +79,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_8_BE;
         VarHandle byteHandle = layout.varHandle(byte.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(byteHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.address(), longValue);
+            longHandle.set(segment, longValue);
             long expectedLongValue = Byte.toUnsignedLong(byteValue);
-            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
-            assertEquals((byte) byteHandle.get(segment.address()), byteValue);
+            assertEquals((long) longHandle.get(segment), expectedLongValue);
+            assertEquals((byte) byteHandle.get(segment), byteValue);
         }
     }
 
     @DataProvider(name = "unsignedIntToShortData")
     public Object[][] unsignedIntToShortData() {
@@ -101,14 +101,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_16_BE;
         VarHandle shortHandle = layout.varHandle(short.class);
         VarHandle intHandle = MemoryHandles.asUnsigned(shortHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.address(), intValue);
+            intHandle.set(segment, intValue);
             int expectedIntValue = Short.toUnsignedInt(shortValue);
-            assertEquals((int) intHandle.get(segment.address()), expectedIntValue);
-            assertEquals((short) shortHandle.get(segment.address()), shortValue);
+            assertEquals((int) intHandle.get(segment), expectedIntValue);
+            assertEquals((short) shortHandle.get(segment), shortValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToShortData")
     public Object[][] unsignedLongToShortData() {
@@ -123,14 +123,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_16_BE;
         VarHandle shortHandle = layout.varHandle(short.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(shortHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.address(), longValue);
+            longHandle.set(segment, longValue);
             long expectedLongValue = Short.toUnsignedLong(shortValue);
-            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
-            assertEquals((short) shortHandle.get(segment.address()), shortValue);
+            assertEquals((long) longHandle.get(segment), expectedLongValue);
+            assertEquals((short) shortHandle.get(segment), shortValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToIntData")
     public Object[][] unsignedLongToIntData() {
@@ -149,48 +149,47 @@
         MemoryLayout layout = MemoryLayouts.BITS_32_BE;
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(intHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.address(), longValue);
+            longHandle.set(segment, longValue);
             long expectedLongValue = Integer.toUnsignedLong(intValue);
-            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
-            assertEquals((int) intHandle.get(segment.address()), intValue);
+            assertEquals((long) longHandle.get(segment), expectedLongValue);
+            assertEquals((int) intHandle.get(segment), intValue);
         }
     }
 
     @Test
     public void testCoordinatesSequenceLayout() {
         MemoryLayout layout = MemoryLayout.ofSequence(2, MemoryLayouts.BITS_8_BE);
         VarHandle byteHandle = layout.varHandle(byte.class, PathElement.sequenceElement());
         VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.address(), 0L, (int) -1);
-            assertEquals((int) intHandle.get(segment.address(), 0L), 255);
-            intHandle.set(segment.address(), 1L, (int) 200);
-            assertEquals((int) intHandle.get(segment.address(), 1L), 200);
+            intHandle.set(segment, 0L, (int) -1);
+            assertEquals((int) intHandle.get(segment, 0L), 255);
+            intHandle.set(segment, 1L, (int) 200);
+            assertEquals((int) intHandle.get(segment, 1L), 200);
         }
     }
 
     @Test
     public void testCoordinatesStride() {
         byte[] arr = { 0, 0, (byte) 129, 0 };
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress addr = segment.address();
 
         {
-            VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
+            VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+                    .varHandle(byte.class, PathElement.sequenceElement());
             VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
-            VarHandle strideHandle = MemoryHandles.withStride(intHandle, 1);
-            assertEquals((int) strideHandle.get(addr, 2L), 129);
+            assertEquals((int) intHandle.get(segment, 2L), 129);
         }
         {
-            VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-            VarHandle strideHandle = MemoryHandles.withStride(byteHandle, 1);
-            VarHandle intHandle = MemoryHandles.asUnsigned(strideHandle, int.class);
-            assertEquals((int) intHandle.get(addr, 2L), 129);
+            VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+                    .varHandle(byte.class, PathElement.sequenceElement());
+            VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
+            assertEquals((int) intHandle.get(segment, 2L), 129);
         }
     }
 
     static final Class<NullPointerException> NPE = NullPointerException.class;
 
diff a/test/jdk/java/foreign/TestMismatch.java b/test/jdk/java/foreign/TestMismatch.java
--- a/test/jdk/java/foreign/TestMismatch.java
+++ b/test/jdk/java/foreign/TestMismatch.java
@@ -45,13 +45,12 @@
 
     final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
 
     // stores a increasing sequence of values into the memory of the given segment
     static MemorySegment initializeSegment(MemorySegment segment) {
-        MemoryAddress addr = segment.address();
         for (int i = 0 ; i < segment.byteSize() ; i++) {
-            BYTE_HANDLE.set(addr.addOffset(i), (byte)i);
+            BYTE_HANDLE.set(segment.asSlice(i), (byte)i);
         }
         return segment;
     }
 
     @Test(dataProvider = "slices")
@@ -79,11 +78,11 @@
         s1 = initializeSegment(s1);
         s2 = initializeSegment(s2);
 
         for (long i = s2.byteSize() -1 ; i >= 0; i--) {
             long expectedMismatchOffset = i;
-            BYTE_HANDLE.set(s2.address().addOffset(i), (byte) 0xFF);
+            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);
 
             if (s1.byteSize() == s2.byteSize()) {
                 assertEquals(s1.mismatch(s2), expectedMismatchOffset);
                 assertEquals(s2.mismatch(s1), expectedMismatchOffset);
             } else if (s1.byteSize() > s2.byteSize()) {
@@ -133,11 +132,11 @@
         }
     }
 
     private void testLargeMismatchAcrossMaxBoundary(MemorySegment s1, MemorySegment s2) {
         for (long i = s2.byteSize() -1 ; i >= Integer.MAX_VALUE - 10L; i--) {
-            BYTE_HANDLE.set(s2.address().addOffset(i), (byte) 0xFF);
+            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);
             long expectedMismatchOffset = i;
             assertEquals(s1.mismatch(s2), expectedMismatchOffset);
             assertEquals(s2.mismatch(s1), expectedMismatchOffset);
         }
     }
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -22,23 +22,21 @@
  *
  */
 
 /*
  * @test
- * @modules java.base/jdk.internal.misc
- *          jdk.incubator.foreign/jdk.internal.foreign
+ * @modules jdk.incubator.foreign/jdk.internal.foreign
  * @run testng/othervm -Dforeign.restricted=permit TestNative
  */
 
 import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
-import jdk.internal.misc.Unsafe;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
 import java.nio.Buffer;
@@ -57,16 +55,10 @@
 import static jdk.incubator.foreign.MemorySegment.*;
 import static org.testng.Assert.*;
 
 public class TestNative {
 
-    static Unsafe UNSAFE;
-
-    static {
-        UNSAFE = Unsafe.getUnsafe();
-    }
-
     static SequenceLayout bytes = MemoryLayout.ofSequence(100,
             MemoryLayouts.JAVA_BYTE.withOrder(ByteOrder.nativeOrder())
     );
 
     static SequenceLayout chars = MemoryLayout.ofSequence(100,
@@ -99,28 +91,28 @@
     static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());
     static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());
     static VarHandle longHandle = doubles.varHandle(long.class, PathElement.sequenceElement());
     static VarHandle doubleHandle = longs.varHandle(double.class, PathElement.sequenceElement());
 
-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {
+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {
         for (long i = 0; i < seq.elementCount().getAsLong() ; i++) {
             handleSetter.accept(base, i);
         }
     }
 
-    static <Z extends Buffer> void checkBytes(MemoryAddress base, SequenceLayout layout,
-                                              BiFunction<MemoryAddress, Long, Object> handleExtractor,
+    static <Z extends Buffer> void checkBytes(MemorySegment base, SequenceLayout layout,
+                                              BiFunction<MemorySegment, Long, Object> handleExtractor,
                                               Function<ByteBuffer, Z> bufferFactory,
                                               BiFunction<Z, Integer, Object> nativeBufferExtractor,
                                               BiFunction<Long, Integer, Object> nativeRawExtractor) {
         long nelems = layout.elementCount().getAsLong();
-        ByteBuffer bb = base.segment().asSlice(base.segmentOffset(), (int)layout.byteSize()).asByteBuffer();
+        ByteBuffer bb = base.asByteBuffer();
         Z z = bufferFactory.apply(bb);
         for (long i = 0 ; i < nelems ; i++) {
             Object handleValue = handleExtractor.apply(base, i);
             Object bufferValue = nativeBufferExtractor.apply(z, (int)i);
-            Object rawValue = nativeRawExtractor.apply(base.toRawLongValue(), (int)i);
+            Object rawValue = nativeRawExtractor.apply(base.address().toRawLongValue(), (int)i);
             if (handleValue instanceof Number) {
                 assertEquals(((Number)handleValue).longValue(), i);
                 assertEquals(((Number)bufferValue).longValue(), i);
                 assertEquals(((Number)rawValue).longValue(), i);
             } else {
@@ -151,15 +143,14 @@
 
     public static native long allocate(int size);
     public static native void free(long address);
 
     @Test(dataProvider="nativeAccessOps")
-    public void testNativeAccess(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
+    public void testNativeAccess(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress address = segment.address();
-            initializer.accept(address);
-            checker.accept(address);
+            initializer.accept(segment);
+            checker.accept(segment);
         }
     }
 
     @Test(dataProvider="buffers")
     public void testNativeCapacity(Function<ByteBuffer, Buffer> bufferFunction, int elemSize) {
@@ -192,26 +183,23 @@
     }
 
     @Test
     public void testMallocSegment() {
         MemoryAddress addr = MemoryAddress.ofLong(allocate(12));
-        assertNull(addr.segment());
         MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,
                 () -> free(addr.toRawLongValue()), null);
         assertEquals(mallocSegment.byteSize(), 12);
         mallocSegment.close(); //free here
         assertTrue(!mallocSegment.isAlive());
     }
 
     @Test
     public void testEverythingSegment() {
         MemoryAddress addr = MemoryAddress.ofLong(allocate(4));
-        assertNull(addr.segment());
         MemorySegment everything = MemorySegment.ofNativeRestricted();
-        MemoryAddress ptr = addr.rebase(everything);
-        MemoryAccess.setInt(ptr, 42);
-        assertEquals(MemoryAccess.getInt(ptr), 42);
+        MemoryAccess.setIntAtOffset(everything, addr.toRawLongValue(), 42);
+        assertEquals(MemoryAccess.getIntAtOffset(everything, addr.toRawLongValue()), 42);
         free(addr.toRawLongValue());
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadResize() {
@@ -229,38 +217,38 @@
         System.loadLibrary("NativeAccess");
     }
 
     @DataProvider(name = "nativeAccessOps")
     public Object[][] nativeAccessOps() {
-        Consumer<MemoryAddress> byteInitializer =
+        Consumer<MemorySegment> byteInitializer =
                 (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));
-        Consumer<MemoryAddress> charInitializer =
+        Consumer<MemorySegment> charInitializer =
                 (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));
-        Consumer<MemoryAddress> shortInitializer =
+        Consumer<MemorySegment> shortInitializer =
                 (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));
-        Consumer<MemoryAddress> intInitializer =
+        Consumer<MemorySegment> intInitializer =
                 (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));
-        Consumer<MemoryAddress> floatInitializer =
+        Consumer<MemorySegment> floatInitializer =
                 (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));
-        Consumer<MemoryAddress> longInitializer =
+        Consumer<MemorySegment> longInitializer =
                 (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));
-        Consumer<MemoryAddress> doubleInitializer =
+        Consumer<MemorySegment> doubleInitializer =
                 (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));
 
-        Consumer<MemoryAddress> byteChecker =
+        Consumer<MemorySegment> byteChecker =
                 (base) -> checkBytes(base, bytes, byteHandle::get, bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);
-        Consumer<MemoryAddress> charChecker =
+        Consumer<MemorySegment> charChecker =
                 (base) -> checkBytes(base, chars, charHandle::get, ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);
-        Consumer<MemoryAddress> shortChecker =
+        Consumer<MemorySegment> shortChecker =
                 (base) -> checkBytes(base, shorts, shortHandle::get, ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);
-        Consumer<MemoryAddress> intChecker =
+        Consumer<MemorySegment> intChecker =
                 (base) -> checkBytes(base, ints, intHandle::get, ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);
-        Consumer<MemoryAddress> floatChecker =
+        Consumer<MemorySegment> floatChecker =
                 (base) -> checkBytes(base, floats, floatHandle::get, ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);
-        Consumer<MemoryAddress> longChecker =
+        Consumer<MemorySegment> longChecker =
                 (base) -> checkBytes(base, longs, longHandle::get, ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);
-        Consumer<MemoryAddress> doubleChecker =
+        Consumer<MemorySegment> doubleChecker =
                 (base) -> checkBytes(base, doubles, doubleHandle::get, ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);
 
         return new Object[][]{
                 {byteChecker, byteInitializer, bytes},
                 {charChecker, charInitializer, chars},
diff a/test/jdk/java/foreign/TestRebase.java b/test/jdk/java/foreign/TestRebase.java
--- a/test/jdk/java/foreign/TestRebase.java
+++ b/test/jdk/java/foreign/TestRebase.java
@@ -25,10 +25,11 @@
 /*
  * @test
  * @run testng TestRebase
  */
 
+import jdk.incubator.foreign.MemoryAccess;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
@@ -42,39 +43,37 @@
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
 public class TestRebase {
 
-    static VarHandle BYTE_VH = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
-
     @Test(dataProvider = "slices")
     public void testRebase(SegmentSlice s1, SegmentSlice s2) {
         if (s1.contains(s2)) {
             //check that an address and its rebased counterpart point to same element
             MemoryAddress base = s2.segment.address();
-            MemoryAddress rebased = base.rebase(s1.segment);
+            long offset = base.segmentOffset(s1.segment);
             for (int i = 0; i < s2.size(); i++) {
-                int expected = (int) BYTE_VH.get(base.addOffset(i));
-                int found = (int) BYTE_VH.get(rebased.addOffset(i));
+                int expected = MemoryAccess.getByteAtOffset(s2.segment, i);
+                int found = (int)MemoryAccess.getByteAtOffset(s1.segment, i + offset);
                 assertEquals(found, expected);
             }
         } else if (s1.kind != s2.kind) {
             // check that rebase s1 to s2 fails
             try {
-                s1.segment.address().rebase(s2.segment);
+                s1.segment.address().segmentOffset(s2.segment);
                 fail("Rebase unexpectedly passed!");
             } catch (IllegalArgumentException ex) {
                 assertTrue(true);
             }
         } else if (!s2.contains(s1)) {
             //disjoint segments - check that rebased address is out of bounds
             MemoryAddress base = s2.segment.address();
-            MemoryAddress rebased = base.rebase(s1.segment);
+            long offset = base.segmentOffset(s1.segment);
             for (int i = 0; i < s2.size(); i++) {
-                BYTE_VH.get(base.addOffset(i));
+                MemoryAccess.getByteAtOffset(s2.segment, i);
                 try {
-                    BYTE_VH.get(rebased.addOffset(i));
+                    MemoryAccess.getByteAtOffset(s1.segment, i + offset);
                     fail("Rebased address on a disjoint segment is not out of bounds!");
                 } catch (IndexOutOfBoundsException ex) {
                     assertTrue(true);
                 }
             }
@@ -127,11 +126,11 @@
         List<SegmentSlice> slices = new ArrayList<>();
         for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {
             //init root segment
             MemorySegment segment = kind.makeSegment(16);
             for (int i = 0 ; i < 16 ; i++) {
-                BYTE_VH.set(segment.address().addOffset(i), (byte)i);
+                MemoryAccess.setByteAtOffset(segment, i, (byte)i);
             }
             //compute all slices
             for (int size : sizes) {
                 for (int index = 0 ; index < 16 ; index += size) {
                     MemorySegment slice = segment.asSlice(index, size);
diff a/test/jdk/java/foreign/TestSegments.java b/test/jdk/java/foreign/TestSegments.java
--- a/test/jdk/java/foreign/TestSegments.java
+++ b/test/jdk/java/foreign/TestSegments.java
@@ -92,58 +92,32 @@
     public void testNativeSegmentIsZeroed() {
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(1000)) {
             for (long i = 0 ; i < segment.byteSize() ; i++) {
-                assertEquals(0, (byte)byteHandle.get(segment.address(), i));
+                assertEquals(0, (byte)byteHandle.get(segment, i));
             }
         }
     }
 
-    @Test
-    public void testNothingSegmentAccess() {
-        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);
-        long[] values = { 0L, Integer.MAX_VALUE - 1, (long) Integer.MAX_VALUE + 1 };
-        for (long value : values) {
-            MemoryAddress addr = MemoryAddress.ofLong(value);
-            try {
-                longHandle.get(addr);
-            } catch (UnsupportedOperationException ex) {
-                assertTrue(ex.getMessage().contains("Required access mode"));
-            }
-        }
-    }
-
-    @Test(expectedExceptions = UnsupportedOperationException.class)
-    public void testNothingSegmentOffset() {
-        MemoryAddress addr = MemoryAddress.ofLong(42);
-        assertNull(addr.segment());
-        addr.segmentOffset();
-    }
-
     @Test
     public void testSlices() {
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(10)) {
             //init
             for (byte i = 0 ; i < segment.byteSize() ; i++) {
-                byteHandle.set(segment.address(), (long)i, i);
+                byteHandle.set(segment, (long)i, i);
             }
-            long start = 0;
-            MemoryAddress base = segment.address();
-            MemoryAddress last = base.addOffset(10);
-            while (!base.equals(last)) {
-                MemorySegment slice = segment.asSlice(base.segmentOffset(), 10 - start);
-                for (long i = start ; i < 10 ; i++) {
+            for (int offset = 0 ; offset < 10 ; offset++) {
+                MemorySegment slice = segment.asSlice(offset);
+                for (long i = offset ; i < 10 ; i++) {
                     assertEquals(
-                            byteHandle.get(segment.address(), i),
-                            byteHandle.get(slice.address(), i - start)
+                            byteHandle.get(segment, i),
+                            byteHandle.get(slice, i - offset)
                     );
                 }
-                base = base.addOffset(1);
-                start++;
             }
         }
     }
 
     @Test(dataProvider = "segmentFactories")
@@ -195,24 +169,24 @@
 
         for (byte value : new byte[] {(byte) 0xFF, (byte) 0x00, (byte) 0x45}) {
             try (MemorySegment segment = memorySegmentSupplier.get()) {
                 segment.fill(value);
                 for (long l = 0; l < segment.byteSize(); l++) {
-                    assertEquals((byte) byteHandle.get(segment.address(), l), value);
+                    assertEquals((byte) byteHandle.get(segment, l), value);
                 }
 
                 // fill a slice
                 var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);
                 for (long l = 0; l < sliceSegment.byteSize(); l++) {
-                    assertEquals((byte) byteHandle.get(sliceSegment.address(), l), ~value);
+                    assertEquals((byte) byteHandle.get(sliceSegment, l), ~value);
                 }
                 // assert enclosing slice
-                assertEquals((byte) byteHandle.get(segment.address(), 0L), value);
+                assertEquals((byte) byteHandle.get(segment, 0L), value);
                 for (long l = 1; l < segment.byteSize() - 2; l++) {
-                    assertEquals((byte) byteHandle.get(segment.address(), l), (byte) ~value);
+                    assertEquals((byte) byteHandle.get(segment, l), (byte) ~value);
                 }
-                assertEquals((byte) byteHandle.get(segment.address(), segment.byteSize() - 1L), value);
+                assertEquals((byte) byteHandle.get(segment, segment.byteSize() - 1L), value);
             }
         }
     }
 
     @Test(dataProvider = "segmentFactories", expectedExceptions = IllegalStateException.class)
@@ -317,12 +291,13 @@
 
     @DataProvider(name = "segmentOperations")
     static Object[][] segmentMembers() {
         List<SegmentMember> members = new ArrayList<>();
         for (Method m : MemorySegment.class.getDeclaredMethods()) {
-            //skip statics and method declared in j.l.Object
-            if (m.getDeclaringClass().equals(Object.class) ||
+            //skip defaults, statics and method declared in j.l.Object
+            if (m.isDefault() ||
+                    m.getDeclaringClass().equals(Object.class) ||
                     (m.getModifiers() & Modifier.STATIC) != 0) continue;
             Object[] args = Stream.of(m.getParameterTypes())
                     .map(TestSegments::defaultValue)
                     .toArray();
             members.add(new SegmentMember(m, args));
@@ -333,10 +308,11 @@
     static class SegmentMember {
         final Method method;
         final Object[] params;
 
         final static List<String> CONFINED_NAMES = List.of(
+                "address",
                 "close",
                 "fill",
                 "copyFrom",
                 "mismatch",
                 "toByteArray",
@@ -434,17 +410,17 @@
             }
         },
         READ(MemorySegment.READ) {
             @Override
             void run(MemorySegment segment) {
-                INT_HANDLE.get(segment.address());
+                INT_HANDLE.get(segment);
             }
         },
         WRITE(MemorySegment.WRITE) {
             @Override
             void run(MemorySegment segment) {
-                INT_HANDLE.set(segment.address(), 42);
+                INT_HANDLE.set(segment, 42);
             }
         },
         HANDOFF(MemorySegment.HANDOFF) {
             @Override
             void run(MemorySegment segment) {
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -25,16 +25,15 @@
 /*
  * @test
  * @run testng/othervm -Dforeign.restricted=permit TestSharedAccess
  */
 
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.SequenceLayout;
-import org.testng.annotations.Test;
+import org.testng.annotations.*;
 
 import java.lang.invoke.VarHandle;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
@@ -43,29 +42,27 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
+import static org.testng.Assert.*;
 
 public class TestSharedAccess {
 
     static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);
 
     @Test
     public void testConfined() throws Throwable {
         Thread owner = Thread.currentThread();
         MemorySegment s = MemorySegment.allocateNative(4);
         AtomicReference<MemorySegment> confined = new AtomicReference<>(s);
-        setInt(s.address(), 42);
-        assertEquals(getInt(s.address()), 42);
+        setInt(s, 42);
+        assertEquals(getInt(s), 42);
         List<Thread> threads = new ArrayList<>();
         for (int i = 0 ; i < 1000 ; i++) {
             threads.add(new Thread(() -> {
-                assertEquals(getInt(confined.get().address()), 42);
+                assertEquals(getInt(confined.get()), 42);
                 confined.set(confined.get().withOwnerThread(owner));
             }));
         }
         threads.forEach(t -> {
             confined.set(confined.get().withOwnerThread(t));
@@ -82,11 +79,11 @@
     @Test
     public void testShared() throws Throwable {
         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
         try (MemorySegment s = MemorySegment.allocateNative(layout)) {
             for (int i = 0 ; i < layout.elementCount().getAsLong() ; i++) {
-                setInt(s.address().addOffset(i * 4), 42);
+                setInt(s.asSlice(i * 4), 42);
             }
             List<Thread> threads = new ArrayList<>();
             List<Spliterator<MemorySegment>> spliterators = new ArrayList<>();
             spliterators.add(MemorySegment.spliterator(s, layout));
             while (true) {
@@ -105,11 +102,11 @@
 
             AtomicInteger accessCount = new AtomicInteger();
             for (Spliterator<MemorySegment> spliterator : spliterators) {
                 threads.add(new Thread(() -> {
                     spliterator.tryAdvance(local -> {
-                        assertEquals(getInt(local.address()), 42);
+                        assertEquals(getInt(local), 42);
                         accessCount.incrementAndGet();
                     });
                 }));
             }
             threads.forEach(Thread::start);
@@ -125,18 +122,18 @@
     }
 
     @Test
     public void testSharedUnsafe() throws Throwable {
         try (MemorySegment s = MemorySegment.allocateNative(4)) {
-            setInt(s.address(), 42);
-            assertEquals(getInt(s.address()), 42);
+            setInt(s, 42);
+            assertEquals(getInt(s), 42);
             List<Thread> threads = new ArrayList<>();
             MemorySegment sharedSegment = MemorySegment.ofNativeRestricted(
                     s.address(), s.byteSize(), null, null, null);
             for (int i = 0 ; i < 1000 ; i++) {
                 threads.add(new Thread(() -> {
-                    assertEquals(getInt(sharedSegment.address()), 42);
+                    assertEquals(getInt(sharedSegment), 42);
                 }));
             }
             threads.forEach(Thread::start);
             threads.forEach(t -> {
                 try {
@@ -225,30 +222,28 @@
                     try {
                         b.await();
                     } catch (InterruptedException e) {
                     }
 
-                    MemoryAddress base = s2.address();
-                    setInt(base.addOffset(4), -42);
+                    setInt(s2.asSlice(4), -42);
                     fail();
                 } catch (IllegalStateException ex) {
                     assertTrue(ex.getMessage().contains("owning thread"));
                 }
             });
 
             a.await();
-            MemoryAddress base = s1.address();
-            setInt(base.addOffset(4), 42);
+            setInt(s1.asSlice(4), 42);
         }
 
         b.countDown();
         r.get();
     }
 
-    static int getInt(MemoryAddress address) {
-        return (int)intHandle.getVolatile(address);
+    static int getInt(MemorySegment base) {
+        return (int)intHandle.getVolatile(base);
     }
 
-    static void setInt(MemoryAddress address, int value) {
-        intHandle.setVolatile(address, value);
+    static void setInt(MemorySegment base, int value) {
+        intHandle.setVolatile(base, value);
     }
 }
diff a/test/jdk/java/foreign/TestSlices.java b/test/jdk/java/foreign/TestSlices.java
--- a/test/jdk/java/foreign/TestSlices.java
+++ b/test/jdk/java/foreign/TestSlices.java
@@ -42,19 +42,17 @@
             MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT));
 
     static VarHandle VH_ALL = LAYOUT.varHandle(int.class,
             MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement());
 
-    static VarHandle VH_INT = MemoryLayouts.JAVA_INT.varHandle(int.class);
-
     @Test(dataProvider = "slices")
     public void testSlices(VarHandle handle, int lo, int hi, int[] values) {
         try (MemorySegment segment = MemorySegment.allocateNative(LAYOUT)) {
             //init
             for (long i = 0 ; i < 2 ; i++) {
                 for (long j = 0 ; j < 5 ; j++) {
-                    VH_ALL.set(segment.address(), i, j, (int)j + 1 + ((int)i * 5));
+                    VH_ALL.set(segment, i, j, (int)j + 1 + ((int)i * 5));
                 }
             }
 
             checkSlice(segment, handle, lo, hi, values);
         }
@@ -62,11 +60,11 @@
 
     static void checkSlice(MemorySegment segment, VarHandle handle, long i_max, long j_max, int... values) {
         int index = 0;
         for (long i = 0 ; i < i_max ; i++) {
             for (long j = 0 ; j < j_max ; j++) {
-                int x = (int) handle.get(segment.address(), i, j);
+                int x = (int) handle.get(segment, i, j);
                 assertEquals(x, values[index++]);
             }
         }
         assertEquals(index, values.length);
     }
@@ -77,21 +75,17 @@
                 // x
                 { VH_ALL, 2, 5, new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } },
                 // x[0::2]
                 { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),
                         MemoryLayout.PathElement.sequenceElement(0, 2)), 2, 3, new int[] { 1, 3, 5, 6, 8, 10 } },
-                { MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, 8), 20), 2, 3, new int[] { 1, 3, 5, 6, 8, 10 } },
                 // x[1::2]
                 { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),
                         MemoryLayout.PathElement.sequenceElement(1, 2)), 2, 2, new int[] { 2, 4, 7, 9 } },
-                { MemoryHandles.withOffset(MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, 8), 20), 4), 2, 2, new int[] { 2, 4, 7, 9 } },
                 // x[4::-2]
                 { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),
                         MemoryLayout.PathElement.sequenceElement(4, -2)), 2, 3, new int[] { 5, 3, 1, 10, 8, 6 } },
-                { MemoryHandles.withOffset(MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, -8), 20), 16), 2, 3, new int[] { 5, 3, 1, 10, 8, 6 } },
                 // x[3::-2]
                 { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),
                         MemoryLayout.PathElement.sequenceElement(3, -2)), 2, 2, new int[] { 4, 2, 9, 7 } },
-                { MemoryHandles.withOffset(MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, -8), 20), 12), 2, 2, new int[] { 4, 2, 9, 7 } },
         };
     }
 }
diff a/test/jdk/java/foreign/TestSpliterator.java b/test/jdk/java/foreign/TestSpliterator.java
--- a/test/jdk/java/foreign/TestSpliterator.java
+++ b/test/jdk/java/foreign/TestSpliterator.java
@@ -61,11 +61,11 @@
         SequenceLayout layout = MemoryLayout.ofSequence(size, MemoryLayouts.JAVA_INT);
 
         //setup
         MemorySegment segment = MemorySegment.allocateNative(layout);
         for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
-            INT_HANDLE.set(segment.address(), (long) i, i);
+            INT_HANDLE.set(segment, (long) i, i);
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
         //serial
         long serial = sum(0, segment);
         assertEquals(serial, expected);
@@ -86,11 +86,11 @@
         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
 
         //setup
         MemorySegment segment = MemorySegment.allocateNative(layout);
         for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
-            INT_HANDLE.set(segment.address(), (long) i, i);
+            INT_HANDLE.set(segment, (long) i, i);
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 
         //check that a segment w/o ACQUIRE access mode can still be used from same thread
         AtomicLong spliteratorSum = new AtomicLong();
@@ -98,19 +98,18 @@
                 .forEachRemaining(s -> spliteratorSum.addAndGet(sumSingle(0L, s)));
         assertEquals(spliteratorSum.get(), expected);
     }
 
     static long sumSingle(long acc, MemorySegment segment) {
-        return acc + (int)INT_HANDLE.get(segment.address(), 0L);
+        return acc + (int)INT_HANDLE.get(segment, 0L);
     }
 
     static long sum(long start, MemorySegment segment) {
         long sum = start;
-        MemoryAddress base = segment.address();
         int length = (int)segment.byteSize();
         for (int i = 0 ; i < length / CARRIER_SIZE ; i++) {
-            sum += (int)INT_HANDLE.get(base, (long)i);
+            sum += (int)INT_HANDLE.get(segment, (long)i);
         }
         return sum;
     }
 
     static class SumSegmentCounted extends CountedCompleter<Long> {
diff a/test/jdk/java/foreign/TestVarHandleCombinators.java b/test/jdk/java/foreign/TestVarHandleCombinators.java
--- a/test/jdk/java/foreign/TestVarHandleCombinators.java
+++ b/test/jdk/java/foreign/TestVarHandleCombinators.java
@@ -29,11 +29,10 @@
 
 import jdk.incubator.foreign.MemoryHandles;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
@@ -43,40 +42,24 @@
 public class TestVarHandleCombinators {
 
     @Test
     public void testElementAccess() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withStride(vh, 1);
 
         byte[] arr = { 0, 0, -1, 0 };
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress addr = segment.address();
-
-        assertEquals((byte) vh.get(addr, 2), (byte) -1);
+        assertEquals((byte) vh.get(segment, 2), (byte) -1);
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedElement() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withStride(vh, 2);
         MemorySegment segment = MemorySegment.ofArray(new byte[4]);
-        vh.get(segment.address(), 1L); //should throw
-    }
-
-    public void testZeroStrideElement() {
-        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-        VarHandle strided_vh = MemoryHandles.withStride(vh, 0);
-        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
-        for (int i = 0 ; i < 100 ; i++) {
-            assertEquals((int)vh.get(segment.address()), strided_vh.get(segment.address(), (long)i));
-        }
-    }
-
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void testStrideWrongHandle() {
-        VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());
-        MemoryHandles.withStride(vh, 10);
+        vh.get(segment, 2L); //should throw
+        //FIXME: the VH only checks the alignment of the segment, which is fine if the VH is derived from layouts,
+        //FIXME: but not if the VH is just created from scratch - we need a VH variable to govern this property,
+        //FIXME: at least until the VM is fixed
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testAlignNotPowerOf2() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 3, ByteOrder.nativeOrder());
@@ -90,82 +73,30 @@
     @Test
     public void testAlign() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
 
         MemorySegment segment = MemorySegment.allocateNative(1, 2);
-        MemoryAddress address = segment.address();
-
-        vh.set(address, (byte) 10); // fine, memory region is aligned
-        assertEquals((byte) vh.get(address), (byte) 10);
-    }
-
-    @Test(expectedExceptions = IllegalStateException.class)
-    public void testAlignBadAccess() {
-        VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withOffset(vh, 1); // offset by 1 byte
-
-        MemorySegment segment = MemorySegment.allocateNative(2, 2);
-        MemoryAddress address = segment.address();
-
-        vh.set(address, (byte) 10); // should be bad align
-    }
-
-    public void testZeroOffsetElement() {
-        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-        VarHandle offset_vh = MemoryHandles.withOffset(vh, 0);
-        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
-        for (int i = 0 ; i < 100 ; i++) {
-            assertEquals((int)vh.get(segment.address()), offset_vh.get(segment.address(), (long)i));
-        }
-    }
-
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void testOffsetWrongHandle() {
-        VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());
-        MemoryHandles.withOffset(vh, 1);
-    }
-
-    @Test(expectedExceptions = IllegalStateException.class)
-    public void testUnalignedOffset() {
-        VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withOffset(vh, 2);
-        MemorySegment segment = MemorySegment.ofArray(new byte[4]);
-        vh.get(segment.address()); //should throw
-    }
-
-    @Test
-    public void testOffset() {
-        VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withOffset(vh, 1);
-
-        MemorySegment segment = MemorySegment.ofArray(new byte[2]);
-        MemoryAddress address = segment.address();
-
-        vh.set(address, (byte) 10);
-        assertEquals((byte) vh.get(address), (byte) 10);
+        vh.set(segment, 0L, (byte) 10); // fine, memory region is aligned
+        assertEquals((byte) vh.get(segment, 0L), (byte) 10);
     }
 
     @Test
     public void testByteOrderLE() {
         VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.LITTLE_ENDIAN);
         byte[] arr = new byte[2];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress address = segment.address();
-
-        vh.set(address, (short) 0xFF);
+        vh.set(segment, 0L, (short) 0xFF);
         assertEquals(arr[0], (byte) 0xFF);
         assertEquals(arr[1], (byte) 0);
     }
 
     @Test
     public void testByteOrderBE() {
         VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.BIG_ENDIAN);
         byte[] arr = new byte[2];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress address = segment.address();
-
-        vh.set(address, (short) 0xFF);
+        vh.set(segment, 0L, (short) 0xFF);
         assertEquals(arr[0], (byte) 0);
         assertEquals(arr[1], (byte) 0xFF);
     }
 
     @Test
@@ -174,20 +105,17 @@
         int inner_size = 5;
 
         //[10 : [5 : [x32 i32]]]
 
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
-        vh = MemoryHandles.withOffset(vh, 4);
-        VarHandle inner_vh = MemoryHandles.withStride(vh, 8);
-        VarHandle outer_vh = MemoryHandles.withStride(inner_vh, 5 * 8);
         int count = 0;
         try (MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8)) {
             for (long i = 0; i < outer_size; i++) {
                 for (long j = 0; j < inner_size; j++) {
-                    outer_vh.set(segment.address(), i, j, count);
+                    vh.set(segment, i * 40 + j * 8, count);
                     assertEquals(
-                            (int)inner_vh.get(segment.address().addOffset(i * inner_size * 8), j),
+                            (int)vh.get(segment.asSlice(i * inner_size * 8), j * 8),
                             count);
                     count++;
                 }
             }
         }
@@ -203,10 +131,10 @@
         return new Object[][] {
                 { void.class },
                 { boolean.class },
                 { Object.class },
                 { int[].class },
-                { MemoryAddress.class }
+                { MemorySegment.class }
         };
     }
 
 }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
@@ -70,16 +70,16 @@
         }
     }
 
     //setup native memory segment
 
-    static final MemoryAddress segment_addr = MemorySegment.allocateNative(ALLOC_SIZE).address();
+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);
     static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());
 
     static {
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment_addr, (long) i, i);
+            VH_int.set(segment, (long) i, i);
         }
     }
 
     //setup direct buffer
 
@@ -98,11 +98,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int)VH_int.get(segment_addr, 0L);
+        return (int)VH_int.get(segment, 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -120,11 +120,11 @@
 
     @Benchmark
     public int segment_loop() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i++) {
-            res += (int) VH_int.get(segment_addr, (long)i);
+            res += (int) VH_int.get(segment, (long)i);
         }
         return res;
     }
 
     @Benchmark
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
@@ -71,11 +71,11 @@
 
     @Benchmark
     public void segment_loop() {
         MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.address(), (long) i, i);
+            VH_int.set(segment, (long) i, i);
         }
         segment.close();
     }
 
     @Benchmark
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
@@ -72,11 +72,11 @@
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(unsafe_addr + (i * CARRIER_SIZE) , i);
         }
         segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.address(), (long) i, i);
+            VH_int.set(segment, (long) i, i);
         }
         byteBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());
         for (int i = 0; i < ELEM_SIZE; i++) {
             byteBuffer.putInt(i * CARRIER_SIZE , i);
         }
@@ -96,11 +96,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.address(), 0L);
+        return (int) VH_int.get(segment, 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -118,39 +118,38 @@
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.address(), i);
+            res += MemoryAccess.getIntAtIndex(segment, i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            sum += (int) VH_int.get(base, (long) i);
+            sum += (int) VH_int.get(segment, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
+        MemorySegment base = segment.asSlice(0, segment.byteSize());
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
@@ -89,11 +89,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.address(), 0L);
+        return (int) VH_int.get(segment, 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -110,40 +110,39 @@
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            sum += (int) VH_int.get(base, (long) i);
+            sum += (int) VH_int.get(segment, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.address(), i);
+            res += MemoryAccess.getIntAtIndex(segment, i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
+        MemorySegment base = segment.asSlice(0, segment.byteSize());
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
@@ -113,11 +113,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.address(), 0L);
+        return (int) VH_int.get(segment, 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -134,40 +134,39 @@
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            sum += (int) VH_int.get(base, (long) i);
+            sum += (int) VH_int.get(segment, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.address(), i);
+            res += MemoryAccess.getIntAtIndex(segment, i * CARRIER_SIZE);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
+        MemorySegment base = segment.asSlice(0, segment.byteSize());
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
@@ -42,14 +42,16 @@
 import jdk.incubator.foreign.MemorySegment;
 import java.lang.invoke.VarHandle;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Optional;
+import java.util.OptionalInt;
 import java.util.Spliterator;
 import java.util.concurrent.CountedCompleter;
 import java.util.concurrent.RecursiveTask;
 import java.util.concurrent.TimeUnit;
+import java.util.function.IntFunction;
 import java.util.function.Predicate;
 import java.util.function.ToIntFunction;
 import java.util.stream.StreamSupport;
 
 import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;
@@ -83,11 +85,11 @@
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(address + (i * CARRIER_SIZE), i);
         }
         segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.address(), (long) i, i);
+            VH_int.set(segment, (long) i, i);
         }
     }
 
     @TearDown
     public void tearDown() throws Throwable {
@@ -96,13 +98,12 @@
     }
 
     @Benchmark
     public int segment_serial() {
         int res = 0;
-        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            res += (int)VH_int.get(base, (long) i);
+            res += (int)VH_int.get(segment, (long) i);
         }
         return res;
     }
 
     @Benchmark
@@ -135,17 +136,16 @@
         return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)
                 .mapToInt(SEGMENT_TO_INT_BULK).sum();
     }
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT = slice ->
-            (int) VH_int.get(slice.address(), 0L);
+            (int) VH_int.get(slice, 0L);
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT_BULK = slice -> {
         int res = 0;
-        MemoryAddress base = slice.address();
         for (int i = 0; i < BULK_FACTOR ; i++) {
-            res += (int)VH_int.get(base, (long) i);
+            res += (int)VH_int.get(slice, (long) i);
         }
         return res;
     };
 
     @Benchmark
@@ -175,16 +175,15 @@
                 .filter(FIND_BULK)
                 .findAny();
     }
 
     final static Predicate<MemorySegment> FIND_SINGLE = slice ->
-            (int)VH_int.get(slice.address(), 0L) == (ELEM_SIZE - 1);
+            (int)VH_int.get(slice, 0L) == (ELEM_SIZE - 1);
 
     final static Predicate<MemorySegment> FIND_BULK = slice -> {
-        MemoryAddress base = slice.address();
         for (int i = 0; i < BULK_FACTOR ; i++) {
-            if ((int)VH_int.get(base, (long)i) == (ELEM_SIZE - 1)) {
+            if ((int)VH_int.get(slice, (long)i) == (ELEM_SIZE - 1)) {
                 return true;
             }
         }
         return false;
     };
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
@@ -142,22 +142,20 @@
     }
 
     @Benchmark
     public int segment_loop() throws Throwable {
         int sum = 0;
-        MemoryAddress baseAddress = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            sum += (int)VH_addr_int.get(baseAddress, (long)i);
+            sum += (int)VH_addr_int.get(segment, (long)i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_box_loop() throws Throwable {
         int sum = 0;
-        MemoryAddress baseAddress = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
-            sum += ((IntBox)VH_addr_box_int.get(baseAddress, (long)i)).intValue();
+            sum += ((IntBox)VH_addr_box_int.get(segment, (long)i)).intValue();
         }
         return sum;
     }
 }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
@@ -56,23 +56,23 @@
     public PanamaPoint(MemorySegment segment) {
         this.segment = segment;
     }
 
     public void setX(int x) {
-        VH_x.set(segment.address(), x);
+        VH_x.set(segment, x);
     }
 
     public int getX() {
-        return (int) VH_x.get(segment.address());
+        return (int) VH_x.get(segment);
     }
 
     public void setY(int y) {
-        VH_y.set(segment.address(), y);
+        VH_y.set(segment, y);
     }
 
     public int getY() {
-        return (int) VH_y.get(segment.address());
+        return (int) VH_y.get(segment);
     }
 
     @Override
     public void close() {
         segment.close();

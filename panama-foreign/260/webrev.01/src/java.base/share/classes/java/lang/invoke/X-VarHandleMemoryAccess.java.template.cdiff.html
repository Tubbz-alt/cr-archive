<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="VarHandles.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaLangInvokeAccess.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,25 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package java.lang.invoke;
  
<span class="line-modified">! import jdk.internal.access.foreign.MemoryAddressProxy;</span>
  import jdk.internal.vm.annotation.ForceInline;
  
  import java.util.Objects;
  
  import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  
  #warn
  
<span class="line-modified">! final class MemoryAccessVarHandle$Type$Helper {</span>
  
      static final boolean BE = UNSAFE.isBigEndian();
  
      static final int VM_ALIGN = $BoxType$.BYTES - 1;
  
  #if[floatingPoint]
      @ForceInline
      static $rawType$ convEndian(boolean big, $type$ v) {
          $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
          return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
<span class="line-new-header">--- 22,36 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package java.lang.invoke;
  
<span class="line-modified">! import jdk.internal.access.foreign.MemorySegmentProxy;</span>
  import jdk.internal.vm.annotation.ForceInline;
  
  import java.util.Objects;
  
  import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  
  #warn
  
<span class="line-modified">! final class MemoryAccessVarHandle$Type$Helper extends MemoryAccessVarHandleBase {</span>
  
      static final boolean BE = UNSAFE.isBigEndian();
  
      static final int VM_ALIGN = $BoxType$.BYTES - 1;
  
<span class="line-added">+     static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegmentProxy.class, $type$.class, long.class);</span>
<span class="line-added">+ </span>
<span class="line-added">+     MemoryAccessVarHandle$Type$Helper(boolean skipOffetCheck, boolean be, long length, long alignmentMask) {</span>
<span class="line-added">+         super(FORM, skipOffetCheck, be, length, alignmentMask);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     final MethodType accessModeTypeUncached(AccessMode accessMode) {</span>
<span class="line-added">+         return accessMode.at.accessModeType(MemorySegmentProxy.class, $type$.class, long.class);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
  #if[floatingPoint]
      @ForceInline
      static $rawType$ convEndian(boolean big, $type$ v) {
          $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
          return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,309 ***</span>
      }
  #end[byte]
  #end[floatingPoint]
  
      @ForceInline
<span class="line-modified">!     static MemoryAddressProxy checkAddress(Object obb, long offset, long length, boolean ro) {</span>
<span class="line-modified">!         MemoryAddressProxy oo = (MemoryAddressProxy)Objects.requireNonNull(obb);</span>
          oo.checkAccess(offset, length, ro);
          return oo;
      }
<span class="line-modified">!     </span>
      @ForceInline
<span class="line-modified">!     static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {</span>
<span class="line-modified">!         long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);</span>
          if ((address &amp; VM_ALIGN) != 0) {
              throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
          }
          return address;
      }
  
      @ForceInline
<span class="line-modified">!     static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {</span>
          long base = bb.unsafeGetOffset();
          long address = base + offset;
<span class="line-modified">!         //note: the offset portion has already been aligned-checked, by construction</span>
<span class="line-modified">!         if ((base &amp; alignmentMask) != 0) {</span>
<span class="line-modified">!             throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);</span>
          }
          return address;
      }
<span class="line-modified">!     </span>
      @ForceInline
<span class="line-modified">!     static $type$ get0(VarHandle ob, Object obb, long base) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);</span>
  #if[floatingPoint]
          $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),</span>
                  handle.be);
          return $Type$.$rawType$BitsTo$Type$(rawValue);
  #else[floatingPoint]
  #if[byte]
          return UNSAFE.get$Type$(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask));</span>
  #else[byte]
          return UNSAFE.get$Type$Unaligned(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),</span>
                  handle.be);
  #end[byte]
  #end[floatingPoint]
      }
  
      @ForceInline
<span class="line-modified">!     static void set0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
  #if[floatingPoint]
          UNSAFE.put$RawType$Unaligned(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),</span>
                  $Type$.$type$ToRaw$RawType$Bits(value),
                  handle.be);
  #else[floatingPoint]
  #if[byte]
          UNSAFE.put$Type$(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),</span>
                  value);
  #else[byte]
          UNSAFE.put$Type$Unaligned(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),</span>
                  value,
                  handle.be);
  #end[byte]
  #end[floatingPoint]
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getVolatile0(VarHandle ob, Object obb, long base) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);</span>
          return convEndian(handle.be,
                            UNSAFE.get$RawType$Volatile(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(bb, base, handle.alignmentMask)));</span>
      }
  
      @ForceInline
<span class="line-modified">!     static void setVolatile0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          UNSAFE.put$RawType$Volatile(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAcquire0(VarHandle ob, Object obb, long base) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);</span>
          return convEndian(handle.be,
                            UNSAFE.get$RawType$Acquire(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(bb, base, handle.alignmentMask)));</span>
      }
  
      @ForceInline
<span class="line-modified">!     static void setRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          UNSAFE.put$RawType$Release(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getOpaque0(VarHandle ob, Object obb, long base) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);</span>
          return convEndian(handle.be,
                            UNSAFE.get$RawType$Opaque(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(bb, base, handle.alignmentMask)));</span>
      }
  
      @ForceInline
<span class="line-modified">!     static void setOpaque0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          UNSAFE.put$RawType$Opaque(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, value));
      }
  #if[CAS]
  
      @ForceInline
<span class="line-modified">!     static boolean compareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return UNSAFE.compareAndSet$RawType$(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, expected), convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ compareAndExchange0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.compareAndExchange$RawType$(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, expected), convEndian(handle.be, value)));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ compareAndExchangeAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.compareAndExchange$RawType$Acquire(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, expected), convEndian(handle.be, value)));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ compareAndExchangeRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.compareAndExchange$RawType$Release(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, expected), convEndian(handle.be, value)));
      }
  
      @ForceInline
<span class="line-modified">!     static boolean weakCompareAndSetPlain0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return UNSAFE.weakCompareAndSet$RawType$Plain(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, expected), convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static boolean weakCompareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return UNSAFE.weakCompareAndSet$RawType$(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, expected), convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static boolean weakCompareAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return UNSAFE.weakCompareAndSet$RawType$Acquire(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, expected), convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static boolean weakCompareAndSetRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return UNSAFE.weakCompareAndSet$RawType$Release(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, expected), convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndSet0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.getAndSet$RawType$(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, value)));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.getAndSet$RawType$Acquire(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, value)));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndSetRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.getAndSet$RawType$Release(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, value)));
      }
  #end[CAS]
  #if[AtomicAdd]
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndAdd0(VarHandle ob, Object obb, long base, $type$ delta) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndAdd$RawType$(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      delta);
          } else {
<span class="line-modified">!             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndAddAcquire0(VarHandle ob, Object obb, long base, $type$ delta) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndAdd$RawType$Acquire(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      delta);
          } else {
<span class="line-modified">!             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndAddRelease0(VarHandle ob, Object obb, long base, $type$ delta) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndAdd$RawType$Release(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      delta);
          } else {
<span class="line-modified">!             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {</span>
          $type$ nativeExpectedValue, expectedValue;
          Object base = bb.unsafeGetBase();
          do {
              nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
              expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
<span class="line-new-header">--- 75,315 ---</span>
      }
  #end[byte]
  #end[floatingPoint]
  
      @ForceInline
<span class="line-modified">!     static MemorySegmentProxy checkAddress(Object obb, long offset, long length, boolean ro) {</span>
<span class="line-modified">!         MemorySegmentProxy oo = (MemorySegmentProxy)Objects.requireNonNull(obb);</span>
          oo.checkAccess(offset, length, ro);
          return oo;
      }
<span class="line-modified">! </span>
      @ForceInline
<span class="line-modified">!     static long offset(boolean skipOffsetCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {</span>
<span class="line-modified">!         long address = offsetNoVMAlignCheck(skipOffsetCheck, bb, offset, alignmentMask);</span>
          if ((address &amp; VM_ALIGN) != 0) {
              throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
          }
          return address;
      }
  
      @ForceInline
<span class="line-modified">!     static long offsetNoVMAlignCheck(boolean skipOffsetCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {</span>
          long base = bb.unsafeGetOffset();
          long address = base + offset;
<span class="line-modified">!         if (skipOffsetCheck) {</span>
<span class="line-modified">!             //note: the offset portion has already been aligned-checked, by construction</span>
<span class="line-modified">!             if ((base &amp; alignmentMask) != 0) {</span>
<span class="line-added">+                 throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             if ((address &amp; alignmentMask) != 0) {</span>
<span class="line-added">+                 throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);</span>
<span class="line-added">+             }</span>
          }
          return address;
      }
<span class="line-modified">! </span>
      @ForceInline
<span class="line-modified">!     static $type$ get(VarHandle ob, Object obb, long base) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);</span>
  #if[floatingPoint]
          $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  handle.be);
          return $Type$.$rawType$BitsTo$Type$(rawValue);
  #else[floatingPoint]
  #if[byte]
          return UNSAFE.get$Type$(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask));</span>
  #else[byte]
          return UNSAFE.get$Type$Unaligned(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  handle.be);
  #end[byte]
  #end[floatingPoint]
      }
  
      @ForceInline
<span class="line-modified">!     static void set(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
  #if[floatingPoint]
          UNSAFE.put$RawType$Unaligned(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  $Type$.$type$ToRaw$RawType$Bits(value),
                  handle.be);
  #else[floatingPoint]
  #if[byte]
          UNSAFE.put$Type$(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  value);
  #else[byte]
          UNSAFE.put$Type$Unaligned(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  value,
                  handle.be);
  #end[byte]
  #end[floatingPoint]
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getVolatile(VarHandle ob, Object obb, long base) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);</span>
          return convEndian(handle.be,
                            UNSAFE.get$RawType$Volatile(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask)));</span>
      }
  
      @ForceInline
<span class="line-modified">!     static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          UNSAFE.put$RawType$Volatile(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAcquire(VarHandle ob, Object obb, long base) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);</span>
          return convEndian(handle.be,
                            UNSAFE.get$RawType$Acquire(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask)));</span>
      }
  
      @ForceInline
<span class="line-modified">!     static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          UNSAFE.put$RawType$Release(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getOpaque(VarHandle ob, Object obb, long base) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);</span>
          return convEndian(handle.be,
                            UNSAFE.get$RawType$Opaque(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask)));</span>
      }
  
      @ForceInline
<span class="line-modified">!     static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          UNSAFE.put$RawType$Opaque(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, value));
      }
  #if[CAS]
  
      @ForceInline
<span class="line-modified">!     static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return UNSAFE.compareAndSet$RawType$(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, expected), convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.compareAndExchange$RawType$(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, expected), convEndian(handle.be, value)));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.compareAndExchange$RawType$Acquire(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, expected), convEndian(handle.be, value)));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.compareAndExchange$RawType$Release(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, expected), convEndian(handle.be, value)));
      }
  
      @ForceInline
<span class="line-modified">!     static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return UNSAFE.weakCompareAndSet$RawType$Plain(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, expected), convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return UNSAFE.weakCompareAndSet$RawType$(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, expected), convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return UNSAFE.weakCompareAndSet$RawType$Acquire(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, expected), convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return UNSAFE.weakCompareAndSet$RawType$Release(
                  bb.unsafeGetBase(),
<span class="line-modified">!                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                  convEndian(handle.be, expected), convEndian(handle.be, value));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.getAndSet$RawType$(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, value)));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.getAndSet$RawType$Acquire(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, value)));
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          return convEndian(handle.be,
                            UNSAFE.getAndSet$RawType$Release(
                                    bb.unsafeGetBase(),
<span class="line-modified">!                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                                    convEndian(handle.be, value)));
      }
  #end[CAS]
  #if[AtomicAdd]
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndAdd$RawType$(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      delta);
          } else {
<span class="line-modified">!             return getAndAddConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), delta);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndAdd$RawType$Acquire(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      delta);
          } else {
<span class="line-modified">!             return getAndAddConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), delta);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndAdd$RawType$Release(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      delta);
          } else {
<span class="line-modified">!             return getAndAddConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), delta);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndAddConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ delta) {</span>
          $type$ nativeExpectedValue, expectedValue;
          Object base = bb.unsafeGetBase();
          do {
              nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
              expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 376,53 ***</span>
      }
  #end[AtomicAdd]
  #if[Bitwise]
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseOr0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseOr$RawType$(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseOrRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseOr$RawType$Release(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseOrAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseOr$RawType$Acquire(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {</span>
          $type$ nativeExpectedValue, expectedValue;
          Object base = bb.unsafeGetBase();
          do {
              nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
              expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
<span class="line-new-header">--- 393,53 ---</span>
      }
  #end[AtomicAdd]
  #if[Bitwise]
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseOr$RawType$(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseOr$RawType$Release(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseOr$RawType$Acquire(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseOrConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {</span>
          $type$ nativeExpectedValue, expectedValue;
          Object base = bb.unsafeGetBase();
          do {
              nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
              expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,53 ***</span>
                  nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
          return expectedValue;
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseAnd0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseAnd$RawType$(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseAndRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseAnd$RawType$Release(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseAndAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {</span>
          $type$ nativeExpectedValue, expectedValue;
          Object base = bb.unsafeGetBase();
          do {
              nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
              expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
<span class="line-new-header">--- 447,53 ---</span>
                  nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
          return expectedValue;
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseAnd$RawType$(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseAnd$RawType$Release(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseAndConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {</span>
          $type$ nativeExpectedValue, expectedValue;
          Object base = bb.unsafeGetBase();
          do {
              nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
              expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 485,53 ***</span>
          return expectedValue;
      }
  
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseXor0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseXor$RawType$(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseXorRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseXor$RawType$Release(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseXorAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseXor$RawType$Acquire(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {</span>
          $type$ nativeExpectedValue, expectedValue;
          Object base = bb.unsafeGetBase();
          do {
              nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
              expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
<span class="line-new-header">--- 502,53 ---</span>
          return expectedValue;
      }
  
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseXor$RawType$(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseXor$RawType$Release(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {</span>
          MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
<span class="line-modified">!         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);</span>
          if (handle.be == BE) {
              return UNSAFE.getAndBitwiseXor$RawType$Acquire(
                      bb.unsafeGetBase(),
<span class="line-modified">!                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
                      value);
          } else {
<span class="line-modified">!             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
          }
      }
  
      @ForceInline
<span class="line-modified">!     static $type$ getAndBitwiseXorConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {</span>
          $type$ nativeExpectedValue, expectedValue;
          Object base = bb.unsafeGetBase();
          do {
              nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
              expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
</pre>
<center><a href="VarHandles.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaLangInvokeAccess.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
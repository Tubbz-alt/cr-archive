<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 
 33 import java.lang.invoke.MethodHandle;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.invoke.MethodType;
 36 import java.lang.invoke.VarHandle;
 37 import java.nio.ByteOrder;
 38 import java.util.List;
 39 import java.util.Objects;
 40 
 41 /**
 42  * This class defines several factory methods for constructing and combining memory access var handles.
 43  * To obtain a memory access var handle, clients must start from one of the &lt;em&gt;leaf&lt;/em&gt; methods
 44  * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},
 45  * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type
 46  * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the
 47  * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways
 48  * to emulate different addressing modes. The var handles created by this class feature a &lt;em&gt;mandatory&lt;/em&gt; coordinate type
 49  * (of type {@link MemorySegment}), and one {@code long} coordinate type, which represents the offset, in bytes, relative
 50  * to the segment, at which dereference should occur.
 51  * &lt;p&gt;
<span class="line-modified"> 52  * As an example, consider the memory layout expressed by a {@link SequenceLayout} instance constructed as follows:</span>
 53  * &lt;blockquote&gt;&lt;pre&gt;{@code
 54 GroupLayout seq = MemoryLayout.ofStruct(
 55         MemoryLayout.ofPaddingBits(32),
 56         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
<span class="line-modified"> 57 ));</span>
 58  * }&lt;/pre&gt;&lt;/blockquote&gt;
 59  * To access the member layout named {@code value}, we can construct a memory access var handle as follows:
 60  * &lt;blockquote&gt;&lt;pre&gt;{@code
 61 VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); //(MemorySegment, long) -&gt; int
 62 handle = MemoryHandles.insertCoordinates(handle, 1, 4); //(MemorySegment) -&gt; int
 63  * }&lt;/pre&gt;&lt;/blockquote&gt;
 64  *
 65  * &lt;h2&gt;&lt;a id=&quot;memaccess-mode&quot;&gt;&lt;/a&gt;Alignment and access modes&lt;/h2&gt;
 66  *
 67  * A memory access var handle is associated with an access size {@code S} and an alignment constraint {@code B}
 68  * (both expressed in bytes). We say that a memory access operation is &lt;em&gt;fully aligned&lt;/em&gt; if it occurs
 69  * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.
 70  * If access is fully aligned then following access modes are supported and are
 71  * guaranteed to support atomic access:
 72  * &lt;ul&gt;
 73  * &lt;li&gt;read write access modes for all {@code T}, with the exception of
 74  *     access modes {@code get} and {@code set} for {@code long} and
 75  *     {@code double} on 32-bit platforms.
 76  * &lt;li&gt;atomic update access modes for {@code int}, {@code long},
 77  *     {@code float} or {@code double}.
</pre>
</td>
<td>
<hr />
<pre>
 32 
 33 import java.lang.invoke.MethodHandle;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.invoke.MethodType;
 36 import java.lang.invoke.VarHandle;
 37 import java.nio.ByteOrder;
 38 import java.util.List;
 39 import java.util.Objects;
 40 
 41 /**
 42  * This class defines several factory methods for constructing and combining memory access var handles.
 43  * To obtain a memory access var handle, clients must start from one of the &lt;em&gt;leaf&lt;/em&gt; methods
 44  * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},
 45  * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type
 46  * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the
 47  * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways
 48  * to emulate different addressing modes. The var handles created by this class feature a &lt;em&gt;mandatory&lt;/em&gt; coordinate type
 49  * (of type {@link MemorySegment}), and one {@code long} coordinate type, which represents the offset, in bytes, relative
 50  * to the segment, at which dereference should occur.
 51  * &lt;p&gt;
<span class="line-modified"> 52  * As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:</span>
 53  * &lt;blockquote&gt;&lt;pre&gt;{@code
 54 GroupLayout seq = MemoryLayout.ofStruct(
 55         MemoryLayout.ofPaddingBits(32),
 56         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
<span class="line-modified"> 57 );</span>
 58  * }&lt;/pre&gt;&lt;/blockquote&gt;
 59  * To access the member layout named {@code value}, we can construct a memory access var handle as follows:
 60  * &lt;blockquote&gt;&lt;pre&gt;{@code
 61 VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); //(MemorySegment, long) -&gt; int
 62 handle = MemoryHandles.insertCoordinates(handle, 1, 4); //(MemorySegment) -&gt; int
 63  * }&lt;/pre&gt;&lt;/blockquote&gt;
 64  *
 65  * &lt;h2&gt;&lt;a id=&quot;memaccess-mode&quot;&gt;&lt;/a&gt;Alignment and access modes&lt;/h2&gt;
 66  *
 67  * A memory access var handle is associated with an access size {@code S} and an alignment constraint {@code B}
 68  * (both expressed in bytes). We say that a memory access operation is &lt;em&gt;fully aligned&lt;/em&gt; if it occurs
 69  * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.
 70  * If access is fully aligned then following access modes are supported and are
 71  * guaranteed to support atomic access:
 72  * &lt;ul&gt;
 73  * &lt;li&gt;read write access modes for all {@code T}, with the exception of
 74  *     access modes {@code get} and {@code set} for {@code long} and
 75  *     {@code double} on 32-bit platforms.
 76  * &lt;li&gt;atomic update access modes for {@code int}, {@code long},
 77  *     {@code float} or {@code double}.
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
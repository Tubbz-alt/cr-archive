diff a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
--- a/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
+++ b/src/java.base/share/classes/java/lang/invoke/MemoryAccessVarHandleBase.java
@@ -37,11 +37,11 @@
     final long length;
 
     /** alignment constraint (in bytes, expressed as a bit mask) **/
     final long alignmentMask;
 
-    /** alignment constraint (in bytes, expressed as a bit mask) **/
+    /** if true, only the base part of the address will be checked for alignment **/
     final boolean skipOffsetCheck;
 
     MemoryAccessVarHandleBase(VarForm form, boolean skipOffetCheck, boolean be, long length, long alignmentMask) {
         super(form);
         this.skipOffsetCheck = skipOffetCheck;
diff a/src/java.base/share/classes/java/lang/invoke/VarHandles.java b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/VarHandles.java
@@ -309,10 +309,11 @@
      *
      * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added
      * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.
      *
      * @param carrier the Java carrier type.
+     * @param skipOffsetCheck if true, only the base part of the address will be checked for alignment.
      * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.
      * @param byteOrder the byte order.
      * @return the created VarHandle.
      */
     static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, boolean skipOffsetCheck, long alignmentMask,
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -283,21 +283,21 @@
     /**
      * Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
      * and whose new size is computed by subtracting the specified offset from this segment size.
      * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.
      * @return a new memory segment view with updated base/limit addresses.
-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}
+     * @throws IndexOutOfBoundsException if {@code offset < 0}, or {@code offset > byteSize()}.
      */
     MemorySegment asSlice(long offset);
 
     /**
      * Obtains a new memory segment view whose base address is the address passed as argument,
      * and whose new size is computed by subtracting the address offset relative to this segment
      * (see {@link MemoryAddress#segmentOffset(MemorySegment)}) from this segment size.
      * @param address The new segment base offset (relative to the current segment base address), specified in bytes.
      * @return a new memory segment view with updated base/limit addresses.
-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}
+     * @throws IndexOutOfBoundsException if {@code address.segmentOffset(this) < 0}, or {@code address.segmentOffset(this) > byteSize()}.
      */
     default MemorySegment asSlice(MemoryAddress address) {
         return asSlice(address.segmentOffset(this));
     }
 

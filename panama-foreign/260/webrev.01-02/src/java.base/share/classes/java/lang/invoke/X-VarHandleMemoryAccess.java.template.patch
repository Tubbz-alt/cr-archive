diff a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
--- a/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
+++ b/src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template
@@ -39,12 +39,12 @@
 
     static final int VM_ALIGN = $BoxType$.BYTES - 1;
 
     static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegmentProxy.class, $type$.class, long.class);
 
-    MemoryAccessVarHandle$Type$Helper(boolean skipOffetCheck, boolean be, long length, long alignmentMask) {
-        super(FORM, skipOffetCheck, be, length, alignmentMask);
+    MemoryAccessVarHandle$Type$Helper(boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask) {
+        super(FORM, skipAlignmentMaskCheck, be, length, alignmentMask);
     }
 
     @Override
     final MethodType accessModeTypeUncached(AccessMode accessMode) {
         return accessMode.at.accessModeType(MemorySegmentProxy.class, $type$.class, long.class);
@@ -82,23 +82,23 @@
         oo.checkAccess(offset, length, ro);
         return oo;
     }
 
     @ForceInline
-    static long offset(boolean skipOffsetCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {
-        long address = offsetNoVMAlignCheck(skipOffsetCheck, bb, offset, alignmentMask);
+    static long offset(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {
+        long address = offsetNoVMAlignCheck(skipAlignmentMaskCheck, bb, offset, alignmentMask);
         if ((address & VM_ALIGN) != 0) {
             throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
         }
         return address;
     }
 
     @ForceInline
-    static long offsetNoVMAlignCheck(boolean skipOffsetCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {
+    static long offsetNoVMAlignCheck(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {
         long base = bb.unsafeGetOffset();
         long address = base + offset;
-        if (skipOffsetCheck) {
+        if (skipAlignmentMaskCheck) {
             //note: the offset portion has already been aligned-checked, by construction
             if ((base & alignmentMask) != 0) {
                 throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
             }
         } else {
@@ -114,22 +114,22 @@
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
 #if[floatingPoint]
         $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 handle.be);
         return $Type$.$rawType$BitsTo$Type$(rawValue);
 #else[floatingPoint]
 #if[byte]
         return UNSAFE.get$Type$(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask));
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask));
 #else[byte]
         return UNSAFE.get$Type$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 handle.be);
 #end[byte]
 #end[floatingPoint]
     }
 
@@ -138,23 +138,23 @@
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
 #if[floatingPoint]
         UNSAFE.put$RawType$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 $Type$.$type$ToRaw$RawType$Bits(value),
                 handle.be);
 #else[floatingPoint]
 #if[byte]
         UNSAFE.put$Type$(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 value);
 #else[byte]
         UNSAFE.put$Type$Unaligned(
                 bb.unsafeGetBase(),
-                offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 value,
                 handle.be);
 #end[byte]
 #end[floatingPoint]
     }
@@ -164,177 +164,177 @@
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
         return convEndian(handle.be,
                           UNSAFE.get$RawType$Volatile(
                                   bb.unsafeGetBase(),
-                                  offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask)));
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));
     }
 
     @ForceInline
     static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         UNSAFE.put$RawType$Volatile(
                 bb.unsafeGetBase(),
-                offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, value));
     }
 
     @ForceInline
     static $type$ getAcquire(VarHandle ob, Object obb, long base) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
         return convEndian(handle.be,
                           UNSAFE.get$RawType$Acquire(
                                   bb.unsafeGetBase(),
-                                  offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask)));
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));
     }
 
     @ForceInline
     static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         UNSAFE.put$RawType$Release(
                 bb.unsafeGetBase(),
-                offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, value));
     }
 
     @ForceInline
     static $type$ getOpaque(VarHandle ob, Object obb, long base) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
         return convEndian(handle.be,
                           UNSAFE.get$RawType$Opaque(
                                   bb.unsafeGetBase(),
-                                  offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask)));
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));
     }
 
     @ForceInline
     static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         UNSAFE.put$RawType$Opaque(
                 bb.unsafeGetBase(),
-                offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, value));
     }
 #if[CAS]
 
     @ForceInline
     static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.compareAndSet$RawType$(
                 bb.unsafeGetBase(),
-                offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
     static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.compareAndExchange$RawType$(
                                   bb.unsafeGetBase(),
-                                  offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
     }
 
     @ForceInline
     static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.compareAndExchange$RawType$Acquire(
                                   bb.unsafeGetBase(),
-                                  offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
     }
 
     @ForceInline
     static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.compareAndExchange$RawType$Release(
                                   bb.unsafeGetBase(),
-                                  offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
     }
 
     @ForceInline
     static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$Plain(
                 bb.unsafeGetBase(),
-                offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
     static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$(
                 bb.unsafeGetBase(),
-                offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
     static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$Acquire(
                 bb.unsafeGetBase(),
-                offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
     static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return UNSAFE.weakCompareAndSet$RawType$Release(
                 bb.unsafeGetBase(),
-                offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                 convEndian(handle.be, expected), convEndian(handle.be, value));
     }
 
     @ForceInline
     static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.getAndSet$RawType$(
                                   bb.unsafeGetBase(),
-                                  offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, value)));
     }
 
     @ForceInline
     static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.getAndSet$RawType$Acquire(
                                   bb.unsafeGetBase(),
-                                  offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, value)));
     }
 
     @ForceInline
     static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         return convEndian(handle.be,
                           UNSAFE.getAndSet$RawType$Release(
                                   bb.unsafeGetBase(),
-                                  offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                                   convEndian(handle.be, value)));
     }
 #end[CAS]
 #if[AtomicAdd]
 
@@ -343,42 +343,42 @@
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndAdd$RawType$(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     delta);
         } else {
-            return getAndAddConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), delta);
+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);
         }
     }
 
     @ForceInline
     static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndAdd$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     delta);
         } else {
-            return getAndAddConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), delta);
+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);
         }
     }
 
     @ForceInline
     static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndAdd$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     delta);
         } else {
-            return getAndAddConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), delta);
+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);
         }
     }
 
     @ForceInline
     static $type$ getAndAddConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ delta) {
@@ -399,42 +399,42 @@
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseOr$RawType$(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
     static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseOr$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
     static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseOr$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);
+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
     static $type$ getAndBitwiseOrConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
@@ -453,42 +453,42 @@
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseAnd$RawType$(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
     static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseAnd$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
     static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);
+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
     static $type$ getAndBitwiseAndConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
@@ -508,42 +508,42 @@
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseXor$RawType$(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
     static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseXor$RawType$Release(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
     static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {
         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
         if (handle.be == BE) {
             return UNSAFE.getAndBitwiseXor$RawType$Acquire(
                     bb.unsafeGetBase(),
-                    offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),
+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),
                     value);
         } else {
-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);
+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);
         }
     }
 
     @ForceInline
     static $type$ getAndBitwiseXorConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {

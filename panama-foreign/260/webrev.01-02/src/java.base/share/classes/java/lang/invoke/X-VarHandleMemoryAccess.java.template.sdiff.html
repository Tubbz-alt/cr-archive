<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="VarHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaLangInvokeAccess.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAccess.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  */
 25 package java.lang.invoke;
 26 
 27 import jdk.internal.access.foreign.MemorySegmentProxy;
 28 import jdk.internal.vm.annotation.ForceInline;
 29 
 30 import java.util.Objects;
 31 
 32 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 33 
 34 #warn
 35 
 36 final class MemoryAccessVarHandle$Type$Helper extends MemoryAccessVarHandleBase {
 37 
 38     static final boolean BE = UNSAFE.isBigEndian();
 39 
 40     static final int VM_ALIGN = $BoxType$.BYTES - 1;
 41 
 42     static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegmentProxy.class, $type$.class, long.class);
 43 
<span class="line-modified"> 44     MemoryAccessVarHandle$Type$Helper(boolean skipOffetCheck, boolean be, long length, long alignmentMask) {</span>
<span class="line-modified"> 45         super(FORM, skipOffetCheck, be, length, alignmentMask);</span>
 46     }
 47 
 48     @Override
 49     final MethodType accessModeTypeUncached(AccessMode accessMode) {
 50         return accessMode.at.accessModeType(MemorySegmentProxy.class, $type$.class, long.class);
 51     }
 52 
 53 #if[floatingPoint]
 54     @ForceInline
 55     static $rawType$ convEndian(boolean big, $type$ v) {
 56         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
 57         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 58     }
 59 
 60     @ForceInline
 61     static $type$ convEndian(boolean big, $rawType$ rv) {
 62         rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 63         return $Type$.$rawType$BitsTo$Type$(rv);
 64     }
 65 #else[floatingPoint]
</pre>
<hr />
<pre>
 67     @ForceInline
 68     static $type$ convEndian(boolean big, $type$ n) {
 69         return n;
 70     }
 71 #else[byte]
 72     @ForceInline
 73     static $type$ convEndian(boolean big, $type$ n) {
 74         return big == BE ? n : $BoxType$.reverseBytes(n);
 75     }
 76 #end[byte]
 77 #end[floatingPoint]
 78 
 79     @ForceInline
 80     static MemorySegmentProxy checkAddress(Object obb, long offset, long length, boolean ro) {
 81         MemorySegmentProxy oo = (MemorySegmentProxy)Objects.requireNonNull(obb);
 82         oo.checkAccess(offset, length, ro);
 83         return oo;
 84     }
 85 
 86     @ForceInline
<span class="line-modified"> 87     static long offset(boolean skipOffsetCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {</span>
<span class="line-modified"> 88         long address = offsetNoVMAlignCheck(skipOffsetCheck, bb, offset, alignmentMask);</span>
 89         if ((address &amp; VM_ALIGN) != 0) {
 90             throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
 91         }
 92         return address;
 93     }
 94 
 95     @ForceInline
<span class="line-modified"> 96     static long offsetNoVMAlignCheck(boolean skipOffsetCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {</span>
 97         long base = bb.unsafeGetOffset();
 98         long address = base + offset;
<span class="line-modified"> 99         if (skipOffsetCheck) {</span>
100             //note: the offset portion has already been aligned-checked, by construction
101             if ((base &amp; alignmentMask) != 0) {
102                 throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
103             }
104         } else {
105             if ((address &amp; alignmentMask) != 0) {
106                 throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
107             }
108         }
109         return address;
110     }
111 
112     @ForceInline
113     static $type$ get(VarHandle ob, Object obb, long base) {
114         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
115         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
116 #if[floatingPoint]
117         $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
118                 bb.unsafeGetBase(),
<span class="line-modified">119                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
120                 handle.be);
121         return $Type$.$rawType$BitsTo$Type$(rawValue);
122 #else[floatingPoint]
123 #if[byte]
124         return UNSAFE.get$Type$(
125                 bb.unsafeGetBase(),
<span class="line-modified">126                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask));</span>
127 #else[byte]
128         return UNSAFE.get$Type$Unaligned(
129                 bb.unsafeGetBase(),
<span class="line-modified">130                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
131                 handle.be);
132 #end[byte]
133 #end[floatingPoint]
134     }
135 
136     @ForceInline
137     static void set(VarHandle ob, Object obb, long base, $type$ value) {
138         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
139         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
140 #if[floatingPoint]
141         UNSAFE.put$RawType$Unaligned(
142                 bb.unsafeGetBase(),
<span class="line-modified">143                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
144                 $Type$.$type$ToRaw$RawType$Bits(value),
145                 handle.be);
146 #else[floatingPoint]
147 #if[byte]
148         UNSAFE.put$Type$(
149                 bb.unsafeGetBase(),
<span class="line-modified">150                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
151                 value);
152 #else[byte]
153         UNSAFE.put$Type$Unaligned(
154                 bb.unsafeGetBase(),
<span class="line-modified">155                 offsetNoVMAlignCheck(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
156                 value,
157                 handle.be);
158 #end[byte]
159 #end[floatingPoint]
160     }
161 
162     @ForceInline
163     static $type$ getVolatile(VarHandle ob, Object obb, long base) {
164         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
165         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
166         return convEndian(handle.be,
167                           UNSAFE.get$RawType$Volatile(
168                                   bb.unsafeGetBase(),
<span class="line-modified">169                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask)));</span>
170     }
171 
172     @ForceInline
173     static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {
174         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
175         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
176         UNSAFE.put$RawType$Volatile(
177                 bb.unsafeGetBase(),
<span class="line-modified">178                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
179                 convEndian(handle.be, value));
180     }
181 
182     @ForceInline
183     static $type$ getAcquire(VarHandle ob, Object obb, long base) {
184         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
185         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
186         return convEndian(handle.be,
187                           UNSAFE.get$RawType$Acquire(
188                                   bb.unsafeGetBase(),
<span class="line-modified">189                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask)));</span>
190     }
191 
192     @ForceInline
193     static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {
194         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
195         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
196         UNSAFE.put$RawType$Release(
197                 bb.unsafeGetBase(),
<span class="line-modified">198                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
199                 convEndian(handle.be, value));
200     }
201 
202     @ForceInline
203     static $type$ getOpaque(VarHandle ob, Object obb, long base) {
204         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
205         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
206         return convEndian(handle.be,
207                           UNSAFE.get$RawType$Opaque(
208                                   bb.unsafeGetBase(),
<span class="line-modified">209                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask)));</span>
210     }
211 
212     @ForceInline
213     static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {
214         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
215         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
216         UNSAFE.put$RawType$Opaque(
217                 bb.unsafeGetBase(),
<span class="line-modified">218                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
219                 convEndian(handle.be, value));
220     }
221 #if[CAS]
222 
223     @ForceInline
224     static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
225         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
226         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
227         return UNSAFE.compareAndSet$RawType$(
228                 bb.unsafeGetBase(),
<span class="line-modified">229                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
230                 convEndian(handle.be, expected), convEndian(handle.be, value));
231     }
232 
233     @ForceInline
234     static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
235         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
236         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
237         return convEndian(handle.be,
238                           UNSAFE.compareAndExchange$RawType$(
239                                   bb.unsafeGetBase(),
<span class="line-modified">240                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
241                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
242     }
243 
244     @ForceInline
245     static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
246         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
247         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
248         return convEndian(handle.be,
249                           UNSAFE.compareAndExchange$RawType$Acquire(
250                                   bb.unsafeGetBase(),
<span class="line-modified">251                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
252                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
253     }
254 
255     @ForceInline
256     static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
257         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
258         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
259         return convEndian(handle.be,
260                           UNSAFE.compareAndExchange$RawType$Release(
261                                   bb.unsafeGetBase(),
<span class="line-modified">262                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
263                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
264     }
265 
266     @ForceInline
267     static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
268         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
269         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
270         return UNSAFE.weakCompareAndSet$RawType$Plain(
271                 bb.unsafeGetBase(),
<span class="line-modified">272                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
273                 convEndian(handle.be, expected), convEndian(handle.be, value));
274     }
275 
276     @ForceInline
277     static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
278         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
279         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
280         return UNSAFE.weakCompareAndSet$RawType$(
281                 bb.unsafeGetBase(),
<span class="line-modified">282                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
283                 convEndian(handle.be, expected), convEndian(handle.be, value));
284     }
285 
286     @ForceInline
287     static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
288         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
289         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
290         return UNSAFE.weakCompareAndSet$RawType$Acquire(
291                 bb.unsafeGetBase(),
<span class="line-modified">292                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
293                 convEndian(handle.be, expected), convEndian(handle.be, value));
294     }
295 
296     @ForceInline
297     static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
298         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
299         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
300         return UNSAFE.weakCompareAndSet$RawType$Release(
301                 bb.unsafeGetBase(),
<span class="line-modified">302                 offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
303                 convEndian(handle.be, expected), convEndian(handle.be, value));
304     }
305 
306     @ForceInline
307     static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {
308         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
309         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
310         return convEndian(handle.be,
311                           UNSAFE.getAndSet$RawType$(
312                                   bb.unsafeGetBase(),
<span class="line-modified">313                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
314                                   convEndian(handle.be, value)));
315     }
316 
317     @ForceInline
318     static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {
319         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
320         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
321         return convEndian(handle.be,
322                           UNSAFE.getAndSet$RawType$Acquire(
323                                   bb.unsafeGetBase(),
<span class="line-modified">324                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
325                                   convEndian(handle.be, value)));
326     }
327 
328     @ForceInline
329     static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {
330         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
331         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
332         return convEndian(handle.be,
333                           UNSAFE.getAndSet$RawType$Release(
334                                   bb.unsafeGetBase(),
<span class="line-modified">335                                   offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
336                                   convEndian(handle.be, value)));
337     }
338 #end[CAS]
339 #if[AtomicAdd]
340 
341     @ForceInline
342     static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {
343         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
344         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
345         if (handle.be == BE) {
346             return UNSAFE.getAndAdd$RawType$(
347                     bb.unsafeGetBase(),
<span class="line-modified">348                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
349                     delta);
350         } else {
<span class="line-modified">351             return getAndAddConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), delta);</span>
352         }
353     }
354 
355     @ForceInline
356     static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {
357         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
358         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
359         if (handle.be == BE) {
360             return UNSAFE.getAndAdd$RawType$Acquire(
361                     bb.unsafeGetBase(),
<span class="line-modified">362                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
363                     delta);
364         } else {
<span class="line-modified">365             return getAndAddConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), delta);</span>
366         }
367     }
368 
369     @ForceInline
370     static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {
371         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
372         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
373         if (handle.be == BE) {
374             return UNSAFE.getAndAdd$RawType$Release(
375                     bb.unsafeGetBase(),
<span class="line-modified">376                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
377                     delta);
378         } else {
<span class="line-modified">379             return getAndAddConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), delta);</span>
380         }
381     }
382 
383     @ForceInline
384     static $type$ getAndAddConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ delta) {
385         $type$ nativeExpectedValue, expectedValue;
386         Object base = bb.unsafeGetBase();
387         do {
388             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
389             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
390         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
391                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
392         return expectedValue;
393     }
394 #end[AtomicAdd]
395 #if[Bitwise]
396 
397     @ForceInline
398     static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {
399         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
400         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
401         if (handle.be == BE) {
402             return UNSAFE.getAndBitwiseOr$RawType$(
403                     bb.unsafeGetBase(),
<span class="line-modified">404                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
405                     value);
406         } else {
<span class="line-modified">407             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
408         }
409     }
410 
411     @ForceInline
412     static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {
413         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
414         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
415         if (handle.be == BE) {
416             return UNSAFE.getAndBitwiseOr$RawType$Release(
417                     bb.unsafeGetBase(),
<span class="line-modified">418                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
419                     value);
420         } else {
<span class="line-modified">421             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
422         }
423     }
424 
425     @ForceInline
426     static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {
427         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
428         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
429         if (handle.be == BE) {
430             return UNSAFE.getAndBitwiseOr$RawType$Acquire(
431                     bb.unsafeGetBase(),
<span class="line-modified">432                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
433                     value);
434         } else {
<span class="line-modified">435             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
436         }
437     }
438 
439     @ForceInline
440     static $type$ getAndBitwiseOrConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
441         $type$ nativeExpectedValue, expectedValue;
442         Object base = bb.unsafeGetBase();
443         do {
444             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
445             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
446         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
447                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
448         return expectedValue;
449     }
450 
451     @ForceInline
452     static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {
453         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
454         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
455         if (handle.be == BE) {
456             return UNSAFE.getAndBitwiseAnd$RawType$(
457                     bb.unsafeGetBase(),
<span class="line-modified">458                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
459                     value);
460         } else {
<span class="line-modified">461             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
462         }
463     }
464 
465     @ForceInline
466     static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {
467         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
468         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
469         if (handle.be == BE) {
470             return UNSAFE.getAndBitwiseAnd$RawType$Release(
471                     bb.unsafeGetBase(),
<span class="line-modified">472                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
473                     value);
474         } else {
<span class="line-modified">475             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
476         }
477     }
478 
479     @ForceInline
480     static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {
481         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
482         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
483         if (handle.be == BE) {
484             return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
485                     bb.unsafeGetBase(),
<span class="line-modified">486                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
487                     value);
488         } else {
<span class="line-modified">489             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
490         }
491     }
492 
493     @ForceInline
494     static $type$ getAndBitwiseAndConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
495         $type$ nativeExpectedValue, expectedValue;
496         Object base = bb.unsafeGetBase();
497         do {
498             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
499             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
500         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
501                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
502         return expectedValue;
503     }
504 
505 
506     @ForceInline
507     static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {
508         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
509         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
510         if (handle.be == BE) {
511             return UNSAFE.getAndBitwiseXor$RawType$(
512                     bb.unsafeGetBase(),
<span class="line-modified">513                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
514                     value);
515         } else {
<span class="line-modified">516             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
517         }
518     }
519 
520     @ForceInline
521     static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {
522         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
523         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
524         if (handle.be == BE) {
525             return UNSAFE.getAndBitwiseXor$RawType$Release(
526                     bb.unsafeGetBase(),
<span class="line-modified">527                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
528                     value);
529         } else {
<span class="line-modified">530             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
531         }
532     }
533 
534     @ForceInline
535     static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {
536         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
537         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
538         if (handle.be == BE) {
539             return UNSAFE.getAndBitwiseXor$RawType$Acquire(
540                     bb.unsafeGetBase(),
<span class="line-modified">541                     offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask),</span>
542                     value);
543         } else {
<span class="line-modified">544             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipOffsetCheck, bb, base, handle.alignmentMask), value);</span>
545         }
546     }
547 
548     @ForceInline
549     static $type$ getAndBitwiseXorConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
550         $type$ nativeExpectedValue, expectedValue;
551         Object base = bb.unsafeGetBase();
552         do {
553             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
554             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
555         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
556                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
557         return expectedValue;
558     }
559 #end[Bitwise]
560 }
</pre>
</td>
<td>
<hr />
<pre>
 24  */
 25 package java.lang.invoke;
 26 
 27 import jdk.internal.access.foreign.MemorySegmentProxy;
 28 import jdk.internal.vm.annotation.ForceInline;
 29 
 30 import java.util.Objects;
 31 
 32 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 33 
 34 #warn
 35 
 36 final class MemoryAccessVarHandle$Type$Helper extends MemoryAccessVarHandleBase {
 37 
 38     static final boolean BE = UNSAFE.isBigEndian();
 39 
 40     static final int VM_ALIGN = $BoxType$.BYTES - 1;
 41 
 42     static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegmentProxy.class, $type$.class, long.class);
 43 
<span class="line-modified"> 44     MemoryAccessVarHandle$Type$Helper(boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask) {</span>
<span class="line-modified"> 45         super(FORM, skipAlignmentMaskCheck, be, length, alignmentMask);</span>
 46     }
 47 
 48     @Override
 49     final MethodType accessModeTypeUncached(AccessMode accessMode) {
 50         return accessMode.at.accessModeType(MemorySegmentProxy.class, $type$.class, long.class);
 51     }
 52 
 53 #if[floatingPoint]
 54     @ForceInline
 55     static $rawType$ convEndian(boolean big, $type$ v) {
 56         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
 57         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 58     }
 59 
 60     @ForceInline
 61     static $type$ convEndian(boolean big, $rawType$ rv) {
 62         rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 63         return $Type$.$rawType$BitsTo$Type$(rv);
 64     }
 65 #else[floatingPoint]
</pre>
<hr />
<pre>
 67     @ForceInline
 68     static $type$ convEndian(boolean big, $type$ n) {
 69         return n;
 70     }
 71 #else[byte]
 72     @ForceInline
 73     static $type$ convEndian(boolean big, $type$ n) {
 74         return big == BE ? n : $BoxType$.reverseBytes(n);
 75     }
 76 #end[byte]
 77 #end[floatingPoint]
 78 
 79     @ForceInline
 80     static MemorySegmentProxy checkAddress(Object obb, long offset, long length, boolean ro) {
 81         MemorySegmentProxy oo = (MemorySegmentProxy)Objects.requireNonNull(obb);
 82         oo.checkAccess(offset, length, ro);
 83         return oo;
 84     }
 85 
 86     @ForceInline
<span class="line-modified"> 87     static long offset(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {</span>
<span class="line-modified"> 88         long address = offsetNoVMAlignCheck(skipAlignmentMaskCheck, bb, offset, alignmentMask);</span>
 89         if ((address &amp; VM_ALIGN) != 0) {
 90             throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
 91         }
 92         return address;
 93     }
 94 
 95     @ForceInline
<span class="line-modified"> 96     static long offsetNoVMAlignCheck(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {</span>
 97         long base = bb.unsafeGetOffset();
 98         long address = base + offset;
<span class="line-modified"> 99         if (skipAlignmentMaskCheck) {</span>
100             //note: the offset portion has already been aligned-checked, by construction
101             if ((base &amp; alignmentMask) != 0) {
102                 throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
103             }
104         } else {
105             if ((address &amp; alignmentMask) != 0) {
106                 throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);
107             }
108         }
109         return address;
110     }
111 
112     @ForceInline
113     static $type$ get(VarHandle ob, Object obb, long base) {
114         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
115         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
116 #if[floatingPoint]
117         $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
118                 bb.unsafeGetBase(),
<span class="line-modified">119                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
120                 handle.be);
121         return $Type$.$rawType$BitsTo$Type$(rawValue);
122 #else[floatingPoint]
123 #if[byte]
124         return UNSAFE.get$Type$(
125                 bb.unsafeGetBase(),
<span class="line-modified">126                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask));</span>
127 #else[byte]
128         return UNSAFE.get$Type$Unaligned(
129                 bb.unsafeGetBase(),
<span class="line-modified">130                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
131                 handle.be);
132 #end[byte]
133 #end[floatingPoint]
134     }
135 
136     @ForceInline
137     static void set(VarHandle ob, Object obb, long base, $type$ value) {
138         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
139         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
140 #if[floatingPoint]
141         UNSAFE.put$RawType$Unaligned(
142                 bb.unsafeGetBase(),
<span class="line-modified">143                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
144                 $Type$.$type$ToRaw$RawType$Bits(value),
145                 handle.be);
146 #else[floatingPoint]
147 #if[byte]
148         UNSAFE.put$Type$(
149                 bb.unsafeGetBase(),
<span class="line-modified">150                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
151                 value);
152 #else[byte]
153         UNSAFE.put$Type$Unaligned(
154                 bb.unsafeGetBase(),
<span class="line-modified">155                 offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
156                 value,
157                 handle.be);
158 #end[byte]
159 #end[floatingPoint]
160     }
161 
162     @ForceInline
163     static $type$ getVolatile(VarHandle ob, Object obb, long base) {
164         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
165         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
166         return convEndian(handle.be,
167                           UNSAFE.get$RawType$Volatile(
168                                   bb.unsafeGetBase(),
<span class="line-modified">169                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));</span>
170     }
171 
172     @ForceInline
173     static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {
174         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
175         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
176         UNSAFE.put$RawType$Volatile(
177                 bb.unsafeGetBase(),
<span class="line-modified">178                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
179                 convEndian(handle.be, value));
180     }
181 
182     @ForceInline
183     static $type$ getAcquire(VarHandle ob, Object obb, long base) {
184         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
185         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
186         return convEndian(handle.be,
187                           UNSAFE.get$RawType$Acquire(
188                                   bb.unsafeGetBase(),
<span class="line-modified">189                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));</span>
190     }
191 
192     @ForceInline
193     static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {
194         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
195         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
196         UNSAFE.put$RawType$Release(
197                 bb.unsafeGetBase(),
<span class="line-modified">198                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
199                 convEndian(handle.be, value));
200     }
201 
202     @ForceInline
203     static $type$ getOpaque(VarHandle ob, Object obb, long base) {
204         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
205         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);
206         return convEndian(handle.be,
207                           UNSAFE.get$RawType$Opaque(
208                                   bb.unsafeGetBase(),
<span class="line-modified">209                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));</span>
210     }
211 
212     @ForceInline
213     static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {
214         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
215         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
216         UNSAFE.put$RawType$Opaque(
217                 bb.unsafeGetBase(),
<span class="line-modified">218                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
219                 convEndian(handle.be, value));
220     }
221 #if[CAS]
222 
223     @ForceInline
224     static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
225         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
226         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
227         return UNSAFE.compareAndSet$RawType$(
228                 bb.unsafeGetBase(),
<span class="line-modified">229                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
230                 convEndian(handle.be, expected), convEndian(handle.be, value));
231     }
232 
233     @ForceInline
234     static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
235         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
236         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
237         return convEndian(handle.be,
238                           UNSAFE.compareAndExchange$RawType$(
239                                   bb.unsafeGetBase(),
<span class="line-modified">240                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
241                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
242     }
243 
244     @ForceInline
245     static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
246         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
247         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
248         return convEndian(handle.be,
249                           UNSAFE.compareAndExchange$RawType$Acquire(
250                                   bb.unsafeGetBase(),
<span class="line-modified">251                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
252                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
253     }
254 
255     @ForceInline
256     static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
257         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
258         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
259         return convEndian(handle.be,
260                           UNSAFE.compareAndExchange$RawType$Release(
261                                   bb.unsafeGetBase(),
<span class="line-modified">262                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
263                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
264     }
265 
266     @ForceInline
267     static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
268         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
269         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
270         return UNSAFE.weakCompareAndSet$RawType$Plain(
271                 bb.unsafeGetBase(),
<span class="line-modified">272                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
273                 convEndian(handle.be, expected), convEndian(handle.be, value));
274     }
275 
276     @ForceInline
277     static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
278         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
279         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
280         return UNSAFE.weakCompareAndSet$RawType$(
281                 bb.unsafeGetBase(),
<span class="line-modified">282                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
283                 convEndian(handle.be, expected), convEndian(handle.be, value));
284     }
285 
286     @ForceInline
287     static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
288         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
289         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
290         return UNSAFE.weakCompareAndSet$RawType$Acquire(
291                 bb.unsafeGetBase(),
<span class="line-modified">292                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
293                 convEndian(handle.be, expected), convEndian(handle.be, value));
294     }
295 
296     @ForceInline
297     static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {
298         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
299         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
300         return UNSAFE.weakCompareAndSet$RawType$Release(
301                 bb.unsafeGetBase(),
<span class="line-modified">302                 offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
303                 convEndian(handle.be, expected), convEndian(handle.be, value));
304     }
305 
306     @ForceInline
307     static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {
308         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
309         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
310         return convEndian(handle.be,
311                           UNSAFE.getAndSet$RawType$(
312                                   bb.unsafeGetBase(),
<span class="line-modified">313                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
314                                   convEndian(handle.be, value)));
315     }
316 
317     @ForceInline
318     static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {
319         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
320         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
321         return convEndian(handle.be,
322                           UNSAFE.getAndSet$RawType$Acquire(
323                                   bb.unsafeGetBase(),
<span class="line-modified">324                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
325                                   convEndian(handle.be, value)));
326     }
327 
328     @ForceInline
329     static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {
330         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
331         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
332         return convEndian(handle.be,
333                           UNSAFE.getAndSet$RawType$Release(
334                                   bb.unsafeGetBase(),
<span class="line-modified">335                                   offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
336                                   convEndian(handle.be, value)));
337     }
338 #end[CAS]
339 #if[AtomicAdd]
340 
341     @ForceInline
342     static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {
343         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
344         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
345         if (handle.be == BE) {
346             return UNSAFE.getAndAdd$RawType$(
347                     bb.unsafeGetBase(),
<span class="line-modified">348                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
349                     delta);
350         } else {
<span class="line-modified">351             return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);</span>
352         }
353     }
354 
355     @ForceInline
356     static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {
357         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
358         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
359         if (handle.be == BE) {
360             return UNSAFE.getAndAdd$RawType$Acquire(
361                     bb.unsafeGetBase(),
<span class="line-modified">362                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
363                     delta);
364         } else {
<span class="line-modified">365             return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);</span>
366         }
367     }
368 
369     @ForceInline
370     static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {
371         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
372         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
373         if (handle.be == BE) {
374             return UNSAFE.getAndAdd$RawType$Release(
375                     bb.unsafeGetBase(),
<span class="line-modified">376                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
377                     delta);
378         } else {
<span class="line-modified">379             return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);</span>
380         }
381     }
382 
383     @ForceInline
384     static $type$ getAndAddConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ delta) {
385         $type$ nativeExpectedValue, expectedValue;
386         Object base = bb.unsafeGetBase();
387         do {
388             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
389             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
390         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
391                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
392         return expectedValue;
393     }
394 #end[AtomicAdd]
395 #if[Bitwise]
396 
397     @ForceInline
398     static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {
399         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
400         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
401         if (handle.be == BE) {
402             return UNSAFE.getAndBitwiseOr$RawType$(
403                     bb.unsafeGetBase(),
<span class="line-modified">404                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
405                     value);
406         } else {
<span class="line-modified">407             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
408         }
409     }
410 
411     @ForceInline
412     static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {
413         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
414         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
415         if (handle.be == BE) {
416             return UNSAFE.getAndBitwiseOr$RawType$Release(
417                     bb.unsafeGetBase(),
<span class="line-modified">418                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
419                     value);
420         } else {
<span class="line-modified">421             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
422         }
423     }
424 
425     @ForceInline
426     static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {
427         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
428         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
429         if (handle.be == BE) {
430             return UNSAFE.getAndBitwiseOr$RawType$Acquire(
431                     bb.unsafeGetBase(),
<span class="line-modified">432                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
433                     value);
434         } else {
<span class="line-modified">435             return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
436         }
437     }
438 
439     @ForceInline
440     static $type$ getAndBitwiseOrConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
441         $type$ nativeExpectedValue, expectedValue;
442         Object base = bb.unsafeGetBase();
443         do {
444             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
445             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
446         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
447                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
448         return expectedValue;
449     }
450 
451     @ForceInline
452     static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {
453         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
454         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
455         if (handle.be == BE) {
456             return UNSAFE.getAndBitwiseAnd$RawType$(
457                     bb.unsafeGetBase(),
<span class="line-modified">458                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
459                     value);
460         } else {
<span class="line-modified">461             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
462         }
463     }
464 
465     @ForceInline
466     static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {
467         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
468         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
469         if (handle.be == BE) {
470             return UNSAFE.getAndBitwiseAnd$RawType$Release(
471                     bb.unsafeGetBase(),
<span class="line-modified">472                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
473                     value);
474         } else {
<span class="line-modified">475             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
476         }
477     }
478 
479     @ForceInline
480     static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {
481         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
482         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
483         if (handle.be == BE) {
484             return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
485                     bb.unsafeGetBase(),
<span class="line-modified">486                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
487                     value);
488         } else {
<span class="line-modified">489             return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
490         }
491     }
492 
493     @ForceInline
494     static $type$ getAndBitwiseAndConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
495         $type$ nativeExpectedValue, expectedValue;
496         Object base = bb.unsafeGetBase();
497         do {
498             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
499             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
500         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
501                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
502         return expectedValue;
503     }
504 
505 
506     @ForceInline
507     static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {
508         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
509         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
510         if (handle.be == BE) {
511             return UNSAFE.getAndBitwiseXor$RawType$(
512                     bb.unsafeGetBase(),
<span class="line-modified">513                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
514                     value);
515         } else {
<span class="line-modified">516             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
517         }
518     }
519 
520     @ForceInline
521     static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {
522         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
523         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
524         if (handle.be == BE) {
525             return UNSAFE.getAndBitwiseXor$RawType$Release(
526                     bb.unsafeGetBase(),
<span class="line-modified">527                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
528                     value);
529         } else {
<span class="line-modified">530             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
531         }
532     }
533 
534     @ForceInline
535     static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {
536         MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;
537         MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);
538         if (handle.be == BE) {
539             return UNSAFE.getAndBitwiseXor$RawType$Acquire(
540                     bb.unsafeGetBase(),
<span class="line-modified">541                     offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),</span>
542                     value);
543         } else {
<span class="line-modified">544             return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);</span>
545         }
546     }
547 
548     @ForceInline
549     static $type$ getAndBitwiseXorConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {
550         $type$ nativeExpectedValue, expectedValue;
551         Object base = bb.unsafeGetBase();
552         do {
553             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
554             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
555         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
556                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
557         return expectedValue;
558     }
559 #end[Bitwise]
560 }
</pre>
</td>
</tr>
</table>
<center><a href="VarHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaLangInvokeAccess.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
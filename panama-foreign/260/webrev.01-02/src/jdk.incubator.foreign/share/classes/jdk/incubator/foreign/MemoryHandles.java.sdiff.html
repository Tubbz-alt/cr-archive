<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryAddress.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.foreign.Utils;
 31 import sun.invoke.util.Wrapper;
 32 
 33 import java.lang.invoke.MethodHandle;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.invoke.MethodType;
 36 import java.lang.invoke.VarHandle;
 37 import java.nio.ByteOrder;
 38 import java.util.List;
 39 import java.util.Objects;
 40 
 41 /**
 42  * This class defines several factory methods for constructing and combining memory access var handles.
 43  * To obtain a memory access var handle, clients must start from one of the &lt;em&gt;leaf&lt;/em&gt; methods
 44  * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},
 45  * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type
 46  * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the
 47  * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways
 48  * to emulate different addressing modes. The var handles created by this class feature a &lt;em&gt;mandatory&lt;/em&gt; coordinate type
<span class="line-modified"> 49  * (of type {@link MemorySegment}), and one {@code long} coordinate types, which represents the offset, in bytes, relative</span>
 50  * to the segment, at which dereference should occur.
 51  * &lt;p&gt;
 52  * As an example, consider the memory layout expressed by a {@link SequenceLayout} instance constructed as follows:
 53  * &lt;blockquote&gt;&lt;pre&gt;{@code
 54 GroupLayout seq = MemoryLayout.ofStruct(
 55         MemoryLayout.ofPaddingBits(32),
 56         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
 57 ));
 58  * }&lt;/pre&gt;&lt;/blockquote&gt;
 59  * To access the member layout named {@code value}, we can construct a memory access var handle as follows:
 60  * &lt;blockquote&gt;&lt;pre&gt;{@code
 61 VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); //(MemorySegment, long) -&gt; int
 62 handle = MemoryHandles.insertCoordinates(handle, 1, 4); //(MemorySegment) -&gt; int
 63  * }&lt;/pre&gt;&lt;/blockquote&gt;
 64  *
<span class="line-removed"> 65  * where {@code x_1}, {@code x_2}, ... {@code x_n} are &lt;em&gt;dynamic&lt;/em&gt; values provided as optional {@code long}</span>
<span class="line-removed"> 66  * access coordinates, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are</span>
<span class="line-removed"> 67  * &lt;em&gt;static&lt;/em&gt; constants which are can be acquired through the {@link MemoryHandles#withOffset(VarHandle, long)}</span>
<span class="line-removed"> 68  * and the {@link MemoryHandles#withStride(VarHandle, long)} combinators, respectively.</span>
<span class="line-removed"> 69  *</span>
 70  * &lt;h2&gt;&lt;a id=&quot;memaccess-mode&quot;&gt;&lt;/a&gt;Alignment and access modes&lt;/h2&gt;
 71  *
 72  * A memory access var handle is associated with an access size {@code S} and an alignment constraint {@code B}
 73  * (both expressed in bytes). We say that a memory access operation is &lt;em&gt;fully aligned&lt;/em&gt; if it occurs
 74  * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.
 75  * If access is fully aligned then following access modes are supported and are
 76  * guaranteed to support atomic access:
 77  * &lt;ul&gt;
 78  * &lt;li&gt;read write access modes for all {@code T}, with the exception of
 79  *     access modes {@code get} and {@code set} for {@code long} and
 80  *     {@code double} on 32-bit platforms.
 81  * &lt;li&gt;atomic update access modes for {@code int}, {@code long},
 82  *     {@code float} or {@code double}.
 83  *     (Future major platform releases of the JDK may support additional
 84  *     types for certain currently unsupported access modes.)
 85  * &lt;li&gt;numeric atomic update access modes for {@code int} and {@code long}.
 86  *     (Future major platform releases of the JDK may support additional
 87  *     numeric types for certain currently unsupported access modes.)
 88  * &lt;li&gt;bitwise atomic update access modes for {@code int} and {@code long}.
 89  *     (Future major platform releases of the JDK may support additional
</pre>
</td>
<td>
<hr />
<pre>
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.foreign.Utils;
 31 import sun.invoke.util.Wrapper;
 32 
 33 import java.lang.invoke.MethodHandle;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.invoke.MethodType;
 36 import java.lang.invoke.VarHandle;
 37 import java.nio.ByteOrder;
 38 import java.util.List;
 39 import java.util.Objects;
 40 
 41 /**
 42  * This class defines several factory methods for constructing and combining memory access var handles.
 43  * To obtain a memory access var handle, clients must start from one of the &lt;em&gt;leaf&lt;/em&gt; methods
 44  * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},
 45  * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type
 46  * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the
 47  * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways
 48  * to emulate different addressing modes. The var handles created by this class feature a &lt;em&gt;mandatory&lt;/em&gt; coordinate type
<span class="line-modified"> 49  * (of type {@link MemorySegment}), and one {@code long} coordinate type, which represents the offset, in bytes, relative</span>
 50  * to the segment, at which dereference should occur.
 51  * &lt;p&gt;
 52  * As an example, consider the memory layout expressed by a {@link SequenceLayout} instance constructed as follows:
 53  * &lt;blockquote&gt;&lt;pre&gt;{@code
 54 GroupLayout seq = MemoryLayout.ofStruct(
 55         MemoryLayout.ofPaddingBits(32),
 56         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
 57 ));
 58  * }&lt;/pre&gt;&lt;/blockquote&gt;
 59  * To access the member layout named {@code value}, we can construct a memory access var handle as follows:
 60  * &lt;blockquote&gt;&lt;pre&gt;{@code
 61 VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); //(MemorySegment, long) -&gt; int
 62 handle = MemoryHandles.insertCoordinates(handle, 1, 4); //(MemorySegment) -&gt; int
 63  * }&lt;/pre&gt;&lt;/blockquote&gt;
 64  *





 65  * &lt;h2&gt;&lt;a id=&quot;memaccess-mode&quot;&gt;&lt;/a&gt;Alignment and access modes&lt;/h2&gt;
 66  *
 67  * A memory access var handle is associated with an access size {@code S} and an alignment constraint {@code B}
 68  * (both expressed in bytes). We say that a memory access operation is &lt;em&gt;fully aligned&lt;/em&gt; if it occurs
 69  * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.
 70  * If access is fully aligned then following access modes are supported and are
 71  * guaranteed to support atomic access:
 72  * &lt;ul&gt;
 73  * &lt;li&gt;read write access modes for all {@code T}, with the exception of
 74  *     access modes {@code get} and {@code set} for {@code long} and
 75  *     {@code double} on 32-bit platforms.
 76  * &lt;li&gt;atomic update access modes for {@code int}, {@code long},
 77  *     {@code float} or {@code double}.
 78  *     (Future major platform releases of the JDK may support additional
 79  *     types for certain currently unsupported access modes.)
 80  * &lt;li&gt;numeric atomic update access modes for {@code int} and {@code long}.
 81  *     (Future major platform releases of the JDK may support additional
 82  *     numeric types for certain currently unsupported access modes.)
 83  * &lt;li&gt;bitwise atomic update access modes for {@code int} and {@code long}.
 84  *     (Future major platform releases of the JDK may support additional
</pre>
</td>
</tr>
</table>
<center><a href="MemoryAddress.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
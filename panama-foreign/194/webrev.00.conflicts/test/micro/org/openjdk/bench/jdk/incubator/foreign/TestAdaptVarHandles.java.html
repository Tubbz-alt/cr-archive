<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  3  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  4  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  *  This code is free software; you can redistribute it and/or modify it
  7  *  under the terms of the GNU General Public License version 2 only, as
  8  *  published by the Free Software Foundation.
  9  *
 10  *  This code is distributed in the hope that it will be useful, but WITHOUT
 11  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  *  version 2 for more details (a copy is included in the LICENSE file that
 14  *  accompanied this code).
 15  *
 16  *  You should have received a copy of the GNU General Public License version
 17  *  2 along with this work; if not, write to the Free Software Foundation,
 18  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  *  or visit www.oracle.com if you need additional information or have any
 22  *  questions.
 23  *
 24  */
 25 
 26 =======
 27  * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
 28  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 29  *
 30  * This code is free software; you can redistribute it and/or modify it
 31  * under the terms of the GNU General Public License version 2 only, as
 32  * published by the Free Software Foundation.
 33  *
 34  * This code is distributed in the hope that it will be useful, but WITHOUT
 35  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 36  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 37  * version 2 for more details (a copy is included in the LICENSE file that
 38  * accompanied this code).
 39  *
 40  * You should have received a copy of the GNU General Public License version
 41  * 2 along with this work; if not, write to the Free Software Foundation,
 42  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 43  *
 44  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 45  * or visit www.oracle.com if you need additional information or have any
 46  * questions.
 47  */
 48 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 0215250226e7da9e59e1c990f4d5788b964c6b6b
 49 package org.openjdk.bench.jdk.incubator.foreign;
 50 
 51 import jdk.incubator.foreign.MemoryAddress;
 52 import jdk.incubator.foreign.MemoryHandles;
 53 import jdk.incubator.foreign.MemoryLayout;
 54 import jdk.incubator.foreign.MemoryLayouts;
 55 import jdk.incubator.foreign.MemorySegment;
 56 import org.openjdk.jmh.annotations.Benchmark;
 57 import org.openjdk.jmh.annotations.BenchmarkMode;
 58 import org.openjdk.jmh.annotations.Fork;
 59 import org.openjdk.jmh.annotations.Measurement;
 60 import org.openjdk.jmh.annotations.Mode;
 61 import org.openjdk.jmh.annotations.OutputTimeUnit;
 62 import org.openjdk.jmh.annotations.Setup;
 63 import org.openjdk.jmh.annotations.State;
 64 import org.openjdk.jmh.annotations.Warmup;
 65 
 66 import java.lang.invoke.MethodHandle;
 67 import java.lang.invoke.MethodHandles;
 68 import java.lang.invoke.MethodType;
 69 import java.lang.invoke.VarHandle;
 70 import java.util.concurrent.TimeUnit;
 71 
 72 @BenchmarkMode(Mode.AverageTime)
 73 @Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)
 74 @Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)
 75 @State(org.openjdk.jmh.annotations.Scope.Thread)
 76 @OutputTimeUnit(TimeUnit.MILLISECONDS)
 77 @Fork(3)
 78 public class TestAdaptVarHandles {
 79 
 80     static class IntBox {
 81 
 82         private final int value;
 83 
 84         IntBox(int value) {
 85             this.value = value;
 86         }
 87 
 88         int intValue() {
 89             return value;
 90         }
 91     }
 92 
 93     static final int ELEM_SIZE = 1_000_000;
 94 
 95     static final MethodHandle INT_TO_INTBOX;
 96     static final MethodHandle INTBOX_TO_INT;
 97 
 98     static {
 99         try {
100             INT_TO_INTBOX = MethodHandles.lookup()
101                     .findConstructor(IntBox.class, MethodType.methodType(void.class, int.class));
102             INTBOX_TO_INT = MethodHandles.lookup()
103                     .findVirtual(IntBox.class, &quot;intValue&quot;, MethodType.methodType(int.class));
104         } catch (Throwable ex) {
105             throw new ExceptionInInitializerError(ex);
106         }
107     }
108 
109     static final VarHandle VH_int = MethodHandles.arrayElementVarHandle(int[].class);
110 
111     static final VarHandle VH_box_int = MemoryHandles.filterValue(VH_int, INTBOX_TO_INT, INT_TO_INTBOX);
112 
113     static final VarHandle VH_addr_int = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)
114             .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
115 
116     static final VarHandle VH_addr_box_int = MemoryHandles.filterValue(VH_addr_int, INTBOX_TO_INT, INT_TO_INTBOX);
117 
118     static final MethodHandle MH_int = VH_int.toMethodHandle(VarHandle.AccessMode.GET);
119 
120     static final MethodHandle MH_box_int = MethodHandles.filterReturnValue(MH_int, INT_TO_INTBOX);
121 
122     int[] base = new int[ELEM_SIZE];
123     MemorySegment segment = MemorySegment.ofArray(base);
124 
125     @Setup
126     public void setup() {
127         for (int i = 0; i &lt; ELEM_SIZE; i++) {
128             base[i] = i;
129         }
130     }
131 
132     @Benchmark
133     public int vh_loop() throws Throwable {
134         int sum = 0;
135         for (int i = 0; i &lt; ELEM_SIZE; i++) {
136             sum += (int)VH_int.get(base, i);
137         }
138         return sum;
139     }
140 
141     @Benchmark
142     public int vh_box_loop() throws Throwable {
143         int sum = 0;
144         for (int i = 0; i &lt; ELEM_SIZE; i++) {
145             sum += ((IntBox)VH_box_int.get(base, i)).intValue();
146         }
147         return sum;
148     }
149 
150     @Benchmark
151     public int mh_loop() throws Throwable {
152         int sum = 0;
153         for (int i = 0; i &lt; ELEM_SIZE; i++) {
154             sum += (int)MH_int.invokeExact(base, i);
155         }
156         return sum;
157     }
158 
159     @Benchmark
160     public int mh_box_loop() throws Throwable {
161         int sum = 0;
162         for (int i = 0; i &lt; ELEM_SIZE; i++) {
163             sum += ((IntBox)MH_box_int.invokeExact(base, i)).intValue();
164         }
165         return sum;
166     }
167 
168     @Benchmark
169     public int segment_loop() throws Throwable {
170         int sum = 0;
171         MemoryAddress baseAddress = segment.baseAddress();
172         for (int i = 0; i &lt; ELEM_SIZE; i++) {
173             sum += (int)VH_addr_int.get(baseAddress, (long)i);
174         }
175         return sum;
176     }
177 
178     @Benchmark
179     public int segment_box_loop() throws Throwable {
180         int sum = 0;
181         MemoryAddress baseAddress = segment.baseAddress();
182         for (int i = 0; i &lt; ELEM_SIZE; i++) {
183             sum += ((IntBox)VH_addr_box_int.get(baseAddress, (long)i)).intValue();
184         }
185         return sum;
186     }
187 }
    </pre>
  </body>
</html>
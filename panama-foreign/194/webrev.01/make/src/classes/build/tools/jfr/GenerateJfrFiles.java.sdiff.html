<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/src/classes/build/tools/jfr/GenerateJfrFiles.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../jdk/src/classes/build/tools/classlist/HelloClasslist.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../../src/hotspot/cpu/aarch64/aarch64.ad.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/src/classes/build/tools/jfr/GenerateJfrFiles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 package build.tools.jfr;
  2 
  3 import java.io.BufferedOutputStream;
  4 import java.io.File;
  5 import java.io.FileNotFoundException;
  6 import java.io.FileOutputStream;
  7 import java.io.IOException;
  8 import java.io.PrintStream;
  9 import java.util.ArrayList;
<span class="line-removed"> 10 import java.util.HashMap;</span>
 11 import java.util.LinkedHashMap;
 12 import java.util.List;
 13 import java.util.Map;

 14 import java.util.StringJoiner;
 15 import java.util.function.Predicate;
 16 
 17 import javax.xml.XMLConstants;
 18 import javax.xml.parsers.ParserConfigurationException;
 19 import javax.xml.parsers.SAXParser;
 20 import javax.xml.parsers.SAXParserFactory;
 21 import javax.xml.validation.SchemaFactory;
 22 
 23 import org.xml.sax.Attributes;
 24 import org.xml.sax.SAXException;
 25 import org.xml.sax.SAXParseException;
 26 import org.xml.sax.helpers.DefaultHandler;
 27 
 28 public class GenerateJfrFiles {
 29 
 30     public static void main(String... args) throws Exception {
 31         if (args.length != 3) {
 32             System.err.println(&quot;Incorrect number of command line arguments.&quot;);
 33             System.err.println(&quot;Usage:&quot;);
 34             System.err.println(&quot;java GenerateJfrFiles[.java] &lt;path-to-metadata.xml&gt; &lt;path-to-metadata.xsd&gt; &lt;output-directory&gt;&quot;);
 35             System.exit(1);
 36         }
 37         try {
 38             File metadataXml = new File(args[0]);
 39             File metadataSchema = new File(args[1]);
 40             File outputDirectory = new File(args[2]);
 41 
 42             Metadata metadata = new Metadata(metadataXml, metadataSchema);
 43             metadata.verify();
 44             metadata.wireUpTypes();
 45 



 46             printJfrPeriodicHpp(metadata, outputDirectory);
<span class="line-modified"> 47             printJfrEventIdsHpp(metadata, outputDirectory);</span>
<span class="line-removed"> 48             printJfrEventControlHpp(metadata, outputDirectory);</span>
<span class="line-removed"> 49             printJfrTypesHpp(metadata, outputDirectory);</span>
 50             printJfrEventClassesHpp(metadata, outputDirectory);
 51 
 52         } catch (Exception e) {
 53             e.printStackTrace();
 54             System.exit(1);
 55         }
 56     }
 57 



























































 58     static class XmlType {

 59         final String fieldType;
 60         final String parameterType;
<span class="line-modified"> 61         XmlType(String fieldType, String parameterType) {</span>




 62             this.fieldType = fieldType;
 63             this.parameterType = parameterType;


 64         }
 65     }
 66 
 67     static class TypeElement {
 68         List&lt;FieldElement&gt; fields = new ArrayList&lt;&gt;();
 69         String name;
 70         String fieldType;
 71         String parameterType;
 72         boolean supportStruct;
 73     }
 74 
 75     static class Metadata {
 76         final Map&lt;String, TypeElement&gt; types = new LinkedHashMap&lt;&gt;();
<span class="line-modified"> 77         final Map&lt;String, XmlType&gt; xmlTypes = new HashMap&lt;&gt;();</span>
 78         Metadata(File metadataXml, File metadataSchema) throws ParserConfigurationException, SAXException, FileNotFoundException, IOException {
 79             SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
 80             SAXParserFactory factory = SAXParserFactory.newInstance();
 81             factory.setSchema(schemaFactory.newSchema(metadataSchema));
 82             SAXParser sp = factory.newSAXParser();
 83             sp.parse(metadataXml, new MetadataHandler(this));
 84         }
 85 
 86         List&lt;EventElement&gt; getEvents() {
 87             return getList(t -&gt; t.getClass() == EventElement.class);
 88         }
 89 
 90         List&lt;TypeElement&gt; getEventsAndStructs() {
 91             return getList(t -&gt; t.getClass() == EventElement.class || t.supportStruct);
 92         }
 93 
 94         List&lt;TypeElement&gt; getTypesAndStructs() {
 95             return getList(t -&gt; t.getClass() == TypeElement.class || t.supportStruct);
 96         }
 97 
 98         @SuppressWarnings(&quot;unchecked&quot;)
 99         &lt;T&gt; List&lt;T&gt; getList(Predicate&lt;? super TypeElement&gt; pred) {
100             List&lt;T&gt; result = new ArrayList&lt;&gt;(types.size());
101             for (TypeElement t : types.values()) {
102                 if (pred.test(t)) {
103                     result.add((T) t);
104                 }
105             }
106             return result;
107         }
108 
109         List&lt;EventElement&gt; getPeriodicEvents() {
110             return getList(t -&gt; t.getClass() == EventElement.class &amp;&amp; ((EventElement) t).periodic);
111         }
112 
<span class="line-removed">113         List&lt;TypeElement&gt; getNonEventsAndNonStructs() {</span>
<span class="line-removed">114             return getList(t -&gt; t.getClass() != EventElement.class &amp;&amp; !t.supportStruct);</span>
<span class="line-removed">115         }</span>
<span class="line-removed">116 </span>
117         List&lt;TypeElement&gt; getTypes() {
<span class="line-modified">118             return getList(t -&gt; t.getClass() == TypeElement.class &amp;&amp; !t.supportStruct);</span>
119         }
120 
121         List&lt;TypeElement&gt; getStructs() {
122             return getList(t -&gt; t.getClass() == TypeElement.class &amp;&amp; t.supportStruct);
123         }
124 
125         void verify()  {
126             for (TypeElement t : types.values()) {
127                 for (FieldElement f : t.fields) {
128                     if (!xmlTypes.containsKey(f.typeName)) { // ignore primitives
129                         if (!types.containsKey(f.typeName)) {
130                             throw new IllegalStateException(&quot;Could not find definition of type &#39;&quot; + f.typeName + &quot;&#39; used by &quot; + t.name + &quot;#&quot; + f.name);
131                         }
132                     }
133                 }
134             }
135         }
136 
137         void wireUpTypes() {
138             for (TypeElement t : types.values()) {
</pre>
<hr />
<pre>
196     }
197 
198     static class MetadataHandler extends DefaultHandler {
199         final Metadata metadata;
200         FieldElement currentField;
201         TypeElement currentType;
202         MetadataHandler(Metadata metadata) {
203             this.metadata = metadata;
204         }
205         @Override
206         public void error(SAXParseException e) throws SAXException {
207           throw e;
208         }
209         @Override
210         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
211             switch (qName) {
212             case &quot;XmlType&quot;:
213                 String name = attributes.getValue(&quot;name&quot;);
214                 String parameterType = attributes.getValue(&quot;parameterType&quot;);
215                 String fieldType = attributes.getValue(&quot;fieldType&quot;);
<span class="line-modified">216                 metadata.xmlTypes.put(name, new XmlType(fieldType, parameterType));</span>


217                 break;

218             case &quot;Type&quot;:
219                 currentType = new TypeElement();
220                 currentType.name = attributes.getValue(&quot;name&quot;);
221                 break;
222             case &quot;Event&quot;:
223                 EventElement eventType = new EventElement();
224                 eventType.name = attributes.getValue(&quot;name&quot;);
225                 eventType.thread = getBoolean(attributes, &quot;thread&quot;, false);
226                 eventType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);
227                 eventType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);
228                 eventType.periodic = attributes.getValue(&quot;period&quot;) != null;
229                 eventType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);
230                 eventType.commitState = attributes.getValue(&quot;commitState&quot;);
231                 currentType = eventType;
232                 break;
233             case &quot;Field&quot;:
234                 currentField = new FieldElement(metadata);
235                 currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
236                 currentField.name = attributes.getValue(&quot;name&quot;);
237                 currentField.typeName = attributes.getValue(&quot;type&quot;);
238                 break;
239             }
240         }
241 
242         private boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {
243             String value = attributes.getValue(name);
244             return value == null ? defaultValue : Boolean.valueOf(value);
245         }
246 
247         @Override
248         public void endElement(String uri, String localName, String qName) {
249             switch (qName) {

250             case &quot;Type&quot;:
251             case &quot;Event&quot;:
252                 metadata.types.put(currentType.name, currentType);
253                 currentType = null;
254                 break;
255             case &quot;Field&quot;:
256                 currentType.fields.add(currentField);
257                 currentField = null;
258                 break;
259             }
260         }
261     }
262 
263     static class Printer implements AutoCloseable {
264         final PrintStream out;
265         Printer(File outputDirectory, String filename) throws FileNotFoundException {
266             out = new PrintStream(new BufferedOutputStream(new FileOutputStream(new File(outputDirectory, filename))));
267             write(&quot;/* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */&quot;);
268             write(&quot;&quot;);
269         }
</pre>
<hr />
<pre>
301                 out.write(&quot;  &quot;);
302             }
303             out.write(&quot;      default:&quot;);
304             out.write(&quot;        break;&quot;);
305             out.write(&quot;      }&quot;);
306             out.write(&quot;    }&quot;);
307             out.write(&quot;&quot;);
308             out.write(&quot; private:&quot;);
309             out.write(&quot;&quot;);
310             for (EventElement e : metadata.getPeriodicEvents()) {
311                 out.write(&quot;  static void request&quot; + e.name + &quot;(void);&quot;);
312                 out.write(&quot;&quot;);
313             }
314             out.write(&quot;};&quot;);
315             out.write(&quot;&quot;);
316             out.write(&quot;#endif // INCLUDE_JFR&quot;);
317             out.write(&quot;#endif // JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
318         }
319     }
320 
<span class="line-modified">321     private static void printJfrEventControlHpp(Metadata metadata, File outputDirectory) throws Exception {</span>
322         try (Printer out = new Printer(outputDirectory, &quot;jfrEventControl.hpp&quot;)) {
323             out.write(&quot;#ifndef JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
324             out.write(&quot;#define JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
325             out.write(&quot;&quot;);
326             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
327             out.write(&quot;#if INCLUDE_JFR&quot;);
328             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
329             out.write(&quot;&quot;);
330             out.write(&quot;/**&quot;);
331             out.write(&quot; * Event setting. We add some padding so we can use our&quot;);
332             out.write(&quot; * event IDs as indexes into this.&quot;);
333             out.write(&quot; */&quot;);
334             out.write(&quot;&quot;);
335             out.write(&quot;struct jfrNativeEventSetting {&quot;);
336             out.write(&quot;  jlong  threshold_ticks;&quot;);
337             out.write(&quot;  jlong  cutoff_ticks;&quot;);
338             out.write(&quot;  u1     stacktrace;&quot;);
339             out.write(&quot;  u1     enabled;&quot;);
<span class="line-modified">340             out.write(&quot;  u1     pad[6]; // Because GCC on linux ia32 at least tries to pack this.&quot;);</span>

341             out.write(&quot;};&quot;);
342             out.write(&quot;&quot;);
343             out.write(&quot;union JfrNativeSettings {&quot;);
344             out.write(&quot;  // Array version.&quot;);
<span class="line-modified">345             out.write(&quot;  jfrNativeEventSetting bits[MaxJfrEventId];&quot;);</span>
346             out.write(&quot;  // Then, to make it easy to debug,&quot;);
347             out.write(&quot;  // add named struct members also.&quot;);
348             out.write(&quot;  struct {&quot;);
<span class="line-modified">349             out.write(&quot;    jfrNativeEventSetting pad[NUM_RESERVED_EVENTS];&quot;);</span>
350             for (TypeElement t : metadata.getEventsAndStructs()) {
351                 out.write(&quot;    jfrNativeEventSetting &quot; + t.name + &quot;;&quot;);
352             }
353             out.write(&quot;  } ev;&quot;);
354             out.write(&quot;};&quot;);
355             out.write(&quot;&quot;);
356             out.write(&quot;#endif // INCLUDE_JFR&quot;);
357             out.write(&quot;#endif // JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
358         }
359     }
360 
<span class="line-modified">361     private static void printJfrEventIdsHpp(Metadata metadata, File outputDirectory) throws Exception {</span>
362         try (Printer out = new Printer(outputDirectory, &quot;jfrEventIds.hpp&quot;)) {
363             out.write(&quot;#ifndef JFRFILES_JFREVENTIDS_HPP&quot;);
364             out.write(&quot;#define JFRFILES_JFREVENTIDS_HPP&quot;);
365             out.write(&quot;&quot;);
366             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
367             out.write(&quot;#if INCLUDE_JFR&quot;);
<span class="line-removed">368             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);</span>
369             out.write(&quot;&quot;);
<span class="line-removed">370             out.write(&quot;/**&quot;);</span>
<span class="line-removed">371             out.write(&quot; * Enum of the event types in the JVM&quot;);</span>
<span class="line-removed">372             out.write(&quot; */&quot;);</span>
373             out.write(&quot;enum JfrEventId {&quot;);
<span class="line-modified">374             out.write(&quot;  _jfreventbase = (NUM_RESERVED_EVENTS-1), // Make sure we start at right index.&quot;);</span>
<span class="line-modified">375             out.write(&quot;  &quot;);</span>
<span class="line-modified">376             out.write(&quot;  // Events -&gt; enum entry&quot;);</span>
<span class="line-modified">377             for (TypeElement t : metadata.getEventsAndStructs()) {</span>
<span class="line-modified">378                 out.write(&quot;  Jfr&quot; + t.name + &quot;Event,&quot;);</span>
<span class="line-removed">379             }</span>
<span class="line-removed">380             out.write(&quot;&quot;);</span>
<span class="line-removed">381             out.write(&quot;  MaxJfrEventId&quot;);</span>
<span class="line-removed">382             out.write(&quot;};&quot;);</span>
<span class="line-removed">383             out.write(&quot;&quot;);</span>
<span class="line-removed">384             out.write(&quot;/**&quot;);</span>
<span class="line-removed">385             out.write(&quot; * Struct types in the JVM&quot;);</span>
<span class="line-removed">386             out.write(&quot; */&quot;);</span>
<span class="line-removed">387             out.write(&quot;enum JfrStructId {&quot;);</span>
<span class="line-removed">388             for (TypeElement t : metadata.getNonEventsAndNonStructs()) {</span>
<span class="line-removed">389                 out.write(&quot;  Jfr&quot; + t.name + &quot;Struct,&quot;);</span>
<span class="line-removed">390             }</span>
<span class="line-removed">391             for (TypeElement t : metadata.getEventsAndStructs()) {</span>
<span class="line-removed">392                 out.write(&quot;  Jfr&quot; + t.name + &quot;Struct,&quot;);</span>
393             }
<span class="line-removed">394             out.write(&quot;&quot;);</span>
<span class="line-removed">395             out.write(&quot;  MaxJfrStructId&quot;);</span>
396             out.write(&quot;};&quot;);
<span class="line-removed">397             out.write(&quot;&quot;);</span>
398             out.write(&quot;typedef enum JfrEventId JfrEventId;&quot;);
<span class="line-removed">399             out.write(&quot;typedef enum JfrStructId JfrStructId;&quot;);</span>
400             out.write(&quot;&quot;);




401             out.write(&quot;#endif // INCLUDE_JFR&quot;);
402             out.write(&quot;#endif // JFRFILES_JFREVENTIDS_HPP&quot;);
403         }
404     }
405 
<span class="line-modified">406     private static void printJfrTypesHpp(Metadata metadata, File outputDirectory) throws Exception {</span>
<span class="line-removed">407         List&lt;String&gt; knownTypes = List.of(&quot;Thread&quot;, &quot;StackTrace&quot;, &quot;Class&quot;, &quot;StackFrame&quot;);</span>
408         try (Printer out = new Printer(outputDirectory, &quot;jfrTypes.hpp&quot;)) {
409             out.write(&quot;#ifndef JFRFILES_JFRTYPES_HPP&quot;);
410             out.write(&quot;#define JFRFILES_JFRTYPES_HPP&quot;);
411             out.write(&quot;&quot;);
412             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
413             out.write(&quot;#if INCLUDE_JFR&quot;);
414             out.write(&quot;&quot;);



415             out.write(&quot;enum JfrTypeId {&quot;);
<span class="line-modified">416             out.write(&quot;  TYPE_NONE             = 0,&quot;);</span>
<span class="line-modified">417             out.write(&quot;  TYPE_CLASS            = 20,&quot;);</span>
<span class="line-modified">418             out.write(&quot;  TYPE_STRING           = 21,&quot;);</span>
<span class="line-modified">419             out.write(&quot;  TYPE_THREAD           = 22,&quot;);</span>
<span class="line-modified">420             out.write(&quot;  TYPE_STACKTRACE       = 23,&quot;);</span>
<span class="line-modified">421             out.write(&quot;  TYPE_BYTES            = 24,&quot;);</span>
<span class="line-modified">422             out.write(&quot;  TYPE_EPOCHMILLIS      = 25,&quot;);</span>
<span class="line-modified">423             out.write(&quot;  TYPE_MILLIS           = 26,&quot;);</span>
<span class="line-modified">424             out.write(&quot;  TYPE_NANOS            = 27,&quot;);</span>
<span class="line-modified">425             out.write(&quot;  TYPE_TICKS            = 28,&quot;);</span>
<span class="line-modified">426             out.write(&quot;  TYPE_ADDRESS          = 29,&quot;);</span>
<span class="line-removed">427             out.write(&quot;  TYPE_PERCENTAGE       = 30,&quot;);</span>
<span class="line-removed">428             out.write(&quot;  TYPE_DUMMY,&quot;);</span>
<span class="line-removed">429             out.write(&quot;  TYPE_DUMMY_1,&quot;);</span>
430             for (TypeElement type : metadata.getTypes()) {
<span class="line-modified">431                 if (!knownTypes.contains(type.name)) {</span>
<span class="line-modified">432                     out.write(&quot;  TYPE_&quot; + type.name.toUpperCase() + &quot;,&quot;);</span>



433                 }
434             }
<span class="line-removed">435             out.write(&quot;&quot;);</span>
<span class="line-removed">436             out.write(&quot;  NUM_JFR_TYPES,&quot;);</span>
<span class="line-removed">437             out.write(&quot;  TYPES_END             = 255&quot;);</span>
438             out.write(&quot;};&quot;);
439             out.write(&quot;&quot;);
<span class="line-modified">440             out.write(&quot;enum ReservedEvent {&quot;);</span>
<span class="line-modified">441             out.write(&quot;  EVENT_METADATA,&quot;);</span>
<span class="line-modified">442             out.write(&quot;  EVENT_CHECKPOINT,&quot;);</span>
<span class="line-modified">443             out.write(&quot;  EVENT_BUFFERLOST,&quot;);</span>
<span class="line-modified">444             out.write(&quot;  NUM_RESERVED_EVENTS = TYPES_END&quot;);</span>












445             out.write(&quot;};&quot;);
446             out.write(&quot;&quot;);
447             out.write(&quot;#endif // INCLUDE_JFR&quot;);
448             out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
<span class="line-modified">449           };</span>

450     }
451 
452     private static void printJfrEventClassesHpp(Metadata metadata, File outputDirectory) throws Exception {
453         try (Printer out = new Printer(outputDirectory, &quot;jfrEventClasses.hpp&quot;)) {
454             out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
455             out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
456             out.write(&quot;&quot;);
457             out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
458             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
459             out.write(&quot;#include \&quot;jfr/utilities/jfrTypes.hpp\&quot;&quot;);
460             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
461             out.write(&quot;#include \&quot;utilities/ticks.hpp\&quot;&quot;);
462             out.write(&quot;#if INCLUDE_JFR&quot;);
463             out.write(&quot;#include \&quot;jfr/recorder/service/jfrEvent.hpp\&quot;&quot;);
464             out.write(&quot;#include \&quot;jfr/support/jfrEpochSynchronization.hpp\&quot;&quot;);
465             out.write(&quot;/*&quot;);
466             out.write(&quot; * Each event class has an assert member function verify() which is invoked&quot;);
467             out.write(&quot; * just before the engine writes the event and its fields to the data stream.&quot;);
468             out.write(&quot; * The purpose of verify() is to ensure that all fields in the event are initialized&quot;);
469             out.write(&quot; * and set before attempting to commit.&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 package build.tools.jfr;
  2 
  3 import java.io.BufferedOutputStream;
  4 import java.io.File;
  5 import java.io.FileNotFoundException;
  6 import java.io.FileOutputStream;
  7 import java.io.IOException;
  8 import java.io.PrintStream;
  9 import java.util.ArrayList;

 10 import java.util.LinkedHashMap;
 11 import java.util.List;
 12 import java.util.Map;
<span class="line-added"> 13 import java.util.Map.Entry;</span>
 14 import java.util.StringJoiner;
 15 import java.util.function.Predicate;
 16 
 17 import javax.xml.XMLConstants;
 18 import javax.xml.parsers.ParserConfigurationException;
 19 import javax.xml.parsers.SAXParser;
 20 import javax.xml.parsers.SAXParserFactory;
 21 import javax.xml.validation.SchemaFactory;
 22 
 23 import org.xml.sax.Attributes;
 24 import org.xml.sax.SAXException;
 25 import org.xml.sax.SAXParseException;
 26 import org.xml.sax.helpers.DefaultHandler;
 27 
 28 public class GenerateJfrFiles {
 29 
 30     public static void main(String... args) throws Exception {
 31         if (args.length != 3) {
 32             System.err.println(&quot;Incorrect number of command line arguments.&quot;);
 33             System.err.println(&quot;Usage:&quot;);
 34             System.err.println(&quot;java GenerateJfrFiles[.java] &lt;path-to-metadata.xml&gt; &lt;path-to-metadata.xsd&gt; &lt;output-directory&gt;&quot;);
 35             System.exit(1);
 36         }
 37         try {
 38             File metadataXml = new File(args[0]);
 39             File metadataSchema = new File(args[1]);
 40             File outputDirectory = new File(args[2]);
 41 
 42             Metadata metadata = new Metadata(metadataXml, metadataSchema);
 43             metadata.verify();
 44             metadata.wireUpTypes();
 45 
<span class="line-added"> 46             TypeCounter typeCounter = new TypeCounter();</span>
<span class="line-added"> 47             printJfrEventIdsHpp(metadata, typeCounter, outputDirectory);</span>
<span class="line-added"> 48             printJfrTypesHpp(metadata, typeCounter, outputDirectory);</span>
 49             printJfrPeriodicHpp(metadata, outputDirectory);
<span class="line-modified"> 50             printJfrEventControlHpp(metadata, typeCounter, outputDirectory);</span>


 51             printJfrEventClassesHpp(metadata, outputDirectory);
 52 
 53         } catch (Exception e) {
 54             e.printStackTrace();
 55             System.exit(1);
 56         }
 57     }
 58 
<span class="line-added"> 59     static class TypeCounter {</span>
<span class="line-added"> 60         final static long RESERVED_EVENT_COUNT = 2;</span>
<span class="line-added"> 61         long typeId = -1;</span>
<span class="line-added"> 62         long eventId = -1;</span>
<span class="line-added"> 63         long eventCount = 0;</span>
<span class="line-added"> 64         String firstTypeName;</span>
<span class="line-added"> 65         String lastTypeName;</span>
<span class="line-added"> 66         String firstEventName;</span>
<span class="line-added"> 67         String lastEventname;</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69         public long nextEventId(String name) {</span>
<span class="line-added"> 70             eventCount++;</span>
<span class="line-added"> 71             if (eventId == -1) {</span>
<span class="line-added"> 72                 eventId = firstEventId();</span>
<span class="line-added"> 73                 firstEventName = lastEventname = name;</span>
<span class="line-added"> 74                 return eventId;</span>
<span class="line-added"> 75             }</span>
<span class="line-added"> 76             lastEventname = name;</span>
<span class="line-added"> 77             return ++eventId;</span>
<span class="line-added"> 78         }</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80         public long nextTypeId(String typeName) {</span>
<span class="line-added"> 81             if (typeId == -1) {</span>
<span class="line-added"> 82                 lastTypeName = firstTypeName = typeName;</span>
<span class="line-added"> 83                 typeId = lastEventId();</span>
<span class="line-added"> 84             }</span>
<span class="line-added"> 85             lastTypeName = typeName;</span>
<span class="line-added"> 86             return ++typeId;</span>
<span class="line-added"> 87         }</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89         public long firstEventId() {</span>
<span class="line-added"> 90             return RESERVED_EVENT_COUNT;</span>
<span class="line-added"> 91         }</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93         public long lastEventId() {</span>
<span class="line-added"> 94             return eventId == -1 ? firstEventId() : eventId;</span>
<span class="line-added"> 95         }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97         public long eventCount() {</span>
<span class="line-added"> 98             return eventCount;</span>
<span class="line-added"> 99         }</span>
<span class="line-added">100 </span>
<span class="line-added">101         public String firstTypeName() {</span>
<span class="line-added">102             return firstTypeName;</span>
<span class="line-added">103         }</span>
<span class="line-added">104 </span>
<span class="line-added">105         public String lastTypeName() {</span>
<span class="line-added">106             return lastTypeName;</span>
<span class="line-added">107         }</span>
<span class="line-added">108 </span>
<span class="line-added">109         public String firstEventName() {</span>
<span class="line-added">110             return firstEventName;</span>
<span class="line-added">111         }</span>
<span class="line-added">112 </span>
<span class="line-added">113         public String lastEventName() {</span>
<span class="line-added">114             return lastEventname;</span>
<span class="line-added">115         }</span>
<span class="line-added">116     }</span>
<span class="line-added">117 </span>
118     static class XmlType {
<span class="line-added">119         final String name;</span>
120         final String fieldType;
121         final String parameterType;
<span class="line-modified">122         final String javaType;</span>
<span class="line-added">123         final boolean unsigned;</span>
<span class="line-added">124 </span>
<span class="line-added">125         XmlType(String name, String fieldType, String parameterType, String javaType, boolean unsigned) {</span>
<span class="line-added">126             this.name = name;</span>
127             this.fieldType = fieldType;
128             this.parameterType = parameterType;
<span class="line-added">129             this.javaType = javaType;</span>
<span class="line-added">130             this.unsigned = unsigned;</span>
131         }
132     }
133 
134     static class TypeElement {
135         List&lt;FieldElement&gt; fields = new ArrayList&lt;&gt;();
136         String name;
137         String fieldType;
138         String parameterType;
139         boolean supportStruct;
140     }
141 
142     static class Metadata {
143         final Map&lt;String, TypeElement&gt; types = new LinkedHashMap&lt;&gt;();
<span class="line-modified">144         final Map&lt;String, XmlType&gt; xmlTypes = new LinkedHashMap&lt;&gt;();</span>
145         Metadata(File metadataXml, File metadataSchema) throws ParserConfigurationException, SAXException, FileNotFoundException, IOException {
146             SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
147             SAXParserFactory factory = SAXParserFactory.newInstance();
148             factory.setSchema(schemaFactory.newSchema(metadataSchema));
149             SAXParser sp = factory.newSAXParser();
150             sp.parse(metadataXml, new MetadataHandler(this));
151         }
152 
153         List&lt;EventElement&gt; getEvents() {
154             return getList(t -&gt; t.getClass() == EventElement.class);
155         }
156 
157         List&lt;TypeElement&gt; getEventsAndStructs() {
158             return getList(t -&gt; t.getClass() == EventElement.class || t.supportStruct);
159         }
160 
161         List&lt;TypeElement&gt; getTypesAndStructs() {
162             return getList(t -&gt; t.getClass() == TypeElement.class || t.supportStruct);
163         }
164 
165         @SuppressWarnings(&quot;unchecked&quot;)
166         &lt;T&gt; List&lt;T&gt; getList(Predicate&lt;? super TypeElement&gt; pred) {
167             List&lt;T&gt; result = new ArrayList&lt;&gt;(types.size());
168             for (TypeElement t : types.values()) {
169                 if (pred.test(t)) {
170                     result.add((T) t);
171                 }
172             }
173             return result;
174         }
175 
176         List&lt;EventElement&gt; getPeriodicEvents() {
177             return getList(t -&gt; t.getClass() == EventElement.class &amp;&amp; ((EventElement) t).periodic);
178         }
179 




180         List&lt;TypeElement&gt; getTypes() {
<span class="line-modified">181             return getList(t -&gt; t.getClass() == TypeElement.class);</span>
182         }
183 
184         List&lt;TypeElement&gt; getStructs() {
185             return getList(t -&gt; t.getClass() == TypeElement.class &amp;&amp; t.supportStruct);
186         }
187 
188         void verify()  {
189             for (TypeElement t : types.values()) {
190                 for (FieldElement f : t.fields) {
191                     if (!xmlTypes.containsKey(f.typeName)) { // ignore primitives
192                         if (!types.containsKey(f.typeName)) {
193                             throw new IllegalStateException(&quot;Could not find definition of type &#39;&quot; + f.typeName + &quot;&#39; used by &quot; + t.name + &quot;#&quot; + f.name);
194                         }
195                     }
196                 }
197             }
198         }
199 
200         void wireUpTypes() {
201             for (TypeElement t : types.values()) {
</pre>
<hr />
<pre>
259     }
260 
261     static class MetadataHandler extends DefaultHandler {
262         final Metadata metadata;
263         FieldElement currentField;
264         TypeElement currentType;
265         MetadataHandler(Metadata metadata) {
266             this.metadata = metadata;
267         }
268         @Override
269         public void error(SAXParseException e) throws SAXException {
270           throw e;
271         }
272         @Override
273         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
274             switch (qName) {
275             case &quot;XmlType&quot;:
276                 String name = attributes.getValue(&quot;name&quot;);
277                 String parameterType = attributes.getValue(&quot;parameterType&quot;);
278                 String fieldType = attributes.getValue(&quot;fieldType&quot;);
<span class="line-modified">279                 String javaType = attributes.getValue(&quot;javaType&quot;);</span>
<span class="line-added">280                 boolean unsigned = getBoolean(attributes, &quot;unsigned&quot;, false);</span>
<span class="line-added">281                 metadata.xmlTypes.put(name, new XmlType(name, fieldType, parameterType, javaType, unsigned));</span>
282                 break;
<span class="line-added">283             case &quot;Relation&quot;:</span>
284             case &quot;Type&quot;:
285                 currentType = new TypeElement();
286                 currentType.name = attributes.getValue(&quot;name&quot;);
287                 break;
288             case &quot;Event&quot;:
289                 EventElement eventType = new EventElement();
290                 eventType.name = attributes.getValue(&quot;name&quot;);
291                 eventType.thread = getBoolean(attributes, &quot;thread&quot;, false);
292                 eventType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);
293                 eventType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);
294                 eventType.periodic = attributes.getValue(&quot;period&quot;) != null;
295                 eventType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);
296                 eventType.commitState = attributes.getValue(&quot;commitState&quot;);
297                 currentType = eventType;
298                 break;
299             case &quot;Field&quot;:
300                 currentField = new FieldElement(metadata);
301                 currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
302                 currentField.name = attributes.getValue(&quot;name&quot;);
303                 currentField.typeName = attributes.getValue(&quot;type&quot;);
304                 break;
305             }
306         }
307 
308         private boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {
309             String value = attributes.getValue(name);
310             return value == null ? defaultValue : Boolean.valueOf(value);
311         }
312 
313         @Override
314         public void endElement(String uri, String localName, String qName) {
315             switch (qName) {
<span class="line-added">316             case &quot;Relation&quot;:</span>
317             case &quot;Type&quot;:
318             case &quot;Event&quot;:
319                 metadata.types.put(currentType.name, currentType);
320                 currentType = null;
321                 break;
322             case &quot;Field&quot;:
323                 currentType.fields.add(currentField);
324                 currentField = null;
325                 break;
326             }
327         }
328     }
329 
330     static class Printer implements AutoCloseable {
331         final PrintStream out;
332         Printer(File outputDirectory, String filename) throws FileNotFoundException {
333             out = new PrintStream(new BufferedOutputStream(new FileOutputStream(new File(outputDirectory, filename))));
334             write(&quot;/* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */&quot;);
335             write(&quot;&quot;);
336         }
</pre>
<hr />
<pre>
368                 out.write(&quot;  &quot;);
369             }
370             out.write(&quot;      default:&quot;);
371             out.write(&quot;        break;&quot;);
372             out.write(&quot;      }&quot;);
373             out.write(&quot;    }&quot;);
374             out.write(&quot;&quot;);
375             out.write(&quot; private:&quot;);
376             out.write(&quot;&quot;);
377             for (EventElement e : metadata.getPeriodicEvents()) {
378                 out.write(&quot;  static void request&quot; + e.name + &quot;(void);&quot;);
379                 out.write(&quot;&quot;);
380             }
381             out.write(&quot;};&quot;);
382             out.write(&quot;&quot;);
383             out.write(&quot;#endif // INCLUDE_JFR&quot;);
384             out.write(&quot;#endif // JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
385         }
386     }
387 
<span class="line-modified">388     private static void printJfrEventControlHpp(Metadata metadata, TypeCounter typeCounter, File outputDirectory) throws Exception {</span>
389         try (Printer out = new Printer(outputDirectory, &quot;jfrEventControl.hpp&quot;)) {
390             out.write(&quot;#ifndef JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
391             out.write(&quot;#define JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
392             out.write(&quot;&quot;);
393             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
394             out.write(&quot;#if INCLUDE_JFR&quot;);
395             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
396             out.write(&quot;&quot;);
397             out.write(&quot;/**&quot;);
398             out.write(&quot; * Event setting. We add some padding so we can use our&quot;);
399             out.write(&quot; * event IDs as indexes into this.&quot;);
400             out.write(&quot; */&quot;);
401             out.write(&quot;&quot;);
402             out.write(&quot;struct jfrNativeEventSetting {&quot;);
403             out.write(&quot;  jlong  threshold_ticks;&quot;);
404             out.write(&quot;  jlong  cutoff_ticks;&quot;);
405             out.write(&quot;  u1     stacktrace;&quot;);
406             out.write(&quot;  u1     enabled;&quot;);
<span class="line-modified">407             out.write(&quot;  u1     large;&quot;);</span>
<span class="line-added">408             out.write(&quot;  u1     pad[5]; // Because GCC on linux ia32 at least tries to pack this.&quot;);</span>
409             out.write(&quot;};&quot;);
410             out.write(&quot;&quot;);
411             out.write(&quot;union JfrNativeSettings {&quot;);
412             out.write(&quot;  // Array version.&quot;);
<span class="line-modified">413             out.write(&quot;  jfrNativeEventSetting bits[NUMBER_OF_EVENTS];&quot;);</span>
414             out.write(&quot;  // Then, to make it easy to debug,&quot;);
415             out.write(&quot;  // add named struct members also.&quot;);
416             out.write(&quot;  struct {&quot;);
<span class="line-modified">417             out.write(&quot;    jfrNativeEventSetting pad[NUMBER_OF_RESERVED_EVENTS];&quot;);</span>
418             for (TypeElement t : metadata.getEventsAndStructs()) {
419                 out.write(&quot;    jfrNativeEventSetting &quot; + t.name + &quot;;&quot;);
420             }
421             out.write(&quot;  } ev;&quot;);
422             out.write(&quot;};&quot;);
423             out.write(&quot;&quot;);
424             out.write(&quot;#endif // INCLUDE_JFR&quot;);
425             out.write(&quot;#endif // JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
426         }
427     }
428 
<span class="line-modified">429     private static void printJfrEventIdsHpp(Metadata metadata, TypeCounter typeCounter, File outputDirectory) throws Exception {</span>
430         try (Printer out = new Printer(outputDirectory, &quot;jfrEventIds.hpp&quot;)) {
431             out.write(&quot;#ifndef JFRFILES_JFREVENTIDS_HPP&quot;);
432             out.write(&quot;#define JFRFILES_JFREVENTIDS_HPP&quot;);
433             out.write(&quot;&quot;);
434             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
435             out.write(&quot;#if INCLUDE_JFR&quot;);

436             out.write(&quot;&quot;);



437             out.write(&quot;enum JfrEventId {&quot;);
<span class="line-modified">438             out.write(&quot;  JfrMetadataEvent = 0,&quot;);</span>
<span class="line-modified">439             out.write(&quot;  JfrCheckpointEvent = 1,&quot;);</span>
<span class="line-modified">440             for (TypeElement t : metadata.getEvents()) {</span>
<span class="line-modified">441                 String name = &quot;Jfr&quot; + t.name +&quot;Event&quot;;</span>
<span class="line-modified">442                 out.write(&quot;  &quot; + name + &quot; = &quot; + typeCounter.nextEventId(name) + &quot;,&quot;);</span>














443             }


444             out.write(&quot;};&quot;);

445             out.write(&quot;typedef enum JfrEventId JfrEventId;&quot;);

446             out.write(&quot;&quot;);
<span class="line-added">447             out.write(&quot;static const JfrEventId FIRST_EVENT_ID = &quot; + typeCounter.firstEventName() + &quot;;&quot;);</span>
<span class="line-added">448             out.write(&quot;static const JfrEventId LAST_EVENT_ID = &quot; + typeCounter.lastEventName() + &quot;;&quot;);</span>
<span class="line-added">449             out.write(&quot;static const int NUMBER_OF_EVENTS = &quot; + typeCounter.eventCount() + &quot;;&quot;);</span>
<span class="line-added">450             out.write(&quot;static const int NUMBER_OF_RESERVED_EVENTS = &quot; + TypeCounter.RESERVED_EVENT_COUNT + &quot;;&quot;);</span>
451             out.write(&quot;#endif // INCLUDE_JFR&quot;);
452             out.write(&quot;#endif // JFRFILES_JFREVENTIDS_HPP&quot;);
453         }
454     }
455 
<span class="line-modified">456     private static void printJfrTypesHpp(Metadata metadata, TypeCounter typeCounter, File outputDirectory) throws Exception {</span>

457         try (Printer out = new Printer(outputDirectory, &quot;jfrTypes.hpp&quot;)) {
458             out.write(&quot;#ifndef JFRFILES_JFRTYPES_HPP&quot;);
459             out.write(&quot;#define JFRFILES_JFRTYPES_HPP&quot;);
460             out.write(&quot;&quot;);
461             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
462             out.write(&quot;#if INCLUDE_JFR&quot;);
463             out.write(&quot;&quot;);
<span class="line-added">464             out.write(&quot;#include &lt;string.h&gt;&quot;);</span>
<span class="line-added">465             out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);</span>
<span class="line-added">466             out.write(&quot;&quot;);</span>
467             out.write(&quot;enum JfrTypeId {&quot;);
<span class="line-modified">468             Map&lt;String, XmlType&gt; javaTypes = new LinkedHashMap&lt;&gt;();</span>
<span class="line-modified">469             for (var t : metadata.xmlTypes.entrySet()) {</span>
<span class="line-modified">470                 String name = t.getKey();</span>
<span class="line-modified">471                 XmlType xmlType = t.getValue();</span>
<span class="line-modified">472                 if (xmlType.javaType != null &amp;&amp; !xmlType.unsigned) {</span>
<span class="line-modified">473                     String typeName = &quot;TYPE_&quot; + name.toUpperCase();</span>
<span class="line-modified">474                     long typeId = typeCounter.nextTypeId(typeName);</span>
<span class="line-modified">475                     out.write(&quot;  &quot; + typeName + &quot; = &quot; + typeId + &quot;,&quot;);</span>
<span class="line-modified">476                     javaTypes.put(name, xmlType);</span>
<span class="line-modified">477                 }</span>
<span class="line-modified">478             }</span>



479             for (TypeElement type : metadata.getTypes()) {
<span class="line-modified">480                 String name = type.name;</span>
<span class="line-modified">481                 if (!javaTypes.containsKey(name)) {</span>
<span class="line-added">482                     String typeName = &quot;TYPE_&quot; + name.toUpperCase();</span>
<span class="line-added">483                     long typeId = typeCounter.nextTypeId(typeName);</span>
<span class="line-added">484                     out.write(&quot;  &quot; + typeName + &quot; = &quot; + typeId + &quot;,&quot;);</span>
485                 }
486             }



487             out.write(&quot;};&quot;);
488             out.write(&quot;&quot;);
<span class="line-modified">489             out.write(&quot;static const JfrTypeId FIRST_TYPE_ID = &quot; + typeCounter.firstTypeName() + &quot;;&quot;);</span>
<span class="line-modified">490             out.write(&quot;static const JfrTypeId LAST_TYPE_ID = &quot; + typeCounter.lastTypeName() + &quot;;&quot;);</span>
<span class="line-modified">491 </span>
<span class="line-modified">492             out.write(&quot;&quot;);</span>
<span class="line-modified">493             out.write(&quot;class JfrType : public AllStatic {&quot;);</span>
<span class="line-added">494             out.write(&quot; public:&quot;);</span>
<span class="line-added">495             out.write(&quot;  static jlong name_to_id(const char* type_name) {&quot;);</span>
<span class="line-added">496             for (Entry&lt;String, XmlType&gt; m : javaTypes.entrySet()) {</span>
<span class="line-added">497                 XmlType xmlType = m.getValue();</span>
<span class="line-added">498                 String javaName = xmlType.javaType;</span>
<span class="line-added">499                 String typeName = xmlType.name.toUpperCase();</span>
<span class="line-added">500                 out.write(&quot;    if (strcmp(type_name, \&quot;&quot; + javaName + &quot;\&quot;) == 0) {&quot;);</span>
<span class="line-added">501                 out.write(&quot;      return TYPE_&quot; + typeName + &quot;;&quot;);</span>
<span class="line-added">502                 out.write(&quot;    }&quot;);</span>
<span class="line-added">503             }</span>
<span class="line-added">504             out.write(&quot;    return -1;&quot;);</span>
<span class="line-added">505             out.write(&quot;  }&quot;);</span>
506             out.write(&quot;};&quot;);
507             out.write(&quot;&quot;);
508             out.write(&quot;#endif // INCLUDE_JFR&quot;);
509             out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
<span class="line-modified">510         }</span>
<span class="line-added">511         ;</span>
512     }
513 
514     private static void printJfrEventClassesHpp(Metadata metadata, File outputDirectory) throws Exception {
515         try (Printer out = new Printer(outputDirectory, &quot;jfrEventClasses.hpp&quot;)) {
516             out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
517             out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
518             out.write(&quot;&quot;);
519             out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
520             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
521             out.write(&quot;#include \&quot;jfr/utilities/jfrTypes.hpp\&quot;&quot;);
522             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
523             out.write(&quot;#include \&quot;utilities/ticks.hpp\&quot;&quot;);
524             out.write(&quot;#if INCLUDE_JFR&quot;);
525             out.write(&quot;#include \&quot;jfr/recorder/service/jfrEvent.hpp\&quot;&quot;);
526             out.write(&quot;#include \&quot;jfr/support/jfrEpochSynchronization.hpp\&quot;&quot;);
527             out.write(&quot;/*&quot;);
528             out.write(&quot; * Each event class has an assert member function verify() which is invoked&quot;);
529             out.write(&quot; * just before the engine writes the event and its fields to the data stream.&quot;);
530             out.write(&quot; * The purpose of verify() is to ensure that all fields in the event are initialized&quot;);
531             out.write(&quot; * and set before attempting to commit.&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../jdk/src/classes/build/tools/classlist/HelloClasslist.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../../src/hotspot/cpu/aarch64/aarch64.ad.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.File;
 29 import java.io.FileInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.Writer;
 33 import java.math.BigInteger;
 34 import java.nio.file.Files;
 35 import java.nio.file.Path;
 36 import java.nio.file.StandardCopyOption;
 37 import java.nio.file.attribute.PosixFilePermission;
 38 import java.text.MessageFormat;
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.EnumSet;
 42 import java.util.HashMap;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Objects;
 46 import java.util.Optional;
 47 import java.util.ResourceBundle;
 48 import java.util.Set;
 49 import java.util.concurrent.atomic.AtomicReference;
 50 import java.util.function.Consumer;
 51 import java.util.stream.Stream;
 52 import javax.xml.parsers.DocumentBuilder;
 53 import javax.xml.parsers.DocumentBuilderFactory;
 54 import javax.xml.xpath.XPath;
 55 import javax.xml.xpath.XPathConstants;
 56 import javax.xml.xpath.XPathFactory;
 57 
 58 import static jdk.incubator.jpackage.internal.StandardBundlerParam.*;
 59 import static jdk.incubator.jpackage.internal.MacBaseInstallerBundler.*;
 60 import static jdk.incubator.jpackage.internal.MacAppBundler.*;
 61 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 62 
 63 public class MacAppImageBuilder extends AbstractAppImageBuilder {
 64 
 65     private static final ResourceBundle I18N = ResourceBundle.getBundle(
 66             &quot;jdk.incubator.jpackage.internal.resources.MacResources&quot;);
 67 
 68     private static final String TEMPLATE_BUNDLE_ICON = &quot;java.icns&quot;;
 69     private static final String OS_TYPE_CODE = &quot;APPL&quot;;
 70     private static final String TEMPLATE_INFO_PLIST_LITE =
 71             &quot;Info-lite.plist.template&quot;;
 72     private static final String TEMPLATE_RUNTIME_INFO_PLIST =
 73             &quot;Runtime-Info.plist.template&quot;;
 74 
 75     private final Path root;
 76     private final Path contentsDir;
 77     private final Path appDir;
 78     private final Path javaModsDir;
 79     private final Path resourcesDir;
 80     private final Path macOSDir;
 81     private final Path runtimeDir;
 82     private final Path runtimeRoot;
 83     private final Path mdir;
 84 
 85     private static List&lt;String&gt; keyChains;
 86 
 87     public static final BundlerParamInfo&lt;Boolean&gt;
 88             MAC_CONFIGURE_LAUNCHER_IN_PLIST = new StandardBundlerParam&lt;&gt;(
 89                     &quot;mac.configure-launcher-in-plist&quot;,
 90                     Boolean.class,
 91                     params -&gt; Boolean.FALSE,
 92                     (s, p) -&gt; Boolean.valueOf(s));
 93 
 94     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_NAME =
 95             new StandardBundlerParam&lt;&gt;(
 96                     Arguments.CLIOptions.MAC_BUNDLE_NAME.getId(),
 97                     String.class,
 98                     params -&gt; null,
 99                     (s, p) -&gt; s);
100 
101     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_IDENTIFIER =
102             new StandardBundlerParam&lt;&gt;(
103                     Arguments.CLIOptions.MAC_BUNDLE_IDENTIFIER.getId(),
104                     String.class,
105                     params -&gt; {
106                         // Get identifier from app image if user provided
107                         // app image and did not provide the identifier via CLI.
108                         String identifier = extractBundleIdentifier(params);
109                         if (identifier != null) {
110                             return identifier;
111                         }
112 
<a name="1" id="anc1"></a><span class="line-modified">113                         return MacAppBundler.getIdentifier(params);</span>






















114                     },
115                     (s, p) -&gt; s);
116 
117     public static final BundlerParamInfo&lt;File&gt; ICON_ICNS =
118             new StandardBundlerParam&lt;&gt;(
119             &quot;icon.icns&quot;,
120             File.class,
121             params -&gt; {
122                 File f = ICON.fetchFrom(params);
123                 if (f != null &amp;&amp; !f.getName().toLowerCase().endsWith(&quot;.icns&quot;)) {
124                     Log.error(MessageFormat.format(
125                             I18N.getString(&quot;message.icon-not-icns&quot;), f));
126                     return null;
127                 }
128                 return f;
129             },
130             (s, p) -&gt; new File(s));
131 
132     public static final StandardBundlerParam&lt;Boolean&gt; SIGN_BUNDLE  =
133             new StandardBundlerParam&lt;&gt;(
134             Arguments.CLIOptions.MAC_SIGN.getId(),
135             Boolean.class,
136             params -&gt; false,
137             // valueOf(null) is false, we actually do want null in some cases
138             (s, p) -&gt; (s == null || &quot;null&quot;.equalsIgnoreCase(s)) ?
139                     null : Boolean.valueOf(s)
140         );
141 
142     public MacAppImageBuilder(Map&lt;String, Object&gt; params, Path imageOutDir)
143             throws IOException {
144         super(params, imageOutDir.resolve(APP_NAME.fetchFrom(params)
145                 + &quot;.app/Contents/runtime/Contents/Home&quot;));
146 
147         Objects.requireNonNull(imageOutDir);
148 
149         this.root = imageOutDir.resolve(APP_NAME.fetchFrom(params) + &quot;.app&quot;);
150         this.contentsDir = root.resolve(&quot;Contents&quot;);
151         this.appDir = contentsDir.resolve(&quot;app&quot;);
152         this.javaModsDir = appDir.resolve(&quot;mods&quot;);
153         this.resourcesDir = contentsDir.resolve(&quot;Resources&quot;);
154         this.macOSDir = contentsDir.resolve(&quot;MacOS&quot;);
155         this.runtimeDir = contentsDir.resolve(&quot;runtime&quot;);
156         this.runtimeRoot = runtimeDir.resolve(&quot;Contents/Home&quot;);
157         this.mdir = runtimeRoot.resolve(&quot;lib&quot;);
158         Files.createDirectories(appDir);
159         Files.createDirectories(resourcesDir);
160         Files.createDirectories(macOSDir);
161         Files.createDirectories(runtimeDir);
162     }
163 
164     private void writeEntry(InputStream in, Path dstFile) throws IOException {
165         Files.createDirectories(dstFile.getParent());
166         Files.copy(in, dstFile);
167     }
168 
<a name="2" id="anc2"></a>




















































169     @Override
170     public Path getAppDir() {
171         return appDir;
172     }
173 
174     @Override
175     public Path getAppModsDir() {
176         return javaModsDir;
177     }
178 
179     @Override
180     public void prepareApplicationFiles(Map&lt;String, ? super Object&gt; params)
181             throws IOException {
182         Map&lt;String, ? super Object&gt; originalParams = new HashMap&lt;&gt;(params);
183         // Generate PkgInfo
184         File pkgInfoFile = new File(contentsDir.toFile(), &quot;PkgInfo&quot;);
185         pkgInfoFile.createNewFile();
186         writePkgInfo(pkgInfoFile);
187 
188         Path executable = macOSDir.resolve(getLauncherName(params));
189 
190         // create the main app launcher
191         try (InputStream is_launcher =
192                 getResourceAsStream(&quot;jpackageapplauncher&quot;)) {
193             // Copy executable and library to MacOS folder
194             writeEntry(is_launcher, executable);
195         }
196         executable.toFile().setExecutable(true, false);
197         // generate main app launcher config file
198         File cfg = new File(root.toFile(), getLauncherCfgName(params));
199         writeCfgFile(params, cfg);
200 
201         // create additional app launcher(s) and config file(s)
202         List&lt;Map&lt;String, ? super Object&gt;&gt; entryPoints =
203                 StandardBundlerParam.ADD_LAUNCHERS.fetchFrom(params);
204         for (Map&lt;String, ? super Object&gt; entryPoint : entryPoints) {
205             Map&lt;String, ? super Object&gt; tmp =
206                     AddLauncherArguments.merge(originalParams, entryPoint);
207 
208             // add executable for add launcher
209             Path addExecutable = macOSDir.resolve(getLauncherName(tmp));
210             try (InputStream is = getResourceAsStream(&quot;jpackageapplauncher&quot;);) {
211                 writeEntry(is, addExecutable);
212             }
213             addExecutable.toFile().setExecutable(true, false);
214 
215             // add config file for add launcher
216             cfg = new File(root.toFile(), getLauncherCfgName(tmp));
217             writeCfgFile(tmp, cfg);
218         }
219 
220         // Copy class path entries to Java folder
221         copyClassPathEntries(appDir, params);
222 
223         /*********** Take care of &quot;config&quot; files *******/
224 
225         createResource(TEMPLATE_BUNDLE_ICON, params)
226                 .setCategory(&quot;icon&quot;)
227                 .setExternal(ICON_ICNS.fetchFrom(params))
228                 .saveToFile(resourcesDir.resolve(APP_NAME.fetchFrom(params)
229                         + &quot;.icns&quot;));
230 
231         // copy file association icons
232         for (Map&lt;String, ?
233                 super Object&gt; fa : FILE_ASSOCIATIONS.fetchFrom(params)) {
234             File f = FA_ICON.fetchFrom(fa);
235             if (f != null &amp;&amp; f.exists()) {
236                 try (InputStream in2 = new FileInputStream(f)) {
237                     Files.copy(in2, resourcesDir.resolve(f.getName()));
238                 }
239 
240             }
241         }
242 
243         copyRuntimeFiles(params);
244         sign(params);
245     }
246 
247     @Override
248     public void prepareJreFiles(Map&lt;String, ? super Object&gt; params)
249             throws IOException {
250         copyRuntimeFiles(params);
251         sign(params);
252     }
253 
254     @Override
255     File getRuntimeImageDir(File runtimeImageTop) {
256         File home = new File(runtimeImageTop, &quot;Contents/Home&quot;);
257         return (home.exists() ? home : runtimeImageTop);
258     }
259 
260     private void copyRuntimeFiles(Map&lt;String, ? super Object&gt; params)
261             throws IOException {
262         // Generate Info.plist
263         writeInfoPlist(contentsDir.resolve(&quot;Info.plist&quot;).toFile(), params);
264 
265         // generate java runtime info.plist
266         writeRuntimeInfoPlist(
267                 runtimeDir.resolve(&quot;Contents/Info.plist&quot;).toFile(), params);
268 
269         // copy library
270         Path runtimeMacOSDir = Files.createDirectories(
271                 runtimeDir.resolve(&quot;Contents/MacOS&quot;));
272 
273         // JDK 9, 10, and 11 have extra &#39;/jli/&#39; subdir
274         Path jli = runtimeRoot.resolve(&quot;lib/libjli.dylib&quot;);
275         if (!Files.exists(jli)) {
276             jli = runtimeRoot.resolve(&quot;lib/jli/libjli.dylib&quot;);
277         }
278 
279         Files.copy(jli, runtimeMacOSDir.resolve(&quot;libjli.dylib&quot;));
280     }
281 
282     private void sign(Map&lt;String, ? super Object&gt; params) throws IOException {
283         if (Optional.ofNullable(
284                 SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {
285             try {
286                 addNewKeychain(params);
287             } catch (InterruptedException e) {
288                 Log.error(e.getMessage());
289             }
290             String signingIdentity =
291                     DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);
292             if (signingIdentity != null) {
293                 prepareEntitlements(params);
294                 signAppBundle(params, root, signingIdentity,
295                         BUNDLE_ID_SIGNING_PREFIX.fetchFrom(params),
296                         getConfig_Entitlements(params));
297             }
298             restoreKeychainList(params);
299         }
300     }
301 
302     static File getConfig_Entitlements(Map&lt;String, ? super Object&gt; params) {
303         return new File(CONFIG_ROOT.fetchFrom(params),
304                 getLauncherName(params) + &quot;.entitlements&quot;);
305     }
306 
307     static void prepareEntitlements(Map&lt;String, ? super Object&gt; params)
308             throws IOException {
309         createResource(&quot;entitlements.plist&quot;, params)
310                 .setCategory(I18N.getString(&quot;resource.entitlements&quot;))
311                 .saveToFile(getConfig_Entitlements(params));
312     }
313 
314     private static String getLauncherName(Map&lt;String, ? super Object&gt; params) {
315         if (APP_NAME.fetchFrom(params) != null) {
316             return APP_NAME.fetchFrom(params);
317         } else {
318             return MAIN_CLASS.fetchFrom(params);
319         }
320     }
321 
322     public static String getLauncherCfgName(
323             Map&lt;String, ? super Object&gt; params) {
324         return &quot;Contents/app/&quot; + APP_NAME.fetchFrom(params) + &quot;.cfg&quot;;
325     }
326 
327     private void copyClassPathEntries(Path javaDirectory,
328             Map&lt;String, ? super Object&gt; params) throws IOException {
329         List&lt;RelativeFileSet&gt; resourcesList =
330                 APP_RESOURCES_LIST.fetchFrom(params);
331         if (resourcesList == null) {
332             throw new RuntimeException(
333                     I18N.getString(&quot;message.null-classpath&quot;));
334         }
335 
336         for (RelativeFileSet classPath : resourcesList) {
337             File srcdir = classPath.getBaseDirectory();
338             for (String fname : classPath.getIncludedFiles()) {
339                 copyEntry(javaDirectory, srcdir, fname);
340             }
341         }
342     }
343 
344     private String getBundleName(Map&lt;String, ? super Object&gt; params) {
345         if (MAC_CF_BUNDLE_NAME.fetchFrom(params) != null) {
346             String bn = MAC_CF_BUNDLE_NAME.fetchFrom(params);
347             if (bn.length() &gt; 16) {
348                 Log.error(MessageFormat.format(I18N.getString(
349                         &quot;message.bundle-name-too-long-warning&quot;),
350                         MAC_CF_BUNDLE_NAME.getID(), bn));
351             }
352             return MAC_CF_BUNDLE_NAME.fetchFrom(params);
353         } else if (APP_NAME.fetchFrom(params) != null) {
354             return APP_NAME.fetchFrom(params);
355         } else {
356             String nm = MAIN_CLASS.fetchFrom(params);
357             if (nm.length() &gt; 16) {
358                 nm = nm.substring(0, 16);
359             }
360             return nm;
361         }
362     }
363 
364     private void writeRuntimeInfoPlist(File file,
365             Map&lt;String, ? super Object&gt; params) throws IOException {
366         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
367         String identifier = StandardBundlerParam.isRuntimeInstaller(params) ?
368                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) :
369                 &quot;com.oracle.java.&quot; + MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);
370         data.put(&quot;CF_BUNDLE_IDENTIFIER&quot;, identifier);
371         String name = StandardBundlerParam.isRuntimeInstaller(params) ?
372                 getBundleName(params): &quot;Java Runtime Image&quot;;
373         data.put(&quot;CF_BUNDLE_NAME&quot;, name);
374         data.put(&quot;CF_BUNDLE_VERSION&quot;, VERSION.fetchFrom(params));
375         data.put(&quot;CF_BUNDLE_SHORT_VERSION_STRING&quot;, VERSION.fetchFrom(params));
376 
377         createResource(TEMPLATE_RUNTIME_INFO_PLIST, params)
378                 .setPublicName(&quot;Runtime-Info.plist&quot;)
379                 .setCategory(I18N.getString(&quot;resource.runtime-info-plist&quot;))
380                 .setSubstitutionData(data)
381                 .saveToFile(file);
382     }
383 
384     private void writeInfoPlist(File file, Map&lt;String, ? super Object&gt; params)
385             throws IOException {
386         Log.verbose(MessageFormat.format(I18N.getString(
387                 &quot;message.preparing-info-plist&quot;), file.getAbsolutePath()));
388 
389         //prepare config for exe
390         //Note: do not need CFBundleDisplayName if we don&#39;t support localization
391         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
392         data.put(&quot;DEPLOY_ICON_FILE&quot;, APP_NAME.fetchFrom(params) + &quot;.icns&quot;);
393         data.put(&quot;DEPLOY_BUNDLE_IDENTIFIER&quot;,
394                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params));
395         data.put(&quot;DEPLOY_BUNDLE_NAME&quot;,
396                 getBundleName(params));
<a name="3" id="anc3"></a><span class="line-modified">397         data.put(&quot;DEPLOY_BUNDLE_COPYRIGHT&quot;, COPYRIGHT.fetchFrom(params));</span>


398         data.put(&quot;DEPLOY_LAUNCHER_NAME&quot;, getLauncherName(params));
<a name="4" id="anc4"></a><span class="line-modified">399         data.put(&quot;DEPLOY_BUNDLE_SHORT_VERSION&quot;, VERSION.fetchFrom(params));</span>
<span class="line-modified">400         data.put(&quot;DEPLOY_BUNDLE_CFBUNDLE_VERSION&quot;, VERSION.fetchFrom(params));</span>




401 
402         boolean hasMainJar = MAIN_JAR.fetchFrom(params) != null;
403         boolean hasMainModule =
404                 StandardBundlerParam.MODULE.fetchFrom(params) != null;
405 
406         if (hasMainJar) {
407             data.put(&quot;DEPLOY_MAIN_JAR_NAME&quot;, MAIN_JAR.fetchFrom(params).
408                     getIncludedFiles().iterator().next());
409         }
410         else if (hasMainModule) {
411             data.put(&quot;DEPLOY_MODULE_NAME&quot;,
412                     StandardBundlerParam.MODULE.fetchFrom(params));
413         }
414 
415         StringBuilder sb = new StringBuilder();
416         List&lt;String&gt; jvmOptions = JAVA_OPTIONS.fetchFrom(params);
417 
418         String newline = &quot;&quot;; //So we don&#39;t add extra line after last append
419         for (String o : jvmOptions) {
420             sb.append(newline).append(
421                     &quot;    &lt;string&gt;&quot;).append(o).append(&quot;&lt;/string&gt;&quot;);
422             newline = &quot;\n&quot;;
423         }
424 
425         data.put(&quot;DEPLOY_JAVA_OPTIONS&quot;, sb.toString());
426 
427         sb = new StringBuilder();
428         List&lt;String&gt; args = ARGUMENTS.fetchFrom(params);
429         newline = &quot;&quot;;
430         // So we don&#39;t add unneccessary extra line after last append
431 
432         for (String o : args) {
433             sb.append(newline).append(&quot;    &lt;string&gt;&quot;).append(o).append(
434                     &quot;&lt;/string&gt;&quot;);
435             newline = &quot;\n&quot;;
436         }
437         data.put(&quot;DEPLOY_ARGUMENTS&quot;, sb.toString());
438 
439         newline = &quot;&quot;;
440 
441         data.put(&quot;DEPLOY_LAUNCHER_CLASS&quot;, MAIN_CLASS.fetchFrom(params));
442 
443         data.put(&quot;DEPLOY_APP_CLASSPATH&quot;,
444                   getCfgClassPath(CLASSPATH.fetchFrom(params)));
445 
446         StringBuilder bundleDocumentTypes = new StringBuilder();
447         StringBuilder exportedTypes = new StringBuilder();
448         for (Map&lt;String, ? super Object&gt;
449                 fileAssociation : FILE_ASSOCIATIONS.fetchFrom(params)) {
450 
451             List&lt;String&gt; extensions = FA_EXTENSIONS.fetchFrom(fileAssociation);
452 
453             if (extensions == null) {
454                 Log.verbose(I18N.getString(
455                         &quot;message.creating-association-with-null-extension&quot;));
456             }
457 
458             List&lt;String&gt; mimeTypes = FA_CONTENT_TYPE.fetchFrom(fileAssociation);
459             String itemContentType = MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params)
460                     + &quot;.&quot; + ((extensions == null || extensions.isEmpty())
461                     ? &quot;mime&quot; : extensions.get(0));
462             String description = FA_DESCRIPTION.fetchFrom(fileAssociation);
463             File icon = FA_ICON.fetchFrom(fileAssociation);
464 
465             bundleDocumentTypes.append(&quot;    &lt;dict&gt;\n&quot;)
466                     .append(&quot;      &lt;key&gt;LSItemContentTypes&lt;/key&gt;\n&quot;)
467                     .append(&quot;      &lt;array&gt;\n&quot;)
468                     .append(&quot;        &lt;string&gt;&quot;)
469                     .append(itemContentType)
470                     .append(&quot;&lt;/string&gt;\n&quot;)
471                     .append(&quot;      &lt;/array&gt;\n&quot;)
472                     .append(&quot;\n&quot;)
473                     .append(&quot;      &lt;key&gt;CFBundleTypeName&lt;/key&gt;\n&quot;)
474                     .append(&quot;      &lt;string&gt;&quot;)
475                     .append(description)
476                     .append(&quot;&lt;/string&gt;\n&quot;)
477                     .append(&quot;\n&quot;)
478                     .append(&quot;      &lt;key&gt;LSHandlerRank&lt;/key&gt;\n&quot;)
479                     .append(&quot;      &lt;string&gt;Owner&lt;/string&gt;\n&quot;)
480                             // TODO make a bundler arg
481                     .append(&quot;\n&quot;)
482                     .append(&quot;      &lt;key&gt;CFBundleTypeRole&lt;/key&gt;\n&quot;)
483                     .append(&quot;      &lt;string&gt;Editor&lt;/string&gt;\n&quot;)
484                             // TODO make a bundler arg
485                     .append(&quot;\n&quot;)
486                     .append(&quot;      &lt;key&gt;LSIsAppleDefaultForType&lt;/key&gt;\n&quot;)
487                     .append(&quot;      &lt;true/&gt;\n&quot;)
488                             // TODO make a bundler arg
489                     .append(&quot;\n&quot;);
490 
491             if (icon != null &amp;&amp; icon.exists()) {
492                 bundleDocumentTypes
493                         .append(&quot;      &lt;key&gt;CFBundleTypeIconFile&lt;/key&gt;\n&quot;)
494                         .append(&quot;      &lt;string&gt;&quot;)
495                         .append(icon.getName())
496                         .append(&quot;&lt;/string&gt;\n&quot;);
497             }
498             bundleDocumentTypes.append(&quot;    &lt;/dict&gt;\n&quot;);
499 
500             exportedTypes.append(&quot;    &lt;dict&gt;\n&quot;)
501                     .append(&quot;      &lt;key&gt;UTTypeIdentifier&lt;/key&gt;\n&quot;)
502                     .append(&quot;      &lt;string&gt;&quot;)
503                     .append(itemContentType)
504                     .append(&quot;&lt;/string&gt;\n&quot;)
505                     .append(&quot;\n&quot;)
506                     .append(&quot;      &lt;key&gt;UTTypeDescription&lt;/key&gt;\n&quot;)
507                     .append(&quot;      &lt;string&gt;&quot;)
508                     .append(description)
509                     .append(&quot;&lt;/string&gt;\n&quot;)
510                     .append(&quot;      &lt;key&gt;UTTypeConformsTo&lt;/key&gt;\n&quot;)
511                     .append(&quot;      &lt;array&gt;\n&quot;)
512                     .append(&quot;          &lt;string&gt;public.data&lt;/string&gt;\n&quot;)
513                             //TODO expose this?
514                     .append(&quot;      &lt;/array&gt;\n&quot;)
515                     .append(&quot;\n&quot;);
516 
517             if (icon != null &amp;&amp; icon.exists()) {
518                 exportedTypes.append(&quot;      &lt;key&gt;UTTypeIconFile&lt;/key&gt;\n&quot;)
519                         .append(&quot;      &lt;string&gt;&quot;)
520                         .append(icon.getName())
521                         .append(&quot;&lt;/string&gt;\n&quot;)
522                         .append(&quot;\n&quot;);
523             }
524 
525             exportedTypes.append(&quot;\n&quot;)
526                     .append(&quot;      &lt;key&gt;UTTypeTagSpecification&lt;/key&gt;\n&quot;)
527                     .append(&quot;      &lt;dict&gt;\n&quot;)
528                             // TODO expose via param? .append(
529                             // &quot;        &lt;key&gt;com.apple.ostype&lt;/key&gt;\n&quot;);
530                             // TODO expose via param? .append(
531                             // &quot;        &lt;string&gt;ABCD&lt;/string&gt;\n&quot;)
532                     .append(&quot;\n&quot;);
533 
534             if (extensions != null &amp;&amp; !extensions.isEmpty()) {
535                 exportedTypes.append(
536                         &quot;        &lt;key&gt;public.filename-extension&lt;/key&gt;\n&quot;)
537                         .append(&quot;        &lt;array&gt;\n&quot;);
538 
539                 for (String ext : extensions) {
540                     exportedTypes.append(&quot;          &lt;string&gt;&quot;)
541                             .append(ext)
542                             .append(&quot;&lt;/string&gt;\n&quot;);
543                 }
544                 exportedTypes.append(&quot;        &lt;/array&gt;\n&quot;);
545             }
546             if (mimeTypes != null &amp;&amp; !mimeTypes.isEmpty()) {
547                 exportedTypes.append(&quot;        &lt;key&gt;public.mime-type&lt;/key&gt;\n&quot;)
548                         .append(&quot;        &lt;array&gt;\n&quot;);
549 
550                 for (String mime : mimeTypes) {
551                     exportedTypes.append(&quot;          &lt;string&gt;&quot;)
552                             .append(mime)
553                             .append(&quot;&lt;/string&gt;\n&quot;);
554                 }
555                 exportedTypes.append(&quot;        &lt;/array&gt;\n&quot;);
556             }
557             exportedTypes.append(&quot;      &lt;/dict&gt;\n&quot;)
558                     .append(&quot;    &lt;/dict&gt;\n&quot;);
559         }
560         String associationData;
561         if (bundleDocumentTypes.length() &gt; 0) {
562             associationData =
563                     &quot;\n  &lt;key&gt;CFBundleDocumentTypes&lt;/key&gt;\n  &lt;array&gt;\n&quot;
564                     + bundleDocumentTypes.toString()
565                     + &quot;  &lt;/array&gt;\n\n&quot;
566                     + &quot;  &lt;key&gt;UTExportedTypeDeclarations&lt;/key&gt;\n  &lt;array&gt;\n&quot;
567                     + exportedTypes.toString()
568                     + &quot;  &lt;/array&gt;\n&quot;;
569         } else {
570             associationData = &quot;&quot;;
571         }
572         data.put(&quot;DEPLOY_FILE_ASSOCIATIONS&quot;, associationData);
573 
574         createResource(TEMPLATE_INFO_PLIST_LITE, params)
575                 .setCategory(I18N.getString(&quot;resource.app-info-plist&quot;))
576                 .setSubstitutionData(data)
577                 .setPublicName(&quot;Info.plist&quot;)
578                 .saveToFile(file);
579     }
580 
581     private void writePkgInfo(File file) throws IOException {
582         //hardcoded as it does not seem we need to change it ever
583         String signature = &quot;????&quot;;
584 
585         try (Writer out = Files.newBufferedWriter(file.toPath())) {
586             out.write(OS_TYPE_CODE + signature);
587             out.flush();
588         }
589     }
590 
591     public static void addNewKeychain(Map&lt;String, ? super Object&gt; params)
592                                     throws IOException, InterruptedException {
593         if (Platform.getMajorVersion() &lt; 10 ||
594                 (Platform.getMajorVersion() == 10 &amp;&amp;
595                 Platform.getMinorVersion() &lt; 12)) {
596             // we need this for OS X 10.12+
597             return;
598         }
599 
600         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
601         if (keyChain == null || keyChain.isEmpty()) {
602             return;
603         }
604 
605         // get current keychain list
606         String keyChainPath = new File (keyChain).getAbsolutePath().toString();
607         List&lt;String&gt; keychainList = new ArrayList&lt;&gt;();
608         int ret = IOUtils.getProcessOutput(
609                 keychainList, &quot;security&quot;, &quot;list-keychains&quot;);
610         if (ret != 0) {
611             Log.error(I18N.getString(&quot;message.keychain.error&quot;));
612             return;
613         }
614 
615         boolean contains = keychainList.stream().anyMatch(
616                     str -&gt; str.trim().equals(&quot;\&quot;&quot;+keyChainPath.trim()+&quot;\&quot;&quot;));
617         if (contains) {
618             // keychain is already added in the search list
619             return;
620         }
621 
622         keyChains = new ArrayList&lt;&gt;();
623         // remove &quot;
624         keychainList.forEach((String s) -&gt; {
625             String path = s.trim();
626             if (path.startsWith(&quot;\&quot;&quot;) &amp;&amp; path.endsWith(&quot;\&quot;&quot;)) {
627                 path = path.substring(1, path.length()-1);
628             }
629             keyChains.add(path);
630         });
631 
632         List&lt;String&gt; args = new ArrayList&lt;&gt;();
633         args.add(&quot;security&quot;);
634         args.add(&quot;list-keychains&quot;);
635         args.add(&quot;-s&quot;);
636 
637         args.addAll(keyChains);
638         args.add(keyChain);
639 
640         ProcessBuilder  pb = new ProcessBuilder(args);
641         IOUtils.exec(pb);
642     }
643 
644     public static void restoreKeychainList(Map&lt;String, ? super Object&gt; params)
645             throws IOException{
646         if (Platform.getMajorVersion() &lt; 10 ||
647                 (Platform.getMajorVersion() == 10 &amp;&amp;
648                 Platform.getMinorVersion() &lt; 12)) {
649             // we need this for OS X 10.12+
650             return;
651         }
652 
653         if (keyChains == null || keyChains.isEmpty()) {
654             return;
655         }
656 
657         List&lt;String&gt; args = new ArrayList&lt;&gt;();
658         args.add(&quot;security&quot;);
659         args.add(&quot;list-keychains&quot;);
660         args.add(&quot;-s&quot;);
661 
662         args.addAll(keyChains);
663 
664         ProcessBuilder  pb = new ProcessBuilder(args);
665         IOUtils.exec(pb);
666     }
667 
668     static void signAppBundle(
669             Map&lt;String, ? super Object&gt; params, Path appLocation,
670             String signingIdentity, String identifierPrefix, File entitlements)
671             throws IOException {
672         AtomicReference&lt;IOException&gt; toThrow = new AtomicReference&lt;&gt;();
673         String appExecutable = &quot;/Contents/MacOS/&quot; + APP_NAME.fetchFrom(params);
674         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
675 
676         // sign all dylibs and executables
677         try (Stream&lt;Path&gt; stream = Files.walk(appLocation)) {
678             stream.peek(path -&gt; { // fix permissions
679                 try {
680                     Set&lt;PosixFilePermission&gt; pfp =
681                             Files.getPosixFilePermissions(path);
682                     if (!pfp.contains(PosixFilePermission.OWNER_WRITE)) {
683                         pfp = EnumSet.copyOf(pfp);
684                         pfp.add(PosixFilePermission.OWNER_WRITE);
685                         Files.setPosixFilePermissions(path, pfp);
686                     }
687                 } catch (IOException e) {
688                     Log.verbose(e);
689                 }
690             }).filter(p -&gt; Files.isRegularFile(p) &amp;&amp;
691                       (Files.isExecutable(p) || p.toString().endsWith(&quot;.dylib&quot;))
692                       &amp;&amp; !(p.toString().endsWith(appExecutable)
693                       || p.toString().contains(&quot;/Contents/runtime&quot;)
694                       || p.toString().contains(&quot;/Contents/Frameworks&quot;))
695                      ).forEach(p -&gt; {
696                 // noinspection ThrowableResultOfMethodCallIgnored
697                 if (toThrow.get() != null) return;
698 
699                 // If p is a symlink then skip the signing process.
700                 if (Files.isSymbolicLink(p)) {
701                     Log.verbose(MessageFormat.format(I18N.getString(
702                             &quot;message.ignoring.symlink&quot;), p.toString()));
703                 } else if (isFileSigned(p)) {
704                     // executable or lib already signed
705                     Log.verbose(MessageFormat.format(I18N.getString(
706                             &quot;message.already.signed&quot;), p.toString()));
707                 } else {
708                     List&lt;String&gt; args = new ArrayList&lt;&gt;();
709                     args.addAll(Arrays.asList(&quot;codesign&quot;,
710                             &quot;--timestamp&quot;,
711                             &quot;--options&quot;, &quot;runtime&quot;,
712                             &quot;-s&quot;, signingIdentity,
713                             &quot;--prefix&quot;, identifierPrefix,
714                             &quot;-vvvv&quot;));
715                     if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
716                         args.add(&quot;--keychain&quot;);
717                         args.add(keyChain);
718                     }
719 
720                     if (Files.isExecutable(p)) {
721                         if (entitlements != null) {
722                             args.add(&quot;--entitlements&quot;);
723                             args.add(entitlements.toString());
724                         }
725                     }
726 
727                     args.add(p.toString());
728 
729                     try {
730                         Set&lt;PosixFilePermission&gt; oldPermissions =
731                                 Files.getPosixFilePermissions(p);
732                         File f = p.toFile();
733                         f.setWritable(true, true);
734 
735                         ProcessBuilder pb = new ProcessBuilder(args);
736 
737                         IOUtils.exec(pb);
738 
739                         Files.setPosixFilePermissions(p, oldPermissions);
740                     } catch (IOException ioe) {
741                         toThrow.set(ioe);
742                     }
743                 }
744             });
745         }
746         IOException ioe = toThrow.get();
747         if (ioe != null) {
748             throw ioe;
749         }
750 
751         // sign all runtime and frameworks
752         Consumer&lt;? super Path&gt; signIdentifiedByPList = path -&gt; {
753             //noinspection ThrowableResultOfMethodCallIgnored
754             if (toThrow.get() != null) return;
755 
756             try {
757                 List&lt;String&gt; args = new ArrayList&lt;&gt;();
758                 args.addAll(Arrays.asList(&quot;codesign&quot;,
759                         &quot;--timestamp&quot;,
760                         &quot;--options&quot;, &quot;runtime&quot;,
761                         &quot;--force&quot;,
762                         &quot;-s&quot;, signingIdentity, // sign with this key
763                         &quot;--prefix&quot;, identifierPrefix,
764                         // use the identifier as a prefix
765                         &quot;-vvvv&quot;));
766 
767                 if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
768                     args.add(&quot;--keychain&quot;);
769                     args.add(keyChain);
770                 }
771                 args.add(path.toString());
772                 ProcessBuilder pb = new ProcessBuilder(args);
773 
774                 IOUtils.exec(pb);
775             } catch (IOException e) {
776                 toThrow.set(e);
777             }
778         };
779 
780         Path javaPath = appLocation.resolve(&quot;Contents/runtime&quot;);
781         if (Files.isDirectory(javaPath)) {
782             signIdentifiedByPList.accept(javaPath);
783 
784             ioe = toThrow.get();
785             if (ioe != null) {
786                 throw ioe;
787             }
788         }
789         Path frameworkPath = appLocation.resolve(&quot;Contents/Frameworks&quot;);
790         if (Files.isDirectory(frameworkPath)) {
791             Files.list(frameworkPath)
792                     .forEach(signIdentifiedByPList);
793 
794             ioe = toThrow.get();
795             if (ioe != null) {
796                 throw ioe;
797             }
798         }
799 
800         // sign the app itself
801         List&lt;String&gt; args = new ArrayList&lt;&gt;();
802         args.addAll(Arrays.asList(&quot;codesign&quot;,
803                 &quot;--timestamp&quot;,
804                 &quot;--options&quot;, &quot;runtime&quot;,
805                 &quot;--force&quot;,
806                 &quot;-s&quot;, signingIdentity,
807                 &quot;-vvvv&quot;));
808 
809         if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
810             args.add(&quot;--keychain&quot;);
811             args.add(keyChain);
812         }
813 
814         if (entitlements != null) {
815             args.add(&quot;--entitlements&quot;);
816             args.add(entitlements.toString());
817         }
818 
819         args.add(appLocation.toString());
820 
821         ProcessBuilder pb =
822                 new ProcessBuilder(args.toArray(new String[args.size()]));
823 
824         IOUtils.exec(pb);
825     }
826 
827     private static boolean isFileSigned(Path file) {
828         ProcessBuilder pb =
829                 new ProcessBuilder(&quot;codesign&quot;, &quot;--verify&quot;, file.toString());
830 
831         try {
832             IOUtils.exec(pb);
833         } catch (IOException ex) {
834             return false;
835         }
836 
837         return true;
838     }
839 
840     private static String extractBundleIdentifier(Map&lt;String, Object&gt; params) {
841         if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {
842             return null;
843         }
844 
845         try {
846             File infoPList = new File(PREDEFINED_APP_IMAGE.fetchFrom(params) +
847                                       File.separator + &quot;Contents&quot; +
848                                       File.separator + &quot;Info.plist&quot;);
849 
850             DocumentBuilderFactory dbf
851                     = DocumentBuilderFactory.newDefaultInstance();
852             dbf.setFeature(&quot;http://apache.org/xml/features/&quot; +
853                            &quot;nonvalidating/load-external-dtd&quot;, false);
854             DocumentBuilder b = dbf.newDocumentBuilder();
855             org.w3c.dom.Document doc = b.parse(new FileInputStream(
856                     infoPList.getAbsolutePath()));
857 
858             XPath xPath = XPathFactory.newInstance().newXPath();
859             // Query for the value of &lt;string&gt; element preceding &lt;key&gt;
860             // element with value equal to CFBundleIdentifier
861             String v = (String) xPath.evaluate(
862                     &quot;//string[preceding-sibling::key = \&quot;CFBundleIdentifier\&quot;][1]&quot;,
863                     doc, XPathConstants.STRING);
864 
865             if (v != null &amp;&amp; !v.isEmpty()) {
866                 return v;
867             }
868         } catch (Exception ex) {
869             Log.verbose(ex);
870         }
871 
872         return null;
873     }
874 
875 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.jpackage/windows/classes/jdk/incubator/jpackage/internal/WinMsiBundler.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.File;
 29 import java.io.FileInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.Writer;
 33 import java.nio.charset.Charset;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.Files;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.text.MessageFormat;
 39 import java.util.Arrays;
 40 import java.util.HashMap;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.UUID;
 44 import java.util.stream.Collectors;
 45 import java.util.stream.Stream;
 46 
 47 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 48 import static jdk.incubator.jpackage.internal.StandardBundlerParam.APP_NAME;
 49 import static jdk.incubator.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;
 50 import static jdk.incubator.jpackage.internal.StandardBundlerParam.DESCRIPTION;
 51 import static jdk.incubator.jpackage.internal.StandardBundlerParam.FA_CONTENT_TYPE;
 52 import static jdk.incubator.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;
 53 import static jdk.incubator.jpackage.internal.StandardBundlerParam.LICENSE_FILE;
 54 import static jdk.incubator.jpackage.internal.StandardBundlerParam.TEMP_ROOT;
 55 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VENDOR;
 56 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VERSION;
 57 import static jdk.incubator.jpackage.internal.WindowsBundlerParam.INSTALLDIR_CHOOSER;
 58 import static jdk.incubator.jpackage.internal.WindowsBundlerParam.INSTALLER_FILE_NAME;
 59 
 60 /**
 61  * WinMsiBundler
 62  *
 63  * Produces .msi installer from application image. Uses WiX Toolkit to build
 64  * .msi installer.
 65  * &lt;p&gt;
 66  * {@link #execute} method creates a number of source files with the description
 67  * of installer to be processed by WiX tools. Generated source files are stored
 68  * in &quot;config&quot; subdirectory next to &quot;app&quot; subdirectory in the root work
 69  * directory. The following WiX source files are generated:
 70  * &lt;ul&gt;
 71  * &lt;li&gt;main.wxs. Main source file with the installer description
 72  * &lt;li&gt;bundle.wxf. Source file with application and Java run-time directory tree
 73  * description.
 74  * &lt;/ul&gt;
 75  * &lt;p&gt;
 76  * main.wxs file is a copy of main.wxs resource from
 77  * jdk.incubator.jpackage.internal.resources package. It is parametrized with the
 78  * following WiX variables:
 79  * &lt;ul&gt;
 80  * &lt;li&gt;JpAppName. Name of the application. Set to the value of --name command
 81  * line option
 82  * &lt;li&gt;JpAppVersion. Version of the application. Set to the value of
 83  * --app-version command line option
 84  * &lt;li&gt;JpAppVendor. Vendor of the application. Set to the value of --vendor
 85  * command line option
 86  * &lt;li&gt;JpAppDescription. Description of the application. Set to the value of
 87  * --description command line option
 88  * &lt;li&gt;JpProductCode. Set to product code UUID of the application. Random value
 89  * generated by jpackage every time {@link #execute} method is called
 90  * &lt;li&gt;JpProductUpgradeCode. Set to upgrade code UUID of the application. Random
 91  * value generated by jpackage every time {@link #execute} method is called if
 92  * --win-upgrade-uuid command line option is not specified. Otherwise this
 93  * variable is set to the value of --win-upgrade-uuid command line option
 94  * &lt;li&gt;JpAllowDowngrades. Set to &quot;yes&quot; if --win-upgrade-uuid command line option
 95  * was specified. Undefined otherwise
 96  * &lt;li&gt;JpLicenseRtf. Set to the value of --license-file command line option.
 97  * Undefined is --license-file command line option was not specified
 98  * &lt;li&gt;JpInstallDirChooser. Set to &quot;yes&quot; if --win-dir-chooser command line
 99  * option was specified. Undefined otherwise
100  * &lt;li&gt;JpConfigDir. Absolute path to the directory with generated WiX source
101  * files.
102  * &lt;li&gt;JpIsSystemWide. Set to &quot;yes&quot; if --win-per-user-install command line
103  * option was not specified. Undefined otherwise
104  * &lt;/ul&gt;
105  */
106 public class WinMsiBundler  extends AbstractBundler {
107 
108     public static final BundlerParamInfo&lt;WinAppBundler&gt; APP_BUNDLER =
109             new WindowsBundlerParam&lt;&gt;(
110             &quot;win.app.bundler&quot;,
111             WinAppBundler.class,
112             params -&gt; new WinAppBundler(),
113             null);
114 
115     public static final BundlerParamInfo&lt;File&gt; MSI_IMAGE_DIR =
116             new WindowsBundlerParam&lt;&gt;(
117             &quot;win.msi.imageDir&quot;,
118             File.class,
119             params -&gt; {
120                 File imagesRoot = IMAGES_ROOT.fetchFrom(params);
121                 if (!imagesRoot.exists()) imagesRoot.mkdirs();
122                 return new File(imagesRoot, &quot;win-msi.image&quot;);
123             },
124             (s, p) -&gt; null);
125 
126     public static final BundlerParamInfo&lt;File&gt; WIN_APP_IMAGE =
127             new WindowsBundlerParam&lt;&gt;(
128             &quot;win.app.image&quot;,
129             File.class,
130             null,
131             (s, p) -&gt; null);
132 
133     public static final StandardBundlerParam&lt;Boolean&gt; MSI_SYSTEM_WIDE  =
134             new StandardBundlerParam&lt;&gt;(
135                     Arguments.CLIOptions.WIN_PER_USER_INSTALLATION.getId(),
136                     Boolean.class,
137                     params -&gt; true, // MSIs default to system wide
138                     // valueOf(null) is false,
139                     // and we actually do want null
140                     (s, p) -&gt; (s == null || &quot;null&quot;.equalsIgnoreCase(s))? null
141                             : Boolean.valueOf(s)
142             );
143 
144 
145     public static final StandardBundlerParam&lt;String&gt; PRODUCT_VERSION =
146             new StandardBundlerParam&lt;&gt;(
147                     &quot;win.msi.productVersion&quot;,
148                     String.class,
149                     VERSION::fetchFrom,
150                     (s, p) -&gt; s
151             );
152 
153     private static final BundlerParamInfo&lt;String&gt; UPGRADE_UUID =
154             new WindowsBundlerParam&lt;&gt;(
155             Arguments.CLIOptions.WIN_UPGRADE_UUID.getId(),
156             String.class,
157             null,
158             (s, p) -&gt; s);
159 
160     @Override
161     public String getName() {
162         return I18N.getString(&quot;msi.bundler.name&quot;);
163     }
164 
165     @Override
166     public String getID() {
167         return &quot;msi&quot;;
168     }
169 
170     @Override
171     public String getBundleType() {
172         return &quot;INSTALLER&quot;;
173     }
174 
175     @Override
176     public File execute(Map&lt;String, ? super Object&gt; params,
177             File outputParentDir) throws PackagerException {
178         return bundle(params, outputParentDir);
179     }
180 
181     @Override
182     public boolean supported(boolean platformInstaller) {
183         try {
184             if (wixToolset == null) {
185                 wixToolset = WixTool.toolset();
186             }
187             return true;
188         } catch (ConfigException ce) {
189             Log.error(ce.getMessage());
190             if (ce.getAdvice() != null) {
191                 Log.error(ce.getAdvice());
192             }
193         } catch (Exception e) {
194             Log.error(e.getMessage());
195         }
196         return false;
197     }
198 
199     @Override
200     public boolean isDefault() {
201         return false;
202     }
203 
204     private static UUID getUpgradeCode(Map&lt;String, ? super Object&gt; params) {
205         String upgradeCode = UPGRADE_UUID.fetchFrom(params);
206         if (upgradeCode != null) {
207             return UUID.fromString(upgradeCode);
208         }
209         return createNameUUID(&quot;UpgradeCode&quot;, params, List.of(VENDOR, APP_NAME));
210     }
211 
212     private static UUID getProductCode(Map&lt;String, ? super Object&gt; params) {
213         return createNameUUID(&quot;ProductCode&quot;, params, List.of(VENDOR, APP_NAME,
214                 VERSION));
215     }
216 
217     private static UUID createNameUUID(String prefix,
218             Map&lt;String, ? super Object&gt; params,
219             List&lt;StandardBundlerParam&lt;String&gt;&gt; components) {
220         String key = Stream.concat(Stream.of(prefix), components.stream().map(
221                 c -&gt; c.fetchFrom(params))).collect(Collectors.joining(&quot;/&quot;));
222         return UUID.nameUUIDFromBytes(key.getBytes(StandardCharsets.UTF_8));
223     }
224 
225     @Override
226     public boolean validate(Map&lt;String, ? super Object&gt; params)
227             throws ConfigException {
228         try {
229             if (wixToolset == null) {
230                 wixToolset = WixTool.toolset();
231             }
232 
233             try {
234                 getUpgradeCode(params);
235             } catch (IllegalArgumentException ex) {
236                 throw new ConfigException(ex);
237             }
238 
239             for (var toolInfo: wixToolset.values()) {
240                 Log.verbose(MessageFormat.format(I18N.getString(
241                         &quot;message.tool-version&quot;), toolInfo.path.getFileName(),
242                         toolInfo.version));
243             }
244 
245             wixSourcesBuilder.setWixVersion(wixToolset.get(WixTool.Light).version);
246 
247             wixSourcesBuilder.logWixFeatures();
248 
249             /********* validate bundle parameters *************/
250 
<a name="1" id="anc1"></a><span class="line-modified">251             String version = PRODUCT_VERSION.fetchFrom(params);</span>
<span class="line-modified">252             if (!isVersionStringValid(version)) {</span>
<span class="line-modified">253                 throw new ConfigException(</span>
<span class="line-modified">254                         MessageFormat.format(I18N.getString(</span>
<span class="line-modified">255                                 &quot;error.version-string-wrong-format&quot;), version),</span>
<span class="line-modified">256                         MessageFormat.format(I18N.getString(</span>
<span class="line-removed">257                                 &quot;error.version-string-wrong-format.advice&quot;),</span>
<span class="line-removed">258                                 PRODUCT_VERSION.getID()));</span>
259             }
260 
261             FileAssociation.verify(FileAssociation.fetchFrom(params));
262 
263             return true;
264         } catch (RuntimeException re) {
265             if (re.getCause() instanceof ConfigException) {
266                 throw (ConfigException) re.getCause();
267             } else {
268                 throw new ConfigException(re);
269             }
270         }
271     }
272 
<a name="2" id="anc2"></a><span class="line-removed">273     // https://msdn.microsoft.com/en-us/library/aa370859%28v=VS.85%29.aspx</span>
<span class="line-removed">274     // The format of the string is as follows:</span>
<span class="line-removed">275     //     major.minor.build</span>
<span class="line-removed">276     // The first field is the major version and has a maximum value of 255.</span>
<span class="line-removed">277     // The second field is the minor version and has a maximum value of 255.</span>
<span class="line-removed">278     // The third field is called the build version or the update version and</span>
<span class="line-removed">279     // has a maximum value of 65,535.</span>
<span class="line-removed">280     static boolean isVersionStringValid(String v) {</span>
<span class="line-removed">281         if (v == null) {</span>
<span class="line-removed">282             return true;</span>
<span class="line-removed">283         }</span>
<span class="line-removed">284 </span>
<span class="line-removed">285         String p[] = v.split(&quot;\\.&quot;);</span>
<span class="line-removed">286         if (p.length &gt; 3) {</span>
<span class="line-removed">287             Log.verbose(I18N.getString(</span>
<span class="line-removed">288                     &quot;message.version-string-too-many-components&quot;));</span>
<span class="line-removed">289             return false;</span>
<span class="line-removed">290         }</span>
<span class="line-removed">291 </span>
<span class="line-removed">292         try {</span>
<span class="line-removed">293             int val = Integer.parseInt(p[0]);</span>
<span class="line-removed">294             if (val &lt; 0 || val &gt; 255) {</span>
<span class="line-removed">295                 Log.verbose(I18N.getString(</span>
<span class="line-removed">296                         &quot;error.version-string-major-out-of-range&quot;));</span>
<span class="line-removed">297                 return false;</span>
<span class="line-removed">298             }</span>
<span class="line-removed">299             if (p.length &gt; 1) {</span>
<span class="line-removed">300                 val = Integer.parseInt(p[1]);</span>
<span class="line-removed">301                 if (val &lt; 0 || val &gt; 255) {</span>
<span class="line-removed">302                     Log.verbose(I18N.getString(</span>
<span class="line-removed">303                             &quot;error.version-string-minor-out-of-range&quot;));</span>
<span class="line-removed">304                     return false;</span>
<span class="line-removed">305                 }</span>
<span class="line-removed">306             }</span>
<span class="line-removed">307             if (p.length &gt; 2) {</span>
<span class="line-removed">308                 val = Integer.parseInt(p[2]);</span>
<span class="line-removed">309                 if (val &lt; 0 || val &gt; 65535) {</span>
<span class="line-removed">310                     Log.verbose(I18N.getString(</span>
<span class="line-removed">311                             &quot;error.version-string-build-out-of-range&quot;));</span>
<span class="line-removed">312                     return false;</span>
<span class="line-removed">313                 }</span>
<span class="line-removed">314             }</span>
<span class="line-removed">315         } catch (NumberFormatException ne) {</span>
<span class="line-removed">316             Log.verbose(I18N.getString(&quot;error.version-string-part-not-number&quot;));</span>
<span class="line-removed">317             Log.verbose(ne);</span>
<span class="line-removed">318             return false;</span>
<span class="line-removed">319         }</span>
<span class="line-removed">320 </span>
<span class="line-removed">321         return true;</span>
<span class="line-removed">322     }</span>
<span class="line-removed">323 </span>
324     private void prepareProto(Map&lt;String, ? super Object&gt; params)
325                 throws PackagerException, IOException {
326         File appImage = StandardBundlerParam.getPredefinedAppImage(params);
327         File appDir = null;
328 
329         // we either have an application image or need to build one
330         if (appImage != null) {
331             appDir = new File(MSI_IMAGE_DIR.fetchFrom(params),
332                     APP_NAME.fetchFrom(params));
333             // copy everything from appImage dir into appDir/name
334             IOUtils.copyRecursive(appImage.toPath(), appDir.toPath());
335         } else {
336             appDir = APP_BUNDLER.fetchFrom(params).doBundle(params,
337                     MSI_IMAGE_DIR.fetchFrom(params), true);
338         }
339 
340         // Configure installer icon
341         if (StandardBundlerParam.isRuntimeInstaller(params)) {
342             // Use icon from java launcher.
343             // Assume java.exe exists in Java Runtime being packed.
344             // Ignore custom icon if any as we don&#39;t want to copy anything in
345             // Java Runtime image.
346             installerIcon = ApplicationLayout.javaRuntime()
347                     .runtimeDirectory()
348                     .resolve(Path.of(&quot;bin&quot;, &quot;java.exe&quot;));
349         } else {
350             installerIcon = ApplicationLayout.windowsAppImage()
351                     .launchersDirectory()
352                     .resolve(APP_NAME.fetchFrom(params) + &quot;.exe&quot;);
353         }
354 
355         params.put(WIN_APP_IMAGE.getID(), appDir);
356 
357         String licenseFile = LICENSE_FILE.fetchFrom(params);
358         if (licenseFile != null) {
359             // need to copy license file to the working directory
360             // and convert to rtf if needed
361             File lfile = new File(licenseFile);
362             File destFile = new File(CONFIG_ROOT.fetchFrom(params),
363                     lfile.getName());
364 
365             IOUtils.copyFile(lfile, destFile);
366             destFile.setWritable(true);
367             ensureByMutationFileIsRTF(destFile);
368         }
369     }
370 
371     public File bundle(Map&lt;String, ? super Object&gt; params, File outdir)
372             throws PackagerException {
373 
374         IOUtils.writableOutputDir(outdir.toPath());
375 
376         Path imageDir = MSI_IMAGE_DIR.fetchFrom(params).toPath();
377         try {
378             Files.createDirectories(imageDir);
379 
380             prepareProto(params);
381 
382             wixSourcesBuilder
383             .initFromParams(WIN_APP_IMAGE.fetchFrom(params).toPath(), params)
384             .createMainFragment(CONFIG_ROOT.fetchFrom(params).toPath().resolve(
385                     &quot;bundle.wxf&quot;));
386 
387             Map&lt;String, String&gt; wixVars = prepareMainProjectFile(params);
388 
389             new ScriptRunner()
390             .setDirectory(imageDir)
391             .setResourceCategoryId(&quot;resource.post-app-image-script&quot;)
392             .setScriptNameSuffix(&quot;post-image&quot;)
393             .setEnvironmentVariable(&quot;JpAppImageDir&quot;, imageDir.toAbsolutePath().toString())
394             .run(params);
395 
396             return buildMSI(params, wixVars, outdir);
397         } catch (IOException ex) {
398             Log.verbose(ex);
399             throw new PackagerException(ex);
400         }
401     }
402 
403     Map&lt;String, String&gt; prepareMainProjectFile(
404             Map&lt;String, ? super Object&gt; params) throws IOException {
405         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
406 
407         final UUID productCode = getProductCode(params);
408         final UUID upgradeCode = getUpgradeCode(params);
409 
410         data.put(&quot;JpProductCode&quot;, productCode.toString());
411         data.put(&quot;JpProductUpgradeCode&quot;, upgradeCode.toString());
412 
413         Log.verbose(MessageFormat.format(I18N.getString(&quot;message.product-code&quot;),
414                 productCode));
415         Log.verbose(MessageFormat.format(I18N.getString(&quot;message.upgrade-code&quot;),
416                 upgradeCode));
417 
418         data.put(&quot;JpAllowUpgrades&quot;, &quot;yes&quot;);
419         data.put(&quot;JpAllowDowngrades&quot;, &quot;yes&quot;);
420 
421         data.put(&quot;JpAppName&quot;, APP_NAME.fetchFrom(params));
422         data.put(&quot;JpAppDescription&quot;, DESCRIPTION.fetchFrom(params));
423         data.put(&quot;JpAppVendor&quot;, VENDOR.fetchFrom(params));
424         data.put(&quot;JpAppVersion&quot;, PRODUCT_VERSION.fetchFrom(params));
425         data.put(&quot;JpIcon&quot;, installerIcon.toString());
426 
427         final Path configDir = CONFIG_ROOT.fetchFrom(params).toPath();
428 
429         data.put(&quot;JpConfigDir&quot;, configDir.toAbsolutePath().toString());
430 
431         if (MSI_SYSTEM_WIDE.fetchFrom(params)) {
432             data.put(&quot;JpIsSystemWide&quot;, &quot;yes&quot;);
433         }
434 
435         String licenseFile = LICENSE_FILE.fetchFrom(params);
436         if (licenseFile != null) {
437             String lname = new File(licenseFile).getName();
438             File destFile = new File(CONFIG_ROOT.fetchFrom(params), lname);
439             data.put(&quot;JpLicenseRtf&quot;, destFile.getAbsolutePath());
440         }
441 
442         // Copy CA dll to include with installer
443         if (INSTALLDIR_CHOOSER.fetchFrom(params)) {
444             data.put(&quot;JpInstallDirChooser&quot;, &quot;yes&quot;);
445             String fname = &quot;wixhelper.dll&quot;;
446             try (InputStream is = OverridableResource.readDefault(fname)) {
447                 Files.copy(is, Paths.get(
448                         CONFIG_ROOT.fetchFrom(params).getAbsolutePath(),
449                         fname));
450             }
451         }
452 
453         // Copy l10n files.
454         for (String loc : Arrays.asList(&quot;en&quot;, &quot;ja&quot;, &quot;zh_CN&quot;)) {
455             String fname = &quot;MsiInstallerStrings_&quot; + loc + &quot;.wxl&quot;;
456             try (InputStream is = OverridableResource.readDefault(fname)) {
457                 Files.copy(is, Paths.get(
458                         CONFIG_ROOT.fetchFrom(params).getAbsolutePath(),
459                         fname));
460             }
461         }
462 
463         createResource(&quot;main.wxs&quot;, params)
464                 .setCategory(I18N.getString(&quot;resource.main-wix-file&quot;))
465                 .saveToFile(configDir.resolve(&quot;main.wxs&quot;));
466 
467         createResource(&quot;overrides.wxi&quot;, params)
468                 .setCategory(I18N.getString(&quot;resource.overrides-wix-file&quot;))
469                 .saveToFile(configDir.resolve(&quot;overrides.wxi&quot;));
470 
471         return data;
472     }
473 
474     private File buildMSI(Map&lt;String, ? super Object&gt; params,
475             Map&lt;String, String&gt; wixVars, File outdir)
476             throws IOException {
477 
478         File msiOut = new File(
479                 outdir, INSTALLER_FILE_NAME.fetchFrom(params) + &quot;.msi&quot;);
480 
481         Log.verbose(MessageFormat.format(I18N.getString(
482                 &quot;message.preparing-msi-config&quot;), msiOut.getAbsolutePath()));
483 
484         WixPipeline wixPipeline = new WixPipeline()
485         .setToolset(wixToolset.entrySet().stream().collect(
486                 Collectors.toMap(
487                         entry -&gt; entry.getKey(),
488                         entry -&gt; entry.getValue().path)))
489         .setWixObjDir(TEMP_ROOT.fetchFrom(params).toPath().resolve(&quot;wixobj&quot;))
490         .setWorkDir(WIN_APP_IMAGE.fetchFrom(params).toPath())
491         .addSource(CONFIG_ROOT.fetchFrom(params).toPath().resolve(&quot;main.wxs&quot;), wixVars)
492         .addSource(CONFIG_ROOT.fetchFrom(params).toPath().resolve(&quot;bundle.wxf&quot;), null);
493 
494         Log.verbose(MessageFormat.format(I18N.getString(
495                 &quot;message.generating-msi&quot;), msiOut.getAbsolutePath()));
496 
497         boolean enableLicenseUI = (LICENSE_FILE.fetchFrom(params) != null);
498         boolean enableInstalldirUI = INSTALLDIR_CHOOSER.fetchFrom(params);
499 
500         if (!MSI_SYSTEM_WIDE.fetchFrom(params)) {
501             wixPipeline.addLightOptions(&quot;-sice:ICE91&quot;);
502         }
503         if (enableLicenseUI || enableInstalldirUI) {
504             wixPipeline.addLightOptions(&quot;-ext&quot;, &quot;WixUIExtension&quot;);
505         }
506 
507         wixPipeline.addLightOptions(&quot;-loc&quot;,
508                 CONFIG_ROOT.fetchFrom(params).toPath().resolve(I18N.getString(
509                         &quot;resource.wxl-file-name&quot;)).toAbsolutePath().toString());
510 
511         // Only needed if we using CA dll, so Wix can find it
512         if (enableInstalldirUI) {
513             wixPipeline.addLightOptions(&quot;-b&quot;, CONFIG_ROOT.fetchFrom(params).getAbsolutePath());
514         }
515 
516         wixPipeline.buildMsi(msiOut.toPath().toAbsolutePath());
517 
518         return msiOut;
519     }
520 
521     public static void ensureByMutationFileIsRTF(File f) {
522         if (f == null || !f.isFile()) return;
523 
524         try {
525             boolean existingLicenseIsRTF = false;
526 
527             try (FileInputStream fin = new FileInputStream(f)) {
528                 byte[] firstBits = new byte[7];
529 
530                 if (fin.read(firstBits) == firstBits.length) {
531                     String header = new String(firstBits);
532                     existingLicenseIsRTF = &quot;{\\rtf1\\&quot;.equals(header);
533                 }
534             }
535 
536             if (!existingLicenseIsRTF) {
537                 List&lt;String&gt; oldLicense = Files.readAllLines(f.toPath());
538                 try (Writer w = Files.newBufferedWriter(
539                         f.toPath(), Charset.forName(&quot;Windows-1252&quot;))) {
540                     w.write(&quot;{\\rtf1\\ansi\\ansicpg1252\\deff0\\deflang1033&quot;
541                             + &quot;{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\n&quot;
542                             + &quot;\\viewkind4\\uc1\\pard\\sa200\\sl276&quot;
543                             + &quot;\\slmult1\\lang9\\fs20 &quot;);
544                     oldLicense.forEach(l -&gt; {
545                         try {
546                             for (char c : l.toCharArray()) {
547                                 // 0x00 &lt;= ch &lt; 0x20 Escaped (\&#39;hh)
548                                 // 0x20 &lt;= ch &lt; 0x80 Raw(non - escaped) char
549                                 // 0x80 &lt;= ch &lt;= 0xFF Escaped(\ &#39;hh)
550                                 // 0x5C, 0x7B, 0x7D (special RTF characters
551                                 // \,{,})Escaped(\&#39;hh)
552                                 // ch &gt; 0xff Escaped (\\ud###?)
553                                 if (c &lt; 0x10) {
554                                     w.write(&quot;\\&#39;0&quot;);
555                                     w.write(Integer.toHexString(c));
556                                 } else if (c &gt; 0xff) {
557                                     w.write(&quot;\\ud&quot;);
558                                     w.write(Integer.toString(c));
559                                     // \\uc1 is in the header and in effect
560                                     // so we trail with a replacement char if
561                                     // the font lacks that character - &#39;?&#39;
562                                     w.write(&quot;?&quot;);
563                                 } else if ((c &lt; 0x20) || (c &gt;= 0x80) ||
564                                         (c == 0x5C) || (c == 0x7B) ||
565                                         (c == 0x7D)) {
566                                     w.write(&quot;\\&#39;&quot;);
567                                     w.write(Integer.toHexString(c));
568                                 } else {
569                                     w.write(c);
570                                 }
571                             }
572                             // blank lines are interpreted as paragraph breaks
573                             if (l.length() &lt; 1) {
574                                 w.write(&quot;\\par&quot;);
575                             } else {
576                                 w.write(&quot; &quot;);
577                             }
578                             w.write(&quot;\r\n&quot;);
579                         } catch (IOException e) {
580                             Log.verbose(e);
581                         }
582                     });
583                     w.write(&quot;}\r\n&quot;);
584                 }
585             }
586         } catch (IOException e) {
587             Log.verbose(e);
588         }
589 
590     }
591 
592     private Path installerIcon;
593     private Map&lt;WixTool, WixTool.ToolInfo&gt; wixToolset;
594     private WixSourcesBuilder wixSourcesBuilder = new WixSourcesBuilder();
595 
596 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
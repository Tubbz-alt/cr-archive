<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/Finished.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.GeneralSecurityException;
  31 import java.security.InvalidKeyException;
  32 import java.security.MessageDigest;
  33 import java.security.NoSuchAlgorithmException;
  34 import java.security.ProviderException;
  35 import java.security.spec.AlgorithmParameterSpec;
  36 import java.text.MessageFormat;
  37 import java.util.Locale;
  38 import javax.crypto.KeyGenerator;
  39 import javax.crypto.Mac;
  40 import javax.crypto.SecretKey;
  41 import javax.crypto.spec.IvParameterSpec;
  42 import javax.crypto.spec.SecretKeySpec;
  43 import javax.net.ssl.SSLPeerUnverifiedException;
  44 
  45 import jdk.internal.event.EventHelper;
  46 import jdk.internal.event.TLSHandshakeEvent;
  47 import sun.security.internal.spec.TlsPrfParameterSpec;
  48 import sun.security.ssl.CipherSuite.HashAlg;
  49 import static sun.security.ssl.CipherSuite.HashAlg.H_NONE;
  50 import sun.security.ssl.SSLBasicKeyDerivation.SecretSizeSpec;
  51 import sun.security.ssl.SSLCipher.SSLReadCipher;
  52 import sun.security.ssl.SSLCipher.SSLWriteCipher;
  53 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  54 import sun.security.util.HexDumpEncoder;
  55 
  56 /**
  57  * Pack of the Finished handshake message.
  58  */
  59 final class Finished {
  60     static final SSLConsumer t12HandshakeConsumer =
  61         new T12FinishedConsumer();
  62     static final HandshakeProducer t12HandshakeProducer =
  63         new T12FinishedProducer();
  64 
  65     static final SSLConsumer t13HandshakeConsumer =
  66         new T13FinishedConsumer();
  67     static final HandshakeProducer t13HandshakeProducer =
  68         new T13FinishedProducer();
  69 
  70     /**
  71      * The Finished handshake message.
  72      */
  73     private static final class FinishedMessage extends HandshakeMessage {
  74         private final byte[] verifyData;
  75 
  76         FinishedMessage(HandshakeContext context) throws IOException {
  77             super(context);
  78 
  79             VerifyDataScheme vds =
  80                     VerifyDataScheme.valueOf(context.negotiatedProtocol);
  81 
  82             byte[] vd = null;
  83             try {
  84                 vd = vds.createVerifyData(context, false);
  85             } catch (IOException ioe) {
  86                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
  87                         &quot;Failed to generate verify_data&quot;, ioe);
  88             }
  89 
  90             this.verifyData = vd;
  91         }
  92 
  93         FinishedMessage(HandshakeContext context,
  94                 ByteBuffer m) throws IOException {
  95             super(context);
  96             int verifyDataLen = 12;
  97             if (context.negotiatedProtocol == ProtocolVersion.SSL30) {
  98                 verifyDataLen = 36;
  99             } else if (context.negotiatedProtocol.useTLS13PlusSpec()) {
 100                 verifyDataLen =
 101                         context.negotiatedCipherSuite.hashAlg.hashLength;
 102             }
 103 
 104             if (m.remaining() != verifyDataLen) {
 105                 throw context.conContext.fatal(Alert.DECODE_ERROR,
 106                     &quot;Inappropriate finished message: need &quot; + verifyDataLen +
 107                     &quot; but remaining &quot; + m.remaining() + &quot; bytes verify_data&quot;);
 108             }
 109 
 110             this.verifyData = new byte[verifyDataLen];
 111             m.get(verifyData);
 112 
 113             VerifyDataScheme vd =
 114                     VerifyDataScheme.valueOf(context.negotiatedProtocol);
 115             byte[] myVerifyData;
 116             try {
 117                 myVerifyData = vd.createVerifyData(context, true);
 118             } catch (IOException ioe) {
 119                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 120                         &quot;Failed to generate verify_data&quot;, ioe);
 121             }
 122             if (!MessageDigest.isEqual(myVerifyData, verifyData)) {
 123                 throw context.conContext.fatal(Alert.DECRYPT_ERROR,
 124                         &quot;The Finished message cannot be verified.&quot;);
 125             }
 126         }
 127 
 128         @Override
 129         public SSLHandshake handshakeType() {
 130             return SSLHandshake.FINISHED;
 131         }
 132 
 133         @Override
 134         public int messageLength() {
 135             return verifyData.length;
 136         }
 137 
 138         @Override
 139         public void send(HandshakeOutStream hos) throws IOException {
 140             hos.write(verifyData);
 141         }
 142 
 143         @Override
 144         public String toString() {
 145             MessageFormat messageFormat = new MessageFormat(
 146                     &quot;\&quot;Finished\&quot;: &#39;{&#39;\n&quot; +
 147                     &quot;  \&quot;verify data\&quot;: &#39;{&#39;\n&quot; +
 148                     &quot;{0}\n&quot; +
 149                     &quot;  &#39;}&#39;&quot; +
 150                     &quot;&#39;}&#39;&quot;,
 151                     Locale.ENGLISH);
 152 
 153             HexDumpEncoder hexEncoder = new HexDumpEncoder();
 154             Object[] messageFields = {
 155                     Utilities.indent(hexEncoder.encode(verifyData), &quot;    &quot;),
 156                 };
 157             return messageFormat.format(messageFields);
 158         }
 159     }
 160 
 161     interface VerifyDataGenerator {
 162         byte[] createVerifyData(HandshakeContext context,
 163                 boolean isValidation) throws IOException;
 164     }
 165 
 166     enum VerifyDataScheme {
 167         SSL30       (&quot;kdf_ssl30&quot;, new S30VerifyDataGenerator()),
 168         TLS10       (&quot;kdf_tls10&quot;, new T10VerifyDataGenerator()),
 169         TLS12       (&quot;kdf_tls12&quot;, new T12VerifyDataGenerator()),
 170         TLS13       (&quot;kdf_tls13&quot;, new T13VerifyDataGenerator());
 171 
 172         final String name;
 173         final VerifyDataGenerator generator;
 174 
 175         VerifyDataScheme(String name, VerifyDataGenerator verifyDataGenerator) {
 176             this.name = name;
 177             this.generator = verifyDataGenerator;
 178         }
 179 
 180         static VerifyDataScheme valueOf(ProtocolVersion protocolVersion) {
 181             switch (protocolVersion) {
 182                 case SSL30:
 183                     return VerifyDataScheme.SSL30;
 184                 case TLS10:
 185                 case TLS11:
 186                 case DTLS10:
 187                     return VerifyDataScheme.TLS10;
 188                 case TLS12:
 189                 case DTLS12:
 190                     return VerifyDataScheme.TLS12;
 191                 case TLS13:
 192                     return VerifyDataScheme.TLS13;
 193                 default:
 194                     return null;
 195             }
 196         }
 197 
 198         public byte[] createVerifyData(HandshakeContext context,
 199                 boolean isValidation) throws IOException {
 200             if (generator != null) {
 201                 return generator.createVerifyData(context, isValidation);
 202             }
 203 
 204             throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
 205         }
 206     }
 207 
 208     // SSL 3.0
 209     private static final
 210             class S30VerifyDataGenerator implements VerifyDataGenerator {
 211         @Override
 212         public byte[] createVerifyData(HandshakeContext context,
 213                 boolean isValidation) throws IOException {
 214             HandshakeHash handshakeHash = context.handshakeHash;
 215             SecretKey masterSecretKey =
 216                     context.handshakeSession.getMasterSecret();
 217 
 218             boolean useClientLabel =
 219                     (context.sslConfig.isClientMode &amp;&amp; !isValidation) ||
 220                     (!context.sslConfig.isClientMode &amp;&amp; isValidation);
 221             return handshakeHash.digest(useClientLabel, masterSecretKey);
 222         }
 223     }
 224 
 225     // TLS 1.0, TLS 1.1, DTLS 1.0
 226     private static final
 227             class T10VerifyDataGenerator implements VerifyDataGenerator {
 228         @Override
 229         public byte[] createVerifyData(HandshakeContext context,
 230                 boolean isValidation) throws IOException {
 231             HandshakeHash handshakeHash = context.handshakeHash;
 232             SecretKey masterSecretKey =
 233                     context.handshakeSession.getMasterSecret();
 234 
 235             boolean useClientLabel =
 236                     (context.sslConfig.isClientMode &amp;&amp; !isValidation) ||
 237                     (!context.sslConfig.isClientMode &amp;&amp; isValidation);
 238             String tlsLabel;
 239             if (useClientLabel) {
 240                 tlsLabel = &quot;client finished&quot;;
 241             } else {
 242                 tlsLabel = &quot;server finished&quot;;
 243             }
 244 
 245             try {
 246                 byte[] seed = handshakeHash.digest();
 247                 String prfAlg = &quot;SunTlsPrf&quot;;
 248                 HashAlg hashAlg = H_NONE;
 249 
 250                 /*
 251                  * RFC 5246/7.4.9 says that finished messages can
 252                  * be ciphersuite-specific in both length/PRF hash
 253                  * algorithm.  If we ever run across a different
 254                  * length, this call will need to be updated.
 255                  */
 256                 @SuppressWarnings(&quot;deprecation&quot;)
 257                 TlsPrfParameterSpec spec = new TlsPrfParameterSpec(
 258                     masterSecretKey, tlsLabel, seed, 12,
 259                     hashAlg.name, hashAlg.hashLength, hashAlg.blockSize);
 260                 KeyGenerator kg = KeyGenerator.getInstance(prfAlg);
 261                 kg.init(spec);
 262                 SecretKey prfKey = kg.generateKey();
 263                 if (!&quot;RAW&quot;.equals(prfKey.getFormat())) {
 264                     throw new ProviderException(
 265                         &quot;Invalid PRF output, format must be RAW. &quot; +
 266                         &quot;Format received: &quot; + prfKey.getFormat());
 267                 }
 268                 byte[] finished = prfKey.getEncoded();
 269                 return finished;
 270             } catch (GeneralSecurityException e) {
 271                 throw new RuntimeException(&quot;PRF failed&quot;, e);
 272             }
 273         }
 274     }
 275 
 276     // TLS 1.2
 277     private static final
 278             class T12VerifyDataGenerator implements VerifyDataGenerator {
 279         @Override
 280         public byte[] createVerifyData(HandshakeContext context,
 281                 boolean isValidation) throws IOException {
 282             CipherSuite cipherSuite = context.negotiatedCipherSuite;
 283             HandshakeHash handshakeHash = context.handshakeHash;
 284             SecretKey masterSecretKey =
 285                     context.handshakeSession.getMasterSecret();
 286 
 287             boolean useClientLabel =
 288                     (context.sslConfig.isClientMode &amp;&amp; !isValidation) ||
 289                     (!context.sslConfig.isClientMode &amp;&amp; isValidation);
 290             String tlsLabel;
 291             if (useClientLabel) {
 292                 tlsLabel = &quot;client finished&quot;;
 293             } else {
 294                 tlsLabel = &quot;server finished&quot;;
 295             }
 296 
 297             try {
 298                 byte[] seed = handshakeHash.digest();
 299                 String prfAlg = &quot;SunTls12Prf&quot;;
 300                 HashAlg hashAlg = cipherSuite.hashAlg;
 301 
 302                 /*
 303                  * RFC 5246/7.4.9 says that finished messages can
 304                  * be ciphersuite-specific in both length/PRF hash
 305                  * algorithm.  If we ever run across a different
 306                  * length, this call will need to be updated.
 307                  */
 308                 @SuppressWarnings(&quot;deprecation&quot;)
 309                 TlsPrfParameterSpec spec = new TlsPrfParameterSpec(
 310                     masterSecretKey, tlsLabel, seed, 12,
 311                     hashAlg.name, hashAlg.hashLength, hashAlg.blockSize);
 312                 KeyGenerator kg = KeyGenerator.getInstance(prfAlg);
 313                 kg.init(spec);
 314                 SecretKey prfKey = kg.generateKey();
 315                 if (!&quot;RAW&quot;.equals(prfKey.getFormat())) {
 316                     throw new ProviderException(
 317                         &quot;Invalid PRF output, format must be RAW. &quot; +
 318                         &quot;Format received: &quot; + prfKey.getFormat());
 319                 }
 320                 byte[] finished = prfKey.getEncoded();
 321                 return finished;
 322             } catch (GeneralSecurityException e) {
 323                 throw new RuntimeException(&quot;PRF failed&quot;, e);
 324             }
 325         }
 326     }
 327 
 328     // TLS 1.2
 329     private static final
 330             class T13VerifyDataGenerator implements VerifyDataGenerator {
 331         private static final byte[] hkdfLabel = &quot;tls13 finished&quot;.getBytes();
 332         private static final byte[] hkdfContext = new byte[0];
 333 
 334         @Override
 335         public byte[] createVerifyData(HandshakeContext context,
 336                 boolean isValidation) throws IOException {
 337             // create finished secret key
 338             HashAlg hashAlg =
 339                     context.negotiatedCipherSuite.hashAlg;
 340             SecretKey secret = isValidation ?
 341                     context.baseReadSecret : context.baseWriteSecret;
 342             SSLBasicKeyDerivation kdf = new SSLBasicKeyDerivation(
 343                     secret, hashAlg.name,
 344                     hkdfLabel, hkdfContext, hashAlg.hashLength);
 345             AlgorithmParameterSpec keySpec =
 346                     new SecretSizeSpec(hashAlg.hashLength);
 347             SecretKey finishedSecret =
 348                     kdf.deriveKey(&quot;TlsFinishedSecret&quot;, keySpec);
 349 
 350             String hmacAlg =
 351                 &quot;Hmac&quot; + hashAlg.name.replace(&quot;-&quot;, &quot;&quot;);
 352             try {
 353                 Mac hmac = Mac.getInstance(hmacAlg);
 354                 hmac.init(finishedSecret);
 355                 return hmac.doFinal(context.handshakeHash.digest());
 356             } catch (NoSuchAlgorithmException |InvalidKeyException ex) {
 357                 throw new ProviderException(
 358                         &quot;Failed to generate verify_data&quot;, ex);
 359             }
 360         }
 361     }
 362 
 363     /**
 364      * The &quot;Finished&quot; handshake message producer.
 365      */
 366     private static final
 367             class T12FinishedProducer implements HandshakeProducer {
 368         // Prevent instantiation of this class.
 369         private T12FinishedProducer() {
 370             // blank
 371         }
 372 
 373         @Override
 374         public byte[] produce(ConnectionContext context,
 375                 HandshakeMessage message) throws IOException {
 376             // The consuming happens in handshake context only.
 377             HandshakeContext hc = (HandshakeContext)context;
 378             if (hc.sslConfig.isClientMode) {
 379                 return onProduceFinished(
 380                         (ClientHandshakeContext)context, message);
 381             } else {
 382                 return onProduceFinished(
 383                         (ServerHandshakeContext)context, message);
 384             }
 385         }
 386 
 387         private byte[] onProduceFinished(ClientHandshakeContext chc,
 388                 HandshakeMessage message) throws IOException {
 389             // Refresh handshake hash
 390             chc.handshakeHash.update();
 391 
 392             FinishedMessage fm = new FinishedMessage(chc);
 393 
 394             // Change write cipher and delivery ChangeCipherSpec message.
 395             ChangeCipherSpec.t10Producer.produce(chc, message);
 396 
 397             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 398                 SSLLogger.fine(
 399                         &quot;Produced client Finished handshake message&quot;, fm);
 400             }
 401 
 402             // Output the handshake message.
 403             fm.write(chc.handshakeOutput);
 404             chc.handshakeOutput.flush();
 405 
 406             /*
 407              * save server verify data for secure renegotiation
 408              */
 409             if (chc.conContext.secureRenegotiation) {
 410                 chc.conContext.clientVerifyData = fm.verifyData;
 411             }
 412 
 413             if (chc.statelessResumption) {
 414                 chc.handshakeConsumers.put(
 415                         SSLHandshake.NEW_SESSION_TICKET.id, SSLHandshake.NEW_SESSION_TICKET);
 416             }
 417             // update the consumers and producers
 418             if (!chc.isResumption) {
 419                 chc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 420                         ChangeCipherSpec.t10Consumer);
 421                 chc.handshakeConsumers.put(
 422                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 423                 chc.conContext.inputRecord.expectingFinishFlight();
 424             } else {
 425                 if (chc.handshakeSession.isRejoinable()) {
 426                     ((SSLSessionContextImpl)chc.sslContext.
 427                         engineGetClientSessionContext()).put(
 428                             chc.handshakeSession);
 429                 }
 430                 chc.conContext.conSession = chc.handshakeSession.finish();
 431                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 432 
 433                 // handshake context cleanup.
 434                 chc.handshakeFinished = true;
 435 
 436                 // May need to retransmit the last flight for DTLS.
 437                 if (!chc.sslContext.isDTLS()) {
 438                     chc.conContext.finishHandshake();
 439                 }
 440             }
 441 
 442             // The handshake message has been delivered.
 443             return null;
 444         }
 445 
 446         private byte[] onProduceFinished(ServerHandshakeContext shc,
 447                 HandshakeMessage message) throws IOException {
 448             if (shc.statelessResumption) {
 449                 NewSessionTicket.handshake12Producer.produce(shc, message);
 450             }
 451 
 452             // Refresh handshake hash
 453             shc.handshakeHash.update();
 454 
 455             FinishedMessage fm = new FinishedMessage(shc);
 456 
 457             // Change write cipher and delivery ChangeCipherSpec message.
 458             ChangeCipherSpec.t10Producer.produce(shc, message);
 459 
 460             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 461                 SSLLogger.fine(
 462                         &quot;Produced server Finished handshake message&quot;, fm);
 463             }
 464 
 465             // Output the handshake message.
 466             fm.write(shc.handshakeOutput);
 467             shc.handshakeOutput.flush();
 468 
 469             /*
 470              * save client verify data for secure renegotiation
 471              */
 472             if (shc.conContext.secureRenegotiation) {
 473                 shc.conContext.serverVerifyData = fm.verifyData;
 474             }
 475 
 476             // update the consumers and producers
 477             if (shc.isResumption) {
 478                 shc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 479                         ChangeCipherSpec.t10Consumer);
 480                 shc.handshakeConsumers.put(
 481                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 482                 shc.conContext.inputRecord.expectingFinishFlight();
 483             } else {
 484                 // Set the session&#39;s context based on stateless/cache status
 485                 if (shc.statelessResumption &amp;&amp;
 486                         shc.handshakeSession.isStatelessable()) {
 487                     shc.handshakeSession.setContext((SSLSessionContextImpl)
 488                             shc.sslContext.engineGetServerSessionContext());
 489                 } else {
 490                     if (shc.handshakeSession.isRejoinable()) {
 491                         ((SSLSessionContextImpl)shc.sslContext.
 492                                 engineGetServerSessionContext()).put(
 493                                 shc.handshakeSession);
 494                     }
 495                 }
 496                 shc.conContext.conSession = shc.handshakeSession.finish();
 497                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 498 
 499                 // handshake context cleanup.
 500                 shc.handshakeFinished = true;
 501 
 502                 // May need to retransmit the last flight for DTLS.
 503                 if (!shc.sslContext.isDTLS()) {
 504                     shc.conContext.finishHandshake();
 505                 }
 506             }
 507 
 508             // The handshake message has been delivered.
 509             return null;
 510         }
 511     }
 512 
 513     /**
 514      * The &quot;Finished&quot; handshake message consumer.
 515      */
 516     private static final class T12FinishedConsumer implements SSLConsumer {
 517         // Prevent instantiation of this class.
 518         private T12FinishedConsumer() {
 519             // blank
 520         }
 521 
 522         @Override
 523         public void consume(ConnectionContext context,
 524                 ByteBuffer message) throws IOException {
 525             // The consuming happens in handshake context only.
 526             HandshakeContext hc = (HandshakeContext)context;
 527 
 528             // This consumer can be used only once.
 529             hc.handshakeConsumers.remove(SSLHandshake.FINISHED.id);
 530 
 531             // We should not be processing finished messages unless
 532             // we have received ChangeCipherSpec
 533             if (hc.conContext.consumers.containsKey(
 534                     ContentType.CHANGE_CIPHER_SPEC.id)) {
 535                 throw hc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 536                         &quot;Missing ChangeCipherSpec message&quot;);
 537             }
 538 
 539             if (hc.sslConfig.isClientMode) {
 540                 onConsumeFinished((ClientHandshakeContext)context, message);
 541             } else {
 542                 onConsumeFinished((ServerHandshakeContext)context, message);
 543             }
 544         }
 545 
 546         private void onConsumeFinished(ClientHandshakeContext chc,
 547                 ByteBuffer message) throws IOException {
 548             FinishedMessage fm = new FinishedMessage(chc, message);
 549             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 550                 SSLLogger.fine(
 551                         &quot;Consuming server Finished handshake message&quot;, fm);
 552             }
 553 
 554             if (chc.conContext.secureRenegotiation) {
 555                 chc.conContext.serverVerifyData = fm.verifyData;
 556             }
 557 
 558             if (!chc.isResumption) {
 559                 if (chc.handshakeSession.isRejoinable()) {
 560                     ((SSLSessionContextImpl)chc.sslContext.
 561                         engineGetClientSessionContext()).put(
 562                             chc.handshakeSession);
 563                 }
 564                 chc.conContext.conSession = chc.handshakeSession.finish();
 565                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 566 
 567                 // handshake context cleanup.
 568                 chc.handshakeFinished = true;
 569                 recordEvent(chc.conContext.conSession);
 570 
 571                 // May need to retransmit the last flight for DTLS.
 572                 if (!chc.sslContext.isDTLS()) {
 573                     chc.conContext.finishHandshake();
 574                 }
 575             } else {
 576                 chc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 577                         SSLHandshake.FINISHED);
 578             }
 579 
 580             //
 581             // produce
 582             //
 583             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
 584                 SSLHandshake.FINISHED
 585             };
 586 
 587             for (SSLHandshake hs : probableHandshakeMessages) {
 588                 HandshakeProducer handshakeProducer =
 589                         chc.handshakeProducers.remove(hs.id);
 590                 if (handshakeProducer != null) {
 591                     handshakeProducer.produce(chc, fm);
 592                 }
 593             }
 594         }
 595 
 596         private void onConsumeFinished(ServerHandshakeContext shc,
 597                 ByteBuffer message) throws IOException {
 598             // Make sure that any expected CertificateVerify message
 599             // has been received and processed.
 600             if (!shc.isResumption) {
 601                 if (shc.handshakeConsumers.containsKey(
 602                         SSLHandshake.CERTIFICATE_VERIFY.id)) {
 603                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 604                             &quot;Unexpected Finished handshake message&quot;);
 605                 }
 606             }
 607 
 608             FinishedMessage fm = new FinishedMessage(shc, message);
 609             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 610                 SSLLogger.fine(
 611                         &quot;Consuming client Finished handshake message&quot;, fm);
 612             }
 613 
 614             if (shc.conContext.secureRenegotiation) {
 615                 shc.conContext.clientVerifyData = fm.verifyData;
 616             }
 617 
 618             if (shc.isResumption) {
 619                 if (shc.handshakeSession.isRejoinable() &amp;&amp;
 620                         !shc.statelessResumption) {
 621                     ((SSLSessionContextImpl)shc.sslContext.
 622                         engineGetServerSessionContext()).put(
 623                             shc.handshakeSession);
 624                 }
 625                 shc.conContext.conSession = shc.handshakeSession.finish();
 626                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 627 
 628                 // handshake context cleanup.
 629                 shc.handshakeFinished = true;
 630                 recordEvent(shc.conContext.conSession);
 631 
 632                 // May need to retransmit the last flight for DTLS.
 633                 if (!shc.sslContext.isDTLS()) {
 634                     shc.conContext.finishHandshake();
 635                 }
 636             } else {
 637                 shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 638                         SSLHandshake.FINISHED);
 639             }
 640 
 641             //
 642             // produce
 643             //
 644             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
 645                 SSLHandshake.FINISHED
 646             };
 647 
 648             for (SSLHandshake hs : probableHandshakeMessages) {
 649                 HandshakeProducer handshakeProducer =
 650                         shc.handshakeProducers.remove(hs.id);
 651                 if (handshakeProducer != null) {
 652                     handshakeProducer.produce(shc, fm);
 653                 }
 654             }
 655         }
 656     }
 657 
 658     /**
 659      * The &quot;Finished&quot; handshake message producer.
 660      */
 661     private static final
 662             class T13FinishedProducer implements HandshakeProducer {
 663         // Prevent instantiation of this class.
 664         private T13FinishedProducer() {
 665             // blank
 666         }
 667 
 668         @Override
 669         public byte[] produce(ConnectionContext context,
 670                 HandshakeMessage message) throws IOException {
 671             // The consuming happens in handshake context only.
 672             HandshakeContext hc = (HandshakeContext)context;
 673             if (hc.sslConfig.isClientMode) {
 674                 return onProduceFinished(
 675                         (ClientHandshakeContext)context, message);
 676             } else {
 677                 return onProduceFinished(
 678                         (ServerHandshakeContext)context, message);
 679             }
 680         }
 681 
 682         private byte[] onProduceFinished(ClientHandshakeContext chc,
 683                 HandshakeMessage message) throws IOException {
 684             // Refresh handshake hash
 685             chc.handshakeHash.update();
 686 
 687             FinishedMessage fm = new FinishedMessage(chc);
 688             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 689                 SSLLogger.fine(
 690                         &quot;Produced client Finished handshake message&quot;, fm);
 691             }
 692 
 693             // Output the handshake message.
 694             fm.write(chc.handshakeOutput);
 695             chc.handshakeOutput.flush();
 696 
 697             // save server verify data for secure renegotiation
 698             if (chc.conContext.secureRenegotiation) {
 699                 chc.conContext.clientVerifyData = fm.verifyData;
 700             }
 701 
 702             // update the context
 703             // Change client/server application traffic secrets.
 704             SSLKeyDerivation kd = chc.handshakeKeyDerivation;
 705             if (kd == null) {
 706                 // unlikely
 707                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 708                     &quot;no key derivation&quot;);
 709             }
 710 
 711             SSLTrafficKeyDerivation kdg =
 712                     SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
 713             if (kdg == null) {
 714                 // unlikely
 715                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 716                         &quot;Not supported key derivation: &quot; +
 717                         chc.negotiatedProtocol);
 718             }
 719 
 720             try {
 721                 // update the application traffic read keys.
 722                 SecretKey writeSecret = kd.deriveKey(
 723                         &quot;TlsClientAppTrafficSecret&quot;, null);
 724 
 725                 SSLKeyDerivation writeKD =
 726                         kdg.createKeyDerivation(chc, writeSecret);
 727                 SecretKey writeKey = writeKD.deriveKey(
 728                         &quot;TlsKey&quot;, null);
 729                 SecretKey writeIvSecret = writeKD.deriveKey(
 730                         &quot;TlsIv&quot;, null);
 731                 IvParameterSpec writeIv =
 732                         new IvParameterSpec(writeIvSecret.getEncoded());
 733                 SSLWriteCipher writeCipher =
 734                         chc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
 735                                 Authenticator.valueOf(chc.negotiatedProtocol),
 736                                 chc.negotiatedProtocol, writeKey, writeIv,
 737                                 chc.sslContext.getSecureRandom());
 738 
 739                 if (writeCipher == null) {
 740                     throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 741                         &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
 742                         &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
 743                         &quot;)&quot;);
 744                 }
 745 
 746                 chc.baseWriteSecret = writeSecret;
 747                 chc.conContext.outputRecord.changeWriteCiphers(
 748                         writeCipher, false);
 749 
 750             } catch (GeneralSecurityException gse) {
 751                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 752                         &quot;Failure to derive application secrets&quot;, gse);
 753             }
 754 
 755             // The resumption master secret is stored in the session so
 756             // it can be used after the handshake is completed.
 757             SSLSecretDerivation sd = ((SSLSecretDerivation) kd).forContext(chc);
 758             SecretKey resumptionMasterSecret = sd.deriveKey(
 759                     &quot;TlsResumptionMasterSecret&quot;, null);
 760             chc.handshakeSession.setResumptionMasterSecret(
 761                     resumptionMasterSecret);
 762 
 763             chc.conContext.conSession = chc.handshakeSession.finish();
 764             chc.conContext.protocolVersion = chc.negotiatedProtocol;
 765 
 766             // handshake context cleanup.
 767             chc.handshakeFinished = true;
 768             chc.conContext.finishHandshake();
 769             recordEvent(chc.conContext.conSession);
 770 
 771 
 772             // The handshake message has been delivered.
 773             return null;
 774         }
 775 
 776         private byte[] onProduceFinished(ServerHandshakeContext shc,
 777                 HandshakeMessage message) throws IOException {
 778             // Refresh handshake hash
 779             shc.handshakeHash.update();
 780 
 781             FinishedMessage fm = new FinishedMessage(shc);
 782             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 783                 SSLLogger.fine(
 784                         &quot;Produced server Finished handshake message&quot;, fm);
 785             }
 786 
 787             // Output the handshake message.
 788             fm.write(shc.handshakeOutput);
 789             shc.handshakeOutput.flush();
 790 
 791             // Change client/server application traffic secrets.
 792             SSLKeyDerivation kd = shc.handshakeKeyDerivation;
 793             if (kd == null) {
 794                 // unlikely
 795                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 796                     &quot;no key derivation&quot;);
 797             }
 798 
 799             SSLTrafficKeyDerivation kdg =
 800                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
 801             if (kdg == null) {
 802                 // unlikely
 803                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 804                         &quot;Not supported key derivation: &quot; +
 805                         shc.negotiatedProtocol);
 806             }
 807 
 808             // derive salt secret
 809             try {
 810                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);
 811 
 812                 // derive application secrets
 813                 HashAlg hashAlg = shc.negotiatedCipherSuite.hashAlg;
 814                 HKDF hkdf = new HKDF(hashAlg.name);
 815                 byte[] zeros = new byte[hashAlg.hashLength];
 816                 SecretKeySpec sharedSecret =
 817                         new SecretKeySpec(zeros, &quot;TlsZeroSecret&quot;);
 818                 SecretKey masterSecret =
 819                     hkdf.extract(saltSecret, sharedSecret, &quot;TlsMasterSecret&quot;);
 820 
 821                 SSLKeyDerivation secretKD =
 822                         new SSLSecretDerivation(shc, masterSecret);
 823 
 824                 // update the handshake traffic write keys.
 825                 SecretKey writeSecret = secretKD.deriveKey(
 826                         &quot;TlsServerAppTrafficSecret&quot;, null);
 827                 SSLKeyDerivation writeKD =
 828                         kdg.createKeyDerivation(shc, writeSecret);
 829                 SecretKey writeKey = writeKD.deriveKey(
 830                         &quot;TlsKey&quot;, null);
 831                 SecretKey writeIvSecret = writeKD.deriveKey(
 832                         &quot;TlsIv&quot;, null);
 833                 IvParameterSpec writeIv =
 834                         new IvParameterSpec(writeIvSecret.getEncoded());
 835                 SSLWriteCipher writeCipher =
 836                         shc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
 837                                 Authenticator.valueOf(shc.negotiatedProtocol),
 838                                 shc.negotiatedProtocol, writeKey, writeIv,
 839                                 shc.sslContext.getSecureRandom());
 840 
 841                 if (writeCipher == null) {
 842                     throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 843                         &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 844                         &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 845                         &quot;)&quot;);
 846                 }
 847 
 848                 shc.baseWriteSecret = writeSecret;
 849                 shc.conContext.outputRecord.changeWriteCiphers(
 850                         writeCipher, false);
 851 
 852                 // update the context for the following key derivation
 853                 shc.handshakeKeyDerivation = secretKD;
 854             } catch (GeneralSecurityException gse) {
 855                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 856                         &quot;Failure to derive application secrets&quot;, gse);
 857             }
 858 
 859             /*
 860              * save client verify data for secure renegotiation
 861              */
 862             if (shc.conContext.secureRenegotiation) {
 863                 shc.conContext.serverVerifyData = fm.verifyData;
 864             }
 865 
 866             // Make sure session&#39;s context is set
 867             shc.handshakeSession.setContext((SSLSessionContextImpl)
 868                     shc.sslContext.engineGetServerSessionContext());
 869             shc.conContext.conSession = shc.handshakeSession.finish();
 870 
 871             // update the context
 872             shc.handshakeConsumers.put(
 873                     SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 874 
 875             // The handshake message has been delivered.
 876             return null;
 877         }
 878     }
 879 
 880     /**
 881      * The &quot;Finished&quot; handshake message consumer.
 882      */
 883     private static final class T13FinishedConsumer implements SSLConsumer {
 884         // Prevent instantiation of this class.
 885         private T13FinishedConsumer() {
 886             // blank
 887         }
 888 
 889         @Override
 890         public void consume(ConnectionContext context,
 891                 ByteBuffer message) throws IOException {
 892             // The consuming happens in handshake context only.
 893             HandshakeContext hc = (HandshakeContext)context;
 894             if (hc.sslConfig.isClientMode) {
 895                 onConsumeFinished(
 896                         (ClientHandshakeContext)context, message);
 897             } else {
 898                 onConsumeFinished(
 899                         (ServerHandshakeContext)context, message);
 900             }
 901         }
 902 
 903         private void onConsumeFinished(ClientHandshakeContext chc,
 904                 ByteBuffer message) throws IOException {
 905             // Make sure that any expected CertificateVerify message
 906             // has been received and processed.
 907             if (!chc.isResumption) {
 908                 if (chc.handshakeConsumers.containsKey(
 909                         SSLHandshake.CERTIFICATE.id) ||
 910                     chc.handshakeConsumers.containsKey(
 911                         SSLHandshake.CERTIFICATE_VERIFY.id)) {
 912                     throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 913                             &quot;Unexpected Finished handshake message&quot;);
 914                 }
 915             }
 916 
 917             FinishedMessage fm = new FinishedMessage(chc, message);
 918             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 919                 SSLLogger.fine(
 920                         &quot;Consuming server Finished handshake message&quot;, fm);
 921             }
 922 
 923             // Save client verify data for secure renegotiation.
 924             if (chc.conContext.secureRenegotiation) {
 925                 chc.conContext.serverVerifyData = fm.verifyData;
 926             }
 927 
 928             //
 929             // validate
 930             //
 931             // blank
 932 
 933             //
 934             // update
 935             //
 936             // A change_cipher_spec record received after the peer&#39;s Finished
 937             // message MUST be treated as an unexpected record type.
 938             chc.conContext.consumers.remove(ContentType.CHANGE_CIPHER_SPEC.id);
 939 
 940             // Change client/server application traffic secrets.
 941             // Refresh handshake hash
 942             chc.handshakeHash.update();
 943             SSLKeyDerivation kd = chc.handshakeKeyDerivation;
 944             if (kd == null) {
 945                 // unlikely
 946                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 947                     &quot;no key derivation&quot;);
 948             }
 949 
 950             SSLTrafficKeyDerivation kdg =
 951                     SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
 952             if (kdg == null) {
 953                 // unlikely
 954                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 955                         &quot;Not supported key derivation: &quot; +
 956                         chc.negotiatedProtocol);
 957             }
 958 
 959             // save the session
 960             if (!chc.isResumption &amp;&amp; chc.handshakeSession.isRejoinable()) {
 961                 ((SSLSessionContextImpl)chc.sslContext.
 962                         engineGetClientSessionContext()).
 963                         put(chc.handshakeSession);
 964             }
 965 
 966             // derive salt secret
 967             try {
 968                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);
 969 
 970                 // derive application secrets
 971                 HashAlg hashAlg = chc.negotiatedCipherSuite.hashAlg;
 972                 HKDF hkdf = new HKDF(hashAlg.name);
 973                 byte[] zeros = new byte[hashAlg.hashLength];
 974                 SecretKeySpec sharedSecret =
 975                         new SecretKeySpec(zeros, &quot;TlsZeroSecret&quot;);
 976                 SecretKey masterSecret =
 977                     hkdf.extract(saltSecret, sharedSecret, &quot;TlsMasterSecret&quot;);
 978 
 979                 SSLKeyDerivation secretKD =
 980                         new SSLSecretDerivation(chc, masterSecret);
 981 
 982                 // update the handshake traffic read keys.
 983                 SecretKey readSecret = secretKD.deriveKey(
 984                         &quot;TlsServerAppTrafficSecret&quot;, null);
 985                 SSLKeyDerivation writeKD =
 986                         kdg.createKeyDerivation(chc, readSecret);
 987                 SecretKey readKey = writeKD.deriveKey(
 988                         &quot;TlsKey&quot;, null);
 989                 SecretKey readIvSecret = writeKD.deriveKey(
 990                         &quot;TlsIv&quot;, null);
 991                 IvParameterSpec readIv =
 992                         new IvParameterSpec(readIvSecret.getEncoded());
 993                 SSLReadCipher readCipher =
 994                         chc.negotiatedCipherSuite.bulkCipher.createReadCipher(
 995                                 Authenticator.valueOf(chc.negotiatedProtocol),
 996                                 chc.negotiatedProtocol, readKey, readIv,
 997                                 chc.sslContext.getSecureRandom());
 998 
 999                 if (readCipher == null) {
1000                     throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1001                         &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
1002                         &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
1003                         &quot;)&quot;);
1004                 }
1005 
1006                 chc.baseReadSecret = readSecret;
1007                 chc.conContext.inputRecord.changeReadCiphers(readCipher);
1008 
1009                 // update the context for the following key derivation
1010                 chc.handshakeKeyDerivation = secretKD;
1011             } catch (GeneralSecurityException gse) {
1012                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1013                         &quot;Failure to derive application secrets&quot;, gse);
1014             }
1015 
1016             //
1017             // produce
1018             //
1019             chc.handshakeProducers.put(SSLHandshake.FINISHED.id,
1020                         SSLHandshake.FINISHED);
1021             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
1022                 // full handshake messages
1023                 SSLHandshake.CERTIFICATE,
1024                 SSLHandshake.CERTIFICATE_VERIFY,
1025                 SSLHandshake.FINISHED
1026             };
1027 
1028             for (SSLHandshake hs : probableHandshakeMessages) {
1029                 HandshakeProducer handshakeProducer =
1030                         chc.handshakeProducers.remove(hs.id);
1031                 if (handshakeProducer != null) {
1032                     handshakeProducer.produce(chc, null);
1033                 }
1034             }
1035         }
1036 
1037         private void onConsumeFinished(ServerHandshakeContext shc,
1038                 ByteBuffer message) throws IOException {
1039             // Make sure that any expected CertificateVerify message
1040             // has been received and processed.
1041             if (!shc.isResumption) {
1042                 if (shc.handshakeConsumers.containsKey(
1043                         SSLHandshake.CERTIFICATE.id) ||
1044                     shc.handshakeConsumers.containsKey(
1045                         SSLHandshake.CERTIFICATE_VERIFY.id)) {
1046                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1047                             &quot;Unexpected Finished handshake message&quot;);
1048                 }
1049             }
1050 
1051             FinishedMessage fm = new FinishedMessage(shc, message);
1052             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1053                 SSLLogger.fine(
1054                         &quot;Consuming client Finished handshake message&quot;, fm);
1055             }
1056 
1057             if (shc.conContext.secureRenegotiation) {
1058                 shc.conContext.clientVerifyData = fm.verifyData;
1059             }
1060 
1061             //
1062             // validate
1063             //
1064             // blank
1065 
1066             //
1067             // update
1068             //
1069             // Change client/server application traffic secrets.
1070             SSLKeyDerivation kd = shc.handshakeKeyDerivation;
1071             if (kd == null) {
1072                 // unlikely
1073                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1074                     &quot;no key derivation&quot;);
1075             }
1076 
1077             SSLTrafficKeyDerivation kdg =
1078                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
1079             if (kdg == null) {
1080                 // unlikely
1081                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1082                         &quot;Not supported key derivation: &quot; +
1083                         shc.negotiatedProtocol);
1084             }
1085 
1086             try {
1087                 // update the application traffic read keys.
1088                 SecretKey readSecret = kd.deriveKey(
1089                         &quot;TlsClientAppTrafficSecret&quot;, null);
1090 
1091                 SSLKeyDerivation readKD =
1092                         kdg.createKeyDerivation(shc, readSecret);
1093                 SecretKey readKey = readKD.deriveKey(
1094                         &quot;TlsKey&quot;, null);
1095                 SecretKey readIvSecret = readKD.deriveKey(
1096                         &quot;TlsIv&quot;, null);
1097                 IvParameterSpec readIv =
1098                         new IvParameterSpec(readIvSecret.getEncoded());
1099                 SSLReadCipher readCipher =
1100                         shc.negotiatedCipherSuite.bulkCipher.createReadCipher(
1101                                 Authenticator.valueOf(shc.negotiatedProtocol),
1102                                 shc.negotiatedProtocol, readKey, readIv,
1103                                 shc.sslContext.getSecureRandom());
1104 
1105                 if (readCipher == null) {
1106                     throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1107                         &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
1108                         &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
1109                         &quot;)&quot;);
1110                 }
1111 
1112                 shc.baseReadSecret = readSecret;
1113                 shc.conContext.inputRecord.changeReadCiphers(readCipher);
1114 
1115                 // The resumption master secret is stored in the session so
1116                 // it can be used after the handshake is completed.
1117                 shc.handshakeHash.update();
1118                 SSLSecretDerivation sd =
1119                         ((SSLSecretDerivation)kd).forContext(shc);
1120                 SecretKey resumptionMasterSecret = sd.deriveKey(
1121                 &quot;TlsResumptionMasterSecret&quot;, null);
1122                 shc.handshakeSession.setResumptionMasterSecret(
1123                         resumptionMasterSecret);
1124             } catch (GeneralSecurityException gse) {
1125                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1126                         &quot;Failure to derive application secrets&quot;, gse);
1127             }
1128 
1129             //  update connection context
1130             shc.conContext.conSession = shc.handshakeSession.finish();
1131             shc.conContext.protocolVersion = shc.negotiatedProtocol;
1132 
1133             // handshake context cleanup.
1134             shc.handshakeFinished = true;
1135 
1136             // May need to retransmit the last flight for DTLS.
1137             if (!shc.sslContext.isDTLS()) {
1138                 shc.conContext.finishHandshake();
1139             }
1140             recordEvent(shc.conContext.conSession);
1141 
1142             //
1143             // produce
1144             NewSessionTicket.t13PosthandshakeProducer.produce(shc);
1145         }
1146     }
1147 
1148     private static void recordEvent(SSLSessionImpl session) {
1149         TLSHandshakeEvent event = new TLSHandshakeEvent();
1150         if (event.shouldCommit() || EventHelper.isLoggingSecurity()) {
1151             int peerCertificateId = 0;
1152             try {
1153                 // use hash code for Id
1154                 peerCertificateId = session
1155                         .getCertificateChain()[0]
1156                         .hashCode();
1157             } catch (SSLPeerUnverifiedException e) {
1158                  // not verified msg
1159             }
1160             if (event.shouldCommit()) {
1161                 event.peerHost = session.getPeerHost();
1162                 event.peerPort = session.getPeerPort();
1163                 event.cipherSuite = session.getCipherSuite();
1164                 event.protocolVersion = session.getProtocol();
1165                 event.certificateId = peerCertificateId;
1166                 event.commit();
1167             }
1168             if (EventHelper.isLoggingSecurity()) {
1169                 EventHelper.logTLSHandshakeEvent(null,
1170                                 session.getPeerHost(),
1171                                 session.getPeerPort(),
1172                                 session.getCipherSuite(),
1173                                 session.getProtocol(),
1174                                 peerCertificateId);
1175             }
1176         }
1177     }
1178 }
    </pre>
  </body>
</html>
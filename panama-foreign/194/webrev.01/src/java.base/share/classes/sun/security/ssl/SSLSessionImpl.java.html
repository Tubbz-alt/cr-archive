<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package sun.security.ssl;
  26 
  27 import sun.security.x509.X509CertImpl;
  28 
  29 import java.io.IOException;
  30 import java.math.BigInteger;
  31 import java.net.InetAddress;
  32 import java.nio.ByteBuffer;
  33 import java.security.Principal;
  34 import java.security.PrivateKey;
  35 import java.security.cert.X509Certificate;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Queue;
  39 import java.util.Collection;
  40 import java.util.Collections;
  41 import java.util.Enumeration;
  42 import java.util.List;
  43 import java.util.concurrent.ConcurrentHashMap;
  44 import java.util.concurrent.ConcurrentLinkedQueue;
  45 import java.util.concurrent.locks.ReentrantLock;
  46 import javax.crypto.SecretKey;
  47 import javax.crypto.spec.SecretKeySpec;
  48 import javax.net.ssl.ExtendedSSLSession;
  49 import javax.net.ssl.SNIHostName;
  50 import javax.net.ssl.SNIServerName;
  51 import javax.net.ssl.SSLException;
  52 import javax.net.ssl.SSLPeerUnverifiedException;
  53 import javax.net.ssl.SSLPermission;
  54 import javax.net.ssl.SSLSessionBindingEvent;
  55 import javax.net.ssl.SSLSessionBindingListener;
  56 import javax.net.ssl.SSLSessionContext;
  57 
  58 /**
  59  * Implements the SSL session interface, and exposes the session context
  60  * which is maintained by SSL servers.
  61  *
  62  * &lt;P&gt; Servers have the ability to manage the sessions associated with
  63  * their authentication context(s).  They can do this by enumerating the
  64  * IDs of the sessions which are cached, examining those sessions, and then
  65  * perhaps invalidating a given session so that it can&#39;t be used again.
  66  * If servers do not explicitly manage the cache, sessions will linger
  67  * until memory is low enough that the runtime environment purges cache
  68  * entries automatically to reclaim space.
  69  *
  70  * &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
  71  * there&#39;s no other public way to get at the server session context which
  72  * is associated with any given authentication context. &lt;/em&gt;
  73  *
  74  * @author David Brownell
  75  */
  76 final class SSLSessionImpl extends ExtendedSSLSession {
  77 
  78     /*
  79      * The state of a single session, as described in section 7.1
  80      * of the SSLv3 spec.
  81      */
  82     private final ProtocolVersion       protocolVersion;
  83     private final SessionId             sessionId;
  84     private X509Certificate[]   peerCerts;
  85     private CipherSuite         cipherSuite;
  86     private SecretKey           masterSecret;
  87     final boolean               useExtendedMasterSecret;
  88 
  89     /*
  90      * Information not part of the SSLv3 protocol spec, but used
  91      * to support session management policies.
  92      */
  93     private final long          creationTime;
  94     private long                lastUsedTime = 0;
  95     private final String        host;
  96     private final int           port;
  97     private SSLSessionContextImpl       context;
  98     private boolean             invalidated;
  99     private X509Certificate[]   localCerts;
 100     private PrivateKey          localPrivateKey;
 101     private final Collection&lt;SignatureScheme&gt;     localSupportedSignAlgs;
 102     private Collection&lt;SignatureScheme&gt; peerSupportedSignAlgs; //for certificate
 103     private boolean             useDefaultPeerSignAlgs = false;
 104     private List&lt;byte[]&gt;        statusResponses;
 105     private SecretKey           resumptionMasterSecret;
 106     private SecretKey           preSharedKey;
 107     private byte[]              pskIdentity;
 108     private final long          ticketCreationTime = System.currentTimeMillis();
 109     private int                 ticketAgeAdd;
 110 
 111     private int                 negotiatedMaxFragLen = -1;
 112     private int                 maximumPacketSize;
 113 
 114     private final Queue&lt;SSLSessionImpl&gt; childSessions =
 115                                         new ConcurrentLinkedQueue&lt;&gt;();
 116 
 117     /*
 118      * Is the session currently re-established with a session-resumption
 119      * abbreviated initial handshake?
 120      *
 121      * Note that currently we only set this variable in client side.
 122      */
 123     private boolean isSessionResumption = false;
 124 
 125     /*
 126      * Use of session caches is globally enabled/disabled.
 127      */
 128     private static boolean      defaultRejoinable = true;
 129 
 130     // server name indication
 131     final SNIServerName         serverNameIndication;
 132     private final List&lt;SNIServerName&gt;    requestedServerNames;
 133 
 134     // Counter used to create unique nonces in NewSessionTicket
 135     private BigInteger ticketNonceCounter = BigInteger.ONE;
 136 
 137     // The endpoint identification algorithm used to check certificates
 138     // in this session.
 139     private final String        identificationProtocol;
 140 
 141     private final ReentrantLock sessionLock = new ReentrantLock();
 142 
 143     /*
 144      * Create a new non-rejoinable session, using the default (null)
 145      * cipher spec.  This constructor returns a session which could
 146      * be used either by a client or by a server, as a connection is
 147      * first opened and before handshaking begins.
 148      */
 149     SSLSessionImpl() {
 150         this.protocolVersion = ProtocolVersion.NONE;
 151         this.cipherSuite = CipherSuite.C_NULL;
 152         this.sessionId = new SessionId(false, null);
 153         this.host = null;
 154         this.port = -1;
 155         this.localSupportedSignAlgs = Collections.emptySet();
 156         this.serverNameIndication = null;
 157         this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 158         this.useExtendedMasterSecret = false;
 159         this.creationTime = System.currentTimeMillis();
 160         this.identificationProtocol = null;
 161         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 162     }
 163 
 164     /*
 165      * Create a new session, using a given cipher spec.  This will
 166      * be rejoinable if session caching is enabled; the constructor
 167      * is intended mostly for use by serves.
 168      */
 169     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite) {
 170         this(hc, cipherSuite,
 171             new SessionId(defaultRejoinable, hc.sslContext.getSecureRandom()));
 172     }
 173 
 174     /*
 175      * Record a new session, using a given cipher spec and session ID.
 176      */
 177     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite, SessionId id) {
 178         this(hc, cipherSuite, id, System.currentTimeMillis());
 179     }
 180 
 181     /*
 182      * Record a new session, using a given cipher spec, session ID,
 183      * and creation time.
 184      * Note: For the unmodifiable collections and lists we are creating new
 185      * collections as inputs to avoid potential deep nesting of
 186      * unmodifiable collections that can cause StackOverflowErrors
 187      * (see JDK-6323374).
 188      */
 189     SSLSessionImpl(HandshakeContext hc,
 190             CipherSuite cipherSuite, SessionId id, long creationTime) {
 191         this.protocolVersion = hc.negotiatedProtocol;
 192         this.cipherSuite = cipherSuite;
 193         this.sessionId = id;
 194         this.host = hc.conContext.transport.getPeerHost();
 195         this.port = hc.conContext.transport.getPeerPort();
 196         this.localSupportedSignAlgs = hc.localSupportedSignAlgs == null ?
 197                 Collections.emptySet() :
 198                 Collections.unmodifiableCollection(
 199                         new ArrayList&lt;&gt;(hc.localSupportedSignAlgs));
 200         this.serverNameIndication = hc.negotiatedServerName;
 201         this.requestedServerNames = Collections.unmodifiableList(
 202                 new ArrayList&lt;&gt;(hc.getRequestedServerNames()));
 203         if (hc.sslConfig.isClientMode) {
 204             this.useExtendedMasterSecret =
 205                 (hc.handshakeExtensions.get(
 206                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 207                 (hc.handshakeExtensions.get(
 208                         SSLExtension.SH_EXTENDED_MASTER_SECRET) != null);
 209         } else {
 210             this.useExtendedMasterSecret =
 211                 (hc.handshakeExtensions.get(
 212                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 213                 (!hc.negotiatedProtocol.useTLS13PlusSpec());
 214         }
 215         this.creationTime = creationTime;
 216         this.identificationProtocol = hc.sslConfig.identificationProtocol;
 217         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 218 
 219         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 220              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 221         }
 222     }
 223 
 224     SSLSessionImpl(SSLSessionImpl baseSession, SessionId newId) {
 225         this.protocolVersion = baseSession.getProtocolVersion();
 226         this.cipherSuite = baseSession.cipherSuite;
 227         this.sessionId = newId;
 228         this.host = baseSession.getPeerHost();
 229         this.port = baseSession.getPeerPort();
 230         this.localSupportedSignAlgs =
 231                 baseSession.localSupportedSignAlgs == null ?
 232                 Collections.emptySet() : baseSession.localSupportedSignAlgs;
 233         this.peerSupportedSignAlgs =
 234                 baseSession.peerSupportedSignAlgs == null ?
 235                 Collections.emptySet() : baseSession.peerSupportedSignAlgs;
 236         this.serverNameIndication = baseSession.serverNameIndication;
 237         this.requestedServerNames = baseSession.getRequestedServerNames();
 238         this.masterSecret = baseSession.getMasterSecret();
 239         this.useExtendedMasterSecret = baseSession.useExtendedMasterSecret;
 240         this.creationTime = baseSession.getCreationTime();
 241         this.lastUsedTime = System.currentTimeMillis();
 242         this.identificationProtocol = baseSession.getIdentificationProtocol();
 243         this.localCerts = baseSession.localCerts;
 244         this.peerCerts = baseSession.peerCerts;
 245         this.statusResponses = baseSession.statusResponses;
 246         this.resumptionMasterSecret = baseSession.resumptionMasterSecret;
 247         this.context = baseSession.context;
 248         this.negotiatedMaxFragLen = baseSession.negotiatedMaxFragLen;
 249         this.maximumPacketSize = baseSession.maximumPacketSize;
 250         this.boundValues = baseSession.boundValues;
 251 
 252         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 253              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 254         }
 255     }
 256 
 257     /**
 258      * &lt; 2 bytes &gt; protocolVersion
 259      * &lt; 2 bytes &gt; cipherSuite
 260      * &lt; 1 byte &gt; localSupportedSignAlgs entries
 261      *   &lt; 2 bytes per entries &gt; localSupportedSignAlgs
 262      * &lt; 1 bytes &gt; peerSupportedSignAlgs entries
 263      *   &lt; 2 bytes per entries &gt; peerSupportedSignAlgs
 264      * &lt; 2 bytes &gt; preSharedKey length
 265      * &lt; length in bytes &gt; preSharedKey
 266      * &lt; 1 byte &gt; pskIdentity length
 267      * &lt; length in bytes &gt; pskIdentity
 268      * &lt; 1 byte &gt; masterSecret length
 269      *   &lt; 1 byte &gt; masterSecret algorithm length
 270      *   &lt; length in bytes &gt; masterSecret algorithm
 271      *   &lt; 2 bytes &gt; masterSecretKey length
 272      *   &lt; length in bytes&gt; masterSecretKey
 273      * &lt; 1 byte &gt; useExtendedMasterSecret
 274      * &lt; 1 byte &gt; identificationProtocol length
 275      * &lt; length in bytes &gt; identificationProtocol
 276      * &lt; 1 byte &gt; serverNameIndication length
 277      * &lt; length in bytes &gt; serverNameIndication
 278      * &lt; 1 byte &gt; Number of requestedServerNames entries
 279      *   &lt; 1 byte &gt; ServerName length
 280      *   &lt; length in bytes &gt; ServerName
 281      * &lt; 4 bytes &gt; creationTime
 282      * &lt; 2 byte &gt; status response length
 283      *   &lt; 2 byte &gt; status response entry length
 284      *   &lt; length in byte &gt; status response entry
 285      * &lt; 1 byte &gt; Length of peer host
 286      *   &lt; length in bytes &gt; peer host
 287      * &lt; 2 bytes&gt; peer port
 288      * &lt; 1 byte &gt; Number of peerCerts entries
 289      *   &lt; 4 byte &gt; peerCert length
 290      *   &lt; length in bytes &gt; peerCert
 291      * &lt; 1 byte &gt; localCerts type (Cert, PSK, Anonymous)
 292      *   Certificate
 293      *     &lt; 1 byte &gt; Number of Certificate entries
 294      *       &lt; 4 byte&gt; Certificate length
 295      *       &lt; length in bytes&gt; Certificate
 296      *   PSK
 297      *     &lt; 1 byte &gt; Number of PSK entries
 298      *       &lt; 1 bytes &gt; PSK algorithm length
 299      *       &lt; length in bytes &gt; PSK algorithm string
 300      *       &lt; 4 bytes &gt; PSK key length
 301      *       &lt; length in bytes&gt; PSK key
 302      *       &lt; 4 bytes &gt; PSK identity length
 303      *       &lt; length in bytes&gt; PSK identity
 304      *   Anonymous
 305      *     &lt; 1 byte &gt;
 306      * &lt; 4 bytes &gt; maximumPacketSize
 307      * &lt; 4 bytes &gt; negotiatedMaxFragSize
 308      */
 309 
 310     SSLSessionImpl(HandshakeContext hc, ByteBuffer buf) throws IOException {
 311         int i = 0;
 312         byte[] b;
 313 
 314         boundValues = new ConcurrentHashMap&lt;&gt;();
 315         this.protocolVersion =
 316                 ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));
 317 
 318         // The CH session id may reset this if it&#39;s provided
 319         this.sessionId = new SessionId(true,
 320                 hc.sslContext.getSecureRandom());
 321 
 322         this.cipherSuite =
 323                 CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));
 324 
 325         // Local Supported signature algorithms
 326         ArrayList&lt;SignatureScheme&gt; list = new ArrayList&lt;&gt;();
 327         i = Byte.toUnsignedInt(buf.get());
 328         while (i-- &gt; 0) {
 329             list.add(SignatureScheme.valueOf(
 330                     Short.toUnsignedInt(buf.getShort())));
 331         }
 332         this.localSupportedSignAlgs = Collections.unmodifiableCollection(list);
 333 
 334         // Peer Supported signature algorithms
 335         i = Byte.toUnsignedInt(buf.get());
 336         list.clear();
 337         while (i-- &gt; 0) {
 338             list.add(SignatureScheme.valueOf(
 339                     Short.toUnsignedInt(buf.getShort())));
 340         }
 341         this.peerSupportedSignAlgs = Collections.unmodifiableCollection(list);
 342 
 343         // PSK
 344         i = Short.toUnsignedInt(buf.getShort());
 345         if (i &gt; 0) {
 346             b = new byte[i];
 347             // Get algorithm string
 348             buf.get(b, 0, i);
 349             // Encoded length
 350             i = Short.toUnsignedInt(buf.getShort());
 351             // Encoded SecretKey
 352             b = new byte[i];
 353             buf.get(b);
 354             this.preSharedKey = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);
 355         } else {
 356             this.preSharedKey = null;
 357         }
 358 
 359         // PSK identity
 360         i = buf.get();
 361         if (i &gt; 0) {
 362             b = new byte[i];
 363             buf.get(b);
 364             this.pskIdentity = b;
 365         } else {
 366             this.pskIdentity = null;
 367         }
 368 
 369         // Master secret length of secret key algorithm  (one byte)
 370         i = buf.get();
 371         if (i &gt; 0) {
 372             b = new byte[i];
 373             // Get algorithm string
 374             buf.get(b, 0, i);
 375             // Encoded length
 376             i = Short.toUnsignedInt(buf.getShort());
 377             // Encoded SecretKey
 378             b = new byte[i];
 379             buf.get(b);
 380             this.masterSecret = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);
 381         } else {
 382             this.masterSecret = null;
 383         }
 384         // Use extended master secret
 385         this.useExtendedMasterSecret = (buf.get() != 0);
 386 
 387         // Identification Protocol
 388         i = buf.get();
 389         if (i == 0) {
 390             identificationProtocol = null;
 391         } else {
 392             b = new byte[i];
 393             buf.get(b);
 394             identificationProtocol = new String(b);
 395         }
 396 
 397         // SNI
 398         i = buf.get();  // length
 399         if (i == 0) {
 400             serverNameIndication = null;
 401         } else {
 402             b = new byte[i];
 403             buf.get(b, 0, b.length);
 404             serverNameIndication = new SNIHostName(b);
 405         }
 406 
 407         // List of SNIServerName
 408         int len = Short.toUnsignedInt(buf.getShort());
 409         if (len == 0) {
 410             this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 411         } else {
 412             requestedServerNames = new ArrayList&lt;&gt;();
 413             while (len &gt; 0) {
 414                 int l = buf.get();
 415                 b = new byte[l];
 416                 buf.get(b, 0, l);
 417                 requestedServerNames.add(new SNIHostName(new String(b)));
 418                 len--;
 419             }
 420         }
 421 
 422         maximumPacketSize = buf.getInt();
 423         negotiatedMaxFragLen = buf.getInt();
 424 
 425         // Get creation time
 426         this.creationTime = buf.getLong();
 427 
 428         // Get Buffer sizes
 429 
 430         // Status Response
 431         len = Short.toUnsignedInt(buf.getShort());
 432         if (len == 0) {
 433             statusResponses = Collections.emptyList();
 434         } else {
 435             statusResponses = new ArrayList&lt;&gt;();
 436         }
 437         while (len-- &gt; 0) {
 438             b = new byte[Short.toUnsignedInt(buf.getShort())];
 439             buf.get(b);
 440             statusResponses.add(b);
 441         }
 442 
 443         // Get Peer host &amp; port
 444         i = Byte.toUnsignedInt(buf.get());
 445         if (i == 0) {
 446             this.host = new String();
 447         } else {
 448             b = new byte[i];
 449             buf.get(b, 0, i);
 450             this.host = new String(b);
 451         }
 452         this.port = Short.toUnsignedInt(buf.getShort());
 453 
 454         // Peer certs
 455         i = buf.get();
 456         if (i == 0) {
 457             this.peerCerts = null;
 458         } else {
 459             this.peerCerts = new X509Certificate[i];
 460             int j = 0;
 461             while (i &gt; j) {
 462                 b = new byte[buf.getInt()];
 463                 buf.get(b);
 464                 try {
 465                     this.peerCerts[j] = new X509CertImpl(b);
 466                 } catch (Exception e) {
 467                     throw new IOException(e);
 468                 }
 469                 j++;
 470             }
 471         }
 472 
 473         // Get local certs of PSK
 474         switch (buf.get()) {
 475             case 0:
 476                 break;
 477             case 1:
 478                 // number of certs
 479                 len = buf.get();
 480                 this.localCerts = new X509Certificate[len];
 481                 i = 0;
 482                 while (len &gt; i) {
 483                     b = new byte[buf.getInt()];
 484                     buf.get(b);
 485                     try {
 486                         this.localCerts[i] = new X509CertImpl(b);
 487                     } catch (Exception e) {
 488                         throw new IOException(e);
 489                     }
 490                     i++;
 491                 }
 492                 break;
 493             case 2:
 494                 // pre-shared key
 495                 // Length of pre-shared key algorithm  (one byte)
 496                 i = buf.get();
 497                 b = new byte[i];
 498                 buf.get(b, 0 , i);
 499                 String alg = new String(b);
 500                 // Get length of encoding
 501                 i = Short.toUnsignedInt(buf.getShort());
 502                 // Get encoding
 503                 b = new byte[i];
 504                 buf.get(b);
 505                 this.preSharedKey = new SecretKeySpec(b, alg);
 506                 // Get identity len
 507                 this.pskIdentity = new byte[buf.get()];
 508                 buf.get(pskIdentity);
 509                 break;
 510             default:
 511                 throw new SSLException(&quot;Failed local certs of session.&quot;);
 512         }
 513 
 514         context = (SSLSessionContextImpl)
 515                 hc.sslContext.engineGetServerSessionContext();
 516         this.lastUsedTime = System.currentTimeMillis();
 517     }
 518 
 519     // Some situations we cannot provide a stateless ticket, but after it
 520     // has been negotiated
 521     boolean isStatelessable() {
 522         // If there is no getMasterSecret with TLS1.2 or under, do not resume.
 523         if (!protocolVersion.useTLS13PlusSpec() &amp;&amp;
 524                 getMasterSecret().getEncoded() == null) {
 525             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 526                 SSLLogger.finest(&quot;No MasterSecret, cannot make stateless&quot; +
 527                         &quot; ticket&quot;);
 528             }
 529             return false;
 530         }
 531 
 532         if (boundValues != null &amp;&amp; boundValues.size() &gt; 0) {
 533             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 534                 SSLLogger.finest(&quot;There are boundValues, cannot make&quot; +
 535                         &quot; stateless ticket&quot;);
 536             }
 537             return false;
 538         }
 539 
 540         return true;
 541     }
 542 
 543     /**
 544      * Write out a SSLSessionImpl in a byte array for a stateless session ticket
 545      */
 546     byte[] write() throws Exception {
 547         byte[] b;
 548         HandshakeOutStream hos = new HandshakeOutStream(null);
 549 
 550         hos.putInt16(protocolVersion.id);
 551         hos.putInt16(cipherSuite.id);
 552 
 553         // Local Supported signature algorithms
 554         hos.putInt8(localSupportedSignAlgs.size());
 555         for (SignatureScheme s : localSupportedSignAlgs) {
 556             hos.putInt16(s.id);
 557         }
 558 
 559         // Peer Supported signature algorithms
 560         hos.putInt8(peerSupportedSignAlgs.size());
 561         for (SignatureScheme s : peerSupportedSignAlgs) {
 562             hos.putInt16(s.id);
 563         }
 564 
 565         // PSK
 566         if (preSharedKey == null ||
 567                 preSharedKey.getAlgorithm() == null) {
 568             hos.putInt16(0);
 569         } else {
 570             hos.putInt16(preSharedKey.getAlgorithm().length());
 571             if (preSharedKey.getAlgorithm().length() != 0) {
 572                 hos.write(preSharedKey.getAlgorithm().getBytes());
 573             }
 574             b = preSharedKey.getEncoded();
 575             hos.putInt16(b.length);
 576             hos.write(b, 0, b.length);
 577         }
 578 
 579         // PSK Identity
 580         if (pskIdentity == null) {
 581             hos.putInt8(0);
 582         } else {
 583             hos.putInt8(pskIdentity.length);
 584             hos.write(pskIdentity, 0, pskIdentity.length);
 585         }
 586 
 587         // Master Secret
 588         if (getMasterSecret() == null ||
 589                 getMasterSecret().getAlgorithm() == null) {
 590             hos.putInt8(0);
 591         } else {
 592             hos.putInt8(getMasterSecret().getAlgorithm().length());
 593             if (getMasterSecret().getAlgorithm().length() != 0) {
 594                 hos.write(getMasterSecret().getAlgorithm().getBytes());
 595             }
 596             b = getMasterSecret().getEncoded();
 597             hos.putInt16(b.length);
 598             hos.write(b, 0, b.length);
 599         }
 600 
 601         hos.putInt8(useExtendedMasterSecret ? 1 : 0);
 602 
 603         // Identification Protocol
 604         if (identificationProtocol == null) {
 605             hos.putInt8(0);
 606         } else {
 607             hos.putInt8(identificationProtocol.length());
 608             hos.write(identificationProtocol.getBytes(), 0,
 609                     identificationProtocol.length());
 610         }
 611 
 612         // SNI
 613         if (serverNameIndication == null) {
 614             hos.putInt8(0);
 615         } else {
 616             b = serverNameIndication.getEncoded();
 617             hos.putInt8(b.length);
 618             hos.write(b, 0, b.length);
 619         }
 620 
 621         // List of SNIServerName
 622         hos.putInt16(requestedServerNames.size());
 623         if (requestedServerNames.size() &gt; 0) {
 624             for (SNIServerName sn : requestedServerNames) {
 625                 b = sn.getEncoded();
 626                 hos.putInt8(b.length);
 627                 hos.write(b, 0, b.length);
 628             }
 629         }
 630 
 631         // Buffer sizes
 632         hos.putInt32(maximumPacketSize);
 633         hos.putInt32(negotiatedMaxFragLen);
 634 
 635         // creation time
 636         ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
 637         hos.writeBytes(buffer.putLong(creationTime).array());
 638 
 639         // Status Responses
 640         List&lt;byte[]&gt; list = getStatusResponses();
 641         int l = list.size();
 642         hos.putInt16(l);
 643         for (byte[] e : list) {
 644             hos.putInt16(e.length);
 645             hos.write(e);
 646         }
 647 
 648         // peer Host &amp; Port
 649         if (host == null || host.length() == 0) {
 650             hos.putInt8(0);
 651         } else {
 652             hos.putInt8(host.length());
 653             hos.writeBytes(host.getBytes());
 654         }
 655         hos.putInt16(port);
 656 
 657         // Peer cert
 658         if (peerCerts == null || peerCerts.length == 0) {
 659             hos.putInt8(0);
 660         } else {
 661             hos.putInt8(peerCerts.length);
 662             for (X509Certificate c : peerCerts) {
 663                 b = c.getEncoded();
 664                 hos.putInt32(b.length);
 665                 hos.writeBytes(b);
 666             }
 667         }
 668 
 669         // Client identity
 670         if (localCerts != null &amp;&amp; localCerts.length &gt; 0) {
 671             // certificate based
 672             hos.putInt8(1);
 673             hos.putInt8(localCerts.length);
 674             for (X509Certificate c : localCerts) {
 675                 b = c.getEncoded();
 676                 hos.putInt32(b.length);
 677                 hos.writeBytes(b);
 678             }
 679         } else if (preSharedKey != null) {
 680             // pre-shared key
 681             hos.putInt8(2);
 682             hos.putInt8(preSharedKey.getAlgorithm().length());
 683             hos.write(preSharedKey.getAlgorithm().getBytes());
 684             b = preSharedKey.getEncoded();
 685             hos.putInt32(b.length);
 686             hos.writeBytes(b);
 687             hos.putInt32(pskIdentity.length);
 688             hos.writeBytes(pskIdentity);
 689         } else {
 690             // anonymous
 691             hos.putInt8(0);
 692         }
 693 
 694         return hos.toByteArray();
 695     }
 696 
 697     void setMasterSecret(SecretKey secret) {
 698         masterSecret = secret;
 699     }
 700 
 701     void setResumptionMasterSecret(SecretKey secret) {
 702         resumptionMasterSecret = secret;
 703     }
 704 
 705     void setPreSharedKey(SecretKey key) {
 706         preSharedKey = key;
 707     }
 708 
 709     void addChild(SSLSessionImpl session) {
 710         childSessions.add(session);
 711     }
 712 
 713     void setTicketAgeAdd(int ticketAgeAdd) {
 714         this.ticketAgeAdd = ticketAgeAdd;
 715     }
 716 
 717     void setPskIdentity(byte[] pskIdentity) {
 718         this.pskIdentity = pskIdentity;
 719     }
 720 
 721     BigInteger incrTicketNonceCounter() {
 722         BigInteger result = ticketNonceCounter;
 723         ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);
 724         return result;
 725     }
 726 
 727     boolean isPSKable() {
 728         return (ticketNonceCounter.compareTo(BigInteger.ZERO) &gt; 0);
 729     }
 730 
 731     /**
 732      * Returns the master secret ... treat with extreme caution!
 733      */
 734     SecretKey getMasterSecret() {
 735         return masterSecret;
 736     }
 737 
 738     SecretKey getResumptionMasterSecret() {
 739         return resumptionMasterSecret;
 740     }
 741 
 742     SecretKey getPreSharedKey() {
 743         sessionLock.lock();
 744         try {
 745             return preSharedKey;
 746         } finally {
 747             sessionLock.unlock();
 748         }
 749     }
 750 
 751     SecretKey consumePreSharedKey() {
 752         sessionLock.lock();
 753         try {
 754             return preSharedKey;
 755         } finally {
 756             preSharedKey = null;
 757             sessionLock.unlock();
 758         }
 759     }
 760 
 761     int getTicketAgeAdd() {
 762         return ticketAgeAdd;
 763     }
 764 
 765     String getIdentificationProtocol() {
 766         return this.identificationProtocol;
 767     }
 768 
 769     /* PSK identities created from new_session_ticket messages should only
 770      * be used once. This method will return the identity and then clear it
 771      * so it cannot be used again.
 772      */
 773     byte[] consumePskIdentity() {
 774         sessionLock.lock();
 775         try {
 776             return pskIdentity;
 777         } finally {
 778             pskIdentity = null;
 779             sessionLock.unlock();
 780         }
 781     }
 782 
 783     byte[] getPskIdentity() {
 784         return pskIdentity;
 785     }
 786 
 787     void setPeerCertificates(X509Certificate[] peer) {
 788         if (peerCerts == null) {
 789             peerCerts = peer;
 790         }
 791     }
 792 
 793     void setLocalCertificates(X509Certificate[] local) {
 794         localCerts = local;
 795     }
 796 
 797     void setLocalPrivateKey(PrivateKey privateKey) {
 798         localPrivateKey = privateKey;
 799     }
 800 
 801     void setPeerSupportedSignatureAlgorithms(
 802             Collection&lt;SignatureScheme&gt; signatureSchemes) {
 803         peerSupportedSignAlgs = signatureSchemes;
 804     }
 805 
 806     // TLS 1.2 only
 807     //
 808     // Per RFC 5246, If the client supports only the default hash
 809     // and signature algorithms, it MAY omit the
 810     // signature_algorithms extension.  If the client does not
 811     // support the default algorithms, or supports other hash
 812     // and signature algorithms (and it is willing to use them
 813     // for verifying messages sent by the server, i.e., server
 814     // certificates and server key exchange), it MUST send the
 815     // signature_algorithms extension, listing the algorithms it
 816     // is willing to accept.
 817     private static final ArrayList&lt;SignatureScheme&gt; defaultPeerSupportedSignAlgs =
 818             new ArrayList&lt;&gt;(Arrays.asList(SignatureScheme.RSA_PKCS1_SHA1,
 819                     SignatureScheme.DSA_SHA1,
 820                     SignatureScheme.ECDSA_SHA1));
 821 
 822     void setUseDefaultPeerSignAlgs() {
 823         useDefaultPeerSignAlgs = true;
 824         peerSupportedSignAlgs = defaultPeerSupportedSignAlgs;
 825     }
 826 
 827     // Returns the connection session.
 828     SSLSessionImpl finish() {
 829         if (useDefaultPeerSignAlgs) {
 830             peerSupportedSignAlgs = Collections.emptySet();
 831         }
 832 
 833         return this;
 834     }
 835 
 836     /**
 837      * Provide status response data obtained during the SSL handshake.
 838      *
 839      * @param responses a {@link List} of responses in binary form.
 840      */
 841     void setStatusResponses(List&lt;byte[]&gt; responses) {
 842         if (responses != null &amp;&amp; !responses.isEmpty()) {
 843             statusResponses = responses;
 844         } else {
 845             statusResponses = Collections.emptyList();
 846         }
 847     }
 848 
 849     /**
 850      * Returns true iff this session may be resumed ... sessions are
 851      * usually resumable.  Security policies may suggest otherwise,
 852      * for example sessions that haven&#39;t been used for a while (say,
 853      * a working day) won&#39;t be resumable, and sessions might have a
 854      * maximum lifetime in any case.
 855      */
 856     boolean isRejoinable() {
 857         // TLS 1.3 can have no session id
 858         if (protocolVersion.useTLS13PlusSpec()) {
 859             return (!invalidated &amp;&amp; isLocalAuthenticationValid());
 860         }
 861         return sessionId != null &amp;&amp; sessionId.length() != 0 &amp;&amp;
 862                 !invalidated &amp;&amp; isLocalAuthenticationValid();
 863     }
 864 
 865     @Override
 866     public boolean isValid() {
 867         sessionLock.lock();
 868         try {
 869             return isRejoinable();
 870         } finally {
 871             sessionLock.unlock();
 872         }
 873     }
 874 
 875     /**
 876      * Check if the authentication used when establishing this session
 877      * is still valid. Returns true if no authentication was used
 878      */
 879     private boolean isLocalAuthenticationValid() {
 880         if (localPrivateKey != null) {
 881             try {
 882                 // if the private key is no longer valid, getAlgorithm()
 883                 // should throw an exception
 884                 // (e.g. Smartcard has been removed from the reader)
 885                 localPrivateKey.getAlgorithm();
 886             } catch (Exception e) {
 887                 invalidate();
 888                 return false;
 889             }
 890         }
 891 
 892         return true;
 893     }
 894 
 895     /**
 896      * Returns the ID for this session.  The ID is fixed for the
 897      * duration of the session; neither it, nor its value, changes.
 898      */
 899     @Override
 900     public byte[] getId() {
 901         return sessionId.getId();
 902     }
 903 
 904     /**
 905      * For server sessions, this returns the set of sessions which
 906      * are currently valid in this process.  For client sessions,
 907      * this returns null.
 908      */
 909     @Override
 910     public SSLSessionContext getSessionContext() {
 911         /*
 912          * An interim security policy until we can do something
 913          * more specific in 1.2. Only allow trusted code (code which
 914          * can set system properties) to get an
 915          * SSLSessionContext. This is to limit the ability of code to
 916          * look up specific sessions or enumerate over them. Otherwise,
 917          * code can only get session objects from successful SSL
 918          * connections which implies that they must have had permission
 919          * to make the network connection in the first place.
 920          */
 921         SecurityManager sm;
 922         if ((sm = System.getSecurityManager()) != null) {
 923             sm.checkPermission(new SSLPermission(&quot;getSSLSessionContext&quot;));
 924         }
 925 
 926         return context;
 927     }
 928 
 929 
 930     SessionId getSessionId() {
 931         return sessionId;
 932     }
 933 
 934 
 935     /**
 936      * Returns the cipher spec in use on this session
 937      */
 938     CipherSuite getSuite() {
 939         return cipherSuite;
 940     }
 941 
 942     /**
 943      * Resets the cipher spec in use on this session
 944      */
 945     void setSuite(CipherSuite suite) {
 946        cipherSuite = suite;
 947 
 948         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 949              SSLLogger.finest(&quot;Negotiating session:  &quot; + this);
 950        }
 951     }
 952 
 953     /**
 954      * Return true if the session is currently re-established with a
 955      * session-resumption abbreviated initial handshake.
 956      */
 957     boolean isSessionResumption() {
 958         return isSessionResumption;
 959     }
 960 
 961     /**
 962      * Resets whether the session is re-established with a session-resumption
 963      * abbreviated initial handshake.
 964      */
 965     void setAsSessionResumption(boolean flag) {
 966         isSessionResumption = flag;
 967     }
 968 
 969     /**
 970      * Returns the name of the cipher suite in use on this session
 971      */
 972     @Override
 973     public String getCipherSuite() {
 974         return getSuite().name;
 975     }
 976 
 977     ProtocolVersion getProtocolVersion() {
 978         return protocolVersion;
 979     }
 980 
 981     /**
 982      * Returns the standard name of the protocol in use on this session
 983      */
 984     @Override
 985     public String getProtocol() {
 986         return getProtocolVersion().name;
 987     }
 988 
 989     /**
 990      * Returns the hashcode for this session
 991      */
 992     @Override
 993     public int hashCode() {
 994         return sessionId.hashCode();
 995     }
 996 
 997     /**
 998      * Returns true if sessions have same ids, false otherwise.
 999      */
1000     @Override
1001     public boolean equals(Object obj) {
1002 
1003         if (obj == this) {
1004             return true;
1005         }
1006 
1007         if (obj instanceof SSLSessionImpl) {
1008             SSLSessionImpl sess = (SSLSessionImpl) obj;
1009             return (sessionId != null) &amp;&amp; (sessionId.equals(
1010                         sess.getSessionId()));
1011         }
1012 
1013         return false;
1014     }
1015 
1016 
1017     /**
1018      * Return the cert chain presented by the peer in the
1019      * java.security.cert format.
1020      * Note: This method can be used only when using certificate-based
1021      * cipher suites; using it with non-certificate-based cipher suites
1022      * will throw an SSLPeerUnverifiedException.
1023      *
1024      * @return array of peer X.509 certs, with the peer&#39;s own cert
1025      *  first in the chain, and with the &quot;root&quot; CA last.
1026      */
1027     @Override
1028     public java.security.cert.Certificate[] getPeerCertificates()
1029             throws SSLPeerUnverifiedException {
1030         //
1031         // clone to preserve integrity of session ... caller can&#39;t
1032         // change record of peer identity even by accident, much
1033         // less do it intentionally.
1034         //
1035         if (peerCerts == null) {
1036             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1037         }
1038         // Certs are immutable objects, therefore we don&#39;t clone them.
1039         // But do need to clone the array, so that nothing is inserted
1040         // into peerCerts.
1041         return (java.security.cert.Certificate[])peerCerts.clone();
1042     }
1043 
1044     /**
1045      * Return the cert chain presented to the peer in the
1046      * java.security.cert format.
1047      * Note: This method is useful only when using certificate-based
1048      * cipher suites.
1049      *
1050      * @return array of peer X.509 certs, with the peer&#39;s own cert
1051      *  first in the chain, and with the &quot;root&quot; CA last.
1052      */
1053     @Override
1054     public java.security.cert.Certificate[] getLocalCertificates() {
1055         //
1056         // clone to preserve integrity of session ... caller can&#39;t
1057         // change record of peer identity even by accident, much
1058         // less do it intentionally.
1059         return (localCerts == null ? null :
1060             (java.security.cert.Certificate[])localCerts.clone());
1061     }
1062 
1063     /**
1064      * Return the cert chain presented by the peer.
1065      * Note: This method can be used only when using certificate-based
1066      * cipher suites; using it with non-certificate-based cipher suites
1067      * will throw an SSLPeerUnverifiedException.
1068      *
1069      * @return array of peer X.509 certs, with the peer&#39;s own cert
1070      *  first in the chain, and with the &quot;root&quot; CA last.
1071      */
1072     public X509Certificate[] getCertificateChain()
1073             throws SSLPeerUnverifiedException {
1074         /*
1075          * clone to preserve integrity of session ... caller can&#39;t
1076          * change record of peer identity even by accident, much
1077          * less do it intentionally.
1078          */
1079         if (peerCerts != null) {
1080             return peerCerts.clone();
1081         } else {
1082             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1083         }
1084     }
1085 
1086     /**
1087      * Return a List of status responses presented by the peer.
1088      * Note: This method can be used only when using certificate-based
1089      * server authentication; otherwise an empty {@code List} will be returned.
1090      *
1091      * @return an unmodifiable {@code List} of byte arrays, each consisting
1092      * of a DER-encoded OCSP response (see RFC 6960).  If no responses have
1093      * been presented by the server or non-certificate based server
1094      * authentication is used then an empty {@code List} is returned.
1095      */
1096     @Override
1097     public List&lt;byte[]&gt; getStatusResponses() {
1098         if (statusResponses == null || statusResponses.isEmpty()) {
1099             return Collections.emptyList();
1100         } else {
1101             // Clone both the list and the contents
1102             List&lt;byte[]&gt; responses = new ArrayList&lt;&gt;(statusResponses.size());
1103             for (byte[] respBytes : statusResponses) {
1104                 responses.add(respBytes.clone());
1105             }
1106             return Collections.unmodifiableList(responses);
1107         }
1108     }
1109 
1110     /**
1111      * Returns the identity of the peer which was established as part of
1112      * defining the session.
1113      *
1114      * @return the peer&#39;s principal. Returns an X500Principal of the
1115      * end-entity certificate for X509-based cipher suites.
1116      *
1117      * @throws SSLPeerUnverifiedException if the peer&#39;s identity has not
1118      *          been verified
1119      */
1120     @Override
1121     public Principal getPeerPrincipal()
1122                 throws SSLPeerUnverifiedException
1123     {
1124         if (peerCerts == null) {
1125             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1126         }
1127         return peerCerts[0].getSubjectX500Principal();
1128     }
1129 
1130     /**
1131      * Returns the principal that was sent to the peer during handshaking.
1132      *
1133      * @return the principal sent to the peer. Returns an X500Principal
1134      * of the end-entity certificate for X509-based cipher suites.
1135      * If no principal was sent, then null is returned.
1136      */
1137     @Override
1138     public Principal getLocalPrincipal() {
1139         return ((localCerts == null || localCerts.length == 0) ? null :
1140                 localCerts[0].getSubjectX500Principal());
1141     }
1142 
1143     /*
1144      * Return the time the ticket for this session was created.
1145      */
1146     public long getTicketCreationTime() {
1147         return ticketCreationTime;
1148     }
1149 
1150     /**
1151      * Returns the time this session was created.
1152      */
1153     @Override
1154     public long getCreationTime() {
1155         return creationTime;
1156     }
1157 
1158     /**
1159      * Returns the last time this session was used to initialize
1160      * a connection.
1161      */
1162     @Override
1163     public long getLastAccessedTime() {
1164         return (lastUsedTime != 0) ? lastUsedTime : creationTime;
1165     }
1166 
1167     void setLastAccessedTime(long time) {
1168         lastUsedTime = time;
1169     }
1170 
1171 
1172     /**
1173      * Returns the network address of the session&#39;s peer.  This
1174      * implementation does not insist that connections between
1175      * different ports on the same host must necessarily belong
1176      * to different sessions, though that is of course allowed.
1177      */
1178     public InetAddress getPeerAddress() {
1179         try {
1180             return InetAddress.getByName(host);
1181         } catch (java.net.UnknownHostException e) {
1182             return null;
1183         }
1184     }
1185 
1186     @Override
1187     public String getPeerHost() {
1188         return host;
1189     }
1190 
1191     /**
1192      * Need to provide the port info for caching sessions based on
1193      * host and port. Accessed by SSLSessionContextImpl
1194      */
1195     @Override
1196     public int getPeerPort() {
1197         return port;
1198     }
1199 
1200     void setContext(SSLSessionContextImpl ctx) {
1201         if (context == null) {
1202             context = ctx;
1203         }
1204     }
1205 
1206     /**
1207      * Invalidate a session.  Active connections may still exist, but
1208      * no connections will be able to rejoin this session.
1209      */
1210     @Override
1211     public void invalidate() {
1212         sessionLock.lock();
1213         try {
1214             if (context != null) {
1215                 context.remove(sessionId);
1216                 context = null;
1217             }
1218 
1219             if (invalidated) {
1220                 return;
1221             }
1222             invalidated = true;
1223             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
1224                  SSLLogger.finest(&quot;Invalidated session:  &quot; + this);
1225             }
1226             for (SSLSessionImpl child : childSessions) {
1227                 child.invalidate();
1228             }
1229         } finally {
1230             sessionLock.unlock();
1231         }
1232     }
1233 
1234     /*
1235      * Table of application-specific session data indexed by an application
1236      * key and the calling security context. This is important since
1237      * sessions can be shared across different protection domains.
1238      */
1239     private final ConcurrentHashMap&lt;SecureKey, Object&gt; boundValues;
1240     boolean updateNST;
1241 
1242     /**
1243      * Assigns a session value.  Session change events are given if
1244      * appropriate, to any original value as well as the new value.
1245      */
1246     @Override
1247     public void putValue(String key, Object value) {
1248         if ((key == null) || (value == null)) {
1249             throw new IllegalArgumentException(&quot;arguments can not be null&quot;);
1250         }
1251 
1252         SecureKey secureKey = new SecureKey(key);
1253         Object oldValue = boundValues.put(secureKey, value);
1254 
1255         if (oldValue instanceof SSLSessionBindingListener) {
1256             SSLSessionBindingEvent e;
1257 
1258             e = new SSLSessionBindingEvent(this, key);
1259             ((SSLSessionBindingListener)oldValue).valueUnbound(e);
1260         }
1261         if (value instanceof SSLSessionBindingListener) {
1262             SSLSessionBindingEvent e;
1263 
1264             e = new SSLSessionBindingEvent(this, key);
1265             ((SSLSessionBindingListener)value).valueBound(e);
1266         }
1267         if (protocolVersion.useTLS13PlusSpec()) {
1268             updateNST = true;
1269         }
1270     }
1271 
1272     /**
1273      * Returns the specified session value.
1274      */
1275     @Override
1276     public Object getValue(String key) {
1277         if (key == null) {
1278             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1279         }
1280 
1281         SecureKey secureKey = new SecureKey(key);
1282         return boundValues.get(secureKey);
1283     }
1284 
1285 
1286     /**
1287      * Removes the specified session value, delivering a session changed
1288      * event as appropriate.
1289      */
1290     @Override
1291     public void removeValue(String key) {
1292         if (key == null) {
1293             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1294         }
1295 
1296         SecureKey secureKey = new SecureKey(key);
1297         Object value = boundValues.remove(secureKey);
1298 
1299         if (value instanceof SSLSessionBindingListener) {
1300             SSLSessionBindingEvent e;
1301 
1302             e = new SSLSessionBindingEvent(this, key);
1303             ((SSLSessionBindingListener)value).valueUnbound(e);
1304         }
1305         if (protocolVersion.useTLS13PlusSpec()) {
1306             updateNST = true;
1307         }
1308     }
1309 
1310 
1311     /**
1312      * Lists the names of the session values.
1313      */
1314     @Override
1315     public String[] getValueNames() {
1316         ArrayList&lt;Object&gt; v = new ArrayList&lt;&gt;();
1317         Object securityCtx = SecureKey.getCurrentSecurityContext();
1318         for (Enumeration&lt;SecureKey&gt; e = boundValues.keys();
1319                 e.hasMoreElements(); ) {
1320             SecureKey key = e.nextElement();
1321             if (securityCtx.equals(key.getSecurityContext())) {
1322                 v.add(key.getAppKey());
1323             }
1324         }
1325 
1326         return v.toArray(new String[0]);
1327     }
1328 
1329     /**
1330      * Use large packet sizes now or follow RFC 2246 packet sizes (2^14)
1331      * until changed.
1332      *
1333      * In the TLS specification (section 6.2.1, RFC2246), it is not
1334      * recommended that the plaintext has more than 2^14 bytes.
1335      * However, some TLS implementations violate the specification.
1336      * This is a workaround for interoperability with these stacks.
1337      *
1338      * Application could accept large fragments up to 2^15 bytes by
1339      * setting the system property jsse.SSLEngine.acceptLargeFragments
1340      * to &quot;true&quot;.
1341      */
1342     private boolean acceptLargeFragments =
1343             Utilities.getBooleanProperty(
1344                     &quot;jsse.SSLEngine.acceptLargeFragments&quot;, false);
1345 
1346     /**
1347      * Expand the buffer size of both SSL/TLS network packet and
1348      * application data.
1349      */
1350     protected void expandBufferSizes() {
1351         sessionLock.lock();
1352         try {
1353             acceptLargeFragments = true;
1354         } finally {
1355             sessionLock.unlock();
1356         }
1357     }
1358 
1359     /**
1360      * Gets the current size of the largest SSL/TLS packet that is expected
1361      * when using this session.
1362      */
1363     @Override
1364     public int getPacketBufferSize() {
1365         sessionLock.lock();
1366         try {
1367             // Use the bigger packet size calculated from maximumPacketSize
1368             // and negotiatedMaxFragLen.
1369             int packetSize = 0;
1370             if (negotiatedMaxFragLen &gt; 0) {
1371                 packetSize = cipherSuite.calculatePacketSize(
1372                         negotiatedMaxFragLen, protocolVersion,
1373                         protocolVersion.isDTLS);
1374             }
1375 
1376             if (maximumPacketSize &gt; 0) {
1377                 return (maximumPacketSize &gt; packetSize) ?
1378                         maximumPacketSize : packetSize;
1379             }
1380 
1381             if (packetSize != 0) {
1382                return packetSize;
1383             }
1384 
1385             if (protocolVersion.isDTLS) {
1386                 return DTLSRecord.maxRecordSize;
1387             } else {
1388                 return acceptLargeFragments ?
1389                         SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;
1390             }
1391         } finally {
1392             sessionLock.unlock();
1393         }
1394     }
1395 
1396     /**
1397      * Gets the current size of the largest application data that is
1398      * expected when using this session.
1399      */
1400     @Override
1401     public int getApplicationBufferSize() {
1402         sessionLock.lock();
1403         try {
1404             // Use the bigger fragment size calculated from maximumPacketSize
1405             // and negotiatedMaxFragLen.
1406             int fragmentSize = 0;
1407             if (maximumPacketSize &gt; 0) {
1408                 fragmentSize = cipherSuite.calculateFragSize(
1409                         maximumPacketSize, protocolVersion,
1410                         protocolVersion.isDTLS);
1411             }
1412 
1413             if (negotiatedMaxFragLen &gt; 0) {
1414                 return (negotiatedMaxFragLen &gt; fragmentSize) ?
1415                         negotiatedMaxFragLen : fragmentSize;
1416             }
1417 
1418             if (fragmentSize != 0) {
1419                 return fragmentSize;
1420             }
1421 
1422             if (protocolVersion.isDTLS) {
1423                 return Record.maxDataSize;
1424             } else {
1425                 int maxPacketSize = acceptLargeFragments ?
1426                             SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;
1427                 return (maxPacketSize - SSLRecord.headerSize);
1428             }
1429         } finally {
1430             sessionLock.unlock();
1431         }
1432     }
1433 
1434     /**
1435      * Sets the negotiated maximum fragment length, as specified by the
1436      * max_fragment_length ClientHello extension in RFC 6066.
1437      *
1438      * @param  negotiatedMaxFragLen
1439      *         the negotiated maximum fragment length, or {@code -1} if
1440      *         no such length has been negotiated.
1441      */
1442     void setNegotiatedMaxFragSize(
1443             int negotiatedMaxFragLen) {
1444         sessionLock.lock();
1445         try {
1446             this.negotiatedMaxFragLen = negotiatedMaxFragLen;
1447         } finally {
1448             sessionLock.unlock();
1449         }
1450     }
1451 
1452     /**
1453      * Get the negotiated maximum fragment length, as specified by the
1454      * max_fragment_length ClientHello extension in RFC 6066.
1455      *
1456      * @return the negotiated maximum fragment length, or {@code -1} if
1457      *         no such length has been negotiated.
1458      */
1459     int getNegotiatedMaxFragSize() {
1460         sessionLock.lock();
1461         try {
1462             return negotiatedMaxFragLen;
1463         } finally {
1464             sessionLock.unlock();
1465         }
1466     }
1467 
1468     void setMaximumPacketSize(int maximumPacketSize) {
1469         sessionLock.lock();
1470         try {
1471             this.maximumPacketSize = maximumPacketSize;
1472         } finally {
1473             sessionLock.unlock();
1474         }
1475     }
1476 
1477     int getMaximumPacketSize() {
1478         sessionLock.lock();
1479         try {
1480             return maximumPacketSize;
1481         } finally {
1482             sessionLock.unlock();
1483         }
1484     }
1485 
1486     /**
1487      * Gets an array of supported signature algorithm names that the local
1488      * side is willing to verify.
1489      */
1490     @Override
1491     public String[] getLocalSupportedSignatureAlgorithms() {
1492         return SignatureScheme.getAlgorithmNames(localSupportedSignAlgs);
1493     }
1494 
1495     /**
1496      * Gets an array of supported signature schemes that the local side is
1497      * willing to verify.
1498      */
1499     public Collection&lt;SignatureScheme&gt; getLocalSupportedSignatureSchemes() {
1500         return localSupportedSignAlgs;
1501     }
1502 
1503     /**
1504      * Gets an array of supported signature algorithms that the peer is
1505      * able to verify.
1506      */
1507     @Override
1508     public String[] getPeerSupportedSignatureAlgorithms() {
1509         return SignatureScheme.getAlgorithmNames(peerSupportedSignAlgs);
1510     }
1511 
1512     /**
1513      * Obtains a &lt;code&gt;List&lt;/code&gt; containing all {@link SNIServerName}s
1514      * of the requested Server Name Indication (SNI) extension.
1515      */
1516     @Override
1517     public List&lt;SNIServerName&gt; getRequestedServerNames() {
1518         return requestedServerNames;
1519     }
1520 
1521     /** Returns a string representation of this SSL session */
1522     @Override
1523     public String toString() {
1524         return &quot;Session(&quot; + creationTime + &quot;|&quot; + getCipherSuite() + &quot;)&quot;;
1525     }
1526 }
1527 
1528 /**
1529  * This &quot;struct&quot; class serves as a Hash Key that combines an
1530  * application-specific key and a security context.
1531  */
1532 class SecureKey {
1533     private static final Object     nullObject = new Object();
1534     private final Object            appKey;
1535     private final Object            securityCtx;
1536 
1537     static Object getCurrentSecurityContext() {
1538         SecurityManager sm = System.getSecurityManager();
1539         Object context = null;
1540 
1541         if (sm != null)
1542             context = sm.getSecurityContext();
1543         if (context == null)
1544             context = nullObject;
1545         return context;
1546     }
1547 
1548     SecureKey(Object key) {
1549         this.appKey = key;
1550         this.securityCtx = getCurrentSecurityContext();
1551     }
1552 
1553     Object getAppKey() {
1554         return appKey;
1555     }
1556 
1557     Object getSecurityContext() {
1558         return securityCtx;
1559     }
1560 
1561     @Override
1562     public int hashCode() {
1563         return appKey.hashCode() ^ securityCtx.hashCode();
1564     }
1565 
1566     @Override
1567     public boolean equals(Object o) {
1568         return o instanceof SecureKey &amp;&amp; ((SecureKey)o).appKey.equals(appKey)
1569                         &amp;&amp; ((SecureKey)o).securityCtx.equals(securityCtx);
1570     }
1571 }
    </pre>
  </body>
</html>
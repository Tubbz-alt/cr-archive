<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/rsa/RSAKeyPairGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.rsa;
 27 
 28 import java.math.BigInteger;
 29 
 30 import java.security.*;
 31 import java.security.spec.AlgorithmParameterSpec;
 32 import java.security.spec.RSAKeyGenParameterSpec;
 33 
 34 import sun.security.jca.JCAUtil;
 35 import static sun.security.util.SecurityProviderConstants.DEF_RSA_KEY_SIZE;
 36 import static sun.security.util.SecurityProviderConstants.DEF_RSASSA_PSS_KEY_SIZE;
 37 import sun.security.x509.AlgorithmId;
 38 import static sun.security.rsa.RSAUtil.KeyType;
 39 
 40 /**
 41  * RSA keypair generation. Standard algorithm, minimum key length 512 bit.
 42  * We generate two random primes until we find two where phi is relative
 43  * prime to the public exponent. Default exponent is 65537. It has only bit 0
 44  * and bit 4 set, which makes it particularly efficient.
 45  *
 46  * @since   1.5
 47  * @author  Andreas Sterbenz
 48  */
 49 public abstract class RSAKeyPairGenerator extends KeyPairGeneratorSpi {
 50 
 51     // public exponent to use
 52     private BigInteger publicExponent;
 53 
 54     // size of the key to generate, &gt;= RSAKeyFactory.MIN_MODLEN
 55     private int keySize;
 56 
 57     private final KeyType type;
 58     private AlgorithmId rsaId;
 59 
 60     // PRNG to use
 61     private SecureRandom random;
 62 
 63     RSAKeyPairGenerator(KeyType type, int defKeySize) {
 64         this.type = type;
 65         // initialize to default in case the app does not call initialize()
 66         initialize(defKeySize, null);
 67     }
 68 
 69     // initialize the generator. See JCA doc
 70     public void initialize(int keySize, SecureRandom random) {
 71         try {
 72             initialize(new RSAKeyGenParameterSpec(keySize,
 73                     RSAKeyGenParameterSpec.F4), random);
 74         } catch (InvalidAlgorithmParameterException iape) {
 75             throw new InvalidParameterException(iape.getMessage());
 76         }
 77     }
 78 
 79     // second initialize method. See JCA doc.
 80     public void initialize(AlgorithmParameterSpec params, SecureRandom random)
 81             throws InvalidAlgorithmParameterException {
 82         if (params instanceof RSAKeyGenParameterSpec == false) {
 83             throw new InvalidAlgorithmParameterException
 84                 (&quot;Params must be instance of RSAKeyGenParameterSpec&quot;);
 85         }
 86 
 87         RSAKeyGenParameterSpec rsaSpec = (RSAKeyGenParameterSpec)params;
 88         int tmpKeySize = rsaSpec.getKeysize();
 89         BigInteger tmpPublicExponent = rsaSpec.getPublicExponent();
 90         AlgorithmParameterSpec tmpParams = rsaSpec.getKeyParams();
 91 
 92         if (tmpPublicExponent == null) {
 93             tmpPublicExponent = RSAKeyGenParameterSpec.F4;
 94         } else {
 95             if (tmpPublicExponent.compareTo(RSAKeyGenParameterSpec.F0) &lt; 0) {
 96                 throw new InvalidAlgorithmParameterException
 97                         (&quot;Public exponent must be 3 or larger&quot;);
 98             }
 99             if (!tmpPublicExponent.testBit(0)) {
100                 throw new InvalidAlgorithmParameterException
101                         (&quot;Public exponent must be an odd number&quot;);
102             }
103             if (tmpPublicExponent.bitLength() &gt; tmpKeySize) {
104                 throw new InvalidAlgorithmParameterException
105                         (&quot;Public exponent must be smaller than key size&quot;);
106             }
107         }
108 
109         // do not allow unreasonably large key sizes, probably user error
110         try {
111             RSAKeyFactory.checkKeyLengths(tmpKeySize, tmpPublicExponent,
112                 512, 64 * 1024);
113         } catch (InvalidKeyException e) {
114             throw new InvalidAlgorithmParameterException(
115                 &quot;Invalid key sizes&quot;, e);
116         }
117 
118         try {
119             this.rsaId = RSAUtil.createAlgorithmId(type, tmpParams);
120         } catch (ProviderException e) {
121             throw new InvalidAlgorithmParameterException(
122                 &quot;Invalid key parameters&quot;, e);
123         }
124 
125         this.keySize = tmpKeySize;
126         this.publicExponent = tmpPublicExponent;
127         this.random = random;
128     }
129 
130     // generate the keypair. See JCA doc
131     public KeyPair generateKeyPair() {
132         // accommodate odd key sizes in case anybody wants to use them
133         int lp = (keySize + 1) &gt;&gt; 1;
134         int lq = keySize - lp;
135         if (random == null) {
136             random = JCAUtil.getSecureRandom();
137         }
138         BigInteger e = publicExponent;
139         while (true) {
140             // generate two random primes of size lp/lq
141             BigInteger p = BigInteger.probablePrime(lp, random);
142             BigInteger q, n;
143             do {
144                 q = BigInteger.probablePrime(lq, random);
145                 // convention is for p &gt; q
146                 if (p.compareTo(q) &lt; 0) {
147                     BigInteger tmp = p;
148                     p = q;
149                     q = tmp;
150                 }
151                 // modulus n = p * q
152                 n = p.multiply(q);
153                 // even with correctly sized p and q, there is a chance that
154                 // n will be one bit short. re-generate the smaller prime if so
155             } while (n.bitLength() &lt; keySize);
156 
157             // phi = (p - 1) * (q - 1) must be relative prime to e
158             // otherwise RSA just won&#39;t work ;-)
159             BigInteger p1 = p.subtract(BigInteger.ONE);
160             BigInteger q1 = q.subtract(BigInteger.ONE);
161             BigInteger phi = p1.multiply(q1);
162             // generate new p and q until they work. typically
163             // the first try will succeed when using F4
164             if (e.gcd(phi).equals(BigInteger.ONE) == false) {
165                 continue;
166             }
167 
168             // private exponent d is the inverse of e mod phi
169             BigInteger d = e.modInverse(phi);
170 
171             // 1st prime exponent pe = d mod (p - 1)
172             BigInteger pe = d.mod(p1);
173             // 2nd prime exponent qe = d mod (q - 1)
174             BigInteger qe = d.mod(q1);
175 
176             // crt coefficient coeff is the inverse of q mod p
177             BigInteger coeff = q.modInverse(p);
178 
179             try {
180                 PublicKey publicKey = new RSAPublicKeyImpl(rsaId, n, e);
181                 PrivateKey privateKey = new RSAPrivateCrtKeyImpl(
182                     rsaId, n, e, d, p, q, pe, qe, coeff);
183                 return new KeyPair(publicKey, privateKey);
184             } catch (InvalidKeyException exc) {
185                 // invalid key exception only thrown for keys &lt; 512 bit,
186                 // will not happen here
187                 throw new RuntimeException(exc);
188             }
189         }
190     }
191 
192     public static final class Legacy extends RSAKeyPairGenerator {
193         public Legacy() {
194             super(KeyType.RSA, DEF_RSA_KEY_SIZE);
195         }
196     }
197 
198     public static final class PSS extends RSAKeyPairGenerator {
199         public PSS() {
200             super(KeyType.PSS, DEF_RSASSA_PSS_KEY_SIZE);
201         }
202     }
203 }
    </pre>
  </body>
</html>
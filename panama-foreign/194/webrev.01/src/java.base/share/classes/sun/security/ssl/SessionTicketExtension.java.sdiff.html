<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SessionTicketExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TransportContext.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SessionTicketExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
243 
244         SessionTicketSpec(HandshakeContext hc,
245                 ByteBuffer buf) throws IOException {
246             if (buf == null) {
247                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
248                         new SSLProtocolException(
249                     &quot;SessionTicket buffer too small&quot;));
250             }
251             if (buf.remaining() &gt; 65536) {
252                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
253                         new SSLProtocolException(
254                     &quot;SessionTicket buffer too large. &quot; + buf.remaining()));
255             }
256 
257             data = buf;
258         }
259 
260         public byte[] encrypt(HandshakeContext hc, SSLSessionImpl session) {
261             byte[] encrypted;
262 
<span class="line-modified">263             if (!hc.handshakeSession.isStatelessable(hc)) {</span>

264                 return new byte[0];
265             }
266 
267             try {
268                 StatelessKey key = KeyState.getCurrentKey(hc);
269                 byte[] iv = new byte[16];
270 
271                 SecureRandom random = hc.sslContext.getSecureRandom();
272                 random.nextBytes(iv);
273                 Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
274                 c.init(Cipher.ENCRYPT_MODE, key.key,
275                         new GCMParameterSpec(GCM_TAG_LEN, iv));
276                 c.updateAAD(new byte[] {
277                         (byte)(key.num &gt;&gt;&gt; 24),
278                         (byte)(key.num &gt;&gt;&gt; 16),
279                         (byte)(key.num &gt;&gt;&gt; 8),
280                         (byte)(key.num)}
281                 );
282                 byte[] data = session.write();
283                 if (data.length == 0) {
</pre>
</td>
<td>
<hr />
<pre>
243 
244         SessionTicketSpec(HandshakeContext hc,
245                 ByteBuffer buf) throws IOException {
246             if (buf == null) {
247                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
248                         new SSLProtocolException(
249                     &quot;SessionTicket buffer too small&quot;));
250             }
251             if (buf.remaining() &gt; 65536) {
252                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
253                         new SSLProtocolException(
254                     &quot;SessionTicket buffer too large. &quot; + buf.remaining()));
255             }
256 
257             data = buf;
258         }
259 
260         public byte[] encrypt(HandshakeContext hc, SSLSessionImpl session) {
261             byte[] encrypted;
262 
<span class="line-modified">263             if (!hc.statelessResumption ||</span>
<span class="line-added">264                     !hc.handshakeSession.isStatelessable()) {</span>
265                 return new byte[0];
266             }
267 
268             try {
269                 StatelessKey key = KeyState.getCurrentKey(hc);
270                 byte[] iv = new byte[16];
271 
272                 SecureRandom random = hc.sslContext.getSecureRandom();
273                 random.nextBytes(iv);
274                 Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
275                 c.init(Cipher.ENCRYPT_MODE, key.key,
276                         new GCMParameterSpec(GCM_TAG_LEN, iv));
277                 c.updateAAD(new byte[] {
278                         (byte)(key.num &gt;&gt;&gt; 24),
279                         (byte)(key.num &gt;&gt;&gt; 16),
280                         (byte)(key.num &gt;&gt;&gt; 8),
281                         (byte)(key.num)}
282                 );
283                 byte[] data = session.write();
284                 if (data.length == 0) {
</pre>
</td>
</tr>
</table>
<center><a href="SSLSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TransportContext.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java b/src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java
--- a/src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java
+++ b/src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java
@@ -25,17 +25,15 @@
 package sun.security.ssl;
 
 import sun.security.x509.X509CertImpl;
 
 import java.io.IOException;
-import java.lang.reflect.Array;
 import java.math.BigInteger;
 import java.net.InetAddress;
 import java.nio.ByteBuffer;
 import java.security.Principal;
 import java.security.PrivateKey;
-import java.security.cert.CertificateEncodingException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Queue;
 import java.util.Collection;
@@ -518,31 +516,29 @@
         this.lastUsedTime = System.currentTimeMillis();
     }
 
     // Some situations we cannot provide a stateless ticket, but after it
     // has been negotiated
-    boolean isStatelessable(HandshakeContext hc) {
-        if (!hc.statelessResumption) {
-            return false;
-        }
-
+    boolean isStatelessable() {
         // If there is no getMasterSecret with TLS1.2 or under, do not resume.
         if (!protocolVersion.useTLS13PlusSpec() &&
                 getMasterSecret().getEncoded() == null) {
             if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
                 SSLLogger.finest("No MasterSecret, cannot make stateless" +
                         " ticket");
             }
             return false;
         }
+
         if (boundValues != null && boundValues.size() > 0) {
             if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
                 SSLLogger.finest("There are boundValues, cannot make" +
                         " stateless ticket");
             }
             return false;
         }
+
         return true;
     }
 
     /**
      * Write out a SSLSessionImpl in a byte array for a stateless session ticket

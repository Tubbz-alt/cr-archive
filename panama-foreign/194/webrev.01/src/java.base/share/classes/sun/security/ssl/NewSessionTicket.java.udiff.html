<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/sun/security/ssl/NewSessionTicket.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="HandshakeContext.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineImpl.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/NewSessionTicket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -31,10 +31,11 @@</span>
  import java.security.SecureRandom;
  import java.text.MessageFormat;
  import java.util.Locale;
  import javax.crypto.SecretKey;
  import javax.net.ssl.SSLHandshakeException;
<span class="udiff-line-added">+ import sun.security.ssl.PskKeyExchangeModesExtension.PskKeyExchangeMode;</span>
  import sun.security.ssl.PskKeyExchangeModesExtension.PskKeyExchangeModesSpec;
  import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;
  import sun.security.ssl.SSLHandshake.HandshakeMessage;
  import sun.security.util.HexDumpEncoder;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -47,12 +48,12 @@</span>
      static final int MAX_TICKET_LIFETIME = 604800;  // seconds, 7 days
      static final SSLConsumer handshakeConsumer =
          new T13NewSessionTicketConsumer();
      static final SSLConsumer handshake12Consumer =
          new T12NewSessionTicketConsumer();
<span class="udiff-line-modified-removed">-     static final SSLProducer kickstartProducer =</span>
<span class="udiff-line-modified-removed">-         new NewSessionTicketKickstartProducer();</span>
<span class="udiff-line-modified-added">+     static final SSLProducer t13PosthandshakeProducer =</span>
<span class="udiff-line-modified-added">+         new T13NewSessionTicketProducer();</span>
      static final HandshakeProducer handshake12Producer =
          new T12NewSessionTicketProducer();
  
      /**
       * The NewSessionTicketMessage handshake messages.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -203,11 +204,11 @@</span>
  
              this.ticket = Record.getBytes16(m);
              if (ticket.length == 0) {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
<span class="udiff-line-modified-removed">-                     &quot;No ticket in the NewSessionTicket handshake message&quot;);</span>
<span class="udiff-line-modified-added">+                         &quot;No ticket in the NewSessionTicket handshake message&quot;);</span>
                  }
              }
  
              if (m.remaining() &lt; 2) {
                  throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -305,24 +306,40 @@</span>
                      &quot;Could not derive PSK&quot;).initCause(gse);
          }
      }
  
      private static final
<span class="udiff-line-modified-removed">-             class NewSessionTicketKickstartProducer implements SSLProducer {</span>
<span class="udiff-line-modified-added">+             class T13NewSessionTicketProducer implements SSLProducer {</span>
          // Prevent instantiation of this class.
<span class="udiff-line-modified-removed">-         private NewSessionTicketKickstartProducer() {</span>
<span class="udiff-line-modified-added">+         private T13NewSessionTicketProducer() {</span>
              // blank
          }
  
          @Override
          public byte[] produce(ConnectionContext context) throws IOException {
              HandshakeContext hc = (HandshakeContext)context;
  
<span class="udiff-line-added">+             // See note on TransportContext.needHandshakeFinishedStatus.</span>
<span class="udiff-line-added">+             //</span>
<span class="udiff-line-added">+             // Set to need handshake finished status.  Reset it later if a</span>
<span class="udiff-line-added">+             // session ticket get delivered.</span>
<span class="udiff-line-added">+             if (hc.conContext.hasDelegatedFinished) {</span>
<span class="udiff-line-added">+                 // Reset, as the delegated finished case will be handled later.</span>
<span class="udiff-line-added">+                 hc.conContext.hasDelegatedFinished = false;</span>
<span class="udiff-line-added">+                 hc.conContext.needHandshakeFinishedStatus = true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              // The producing happens in server side only.
              if (hc instanceof ServerHandshakeContext) {
                  // Is this session resumable?
                  if (!hc.handshakeSession.isRejoinable()) {
<span class="udiff-line-added">+                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                         SSLLogger.fine(</span>
<span class="udiff-line-added">+                                 &quot;No session ticket produced: &quot; +</span>
<span class="udiff-line-added">+                                 &quot;session is not resumable&quot;);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
                      return null;
                  }
  
                  // What&#39;s the requested PSK key exchange modes?
                  //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -330,20 +347,30 @@</span>
                  // produced and delivered only in the current handshake context
                  // if required.
                  PskKeyExchangeModesSpec pkemSpec =
                          (PskKeyExchangeModesSpec) hc.handshakeExtensions.get(
                                  SSLExtension.PSK_KEY_EXCHANGE_MODES);
<span class="udiff-line-modified-removed">-                 if (pkemSpec == null || !pkemSpec.contains(</span>
<span class="udiff-line-modified-removed">-                         PskKeyExchangeModesExtension.PskKeyExchangeMode.PSK_DHE_KE)) {</span>
<span class="udiff-line-modified-removed">-                     // Client doesn&#39;t support PSK with (EC)DHE key establishment.</span>
<span class="udiff-line-modified-added">+                 if (pkemSpec == null ||</span>
<span class="udiff-line-modified-added">+                         !pkemSpec.contains(PskKeyExchangeMode.PSK_DHE_KE)) {</span>
<span class="udiff-line-modified-added">+                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                         SSLLogger.fine(</span>
<span class="udiff-line-added">+                                 &quot;No session ticket produced: &quot; +</span>
<span class="udiff-line-added">+                                 &quot;client does not support psk_dhe_ke&quot;);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
                      return null;
                  }
<span class="udiff-line-modified-removed">-             } else { // PostHandshakeContext</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-                 // Check if we have sent a PSK already, then we know it is using a</span>
<span class="udiff-line-removed">-                 // allowable PSK exchange key mode</span>
<span class="udiff-line-modified-added">+             } else {     // PostHandshakeContext</span>
<span class="udiff-line-modified-added">+                 // Check if we have sent a PSK already, then we know it is</span>
<span class="udiff-line-modified-added">+                 // using a allowable PSK exchange key mode.</span>
                  if (!hc.handshakeSession.isPSKable()) {
<span class="udiff-line-added">+                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                         SSLLogger.fine(</span>
<span class="udiff-line-added">+                                 &quot;No session ticket produced: &quot; +</span>
<span class="udiff-line-added">+                                 &quot;No session ticket allowed in this session&quot;);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
                      return null;
                  }
              }
  
              // get a new session ID
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -355,12 +382,14 @@</span>
              SecretKey resumptionMasterSecret =
                  hc.handshakeSession.getResumptionMasterSecret();
              if (resumptionMasterSecret == null) {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
<span class="udiff-line-modified-removed">-                         &quot;Session has no resumption secret. No ticket sent.&quot;);</span>
<span class="udiff-line-modified-added">+                             &quot;No session ticket produced: &quot; +</span>
<span class="udiff-line-added">+                             &quot;no resumption secret&quot;);</span>
                  }
<span class="udiff-line-added">+ </span>
                  return null;
              }
  
              // construct the PSK and handshake message
              BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -371,12 +400,14 @@</span>
  
              int sessionTimeoutSeconds = sessionCache.getSessionTimeout();
              if (sessionTimeoutSeconds &gt; MAX_TICKET_LIFETIME) {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
<span class="udiff-line-modified-removed">-                         &quot;Session timeout is too long. No ticket sent.&quot;);</span>
<span class="udiff-line-modified-added">+                             &quot;No session ticket produced: &quot; +</span>
<span class="udiff-line-added">+                             &quot;session timeout&quot;);</span>
                  }
<span class="udiff-line-added">+ </span>
                  return null;
              }
  
              NewSessionTicketMessage nstm = null;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -384,11 +415,12 @@</span>
                      new SSLSessionImpl(hc.handshakeSession, newId);
              sessionCopy.setPreSharedKey(psk);
              sessionCopy.setPskIdentity(newId.getId());
  
              // If a stateless ticket is allowed, attempt to make one
<span class="udiff-line-modified-removed">-             if (hc.handshakeSession.isStatelessable(hc)) {</span>
<span class="udiff-line-modified-added">+             if (hc.statelessResumption &amp;&amp;</span>
<span class="udiff-line-added">+                     hc.handshakeSession.isStatelessable()) {</span>
                  nstm = new T13NewSessionTicketMessage(hc,
                          sessionTimeoutSeconds,
                          hc.sslContext.getSecureRandom(),
                          nonceArr,
                          new SessionTicketSpec().encrypt(hc, sessionCopy));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -396,23 +428,25 @@</span>
                  if (!nstm.isValid()) {
                      hc.statelessResumption = false;
                  } else {
                      if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                          SSLLogger.fine(
<span class="udiff-line-modified-removed">-                                 &quot;Produced NewSessionTicket stateless &quot; +</span>
<span class="udiff-line-modified-removed">-                                         &quot;handshake message&quot;, nstm);</span>
<span class="udiff-line-modified-added">+                             &quot;Produced NewSessionTicket stateless &quot; +</span>
<span class="udiff-line-modified-added">+                             &quot;post-handshake message&quot;, nstm);</span>
                      }
                  }
              }
<span class="udiff-line-added">+ </span>
              // If a session cache ticket is being used, make one
<span class="udiff-line-modified-removed">-             if (!hc.handshakeSession.isStatelessable(hc)) {</span>
<span class="udiff-line-modified-added">+             if (!hc.statelessResumption ||</span>
<span class="udiff-line-added">+                     !hc.handshakeSession.isStatelessable()) {</span>
                  nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,
                          hc.sslContext.getSecureRandom(), nonceArr,
                          newId.getId());
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
<span class="udiff-line-modified-removed">-                             &quot;Produced NewSessionTicket handshake message&quot;,</span>
<span class="udiff-line-modified-added">+                             &quot;Produced NewSessionTicket post-handshake message&quot;,</span>
                              nstm);
                  }
  
                  // create and cache the new session
                  // The new session must be a child of the existing session so
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -425,16 +459,25 @@</span>
              // Output the handshake message.
              if (nstm != null) {
                  // should never be null
                  nstm.write(hc.handshakeOutput);
                  hc.handshakeOutput.flush();
<span class="udiff-line-removed">-             }</span>
  
<span class="udiff-line-modified-removed">-             if (hc.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="udiff-line-modified-removed">-                 hc.conContext.finishPostHandshake();</span>
<span class="udiff-line-modified-added">+                 // See note on TransportContext.needHandshakeFinishedStatus.</span>
<span class="udiff-line-modified-added">+                 //</span>
<span class="udiff-line-added">+                 // Reset the needHandshakeFinishedStatus flag.  The delivery</span>
<span class="udiff-line-added">+                 // of this post-handshake message will indicate the FINISHED</span>
<span class="udiff-line-added">+                 // handshake status.  It is not needed to have a follow-on</span>
<span class="udiff-line-added">+                 // SSLEngine.wrap() any longer.</span>
<span class="udiff-line-added">+                 if (hc.conContext.needHandshakeFinishedStatus) {</span>
<span class="udiff-line-added">+                     hc.conContext.needHandshakeFinishedStatus = false;</span>
<span class="udiff-line-added">+                 }</span>
              }
  
<span class="udiff-line-added">+             // clean the post handshake context</span>
<span class="udiff-line-added">+             hc.conContext.finishPostHandshake();</span>
<span class="udiff-line-added">+ </span>
              // The message has been delivered.
              return null;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -481,11 +524,12 @@</span>
              NewSessionTicketMessage nstm = new T12NewSessionTicketMessage(shc,
                      sessionTimeoutSeconds,
                      new SessionTicketSpec().encrypt(shc, sessionCopy));
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
<span class="udiff-line-modified-removed">-                         &quot;Produced NewSessionTicket stateless handshake message&quot;, nstm);</span>
<span class="udiff-line-modified-added">+                     &quot;Produced NewSessionTicket stateless handshake message&quot;,</span>
<span class="udiff-line-added">+                     nstm);</span>
              }
  
              // Output the handshake message.
              nstm.write(shc.handshakeOutput);
              shc.handshakeOutput.flush();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -519,56 +563,54 @@</span>
              HandshakeContext hc = (HandshakeContext)context;
              NewSessionTicketMessage nstm =
                      new T13NewSessionTicketMessage(hc, message);
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
<span class="udiff-line-modified-removed">-                 &quot;Consuming NewSessionTicket message&quot;, nstm);</span>
<span class="udiff-line-modified-added">+                         &quot;Consuming NewSessionTicket message&quot;, nstm);</span>
              }
  
              SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
                      hc.sslContext.engineGetClientSessionContext();
  
              // discard tickets with timeout 0
              if (nstm.ticketLifetime &lt;= 0 ||
                  nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
<span class="udiff-line-modified-removed">-                     &quot;Discarding NewSessionTicket with lifetime &quot;</span>
<span class="udiff-line-modified-removed">-                         + nstm.ticketLifetime, nstm);</span>
<span class="udiff-line-modified-added">+                             &quot;Discarding NewSessionTicket with lifetime &quot; +</span>
<span class="udiff-line-modified-added">+                             nstm.ticketLifetime, nstm);</span>
                  }
                  sessionCache.remove(hc.handshakeSession.getSessionId());
                  return;
              }
  
              if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
<span class="udiff-line-modified-removed">-                     &quot;Session cache lifetime is too long. Discarding ticket.&quot;);</span>
<span class="udiff-line-modified-added">+                         &quot;Session cache lifetime is too long. &quot; +</span>
<span class="udiff-line-added">+                         &quot;Discarding ticket.&quot;);</span>
                  }
                  return;
              }
  
              SSLSessionImpl sessionToSave = hc.conContext.conSession;
<span class="udiff-line-modified-removed">-             SecretKey psk = null;</span>
<span class="udiff-line-modified-removed">-             if (hc.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="udiff-line-modified-removed">-                 SecretKey resumptionMasterSecret =</span>
<span class="udiff-line-modified-removed">-                         sessionToSave.getResumptionMasterSecret();</span>
<span class="udiff-line-modified-removed">-                 if (resumptionMasterSecret == null) {</span>
<span class="udiff-line-modified-removed">-                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-modified-removed">-                         SSLLogger.fine(</span>
<span class="udiff-line-removed">-                                 &quot;Session has no resumption master secret.&quot; +</span>
<span class="udiff-line-removed">-                                         &quot; Ignoring ticket.&quot;);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     return;</span>
<span class="udiff-line-modified-added">+             SecretKey resumptionMasterSecret =</span>
<span class="udiff-line-modified-added">+                     sessionToSave.getResumptionMasterSecret();</span>
<span class="udiff-line-modified-added">+             if (resumptionMasterSecret == null) {</span>
<span class="udiff-line-modified-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-modified-added">+                     SSLLogger.fine(</span>
<span class="udiff-line-modified-added">+                             &quot;Session has no resumption master secret. &quot; +</span>
<span class="udiff-line-modified-added">+                             &quot;Ignoring ticket.&quot;);</span>
                  }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-                 // derive the PSK</span>
<span class="udiff-line-removed">-                 psk = derivePreSharedKey(</span>
<span class="udiff-line-removed">-                         sessionToSave.getSuite().hashAlg,</span>
<span class="udiff-line-removed">-                         resumptionMasterSecret, nstm.getTicketNonce());</span>
<span class="udiff-line-modified-added">+                 return;</span>
              }
  
<span class="udiff-line-added">+             // derive the PSK</span>
<span class="udiff-line-added">+             SecretKey psk = derivePreSharedKey(</span>
<span class="udiff-line-added">+                     sessionToSave.getSuite().hashAlg,</span>
<span class="udiff-line-added">+                     resumptionMasterSecret, nstm.getTicketNonce());</span>
<span class="udiff-line-added">+ </span>
              // create and cache the new session
              // The new session must be a child of the existing session so
              // they will be invalidated together, etc.
              SessionId newId =
                      new SessionId(true, hc.sslContext.getSecureRandom());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -578,14 +620,12 @@</span>
              sessionCopy.setPreSharedKey(psk);
              sessionCopy.setTicketAgeAdd(nstm.getTicketAgeAdd());
              sessionCopy.setPskIdentity(nstm.ticket);
              sessionCache.put(sessionCopy);
  
<span class="udiff-line-modified-removed">-             // clean handshake context</span>
<span class="udiff-line-modified-removed">-             if (hc.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="udiff-line-removed">-                 hc.conContext.finishPostHandshake();</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+             // clean the post handshake context</span>
<span class="udiff-line-modified-added">+             hc.conContext.finishPostHandshake();</span>
          }
      }
  
      private static final
      class T12NewSessionTicketConsumer implements SSLConsumer {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -613,23 +653,24 @@</span>
              // discard tickets with timeout 0
              if (nstm.ticketLifetime &lt;= 0 ||
                  nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
<span class="udiff-line-modified-removed">-                     &quot;Discarding NewSessionTicket with lifetime &quot;</span>
<span class="udiff-line-modified-removed">-                         + nstm.ticketLifetime, nstm);</span>
<span class="udiff-line-modified-added">+                             &quot;Discarding NewSessionTicket with lifetime &quot; +</span>
<span class="udiff-line-modified-added">+                             nstm.ticketLifetime, nstm);</span>
                  }
                  return;
              }
  
              SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
                      hc.sslContext.engineGetClientSessionContext();
  
              if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
<span class="udiff-line-modified-removed">-                     &quot;Session cache lifetime is too long. Discarding ticket.&quot;);</span>
<span class="udiff-line-modified-added">+                         &quot;Session cache lifetime is too long. &quot; +</span>
<span class="udiff-line-added">+                         &quot;Discarding ticket.&quot;);</span>
                  }
                  return;
              }
  
              hc.handshakeSession.setPskIdentity(nstm.ticket);
</pre>
<center><a href="HandshakeContext.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineImpl.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/provider/certpath/AdaptableX509CertSelector.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider.certpath;
 27 
 28 import java.io.IOException;
 29 import java.math.BigInteger;
 30 import java.security.cert.Certificate;
 31 import java.security.cert.X509Certificate;
 32 import java.security.cert.X509CertSelector;
 33 import java.security.cert.CertificateException;
 34 import java.util.Arrays;
 35 import java.util.Date;
 36 
 37 import sun.security.util.Debug;
 38 import sun.security.util.DerInputStream;
<a name="2" id="anc2"></a><span class="line-added"> 39 import sun.security.util.KnownOIDs;</span>
 40 import sun.security.x509.SerialNumber;
 41 import sun.security.x509.AuthorityKeyIdentifierExtension;
 42 
 43 /**
 44  * An adaptable X509 certificate selector for forward certification path
 45  * building. This selector overrides the default X509CertSelector matching
 46  * rules for the subjectKeyIdentifier and serialNumber criteria, and adds
 47  * additional rules for certificate validity.
 48  *
 49  * @since 1.7
 50  */
 51 class AdaptableX509CertSelector extends X509CertSelector {
 52 
 53     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
 54 
 55     // The start date of a validity period.
 56     private Date startDate;
 57 
 58     // The end date of a validity period.
 59     private Date endDate;
 60 
 61     // The subject key identifier
 62     private byte[] ski;
 63 
 64     // The serial number
 65     private BigInteger serial;
 66 
 67     /**
 68      * Sets the criterion of the X509Certificate validity period.
 69      *
 70      * Normally, we may not have to check that a certificate validity period
 71      * must fall within its issuer&#39;s certificate validity period. However,
 72      * when we face root CA key updates for version 1 certificates, according
 73      * to scheme of RFC 4210 or 2510, the validity periods should be checked
 74      * to determine the right issuer&#39;s certificate.
 75      *
 76      * Conservatively, we will only check the validity periods for version
 77      * 1 and version 2 certificates. For version 3 certificates, we can
 78      * determine the right issuer by authority and subject key identifier
 79      * extensions.
 80      *
 81      * @param startDate the start date of a validity period that must fall
 82      *        within the certificate validity period for the X509Certificate
 83      * @param endDate the end date of a validity period that must fall
 84      *        within the certificate validity period for the X509Certificate
 85      */
 86     void setValidityPeriod(Date startDate, Date endDate) {
 87         this.startDate = startDate;
 88         this.endDate = endDate;
 89     }
 90 
 91     /**
 92      * This selector overrides the subjectKeyIdentifier matching rules of
 93      * X509CertSelector, so it throws IllegalArgumentException if this method
 94      * is ever called.
 95      */
 96     @Override
 97     public void setSubjectKeyIdentifier(byte[] subjectKeyID) {
 98         throw new IllegalArgumentException();
 99     }
100 
101     /**
102      * This selector overrides the serialNumber matching rules of
103      * X509CertSelector, so it throws IllegalArgumentException if this method
104      * is ever called.
105      */
106     @Override
107     public void setSerialNumber(BigInteger serial) {
108         throw new IllegalArgumentException();
109     }
110 
111     /**
112      * Sets the subjectKeyIdentifier and serialNumber criteria from the
113      * authority key identifier extension.
114      *
115      * The subjectKeyIdentifier criterion is set to the keyIdentifier field
116      * of the extension, or null if it is empty. The serialNumber criterion
117      * is set to the authorityCertSerialNumber field, or null if it is empty.
118      *
119      * Note that we do not set the subject criterion to the
120      * authorityCertIssuer field of the extension. The caller MUST set
121      * the subject criterion before calling match().
122      *
123      * @param ext the authorityKeyIdentifier extension
124      * @throws IOException if there is an error parsing the extension
125      */
126     void setSkiAndSerialNumber(AuthorityKeyIdentifierExtension ext)
127         throws IOException {
128 
129         ski = null;
130         serial = null;
131 
132         if (ext != null) {
133             ski = ext.getEncodedKeyIdentifier();
134             SerialNumber asn = (SerialNumber)ext.get(
135                 AuthorityKeyIdentifierExtension.SERIAL_NUMBER);
136             if (asn != null) {
137                 serial = asn.getNumber();
138             }
139             // the subject criterion should be set by the caller
140         }
141     }
142 
143     /**
144      * Decides whether a &lt;code&gt;Certificate&lt;/code&gt; should be selected.
145      *
146      * This method overrides the matching rules for the subjectKeyIdentifier
147      * and serialNumber criteria and adds additional rules for certificate
148      * validity.
149      *
150      * For the purpose of compatibility, when a certificate is of
151      * version 1 and version 2, or the certificate does not include
152      * a subject key identifier extension, the selection criterion
153      * of subjectKeyIdentifier will be disabled.
154      */
155     @Override
156     public boolean match(Certificate cert) {
157         X509Certificate xcert = (X509Certificate)cert;
158 
159         // match subject key identifier
160         if (!matchSubjectKeyID(xcert)) {
161             return false;
162         }
163 
164         // In practice, a CA may replace its root certificate and require that
165         // the existing certificate is still valid, even if the AKID extension
166         // does not match the replacement root certificate fields.
167         //
168         // Conservatively, we only support the replacement for version 1 and
169         // version 2 certificate. As for version 3, the certificate extension
170         // may contain sensitive information (for example, policies), the
171         // AKID need to be respected to seek the exact certificate in case
172         // of key or certificate abuse.
173         int version = xcert.getVersion();
174         if (serial != null &amp;&amp; version &gt; 2) {
175             if (!serial.equals(xcert.getSerialNumber())) {
176                 return false;
177             }
178         }
179 
180         // Check the validity period for version 1 and 2 certificate.
181         if (version &lt; 3) {
182             if (startDate != null) {
183                 try {
184                     xcert.checkValidity(startDate);
185                 } catch (CertificateException ce) {
186                     return false;
187                 }
188             }
189             if (endDate != null) {
190                 try {
191                     xcert.checkValidity(endDate);
192                 } catch (CertificateException ce) {
193                     return false;
194                 }
195             }
196         }
197 
198 
199         if (!super.match(cert)) {
200             return false;
201         }
202 
203         return true;
204     }
205 
206     /*
207      * Match on subject key identifier extension value. These matching rules
208      * are identical to X509CertSelector except that if the certificate does
209      * not have a subject key identifier extension, it returns true.
210      */
211     private boolean matchSubjectKeyID(X509Certificate xcert) {
212         if (ski == null) {
213             return true;
214         }
215         try {
<a name="3" id="anc3"></a><span class="line-modified">216             byte[] extVal = xcert.getExtensionValue(</span>
<span class="line-added">217                     KnownOIDs.SubjectKeyID.value());</span>
218             if (extVal == null) {
219                 if (debug != null &amp;&amp; Debug.isVerbose()) {
220                     debug.println(&quot;AdaptableX509CertSelector.match: &quot;
221                         + &quot;no subject key ID extension. Subject: &quot;
222                         + xcert.getSubjectX500Principal());
223                 }
224                 return true;
225             }
226             DerInputStream in = new DerInputStream(extVal);
227             byte[] certSubjectKeyID = in.getOctetString();
228             if (certSubjectKeyID == null ||
229                     !Arrays.equals(ski, certSubjectKeyID)) {
230                 if (debug != null &amp;&amp; Debug.isVerbose()) {
231                     debug.println(&quot;AdaptableX509CertSelector.match: &quot;
232                         + &quot;subject key IDs don&#39;t match. &quot;
233                         + &quot;Expected: &quot; + Arrays.toString(ski) + &quot; &quot;
234                         + &quot;Cert&#39;s: &quot; + Arrays.toString(certSubjectKeyID));
235                 }
236                 return false;
237             }
238         } catch (IOException ex) {
239             if (debug != null &amp;&amp; Debug.isVerbose()) {
240                 debug.println(&quot;AdaptableX509CertSelector.match: &quot;
241                     + &quot;exception in subject key ID check&quot;);
242             }
243             return false;
244         }
245         return true;
246     }
247 
248     @Override
249     public Object clone() {
250         AdaptableX509CertSelector copy =
251                         (AdaptableX509CertSelector)super.clone();
252         if (startDate != null) {
253             copy.startDate = (Date)startDate.clone();
254         }
255 
256         if (endDate != null) {
257             copy.endDate = (Date)endDate.clone();
258         }
259 
260         if (ski != null) {
261             copy.ski = ski.clone();
262         }
263         return copy;
264     }
265 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/Finished.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.GeneralSecurityException;
  31 import java.security.InvalidKeyException;
  32 import java.security.MessageDigest;
  33 import java.security.NoSuchAlgorithmException;
  34 import java.security.ProviderException;
  35 import java.security.spec.AlgorithmParameterSpec;
  36 import java.text.MessageFormat;
  37 import java.util.Locale;
  38 import javax.crypto.KeyGenerator;
  39 import javax.crypto.Mac;
  40 import javax.crypto.SecretKey;
  41 import javax.crypto.spec.IvParameterSpec;
  42 import javax.crypto.spec.SecretKeySpec;
  43 import javax.net.ssl.SSLPeerUnverifiedException;
  44 
  45 import jdk.internal.event.EventHelper;
  46 import jdk.internal.event.TLSHandshakeEvent;
  47 import sun.security.internal.spec.TlsPrfParameterSpec;
  48 import sun.security.ssl.CipherSuite.HashAlg;
  49 import static sun.security.ssl.CipherSuite.HashAlg.H_NONE;
  50 import sun.security.ssl.SSLBasicKeyDerivation.SecretSizeSpec;
  51 import sun.security.ssl.SSLCipher.SSLReadCipher;
  52 import sun.security.ssl.SSLCipher.SSLWriteCipher;
  53 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  54 import sun.security.util.HexDumpEncoder;
  55 
  56 /**
  57  * Pack of the Finished handshake message.
  58  */
  59 final class Finished {
  60     static final SSLConsumer t12HandshakeConsumer =
  61         new T12FinishedConsumer();
  62     static final HandshakeProducer t12HandshakeProducer =
  63         new T12FinishedProducer();
  64 
  65     static final SSLConsumer t13HandshakeConsumer =
  66         new T13FinishedConsumer();
  67     static final HandshakeProducer t13HandshakeProducer =
  68         new T13FinishedProducer();
  69 
  70     /**
  71      * The Finished handshake message.
  72      */
  73     private static final class FinishedMessage extends HandshakeMessage {
  74         private final byte[] verifyData;
  75 
  76         FinishedMessage(HandshakeContext context) throws IOException {
  77             super(context);
  78 
  79             VerifyDataScheme vds =
  80                     VerifyDataScheme.valueOf(context.negotiatedProtocol);
  81 
  82             byte[] vd = null;
  83             try {
  84                 vd = vds.createVerifyData(context, false);
  85             } catch (IOException ioe) {
  86                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
  87                         &quot;Failed to generate verify_data&quot;, ioe);
  88             }
  89 
  90             this.verifyData = vd;
  91         }
  92 
  93         FinishedMessage(HandshakeContext context,
  94                 ByteBuffer m) throws IOException {
  95             super(context);
  96             int verifyDataLen = 12;
  97             if (context.negotiatedProtocol == ProtocolVersion.SSL30) {
  98                 verifyDataLen = 36;
  99             } else if (context.negotiatedProtocol.useTLS13PlusSpec()) {
 100                 verifyDataLen =
 101                         context.negotiatedCipherSuite.hashAlg.hashLength;
 102             }
 103 
 104             if (m.remaining() != verifyDataLen) {
 105                 throw context.conContext.fatal(Alert.DECODE_ERROR,
 106                     &quot;Inappropriate finished message: need &quot; + verifyDataLen +
 107                     &quot; but remaining &quot; + m.remaining() + &quot; bytes verify_data&quot;);
 108             }
 109 
 110             this.verifyData = new byte[verifyDataLen];
 111             m.get(verifyData);
 112 
 113             VerifyDataScheme vd =
 114                     VerifyDataScheme.valueOf(context.negotiatedProtocol);
 115             byte[] myVerifyData;
 116             try {
 117                 myVerifyData = vd.createVerifyData(context, true);
 118             } catch (IOException ioe) {
 119                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 120                         &quot;Failed to generate verify_data&quot;, ioe);
 121             }
 122             if (!MessageDigest.isEqual(myVerifyData, verifyData)) {
 123                 throw context.conContext.fatal(Alert.DECRYPT_ERROR,
 124                         &quot;The Finished message cannot be verified.&quot;);
 125             }
 126         }
 127 
 128         @Override
 129         public SSLHandshake handshakeType() {
 130             return SSLHandshake.FINISHED;
 131         }
 132 
 133         @Override
 134         public int messageLength() {
 135             return verifyData.length;
 136         }
 137 
 138         @Override
 139         public void send(HandshakeOutStream hos) throws IOException {
 140             hos.write(verifyData);
 141         }
 142 
 143         @Override
 144         public String toString() {
 145             MessageFormat messageFormat = new MessageFormat(
 146                     &quot;\&quot;Finished\&quot;: &#39;{&#39;\n&quot; +
 147                     &quot;  \&quot;verify data\&quot;: &#39;{&#39;\n&quot; +
 148                     &quot;{0}\n&quot; +
 149                     &quot;  &#39;}&#39;&quot; +
 150                     &quot;&#39;}&#39;&quot;,
 151                     Locale.ENGLISH);
 152 
 153             HexDumpEncoder hexEncoder = new HexDumpEncoder();
 154             Object[] messageFields = {
 155                     Utilities.indent(hexEncoder.encode(verifyData), &quot;    &quot;),
 156                 };
 157             return messageFormat.format(messageFields);
 158         }
 159     }
 160 
 161     interface VerifyDataGenerator {
 162         byte[] createVerifyData(HandshakeContext context,
 163                 boolean isValidation) throws IOException;
 164     }
 165 
 166     enum VerifyDataScheme {
 167         SSL30       (&quot;kdf_ssl30&quot;, new S30VerifyDataGenerator()),
 168         TLS10       (&quot;kdf_tls10&quot;, new T10VerifyDataGenerator()),
 169         TLS12       (&quot;kdf_tls12&quot;, new T12VerifyDataGenerator()),
 170         TLS13       (&quot;kdf_tls13&quot;, new T13VerifyDataGenerator());
 171 
 172         final String name;
 173         final VerifyDataGenerator generator;
 174 
 175         VerifyDataScheme(String name, VerifyDataGenerator verifyDataGenerator) {
 176             this.name = name;
 177             this.generator = verifyDataGenerator;
 178         }
 179 
 180         static VerifyDataScheme valueOf(ProtocolVersion protocolVersion) {
 181             switch (protocolVersion) {
 182                 case SSL30:
 183                     return VerifyDataScheme.SSL30;
 184                 case TLS10:
 185                 case TLS11:
 186                 case DTLS10:
 187                     return VerifyDataScheme.TLS10;
 188                 case TLS12:
 189                 case DTLS12:
 190                     return VerifyDataScheme.TLS12;
 191                 case TLS13:
 192                     return VerifyDataScheme.TLS13;
 193                 default:
 194                     return null;
 195             }
 196         }
 197 
 198         public byte[] createVerifyData(HandshakeContext context,
 199                 boolean isValidation) throws IOException {
 200             if (generator != null) {
 201                 return generator.createVerifyData(context, isValidation);
 202             }
 203 
 204             throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
 205         }
 206     }
 207 
 208     // SSL 3.0
 209     private static final
 210             class S30VerifyDataGenerator implements VerifyDataGenerator {
 211         @Override
 212         public byte[] createVerifyData(HandshakeContext context,
 213                 boolean isValidation) throws IOException {
 214             HandshakeHash handshakeHash = context.handshakeHash;
 215             SecretKey masterSecretKey =
 216                     context.handshakeSession.getMasterSecret();
 217 
 218             boolean useClientLabel =
 219                     (context.sslConfig.isClientMode &amp;&amp; !isValidation) ||
 220                     (!context.sslConfig.isClientMode &amp;&amp; isValidation);
 221             return handshakeHash.digest(useClientLabel, masterSecretKey);
 222         }
 223     }
 224 
 225     // TLS 1.0, TLS 1.1, DTLS 1.0
 226     private static final
 227             class T10VerifyDataGenerator implements VerifyDataGenerator {
 228         @Override
 229         public byte[] createVerifyData(HandshakeContext context,
 230                 boolean isValidation) throws IOException {
 231             HandshakeHash handshakeHash = context.handshakeHash;
 232             SecretKey masterSecretKey =
 233                     context.handshakeSession.getMasterSecret();
 234 
 235             boolean useClientLabel =
 236                     (context.sslConfig.isClientMode &amp;&amp; !isValidation) ||
 237                     (!context.sslConfig.isClientMode &amp;&amp; isValidation);
 238             String tlsLabel;
 239             if (useClientLabel) {
 240                 tlsLabel = &quot;client finished&quot;;
 241             } else {
 242                 tlsLabel = &quot;server finished&quot;;
 243             }
 244 
 245             try {
 246                 byte[] seed = handshakeHash.digest();
 247                 String prfAlg = &quot;SunTlsPrf&quot;;
 248                 HashAlg hashAlg = H_NONE;
 249 
 250                 /*
 251                  * RFC 5246/7.4.9 says that finished messages can
 252                  * be ciphersuite-specific in both length/PRF hash
 253                  * algorithm.  If we ever run across a different
 254                  * length, this call will need to be updated.
 255                  */
 256                 @SuppressWarnings(&quot;deprecation&quot;)
 257                 TlsPrfParameterSpec spec = new TlsPrfParameterSpec(
 258                     masterSecretKey, tlsLabel, seed, 12,
 259                     hashAlg.name, hashAlg.hashLength, hashAlg.blockSize);
 260                 KeyGenerator kg = KeyGenerator.getInstance(prfAlg);
 261                 kg.init(spec);
 262                 SecretKey prfKey = kg.generateKey();
 263                 if (!&quot;RAW&quot;.equals(prfKey.getFormat())) {
 264                     throw new ProviderException(
 265                         &quot;Invalid PRF output, format must be RAW. &quot; +
 266                         &quot;Format received: &quot; + prfKey.getFormat());
 267                 }
 268                 byte[] finished = prfKey.getEncoded();
 269                 return finished;
 270             } catch (GeneralSecurityException e) {
 271                 throw new RuntimeException(&quot;PRF failed&quot;, e);
 272             }
 273         }
 274     }
 275 
 276     // TLS 1.2
 277     private static final
 278             class T12VerifyDataGenerator implements VerifyDataGenerator {
 279         @Override
 280         public byte[] createVerifyData(HandshakeContext context,
 281                 boolean isValidation) throws IOException {
 282             CipherSuite cipherSuite = context.negotiatedCipherSuite;
 283             HandshakeHash handshakeHash = context.handshakeHash;
 284             SecretKey masterSecretKey =
 285                     context.handshakeSession.getMasterSecret();
 286 
 287             boolean useClientLabel =
 288                     (context.sslConfig.isClientMode &amp;&amp; !isValidation) ||
 289                     (!context.sslConfig.isClientMode &amp;&amp; isValidation);
 290             String tlsLabel;
 291             if (useClientLabel) {
 292                 tlsLabel = &quot;client finished&quot;;
 293             } else {
 294                 tlsLabel = &quot;server finished&quot;;
 295             }
 296 
 297             try {
 298                 byte[] seed = handshakeHash.digest();
 299                 String prfAlg = &quot;SunTls12Prf&quot;;
 300                 HashAlg hashAlg = cipherSuite.hashAlg;
 301 
 302                 /*
 303                  * RFC 5246/7.4.9 says that finished messages can
 304                  * be ciphersuite-specific in both length/PRF hash
 305                  * algorithm.  If we ever run across a different
 306                  * length, this call will need to be updated.
 307                  */
 308                 @SuppressWarnings(&quot;deprecation&quot;)
 309                 TlsPrfParameterSpec spec = new TlsPrfParameterSpec(
 310                     masterSecretKey, tlsLabel, seed, 12,
 311                     hashAlg.name, hashAlg.hashLength, hashAlg.blockSize);
 312                 KeyGenerator kg = KeyGenerator.getInstance(prfAlg);
 313                 kg.init(spec);
 314                 SecretKey prfKey = kg.generateKey();
 315                 if (!&quot;RAW&quot;.equals(prfKey.getFormat())) {
 316                     throw new ProviderException(
 317                         &quot;Invalid PRF output, format must be RAW. &quot; +
 318                         &quot;Format received: &quot; + prfKey.getFormat());
 319                 }
 320                 byte[] finished = prfKey.getEncoded();
 321                 return finished;
 322             } catch (GeneralSecurityException e) {
 323                 throw new RuntimeException(&quot;PRF failed&quot;, e);
 324             }
 325         }
 326     }
 327 
 328     // TLS 1.2
 329     private static final
 330             class T13VerifyDataGenerator implements VerifyDataGenerator {
 331         private static final byte[] hkdfLabel = &quot;tls13 finished&quot;.getBytes();
 332         private static final byte[] hkdfContext = new byte[0];
 333 
 334         @Override
 335         public byte[] createVerifyData(HandshakeContext context,
 336                 boolean isValidation) throws IOException {
 337             // create finished secret key
 338             HashAlg hashAlg =
 339                     context.negotiatedCipherSuite.hashAlg;
 340             SecretKey secret = isValidation ?
 341                     context.baseReadSecret : context.baseWriteSecret;
 342             SSLBasicKeyDerivation kdf = new SSLBasicKeyDerivation(
 343                     secret, hashAlg.name,
 344                     hkdfLabel, hkdfContext, hashAlg.hashLength);
 345             AlgorithmParameterSpec keySpec =
 346                     new SecretSizeSpec(hashAlg.hashLength);
 347             SecretKey finishedSecret =
 348                     kdf.deriveKey(&quot;TlsFinishedSecret&quot;, keySpec);
 349 
 350             String hmacAlg =
 351                 &quot;Hmac&quot; + hashAlg.name.replace(&quot;-&quot;, &quot;&quot;);
 352             try {
 353                 Mac hmac = Mac.getInstance(hmacAlg);
 354                 hmac.init(finishedSecret);
 355                 return hmac.doFinal(context.handshakeHash.digest());
 356             } catch (NoSuchAlgorithmException |InvalidKeyException ex) {
 357                 throw new ProviderException(
 358                         &quot;Failed to generate verify_data&quot;, ex);
 359             }
 360         }
 361     }
 362 
 363     /**
 364      * The &quot;Finished&quot; handshake message producer.
 365      */
 366     private static final
 367             class T12FinishedProducer implements HandshakeProducer {
 368         // Prevent instantiation of this class.
 369         private T12FinishedProducer() {
 370             // blank
 371         }
 372 
 373         @Override
 374         public byte[] produce(ConnectionContext context,
 375                 HandshakeMessage message) throws IOException {
 376             // The consuming happens in handshake context only.
 377             HandshakeContext hc = (HandshakeContext)context;
 378             if (hc.sslConfig.isClientMode) {
 379                 return onProduceFinished(
 380                         (ClientHandshakeContext)context, message);
 381             } else {
 382                 return onProduceFinished(
 383                         (ServerHandshakeContext)context, message);
 384             }
 385         }
 386 
 387         private byte[] onProduceFinished(ClientHandshakeContext chc,
 388                 HandshakeMessage message) throws IOException {
 389             // Refresh handshake hash
 390             chc.handshakeHash.update();
 391 
 392             FinishedMessage fm = new FinishedMessage(chc);
 393 
 394             // Change write cipher and delivery ChangeCipherSpec message.
 395             ChangeCipherSpec.t10Producer.produce(chc, message);
 396 
 397             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 398                 SSLLogger.fine(
 399                         &quot;Produced client Finished handshake message&quot;, fm);
 400             }
 401 
 402             // Output the handshake message.
 403             fm.write(chc.handshakeOutput);
 404             chc.handshakeOutput.flush();
 405 
 406             /*
 407              * save server verify data for secure renegotiation
 408              */
 409             if (chc.conContext.secureRenegotiation) {
 410                 chc.conContext.clientVerifyData = fm.verifyData;
 411             }
 412 
 413             if (chc.statelessResumption) {
 414                 chc.handshakeConsumers.put(
 415                         SSLHandshake.NEW_SESSION_TICKET.id, SSLHandshake.NEW_SESSION_TICKET);
 416             }
 417             // update the consumers and producers
 418             if (!chc.isResumption) {
 419                 chc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 420                         ChangeCipherSpec.t10Consumer);
 421                 chc.handshakeConsumers.put(
 422                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 423                 chc.conContext.inputRecord.expectingFinishFlight();
 424             } else {
 425                 if (chc.handshakeSession.isRejoinable()) {
 426                     ((SSLSessionContextImpl)chc.sslContext.
 427                         engineGetClientSessionContext()).put(
 428                             chc.handshakeSession);
 429                 }
 430                 chc.conContext.conSession = chc.handshakeSession.finish();
 431                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 432 
 433                 // handshake context cleanup.
 434                 chc.handshakeFinished = true;
 435 
 436                 // May need to retransmit the last flight for DTLS.
 437                 if (!chc.sslContext.isDTLS()) {
 438                     chc.conContext.finishHandshake();
 439                 }
 440             }
 441 
 442             // The handshake message has been delivered.
 443             return null;
 444         }
 445 
 446         private byte[] onProduceFinished(ServerHandshakeContext shc,
 447                 HandshakeMessage message) throws IOException {
 448             if (shc.statelessResumption) {
 449                 NewSessionTicket.handshake12Producer.produce(shc, message);
 450             }
 451 
 452             // Refresh handshake hash
 453             shc.handshakeHash.update();
 454 
 455             FinishedMessage fm = new FinishedMessage(shc);
 456 
 457             // Change write cipher and delivery ChangeCipherSpec message.
 458             ChangeCipherSpec.t10Producer.produce(shc, message);
 459 
 460             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 461                 SSLLogger.fine(
 462                         &quot;Produced server Finished handshake message&quot;, fm);
 463             }
 464 
 465             // Output the handshake message.
 466             fm.write(shc.handshakeOutput);
 467             shc.handshakeOutput.flush();
 468 
 469             /*
 470              * save client verify data for secure renegotiation
 471              */
 472             if (shc.conContext.secureRenegotiation) {
 473                 shc.conContext.serverVerifyData = fm.verifyData;
 474             }
 475 
 476             // update the consumers and producers
 477             if (shc.isResumption) {
 478                 shc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 479                         ChangeCipherSpec.t10Consumer);
 480                 shc.handshakeConsumers.put(
 481                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 482                 shc.conContext.inputRecord.expectingFinishFlight();
 483             } else {
 484                 // Set the session&#39;s context based on stateless/cache status
<a name="1" id="anc1"></a><span class="line-modified"> 485                 if (shc.handshakeSession.isStatelessable(shc)) {</span>

 486                     shc.handshakeSession.setContext((SSLSessionContextImpl)
 487                             shc.sslContext.engineGetServerSessionContext());
 488                 } else {
 489                     if (shc.handshakeSession.isRejoinable()) {
 490                         ((SSLSessionContextImpl)shc.sslContext.
 491                                 engineGetServerSessionContext()).put(
 492                                 shc.handshakeSession);
 493                     }
 494                 }
 495                 shc.conContext.conSession = shc.handshakeSession.finish();
 496                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 497 
 498                 // handshake context cleanup.
 499                 shc.handshakeFinished = true;
 500 
 501                 // May need to retransmit the last flight for DTLS.
 502                 if (!shc.sslContext.isDTLS()) {
 503                     shc.conContext.finishHandshake();
 504                 }
 505             }
 506 
 507             // The handshake message has been delivered.
 508             return null;
 509         }
 510     }
 511 
 512     /**
 513      * The &quot;Finished&quot; handshake message consumer.
 514      */
 515     private static final class T12FinishedConsumer implements SSLConsumer {
 516         // Prevent instantiation of this class.
 517         private T12FinishedConsumer() {
 518             // blank
 519         }
 520 
 521         @Override
 522         public void consume(ConnectionContext context,
 523                 ByteBuffer message) throws IOException {
 524             // The consuming happens in handshake context only.
 525             HandshakeContext hc = (HandshakeContext)context;
 526 
 527             // This consumer can be used only once.
 528             hc.handshakeConsumers.remove(SSLHandshake.FINISHED.id);
 529 
 530             // We should not be processing finished messages unless
 531             // we have received ChangeCipherSpec
 532             if (hc.conContext.consumers.containsKey(
 533                     ContentType.CHANGE_CIPHER_SPEC.id)) {
 534                 throw hc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 535                         &quot;Missing ChangeCipherSpec message&quot;);
 536             }
 537 
 538             if (hc.sslConfig.isClientMode) {
 539                 onConsumeFinished((ClientHandshakeContext)context, message);
 540             } else {
 541                 onConsumeFinished((ServerHandshakeContext)context, message);
 542             }
 543         }
 544 
 545         private void onConsumeFinished(ClientHandshakeContext chc,
 546                 ByteBuffer message) throws IOException {
 547             FinishedMessage fm = new FinishedMessage(chc, message);
 548             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 549                 SSLLogger.fine(
 550                         &quot;Consuming server Finished handshake message&quot;, fm);
 551             }
 552 
 553             if (chc.conContext.secureRenegotiation) {
 554                 chc.conContext.serverVerifyData = fm.verifyData;
 555             }
 556 
 557             if (!chc.isResumption) {
 558                 if (chc.handshakeSession.isRejoinable()) {
 559                     ((SSLSessionContextImpl)chc.sslContext.
 560                         engineGetClientSessionContext()).put(
 561                             chc.handshakeSession);
 562                 }
 563                 chc.conContext.conSession = chc.handshakeSession.finish();
 564                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 565 
 566                 // handshake context cleanup.
 567                 chc.handshakeFinished = true;
 568                 recordEvent(chc.conContext.conSession);
 569 
 570                 // May need to retransmit the last flight for DTLS.
 571                 if (!chc.sslContext.isDTLS()) {
 572                     chc.conContext.finishHandshake();
 573                 }
 574             } else {
 575                 chc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 576                         SSLHandshake.FINISHED);
 577             }
 578 
 579             //
 580             // produce
 581             //
 582             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
 583                 SSLHandshake.FINISHED
 584             };
 585 
 586             for (SSLHandshake hs : probableHandshakeMessages) {
 587                 HandshakeProducer handshakeProducer =
 588                         chc.handshakeProducers.remove(hs.id);
 589                 if (handshakeProducer != null) {
 590                     handshakeProducer.produce(chc, fm);
 591                 }
 592             }
 593         }
 594 
 595         private void onConsumeFinished(ServerHandshakeContext shc,
 596                 ByteBuffer message) throws IOException {
 597             // Make sure that any expected CertificateVerify message
 598             // has been received and processed.
 599             if (!shc.isResumption) {
 600                 if (shc.handshakeConsumers.containsKey(
 601                         SSLHandshake.CERTIFICATE_VERIFY.id)) {
 602                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 603                             &quot;Unexpected Finished handshake message&quot;);
 604                 }
 605             }
 606 
 607             FinishedMessage fm = new FinishedMessage(shc, message);
 608             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 609                 SSLLogger.fine(
 610                         &quot;Consuming client Finished handshake message&quot;, fm);
 611             }
 612 
 613             if (shc.conContext.secureRenegotiation) {
 614                 shc.conContext.clientVerifyData = fm.verifyData;
 615             }
 616 
 617             if (shc.isResumption) {
 618                 if (shc.handshakeSession.isRejoinable() &amp;&amp;
 619                         !shc.statelessResumption) {
 620                     ((SSLSessionContextImpl)shc.sslContext.
 621                         engineGetServerSessionContext()).put(
 622                             shc.handshakeSession);
 623                 }
 624                 shc.conContext.conSession = shc.handshakeSession.finish();
 625                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 626 
 627                 // handshake context cleanup.
 628                 shc.handshakeFinished = true;
 629                 recordEvent(shc.conContext.conSession);
 630 
 631                 // May need to retransmit the last flight for DTLS.
 632                 if (!shc.sslContext.isDTLS()) {
 633                     shc.conContext.finishHandshake();
 634                 }
 635             } else {
 636                 shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 637                         SSLHandshake.FINISHED);
 638             }
 639 
 640             //
 641             // produce
 642             //
 643             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
 644                 SSLHandshake.FINISHED
 645             };
 646 
 647             for (SSLHandshake hs : probableHandshakeMessages) {
 648                 HandshakeProducer handshakeProducer =
 649                         shc.handshakeProducers.remove(hs.id);
 650                 if (handshakeProducer != null) {
 651                     handshakeProducer.produce(shc, fm);
 652                 }
 653             }
 654         }
 655     }
 656 
 657     /**
 658      * The &quot;Finished&quot; handshake message producer.
 659      */
 660     private static final
 661             class T13FinishedProducer implements HandshakeProducer {
 662         // Prevent instantiation of this class.
 663         private T13FinishedProducer() {
 664             // blank
 665         }
 666 
 667         @Override
 668         public byte[] produce(ConnectionContext context,
 669                 HandshakeMessage message) throws IOException {
 670             // The consuming happens in handshake context only.
 671             HandshakeContext hc = (HandshakeContext)context;
 672             if (hc.sslConfig.isClientMode) {
 673                 return onProduceFinished(
 674                         (ClientHandshakeContext)context, message);
 675             } else {
 676                 return onProduceFinished(
 677                         (ServerHandshakeContext)context, message);
 678             }
 679         }
 680 
 681         private byte[] onProduceFinished(ClientHandshakeContext chc,
 682                 HandshakeMessage message) throws IOException {
 683             // Refresh handshake hash
 684             chc.handshakeHash.update();
 685 
 686             FinishedMessage fm = new FinishedMessage(chc);
 687             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 688                 SSLLogger.fine(
 689                         &quot;Produced client Finished handshake message&quot;, fm);
 690             }
 691 
 692             // Output the handshake message.
 693             fm.write(chc.handshakeOutput);
 694             chc.handshakeOutput.flush();
 695 
 696             // save server verify data for secure renegotiation
 697             if (chc.conContext.secureRenegotiation) {
 698                 chc.conContext.clientVerifyData = fm.verifyData;
 699             }
 700 
 701             // update the context
 702             // Change client/server application traffic secrets.
 703             SSLKeyDerivation kd = chc.handshakeKeyDerivation;
 704             if (kd == null) {
 705                 // unlikely
 706                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 707                     &quot;no key derivation&quot;);
 708             }
 709 
 710             SSLTrafficKeyDerivation kdg =
 711                     SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
 712             if (kdg == null) {
 713                 // unlikely
 714                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 715                         &quot;Not supported key derivation: &quot; +
 716                         chc.negotiatedProtocol);
 717             }
 718 
 719             try {
 720                 // update the application traffic read keys.
 721                 SecretKey writeSecret = kd.deriveKey(
 722                         &quot;TlsClientAppTrafficSecret&quot;, null);
 723 
 724                 SSLKeyDerivation writeKD =
 725                         kdg.createKeyDerivation(chc, writeSecret);
 726                 SecretKey writeKey = writeKD.deriveKey(
 727                         &quot;TlsKey&quot;, null);
 728                 SecretKey writeIvSecret = writeKD.deriveKey(
 729                         &quot;TlsIv&quot;, null);
 730                 IvParameterSpec writeIv =
 731                         new IvParameterSpec(writeIvSecret.getEncoded());
 732                 SSLWriteCipher writeCipher =
 733                         chc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
 734                                 Authenticator.valueOf(chc.negotiatedProtocol),
 735                                 chc.negotiatedProtocol, writeKey, writeIv,
 736                                 chc.sslContext.getSecureRandom());
 737 
 738                 if (writeCipher == null) {
 739                     throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 740                         &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
 741                         &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
 742                         &quot;)&quot;);
 743                 }
 744 
 745                 chc.baseWriteSecret = writeSecret;
 746                 chc.conContext.outputRecord.changeWriteCiphers(
 747                         writeCipher, false);
 748 
 749             } catch (GeneralSecurityException gse) {
 750                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 751                         &quot;Failure to derive application secrets&quot;, gse);
 752             }
 753 
 754             // The resumption master secret is stored in the session so
 755             // it can be used after the handshake is completed.
 756             SSLSecretDerivation sd = ((SSLSecretDerivation) kd).forContext(chc);
 757             SecretKey resumptionMasterSecret = sd.deriveKey(
 758                     &quot;TlsResumptionMasterSecret&quot;, null);
 759             chc.handshakeSession.setResumptionMasterSecret(
 760                     resumptionMasterSecret);
 761 
 762             chc.conContext.conSession = chc.handshakeSession.finish();
 763             chc.conContext.protocolVersion = chc.negotiatedProtocol;
 764 
 765             // handshake context cleanup.
 766             chc.handshakeFinished = true;
 767             chc.conContext.finishHandshake();
 768             recordEvent(chc.conContext.conSession);
 769 
 770 
 771             // The handshake message has been delivered.
 772             return null;
 773         }
 774 
 775         private byte[] onProduceFinished(ServerHandshakeContext shc,
 776                 HandshakeMessage message) throws IOException {
 777             // Refresh handshake hash
 778             shc.handshakeHash.update();
 779 
 780             FinishedMessage fm = new FinishedMessage(shc);
 781             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 782                 SSLLogger.fine(
 783                         &quot;Produced server Finished handshake message&quot;, fm);
 784             }
 785 
 786             // Output the handshake message.
 787             fm.write(shc.handshakeOutput);
 788             shc.handshakeOutput.flush();
 789 
 790             // Change client/server application traffic secrets.
 791             SSLKeyDerivation kd = shc.handshakeKeyDerivation;
 792             if (kd == null) {
 793                 // unlikely
 794                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 795                     &quot;no key derivation&quot;);
 796             }
 797 
 798             SSLTrafficKeyDerivation kdg =
 799                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
 800             if (kdg == null) {
 801                 // unlikely
 802                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 803                         &quot;Not supported key derivation: &quot; +
 804                         shc.negotiatedProtocol);
 805             }
 806 
 807             // derive salt secret
 808             try {
 809                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);
 810 
 811                 // derive application secrets
 812                 HashAlg hashAlg = shc.negotiatedCipherSuite.hashAlg;
 813                 HKDF hkdf = new HKDF(hashAlg.name);
 814                 byte[] zeros = new byte[hashAlg.hashLength];
 815                 SecretKeySpec sharedSecret =
 816                         new SecretKeySpec(zeros, &quot;TlsZeroSecret&quot;);
 817                 SecretKey masterSecret =
 818                     hkdf.extract(saltSecret, sharedSecret, &quot;TlsMasterSecret&quot;);
 819 
 820                 SSLKeyDerivation secretKD =
 821                         new SSLSecretDerivation(shc, masterSecret);
 822 
 823                 // update the handshake traffic write keys.
 824                 SecretKey writeSecret = secretKD.deriveKey(
 825                         &quot;TlsServerAppTrafficSecret&quot;, null);
 826                 SSLKeyDerivation writeKD =
 827                         kdg.createKeyDerivation(shc, writeSecret);
 828                 SecretKey writeKey = writeKD.deriveKey(
 829                         &quot;TlsKey&quot;, null);
 830                 SecretKey writeIvSecret = writeKD.deriveKey(
 831                         &quot;TlsIv&quot;, null);
 832                 IvParameterSpec writeIv =
 833                         new IvParameterSpec(writeIvSecret.getEncoded());
 834                 SSLWriteCipher writeCipher =
 835                         shc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
 836                                 Authenticator.valueOf(shc.negotiatedProtocol),
 837                                 shc.negotiatedProtocol, writeKey, writeIv,
 838                                 shc.sslContext.getSecureRandom());
 839 
 840                 if (writeCipher == null) {
 841                     throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 842                         &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 843                         &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 844                         &quot;)&quot;);
 845                 }
 846 
 847                 shc.baseWriteSecret = writeSecret;
 848                 shc.conContext.outputRecord.changeWriteCiphers(
 849                         writeCipher, false);
 850 
 851                 // update the context for the following key derivation
 852                 shc.handshakeKeyDerivation = secretKD;
 853             } catch (GeneralSecurityException gse) {
 854                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 855                         &quot;Failure to derive application secrets&quot;, gse);
 856             }
 857 
 858             /*
 859              * save client verify data for secure renegotiation
 860              */
 861             if (shc.conContext.secureRenegotiation) {
 862                 shc.conContext.serverVerifyData = fm.verifyData;
 863             }
 864 
 865             // Make sure session&#39;s context is set
 866             shc.handshakeSession.setContext((SSLSessionContextImpl)
 867                     shc.sslContext.engineGetServerSessionContext());
 868             shc.conContext.conSession = shc.handshakeSession.finish();
 869 
 870             // update the context
 871             shc.handshakeConsumers.put(
 872                     SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 873 
 874             // The handshake message has been delivered.
 875             return null;
 876         }
 877     }
 878 
 879     /**
 880      * The &quot;Finished&quot; handshake message consumer.
 881      */
 882     private static final class T13FinishedConsumer implements SSLConsumer {
 883         // Prevent instantiation of this class.
 884         private T13FinishedConsumer() {
 885             // blank
 886         }
 887 
 888         @Override
 889         public void consume(ConnectionContext context,
 890                 ByteBuffer message) throws IOException {
 891             // The consuming happens in handshake context only.
 892             HandshakeContext hc = (HandshakeContext)context;
 893             if (hc.sslConfig.isClientMode) {
 894                 onConsumeFinished(
 895                         (ClientHandshakeContext)context, message);
 896             } else {
 897                 onConsumeFinished(
 898                         (ServerHandshakeContext)context, message);
 899             }
 900         }
 901 
 902         private void onConsumeFinished(ClientHandshakeContext chc,
 903                 ByteBuffer message) throws IOException {
 904             // Make sure that any expected CertificateVerify message
 905             // has been received and processed.
 906             if (!chc.isResumption) {
 907                 if (chc.handshakeConsumers.containsKey(
 908                         SSLHandshake.CERTIFICATE.id) ||
 909                     chc.handshakeConsumers.containsKey(
 910                         SSLHandshake.CERTIFICATE_VERIFY.id)) {
 911                     throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 912                             &quot;Unexpected Finished handshake message&quot;);
 913                 }
 914             }
 915 
 916             FinishedMessage fm = new FinishedMessage(chc, message);
 917             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 918                 SSLLogger.fine(
 919                         &quot;Consuming server Finished handshake message&quot;, fm);
 920             }
 921 
 922             // Save client verify data for secure renegotiation.
 923             if (chc.conContext.secureRenegotiation) {
 924                 chc.conContext.serverVerifyData = fm.verifyData;
 925             }
 926 
 927             //
 928             // validate
 929             //
 930             // blank
 931 
 932             //
 933             // update
 934             //
 935             // A change_cipher_spec record received after the peer&#39;s Finished
 936             // message MUST be treated as an unexpected record type.
 937             chc.conContext.consumers.remove(ContentType.CHANGE_CIPHER_SPEC.id);
 938 
 939             // Change client/server application traffic secrets.
 940             // Refresh handshake hash
 941             chc.handshakeHash.update();
 942             SSLKeyDerivation kd = chc.handshakeKeyDerivation;
 943             if (kd == null) {
 944                 // unlikely
 945                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 946                     &quot;no key derivation&quot;);
 947             }
 948 
 949             SSLTrafficKeyDerivation kdg =
 950                     SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
 951             if (kdg == null) {
 952                 // unlikely
 953                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 954                         &quot;Not supported key derivation: &quot; +
 955                         chc.negotiatedProtocol);
 956             }
 957 
 958             // save the session
 959             if (!chc.isResumption &amp;&amp; chc.handshakeSession.isRejoinable()) {
 960                 ((SSLSessionContextImpl)chc.sslContext.
 961                         engineGetClientSessionContext()).
 962                         put(chc.handshakeSession);
 963             }
 964 
 965             // derive salt secret
 966             try {
 967                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);
 968 
 969                 // derive application secrets
 970                 HashAlg hashAlg = chc.negotiatedCipherSuite.hashAlg;
 971                 HKDF hkdf = new HKDF(hashAlg.name);
 972                 byte[] zeros = new byte[hashAlg.hashLength];
 973                 SecretKeySpec sharedSecret =
 974                         new SecretKeySpec(zeros, &quot;TlsZeroSecret&quot;);
 975                 SecretKey masterSecret =
 976                     hkdf.extract(saltSecret, sharedSecret, &quot;TlsMasterSecret&quot;);
 977 
 978                 SSLKeyDerivation secretKD =
 979                         new SSLSecretDerivation(chc, masterSecret);
 980 
 981                 // update the handshake traffic read keys.
 982                 SecretKey readSecret = secretKD.deriveKey(
 983                         &quot;TlsServerAppTrafficSecret&quot;, null);
 984                 SSLKeyDerivation writeKD =
 985                         kdg.createKeyDerivation(chc, readSecret);
 986                 SecretKey readKey = writeKD.deriveKey(
 987                         &quot;TlsKey&quot;, null);
 988                 SecretKey readIvSecret = writeKD.deriveKey(
 989                         &quot;TlsIv&quot;, null);
 990                 IvParameterSpec readIv =
 991                         new IvParameterSpec(readIvSecret.getEncoded());
 992                 SSLReadCipher readCipher =
 993                         chc.negotiatedCipherSuite.bulkCipher.createReadCipher(
 994                                 Authenticator.valueOf(chc.negotiatedProtocol),
 995                                 chc.negotiatedProtocol, readKey, readIv,
 996                                 chc.sslContext.getSecureRandom());
 997 
 998                 if (readCipher == null) {
 999                     throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1000                         &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
1001                         &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
1002                         &quot;)&quot;);
1003                 }
1004 
1005                 chc.baseReadSecret = readSecret;
1006                 chc.conContext.inputRecord.changeReadCiphers(readCipher);
1007 
1008                 // update the context for the following key derivation
1009                 chc.handshakeKeyDerivation = secretKD;
1010             } catch (GeneralSecurityException gse) {
1011                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1012                         &quot;Failure to derive application secrets&quot;, gse);
1013             }
1014 
1015             //
1016             // produce
1017             //
1018             chc.handshakeProducers.put(SSLHandshake.FINISHED.id,
1019                         SSLHandshake.FINISHED);
1020             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
1021                 // full handshake messages
1022                 SSLHandshake.CERTIFICATE,
1023                 SSLHandshake.CERTIFICATE_VERIFY,
1024                 SSLHandshake.FINISHED
1025             };
1026 
1027             for (SSLHandshake hs : probableHandshakeMessages) {
1028                 HandshakeProducer handshakeProducer =
1029                         chc.handshakeProducers.remove(hs.id);
1030                 if (handshakeProducer != null) {
1031                     handshakeProducer.produce(chc, null);
1032                 }
1033             }
1034         }
1035 
1036         private void onConsumeFinished(ServerHandshakeContext shc,
1037                 ByteBuffer message) throws IOException {
1038             // Make sure that any expected CertificateVerify message
1039             // has been received and processed.
1040             if (!shc.isResumption) {
1041                 if (shc.handshakeConsumers.containsKey(
1042                         SSLHandshake.CERTIFICATE.id) ||
1043                     shc.handshakeConsumers.containsKey(
1044                         SSLHandshake.CERTIFICATE_VERIFY.id)) {
1045                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1046                             &quot;Unexpected Finished handshake message&quot;);
1047                 }
1048             }
1049 
1050             FinishedMessage fm = new FinishedMessage(shc, message);
1051             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1052                 SSLLogger.fine(
1053                         &quot;Consuming client Finished handshake message&quot;, fm);
1054             }
1055 
1056             if (shc.conContext.secureRenegotiation) {
1057                 shc.conContext.clientVerifyData = fm.verifyData;
1058             }
1059 
1060             //
1061             // validate
1062             //
1063             // blank
1064 
1065             //
1066             // update
1067             //
1068             // Change client/server application traffic secrets.
1069             SSLKeyDerivation kd = shc.handshakeKeyDerivation;
1070             if (kd == null) {
1071                 // unlikely
1072                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1073                     &quot;no key derivation&quot;);
1074             }
1075 
1076             SSLTrafficKeyDerivation kdg =
1077                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
1078             if (kdg == null) {
1079                 // unlikely
1080                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1081                         &quot;Not supported key derivation: &quot; +
1082                         shc.negotiatedProtocol);
1083             }
1084 
1085             try {
1086                 // update the application traffic read keys.
1087                 SecretKey readSecret = kd.deriveKey(
1088                         &quot;TlsClientAppTrafficSecret&quot;, null);
1089 
1090                 SSLKeyDerivation readKD =
1091                         kdg.createKeyDerivation(shc, readSecret);
1092                 SecretKey readKey = readKD.deriveKey(
1093                         &quot;TlsKey&quot;, null);
1094                 SecretKey readIvSecret = readKD.deriveKey(
1095                         &quot;TlsIv&quot;, null);
1096                 IvParameterSpec readIv =
1097                         new IvParameterSpec(readIvSecret.getEncoded());
1098                 SSLReadCipher readCipher =
1099                         shc.negotiatedCipherSuite.bulkCipher.createReadCipher(
1100                                 Authenticator.valueOf(shc.negotiatedProtocol),
1101                                 shc.negotiatedProtocol, readKey, readIv,
1102                                 shc.sslContext.getSecureRandom());
1103 
1104                 if (readCipher == null) {
1105                     throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1106                         &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
1107                         &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
1108                         &quot;)&quot;);
1109                 }
1110 
1111                 shc.baseReadSecret = readSecret;
1112                 shc.conContext.inputRecord.changeReadCiphers(readCipher);
1113 
1114                 // The resumption master secret is stored in the session so
1115                 // it can be used after the handshake is completed.
1116                 shc.handshakeHash.update();
1117                 SSLSecretDerivation sd =
1118                         ((SSLSecretDerivation)kd).forContext(shc);
1119                 SecretKey resumptionMasterSecret = sd.deriveKey(
1120                 &quot;TlsResumptionMasterSecret&quot;, null);
1121                 shc.handshakeSession.setResumptionMasterSecret(
1122                         resumptionMasterSecret);
1123             } catch (GeneralSecurityException gse) {
1124                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1125                         &quot;Failure to derive application secrets&quot;, gse);
1126             }
1127 
1128             //  update connection context
1129             shc.conContext.conSession = shc.handshakeSession.finish();
1130             shc.conContext.protocolVersion = shc.negotiatedProtocol;
1131 
1132             // handshake context cleanup.
1133             shc.handshakeFinished = true;
1134 
1135             // May need to retransmit the last flight for DTLS.
1136             if (!shc.sslContext.isDTLS()) {
1137                 shc.conContext.finishHandshake();
1138             }
1139             recordEvent(shc.conContext.conSession);
1140 
1141             //
1142             // produce
<a name="2" id="anc2"></a><span class="line-modified">1143             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-removed">1144                 SSLLogger.fine(</span>
<span class="line-removed">1145                 &quot;Sending new session ticket&quot;);</span>
<span class="line-removed">1146             }</span>
<span class="line-removed">1147 </span>
<span class="line-removed">1148             NewSessionTicket.kickstartProducer.produce(shc);</span>
1149         }
1150     }
1151 
1152     private static void recordEvent(SSLSessionImpl session) {
1153         TLSHandshakeEvent event = new TLSHandshakeEvent();
1154         if (event.shouldCommit() || EventHelper.isLoggingSecurity()) {
1155             int peerCertificateId = 0;
1156             try {
1157                 // use hash code for Id
1158                 peerCertificateId = session
1159                         .getCertificateChain()[0]
1160                         .hashCode();
1161             } catch (SSLPeerUnverifiedException e) {
1162                  // not verified msg
1163             }
1164             if (event.shouldCommit()) {
1165                 event.peerHost = session.getPeerHost();
1166                 event.peerPort = session.getPeerPort();
1167                 event.cipherSuite = session.getCipherSuite();
1168                 event.protocolVersion = session.getProtocol();
1169                 event.certificateId = peerCertificateId;
1170                 event.commit();
1171             }
1172             if (EventHelper.isLoggingSecurity()) {
1173                 EventHelper.logTLSHandshakeEvent(null,
1174                                 session.getPeerHost(),
1175                                 session.getPeerPort(),
1176                                 session.getCipherSuite(),
1177                                 session.getProtocol(),
1178                                 peerCertificateId);
1179             }
1180         }
1181     }
1182 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
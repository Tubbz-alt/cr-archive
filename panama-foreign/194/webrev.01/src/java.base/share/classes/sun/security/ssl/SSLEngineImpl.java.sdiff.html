<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLEngineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="NewSessionTicket.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSessionImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLEngineImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 147                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);
 148             } catch (SSLProtocolException spe) {
 149                 // may be an unexpected handshake message
 150                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, spe);
 151             } catch (IOException ioe) {
 152                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 153                     &quot;problem wrapping app data&quot;, ioe);
 154             } catch (Exception ex) {     // including RuntimeException
 155                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 156                     &quot;Fail to wrap application data&quot;, ex);
 157             }
 158         } finally {
 159             engineLock.unlock();
 160         }
 161     }
 162 
 163     private SSLEngineResult writeRecord(
 164         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 165         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 166 







 167         // May need to deliver cached records.
 168         if (isOutboundDone()) {
 169             return new SSLEngineResult(
 170                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 171         }
 172 
 173         HandshakeContext hc = conContext.handshakeContext;
 174         HandshakeStatus hsStatus = null;
 175         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 176                 !conContext.isInboundClosed() &amp;&amp;
 177                 !conContext.isOutboundClosed()) {
 178             conContext.kickstart();
 179 
 180             hsStatus = getHandshakeStatus();
 181             if (hsStatus == HandshakeStatus.NEED_UNWRAP) {
 182                 /*
 183                  * For DTLS, if the handshake state is
 184                  * HandshakeStatus.NEED_UNWRAP, a call to SSLEngine.wrap()
 185                  * means that the previous handshake packets (if delivered)
 186                  * get lost, and need retransmit the handshake messages.
</pre>
<hr />
<pre>
 401         }
 402 
 403         return currentHandshakeStatus;
 404     }
 405 
 406     // Try to generate a PostHandshake NewSessionTicket message.  This is
 407     // TLS 1.3 only.
 408     private HandshakeStatus tryNewSessionTicket(
 409             HandshakeStatus currentHandshakeStatus) throws IOException {
 410         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
 411         // connection is not duplex-open.
 412         if ((conContext.handshakeContext == null) &amp;&amp;
 413                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;
 414                 !conContext.isOutboundClosed() &amp;&amp;
 415                 !conContext.isInboundClosed() &amp;&amp;
 416                 !conContext.isBroken) {
 417             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 418                 SSLLogger.finest(&quot;trigger NST&quot;);
 419             }
 420             conContext.conSession.updateNST = false;
<span class="line-modified"> 421             NewSessionTicket.kickstartProducer.produce(</span>
 422                     new PostHandshakeContext(conContext));
 423             return conContext.getHandshakeStatus();
 424         }
 425 
 426         return currentHandshakeStatus;
 427     }
 428 
 429     private static void checkParams(
 430             ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 431             ByteBuffer[] dsts, int dstsOffset, int dstsLength) {
 432 
 433         if ((srcs == null) || (dsts == null)) {
 434             throw new IllegalArgumentException(
 435                     &quot;source or destination buffer is null&quot;);
 436         }
 437 
 438         if ((dstsOffset &lt; 0) || (dstsLength &lt; 0) ||
 439                 (dstsOffset &gt; dsts.length - dstsLength)) {
 440             throw new IndexOutOfBoundsException(
 441                     &quot;index out of bound of the destination buffers&quot;);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 147                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);
 148             } catch (SSLProtocolException spe) {
 149                 // may be an unexpected handshake message
 150                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, spe);
 151             } catch (IOException ioe) {
 152                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 153                     &quot;problem wrapping app data&quot;, ioe);
 154             } catch (Exception ex) {     // including RuntimeException
 155                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 156                     &quot;Fail to wrap application data&quot;, ex);
 157             }
 158         } finally {
 159             engineLock.unlock();
 160         }
 161     }
 162 
 163     private SSLEngineResult writeRecord(
 164         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 165         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 166 
<span class="line-added"> 167         // See note on TransportContext.needHandshakeFinishedStatus.</span>
<span class="line-added"> 168         if (conContext.needHandshakeFinishedStatus) {</span>
<span class="line-added"> 169             conContext.needHandshakeFinishedStatus = false;</span>
<span class="line-added"> 170             return new SSLEngineResult(</span>
<span class="line-added"> 171                     Status.OK, HandshakeStatus.FINISHED, 0, 0);</span>
<span class="line-added"> 172         }</span>
<span class="line-added"> 173 </span>
 174         // May need to deliver cached records.
 175         if (isOutboundDone()) {
 176             return new SSLEngineResult(
 177                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 178         }
 179 
 180         HandshakeContext hc = conContext.handshakeContext;
 181         HandshakeStatus hsStatus = null;
 182         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 183                 !conContext.isInboundClosed() &amp;&amp;
 184                 !conContext.isOutboundClosed()) {
 185             conContext.kickstart();
 186 
 187             hsStatus = getHandshakeStatus();
 188             if (hsStatus == HandshakeStatus.NEED_UNWRAP) {
 189                 /*
 190                  * For DTLS, if the handshake state is
 191                  * HandshakeStatus.NEED_UNWRAP, a call to SSLEngine.wrap()
 192                  * means that the previous handshake packets (if delivered)
 193                  * get lost, and need retransmit the handshake messages.
</pre>
<hr />
<pre>
 408         }
 409 
 410         return currentHandshakeStatus;
 411     }
 412 
 413     // Try to generate a PostHandshake NewSessionTicket message.  This is
 414     // TLS 1.3 only.
 415     private HandshakeStatus tryNewSessionTicket(
 416             HandshakeStatus currentHandshakeStatus) throws IOException {
 417         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
 418         // connection is not duplex-open.
 419         if ((conContext.handshakeContext == null) &amp;&amp;
 420                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;
 421                 !conContext.isOutboundClosed() &amp;&amp;
 422                 !conContext.isInboundClosed() &amp;&amp;
 423                 !conContext.isBroken) {
 424             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 425                 SSLLogger.finest(&quot;trigger NST&quot;);
 426             }
 427             conContext.conSession.updateNST = false;
<span class="line-modified"> 428             NewSessionTicket.t13PosthandshakeProducer.produce(</span>
 429                     new PostHandshakeContext(conContext));
 430             return conContext.getHandshakeStatus();
 431         }
 432 
 433         return currentHandshakeStatus;
 434     }
 435 
 436     private static void checkParams(
 437             ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 438             ByteBuffer[] dsts, int dstsOffset, int dstsLength) {
 439 
 440         if ((srcs == null) || (dsts == null)) {
 441             throw new IllegalArgumentException(
 442                     &quot;source or destination buffer is null&quot;);
 443         }
 444 
 445         if ((dstsOffset &lt; 0) || (dstsLength &lt; 0) ||
 446                 (dstsOffset &gt; dsts.length - dstsLength)) {
 447             throw new IndexOutOfBoundsException(
 448                     &quot;index out of bound of the destination buffers&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="NewSessionTicket.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSessionImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
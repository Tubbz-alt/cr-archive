<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.EOFException;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InterruptedIOException;
  32 import java.io.OutputStream;
  33 import java.net.InetAddress;
  34 import java.net.InetSocketAddress;
  35 import java.net.Socket;
  36 import java.net.SocketAddress;
  37 import java.net.SocketException;
  38 import java.net.UnknownHostException;
  39 import java.nio.ByteBuffer;
  40 import java.util.List;
  41 import java.util.concurrent.TimeUnit;
  42 import java.util.concurrent.locks.ReentrantLock;
  43 import java.util.function.BiFunction;
  44 import javax.net.ssl.HandshakeCompletedListener;
  45 import javax.net.ssl.SSLException;
  46 import javax.net.ssl.SSLHandshakeException;
  47 import javax.net.ssl.SSLParameters;
  48 import javax.net.ssl.SSLProtocolException;
  49 import javax.net.ssl.SSLServerSocket;
  50 import javax.net.ssl.SSLSession;
  51 import javax.net.ssl.SSLSocket;
  52 import jdk.internal.access.JavaNetInetAddressAccess;
  53 import jdk.internal.access.SharedSecrets;
  54 
  55 /**
  56  * Implementation of an SSL socket.
  57  * &lt;P&gt;
  58  * This is a normal connection type socket, implementing SSL over some lower
  59  * level socket, such as TCP.  Because it is layered over some lower level
  60  * socket, it MUST override all default socket methods.
  61  * &lt;P&gt;
  62  * This API offers a non-traditional option for establishing SSL
  63  * connections.  You may first establish the connection directly, then pass
  64  * that connection to the SSL socket constructor with a flag saying which
  65  * role should be taken in the handshake protocol.  (The two ends of the
  66  * connection must not choose the same role!)  This allows setup of SSL
  67  * proxying or tunneling, and also allows the kind of &quot;role reversal&quot;
  68  * that is required for most FTP data transfers.
  69  *
  70  * @see javax.net.ssl.SSLSocket
  71  * @see SSLServerSocket
  72  *
  73  * @author David Brownell
  74  */
  75 public final class SSLSocketImpl
  76         extends BaseSSLSocketImpl implements SSLTransport {
  77 
  78     final SSLContextImpl            sslContext;
  79     final TransportContext          conContext;
  80 
  81     private final AppInputStream    appInput = new AppInputStream();
  82     private final AppOutputStream   appOutput = new AppOutputStream();
  83 
  84     private String                  peerHost;
  85     private boolean                 autoClose;
  86     private boolean                 isConnected = false;
  87     private volatile boolean        tlsIsClosed = false;
  88 
  89     private final ReentrantLock     socketLock = new ReentrantLock();
  90     private final ReentrantLock     handshakeLock = new ReentrantLock();
  91 
  92     /*
  93      * Is the local name service trustworthy?
  94      *
  95      * If the local name service is not trustworthy, reverse host name
  96      * resolution should not be performed for endpoint identification.
  97      */
  98     private static final boolean trustNameService =
  99             Utilities.getBooleanProperty(&quot;jdk.tls.trustNameService&quot;, false);
 100 
 101     /**
 102      * Package-private constructor used to instantiate an unconnected
 103      * socket.
 104      *
 105      * This instance is meant to set handshake state to use &quot;client mode&quot;.
 106      */
 107     SSLSocketImpl(SSLContextImpl sslContext) {
 108         super();
 109         this.sslContext = sslContext;
 110         HandshakeHash handshakeHash = new HandshakeHash();
 111         this.conContext = new TransportContext(sslContext, this,
 112                 new SSLSocketInputRecord(handshakeHash),
 113                 new SSLSocketOutputRecord(handshakeHash), true);
 114     }
 115 
 116     /**
 117      * Package-private constructor used to instantiate a server socket.
 118      *
 119      * This instance is meant to set handshake state to use &quot;server mode&quot;.
 120      */
 121     SSLSocketImpl(SSLContextImpl sslContext, SSLConfiguration sslConfig) {
 122         super();
 123         this.sslContext = sslContext;
 124         HandshakeHash handshakeHash = new HandshakeHash();
 125         this.conContext = new TransportContext(sslContext, this, sslConfig,
 126                 new SSLSocketInputRecord(handshakeHash),
 127                 new SSLSocketOutputRecord(handshakeHash));
 128     }
 129 
 130     /**
 131      * Constructs an SSL connection to a named host at a specified
 132      * port, using the authentication context provided.
 133      *
 134      * This endpoint acts as the client, and may rejoin an existing SSL session
 135      * if appropriate.
 136      */
 137     SSLSocketImpl(SSLContextImpl sslContext, String peerHost,
 138             int peerPort) throws IOException, UnknownHostException {
 139         super();
 140         this.sslContext = sslContext;
 141         HandshakeHash handshakeHash = new HandshakeHash();
 142         this.conContext = new TransportContext(sslContext, this,
 143                 new SSLSocketInputRecord(handshakeHash),
 144                 new SSLSocketOutputRecord(handshakeHash), true);
 145         this.peerHost = peerHost;
 146         SocketAddress socketAddress =
 147                peerHost != null ? new InetSocketAddress(peerHost, peerPort) :
 148                new InetSocketAddress(InetAddress.getByName(null), peerPort);
 149         connect(socketAddress, 0);
 150     }
 151 
 152     /**
 153      * Constructs an SSL connection to a server at a specified
 154      * address, and TCP port, using the authentication context
 155      * provided.
 156      *
 157      * This endpoint acts as the client, and may rejoin an existing SSL
 158      * session if appropriate.
 159      */
 160     SSLSocketImpl(SSLContextImpl sslContext,
 161             InetAddress address, int peerPort) throws IOException {
 162         super();
 163         this.sslContext = sslContext;
 164         HandshakeHash handshakeHash = new HandshakeHash();
 165         this.conContext = new TransportContext(sslContext, this,
 166                 new SSLSocketInputRecord(handshakeHash),
 167                 new SSLSocketOutputRecord(handshakeHash), true);
 168 
 169         SocketAddress socketAddress = new InetSocketAddress(address, peerPort);
 170         connect(socketAddress, 0);
 171     }
 172 
 173     /**
 174      * Constructs an SSL connection to a named host at a specified
 175      * port, using the authentication context provided.
 176      *
 177      * This endpoint acts as the client, and may rejoin an existing SSL
 178      * session if appropriate.
 179      */
 180     SSLSocketImpl(SSLContextImpl sslContext,
 181             String peerHost, int peerPort, InetAddress localAddr,
 182             int localPort) throws IOException, UnknownHostException {
 183         super();
 184         this.sslContext = sslContext;
 185         HandshakeHash handshakeHash = new HandshakeHash();
 186         this.conContext = new TransportContext(sslContext, this,
 187                 new SSLSocketInputRecord(handshakeHash),
 188                 new SSLSocketOutputRecord(handshakeHash), true);
 189         this.peerHost = peerHost;
 190 
 191         bind(new InetSocketAddress(localAddr, localPort));
 192         SocketAddress socketAddress =
 193                peerHost != null ? new InetSocketAddress(peerHost, peerPort) :
 194                new InetSocketAddress(InetAddress.getByName(null), peerPort);
 195         connect(socketAddress, 0);
 196     }
 197 
 198     /**
 199      * Constructs an SSL connection to a server at a specified
 200      * address, and TCP port, using the authentication context
 201      * provided.
 202      *
 203      * This endpoint acts as the client, and may rejoin an existing SSL
 204      * session if appropriate.
 205      */
 206     SSLSocketImpl(SSLContextImpl sslContext,
 207             InetAddress peerAddr, int peerPort,
 208             InetAddress localAddr, int localPort) throws IOException {
 209         super();
 210         this.sslContext = sslContext;
 211         HandshakeHash handshakeHash = new HandshakeHash();
 212         this.conContext = new TransportContext(sslContext, this,
 213                 new SSLSocketInputRecord(handshakeHash),
 214                 new SSLSocketOutputRecord(handshakeHash), true);
 215 
 216         bind(new InetSocketAddress(localAddr, localPort));
 217         SocketAddress socketAddress = new InetSocketAddress(peerAddr, peerPort);
 218         connect(socketAddress, 0);
 219     }
 220 
 221     /**
 222      * Creates a server mode {@link Socket} layered over an
 223      * existing connected socket, and is able to read data which has
 224      * already been consumed/removed from the {@link Socket}&#39;s
 225      * underlying {@link InputStream}.
 226      */
 227     SSLSocketImpl(SSLContextImpl sslContext, Socket sock,
 228             InputStream consumed, boolean autoClose) throws IOException {
 229         super(sock, consumed);
 230         // We always layer over a connected socket
 231         if (!sock.isConnected()) {
 232             throw new SocketException(&quot;Underlying socket is not connected&quot;);
 233         }
 234 
 235         this.sslContext = sslContext;
 236         HandshakeHash handshakeHash = new HandshakeHash();
 237         this.conContext = new TransportContext(sslContext, this,
 238                 new SSLSocketInputRecord(handshakeHash),
 239                 new SSLSocketOutputRecord(handshakeHash), false);
 240         this.autoClose = autoClose;
 241         doneConnect();
 242     }
 243 
 244     /**
 245      * Layer SSL traffic over an existing connection, rather than
 246      * creating a new connection.
 247      *
 248      * The existing connection may be used only for SSL traffic (using this
 249      * SSLSocket) until the SSLSocket.close() call returns. However, if a
 250      * protocol error is detected, that existing connection is automatically
 251      * closed.
 252      * &lt;p&gt;
 253      * This particular constructor always uses the socket in the
 254      * role of an SSL client. It may be useful in cases which start
 255      * using SSL after some initial data transfers, for example in some
 256      * SSL tunneling applications or as part of some kinds of application
 257      * protocols which negotiate use of a SSL based security.
 258      */
 259     SSLSocketImpl(SSLContextImpl sslContext, Socket sock,
 260             String peerHost, int port, boolean autoClose) throws IOException {
 261         super(sock);
 262         // We always layer over a connected socket
 263         if (!sock.isConnected()) {
 264             throw new SocketException(&quot;Underlying socket is not connected&quot;);
 265         }
 266 
 267         this.sslContext = sslContext;
 268         HandshakeHash handshakeHash = new HandshakeHash();
 269         this.conContext = new TransportContext(sslContext, this,
 270                 new SSLSocketInputRecord(handshakeHash),
 271                 new SSLSocketOutputRecord(handshakeHash), true);
 272         this.peerHost = peerHost;
 273         this.autoClose = autoClose;
 274         doneConnect();
 275     }
 276 
 277     @Override
 278     public void connect(SocketAddress endpoint,
 279             int timeout) throws IOException {
 280 
 281         if (isLayered()) {
 282             throw new SocketException(&quot;Already connected&quot;);
 283         }
 284 
 285         if (!(endpoint instanceof InetSocketAddress)) {
 286             throw new SocketException(
 287                     &quot;Cannot handle non-Inet socket addresses.&quot;);
 288         }
 289 
 290         super.connect(endpoint, timeout);
 291         doneConnect();
 292     }
 293 
 294     @Override
 295     public String[] getSupportedCipherSuites() {
 296         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 297     }
 298 
 299     @Override
 300     public String[] getEnabledCipherSuites() {
 301         socketLock.lock();
 302         try {
 303             return CipherSuite.namesOf(
 304                     conContext.sslConfig.enabledCipherSuites);
 305         } finally {
 306             socketLock.unlock();
 307         }
 308     }
 309 
 310     @Override
 311     public void setEnabledCipherSuites(String[] suites) {
 312         socketLock.lock();
 313         try {
 314             conContext.sslConfig.enabledCipherSuites =
 315                     CipherSuite.validValuesOf(suites);
 316         } finally {
 317             socketLock.unlock();
 318         }
 319     }
 320 
 321     @Override
 322     public String[] getSupportedProtocols() {
 323         return ProtocolVersion.toStringArray(
 324                 sslContext.getSupportedProtocolVersions());
 325     }
 326 
 327     @Override
 328     public String[] getEnabledProtocols() {
 329         socketLock.lock();
 330         try {
 331             return ProtocolVersion.toStringArray(
 332                     conContext.sslConfig.enabledProtocols);
 333         } finally {
 334             socketLock.unlock();
 335         }
 336     }
 337 
 338     @Override
 339     public void setEnabledProtocols(String[] protocols) {
 340         if (protocols == null) {
 341             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
 342         }
 343 
 344         socketLock.lock();
 345         try {
 346             conContext.sslConfig.enabledProtocols =
 347                     ProtocolVersion.namesOf(protocols);
 348         } finally {
 349             socketLock.unlock();
 350         }
 351     }
 352 
 353     @Override
 354     public SSLSession getSession() {
 355         try {
 356             // start handshaking, if failed, the connection will be closed.
 357             ensureNegotiated();
 358         } catch (IOException ioe) {
 359             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 360                 SSLLogger.severe(&quot;handshake failed&quot;, ioe);
 361             }
 362 
 363             return new SSLSessionImpl();
 364         }
 365 
 366         return conContext.conSession;
 367     }
 368 
 369     @Override
 370     public SSLSession getHandshakeSession() {
 371         socketLock.lock();
 372         try {
 373             return conContext.handshakeContext == null ?
 374                     null : conContext.handshakeContext.handshakeSession;
 375         } finally {
 376             socketLock.unlock();
 377         }
 378     }
 379 
 380     @Override
 381     public void addHandshakeCompletedListener(
 382             HandshakeCompletedListener listener) {
 383         if (listener == null) {
 384             throw new IllegalArgumentException(&quot;listener is null&quot;);
 385         }
 386 
 387         socketLock.lock();
 388         try {
 389             conContext.sslConfig.addHandshakeCompletedListener(listener);
 390         } finally {
 391             socketLock.unlock();
 392         }
 393     }
 394 
 395     @Override
 396     public void removeHandshakeCompletedListener(
 397             HandshakeCompletedListener listener) {
 398         if (listener == null) {
 399             throw new IllegalArgumentException(&quot;listener is null&quot;);
 400         }
 401 
 402         socketLock.lock();
 403         try {
 404             conContext.sslConfig.removeHandshakeCompletedListener(listener);
 405         } finally {
 406             socketLock.unlock();
 407         }
 408     }
 409 
 410     @Override
 411     public void startHandshake() throws IOException {
 412         if (!isConnected) {
 413             throw new SocketException(&quot;Socket is not connected&quot;);
 414         }
 415 
 416         if (conContext.isBroken || conContext.isInboundClosed() ||
 417                 conContext.isOutboundClosed()) {
 418             throw new SocketException(&quot;Socket has been closed or broken&quot;);
 419         }
 420 
 421         handshakeLock.lock();
 422         try {
 423             // double check the context status
 424             if (conContext.isBroken || conContext.isInboundClosed() ||
 425                     conContext.isOutboundClosed()) {
 426                 throw new SocketException(&quot;Socket has been closed or broken&quot;);
 427             }
 428 
 429             try {
 430                 conContext.kickstart();
 431 
 432                 // All initial handshaking goes through this operation until we
 433                 // have a valid SSL connection.
 434                 //
 435                 // Handle handshake messages only, need no application data.
 436                 if (!conContext.isNegotiated) {
 437                     readHandshakeRecord();
 438                 }
 439             } catch (InterruptedIOException iioe) {
 440                 handleException(iioe);
 441             } catch (IOException ioe) {
 442                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 443                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
 444             } catch (Exception oe) {    // including RuntimeException
 445                 handleException(oe);
 446             }
 447         } finally {
 448             handshakeLock.unlock();
 449         }
 450     }
 451 
 452     @Override
 453     public void setUseClientMode(boolean mode) {
 454         socketLock.lock();
 455         try {
 456             conContext.setUseClientMode(mode);
 457         } finally {
 458             socketLock.unlock();
 459         }
 460     }
 461 
 462     @Override
 463     public boolean getUseClientMode() {
 464         socketLock.lock();
 465         try {
 466             return conContext.sslConfig.isClientMode;
 467         } finally {
 468             socketLock.unlock();
 469         }
 470     }
 471 
 472     @Override
 473     public void setNeedClientAuth(boolean need) {
 474         socketLock.lock();
 475         try {
 476             conContext.sslConfig.clientAuthType =
 477                     (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :
 478                             ClientAuthType.CLIENT_AUTH_NONE);
 479         } finally {
 480             socketLock.unlock();
 481         }
 482     }
 483 
 484     @Override
 485     public boolean getNeedClientAuth() {
 486         socketLock.lock();
 487         try {
 488             return (conContext.sslConfig.clientAuthType ==
 489                         ClientAuthType.CLIENT_AUTH_REQUIRED);
 490         } finally {
 491             socketLock.unlock();
 492         }
 493     }
 494 
 495     @Override
 496     public void setWantClientAuth(boolean want) {
 497         socketLock.lock();
 498         try {
 499             conContext.sslConfig.clientAuthType =
 500                     (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :
 501                             ClientAuthType.CLIENT_AUTH_NONE);
 502         } finally {
 503             socketLock.unlock();
 504         }
 505     }
 506 
 507     @Override
 508     public boolean getWantClientAuth() {
 509         socketLock.lock();
 510         try {
 511             return (conContext.sslConfig.clientAuthType ==
 512                         ClientAuthType.CLIENT_AUTH_REQUESTED);
 513         } finally {
 514             socketLock.unlock();
 515         }
 516     }
 517 
 518     @Override
 519     public void setEnableSessionCreation(boolean flag) {
 520         socketLock.lock();
 521         try {
 522             conContext.sslConfig.enableSessionCreation = flag;
 523         } finally {
 524             socketLock.unlock();
 525         }
 526     }
 527 
 528     @Override
 529     public boolean getEnableSessionCreation() {
 530         socketLock.lock();
 531         try {
 532             return conContext.sslConfig.enableSessionCreation;
 533         } finally {
 534             socketLock.unlock();
 535         }
 536     }
 537 
 538     @Override
 539     public boolean isClosed() {
 540         return tlsIsClosed;
 541     }
 542 
 543     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 544     // locks may be deadlocked.
 545     @Override
 546     public void close() throws IOException {
 547         if (tlsIsClosed) {
 548             return;
 549         }
 550 
 551         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 552             SSLLogger.fine(&quot;duplex close of SSLSocket&quot;);
 553         }
 554 
 555         try {
 556             // shutdown output bound, which may have been closed previously.
 557             if (!isOutputShutdown()) {
 558                 duplexCloseOutput();
 559             }
 560 
 561             // shutdown input bound, which may have been closed previously.
 562             if (!isInputShutdown()) {
 563                 duplexCloseInput();
 564             }
 565 
 566             if (!isClosed()) {
 567                 // close the connection directly
 568                 closeSocket(false);
 569             }
 570         } catch (IOException ioe) {
 571             // ignore the exception
 572             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 573                 SSLLogger.warning(&quot;SSLSocket duplex close failed&quot;, ioe);
 574             }
 575         } finally {
 576             tlsIsClosed = true;
 577         }
 578     }
 579 
 580     /**
 581      * Duplex close, start from closing outbound.
 582      *
 583      * For TLS 1.2 [RFC 5246], unless some other fatal alert has been
 584      * transmitted, each party is required to send a close_notify alert
 585      * before closing the write side of the connection.  The other party
 586      * MUST respond with a close_notify alert of its own and close down
 587      * the connection immediately, discarding any pending writes.  It is
 588      * not required for the initiator of the close to wait for the responding
 589      * close_notify alert before closing the read side of the connection.
 590      *
 591      * For TLS 1.3, Each party MUST send a close_notify alert before
 592      * closing its write side of the connection, unless it has already sent
 593      * some error alert.  This does not have any effect on its read side of
 594      * the connection.  Both parties need not wait to receive a close_notify
 595      * alert before closing their read side of the connection, though doing
 596      * so would introduce the possibility of truncation.
 597      *
 598      * In order to support user initiated duplex-close for TLS 1.3 connections,
 599      * the user_canceled alert is used together with the close_notify alert.
 600      */
 601     private void duplexCloseOutput() throws IOException {
 602         boolean useUserCanceled = false;
 603         boolean hasCloseReceipt = false;
 604         if (conContext.isNegotiated) {
 605             if (!conContext.protocolVersion.useTLS13PlusSpec()) {
 606                 hasCloseReceipt = true;
 607             } else {
 608                 // Use a user_canceled alert for TLS 1.3 duplex close.
 609                 useUserCanceled = true;
 610             }
 611         } else if (conContext.handshakeContext != null) {   // initial handshake
 612             // Use user_canceled alert regardless the protocol versions.
 613             useUserCanceled = true;
 614 
 615             // The protocol version may have been negotiated.
 616             ProtocolVersion pv = conContext.handshakeContext.negotiatedProtocol;
 617             if (pv == null || (!pv.useTLS13PlusSpec())) {
 618                 hasCloseReceipt = true;
 619             }
 620         }
 621 
 622         // Deliver the user_canceled alert and the close notify alert.
 623         closeNotify(useUserCanceled);
 624 
 625         if (!isInputShutdown()) {
 626             bruteForceCloseInput(hasCloseReceipt);
 627         }
 628     }
 629 
 630     void closeNotify(boolean useUserCanceled) throws IOException {
 631         // Need a lock here so that the user_canceled alert and the
 632         // close_notify alert can be delivered together.
 633         int linger = getSoLinger();
 634         if (linger &gt;= 0) {
 635             // don&#39;t wait more than SO_LINGER for obtaining the
 636             // the lock.
 637             //
 638             // keep and clear the current thread interruption status.
 639             boolean interrupted = Thread.interrupted();
 640             try {
 641                 if (conContext.outputRecord.recordLock.tryLock() ||
 642                         conContext.outputRecord.recordLock.tryLock(
 643                                 linger, TimeUnit.SECONDS)) {
 644                     try {
 645                         deliverClosedNotify(useUserCanceled);
 646                     } finally {
 647                         conContext.outputRecord.recordLock.unlock();
 648                     }
 649                 } else {
 650                     // For layered, non-autoclose sockets, we are not
 651                     // able to bring them into a usable state, so we
 652                     // treat it as fatal error.
 653                     if (!super.isOutputShutdown()) {
 654                         if (isLayered() &amp;&amp; !autoClose) {
 655                             throw new SSLException(
 656                                     &quot;SO_LINGER timeout, &quot; +
 657                                     &quot;close_notify message cannot be sent.&quot;);
 658                         } else {
 659                             super.shutdownOutput();
 660                             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 661                                 SSLLogger.warning(
 662                                     &quot;SSLSocket output duplex close failed: &quot; +
 663                                     &quot;SO_LINGER timeout, &quot; +
 664                                     &quot;close_notify message cannot be sent.&quot;);
 665                             }
 666                         }
 667                     }
 668 
 669                     // RFC2246 requires that the session becomes
 670                     // unresumable if any connection is terminated
 671                     // without proper close_notify messages with
 672                     // level equal to warning.
 673                     //
 674                     // RFC4346 no longer requires that a session not be
 675                     // resumed if failure to properly close a connection.
 676                     //
 677                     // We choose to make the session unresumable if
 678                     // failed to send the close_notify message.
 679                     //
 680                     conContext.conSession.invalidate();
 681                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 682                         SSLLogger.warning(
 683                                 &quot;Invalidate the session: SO_LINGER timeout, &quot; +
 684                                 &quot;close_notify message cannot be sent.&quot;);
 685                     }
 686                 }
 687             } catch (InterruptedException ex) {
 688                 // keep interrupted status
 689                 interrupted = true;
 690             }
 691 
 692             // restore the interrupted status
 693             if (interrupted) {
 694                 Thread.currentThread().interrupt();
 695             }
 696         } else {
 697             conContext.outputRecord.recordLock.lock();
 698             try {
 699                 deliverClosedNotify(useUserCanceled);
 700             } finally {
 701                 conContext.outputRecord.recordLock.unlock();
 702             }
 703         }
 704     }
 705 
 706     private void deliverClosedNotify(
 707             boolean useUserCanceled) throws IOException {
 708         try {
 709             // send a user_canceled alert if needed.
 710             if (useUserCanceled) {
 711                 conContext.warning(Alert.USER_CANCELED);
 712             }
 713 
 714             // send a close_notify alert
 715             conContext.warning(Alert.CLOSE_NOTIFY);
 716         } finally {
 717             if (!conContext.isOutboundClosed()) {
 718                 conContext.outputRecord.close();
 719             }
 720 
 721             if (!super.isOutputShutdown() &amp;&amp;
 722                     (autoClose || !isLayered())) {
 723                 super.shutdownOutput();
 724             }
 725         }
 726     }
 727 
 728     /**
 729      * Duplex close, start from closing inbound.
 730      *
 731      * This method should only be called when the outbound has been closed,
 732      * but the inbound is still open.
 733      */
 734     private void duplexCloseInput() throws IOException {
 735         boolean hasCloseReceipt = false;
 736         if (conContext.isNegotiated &amp;&amp;
 737                 !conContext.protocolVersion.useTLS13PlusSpec()) {
 738             hasCloseReceipt = true;
 739         }   // No close receipt if handshake has no completed.
 740 
 741         bruteForceCloseInput(hasCloseReceipt);
 742     }
 743 
 744     /**
 745      * Brute force close the input bound.
 746      *
 747      * This method should only be called when the outbound has been closed,
 748      * but the inbound is still open.
 749      */
 750     private void bruteForceCloseInput(
 751             boolean hasCloseReceipt) throws IOException {
 752         if (hasCloseReceipt) {
 753             // It is not required for the initiator of the close to wait for
 754             // the responding close_notify alert before closing the read side
 755             // of the connection.  However, if the application protocol using
 756             // TLS provides that any data may be carried over the underlying
 757             // transport after the TLS connection is closed, the TLS
 758             // implementation MUST receive a &quot;close_notify&quot; alert before
 759             // indicating end-of-data to the application-layer.
 760             try {
 761                 this.shutdown();
 762             } finally {
 763                 if (!isInputShutdown()) {
 764                     shutdownInput(false);
 765                 }
 766             }
 767         } else {
 768             if (!conContext.isInboundClosed()) {
 769                 try (conContext.inputRecord) {
 770                     // Try the best to use up the input records and close the
 771                     // socket gracefully, without impact the performance too
 772                     // much.
 773                     appInput.deplete();
 774                 }
 775             }
 776 
 777             if ((autoClose || !isLayered()) &amp;&amp; !super.isInputShutdown()) {
 778                 super.shutdownInput();
 779             }
 780         }
 781     }
 782 
 783     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 784     // locks may be deadlocked.
 785     @Override
 786     public void shutdownInput() throws IOException {
 787         shutdownInput(true);
 788     }
 789 
 790     // It is not required to check the close_notify receipt unless an
 791     // application call shutdownInput() explicitly.
 792     private void shutdownInput(
 793             boolean checkCloseNotify) throws IOException {
 794         if (isInputShutdown()) {
 795             return;
 796         }
 797 
 798         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 799             SSLLogger.fine(&quot;close inbound of SSLSocket&quot;);
 800         }
 801 
 802         // Is it ready to close inbound?
 803         //
 804         // No need to throw exception if the initial handshake is not started.
 805         if (checkCloseNotify &amp;&amp; !conContext.isInputCloseNotified &amp;&amp;
 806             (conContext.isNegotiated || conContext.handshakeContext != null)) {
 807 
 808             throw conContext.fatal(Alert.INTERNAL_ERROR,
 809                     &quot;closing inbound before receiving peer&#39;s close_notify&quot;);
 810         }
 811 
 812         conContext.closeInbound();
 813         if ((autoClose || !isLayered()) &amp;&amp; !super.isInputShutdown()) {
 814             super.shutdownInput();
 815         }
 816     }
 817 
 818     @Override
 819     public boolean isInputShutdown() {
 820         return conContext.isInboundClosed() &amp;&amp;
 821                 ((autoClose || !isLayered()) ? super.isInputShutdown(): true);
 822     }
 823 
 824     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 825     // locks may be deadlocked.
 826     @Override
 827     public void shutdownOutput() throws IOException {
 828         if (isOutputShutdown()) {
 829             return;
 830         }
 831 
 832         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 833             SSLLogger.fine(&quot;close outbound of SSLSocket&quot;);
 834         }
 835         conContext.closeOutbound();
 836 
 837         if ((autoClose || !isLayered()) &amp;&amp; !super.isOutputShutdown()) {
 838             super.shutdownOutput();
 839         }
 840     }
 841 
 842     @Override
 843     public boolean isOutputShutdown() {
 844         return conContext.isOutboundClosed() &amp;&amp;
 845                 ((autoClose || !isLayered()) ? super.isOutputShutdown(): true);
 846     }
 847 
 848     @Override
 849     public InputStream getInputStream() throws IOException {
 850         socketLock.lock();
 851         try {
 852             if (isClosed()) {
 853                 throw new SocketException(&quot;Socket is closed&quot;);
 854             }
 855 
 856             if (!isConnected) {
 857                 throw new SocketException(&quot;Socket is not connected&quot;);
 858             }
 859 
 860             if (conContext.isInboundClosed() || isInputShutdown()) {
 861                 throw new SocketException(&quot;Socket input is already shutdown&quot;);
 862             }
 863 
 864             return appInput;
 865         } finally {
 866             socketLock.unlock();
 867         }
 868     }
 869 
 870     private void ensureNegotiated() throws IOException {
 871         if (conContext.isNegotiated || conContext.isBroken ||
 872                 conContext.isInboundClosed() || conContext.isOutboundClosed()) {
 873             return;
 874         }
 875 
 876         handshakeLock.lock();
 877         try {
 878             // double check the context status
 879             if (conContext.isNegotiated || conContext.isBroken ||
 880                     conContext.isInboundClosed() ||
 881                     conContext.isOutboundClosed()) {
 882                 return;
 883             }
 884 
 885             startHandshake();
 886         } finally {
 887             handshakeLock.unlock();
 888         }
 889     }
 890 
 891     /**
 892      * InputStream for application data as returned by
 893      * SSLSocket.getInputStream().
 894      */
 895     private class AppInputStream extends InputStream {
 896         // One element array used to implement the single byte read() method
 897         private final byte[] oneByte = new byte[1];
 898 
 899         // the temporary buffer used to read network
 900         private ByteBuffer buffer;
 901 
 902         // Is application data available in the stream?
 903         private volatile boolean appDataIsAvailable;
 904 
 905         // reading lock
 906         private final ReentrantLock readLock = new ReentrantLock();
 907 
 908         // closing status
 909         private volatile boolean isClosing;
 910         private volatile boolean hasDepleted;
 911 
 912         AppInputStream() {
 913             this.appDataIsAvailable = false;
 914             this.buffer = ByteBuffer.allocate(4096);
 915         }
 916 
 917         /**
 918          * Return the minimum number of bytes that can be read
 919          * without blocking.
 920          */
 921         @Override
 922         public int available() throws IOException {
 923             // Currently not synchronized.
 924             if ((!appDataIsAvailable) || checkEOF()) {
 925                 return 0;
 926             }
 927 
 928             return buffer.remaining();
 929         }
 930 
 931         /**
 932          * Read a single byte, returning -1 on non-fault EOF status.
 933          */
 934         @Override
 935         public int read() throws IOException {
 936             int n = read(oneByte, 0, 1);
 937             if (n &lt;= 0) {   // EOF
 938                 return -1;
 939             }
 940 
 941             return oneByte[0] &amp; 0xFF;
 942         }
 943 
 944         /**
 945          * Reads up to {@code len} bytes of data from the input stream
 946          * into an array of bytes.
 947          *
 948          * An attempt is made to read as many as {@code len} bytes, but a
 949          * smaller number may be read. The number of bytes actually read
 950          * is returned as an integer.
 951          *
 952          * If the layer above needs more data, it asks for more, so we
 953          * are responsible only for blocking to fill at most one buffer,
 954          * and returning &quot;-1&quot; on non-fault EOF status.
 955          */
 956         @Override
 957         public int read(byte[] b, int off, int len) throws IOException {
 958             if (b == null) {
 959                 throw new NullPointerException(&quot;the target buffer is null&quot;);
 960             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
 961                 throw new IndexOutOfBoundsException(
 962                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
 963                         &quot;, bytes to read:&quot; + len);
 964             } else if (len == 0) {
 965                 return 0;
 966             }
 967 
 968             if (checkEOF()) {
 969                 return -1;
 970             }
 971 
 972             // start handshaking if the connection has not been negotiated.
 973             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 974                     !conContext.isInboundClosed() &amp;&amp;
 975                     !conContext.isOutboundClosed()) {
 976                 ensureNegotiated();
 977             }
 978 
 979             // Check if the Socket is invalid (error or closed).
 980             if (!conContext.isNegotiated ||
 981                     conContext.isBroken || conContext.isInboundClosed()) {
 982                 throw new SocketException(&quot;Connection or inbound has closed&quot;);
 983             }
 984 
 985             // Check if the input stream has been depleted.
 986             //
 987             // Note that the &quot;hasDepleted&quot; rather than the isClosing
 988             // filed is checked here, in case the closing process is
 989             // still in progress.
 990             if (hasDepleted) {
 991                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 992                     SSLLogger.fine(&quot;The input stream has been depleted&quot;);
 993                 }
 994 
 995                 return -1;
 996             }
 997 
 998             // Read the available bytes at first.
 999             //
1000             // Note that the receiving and processing of post-handshake message
1001             // are also synchronized with the read lock.
1002             readLock.lock();
1003             try {
1004                 // Double check if the Socket is invalid (error or closed).
1005                 if (conContext.isBroken || conContext.isInboundClosed()) {
1006                     throw new SocketException(
1007                             &quot;Connection or inbound has closed&quot;);
1008                 }
1009 
1010                 // Double check if the input stream has been depleted.
1011                 if (hasDepleted) {
1012                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1013                         SSLLogger.fine(&quot;The input stream is closing&quot;);
1014                     }
1015 
1016                     return -1;
1017                 }
1018 
1019                 int remains = available();
1020                 if (remains &gt; 0) {
1021                     int howmany = Math.min(remains, len);
1022                     buffer.get(b, off, howmany);
1023 
1024                     return howmany;
1025                 }
1026 
1027                 appDataIsAvailable = false;
1028                 try {
1029                     ByteBuffer bb = readApplicationRecord(buffer);
1030                     if (bb == null) {   // EOF
1031                         return -1;
1032                     } else {
1033                         // The buffer may be reallocated for bigger capacity.
1034                         buffer = bb;
1035                     }
1036 
1037                     bb.flip();
1038                     int volume = Math.min(len, bb.remaining());
1039                     buffer.get(b, off, volume);
1040                     appDataIsAvailable = true;
1041 
1042                     return volume;
1043                 } catch (Exception e) {   // including RuntimeException
1044                     // shutdown and rethrow (wrapped) exception as appropriate
1045                     handleException(e);
1046 
1047                     // dummy for compiler
1048                     return -1;
1049                 }
1050             } finally {
1051                 // Check if the input stream is closing.
1052                 //
1053                 // If the deplete() did not hold the lock, clean up the
1054                 // input stream here.
1055                 try {
1056                     if (isClosing) {
1057                         readLockedDeplete();
1058                     }
1059                 } finally {
1060                     readLock.unlock();
1061                 }
1062             }
1063         }
1064 
1065         /**
1066          * Skip n bytes.
1067          *
1068          * This implementation is somewhat less efficient than possible, but
1069          * not badly so (redundant copy).  We reuse the read() code to keep
1070          * things simpler.
1071          */
1072         @Override
1073         public long skip(long n) throws IOException {
1074             // dummy array used to implement skip()
1075             byte[] skipArray = new byte[256];
1076             long skipped = 0;
1077 
1078             readLock.lock();
1079             try {
1080                 while (n &gt; 0) {
1081                     int len = (int)Math.min(n, skipArray.length);
1082                     int r = read(skipArray, 0, len);
1083                     if (r &lt;= 0) {
1084                         break;
1085                     }
1086                     n -= r;
1087                     skipped += r;
1088                 }
1089             } finally {
1090                 readLock.unlock();
1091             }
1092 
1093             return skipped;
1094         }
1095 
1096         @Override
1097         public void close() throws IOException {
1098             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1099                 SSLLogger.finest(&quot;Closing input stream&quot;);
1100             }
1101 
1102             try {
1103                 SSLSocketImpl.this.close();
1104             } catch (IOException ioe) {
1105                 // ignore the exception
1106                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1107                     SSLLogger.warning(&quot;input stream close failed&quot;, ioe);
1108                 }
1109             }
1110         }
1111 
1112         /**
1113          * Return whether we have reached end-of-file.
1114          *
1115          * If the socket is not connected, has been shutdown because of an error
1116          * or has been closed, throw an Exception.
1117          */
1118         private boolean checkEOF() throws IOException {
1119             if (conContext.isBroken) {
1120                 if (conContext.closeReason == null) {
1121                     return true;
1122                 } else {
1123                     throw new SSLException(
1124                             &quot;Connection has closed: &quot; + conContext.closeReason,
1125                             conContext.closeReason);
1126                 }
1127             } else if (conContext.isInboundClosed()) {
1128                 return true;
1129             } else if (conContext.isInputCloseNotified) {
1130                 if (conContext.closeReason == null) {
1131                     return true;
1132                 } else {
1133                     throw new SSLException(
1134                         &quot;Connection has closed: &quot; + conContext.closeReason,
1135                         conContext.closeReason);
1136                 }
1137             }
1138 
1139             return false;
1140         }
1141 
1142         /**
1143          * Try the best to use up the input records so as to close the
1144          * socket gracefully, without impact the performance too much.
1145          */
1146         private void deplete() {
1147             if (conContext.isInboundClosed() || isClosing) {
1148                 return;
1149             }
1150 
1151             isClosing = true;
1152             if (readLock.tryLock()) {
1153                 try {
1154                     readLockedDeplete();
1155                 } finally {
1156                     readLock.unlock();
1157                 }
1158             }
1159         }
1160 
1161         /**
1162          * Try to use up the input records.
1163          *
1164          * Please don&#39;t call this method unless the readLock is held by
1165          * the current thread.
1166          */
1167         private void readLockedDeplete() {
1168             // double check
1169             if (hasDepleted || conContext.isInboundClosed()) {
1170                 return;
1171             }
1172 
1173             if (!(conContext.inputRecord instanceof SSLSocketInputRecord)) {
1174                 return;
1175             }
1176 
1177             SSLSocketInputRecord socketInputRecord =
1178                     (SSLSocketInputRecord)conContext.inputRecord;
1179             try {
1180                 socketInputRecord.deplete(
1181                     conContext.isNegotiated &amp;&amp; (getSoTimeout() &gt; 0));
1182             } catch (Exception ex) {
1183                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1184                     SSLLogger.warning(
1185                         &quot;input stream close depletion failed&quot;, ex);
1186                 }
1187             } finally {
1188                 hasDepleted = true;
1189             }
1190         }
1191     }
1192 
1193     @Override
1194     public OutputStream getOutputStream() throws IOException {
1195         socketLock.lock();
1196         try {
1197             if (isClosed()) {
1198                 throw new SocketException(&quot;Socket is closed&quot;);
1199             }
1200 
1201             if (!isConnected) {
1202                 throw new SocketException(&quot;Socket is not connected&quot;);
1203             }
1204 
1205             if (conContext.isOutboundDone() || isOutputShutdown()) {
1206                 throw new SocketException(&quot;Socket output is already shutdown&quot;);
1207             }
1208 
1209             return appOutput;
1210         } finally {
1211             socketLock.unlock();
1212         }
1213     }
1214 
1215 
1216     /**
1217      * OutputStream for application data as returned by
1218      * SSLSocket.getOutputStream().
1219      */
1220     private class AppOutputStream extends OutputStream {
1221         // One element array used to implement the write(byte) method
1222         private final byte[] oneByte = new byte[1];
1223 
1224         @Override
1225         public void write(int i) throws IOException {
1226             oneByte[0] = (byte)i;
1227             write(oneByte, 0, 1);
1228         }
1229 
1230         @Override
1231         public void write(byte[] b,
1232                 int off, int len) throws IOException {
1233             if (b == null) {
1234                 throw new NullPointerException(&quot;the source buffer is null&quot;);
1235             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
1236                 throw new IndexOutOfBoundsException(
1237                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
1238                         &quot;, bytes to read:&quot; + len);
1239             } else if (len == 0) {
1240                 //
1241                 // Don&#39;t bother to really write empty records.  We went this
1242                 // far to drive the handshake machinery, for correctness; not
1243                 // writing empty records improves performance by cutting CPU
1244                 // time and network resource usage.  However, some protocol
1245                 // implementations are fragile and don&#39;t like to see empty
1246                 // records, so this also increases robustness.
1247                 //
1248                 return;
1249             }
1250 
1251             // Start handshaking if the connection has not been negotiated.
1252             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
1253                     !conContext.isInboundClosed() &amp;&amp;
1254                     !conContext.isOutboundClosed()) {
1255                 ensureNegotiated();
1256             }
1257 
1258             // Check if the Socket is invalid (error or closed).
1259             if (!conContext.isNegotiated ||
1260                     conContext.isBroken || conContext.isOutboundClosed()) {
1261                 throw new SocketException(&quot;Connection or outbound has closed&quot;);
1262             }
1263 
1264             //
1265 
1266             // Delegate the writing to the underlying socket.
1267             try {
1268                 conContext.outputRecord.deliver(b, off, len);
1269             } catch (SSLHandshakeException she) {
1270                 // may be record sequence number overflow
1271                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
1272             } catch (SSLException ssle) {
1273                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, ssle);
1274             }   // re-throw other IOException, which should be caused by
1275                 // the underlying plain socket and could be handled by
1276                 // applications (for example, re-try the connection).
1277 
1278             // Is the sequence number is nearly overflow, or has the key usage
1279             // limit been reached?
1280             if (conContext.outputRecord.seqNumIsHuge() ||
1281                     conContext.outputRecord.writeCipher.atKeyLimit()) {
1282                 tryKeyUpdate();
1283             }
1284             // Check if NewSessionTicket PostHandshake message needs to be sent
1285             if (conContext.conSession.updateNST) {
1286                 conContext.conSession.updateNST = false;
1287                 tryNewSessionTicket();
1288             }
1289         }
1290 
1291         @Override
1292         public void close() throws IOException {
1293             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1294                 SSLLogger.finest(&quot;Closing output stream&quot;);
1295             }
1296 
1297             try {
1298                 SSLSocketImpl.this.close();
1299             } catch (IOException ioe) {
1300                 // ignore the exception
1301                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1302                     SSLLogger.warning(&quot;output stream close failed&quot;, ioe);
1303                 }
1304             }
1305         }
1306     }
1307 
1308     @Override
1309     public SSLParameters getSSLParameters() {
1310         socketLock.lock();
1311         try {
1312             return conContext.sslConfig.getSSLParameters();
1313         } finally {
1314             socketLock.unlock();
1315         }
1316     }
1317 
1318     @Override
1319     public void setSSLParameters(SSLParameters params) {
1320         socketLock.lock();
1321         try {
1322             conContext.sslConfig.setSSLParameters(params);
1323 
1324             if (conContext.sslConfig.maximumPacketSize != 0) {
1325                 conContext.outputRecord.changePacketSize(
1326                         conContext.sslConfig.maximumPacketSize);
1327             }
1328         } finally {
1329             socketLock.unlock();
1330         }
1331     }
1332 
1333     @Override
1334     public String getApplicationProtocol() {
1335         socketLock.lock();
1336         try {
1337             return conContext.applicationProtocol;
1338         } finally {
1339             socketLock.unlock();
1340         }
1341     }
1342 
1343     @Override
1344     public String getHandshakeApplicationProtocol() {
1345         socketLock.lock();
1346         try {
1347             if (conContext.handshakeContext != null) {
1348                 return conContext.handshakeContext.applicationProtocol;
1349             }
1350         } finally {
1351             socketLock.unlock();
1352         }
1353 
1354         return null;
1355     }
1356 
1357     @Override
1358     public void setHandshakeApplicationProtocolSelector(
1359             BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt; selector) {
1360         socketLock.lock();
1361         try {
1362             conContext.sslConfig.socketAPSelector = selector;
1363         } finally {
1364             socketLock.unlock();
1365         }
1366     }
1367 
1368     @Override
1369     public BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt;
1370             getHandshakeApplicationProtocolSelector() {
1371         socketLock.lock();
1372         try {
1373             return conContext.sslConfig.socketAPSelector;
1374         } finally {
1375             socketLock.unlock();
1376         }
1377     }
1378 
1379     /**
1380      * Read the initial handshake records.
1381      */
1382     private int readHandshakeRecord() throws IOException {
1383         while (!conContext.isInboundClosed()) {
1384             try {
1385                 Plaintext plainText = decode(null);
1386                 if ((plainText.contentType == ContentType.HANDSHAKE.id) &amp;&amp;
1387                         conContext.isNegotiated) {
1388                     return 0;
1389                 }
1390             } catch (SSLException ssle) {
1391                 throw ssle;
1392             } catch (InterruptedIOException iioe) {
1393                 // don&#39;t change exception in case of timeouts or interrupts
1394                 throw iioe;
1395             } catch (IOException ioe) {
1396                 throw new SSLException(&quot;readHandshakeRecord&quot;, ioe);
1397             }
1398         }
1399 
1400         return -1;
1401     }
1402 
1403     /**
1404      * Read application data record. Used by AppInputStream only, but defined
1405      * here so as to use the socket level synchronization.
1406      *
1407      * Note that the connection guarantees that handshake, alert, and change
1408      * cipher spec data streams are handled as they arrive, so we never see
1409      * them here.
1410      *
1411      * Note: Please be careful about the synchronization, and don&#39;t use this
1412      * method other than in the AppInputStream class!
1413      */
1414     private ByteBuffer readApplicationRecord(
1415             ByteBuffer buffer) throws IOException {
1416         while (!conContext.isInboundClosed()) {
1417             /*
1418              * clean the buffer and check if it is too small, e.g. because
1419              * the AppInputStream did not have the chance to see the
1420              * current packet length but rather something like that of the
1421              * handshake before. In that case we return 0 at this point to
1422              * give the caller the chance to adjust the buffer.
1423              */
1424             buffer.clear();
1425             int inLen = conContext.inputRecord.bytesInCompletePacket();
1426             if (inLen &lt; 0) {    // EOF
1427                 handleEOF(null);
1428 
1429                 // if no exception thrown
1430                 return null;
1431             }
1432 
1433             // Is this packet bigger than SSL/TLS normally allows?
1434             if (inLen &gt; SSLRecord.maxLargeRecordSize) {
1435                 throw new SSLProtocolException(
1436                         &quot;Illegal packet size: &quot; + inLen);
1437             }
1438 
1439             if (inLen &gt; buffer.remaining()) {
1440                 buffer = ByteBuffer.allocate(inLen);
1441             }
1442 
1443             try {
1444                 Plaintext plainText;
1445                 socketLock.lock();
1446                 try {
1447                     plainText = decode(buffer);
1448                 } finally {
1449                     socketLock.unlock();
1450                 }
1451                 if (plainText.contentType == ContentType.APPLICATION_DATA.id &amp;&amp;
1452                         buffer.position() &gt; 0) {
1453                     return buffer;
1454                 }
1455             } catch (SSLException ssle) {
1456                 throw ssle;
1457             } catch (InterruptedIOException iioe) {
1458                 // don&#39;t change exception in case of timeouts or interrupts
1459                 throw iioe;
1460             } catch (IOException ioe) {
1461                 if (!(ioe instanceof SSLException)) {
1462                     throw new SSLException(&quot;readApplicationRecord&quot;, ioe);
1463                 } else {
1464                     throw ioe;
1465                 }
1466             }
1467         }
1468 
1469         //
1470         // couldn&#39;t read, due to some kind of error
1471         //
1472         return null;
1473     }
1474 
1475     private Plaintext decode(ByteBuffer destination) throws IOException {
1476         Plaintext plainText;
1477         try {
1478             if (destination == null) {
1479                 plainText = SSLTransport.decode(conContext,
1480                         null, 0, 0, null, 0, 0);
1481             } else {
1482                 plainText = SSLTransport.decode(conContext,
1483                         null, 0, 0, new ByteBuffer[]{destination}, 0, 1);
1484             }
1485         } catch (EOFException eofe) {
1486             // EOFException is special as it is related to close_notify.
1487             plainText = handleEOF(eofe);
1488         }
1489 
1490         // Is the sequence number is nearly overflow?
1491         if (plainText != Plaintext.PLAINTEXT_NULL &amp;&amp;
1492                 (conContext.inputRecord.seqNumIsHuge() ||
1493                 conContext.inputRecord.readCipher.atKeyLimit())) {
1494             tryKeyUpdate();
1495         }
1496 
1497         return plainText;
1498     }
1499 
1500     /**
1501      * Try key update for sequence number wrap or key usage limit.
1502      *
1503      * Note that in order to maintain the handshake status properly, we check
1504      * the sequence number and key usage limit after the last record
1505      * reading/writing process.
1506      *
1507      * As we request renegotiation or close the connection for wrapped sequence
1508      * number when there is enough sequence number space left to handle a few
1509      * more records, so the sequence number of the last record cannot be
1510      * wrapped.
1511      */
1512     private void tryKeyUpdate() throws IOException {
1513         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
1514         // connection is not duplex-open.
1515         if ((conContext.handshakeContext == null) &amp;&amp;
1516                 !conContext.isOutboundClosed() &amp;&amp;
1517                 !conContext.isInboundClosed() &amp;&amp;
1518                 !conContext.isBroken) {
1519             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1520                 SSLLogger.finest(&quot;trigger key update&quot;);
1521             }
1522             startHandshake();
1523         }
1524     }
1525 
1526     // Try to generate a PostHandshake NewSessionTicket message.  This is
1527     // TLS 1.3 only.
1528     private void tryNewSessionTicket() throws IOException {
1529         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
1530         // connection is not duplex-open.
1531         if (!conContext.sslConfig.isClientMode &amp;&amp;
1532                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;
1533                 conContext.handshakeContext == null &amp;&amp;
1534                 !conContext.isOutboundClosed() &amp;&amp;
1535                 !conContext.isInboundClosed() &amp;&amp;
1536                 !conContext.isBroken) {
1537             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1538                 SSLLogger.finest(&quot;trigger new session ticket&quot;);
1539             }
1540             NewSessionTicket.t13PosthandshakeProducer.produce(
1541                     new PostHandshakeContext(conContext));
1542         }
1543     }
1544 
1545     /**
1546      * Initialize the handshaker and socket streams.
1547      *
1548      * Called by connect, the layered constructor, and SSLServerSocket.
1549      */
1550     void doneConnect() throws IOException {
1551         socketLock.lock();
1552         try {
1553             // In server mode, it is not necessary to set host and serverNames.
1554             // Otherwise, would require a reverse DNS lookup to get
1555             // the hostname.
1556             if (peerHost == null || peerHost.isEmpty()) {
1557                 boolean useNameService =
1558                         trustNameService &amp;&amp; conContext.sslConfig.isClientMode;
1559                 useImplicitHost(useNameService);
1560             } else {
1561                 conContext.sslConfig.serverNames =
1562                         Utilities.addToSNIServerNameList(
1563                                 conContext.sslConfig.serverNames, peerHost);
1564             }
1565 
1566             InputStream sockInput = super.getInputStream();
1567             conContext.inputRecord.setReceiverStream(sockInput);
1568 
1569             OutputStream sockOutput = super.getOutputStream();
1570             conContext.inputRecord.setDeliverStream(sockOutput);
1571             conContext.outputRecord.setDeliverStream(sockOutput);
1572 
1573             this.isConnected = true;
1574         } finally {
1575             socketLock.unlock();
1576         }
1577     }
1578 
1579     private void useImplicitHost(boolean useNameService) {
1580         // Note: If the local name service is not trustworthy, reverse
1581         // host name resolution should not be performed for endpoint
1582         // identification.  Use the application original specified
1583         // hostname or IP address instead.
1584 
1585         // Get the original hostname via jdk.internal.access.SharedSecrets
1586         InetAddress inetAddress = getInetAddress();
1587         if (inetAddress == null) {      // not connected
1588             return;
1589         }
1590 
1591         JavaNetInetAddressAccess jna =
1592                 SharedSecrets.getJavaNetInetAddressAccess();
1593         String originalHostname = jna.getOriginalHostName(inetAddress);
1594         if (originalHostname != null &amp;&amp; !originalHostname.isEmpty()) {
1595 
1596             this.peerHost = originalHostname;
1597             if (conContext.sslConfig.serverNames.isEmpty() &amp;&amp;
1598                     !conContext.sslConfig.noSniExtension) {
1599                 conContext.sslConfig.serverNames =
1600                         Utilities.addToSNIServerNameList(
1601                                 conContext.sslConfig.serverNames, peerHost);
1602             }
1603 
1604             return;
1605         }
1606 
1607         // No explicitly specified hostname, no server name indication.
1608         if (!useNameService) {
1609             // The local name service is not trustworthy, use IP address.
1610             this.peerHost = inetAddress.getHostAddress();
1611         } else {
1612             // Use the underlying reverse host name resolution service.
1613             this.peerHost = getInetAddress().getHostName();
1614         }
1615     }
1616 
1617     // ONLY used by HttpsClient to setup the URI specified hostname
1618     //
1619     // Please NOTE that this method MUST be called before calling to
1620     // SSLSocket.setSSLParameters(). Otherwise, the {@code host} parameter
1621     // may override SNIHostName in the customized server name indication.
1622     public void setHost(String host) {
1623         socketLock.lock();
1624         try {
1625             this.peerHost = host;
1626             this.conContext.sslConfig.serverNames =
1627                     Utilities.addToSNIServerNameList(
1628                             conContext.sslConfig.serverNames, host);
1629         } finally {
1630             socketLock.unlock();
1631         }
1632     }
1633 
1634     /**
1635      * Handle an exception.
1636      *
1637      * This method is called by top level exception handlers (in read(),
1638      * write()) to make sure we always shutdown the connection correctly
1639      * and do not pass runtime exception to the application.
1640      *
1641      * This method never returns normally, it always throws an IOException.
1642      */
1643     private void handleException(Exception cause) throws IOException {
1644         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1645             SSLLogger.warning(&quot;handling exception&quot;, cause);
1646         }
1647 
1648         // Don&#39;t close the Socket in case of timeouts or interrupts.
1649         if (cause instanceof InterruptedIOException) {
1650             throw (IOException)cause;
1651         }
1652 
1653         // need to perform error shutdown
1654         boolean isSSLException = (cause instanceof SSLException);
1655         Alert alert;
1656         if (isSSLException) {
1657             if (cause instanceof SSLHandshakeException) {
1658                 alert = Alert.HANDSHAKE_FAILURE;
1659             } else {
1660                 alert = Alert.UNEXPECTED_MESSAGE;
1661             }
1662         } else {
1663             if (cause instanceof IOException) {
1664                 alert = Alert.UNEXPECTED_MESSAGE;
1665             } else {
1666                 // RuntimeException
1667                 alert = Alert.INTERNAL_ERROR;
1668             }
1669         }
1670 
1671         throw conContext.fatal(alert, cause);
1672     }
1673 
1674     private Plaintext handleEOF(EOFException eofe) throws IOException {
1675         if (requireCloseNotify || conContext.handshakeContext != null) {
1676             SSLException ssle;
1677             if (conContext.handshakeContext != null) {
1678                 ssle = new SSLHandshakeException(
1679                         &quot;Remote host terminated the handshake&quot;);
1680             } else {
1681                 ssle = new SSLProtocolException(
1682                         &quot;Remote host terminated the connection&quot;);
1683             }
1684 
1685             if (eofe != null) {
1686                 ssle.initCause(eofe);
1687             }
1688             throw ssle;
1689         } else {
1690             // treat as if we had received a close_notify
1691             conContext.isInputCloseNotified = true;
1692             shutdownInput();
1693 
1694             return Plaintext.PLAINTEXT_NULL;
1695         }
1696     }
1697 
1698 
1699     @Override
1700     public String getPeerHost() {
1701         return peerHost;
1702     }
1703 
1704     @Override
1705     public int getPeerPort() {
1706         return getPort();
1707     }
1708 
1709     @Override
1710     public boolean useDelegatedTask() {
1711         return false;
1712     }
1713 
1714     @Override
1715     public void shutdown() throws IOException {
1716         if (!isClosed()) {
1717             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1718                 SSLLogger.fine(&quot;close the underlying socket&quot;);
1719             }
1720 
1721             try {
1722                 if (conContext.isInputCloseNotified) {
1723                     // Close the connection, no wait for more peer response.
1724                     closeSocket(false);
1725                 } else {
1726                     // Close the connection, may wait for peer close_notify.
1727                     closeSocket(true);
1728                 }
1729             } finally {
1730                 tlsIsClosed = true;
1731             }
1732         }
1733     }
1734 
1735     private void closeSocket(boolean selfInitiated) throws IOException {
1736         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1737             SSLLogger.fine(&quot;close the SSL connection &quot; +
1738                 (selfInitiated ? &quot;(initiative)&quot; : &quot;(passive)&quot;));
1739         }
1740 
1741         if (autoClose || !isLayered()) {
1742             super.close();
1743         } else if (selfInitiated) {
1744             if (!conContext.isInboundClosed() &amp;&amp; !isInputShutdown()) {
1745                 // wait for close_notify alert to clear input stream.
1746                 waitForClose();
1747             }
1748         }
1749     }
1750 
1751    /**
1752     * Wait for close_notify alert for a graceful closure.
1753     *
1754     * [RFC 5246] If the application protocol using TLS provides that any
1755     * data may be carried over the underlying transport after the TLS
1756     * connection is closed, the TLS implementation must receive the responding
1757     * close_notify alert before indicating to the application layer that
1758     * the TLS connection has ended.  If the application protocol will not
1759     * transfer any additional data, but will only close the underlying
1760     * transport connection, then the implementation MAY choose to close the
1761     * transport without waiting for the responding close_notify.
1762     */
1763     private void waitForClose() throws IOException {
1764         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1765             SSLLogger.fine(&quot;wait for close_notify or alert&quot;);
1766         }
1767 
1768         while (!conContext.isInboundClosed()) {
1769             try {
1770                 Plaintext plainText = decode(null);
1771                 // discard and continue
1772                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1773                     SSLLogger.finest(
1774                         &quot;discard plaintext while waiting for close&quot;, plainText);
1775                 }
1776             } catch (Exception e) {   // including RuntimeException
1777                 handleException(e);
1778             }
1779         }
1780     }
1781 }
    </pre>
  </body>
</html>
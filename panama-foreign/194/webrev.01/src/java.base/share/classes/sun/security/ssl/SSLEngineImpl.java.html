<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLEngineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.nio.ReadOnlyBufferException;
  31 import java.security.AccessController;
  32 import java.security.PrivilegedActionException;
  33 import java.security.PrivilegedExceptionAction;
  34 import java.util.List;
  35 import java.util.Map;
  36 import java.util.concurrent.locks.ReentrantLock;
  37 import java.util.function.BiFunction;
  38 import javax.net.ssl.SSLEngine;
  39 import javax.net.ssl.SSLEngineResult;
  40 import javax.net.ssl.SSLEngineResult.HandshakeStatus;
  41 import javax.net.ssl.SSLEngineResult.Status;
  42 import javax.net.ssl.SSLException;
  43 import javax.net.ssl.SSLHandshakeException;
  44 import javax.net.ssl.SSLKeyException;
  45 import javax.net.ssl.SSLParameters;
  46 import javax.net.ssl.SSLPeerUnverifiedException;
  47 import javax.net.ssl.SSLProtocolException;
  48 import javax.net.ssl.SSLSession;
  49 
  50 /**
  51  * Implementation of an non-blocking SSLEngine.
  52  *
  53  * @author Brad Wetmore
  54  */
  55 final class SSLEngineImpl extends SSLEngine implements SSLTransport {
  56     private final SSLContextImpl        sslContext;
  57     final TransportContext              conContext;
  58     private final ReentrantLock         engineLock = new ReentrantLock();
  59 
  60     /**
  61      * Constructor for an SSLEngine from SSLContext, without
  62      * host/port hints.
  63      *
  64      * This Engine will not be able to cache sessions, but must renegotiate
  65      * everything by hand.
  66      */
  67     SSLEngineImpl(SSLContextImpl sslContext) {
  68         this(sslContext, null, -1);
  69     }
  70 
  71     /**
  72      * Constructor for an SSLEngine from SSLContext.
  73      */
  74     SSLEngineImpl(SSLContextImpl sslContext,
  75             String host, int port) {
  76         super(host, port);
  77         this.sslContext = sslContext;
  78         HandshakeHash handshakeHash = new HandshakeHash();
  79         if (sslContext.isDTLS()) {
  80             this.conContext = new TransportContext(sslContext, this,
  81                     new DTLSInputRecord(handshakeHash),
  82                     new DTLSOutputRecord(handshakeHash));
  83         } else {
  84             this.conContext = new TransportContext(sslContext, this,
  85                     new SSLEngineInputRecord(handshakeHash),
  86                     new SSLEngineOutputRecord(handshakeHash));
  87         }
  88 
  89         // Server name indication is a connection scope extension.
  90         if (host != null) {
  91             this.conContext.sslConfig.serverNames =
  92                     Utilities.addToSNIServerNameList(
  93                             conContext.sslConfig.serverNames, host);
  94         }
  95     }
  96 
  97     @Override
  98     public void beginHandshake() throws SSLException {
  99         engineLock.lock();
 100         try {
 101             if (conContext.isUnsureMode) {
 102                 throw new IllegalStateException(
 103                         &quot;Client/Server mode has not yet been set.&quot;);
 104             }
 105 
 106             try {
 107                 conContext.kickstart();
 108             } catch (IOException ioe) {
 109                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 110                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
 111             } catch (Exception ex) {     // including RuntimeException
 112                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 113                     &quot;Fail to begin handshake&quot;, ex);
 114             }
 115         } finally {
 116             engineLock.unlock();
 117         }
 118     }
 119 
 120     @Override
 121     public SSLEngineResult wrap(ByteBuffer[] appData,
 122             int offset, int length, ByteBuffer netData) throws SSLException {
 123         return wrap(appData, offset, length, new ByteBuffer[]{ netData }, 0, 1);
 124     }
 125 
 126     // @Override
 127     public SSLEngineResult wrap(
 128         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 129         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 130 
 131         engineLock.lock();
 132         try {
 133             if (conContext.isUnsureMode) {
 134                 throw new IllegalStateException(
 135                         &quot;Client/Server mode has not yet been set.&quot;);
 136             }
 137 
 138             // See if the handshaker needs to report back some SSLException.
 139             checkTaskThrown();
 140 
 141             // check parameters
 142             checkParams(srcs, srcsOffset, srcsLength,
 143                     dsts, dstsOffset, dstsLength);
 144 
 145             try {
 146                 return writeRecord(
 147                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);
 148             } catch (SSLProtocolException spe) {
 149                 // may be an unexpected handshake message
 150                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, spe);
 151             } catch (IOException ioe) {
 152                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 153                     &quot;problem wrapping app data&quot;, ioe);
 154             } catch (Exception ex) {     // including RuntimeException
 155                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 156                     &quot;Fail to wrap application data&quot;, ex);
 157             }
 158         } finally {
 159             engineLock.unlock();
 160         }
 161     }
 162 
 163     private SSLEngineResult writeRecord(
 164         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 165         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 166 
 167         // See note on TransportContext.needHandshakeFinishedStatus.
 168         if (conContext.needHandshakeFinishedStatus) {
 169             conContext.needHandshakeFinishedStatus = false;
 170             return new SSLEngineResult(
 171                     Status.OK, HandshakeStatus.FINISHED, 0, 0);
 172         }
 173 
 174         // May need to deliver cached records.
 175         if (isOutboundDone()) {
 176             return new SSLEngineResult(
 177                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 178         }
 179 
 180         HandshakeContext hc = conContext.handshakeContext;
 181         HandshakeStatus hsStatus = null;
 182         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 183                 !conContext.isInboundClosed() &amp;&amp;
 184                 !conContext.isOutboundClosed()) {
 185             conContext.kickstart();
 186 
 187             hsStatus = getHandshakeStatus();
 188             if (hsStatus == HandshakeStatus.NEED_UNWRAP) {
 189                 /*
 190                  * For DTLS, if the handshake state is
 191                  * HandshakeStatus.NEED_UNWRAP, a call to SSLEngine.wrap()
 192                  * means that the previous handshake packets (if delivered)
 193                  * get lost, and need retransmit the handshake messages.
 194                  */
 195                 if (!sslContext.isDTLS() || hc == null ||
 196                         !hc.sslConfig.enableRetransmissions ||
 197                         conContext.outputRecord.firstMessage) {
 198 
 199                     return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 200                 }   // otherwise, need retransmission
 201             }
 202         }
 203 
 204         if (hsStatus == null) {
 205             hsStatus = getHandshakeStatus();
 206         }
 207 
 208         /*
 209          * If we have a task outstanding, this *MUST* be done before
 210          * doing any more wrapping, because we could be in the middle
 211          * of receiving a handshake message, for example, a finished
 212          * message which would change the ciphers.
 213          */
 214         if (hsStatus == HandshakeStatus.NEED_TASK) {
 215             return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 216         }
 217 
 218         int dstsRemains = 0;
 219         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 220             dstsRemains += dsts[i].remaining();
 221         }
 222 
 223         // Check destination buffer size.
 224         //
 225         // We can be smarter about using smaller buffer sizes later.  For
 226         // now, force it to be large enough to handle any valid record.
 227         if (dstsRemains &lt; conContext.conSession.getPacketBufferSize()) {
 228             return new SSLEngineResult(
 229                 Status.BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);
 230         }
 231 
 232         int srcsRemains = 0;
 233         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 234             srcsRemains += srcs[i].remaining();
 235         }
 236 
 237         Ciphertext ciphertext = null;
 238         try {
 239             // Acquire the buffered to-be-delivered records or retransmissions.
 240             //
 241             // May have buffered records, or need retransmission if handshaking.
 242             if (!conContext.outputRecord.isEmpty() || (hc != null &amp;&amp;
 243                     hc.sslConfig.enableRetransmissions &amp;&amp;
 244                     hc.sslContext.isDTLS() &amp;&amp;
 245                     hsStatus == HandshakeStatus.NEED_UNWRAP)) {
 246                 ciphertext = encode(null, 0, 0,
 247                         dsts, dstsOffset, dstsLength);
 248             }
 249 
 250             if (ciphertext == null &amp;&amp; srcsRemains != 0) {
 251                 ciphertext = encode(srcs, srcsOffset, srcsLength,
 252                         dsts, dstsOffset, dstsLength);
 253             }
 254         } catch (IOException ioe) {
 255             if (ioe instanceof SSLException) {
 256                 throw ioe;
 257             } else {
 258                 throw new SSLException(&quot;Write problems&quot;, ioe);
 259             }
 260         }
 261 
 262         /*
 263          * Check for status.
 264          */
 265         Status status = (isOutboundDone() ? Status.CLOSED : Status.OK);
 266         if (ciphertext != null &amp;&amp; ciphertext.handshakeStatus != null) {
 267             hsStatus = ciphertext.handshakeStatus;
 268         } else {
 269             hsStatus = getHandshakeStatus();
 270             if (ciphertext == null &amp;&amp; !conContext.isNegotiated &amp;&amp;
 271                     conContext.isInboundClosed() &amp;&amp;
 272                     hsStatus == HandshakeStatus.NEED_WRAP) {
 273                 // Even the outboud is open, no futher data could be wrapped as:
 274                 //     1. the outbound is empty
 275                 //     2. no negotiated connection
 276                 //     3. the inbound has closed, cannot complete the handshake
 277                 //
 278                 // Mark the engine as closed if the handshake status is
 279                 // NEED_WRAP. Otherwise, it could lead to dead loops in
 280                 // applications.
 281                 status = Status.CLOSED;
 282             }
 283         }
 284 
 285         int deltaSrcs = srcsRemains;
 286         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 287             deltaSrcs -= srcs[i].remaining();
 288         }
 289 
 290         int deltaDsts = dstsRemains;
 291         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 292             deltaDsts -= dsts[i].remaining();
 293         }
 294 
 295         return new SSLEngineResult(status, hsStatus, deltaSrcs, deltaDsts,
 296                 ciphertext != null ? ciphertext.recordSN : -1L);
 297     }
 298 
 299     private Ciphertext encode(
 300         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 301         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 302 
 303         Ciphertext ciphertext = null;
 304         try {
 305             ciphertext = conContext.outputRecord.encode(
 306                 srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);
 307         } catch (SSLHandshakeException she) {
 308             // may be record sequence number overflow
 309             throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
 310         } catch (IOException e) {
 311             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, e);
 312         }
 313 
 314         if (ciphertext == null) {
 315             return null;
 316         }
 317 
 318         // Is the handshake completed?
 319         boolean needRetransmission =
 320                 conContext.sslContext.isDTLS() &amp;&amp;
 321                 conContext.handshakeContext != null &amp;&amp;
 322                 conContext.handshakeContext.sslConfig.enableRetransmissions;
 323         HandshakeStatus hsStatus =
 324                 tryToFinishHandshake(ciphertext.contentType);
 325         if (needRetransmission &amp;&amp;
 326                 hsStatus == HandshakeStatus.FINISHED &amp;&amp;
 327                 conContext.sslContext.isDTLS() &amp;&amp;
 328                 ciphertext.handshakeType == SSLHandshake.FINISHED.id) {
 329             // Retransmit the last flight for DTLS.
 330             //
 331             // The application data transactions may begin immediately
 332             // after the last flight.  If the last flight get lost, the
 333             // application data may be discarded accordingly.  As could
 334             // be an issue for some applications.  This impact can be
 335             // mitigated by sending the last fligth twice.
 336             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
 337                 SSLLogger.finest(&quot;retransmit the last flight messages&quot;);
 338             }
 339 
 340             conContext.outputRecord.launchRetransmission();
 341             hsStatus = HandshakeStatus.NEED_WRAP;
 342         }
 343 
 344         if (hsStatus == null) {
 345             hsStatus = conContext.getHandshakeStatus();
 346         }
 347 
 348         // Is the sequence number is nearly overflow?
 349         if (conContext.outputRecord.seqNumIsHuge() ||
 350                 conContext.outputRecord.writeCipher.atKeyLimit()) {
 351             hsStatus = tryKeyUpdate(hsStatus);
 352         }
 353 
 354         // Check if NewSessionTicket PostHandshake message needs to be sent
 355         if (conContext.conSession.updateNST &amp;&amp;
 356                 !conContext.sslConfig.isClientMode) {
 357             hsStatus = tryNewSessionTicket(hsStatus);
 358         }
 359 
 360         // update context status
 361         ciphertext.handshakeStatus = hsStatus;
 362 
 363         return ciphertext;
 364     }
 365 
 366     private HandshakeStatus tryToFinishHandshake(byte contentType) {
 367         HandshakeStatus hsStatus = null;
 368         if ((contentType == ContentType.HANDSHAKE.id) &amp;&amp;
 369                 conContext.outputRecord.isEmpty()) {
 370             if (conContext.handshakeContext == null) {
 371                 hsStatus = HandshakeStatus.FINISHED;
 372             } else if (conContext.isPostHandshakeContext()) {
 373                 // unlikely, but just in case.
 374                 hsStatus = conContext.finishPostHandshake();
 375             } else if (conContext.handshakeContext.handshakeFinished) {
 376                 hsStatus = conContext.finishHandshake();
 377             }
 378         }   // Otherwise, the followed call to getHSStatus() will help.
 379 
 380         return hsStatus;
 381     }
 382 
 383     /**
 384      * Try key update for sequence number wrap or key usage limit.
 385      *
 386      * Note that in order to maintain the handshake status properly, we check
 387      * the sequence number and key usage limit after the last record
 388      * reading/writing process.
 389      *
 390      * As we request renegotiation or close the connection for wrapped sequence
 391      * number when there is enough sequence number space left to handle a few
 392      * more records, so the sequence number of the last record cannot be
 393      * wrapped.
 394      */
 395     private HandshakeStatus tryKeyUpdate(
 396             HandshakeStatus currentHandshakeStatus) throws IOException {
 397         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
 398         // connection is not duplex-open.
 399         if ((conContext.handshakeContext == null) &amp;&amp;
 400                 !conContext.isOutboundClosed() &amp;&amp;
 401                 !conContext.isInboundClosed() &amp;&amp;
 402                 !conContext.isBroken) {
 403             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 404                 SSLLogger.finest(&quot;trigger key update&quot;);
 405             }
 406             beginHandshake();
 407             return conContext.getHandshakeStatus();
 408         }
 409 
 410         return currentHandshakeStatus;
 411     }
 412 
 413     // Try to generate a PostHandshake NewSessionTicket message.  This is
 414     // TLS 1.3 only.
 415     private HandshakeStatus tryNewSessionTicket(
 416             HandshakeStatus currentHandshakeStatus) throws IOException {
 417         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
 418         // connection is not duplex-open.
 419         if ((conContext.handshakeContext == null) &amp;&amp;
 420                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;
 421                 !conContext.isOutboundClosed() &amp;&amp;
 422                 !conContext.isInboundClosed() &amp;&amp;
 423                 !conContext.isBroken) {
 424             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 425                 SSLLogger.finest(&quot;trigger NST&quot;);
 426             }
 427             conContext.conSession.updateNST = false;
 428             NewSessionTicket.t13PosthandshakeProducer.produce(
 429                     new PostHandshakeContext(conContext));
 430             return conContext.getHandshakeStatus();
 431         }
 432 
 433         return currentHandshakeStatus;
 434     }
 435 
 436     private static void checkParams(
 437             ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 438             ByteBuffer[] dsts, int dstsOffset, int dstsLength) {
 439 
 440         if ((srcs == null) || (dsts == null)) {
 441             throw new IllegalArgumentException(
 442                     &quot;source or destination buffer is null&quot;);
 443         }
 444 
 445         if ((dstsOffset &lt; 0) || (dstsLength &lt; 0) ||
 446                 (dstsOffset &gt; dsts.length - dstsLength)) {
 447             throw new IndexOutOfBoundsException(
 448                     &quot;index out of bound of the destination buffers&quot;);
 449         }
 450 
 451         if ((srcsOffset &lt; 0) || (srcsLength &lt; 0) ||
 452                 (srcsOffset &gt; srcs.length - srcsLength)) {
 453             throw new IndexOutOfBoundsException(
 454                     &quot;index out of bound of the source buffers&quot;);
 455         }
 456 
 457         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 458             if (dsts[i] == null) {
 459                 throw new IllegalArgumentException(
 460                         &quot;destination buffer[&quot; + i + &quot;] == null&quot;);
 461             }
 462 
 463             /*
 464              * Make sure the destination bufffers are writable.
 465              */
 466             if (dsts[i].isReadOnly()) {
 467                 throw new ReadOnlyBufferException();
 468             }
 469         }
 470 
 471         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 472             if (srcs[i] == null) {
 473                 throw new IllegalArgumentException(
 474                         &quot;source buffer[&quot; + i + &quot;] == null&quot;);
 475             }
 476         }
 477     }
 478 
 479     @Override
 480     public SSLEngineResult unwrap(ByteBuffer src,
 481             ByteBuffer[] dsts, int offset, int length) throws SSLException {
 482         return unwrap(
 483                 new ByteBuffer[]{src}, 0, 1, dsts, offset, length);
 484     }
 485 
 486     // @Override
 487     public SSLEngineResult unwrap(
 488         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 489         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 490 
 491         engineLock.lock();
 492         try {
 493             if (conContext.isUnsureMode) {
 494                 throw new IllegalStateException(
 495                         &quot;Client/Server mode has not yet been set.&quot;);
 496             }
 497 
 498             // See if the handshaker needs to report back some SSLException.
 499             checkTaskThrown();
 500 
 501             // check parameters
 502             checkParams(srcs, srcsOffset, srcsLength,
 503                     dsts, dstsOffset, dstsLength);
 504 
 505             try {
 506                 return readRecord(
 507                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);
 508             } catch (SSLProtocolException spe) {
 509                 // may be an unexpected handshake message
 510                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 511                         spe.getMessage(), spe);
 512             } catch (IOException ioe) {
 513                 /*
 514                  * Don&#39;t reset position so it looks like we didn&#39;t
 515                  * consume anything.  We did consume something, and it
 516                  * got us into this situation, so report that much back.
 517                  * Our days of consuming are now over anyway.
 518                  */
 519                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 520                         &quot;problem unwrapping net record&quot;, ioe);
 521             } catch (Exception ex) {     // including RuntimeException
 522                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 523                     &quot;Fail to unwrap network record&quot;, ex);
 524             }
 525         } finally {
 526             engineLock.unlock();
 527         }
 528     }
 529 
 530     private SSLEngineResult readRecord(
 531         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 532         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 533 
 534         /*
 535          * Check if we are closing/closed.
 536          */
 537         if (isInboundDone()) {
 538             return new SSLEngineResult(
 539                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 540         }
 541 
 542         HandshakeStatus hsStatus = null;
 543         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 544                 !conContext.isInboundClosed() &amp;&amp;
 545                 !conContext.isOutboundClosed()) {
 546             conContext.kickstart();
 547 
 548             /*
 549              * If there&#39;s still outbound data to flush, we
 550              * can return without trying to unwrap anything.
 551              */
 552             hsStatus = getHandshakeStatus();
 553             if (hsStatus == HandshakeStatus.NEED_WRAP) {
 554                 return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 555             }
 556         }
 557 
 558         if (hsStatus == null) {
 559             hsStatus = getHandshakeStatus();
 560         }
 561 
 562         /*
 563          * If we have a task outstanding, this *MUST* be done before
 564          * doing any more unwrapping, because we could be in the middle
 565          * of receiving a handshake message, for example, a finished
 566          * message which would change the ciphers.
 567          */
 568         if (hsStatus == HandshakeStatus.NEED_TASK) {
 569             return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 570         }
 571 
 572         if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {
 573             Plaintext plainText = null;
 574             try {
 575                 plainText = decode(null, 0, 0,
 576                         dsts, dstsOffset, dstsLength);
 577             } catch (IOException ioe) {
 578                 if (ioe instanceof SSLException) {
 579                     throw ioe;
 580                 } else {
 581                     throw new SSLException(&quot;readRecord&quot;, ioe);
 582                 }
 583             }
 584 
 585             Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 586             if (plainText.handshakeStatus != null) {
 587                 hsStatus = plainText.handshakeStatus;
 588             } else {
 589                 hsStatus = getHandshakeStatus();
 590             }
 591 
 592             return new SSLEngineResult(
 593                     status, hsStatus, 0, 0, plainText.recordSN);
 594         }
 595 
 596         int srcsRemains = 0;
 597         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 598             srcsRemains += srcs[i].remaining();
 599         }
 600 
 601         if (srcsRemains == 0) {
 602             return new SSLEngineResult(
 603                 Status.BUFFER_UNDERFLOW, hsStatus, 0, 0);
 604         }
 605 
 606         /*
 607          * Check the packet to make sure enough is here.
 608          * This will also indirectly check for 0 len packets.
 609          */
 610         int packetLen = 0;
 611         try {
 612             packetLen = conContext.inputRecord.bytesInCompletePacket(
 613                     srcs, srcsOffset, srcsLength);
 614         } catch (SSLException ssle) {
 615             // Need to discard invalid records for DTLS protocols.
 616             if (sslContext.isDTLS()) {
 617                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
 618                     SSLLogger.finest(&quot;Discard invalid DTLS records&quot;, ssle);
 619                 }
 620 
 621                 // invalid, discard the entire data [section 4.1.2.7, RFC 6347]
 622                 int deltaNet = 0;
 623                 // int deltaNet = netData.remaining();
 624                 // netData.position(netData.limit());
 625 
 626                 Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 627                 if (hsStatus == null) {
 628                     hsStatus = getHandshakeStatus();
 629                 }
 630 
 631                 return new SSLEngineResult(status, hsStatus, deltaNet, 0, -1L);
 632             } else {
 633                 throw ssle;
 634             }
 635         }
 636 
 637         // Is this packet bigger than SSL/TLS normally allows?
 638         if (packetLen &gt; conContext.conSession.getPacketBufferSize()) {
 639             int largestRecordSize = sslContext.isDTLS() ?
 640                     DTLSRecord.maxRecordSize : SSLRecord.maxLargeRecordSize;
 641             if ((packetLen &lt;= largestRecordSize) &amp;&amp; !sslContext.isDTLS()) {
 642                 // Expand the expected maximum packet/application buffer
 643                 // sizes.
 644                 //
 645                 // Only apply to SSL/TLS protocols.
 646 
 647                 // Old behavior: shall we honor the System Property
 648                 // &quot;jsse.SSLEngine.acceptLargeFragments&quot; if it is &quot;false&quot;?
 649                 conContext.conSession.expandBufferSizes();
 650             }
 651 
 652             // check the packet again
 653             largestRecordSize = conContext.conSession.getPacketBufferSize();
 654             if (packetLen &gt; largestRecordSize) {
 655                 throw new SSLProtocolException(
 656                         &quot;Input record too big: max = &quot; +
 657                         largestRecordSize + &quot; len = &quot; + packetLen);
 658             }
 659         }
 660 
 661         /*
 662          * Check for OVERFLOW.
 663          *
 664          * Delay enforcing the application buffer free space requirement
 665          * until after the initial handshaking.
 666          */
 667         int dstsRemains = 0;
 668         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 669             dstsRemains += dsts[i].remaining();
 670         }
 671 
 672         if (conContext.isNegotiated) {
 673             int FragLen =
 674                     conContext.inputRecord.estimateFragmentSize(packetLen);
 675             if (FragLen &gt; dstsRemains) {
 676                 return new SSLEngineResult(
 677                         Status.BUFFER_OVERFLOW, hsStatus, 0, 0);
 678             }
 679         }
 680 
 681         // check for UNDERFLOW.
 682         if ((packetLen == -1) || (srcsRemains &lt; packetLen)) {
 683             return new SSLEngineResult(Status.BUFFER_UNDERFLOW, hsStatus, 0, 0);
 684         }
 685 
 686         /*
 687          * We&#39;re now ready to actually do the read.
 688          */
 689         Plaintext plainText = null;
 690         try {
 691             plainText = decode(srcs, srcsOffset, srcsLength,
 692                             dsts, dstsOffset, dstsLength);
 693         } catch (IOException ioe) {
 694             if (ioe instanceof SSLException) {
 695                 throw ioe;
 696             } else {
 697                 throw new SSLException(&quot;readRecord&quot;, ioe);
 698             }
 699         }
 700 
 701         /*
 702          * Check the various condition that we could be reporting.
 703          *
 704          * It&#39;s *possible* something might have happened between the
 705          * above and now, but it was better to minimally lock &quot;this&quot;
 706          * during the read process.  We&#39;ll return the current
 707          * status, which is more representative of the current state.
 708          *
 709          * status above should cover:  FINISHED, NEED_TASK
 710          */
 711         Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 712         if (plainText.handshakeStatus != null) {
 713             hsStatus = plainText.handshakeStatus;
 714         } else {
 715             hsStatus = getHandshakeStatus();
 716         }
 717 
 718         int deltaNet = srcsRemains;
 719         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 720             deltaNet -= srcs[i].remaining();
 721         }
 722 
 723         int deltaApp = dstsRemains;
 724         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 725             deltaApp -= dsts[i].remaining();
 726         }
 727 
 728         return new SSLEngineResult(
 729                 status, hsStatus, deltaNet, deltaApp, plainText.recordSN);
 730     }
 731 
 732     private Plaintext decode(
 733         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 734         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 735 
 736         Plaintext pt = SSLTransport.decode(conContext,
 737                             srcs, srcsOffset, srcsLength,
 738                             dsts, dstsOffset, dstsLength);
 739 
 740         // Is the handshake completed?
 741         if (pt != Plaintext.PLAINTEXT_NULL) {
 742             HandshakeStatus hsStatus = tryToFinishHandshake(pt.contentType);
 743             if (hsStatus == null) {
 744                 pt.handshakeStatus = conContext.getHandshakeStatus();
 745             } else {
 746                 pt.handshakeStatus = hsStatus;
 747             }
 748 
 749             // Is the sequence number is nearly overflow?
 750             if (conContext.inputRecord.seqNumIsHuge() ||
 751                     conContext.inputRecord.readCipher.atKeyLimit()) {
 752                 pt.handshakeStatus =
 753                         tryKeyUpdate(pt.handshakeStatus);
 754             }
 755         }
 756 
 757         return pt;
 758     }
 759 
 760     @Override
 761     public Runnable getDelegatedTask() {
 762         engineLock.lock();
 763         try {
 764             if (conContext.handshakeContext != null &amp;&amp; // PRE or POST handshake
 765                     !conContext.handshakeContext.taskDelegated &amp;&amp;
 766                     !conContext.handshakeContext.delegatedActions.isEmpty()) {
 767                 conContext.handshakeContext.taskDelegated = true;
 768                 return new DelegatedTask(this);
 769             }
 770         } finally {
 771             engineLock.unlock();
 772         }
 773 
 774         return null;
 775     }
 776 
 777     @Override
 778     public void closeInbound() throws SSLException {
 779         engineLock.lock();
 780         try {
 781             if (isInboundDone()) {
 782                 return;
 783             }
 784 
 785             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 786                 SSLLogger.finest(&quot;Closing inbound of SSLEngine&quot;);
 787             }
 788 
 789             // Is it ready to close inbound?
 790             //
 791             // No exception if the initial handshake is not started.
 792             if (!conContext.isInputCloseNotified &amp;&amp;
 793                 (conContext.isNegotiated ||
 794                     conContext.handshakeContext != null)) {
 795 
 796                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 797                         &quot;closing inbound before receiving peer&#39;s close_notify&quot;);
 798             }
 799 
 800             conContext.closeInbound();
 801         } finally {
 802             engineLock.unlock();
 803         }
 804     }
 805 
 806     @Override
 807     public boolean isInboundDone() {
 808         engineLock.lock();
 809         try {
 810             return conContext.isInboundClosed();
 811         } finally {
 812             engineLock.unlock();
 813         }
 814     }
 815 
 816     @Override
 817     public void closeOutbound() {
 818         engineLock.lock();
 819         try {
 820             if (conContext.isOutboundClosed()) {
 821                 return;
 822             }
 823 
 824             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 825                 SSLLogger.finest(&quot;Closing outbound of SSLEngine&quot;);
 826             }
 827 
 828             conContext.closeOutbound();
 829         } finally {
 830             engineLock.unlock();
 831         }
 832     }
 833 
 834     @Override
 835     public boolean isOutboundDone() {
 836         engineLock.lock();
 837         try {
 838             return conContext.isOutboundDone();
 839         } finally {
 840             engineLock.unlock();
 841         }
 842     }
 843 
 844     @Override
 845     public String[] getSupportedCipherSuites() {
 846         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 847     }
 848 
 849     @Override
 850     public String[] getEnabledCipherSuites() {
 851         engineLock.lock();
 852         try {
 853             return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);
 854         } finally {
 855             engineLock.unlock();
 856         }
 857     }
 858 
 859     @Override
 860     public void setEnabledCipherSuites(String[] suites) {
 861         engineLock.lock();
 862         try {
 863             conContext.sslConfig.enabledCipherSuites =
 864                     CipherSuite.validValuesOf(suites);
 865         } finally {
 866             engineLock.unlock();
 867         }
 868     }
 869 
 870     @Override
 871     public String[] getSupportedProtocols() {
 872         return ProtocolVersion.toStringArray(
 873                 sslContext.getSupportedProtocolVersions());
 874     }
 875 
 876     @Override
 877     public String[] getEnabledProtocols() {
 878         engineLock.lock();
 879         try {
 880             return ProtocolVersion.toStringArray(
 881                     conContext.sslConfig.enabledProtocols);
 882         } finally {
 883             engineLock.unlock();
 884         }
 885     }
 886 
 887     @Override
 888     public void setEnabledProtocols(String[] protocols) {
 889         engineLock.lock();
 890         try {
 891             if (protocols == null) {
 892                 throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
 893             }
 894 
 895             conContext.sslConfig.enabledProtocols =
 896                     ProtocolVersion.namesOf(protocols);
 897         } finally {
 898             engineLock.unlock();
 899         }
 900     }
 901 
 902     @Override
 903     public SSLSession getSession() {
 904         engineLock.lock();
 905         try {
 906             return conContext.conSession;
 907         } finally {
 908             engineLock.unlock();
 909         }
 910     }
 911 
 912     @Override
 913     public SSLSession getHandshakeSession() {
 914         engineLock.lock();
 915         try {
 916             return conContext.handshakeContext == null ?
 917                     null : conContext.handshakeContext.handshakeSession;
 918         } finally {
 919             engineLock.unlock();
 920         }
 921     }
 922 
 923     @Override
 924     public SSLEngineResult.HandshakeStatus getHandshakeStatus() {
 925         engineLock.lock();
 926         try {
 927             return conContext.getHandshakeStatus();
 928         } finally {
 929             engineLock.unlock();
 930         }
 931     }
 932 
 933     @Override
 934     public void setUseClientMode(boolean mode) {
 935         engineLock.lock();
 936         try {
 937             conContext.setUseClientMode(mode);
 938         } finally {
 939             engineLock.unlock();
 940         }
 941     }
 942 
 943     @Override
 944     public boolean getUseClientMode() {
 945         engineLock.lock();
 946         try {
 947             return conContext.sslConfig.isClientMode;
 948         } finally {
 949             engineLock.unlock();
 950         }
 951     }
 952 
 953     @Override
 954     public void setNeedClientAuth(boolean need) {
 955         engineLock.lock();
 956         try {
 957             conContext.sslConfig.clientAuthType =
 958                     (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :
 959                             ClientAuthType.CLIENT_AUTH_NONE);
 960         } finally {
 961             engineLock.unlock();
 962         }
 963     }
 964 
 965     @Override
 966     public boolean getNeedClientAuth() {
 967         engineLock.lock();
 968         try {
 969             return (conContext.sslConfig.clientAuthType ==
 970                             ClientAuthType.CLIENT_AUTH_REQUIRED);
 971         } finally {
 972             engineLock.unlock();
 973         }
 974     }
 975 
 976     @Override
 977     public void setWantClientAuth(boolean want) {
 978         engineLock.lock();
 979         try {
 980             conContext.sslConfig.clientAuthType =
 981                     (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :
 982                             ClientAuthType.CLIENT_AUTH_NONE);
 983         } finally {
 984             engineLock.unlock();
 985         }
 986     }
 987 
 988     @Override
 989     public boolean getWantClientAuth() {
 990         engineLock.lock();
 991         try {
 992             return (conContext.sslConfig.clientAuthType ==
 993                             ClientAuthType.CLIENT_AUTH_REQUESTED);
 994         } finally {
 995             engineLock.unlock();
 996         }
 997     }
 998 
 999     @Override
1000     public void setEnableSessionCreation(boolean flag) {
1001         engineLock.lock();
1002         try {
1003             conContext.sslConfig.enableSessionCreation = flag;
1004         } finally {
1005             engineLock.unlock();
1006         }
1007     }
1008 
1009     @Override
1010     public boolean getEnableSessionCreation() {
1011         engineLock.lock();
1012         try {
1013             return conContext.sslConfig.enableSessionCreation;
1014         } finally {
1015             engineLock.unlock();
1016         }
1017     }
1018 
1019     @Override
1020     public SSLParameters getSSLParameters() {
1021         engineLock.lock();
1022         try {
1023             return conContext.sslConfig.getSSLParameters();
1024         } finally {
1025             engineLock.unlock();
1026         }
1027    }
1028 
1029     @Override
1030     public void setSSLParameters(SSLParameters params) {
1031         engineLock.lock();
1032         try {
1033             conContext.sslConfig.setSSLParameters(params);
1034 
1035             if (conContext.sslConfig.maximumPacketSize != 0) {
1036                 conContext.outputRecord.changePacketSize(
1037                         conContext.sslConfig.maximumPacketSize);
1038             }
1039         } finally {
1040             engineLock.unlock();
1041         }
1042    }
1043 
1044     @Override
1045     public String getApplicationProtocol() {
1046         engineLock.lock();
1047         try {
1048             return conContext.applicationProtocol;
1049         } finally {
1050             engineLock.unlock();
1051         }
1052     }
1053 
1054     @Override
1055     public String getHandshakeApplicationProtocol() {
1056         engineLock.lock();
1057         try {
1058             return conContext.handshakeContext == null ?
1059                     null : conContext.handshakeContext.applicationProtocol;
1060         } finally {
1061             engineLock.unlock();
1062         }
1063     }
1064 
1065     @Override
1066     public void setHandshakeApplicationProtocolSelector(
1067             BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt; selector) {
1068         engineLock.lock();
1069         try {
1070             conContext.sslConfig.engineAPSelector = selector;
1071         } finally {
1072             engineLock.unlock();
1073         }
1074     }
1075 
1076     @Override
1077     public BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt;
1078             getHandshakeApplicationProtocolSelector() {
1079         engineLock.lock();
1080         try {
1081             return conContext.sslConfig.engineAPSelector;
1082         } finally {
1083             engineLock.unlock();
1084         }
1085     }
1086 
1087     @Override
1088     public boolean useDelegatedTask() {
1089         return true;
1090     }
1091 
1092     /*
1093      * Depending on whether the error was just a warning and the
1094      * handshaker wasn&#39;t closed, or fatal and the handshaker is now
1095      * null, report back the Exception that happened in the delegated
1096      * task(s).
1097      */
1098     private void checkTaskThrown() throws SSLException {
1099 
1100         Exception exc = null;
1101         engineLock.lock();
1102         try {
1103             // First check the handshake context.
1104             HandshakeContext hc = conContext.handshakeContext;
1105             if ((hc != null) &amp;&amp; (hc.delegatedThrown != null)) {
1106                 exc = hc.delegatedThrown;
1107                 hc.delegatedThrown = null;
1108             }
1109 
1110             /*
1111              * hc.delegatedThrown and conContext.delegatedThrown are most
1112              * likely the same, but it&#39;s possible we could have had a non-fatal
1113              * exception and thus the new HandshakeContext is still valid
1114              * (alert warning).  If so, then we may have a secondary exception
1115              * waiting to be reported from the TransportContext, so we will
1116              * need to clear that on a successive call. Otherwise, clear it now.
1117              */
1118             if (conContext.delegatedThrown != null) {
1119                 if (exc != null) {
1120                     // hc object comparison
1121                     if (conContext.delegatedThrown == exc) {
1122                         // clear if/only if both are the same
1123                         conContext.delegatedThrown = null;
1124                     } // otherwise report the hc delegatedThrown
1125                 } else {
1126                     // Nothing waiting in HandshakeContext, but one is in the
1127                     // TransportContext.
1128                     exc = conContext.delegatedThrown;
1129                     conContext.delegatedThrown = null;
1130                 }
1131             }
1132         } finally {
1133             engineLock.unlock();
1134         }
1135 
1136         // Anything to report?
1137         if (exc == null) {
1138             return;
1139         }
1140 
1141         // If it wasn&#39;t a RuntimeException/SSLException, need to wrap it.
1142         if (exc instanceof SSLException) {
1143             throw (SSLException)exc;
1144         } else if (exc instanceof RuntimeException) {
1145             throw (RuntimeException)exc;
1146         } else {
1147             throw getTaskThrown(exc);
1148         }
1149     }
1150 
1151     private static SSLException getTaskThrown(Exception taskThrown) {
1152         String msg = taskThrown.getMessage();
1153 
1154         if (msg == null) {
1155             msg = &quot;Delegated task threw Exception or Error&quot;;
1156         }
1157 
1158         if (taskThrown instanceof RuntimeException) {
1159             throw new RuntimeException(msg, taskThrown);
1160         } else if (taskThrown instanceof SSLHandshakeException) {
1161             return (SSLHandshakeException)
1162                 new SSLHandshakeException(msg).initCause(taskThrown);
1163         } else if (taskThrown instanceof SSLKeyException) {
1164             return (SSLKeyException)
1165                 new SSLKeyException(msg).initCause(taskThrown);
1166         } else if (taskThrown instanceof SSLPeerUnverifiedException) {
1167             return (SSLPeerUnverifiedException)
1168                 new SSLPeerUnverifiedException(msg).initCause(taskThrown);
1169         } else if (taskThrown instanceof SSLProtocolException) {
1170             return (SSLProtocolException)
1171                 new SSLProtocolException(msg).initCause(taskThrown);
1172         } else if (taskThrown instanceof SSLException) {
1173             return (SSLException)taskThrown;
1174         } else {
1175             return new SSLException(msg, taskThrown);
1176         }
1177     }
1178 
1179     /**
1180      * Implement a simple task delegator.
1181      */
1182     private static class DelegatedTask implements Runnable {
1183         private final SSLEngineImpl engine;
1184 
1185         DelegatedTask(SSLEngineImpl engineInstance) {
1186             this.engine = engineInstance;
1187         }
1188 
1189         @Override
1190         public void run() {
1191             engine.engineLock.lock();
1192             try {
1193                 HandshakeContext hc = engine.conContext.handshakeContext;
1194                 if (hc == null || hc.delegatedActions.isEmpty()) {
1195                     return;
1196                 }
1197 
1198                 try {
1199                     AccessController.doPrivileged(
1200                             new DelegatedAction(hc), engine.conContext.acc);
1201                 } catch (PrivilegedActionException pae) {
1202                     // Get the handshake context again in case the
1203                     // handshaking has completed.
1204                     Exception reportedException = pae.getException();
1205 
1206                     // Report to both the TransportContext...
1207                     if (engine.conContext.delegatedThrown == null) {
1208                         engine.conContext.delegatedThrown = reportedException;
1209                     }
1210 
1211                     // ...and the HandshakeContext in case condition
1212                     // wasn&#39;t fatal and the handshakeContext is still
1213                     // around.
1214                     hc = engine.conContext.handshakeContext;
1215                     if (hc != null) {
1216                         hc.delegatedThrown = reportedException;
1217                     } else if (engine.conContext.closeReason != null) {
1218                         // Update the reason in case there was a previous.
1219                         engine.conContext.closeReason =
1220                                 getTaskThrown(reportedException);
1221                     }
1222                 } catch (RuntimeException rte) {
1223                     // Get the handshake context again in case the
1224                     // handshaking has completed.
1225 
1226                     // Report to both the TransportContext...
1227                     if (engine.conContext.delegatedThrown == null) {
1228                         engine.conContext.delegatedThrown = rte;
1229                     }
1230 
1231                     // ...and the HandshakeContext in case condition
1232                     // wasn&#39;t fatal and the handshakeContext is still
1233                     // around.
1234                     hc = engine.conContext.handshakeContext;
1235                     if (hc != null) {
1236                         hc.delegatedThrown = rte;
1237                     } else if (engine.conContext.closeReason != null) {
1238                         // Update the reason in case there was a previous.
1239                         engine.conContext.closeReason = rte;
1240                     }
1241                 }
1242 
1243                 // Get the handshake context again in case the
1244                 // handshaking has completed.
1245                 hc = engine.conContext.handshakeContext;
1246                 if (hc != null) {
1247                     hc.taskDelegated = false;
1248                 }
1249             } finally {
1250                 engine.engineLock.unlock();
1251             }
1252         }
1253 
1254         private static class DelegatedAction
1255                 implements PrivilegedExceptionAction&lt;Void&gt; {
1256             final HandshakeContext context;
1257             DelegatedAction(HandshakeContext context) {
1258                 this.context = context;
1259             }
1260 
1261             @Override
1262             public Void run() throws Exception {
1263                 while (!context.delegatedActions.isEmpty()) {
1264                     Map.Entry&lt;Byte, ByteBuffer&gt; me =
1265                             context.delegatedActions.poll();
1266                     if (me != null) {
1267                         context.dispatch(me.getKey(), me.getValue());
1268                     }
1269                 }
1270                 return null;
1271             }
1272         }
1273     }
1274 }
    </pre>
  </body>
</html>
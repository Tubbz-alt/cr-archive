<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/NewSessionTicket.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="HandshakeContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/NewSessionTicket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.math.BigInteger;
 29 import java.nio.ByteBuffer;
 30 import java.security.GeneralSecurityException;
 31 import java.security.SecureRandom;
 32 import java.text.MessageFormat;
 33 import java.util.Locale;
 34 import javax.crypto.SecretKey;
 35 import javax.net.ssl.SSLHandshakeException;

 36 import sun.security.ssl.PskKeyExchangeModesExtension.PskKeyExchangeModesSpec;
 37 import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;
 38 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 39 import sun.security.util.HexDumpEncoder;
 40 
 41 import static sun.security.ssl.SSLHandshake.NEW_SESSION_TICKET;
 42 
 43 /**
 44  * Pack of the NewSessionTicket handshake message.
 45  */
 46 final class NewSessionTicket {
 47     static final int MAX_TICKET_LIFETIME = 604800;  // seconds, 7 days
 48     static final SSLConsumer handshakeConsumer =
 49         new T13NewSessionTicketConsumer();
 50     static final SSLConsumer handshake12Consumer =
 51         new T12NewSessionTicketConsumer();
<span class="line-modified"> 52     static final SSLProducer kickstartProducer =</span>
<span class="line-modified"> 53         new NewSessionTicketKickstartProducer();</span>
 54     static final HandshakeProducer handshake12Producer =
 55         new T12NewSessionTicketProducer();
 56 
 57     /**
 58      * The NewSessionTicketMessage handshake messages.
 59      */
 60     abstract static class NewSessionTicketMessage extends HandshakeMessage {
 61         int ticketLifetime;
 62         byte[] ticket = new byte[0];
 63 
 64         NewSessionTicketMessage(HandshakeContext context) {
 65             super(context);
 66         }
 67 
 68         @Override
 69         public SSLHandshake handshakeType() {
 70             return NEW_SESSION_TICKET;
 71         }
 72 
 73         // For TLS 1.3 only
</pre>
<hr />
<pre>
188 
189             if (m.remaining() &lt; 14) {
190                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
191                     &quot;Invalid NewSessionTicket message: insufficient data&quot;);
192             }
193 
194             this.ticketLifetime = Record.getInt32(m);
195             this.ticketAgeAdd = Record.getInt32(m);
196             this.ticketNonce = Record.getBytes8(m);
197 
198             if (m.remaining() &lt; 5) {
199                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
200                     &quot;Invalid NewSessionTicket message: insufficient ticket&quot; +
201                             &quot; data&quot;);
202             }
203 
204             this.ticket = Record.getBytes16(m);
205             if (ticket.length == 0) {
206                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
207                     SSLLogger.fine(
<span class="line-modified">208                     &quot;No ticket in the NewSessionTicket handshake message&quot;);</span>
209                 }
210             }
211 
212             if (m.remaining() &lt; 2) {
213                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
214                     &quot;Invalid NewSessionTicket message: extra data&quot;);
215             }
216 
217             SSLExtension[] supportedExtensions =
218                     context.sslConfig.getEnabledExtensions(
219                             NEW_SESSION_TICKET);
220             this.extensions = new SSLExtensions(this, m, supportedExtensions);
221         }
222 
223         @Override
224         public SSLHandshake handshakeType() {
225             return NEW_SESSION_TICKET;
226         }
227 
228         int getTicketAgeAdd() {
</pre>
<hr />
<pre>
290 
291             return messageFormat.format(messageFields);
292         }
293     }
294 
295     private static SecretKey derivePreSharedKey(CipherSuite.HashAlg hashAlg,
296             SecretKey resumptionMasterSecret, byte[] nonce) throws IOException {
297         try {
298             HKDF hkdf = new HKDF(hashAlg.name);
299             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
300                     &quot;tls13 resumption&quot;.getBytes(), nonce, hashAlg.hashLength);
301             return hkdf.expand(resumptionMasterSecret, hkdfInfo,
302                     hashAlg.hashLength, &quot;TlsPreSharedKey&quot;);
303         } catch  (GeneralSecurityException gse) {
304             throw (SSLHandshakeException) new SSLHandshakeException(
305                     &quot;Could not derive PSK&quot;).initCause(gse);
306         }
307     }
308 
309     private static final
<span class="line-modified">310             class NewSessionTicketKickstartProducer implements SSLProducer {</span>
311         // Prevent instantiation of this class.
<span class="line-modified">312         private NewSessionTicketKickstartProducer() {</span>
313             // blank
314         }
315 
316         @Override
317         public byte[] produce(ConnectionContext context) throws IOException {
318             HandshakeContext hc = (HandshakeContext)context;
319 










320             // The producing happens in server side only.
321             if (hc instanceof ServerHandshakeContext) {
322                 // Is this session resumable?
323                 if (!hc.handshakeSession.isRejoinable()) {






324                     return null;
325                 }
326 
327                 // What&#39;s the requested PSK key exchange modes?
328                 //
329                 // Note that currently, the NewSessionTicket post-handshake is
330                 // produced and delivered only in the current handshake context
331                 // if required.
332                 PskKeyExchangeModesSpec pkemSpec =
333                         (PskKeyExchangeModesSpec) hc.handshakeExtensions.get(
334                                 SSLExtension.PSK_KEY_EXCHANGE_MODES);
<span class="line-modified">335                 if (pkemSpec == null || !pkemSpec.contains(</span>
<span class="line-modified">336                         PskKeyExchangeModesExtension.PskKeyExchangeMode.PSK_DHE_KE)) {</span>
<span class="line-modified">337                     // Client doesn&#39;t support PSK with (EC)DHE key establishment.</span>





338                     return null;
339                 }
<span class="line-modified">340             } else { // PostHandshakeContext</span>
<span class="line-modified">341 </span>
<span class="line-modified">342                 // Check if we have sent a PSK already, then we know it is using a</span>
<span class="line-removed">343                 // allowable PSK exchange key mode</span>
344                 if (!hc.handshakeSession.isPSKable()) {






345                     return null;
346                 }
347             }
348 
349             // get a new session ID
350             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
351                 hc.sslContext.engineGetServerSessionContext();
352             SessionId newId = new SessionId(true,
353                 hc.sslContext.getSecureRandom());
354 
355             SecretKey resumptionMasterSecret =
356                 hc.handshakeSession.getResumptionMasterSecret();
357             if (resumptionMasterSecret == null) {
358                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
359                     SSLLogger.fine(
<span class="line-modified">360                         &quot;Session has no resumption secret. No ticket sent.&quot;);</span>

361                 }

362                 return null;
363             }
364 
365             // construct the PSK and handshake message
366             BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();
367             byte[] nonceArr = nonce.toByteArray();
368             SecretKey psk = derivePreSharedKey(
369                     hc.negotiatedCipherSuite.hashAlg,
370                     resumptionMasterSecret, nonceArr);
371 
372             int sessionTimeoutSeconds = sessionCache.getSessionTimeout();
373             if (sessionTimeoutSeconds &gt; MAX_TICKET_LIFETIME) {
374                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
375                     SSLLogger.fine(
<span class="line-modified">376                         &quot;Session timeout is too long. No ticket sent.&quot;);</span>

377                 }

378                 return null;
379             }
380 
381             NewSessionTicketMessage nstm = null;
382 
383             SSLSessionImpl sessionCopy =
384                     new SSLSessionImpl(hc.handshakeSession, newId);
385             sessionCopy.setPreSharedKey(psk);
386             sessionCopy.setPskIdentity(newId.getId());
387 
388             // If a stateless ticket is allowed, attempt to make one
<span class="line-modified">389             if (hc.handshakeSession.isStatelessable(hc)) {</span>

390                 nstm = new T13NewSessionTicketMessage(hc,
391                         sessionTimeoutSeconds,
392                         hc.sslContext.getSecureRandom(),
393                         nonceArr,
394                         new SessionTicketSpec().encrypt(hc, sessionCopy));
395                 // If ticket construction failed, switch to session cache
396                 if (!nstm.isValid()) {
397                     hc.statelessResumption = false;
398                 } else {
399                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
400                         SSLLogger.fine(
<span class="line-modified">401                                 &quot;Produced NewSessionTicket stateless &quot; +</span>
<span class="line-modified">402                                         &quot;handshake message&quot;, nstm);</span>
403                     }
404                 }
405             }

406             // If a session cache ticket is being used, make one
<span class="line-modified">407             if (!hc.handshakeSession.isStatelessable(hc)) {</span>

408                 nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,
409                         hc.sslContext.getSecureRandom(), nonceArr,
410                         newId.getId());
411                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
412                     SSLLogger.fine(
<span class="line-modified">413                             &quot;Produced NewSessionTicket handshake message&quot;,</span>
414                             nstm);
415                 }
416 
417                 // create and cache the new session
418                 // The new session must be a child of the existing session so
419                 // they will be invalidated together, etc.
420                 hc.handshakeSession.addChild(sessionCopy);
421                 sessionCopy.setTicketAgeAdd(nstm.getTicketAgeAdd());
422                 sessionCache.put(sessionCopy);
423             }
424 
425             // Output the handshake message.
426             if (nstm != null) {
427                 // should never be null
428                 nstm.write(hc.handshakeOutput);
429                 hc.handshakeOutput.flush();
<span class="line-removed">430             }</span>
431 
<span class="line-modified">432             if (hc.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-modified">433                 hc.conContext.finishPostHandshake();</span>







434             }
435 



436             // The message has been delivered.
437             return null;
438         }
439     }
440 
441     /**
442      * The &quot;NewSessionTicket&quot; handshake message producer for RFC 5077
443      */
444     private static final class T12NewSessionTicketProducer
445             implements HandshakeProducer {
446 
447         // Prevent instantiation of this class.
448         private T12NewSessionTicketProducer() {
449             // blank
450         }
451 
452         @Override
453         public byte[] produce(ConnectionContext context,
454                 HandshakeMessage message) throws IOException {
455 
</pre>
<hr />
<pre>
466             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
467                     shc.sslContext.engineGetServerSessionContext();
468             int sessionTimeoutSeconds = sessionCache.getSessionTimeout();
469             if (sessionTimeoutSeconds &gt; MAX_TICKET_LIFETIME) {
470                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
471                     SSLLogger.fine(
472                         &quot;Session timeout is too long. No ticket sent.&quot;);
473                 }
474                 return null;
475             }
476 
477             SSLSessionImpl sessionCopy =
478                     new SSLSessionImpl(shc.handshakeSession, newId);
479             sessionCopy.setPskIdentity(newId.getId());
480 
481             NewSessionTicketMessage nstm = new T12NewSessionTicketMessage(shc,
482                     sessionTimeoutSeconds,
483                     new SessionTicketSpec().encrypt(shc, sessionCopy));
484             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
485                 SSLLogger.fine(
<span class="line-modified">486                         &quot;Produced NewSessionTicket stateless handshake message&quot;, nstm);</span>

487             }
488 
489             // Output the handshake message.
490             nstm.write(shc.handshakeOutput);
491             shc.handshakeOutput.flush();
492 
493             // The message has been delivered.
494             return null;
495         }
496     }
497 
498     private static final
499     class T13NewSessionTicketConsumer implements SSLConsumer {
500         // Prevent instantiation of this class.
501         private T13NewSessionTicketConsumer() {
502             // blank
503         }
504 
505         @Override
506         public void consume(ConnectionContext context,
507                 ByteBuffer message) throws IOException {
508 
509             // Note: Although the resumption master secret depends on the
510             // client&#39;s second flight, servers which do not request client
511             // authentication MAY compute the remainder of the transcript
512             // independently and then send a NewSessionTicket immediately
513             // upon sending its Finished rather than waiting for the client
514             // Finished.
515             //
516             // The consuming happens in client side only and is received after
517             // the server&#39;s Finished message with PostHandshakeContext.
518 
519             HandshakeContext hc = (HandshakeContext)context;
520             NewSessionTicketMessage nstm =
521                     new T13NewSessionTicketMessage(hc, message);
522             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
523                 SSLLogger.fine(
<span class="line-modified">524                 &quot;Consuming NewSessionTicket message&quot;, nstm);</span>
525             }
526 
527             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
528                     hc.sslContext.engineGetClientSessionContext();
529 
530             // discard tickets with timeout 0
531             if (nstm.ticketLifetime &lt;= 0 ||
532                 nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {
533                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
534                     SSLLogger.fine(
<span class="line-modified">535                     &quot;Discarding NewSessionTicket with lifetime &quot;</span>
<span class="line-modified">536                         + nstm.ticketLifetime, nstm);</span>
537                 }
538                 sessionCache.remove(hc.handshakeSession.getSessionId());
539                 return;
540             }
541 
542             if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {
543                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
544                     SSLLogger.fine(
<span class="line-modified">545                     &quot;Session cache lifetime is too long. Discarding ticket.&quot;);</span>

546                 }
547                 return;
548             }
549 
550             SSLSessionImpl sessionToSave = hc.conContext.conSession;
<span class="line-modified">551             SecretKey psk = null;</span>
<span class="line-modified">552             if (hc.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-modified">553                 SecretKey resumptionMasterSecret =</span>
<span class="line-modified">554                         sessionToSave.getResumptionMasterSecret();</span>
<span class="line-modified">555                 if (resumptionMasterSecret == null) {</span>
<span class="line-modified">556                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-modified">557                         SSLLogger.fine(</span>
<span class="line-removed">558                                 &quot;Session has no resumption master secret.&quot; +</span>
<span class="line-removed">559                                         &quot; Ignoring ticket.&quot;);</span>
<span class="line-removed">560                     }</span>
<span class="line-removed">561                     return;</span>
562                 }
<span class="line-modified">563 </span>
<span class="line-removed">564                 // derive the PSK</span>
<span class="line-removed">565                 psk = derivePreSharedKey(</span>
<span class="line-removed">566                         sessionToSave.getSuite().hashAlg,</span>
<span class="line-removed">567                         resumptionMasterSecret, nstm.getTicketNonce());</span>
568             }
569 





570             // create and cache the new session
571             // The new session must be a child of the existing session so
572             // they will be invalidated together, etc.
573             SessionId newId =
574                     new SessionId(true, hc.sslContext.getSecureRandom());
575             SSLSessionImpl sessionCopy = new SSLSessionImpl(sessionToSave,
576                     newId);
577             sessionToSave.addChild(sessionCopy);
578             sessionCopy.setPreSharedKey(psk);
579             sessionCopy.setTicketAgeAdd(nstm.getTicketAgeAdd());
580             sessionCopy.setPskIdentity(nstm.ticket);
581             sessionCache.put(sessionCopy);
582 
<span class="line-modified">583             // clean handshake context</span>
<span class="line-modified">584             if (hc.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-removed">585                 hc.conContext.finishPostHandshake();</span>
<span class="line-removed">586             }</span>
587         }
588     }
589 
590     private static final
591     class T12NewSessionTicketConsumer implements SSLConsumer {
592         // Prevent instantiation of this class.
593         private T12NewSessionTicketConsumer() {
594             // blank
595         }
596 
597         @Override
598         public void consume(ConnectionContext context,
599                 ByteBuffer message) throws IOException {
600 
601             HandshakeContext hc = (HandshakeContext)context;
602             hc.handshakeConsumers.remove(NEW_SESSION_TICKET.id);
603 
604             NewSessionTicketMessage nstm = new T12NewSessionTicketMessage(hc,
605                     message);
606             if (nstm.ticket.length == 0) {
607                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
608                     SSLLogger.fine(&quot;NewSessionTicket ticket was empty&quot;);
609                 }
610                 return;
611             }
612 
613             // discard tickets with timeout 0
614             if (nstm.ticketLifetime &lt;= 0 ||
615                 nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {
616                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
617                     SSLLogger.fine(
<span class="line-modified">618                     &quot;Discarding NewSessionTicket with lifetime &quot;</span>
<span class="line-modified">619                         + nstm.ticketLifetime, nstm);</span>
620                 }
621                 return;
622             }
623 
624             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
625                     hc.sslContext.engineGetClientSessionContext();
626 
627             if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {
628                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
629                     SSLLogger.fine(
<span class="line-modified">630                     &quot;Session cache lifetime is too long. Discarding ticket.&quot;);</span>

631                 }
632                 return;
633             }
634 
635             hc.handshakeSession.setPskIdentity(nstm.ticket);
636             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
637                 SSLLogger.fine(&quot;Consuming NewSessionTicket\n&quot; +
638                         nstm.toString());
639             }
640         }
641     }
642 }
643 
</pre>
</td>
<td>
<hr />
<pre>
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.math.BigInteger;
 29 import java.nio.ByteBuffer;
 30 import java.security.GeneralSecurityException;
 31 import java.security.SecureRandom;
 32 import java.text.MessageFormat;
 33 import java.util.Locale;
 34 import javax.crypto.SecretKey;
 35 import javax.net.ssl.SSLHandshakeException;
<span class="line-added"> 36 import sun.security.ssl.PskKeyExchangeModesExtension.PskKeyExchangeMode;</span>
 37 import sun.security.ssl.PskKeyExchangeModesExtension.PskKeyExchangeModesSpec;
 38 import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;
 39 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 40 import sun.security.util.HexDumpEncoder;
 41 
 42 import static sun.security.ssl.SSLHandshake.NEW_SESSION_TICKET;
 43 
 44 /**
 45  * Pack of the NewSessionTicket handshake message.
 46  */
 47 final class NewSessionTicket {
 48     static final int MAX_TICKET_LIFETIME = 604800;  // seconds, 7 days
 49     static final SSLConsumer handshakeConsumer =
 50         new T13NewSessionTicketConsumer();
 51     static final SSLConsumer handshake12Consumer =
 52         new T12NewSessionTicketConsumer();
<span class="line-modified"> 53     static final SSLProducer t13PosthandshakeProducer =</span>
<span class="line-modified"> 54         new T13NewSessionTicketProducer();</span>
 55     static final HandshakeProducer handshake12Producer =
 56         new T12NewSessionTicketProducer();
 57 
 58     /**
 59      * The NewSessionTicketMessage handshake messages.
 60      */
 61     abstract static class NewSessionTicketMessage extends HandshakeMessage {
 62         int ticketLifetime;
 63         byte[] ticket = new byte[0];
 64 
 65         NewSessionTicketMessage(HandshakeContext context) {
 66             super(context);
 67         }
 68 
 69         @Override
 70         public SSLHandshake handshakeType() {
 71             return NEW_SESSION_TICKET;
 72         }
 73 
 74         // For TLS 1.3 only
</pre>
<hr />
<pre>
189 
190             if (m.remaining() &lt; 14) {
191                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
192                     &quot;Invalid NewSessionTicket message: insufficient data&quot;);
193             }
194 
195             this.ticketLifetime = Record.getInt32(m);
196             this.ticketAgeAdd = Record.getInt32(m);
197             this.ticketNonce = Record.getBytes8(m);
198 
199             if (m.remaining() &lt; 5) {
200                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
201                     &quot;Invalid NewSessionTicket message: insufficient ticket&quot; +
202                             &quot; data&quot;);
203             }
204 
205             this.ticket = Record.getBytes16(m);
206             if (ticket.length == 0) {
207                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
208                     SSLLogger.fine(
<span class="line-modified">209                         &quot;No ticket in the NewSessionTicket handshake message&quot;);</span>
210                 }
211             }
212 
213             if (m.remaining() &lt; 2) {
214                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
215                     &quot;Invalid NewSessionTicket message: extra data&quot;);
216             }
217 
218             SSLExtension[] supportedExtensions =
219                     context.sslConfig.getEnabledExtensions(
220                             NEW_SESSION_TICKET);
221             this.extensions = new SSLExtensions(this, m, supportedExtensions);
222         }
223 
224         @Override
225         public SSLHandshake handshakeType() {
226             return NEW_SESSION_TICKET;
227         }
228 
229         int getTicketAgeAdd() {
</pre>
<hr />
<pre>
291 
292             return messageFormat.format(messageFields);
293         }
294     }
295 
296     private static SecretKey derivePreSharedKey(CipherSuite.HashAlg hashAlg,
297             SecretKey resumptionMasterSecret, byte[] nonce) throws IOException {
298         try {
299             HKDF hkdf = new HKDF(hashAlg.name);
300             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
301                     &quot;tls13 resumption&quot;.getBytes(), nonce, hashAlg.hashLength);
302             return hkdf.expand(resumptionMasterSecret, hkdfInfo,
303                     hashAlg.hashLength, &quot;TlsPreSharedKey&quot;);
304         } catch  (GeneralSecurityException gse) {
305             throw (SSLHandshakeException) new SSLHandshakeException(
306                     &quot;Could not derive PSK&quot;).initCause(gse);
307         }
308     }
309 
310     private static final
<span class="line-modified">311             class T13NewSessionTicketProducer implements SSLProducer {</span>
312         // Prevent instantiation of this class.
<span class="line-modified">313         private T13NewSessionTicketProducer() {</span>
314             // blank
315         }
316 
317         @Override
318         public byte[] produce(ConnectionContext context) throws IOException {
319             HandshakeContext hc = (HandshakeContext)context;
320 
<span class="line-added">321             // See note on TransportContext.needHandshakeFinishedStatus.</span>
<span class="line-added">322             //</span>
<span class="line-added">323             // Set to need handshake finished status.  Reset it later if a</span>
<span class="line-added">324             // session ticket get delivered.</span>
<span class="line-added">325             if (hc.conContext.hasDelegatedFinished) {</span>
<span class="line-added">326                 // Reset, as the delegated finished case will be handled later.</span>
<span class="line-added">327                 hc.conContext.hasDelegatedFinished = false;</span>
<span class="line-added">328                 hc.conContext.needHandshakeFinishedStatus = true;</span>
<span class="line-added">329             }</span>
<span class="line-added">330 </span>
331             // The producing happens in server side only.
332             if (hc instanceof ServerHandshakeContext) {
333                 // Is this session resumable?
334                 if (!hc.handshakeSession.isRejoinable()) {
<span class="line-added">335                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">336                         SSLLogger.fine(</span>
<span class="line-added">337                                 &quot;No session ticket produced: &quot; +</span>
<span class="line-added">338                                 &quot;session is not resumable&quot;);</span>
<span class="line-added">339                     }</span>
<span class="line-added">340 </span>
341                     return null;
342                 }
343 
344                 // What&#39;s the requested PSK key exchange modes?
345                 //
346                 // Note that currently, the NewSessionTicket post-handshake is
347                 // produced and delivered only in the current handshake context
348                 // if required.
349                 PskKeyExchangeModesSpec pkemSpec =
350                         (PskKeyExchangeModesSpec) hc.handshakeExtensions.get(
351                                 SSLExtension.PSK_KEY_EXCHANGE_MODES);
<span class="line-modified">352                 if (pkemSpec == null ||</span>
<span class="line-modified">353                         !pkemSpec.contains(PskKeyExchangeMode.PSK_DHE_KE)) {</span>
<span class="line-modified">354                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">355                         SSLLogger.fine(</span>
<span class="line-added">356                                 &quot;No session ticket produced: &quot; +</span>
<span class="line-added">357                                 &quot;client does not support psk_dhe_ke&quot;);</span>
<span class="line-added">358                     }</span>
<span class="line-added">359 </span>
360                     return null;
361                 }
<span class="line-modified">362             } else {     // PostHandshakeContext</span>
<span class="line-modified">363                 // Check if we have sent a PSK already, then we know it is</span>
<span class="line-modified">364                 // using a allowable PSK exchange key mode.</span>

365                 if (!hc.handshakeSession.isPSKable()) {
<span class="line-added">366                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">367                         SSLLogger.fine(</span>
<span class="line-added">368                                 &quot;No session ticket produced: &quot; +</span>
<span class="line-added">369                                 &quot;No session ticket allowed in this session&quot;);</span>
<span class="line-added">370                     }</span>
<span class="line-added">371 </span>
372                     return null;
373                 }
374             }
375 
376             // get a new session ID
377             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
378                 hc.sslContext.engineGetServerSessionContext();
379             SessionId newId = new SessionId(true,
380                 hc.sslContext.getSecureRandom());
381 
382             SecretKey resumptionMasterSecret =
383                 hc.handshakeSession.getResumptionMasterSecret();
384             if (resumptionMasterSecret == null) {
385                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
386                     SSLLogger.fine(
<span class="line-modified">387                             &quot;No session ticket produced: &quot; +</span>
<span class="line-added">388                             &quot;no resumption secret&quot;);</span>
389                 }
<span class="line-added">390 </span>
391                 return null;
392             }
393 
394             // construct the PSK and handshake message
395             BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();
396             byte[] nonceArr = nonce.toByteArray();
397             SecretKey psk = derivePreSharedKey(
398                     hc.negotiatedCipherSuite.hashAlg,
399                     resumptionMasterSecret, nonceArr);
400 
401             int sessionTimeoutSeconds = sessionCache.getSessionTimeout();
402             if (sessionTimeoutSeconds &gt; MAX_TICKET_LIFETIME) {
403                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
404                     SSLLogger.fine(
<span class="line-modified">405                             &quot;No session ticket produced: &quot; +</span>
<span class="line-added">406                             &quot;session timeout&quot;);</span>
407                 }
<span class="line-added">408 </span>
409                 return null;
410             }
411 
412             NewSessionTicketMessage nstm = null;
413 
414             SSLSessionImpl sessionCopy =
415                     new SSLSessionImpl(hc.handshakeSession, newId);
416             sessionCopy.setPreSharedKey(psk);
417             sessionCopy.setPskIdentity(newId.getId());
418 
419             // If a stateless ticket is allowed, attempt to make one
<span class="line-modified">420             if (hc.statelessResumption &amp;&amp;</span>
<span class="line-added">421                     hc.handshakeSession.isStatelessable()) {</span>
422                 nstm = new T13NewSessionTicketMessage(hc,
423                         sessionTimeoutSeconds,
424                         hc.sslContext.getSecureRandom(),
425                         nonceArr,
426                         new SessionTicketSpec().encrypt(hc, sessionCopy));
427                 // If ticket construction failed, switch to session cache
428                 if (!nstm.isValid()) {
429                     hc.statelessResumption = false;
430                 } else {
431                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
432                         SSLLogger.fine(
<span class="line-modified">433                             &quot;Produced NewSessionTicket stateless &quot; +</span>
<span class="line-modified">434                             &quot;post-handshake message&quot;, nstm);</span>
435                     }
436                 }
437             }
<span class="line-added">438 </span>
439             // If a session cache ticket is being used, make one
<span class="line-modified">440             if (!hc.statelessResumption ||</span>
<span class="line-added">441                     !hc.handshakeSession.isStatelessable()) {</span>
442                 nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,
443                         hc.sslContext.getSecureRandom(), nonceArr,
444                         newId.getId());
445                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
446                     SSLLogger.fine(
<span class="line-modified">447                             &quot;Produced NewSessionTicket post-handshake message&quot;,</span>
448                             nstm);
449                 }
450 
451                 // create and cache the new session
452                 // The new session must be a child of the existing session so
453                 // they will be invalidated together, etc.
454                 hc.handshakeSession.addChild(sessionCopy);
455                 sessionCopy.setTicketAgeAdd(nstm.getTicketAgeAdd());
456                 sessionCache.put(sessionCopy);
457             }
458 
459             // Output the handshake message.
460             if (nstm != null) {
461                 // should never be null
462                 nstm.write(hc.handshakeOutput);
463                 hc.handshakeOutput.flush();

464 
<span class="line-modified">465                 // See note on TransportContext.needHandshakeFinishedStatus.</span>
<span class="line-modified">466                 //</span>
<span class="line-added">467                 // Reset the needHandshakeFinishedStatus flag.  The delivery</span>
<span class="line-added">468                 // of this post-handshake message will indicate the FINISHED</span>
<span class="line-added">469                 // handshake status.  It is not needed to have a follow-on</span>
<span class="line-added">470                 // SSLEngine.wrap() any longer.</span>
<span class="line-added">471                 if (hc.conContext.needHandshakeFinishedStatus) {</span>
<span class="line-added">472                     hc.conContext.needHandshakeFinishedStatus = false;</span>
<span class="line-added">473                 }</span>
474             }
475 
<span class="line-added">476             // clean the post handshake context</span>
<span class="line-added">477             hc.conContext.finishPostHandshake();</span>
<span class="line-added">478 </span>
479             // The message has been delivered.
480             return null;
481         }
482     }
483 
484     /**
485      * The &quot;NewSessionTicket&quot; handshake message producer for RFC 5077
486      */
487     private static final class T12NewSessionTicketProducer
488             implements HandshakeProducer {
489 
490         // Prevent instantiation of this class.
491         private T12NewSessionTicketProducer() {
492             // blank
493         }
494 
495         @Override
496         public byte[] produce(ConnectionContext context,
497                 HandshakeMessage message) throws IOException {
498 
</pre>
<hr />
<pre>
509             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
510                     shc.sslContext.engineGetServerSessionContext();
511             int sessionTimeoutSeconds = sessionCache.getSessionTimeout();
512             if (sessionTimeoutSeconds &gt; MAX_TICKET_LIFETIME) {
513                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
514                     SSLLogger.fine(
515                         &quot;Session timeout is too long. No ticket sent.&quot;);
516                 }
517                 return null;
518             }
519 
520             SSLSessionImpl sessionCopy =
521                     new SSLSessionImpl(shc.handshakeSession, newId);
522             sessionCopy.setPskIdentity(newId.getId());
523 
524             NewSessionTicketMessage nstm = new T12NewSessionTicketMessage(shc,
525                     sessionTimeoutSeconds,
526                     new SessionTicketSpec().encrypt(shc, sessionCopy));
527             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
528                 SSLLogger.fine(
<span class="line-modified">529                     &quot;Produced NewSessionTicket stateless handshake message&quot;,</span>
<span class="line-added">530                     nstm);</span>
531             }
532 
533             // Output the handshake message.
534             nstm.write(shc.handshakeOutput);
535             shc.handshakeOutput.flush();
536 
537             // The message has been delivered.
538             return null;
539         }
540     }
541 
542     private static final
543     class T13NewSessionTicketConsumer implements SSLConsumer {
544         // Prevent instantiation of this class.
545         private T13NewSessionTicketConsumer() {
546             // blank
547         }
548 
549         @Override
550         public void consume(ConnectionContext context,
551                 ByteBuffer message) throws IOException {
552 
553             // Note: Although the resumption master secret depends on the
554             // client&#39;s second flight, servers which do not request client
555             // authentication MAY compute the remainder of the transcript
556             // independently and then send a NewSessionTicket immediately
557             // upon sending its Finished rather than waiting for the client
558             // Finished.
559             //
560             // The consuming happens in client side only and is received after
561             // the server&#39;s Finished message with PostHandshakeContext.
562 
563             HandshakeContext hc = (HandshakeContext)context;
564             NewSessionTicketMessage nstm =
565                     new T13NewSessionTicketMessage(hc, message);
566             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
567                 SSLLogger.fine(
<span class="line-modified">568                         &quot;Consuming NewSessionTicket message&quot;, nstm);</span>
569             }
570 
571             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
572                     hc.sslContext.engineGetClientSessionContext();
573 
574             // discard tickets with timeout 0
575             if (nstm.ticketLifetime &lt;= 0 ||
576                 nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {
577                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
578                     SSLLogger.fine(
<span class="line-modified">579                             &quot;Discarding NewSessionTicket with lifetime &quot; +</span>
<span class="line-modified">580                             nstm.ticketLifetime, nstm);</span>
581                 }
582                 sessionCache.remove(hc.handshakeSession.getSessionId());
583                 return;
584             }
585 
586             if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {
587                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
588                     SSLLogger.fine(
<span class="line-modified">589                         &quot;Session cache lifetime is too long. &quot; +</span>
<span class="line-added">590                         &quot;Discarding ticket.&quot;);</span>
591                 }
592                 return;
593             }
594 
595             SSLSessionImpl sessionToSave = hc.conContext.conSession;
<span class="line-modified">596             SecretKey resumptionMasterSecret =</span>
<span class="line-modified">597                     sessionToSave.getResumptionMasterSecret();</span>
<span class="line-modified">598             if (resumptionMasterSecret == null) {</span>
<span class="line-modified">599                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-modified">600                     SSLLogger.fine(</span>
<span class="line-modified">601                             &quot;Session has no resumption master secret. &quot; +</span>
<span class="line-modified">602                             &quot;Ignoring ticket.&quot;);</span>




603                 }
<span class="line-modified">604                 return;</span>




605             }
606 
<span class="line-added">607             // derive the PSK</span>
<span class="line-added">608             SecretKey psk = derivePreSharedKey(</span>
<span class="line-added">609                     sessionToSave.getSuite().hashAlg,</span>
<span class="line-added">610                     resumptionMasterSecret, nstm.getTicketNonce());</span>
<span class="line-added">611 </span>
612             // create and cache the new session
613             // The new session must be a child of the existing session so
614             // they will be invalidated together, etc.
615             SessionId newId =
616                     new SessionId(true, hc.sslContext.getSecureRandom());
617             SSLSessionImpl sessionCopy = new SSLSessionImpl(sessionToSave,
618                     newId);
619             sessionToSave.addChild(sessionCopy);
620             sessionCopy.setPreSharedKey(psk);
621             sessionCopy.setTicketAgeAdd(nstm.getTicketAgeAdd());
622             sessionCopy.setPskIdentity(nstm.ticket);
623             sessionCache.put(sessionCopy);
624 
<span class="line-modified">625             // clean the post handshake context</span>
<span class="line-modified">626             hc.conContext.finishPostHandshake();</span>


627         }
628     }
629 
630     private static final
631     class T12NewSessionTicketConsumer implements SSLConsumer {
632         // Prevent instantiation of this class.
633         private T12NewSessionTicketConsumer() {
634             // blank
635         }
636 
637         @Override
638         public void consume(ConnectionContext context,
639                 ByteBuffer message) throws IOException {
640 
641             HandshakeContext hc = (HandshakeContext)context;
642             hc.handshakeConsumers.remove(NEW_SESSION_TICKET.id);
643 
644             NewSessionTicketMessage nstm = new T12NewSessionTicketMessage(hc,
645                     message);
646             if (nstm.ticket.length == 0) {
647                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
648                     SSLLogger.fine(&quot;NewSessionTicket ticket was empty&quot;);
649                 }
650                 return;
651             }
652 
653             // discard tickets with timeout 0
654             if (nstm.ticketLifetime &lt;= 0 ||
655                 nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {
656                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
657                     SSLLogger.fine(
<span class="line-modified">658                             &quot;Discarding NewSessionTicket with lifetime &quot; +</span>
<span class="line-modified">659                             nstm.ticketLifetime, nstm);</span>
660                 }
661                 return;
662             }
663 
664             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
665                     hc.sslContext.engineGetClientSessionContext();
666 
667             if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {
668                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
669                     SSLLogger.fine(
<span class="line-modified">670                         &quot;Session cache lifetime is too long. &quot; +</span>
<span class="line-added">671                         &quot;Discarding ticket.&quot;);</span>
672                 }
673                 return;
674             }
675 
676             hc.handshakeSession.setPskIdentity(nstm.ticket);
677             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
678                 SSLLogger.fine(&quot;Consuming NewSessionTicket\n&quot; +
679                         nstm.toString());
680             }
681         }
682     }
683 }
684 
</pre>
</td>
</tr>
</table>
<center><a href="HandshakeContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/sun/security/ssl/HandshakeContext.java b/src/java.base/share/classes/sun/security/ssl/HandshakeContext.java
--- a/src/java.base/share/classes/sun/security/ssl/HandshakeContext.java
+++ b/src/java.base/share/classes/sun/security/ssl/HandshakeContext.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -414,10 +414,45 @@
 
                 delegatedActions.add(new SimpleImmutableEntry<>(
                         handshakeType,
                         fragment
                     ));
+
+                // For TLS 1.2 and previous versions, the ChangeCipherSpec
+                // message is always delivered before the Finished handshake
+                // message.  ChangeCipherSpec is not a handshake message,
+                // and cannot be wrapped in one TLS record.  The processing
+                // of Finished handshake message is unlikely to be delegated.
+                //
+                // However, for TLS 1.3 there is no non-handshake messages
+                // delivered immediately before Finished message.  Then, the
+                // 'hasDelegated' could be true, and the Finished message is
+                // handled in a delegated action.
+                //
+                // The HandshakeStatus.FINISHED for the final handshake flight
+                // could be used to determine if the handshake has completed.
+                // Per the HandshakeStatus.FINISHED specification, it is only
+                // generated by call to SSLEngine.wrap()/unwrap().  It is
+                // unlikely to change the spec, so we cannot use delegated
+                // action and SSLEngine.getHandshakeStatus() to indicate the
+                // FINISHED handshake status.
+                //
+                // To workaround this special user case, the follow-on call to
+                // SSLEngine.wrap() method will return HandshakeStatus.FINISHED
+                // status if needed.
+                //
+                // As the final handshake flight is always delivered from the
+                // client side, so we only need to take care of the server
+                // dispatching processes.
+                //
+                // See also the note on
+                // TransportContext.needHandshakeFinishedStatus.
+                if (hasDelegated &&
+                        !conContext.sslConfig.isClientMode &&
+                        handshakeType == SSLHandshake.FINISHED.id) {
+                    conContext.hasDelegatedFinished = true;
+                }
             } else {
                 dispatch(handshakeType, plaintext.fragment);
             }
         } else {
             dispatch(handshakeType, plaintext.fragment);

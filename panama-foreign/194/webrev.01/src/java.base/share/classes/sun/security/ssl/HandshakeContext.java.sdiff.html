<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/HandshakeContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Finished.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="NewSessionTicket.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/HandshakeContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
399                     taskDelegated = false;
400                     delegatedThrown = null;
401                 }
402 
403                 // Clone the fragment for delegated actions.
404                 //
405                 // The plaintext may share the application buffers.  It is
406                 // fine to use shared buffers if no delegated actions.
407                 // However, for delegated actions, the shared buffers may be
408                 // polluted in application layer before the delegated actions
409                 // executed.
410                 ByteBuffer fragment = ByteBuffer.wrap(
411                         new byte[plaintext.fragment.remaining()]);
412                 fragment.put(plaintext.fragment);
413                 fragment = fragment.rewind();
414 
415                 delegatedActions.add(new SimpleImmutableEntry&lt;&gt;(
416                         handshakeType,
417                         fragment
418                     ));



































419             } else {
420                 dispatch(handshakeType, plaintext.fragment);
421             }
422         } else {
423             dispatch(handshakeType, plaintext.fragment);
424         }
425     }
426 
427     void dispatch(byte handshakeType,
428             ByteBuffer fragment) throws IOException {
429         SSLConsumer consumer;
430         if (handshakeType == SSLHandshake.HELLO_REQUEST.id) {
431             // For TLS 1.2 and prior versions, the HelloRequest message MAY
432             // be sent by the server at any time.
433             consumer = SSLHandshake.HELLO_REQUEST;
434         } else {
435             consumer = handshakeConsumers.get(handshakeType);
436         }
437 
438         if (consumer == null) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
399                     taskDelegated = false;
400                     delegatedThrown = null;
401                 }
402 
403                 // Clone the fragment for delegated actions.
404                 //
405                 // The plaintext may share the application buffers.  It is
406                 // fine to use shared buffers if no delegated actions.
407                 // However, for delegated actions, the shared buffers may be
408                 // polluted in application layer before the delegated actions
409                 // executed.
410                 ByteBuffer fragment = ByteBuffer.wrap(
411                         new byte[plaintext.fragment.remaining()]);
412                 fragment.put(plaintext.fragment);
413                 fragment = fragment.rewind();
414 
415                 delegatedActions.add(new SimpleImmutableEntry&lt;&gt;(
416                         handshakeType,
417                         fragment
418                     ));
<span class="line-added">419 </span>
<span class="line-added">420                 // For TLS 1.2 and previous versions, the ChangeCipherSpec</span>
<span class="line-added">421                 // message is always delivered before the Finished handshake</span>
<span class="line-added">422                 // message.  ChangeCipherSpec is not a handshake message,</span>
<span class="line-added">423                 // and cannot be wrapped in one TLS record.  The processing</span>
<span class="line-added">424                 // of Finished handshake message is unlikely to be delegated.</span>
<span class="line-added">425                 //</span>
<span class="line-added">426                 // However, for TLS 1.3 there is no non-handshake messages</span>
<span class="line-added">427                 // delivered immediately before Finished message.  Then, the</span>
<span class="line-added">428                 // &#39;hasDelegated&#39; could be true, and the Finished message is</span>
<span class="line-added">429                 // handled in a delegated action.</span>
<span class="line-added">430                 //</span>
<span class="line-added">431                 // The HandshakeStatus.FINISHED for the final handshake flight</span>
<span class="line-added">432                 // could be used to determine if the handshake has completed.</span>
<span class="line-added">433                 // Per the HandshakeStatus.FINISHED specification, it is only</span>
<span class="line-added">434                 // generated by call to SSLEngine.wrap()/unwrap().  It is</span>
<span class="line-added">435                 // unlikely to change the spec, so we cannot use delegated</span>
<span class="line-added">436                 // action and SSLEngine.getHandshakeStatus() to indicate the</span>
<span class="line-added">437                 // FINISHED handshake status.</span>
<span class="line-added">438                 //</span>
<span class="line-added">439                 // To workaround this special user case, the follow-on call to</span>
<span class="line-added">440                 // SSLEngine.wrap() method will return HandshakeStatus.FINISHED</span>
<span class="line-added">441                 // status if needed.</span>
<span class="line-added">442                 //</span>
<span class="line-added">443                 // As the final handshake flight is always delivered from the</span>
<span class="line-added">444                 // client side, so we only need to take care of the server</span>
<span class="line-added">445                 // dispatching processes.</span>
<span class="line-added">446                 //</span>
<span class="line-added">447                 // See also the note on</span>
<span class="line-added">448                 // TransportContext.needHandshakeFinishedStatus.</span>
<span class="line-added">449                 if (hasDelegated &amp;&amp;</span>
<span class="line-added">450                         !conContext.sslConfig.isClientMode &amp;&amp;</span>
<span class="line-added">451                         handshakeType == SSLHandshake.FINISHED.id) {</span>
<span class="line-added">452                     conContext.hasDelegatedFinished = true;</span>
<span class="line-added">453                 }</span>
454             } else {
455                 dispatch(handshakeType, plaintext.fragment);
456             }
457         } else {
458             dispatch(handshakeType, plaintext.fragment);
459         }
460     }
461 
462     void dispatch(byte handshakeType,
463             ByteBuffer fragment) throws IOException {
464         SSLConsumer consumer;
465         if (handshakeType == SSLHandshake.HELLO_REQUEST.id) {
466             // For TLS 1.2 and prior versions, the HelloRequest message MAY
467             // be sent by the server at any time.
468             consumer = SSLHandshake.HELLO_REQUEST;
469         } else {
470             consumer = handshakeConsumers.get(handshakeType);
471         }
472 
473         if (consumer == null) {
</pre>
</td>
</tr>
</table>
<center><a href="Finished.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="NewSessionTicket.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/TransportContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.security.AccessControlContext;
 30 import java.security.AccessController;
 31 import java.security.PrivilegedAction;
 32 import java.util.HashMap;
 33 import java.util.HashSet;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.Set;
 37 import javax.net.ssl.HandshakeCompletedEvent;
 38 import javax.net.ssl.HandshakeCompletedListener;
 39 import javax.net.ssl.SSLEngineResult.HandshakeStatus;
 40 import javax.net.ssl.SSLException;
 41 import javax.net.ssl.SSLSocket;
 42 
 43 /**
 44  * SSL/(D)TLS transportation context.
 45  */
 46 final class TransportContext implements ConnectionContext {
 47     final SSLTransport              transport;
 48 
 49     // registered plaintext consumers
 50     final Map&lt;Byte, SSLConsumer&gt;    consumers;
 51     final AccessControlContext      acc;
 52 
 53     final SSLContextImpl            sslContext;
 54     final SSLConfiguration          sslConfig;
 55     final InputRecord               inputRecord;
 56     final OutputRecord              outputRecord;
 57 
 58     // connection status
 59     boolean                         isUnsureMode;
 60     boolean                         isNegotiated = false;
 61     boolean                         isBroken = false;
 62     boolean                         isInputCloseNotified = false;
 63     boolean                         peerUserCanceled = false;
 64     Exception                       closeReason = null;
 65     Exception                       delegatedThrown = null;
 66 
<a name="1" id="anc1"></a><span class="line-added"> 67     // For TLS 1.3 full handshake, the last handshake flight could be wrapped</span>
<span class="line-added"> 68     // and encrypted in one record and delegated task would be used.  There is</span>
<span class="line-added"> 69     // no chance to return FINISHED handshake status with SSLEngine.(un)wrap().</span>
<span class="line-added"> 70     // However, per the HandshakeStatus.FINISHED specification, this value is</span>
<span class="line-added"> 71     // only generated by a call to SSLEngine.wrap()/unwrap() and it is never</span>
<span class="line-added"> 72     // generated by SSLEngine.getHandshakeStatus().</span>
<span class="line-added"> 73     //</span>
<span class="line-added"> 74     // In order to workaround this case for TLS 1.3, the FINISHED status is</span>
<span class="line-added"> 75     // present with SSLEngine.wrap() while delivering of the NewSessionTicket</span>
<span class="line-added"> 76     // post-handshake message.  If this post-handshake message is not needed,</span>
<span class="line-added"> 77     // a follow-on SSLEngine.wrap() should be called to indicate the FINISHED</span>
<span class="line-added"> 78     // handshake status.  Although this special SSLEngine.wrap() should not</span>
<span class="line-added"> 79     // consume or produce any application or network data.</span>
<span class="line-added"> 80     boolean                         needHandshakeFinishedStatus = false;</span>
<span class="line-added"> 81     boolean                         hasDelegatedFinished = false;</span>
<span class="line-added"> 82 </span>
<span class="line-added"> 83 </span>
 84     // negotiated security parameters
 85     SSLSessionImpl                  conSession;
 86     ProtocolVersion                 protocolVersion;
 87     String                          applicationProtocol= null;
 88 
 89     // handshake context
 90     HandshakeContext                handshakeContext = null;
 91 
 92     // connection reserved status for handshake.
 93     boolean                         secureRenegotiation = false;
 94     byte[]                          clientVerifyData;
 95     byte[]                          serverVerifyData;
 96 
 97     // connection sensitive configuration
 98     List&lt;NamedGroup&gt;                serverRequestedNamedGroups;
 99 
100     CipherSuite cipherSuite;
101     private static final byte[] emptyByteArray = new byte[0];
102 
103     // Please never use the transport parameter other than storing a
104     // reference to this object.
105     //
106     // Called by SSLEngineImpl
107     TransportContext(SSLContextImpl sslContext, SSLTransport transport,
108             InputRecord inputRecord, OutputRecord outputRecord) {
109         this(sslContext, transport, new SSLConfiguration(sslContext, false),
110                 inputRecord, outputRecord, true);
111     }
112 
113     // Please never use the transport parameter other than storing a
114     // reference to this object.
115     //
116     // Called by SSLSocketImpl
117     TransportContext(SSLContextImpl sslContext, SSLTransport transport,
118             InputRecord inputRecord, OutputRecord outputRecord,
119             boolean isClientMode) {
120         this(sslContext, transport,
121                 new SSLConfiguration(sslContext, isClientMode),
122                 inputRecord, outputRecord, false);
123     }
124 
125     // Please never use the transport parameter other than storing a
126     // reference to this object.
127     //
128     // Called by SSLSocketImpl with an existing SSLConfig
129     TransportContext(SSLContextImpl sslContext, SSLTransport transport,
130             SSLConfiguration sslConfig,
131             InputRecord inputRecord, OutputRecord outputRecord) {
132         this(sslContext, transport, (SSLConfiguration)sslConfig.clone(),
133                 inputRecord, outputRecord, false);
134     }
135 
136     private TransportContext(SSLContextImpl sslContext, SSLTransport transport,
137             SSLConfiguration sslConfig, InputRecord inputRecord,
138             OutputRecord outputRecord, boolean isUnsureMode) {
139         this.transport = transport;
140         this.sslContext = sslContext;
141         this.inputRecord = inputRecord;
142         this.outputRecord = outputRecord;
143         this.sslConfig = sslConfig;
144         if (this.sslConfig.maximumPacketSize == 0) {
145             this.sslConfig.maximumPacketSize = outputRecord.getMaxPacketSize();
146         }
147         this.isUnsureMode = isUnsureMode;
148 
149         // initial security parameters
150         this.conSession = new SSLSessionImpl();
151         this.protocolVersion = this.sslConfig.maximumProtocolVersion;
152         this.clientVerifyData = emptyByteArray;
153         this.serverVerifyData = emptyByteArray;
154 
155         this.acc = AccessController.getContext();
156         this.consumers = new HashMap&lt;&gt;();
157     }
158 
159     // Dispatch plaintext to a specific consumer.
160     void dispatch(Plaintext plaintext) throws IOException {
161         if (plaintext == null) {
162             return;
163         }
164 
165         ContentType ct = ContentType.valueOf(plaintext.contentType);
166         if (ct == null) {
167             throw fatal(Alert.UNEXPECTED_MESSAGE,
168                 &quot;Unknown content type: &quot; + plaintext.contentType);
169         }
170 
171         switch (ct) {
172             case HANDSHAKE:
173                 byte type = HandshakeContext.getHandshakeType(this,
174                         plaintext);
175                 if (handshakeContext == null) {
176                     if (type == SSLHandshake.KEY_UPDATE.id ||
177                             type == SSLHandshake.NEW_SESSION_TICKET.id) {
178                         if (!isNegotiated) {
179                             throw fatal(Alert.UNEXPECTED_MESSAGE,
180                                     &quot;Unexpected unnegotiated post-handshake&quot; +
181                                             &quot; message: &quot; +
182                                             SSLHandshake.nameOf(type));
183                         }
184 
185                         if (!PostHandshakeContext.isConsumable(this, type)) {
186                             throw fatal(Alert.UNEXPECTED_MESSAGE,
187                                     &quot;Unexpected post-handshake message: &quot; +
188                                     SSLHandshake.nameOf(type));
189                         }
190 
191                         handshakeContext = new PostHandshakeContext(this);
192                     } else {
193                         handshakeContext = sslConfig.isClientMode ?
194                                 new ClientHandshakeContext(sslContext, this) :
195                                 new ServerHandshakeContext(sslContext, this);
196                         outputRecord.initHandshaker();
197                     }
198                 }
199                 handshakeContext.dispatch(type, plaintext);
200                 break;
201             case ALERT:
202                 Alert.alertConsumer.consume(this, plaintext.fragment);
203                 break;
204             default:
205                 SSLConsumer consumer = consumers.get(plaintext.contentType);
206                 if (consumer != null) {
207                     consumer.consume(this, plaintext.fragment);
208                 } else {
209                     throw fatal(Alert.UNEXPECTED_MESSAGE,
210                         &quot;Unexpected content: &quot; + plaintext.contentType);
211                 }
212         }
213     }
214 
215     void kickstart() throws IOException {
216         if (isUnsureMode) {
217             throw new IllegalStateException(&quot;Client/Server mode not yet set.&quot;);
218         }
219 
220         if (outputRecord.isClosed() || inputRecord.isClosed() || isBroken) {
221             if (closeReason != null) {
222                 throw new SSLException(
223                         &quot;Cannot kickstart, the connection is broken or closed&quot;,
224                         closeReason);
225             } else {
226                 throw new SSLException(
227                         &quot;Cannot kickstart, the connection is broken or closed&quot;);
228             }
229         }
230 
231         // initialize the handshaker if necessary
232         if (handshakeContext == null) {
233             //  TLS1.3 post-handshake
234             if (isNegotiated &amp;&amp; protocolVersion.useTLS13PlusSpec()) {
235                 handshakeContext = new PostHandshakeContext(this);
236             } else {
237                 handshakeContext = sslConfig.isClientMode ?
238                         new ClientHandshakeContext(sslContext, this) :
239                         new ServerHandshakeContext(sslContext, this);
240                 outputRecord.initHandshaker();
241             }
242         }
243 
244         // kickstart the handshake if needed
245         //
246         // Need no kickstart message on server side unless the connection
247         // has been established.
248         if(isNegotiated || sslConfig.isClientMode) {
249            handshakeContext.kickstart();
250         }
251     }
252 
253     boolean isPostHandshakeContext() {
254         return handshakeContext != null &amp;&amp;
255                 (handshakeContext instanceof PostHandshakeContext);
256     }
257 
258     // Note: Don&#39;t use this method for close_nofity, use closeNotify() instead.
259     void warning(Alert alert) {
260         // For initial handshaking, don&#39;t send a warning alert message to peer
261         // if handshaker has not started.
262         if (isNegotiated || handshakeContext != null) {
263             try {
264                 outputRecord.encodeAlert(Alert.Level.WARNING.level, alert.id);
265             } catch (IOException ioe) {
266                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
267                     SSLLogger.warning(
268                         &quot;Warning: failed to send warning alert &quot; + alert, ioe);
269                 }
270             }
271         }
272     }
273 
274     // Note: close_notify is delivered as a warning alert.
275     void closeNotify(boolean isUserCanceled) throws IOException {
276         // Socket transport is special because of the SO_LINGER impact.
277         if (transport instanceof SSLSocketImpl) {
278             ((SSLSocketImpl)transport).closeNotify(isUserCanceled);
279         } else {
280             // Need a lock here so that the user_canceled alert and the
281             // close_notify alert can be delivered together.
282             outputRecord.recordLock.lock();
283             try {
284                 try {
285                     // send a user_canceled alert if needed.
286                     if (isUserCanceled) {
287                         warning(Alert.USER_CANCELED);
288                     }
289 
290                     // send a close_notify alert
291                     warning(Alert.CLOSE_NOTIFY);
292                 } finally {
293                     outputRecord.close();
294                 }
295             } finally {
296                 outputRecord.recordLock.unlock();
297             }
298         }
299     }
300 
301     SSLException fatal(Alert alert,
302             String diagnostic) throws SSLException {
303         return fatal(alert, diagnostic, null);
304     }
305 
306     SSLException fatal(Alert alert, Throwable cause) throws SSLException {
307         return fatal(alert, null, cause);
308     }
309 
310     SSLException fatal(Alert alert,
311             String diagnostic, Throwable cause) throws SSLException {
312         return fatal(alert, diagnostic, false, cause);
313     }
314 
315     // Note: close_notify is not delivered via fatal() methods.
316     SSLException fatal(Alert alert, String diagnostic,
317             boolean recvFatalAlert, Throwable cause) throws SSLException {
318         // If we&#39;ve already shutdown because of an error, there is nothing we
319         // can do except rethrow the exception.
320         //
321         // Most exceptions seen here will be SSLExceptions. We may find the
322         // occasional Exception which hasn&#39;t been converted to a SSLException,
323         // so we&#39;ll do it here.
324         if (closeReason != null) {
325             if (cause == null) {
326                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
327                     SSLLogger.warning(
328                             &quot;Closed transport, general or untracked problem&quot;);
329                 }
330                 throw alert.createSSLException(
331                         &quot;Closed transport, general or untracked problem&quot;);
332             }
333 
334             if (cause instanceof SSLException) {
335                 throw (SSLException)cause;
336             } else {    // unlikely, but just in case.
337                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
338                     SSLLogger.warning(
339                             &quot;Closed transport, unexpected rethrowing&quot;, cause);
340                 }
341                 throw alert.createSSLException(&quot;Unexpected rethrowing&quot;, cause);
342             }
343         }
344 
345         // If we have no further information, make a general-purpose
346         // message for folks to see.  We generally have one or the other.
347         if (diagnostic == null) {
348             if (cause == null) {
349                 diagnostic = &quot;General/Untracked problem&quot;;
350             } else {
351                 diagnostic = cause.getMessage();
352             }
353         }
354 
355         if (cause == null) {
356             cause = alert.createSSLException(diagnostic);
357         }
358 
359         // shutdown the transport
360         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
361             SSLLogger.severe(&quot;Fatal (&quot; + alert + &quot;): &quot; + diagnostic, cause);
362         }
363 
364         // remember the close reason
365         if (cause instanceof SSLException) {
366             closeReason = (SSLException)cause;
367         } else {
368             // Including RuntimeException, but we&#39;ll throw those down below.
369             closeReason = alert.createSSLException(diagnostic, cause);
370         }
371 
372         // close inbound
373         try {
374             inputRecord.close();
375         } catch (IOException ioe) {
376             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
377                 SSLLogger.warning(&quot;Fatal: input record closure failed&quot;, ioe);
378             }
379 
380             closeReason.addSuppressed(ioe);
381         }
382 
383         // invalidate the session
384         if (conSession != null) {
385             conSession.invalidate();
386         }
387 
388         if (handshakeContext != null &amp;&amp;
389                 handshakeContext.handshakeSession != null) {
390             handshakeContext.handshakeSession.invalidate();
391         }
392 
393         // send fatal alert
394         //
395         // If we haven&#39;t even started handshaking yet, or we are the recipient
396         // of a fatal alert, no need to generate a fatal close alert.
397         if (!recvFatalAlert &amp;&amp; !isOutboundClosed() &amp;&amp; !isBroken &amp;&amp;
398                 (isNegotiated || handshakeContext != null)) {
399             try {
400                 outputRecord.encodeAlert(Alert.Level.FATAL.level, alert.id);
401             } catch (IOException ioe) {
402                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
403                     SSLLogger.warning(
404                         &quot;Fatal: failed to send fatal alert &quot; + alert, ioe);
405                 }
406 
407                 closeReason.addSuppressed(ioe);
408             }
409         }
410 
411         // close outbound
412         try {
413             outputRecord.close();
414         } catch (IOException ioe) {
415             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
416                 SSLLogger.warning(&quot;Fatal: output record closure failed&quot;, ioe);
417             }
418 
419             closeReason.addSuppressed(ioe);
420         }
421 
422         // terminate the handshake context
423         if (handshakeContext != null) {
424             handshakeContext = null;
425         }
426 
427         // terminate the transport
428         try {
429             transport.shutdown();
430         } catch (IOException ioe) {
431             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
432                 SSLLogger.warning(&quot;Fatal: transport closure failed&quot;, ioe);
433             }
434 
435             closeReason.addSuppressed(ioe);
436         } finally {
437             isBroken = true;
438         }
439 
440         if (closeReason instanceof SSLException) {
441             throw (SSLException)closeReason;
442         } else {
443             throw (RuntimeException)closeReason;
444         }
445     }
446 
447     void setUseClientMode(boolean useClientMode) {
448         // Once handshaking has begun, the mode can not be reset for the
449         // life of this engine.
450         if (handshakeContext != null || isNegotiated) {
451             throw new IllegalArgumentException(
452                     &quot;Cannot change mode after SSL traffic has started&quot;);
453         }
454 
455         /*
456          * If we need to change the client mode and the enabled
457          * protocols and cipher suites haven&#39;t specifically been
458          * set by the user, change them to the corresponding
459          * default ones.
460          */
461         if (sslConfig.isClientMode != useClientMode) {
462             if (sslContext.isDefaultProtocolVesions(
463                     sslConfig.enabledProtocols)) {
464                 sslConfig.enabledProtocols =
465                         sslContext.getDefaultProtocolVersions(!useClientMode);
466             }
467 
468             if (sslContext.isDefaultCipherSuiteList(
469                     sslConfig.enabledCipherSuites)) {
470                 sslConfig.enabledCipherSuites =
471                         sslContext.getDefaultCipherSuites(!useClientMode);
472             }
473 
474             sslConfig.toggleClientMode();
475         }
476 
477         isUnsureMode = false;
478     }
479 
480     // The OutputRecord is closed and not buffered output record.
481     boolean isOutboundDone() {
482         return outputRecord.isClosed() &amp;&amp; outputRecord.isEmpty();
483     }
484 
485     // The OutputRecord is closed, but buffered output record may be still
486     // waiting for delivery to the underlying connection.
487     boolean isOutboundClosed() {
488         return outputRecord.isClosed();
489     }
490 
491     boolean isInboundClosed() {
492         return inputRecord.isClosed();
493     }
494 
495     // Close inbound, no more data should be delivered to the underlying
496     // transportation connection.
497     void closeInbound() throws SSLException {
498         if (isInboundClosed()) {
499             return;
500         }
501 
502         try {
503             // Important note: check if the initial handshake is started at
504             // first so that the passiveInboundClose() implementation need not
505             // to consider the case any more.
506             if (!isInputCloseNotified) {
507                 // the initial handshake is not started
508                 initiateInboundClose();
509             } else {
510                 passiveInboundClose();
511             }
512         } catch (IOException ioe) {
513             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
514                 SSLLogger.warning(&quot;inbound closure failed&quot;, ioe);
515             }
516         }
517     }
518 
519     // Close the connection passively.  The closure could be kickoff by
520     // receiving a close_notify alert or reaching end_of_file of the socket.
521     //
522     // Note that this method is called only if the initial handshake has
523     // started or completed.
524     private void passiveInboundClose() throws IOException {
525         if (!isInboundClosed()) {
526             inputRecord.close();
527         }
528 
529         // For TLS 1.2 and prior version, it is required to respond with
530         // a close_notify alert of its own and close down the connection
531         // immediately, discarding any pending writes.
532         if (!isOutboundClosed()) {
533             boolean needCloseNotify = SSLConfiguration.acknowledgeCloseNotify;
534             if (!needCloseNotify) {
535                 if (isNegotiated) {
536                     if (!protocolVersion.useTLS13PlusSpec()) {
537                         needCloseNotify = true;
538                     }
539                 } else if (handshakeContext != null) {  // initial handshake
540                     ProtocolVersion pv = handshakeContext.negotiatedProtocol;
541                     if (pv == null || (!pv.useTLS13PlusSpec())) {
542                         needCloseNotify = true;
543                     }
544                 }
545             }
546 
547             if (needCloseNotify) {
548                 closeNotify(false);
549             }
550         }
551     }
552 
553     // Initiate a inbound close when the handshake is not started.
554     private void initiateInboundClose() throws IOException {
555         if (!isInboundClosed()) {
556             inputRecord.close();
557         }
558     }
559 
560     // Close outbound, no more data should be received from the underlying
561     // transportation connection.
562     void closeOutbound() {
563         if (isOutboundClosed()) {
564             return;
565         }
566 
567         try {
568              initiateOutboundClose();
569         } catch (IOException ioe) {
570             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
571                 SSLLogger.warning(&quot;outbound closure failed&quot;, ioe);
572             }
573         }
574     }
575 
576     // Initiate a close by sending a close_notify alert.
577     private void initiateOutboundClose() throws IOException {
578         boolean useUserCanceled = false;
579         if (!isNegotiated &amp;&amp; (handshakeContext != null) &amp;&amp; !peerUserCanceled) {
580             // initial handshake
581             useUserCanceled = true;
582         }
583 
584         closeNotify(useUserCanceled);
585     }
586 
587     // Note; HandshakeStatus.FINISHED status is retrieved in other places.
588     HandshakeStatus getHandshakeStatus() {
589         if (!outputRecord.isEmpty()) {
590             // If no handshaking, special case to wrap alters or
591             // post-handshake messages.
592             return HandshakeStatus.NEED_WRAP;
593         } else if (isOutboundClosed() &amp;&amp; isInboundClosed()) {
594             return HandshakeStatus.NOT_HANDSHAKING;
595         } else if (handshakeContext != null) {
596             if (!handshakeContext.delegatedActions.isEmpty()) {
597                 return HandshakeStatus.NEED_TASK;
598             } else if (!isInboundClosed()) {
599                 if (sslContext.isDTLS() &amp;&amp;
600                         !inputRecord.isEmpty()) {
601                     return HandshakeStatus.NEED_UNWRAP_AGAIN;
602                 } else {
603                     return HandshakeStatus.NEED_UNWRAP;
604                 }
605             } else if (!isOutboundClosed()) {
606                 // Special case that the inbound was closed, but outbound open.
607                 return HandshakeStatus.NEED_WRAP;
608             }   // Otherwise, both inbound and outbound are closed.
<a name="2" id="anc2"></a><span class="line-added">609         } else if (needHandshakeFinishedStatus) {</span>
<span class="line-added">610             // Special case to get FINISHED status for TLS 1.3 full handshake.</span>
<span class="line-added">611             return HandshakeStatus.NEED_WRAP;</span>
612         }
613 
614         return HandshakeStatus.NOT_HANDSHAKING;
615     }
616 
617     HandshakeStatus finishHandshake() {
618         if (protocolVersion.useTLS13PlusSpec()) {
619             outputRecord.tc = this;
620             inputRecord.tc = this;
621             cipherSuite = handshakeContext.negotiatedCipherSuite;
622             inputRecord.readCipher.baseSecret =
623                     handshakeContext.baseReadSecret;
624             outputRecord.writeCipher.baseSecret =
625                     handshakeContext.baseWriteSecret;
626         }
627 
628         handshakeContext = null;
629         outputRecord.handshakeHash.finish();
630         inputRecord.finishHandshake();
631         outputRecord.finishHandshake();
632         isNegotiated = true;
633 
634         // Tell folk about handshake completion, but do it in a separate thread.
635         if (transport instanceof SSLSocket &amp;&amp;
636                 sslConfig.handshakeListeners != null &amp;&amp;
637                 !sslConfig.handshakeListeners.isEmpty()) {
638             HandshakeCompletedEvent hce =
639                 new HandshakeCompletedEvent((SSLSocket)transport, conSession);
640             Thread thread = new Thread(
641                 null,
642                 new NotifyHandshake(sslConfig.handshakeListeners, hce),
643                 &quot;HandshakeCompletedNotify-Thread&quot;,
644                 0,
645                 false);
646             thread.start();
647         }
648 
649         return HandshakeStatus.FINISHED;
650     }
651 
652     HandshakeStatus finishPostHandshake() {
653         handshakeContext = null;
654 
655         // Note: May need trigger handshake completion even for post-handshake
656         // authentication in the future.
657 
658         return HandshakeStatus.FINISHED;
659     }
660 
661     // A separate thread is allocated to deliver handshake completion
662     // events.
663     private static class NotifyHandshake implements Runnable {
664         private final Set&lt;Map.Entry&lt;HandshakeCompletedListener,
665                 AccessControlContext&gt;&gt; targets;         // who gets notified
666         private final HandshakeCompletedEvent event;    // the notification
667 
668         NotifyHandshake(
669                 Map&lt;HandshakeCompletedListener,AccessControlContext&gt; listeners,
670                 HandshakeCompletedEvent event) {
671             this.targets = new HashSet&lt;&gt;(listeners.entrySet());     // clone
672             this.event = event;
673         }
674 
675         @Override
676         public void run() {
677             // Don&#39;t need to synchronize, as it only runs in one thread.
678             for (Map.Entry&lt;HandshakeCompletedListener,
679                     AccessControlContext&gt; entry : targets) {
680                 final HandshakeCompletedListener listener = entry.getKey();
681                 AccessControlContext acc = entry.getValue();
682                 AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
683                     @Override
684                     public Void run() {
685                         listener.handshakeCompleted(event);
686                         return null;
687                     }
688                 }, acc);
689             }
690         }
691     }
692 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
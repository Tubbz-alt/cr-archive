<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/javax/crypto/Cipher.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.crypto;
  27 
  28 import java.util.*;
  29 import java.util.concurrent.ConcurrentHashMap;
  30 import java.util.concurrent.ConcurrentMap;
  31 import java.util.regex.*;
  32 
  33 
  34 import java.security.*;
  35 import java.security.Provider.Service;
  36 import java.security.spec.AlgorithmParameterSpec;
  37 import java.security.spec.InvalidParameterSpecException;
  38 import java.security.cert.Certificate;
  39 import java.security.cert.X509Certificate;
  40 
  41 import javax.crypto.spec.*;
  42 
  43 import java.nio.ByteBuffer;
  44 import java.nio.ReadOnlyBufferException;
  45 
  46 import sun.security.util.Debug;
  47 import sun.security.jca.*;
<a name="2" id="anc2"></a>
  48 
  49 /**
  50  * This class provides the functionality of a cryptographic cipher for
  51  * encryption and decryption. It forms the core of the Java Cryptographic
  52  * Extension (JCE) framework.
  53  *
  54  * &lt;p&gt;In order to create a Cipher object, the application calls the
  55  * Cipher&#39;s {@code getInstance} method, and passes the name of the
  56  * requested &lt;i&gt;transformation&lt;/i&gt; to it. Optionally, the name of a provider
  57  * may be specified.
  58  *
  59  * &lt;p&gt;A &lt;i&gt;transformation&lt;/i&gt; is a string that describes the operation (or
  60  * set of operations) to be performed on the given input, to produce some
  61  * output. A transformation always includes the name of a cryptographic
  62  * algorithm (e.g., &lt;i&gt;AES&lt;/i&gt;), and may be followed by a feedback mode and
  63  * padding scheme.
  64  *
  65  * &lt;p&gt; A transformation is of the form:
  66  *
  67  * &lt;ul&gt;
  68  * &lt;li&gt;&quot;&lt;i&gt;algorithm/mode/padding&lt;/i&gt;&quot; or
  69  *
  70  * &lt;li&gt;&quot;&lt;i&gt;algorithm&lt;/i&gt;&quot;
  71  * &lt;/ul&gt;
  72  *
  73  * &lt;P&gt; (in the latter case,
  74  * provider-specific default values for the mode and padding scheme are used).
  75  * For example, the following is a valid transformation:
  76  *
  77  * &lt;pre&gt;
  78  *     Cipher c = Cipher.getInstance(&quot;&lt;i&gt;AES/CBC/PKCS5Padding&lt;/i&gt;&quot;);
  79  * &lt;/pre&gt;
  80  *
  81  * Using modes such as {@code CFB} and {@code OFB}, block
  82  * ciphers can encrypt data in units smaller than the cipher&#39;s actual
  83  * block size.  When requesting such a mode, you may optionally specify
  84  * the number of bits to be processed at a time by appending this number
  85  * to the mode name as shown in the &quot;{@code AES/CFB8/NoPadding}&quot; and
  86  * &quot;{@code AES/OFB32/PKCS5Padding}&quot; transformations. If no such
  87  * number is specified, a provider-specific default is used.
  88  * (See the
  89  * {@extLink security_guide_jdk_providers JDK Providers Documentation}
  90  * for the JDK Providers default values.)
  91  * Thus, block ciphers can be turned into byte-oriented stream ciphers by
  92  * using an 8 bit mode such as CFB8 or OFB8.
  93  * &lt;p&gt;
  94  * Modes such as Authenticated Encryption with Associated Data (AEAD)
  95  * provide authenticity assurances for both confidential data and
  96  * Additional Associated Data (AAD) that is not encrypted.  (Please see
  97  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc5116.txt&quot;&gt; RFC 5116 &lt;/a&gt; for more
  98  * information on AEAD and AAD algorithms such as GCM/CCM.) Both
  99  * confidential and AAD data can be used when calculating the
 100  * authentication tag (similar to a {@link Mac}).  This tag is appended
 101  * to the ciphertext during encryption, and is verified on decryption.
 102  * &lt;p&gt;
 103  * AEAD modes such as GCM/CCM perform all AAD authenticity calculations
 104  * before starting the ciphertext authenticity calculations.  To avoid
 105  * implementations having to internally buffer ciphertext, all AAD data
 106  * must be supplied to GCM/CCM implementations (via the {@code updateAAD}
 107  * methods) &lt;b&gt;before&lt;/b&gt; the ciphertext is processed (via
 108  * the {@code update} and {@code doFinal} methods).
 109  * &lt;p&gt;
 110  * Note that GCM mode has a uniqueness requirement on IVs used in
 111  * encryption with a given key. When IVs are repeated for GCM
 112  * encryption, such usages are subject to forgery attacks. Thus, after
 113  * each encryption operation using GCM mode, callers should re-initialize
 114  * the cipher objects with GCM parameters which have a different IV value.
 115  * &lt;pre&gt;
 116  *     GCMParameterSpec s = ...;
 117  *     cipher.init(..., s);
 118  *
 119  *     // If the GCM parameters were generated by the provider, it can
 120  *     // be retrieved by:
 121  *     // cipher.getParameters().getParameterSpec(GCMParameterSpec.class);
 122  *
 123  *     cipher.updateAAD(...);  // AAD
 124  *     cipher.update(...);     // Multi-part update
 125  *     cipher.doFinal(...);    // conclusion of operation
 126  *
 127  *     // Use a different IV value for every encryption
 128  *     byte[] newIv = ...;
 129  *     s = new GCMParameterSpec(s.getTLen(), newIv);
 130  *     cipher.init(..., s);
 131  *     ...
 132  *
 133  * &lt;/pre&gt;
 134  * The ChaCha20 and ChaCha20-Poly1305 algorithms have a similar requirement
 135  * for unique nonces with a given key.  After each encryption or decryption
 136  * operation, callers should re-initialize their ChaCha20 or ChaCha20-Poly1305
 137  * ciphers with parameters that specify a different nonce value.  Please
 138  * see &lt;a href=&quot;https://tools.ietf.org/html/rfc7539&quot;&gt;RFC 7539&lt;/a&gt; for more
 139  * information on the ChaCha20 and ChaCha20-Poly1305 algorithms.
 140  * &lt;p&gt;
 141  * Every implementation of the Java platform is required to support
 142  * the following standard {@code Cipher} transformations with the keysizes
 143  * in parentheses:
 144  * &lt;ul&gt;
 145  * &lt;li&gt;{@code AES/CBC/NoPadding} (128)&lt;/li&gt;
 146  * &lt;li&gt;{@code AES/CBC/PKCS5Padding} (128)&lt;/li&gt;
 147  * &lt;li&gt;{@code AES/ECB/NoPadding} (128)&lt;/li&gt;
 148  * &lt;li&gt;{@code AES/ECB/PKCS5Padding} (128)&lt;/li&gt;
 149  * &lt;li&gt;{@code AES/GCM/NoPadding} (128)&lt;/li&gt;
 150  * &lt;li&gt;{@code DESede/CBC/NoPadding} (168)&lt;/li&gt;
 151  * &lt;li&gt;{@code DESede/CBC/PKCS5Padding} (168)&lt;/li&gt;
 152  * &lt;li&gt;{@code DESede/ECB/NoPadding} (168)&lt;/li&gt;
 153  * &lt;li&gt;{@code DESede/ECB/PKCS5Padding} (168)&lt;/li&gt;
 154  * &lt;li&gt;{@code RSA/ECB/PKCS1Padding} (1024, 2048)&lt;/li&gt;
 155  * &lt;li&gt;{@code RSA/ECB/OAEPWithSHA-1AndMGF1Padding} (1024, 2048)&lt;/li&gt;
 156  * &lt;li&gt;{@code RSA/ECB/OAEPWithSHA-256AndMGF1Padding} (1024, 2048)&lt;/li&gt;
 157  * &lt;/ul&gt;
 158  * These transformations are described in the
 159  * &lt;a href=&quot;{@docRoot}/../specs/security/standard-names.html#cipher-algorithm-names&quot;&gt;
 160  * Cipher section&lt;/a&gt; of the
 161  * Java Security Standard Algorithm Names Specification.
 162  * Consult the release documentation for your implementation to see if any
 163  * other transformations are supported.
 164  *
 165  * @author Jan Luehe
 166  * @see KeyGenerator
 167  * @see SecretKey
 168  * @since 1.4
 169  */
 170 
 171 public class Cipher {
 172 
 173     private static final Debug debug =
 174                         Debug.getInstance(&quot;jca&quot;, &quot;Cipher&quot;);
 175 
 176     private static final Debug pdebug =
 177                         Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 178     private static final boolean skipDebug =
 179         Debug.isOn(&quot;engine=&quot;) &amp;&amp; !Debug.isOn(&quot;cipher&quot;);
 180 
 181     /**
 182      * Constant used to initialize cipher to encryption mode.
 183      */
 184     public static final int ENCRYPT_MODE = 1;
 185 
 186     /**
 187      * Constant used to initialize cipher to decryption mode.
 188      */
 189     public static final int DECRYPT_MODE = 2;
 190 
 191     /**
 192      * Constant used to initialize cipher to key-wrapping mode.
 193      */
 194     public static final int WRAP_MODE = 3;
 195 
 196     /**
 197      * Constant used to initialize cipher to key-unwrapping mode.
 198      */
 199     public static final int UNWRAP_MODE = 4;
 200 
 201     /**
 202      * Constant used to indicate the to-be-unwrapped key is a &quot;public key&quot;.
 203      */
 204     public static final int PUBLIC_KEY = 1;
 205 
 206     /**
 207      * Constant used to indicate the to-be-unwrapped key is a &quot;private key&quot;.
 208      */
 209     public static final int PRIVATE_KEY = 2;
 210 
 211     /**
 212      * Constant used to indicate the to-be-unwrapped key is a &quot;secret key&quot;.
 213      */
 214     public static final int SECRET_KEY = 3;
 215 
 216     // The provider
 217     private Provider provider;
 218 
 219     // The provider implementation (delegate)
 220     private CipherSpi spi;
 221 
 222     // The transformation
 223     private String transformation;
 224 
 225     // Crypto permission representing the maximum allowable cryptographic
 226     // strength that this Cipher object can be used for. (The cryptographic
 227     // strength is a function of the keysize and algorithm parameters encoded
 228     // in the crypto permission.)
 229     private CryptoPermission cryptoPerm;
 230 
 231     // The exemption mechanism that needs to be enforced
 232     private ExemptionMechanism exmech;
 233 
 234     // Flag which indicates whether or not this cipher has been initialized
 235     private boolean initialized = false;
 236 
 237     // The operation mode - store the operation mode after the
 238     // cipher has been initialized.
 239     private int opmode = 0;
 240 
<a name="3" id="anc3"></a><span class="line-removed"> 241     // The OID for the KeyUsage extension in an X.509 v3 certificate</span>
<span class="line-removed"> 242     private static final String KEY_USAGE_EXTENSION_OID = &quot;2.5.29.15&quot;;</span>
<span class="line-removed"> 243 </span>
 244     // next SPI  to try in provider selection
 245     // null once provider is selected
 246     private CipherSpi firstSpi;
 247 
 248     // next service to try in provider selection
 249     // null once provider is selected
 250     private Service firstService;
 251 
 252     // remaining services to try in provider selection
 253     // null once provider is selected
 254     private Iterator&lt;Service&gt; serviceIterator;
 255 
 256     // list of transform Strings to lookup in the provider
 257     private List&lt;Transform&gt; transforms;
 258 
 259     private final Object lock;
 260 
 261     /**
 262      * Creates a Cipher object.
 263      *
 264      * @param cipherSpi the delegate
 265      * @param provider the provider
 266      * @param transformation the transformation
 267      * @throws NullPointerException if {@code provider} is {@code null}
 268      * @throws IllegalArgumentException if the supplied arguments
 269      *         are deemed invalid for constructing the Cipher object
 270      */
 271     protected Cipher(CipherSpi cipherSpi,
 272                      Provider provider,
 273                      String transformation) {
 274         // See bug 4341369 &amp; 4334690 for more info.
 275         // If the caller is trusted, then okay.
 276         // Otherwise throw an IllegalArgumentException.
 277         if (!JceSecurityManager.INSTANCE.isCallerTrusted(provider)) {
 278             throw new IllegalArgumentException(&quot;Cannot construct cipher&quot;);
 279         }
 280         this.spi = cipherSpi;
 281         this.provider = provider;
 282         this.transformation = transformation;
 283         this.cryptoPerm = CryptoAllPermission.INSTANCE;
 284         this.lock = null;
 285     }
 286 
 287     /**
 288      * Creates a Cipher object. Called internally and by NullCipher.
 289      *
 290      * @param cipherSpi the delegate
 291      * @param transformation the transformation
 292      */
 293     Cipher(CipherSpi cipherSpi, String transformation) {
 294         this.spi = cipherSpi;
 295         this.transformation = transformation;
 296         this.cryptoPerm = CryptoAllPermission.INSTANCE;
 297         this.lock = null;
 298     }
 299 
 300     private Cipher(CipherSpi firstSpi, Service firstService,
 301             Iterator&lt;Service&gt; serviceIterator, String transformation,
 302             List&lt;Transform&gt; transforms) {
 303         this.firstSpi = firstSpi;
 304         this.firstService = firstService;
 305         this.serviceIterator = serviceIterator;
 306         this.transforms = transforms;
 307         this.transformation = transformation;
 308         this.lock = new Object();
 309     }
 310 
 311     private static String[] tokenizeTransformation(String transformation)
 312             throws NoSuchAlgorithmException {
 313         if (transformation == null) {
 314             throw new NoSuchAlgorithmException(&quot;No transformation given&quot;);
 315         }
 316         /*
 317          * array containing the components of a Cipher transformation:
 318          *
 319          * index 0: algorithm component (e.g., AES)
 320          * index 1: feedback component (e.g., CFB)
 321          * index 2: padding component (e.g., PKCS5Padding)
 322          */
 323         String[] parts = new String[3];
 324         int count = 0;
 325         StringTokenizer parser = new StringTokenizer(transformation, &quot;/&quot;);
 326         try {
 327             while (parser.hasMoreTokens() &amp;&amp; count &lt; 3) {
 328                 parts[count++] = parser.nextToken().trim();
 329             }
 330             if (count == 0 || count == 2) {
 331                 throw new NoSuchAlgorithmException(&quot;Invalid transformation&quot;
 332                                                + &quot; format:&quot; +
 333                                                transformation);
 334             }
 335             // treats all subsequent tokens as part of padding
 336             if (count == 3 &amp;&amp; parser.hasMoreTokens()) {
 337                 parts[2] = parts[2] + parser.nextToken(&quot;\r\n&quot;);
 338             }
 339         } catch (NoSuchElementException e) {
 340             throw new NoSuchAlgorithmException(&quot;Invalid transformation &quot; +
 341                                            &quot;format:&quot; + transformation);
 342         }
 343         if ((parts[0] == null) || (parts[0].isEmpty())) {
 344             throw new NoSuchAlgorithmException(&quot;Invalid transformation:&quot; +
 345                                    &quot;algorithm not specified-&quot;
 346                                    + transformation);
 347         }
 348         return parts;
 349     }
 350 
 351     // Provider attribute name for supported chaining mode
 352     private static final String ATTR_MODE = &quot;SupportedModes&quot;;
 353     // Provider attribute name for supported padding names
 354     private static final String ATTR_PAD  = &quot;SupportedPaddings&quot;;
 355 
 356     // constants indicating whether the provider supports
 357     // a given mode or padding
 358     private static final int S_NO    = 0;       // does not support
 359     private static final int S_MAYBE = 1;       // unable to determine
 360     private static final int S_YES   = 2;       // does support
 361 
 362     /**
 363      * Nested class to deal with modes and paddings.
 364      */
 365     private static class Transform {
 366         // transform string to lookup in the provider
 367         final String transform;
 368         // the mode/padding suffix in upper case. for example, if the algorithm
 369         // to lookup is &quot;AES/CBC/PKCS5Padding&quot; suffix is &quot;/CBC/PKCS5PADDING&quot;
 370         // if lookup is &quot;AES&quot;, suffix is the empty string
 371         // needed because aliases prevent straight transform.equals()
 372         final String suffix;
 373         // value to pass to setMode() or null if no such call required
 374         final String mode;
 375         // value to pass to setPadding() or null if no such call required
 376         final String pad;
 377         Transform(String alg, String suffix, String mode, String pad) {
 378             this.transform = alg + suffix;
 379             this.suffix = suffix.toUpperCase(Locale.ENGLISH);
 380             this.mode = mode;
 381             this.pad = pad;
 382         }
 383         // set mode and padding for the given SPI
 384         void setModePadding(CipherSpi spi) throws NoSuchAlgorithmException,
 385                 NoSuchPaddingException {
 386             if (mode != null) {
 387                 spi.engineSetMode(mode);
 388             }
 389             if (pad != null) {
 390                 spi.engineSetPadding(pad);
 391             }
 392         }
 393         // check whether the given services supports the mode and
 394         // padding described by this Transform
 395         int supportsModePadding(Service s) {
 396             int smode = supportsMode(s);
 397             if (smode == S_NO) {
 398                 return smode;
 399             }
 400             int spad = supportsPadding(s);
 401             // our constants are defined so that Math.min() is a tri-valued AND
 402             return Math.min(smode, spad);
 403         }
 404 
 405         // separate methods for mode and padding
 406         // called directly by Cipher only to throw the correct exception
 407         int supportsMode(Service s) {
 408             return supports(s, ATTR_MODE, mode);
 409         }
 410         int supportsPadding(Service s) {
 411             return supports(s, ATTR_PAD, pad);
 412         }
 413 
 414         private static int supports(Service s, String attrName, String value) {
 415             if (value == null) {
 416                 return S_YES;
 417             }
 418             String regexp = s.getAttribute(attrName);
 419             if (regexp == null) {
 420                 return S_MAYBE;
 421             }
 422             return matches(regexp, value) ? S_YES : S_NO;
 423         }
 424 
 425         // ConcurrentMap&lt;String,Pattern&gt; for previously compiled patterns
 426         private static final ConcurrentMap&lt;String, Pattern&gt; patternCache =
 427             new ConcurrentHashMap&lt;String, Pattern&gt;();
 428 
 429         private static boolean matches(String regexp, String str) {
 430             Pattern pattern = patternCache.get(regexp);
 431             if (pattern == null) {
 432                 pattern = Pattern.compile(regexp);
 433                 patternCache.putIfAbsent(regexp, pattern);
 434             }
 435             return pattern.matcher(str.toUpperCase(Locale.ENGLISH)).matches();
 436         }
 437 
 438     }
 439 
 440     private static List&lt;Transform&gt; getTransforms(String transformation)
 441             throws NoSuchAlgorithmException {
 442         String[] parts = tokenizeTransformation(transformation);
 443 
 444         String alg = parts[0];
 445         String mode = parts[1];
 446         String pad = parts[2];
 447         if ((mode != null) &amp;&amp; (mode.isEmpty())) {
 448             mode = null;
 449         }
 450         if ((pad != null) &amp;&amp; (pad.isEmpty())) {
 451             pad = null;
 452         }
 453 
 454         if ((mode == null) &amp;&amp; (pad == null)) {
 455             // AES
 456             Transform tr = new Transform(alg, &quot;&quot;, null, null);
 457             return Collections.singletonList(tr);
 458         } else { // if ((mode != null) &amp;&amp; (pad != null)) {
 459             // AES/CBC/PKCS5Padding
 460             List&lt;Transform&gt; list = new ArrayList&lt;&gt;(4);
 461             list.add(new Transform(alg, &quot;/&quot; + mode + &quot;/&quot; + pad, null, null));
 462             list.add(new Transform(alg, &quot;/&quot; + mode, null, pad));
 463             list.add(new Transform(alg, &quot;//&quot; + pad, mode, null));
 464             list.add(new Transform(alg, &quot;&quot;, mode, pad));
 465             return list;
 466         }
 467     }
 468 
 469     // get the transform matching the specified service
 470     private static Transform getTransform(Service s,
 471                                           List&lt;Transform&gt; transforms) {
 472         String alg = s.getAlgorithm().toUpperCase(Locale.ENGLISH);
 473         for (Transform tr : transforms) {
 474             if (alg.endsWith(tr.suffix)) {
 475                 return tr;
 476             }
 477         }
 478         return null;
 479     }
 480 
 481     /**
 482      * Returns a {@code Cipher} object that implements the specified
 483      * transformation.
 484      *
 485      * &lt;p&gt; This method traverses the list of registered security Providers,
 486      * starting with the most preferred Provider.
 487      * A new Cipher object encapsulating the
 488      * CipherSpi implementation from the first
 489      * Provider that supports the specified algorithm is returned.
 490      *
 491      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 492      * the {@link Security#getProviders() Security.getProviders()} method.
 493      *
 494      * @apiNote
 495      * It is recommended to use a transformation that fully specifies the
 496      * algorithm, mode, and padding. By not doing so, the provider will
 497      * use a default for the mode and padding which may not meet the security
 498      * requirements of your application.
 499      *
 500      * @implNote
 501      * The JDK Reference Implementation additionally uses the
 502      * {@code jdk.security.provider.preferred}
 503      * {@link Security#getProperty(String) Security} property to determine
 504      * the preferred provider order for the specified algorithm. This
 505      * may be different than the order of providers returned by
 506      * {@link Security#getProviders() Security.getProviders()}.
 507      * See also the Cipher Transformations section of the {@extLink
 508      * security_guide_jdk_providers JDK Providers} document for information
 509      * on the transformation defaults used by JDK providers.
 510      *
 511      * @param transformation the name of the transformation, e.g.,
 512      * &lt;i&gt;AES/CBC/PKCS5Padding&lt;/i&gt;.
 513      * See the Cipher section in the &lt;a href=
 514      *   &quot;{@docRoot}/../specs/security/standard-names.html#cipher-algorithm-names&quot;&gt;
 515      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 516      * for information about standard transformation names.
 517      *
 518      * @return a cipher that implements the requested transformation
 519      *
 520      * @throws NoSuchAlgorithmException if {@code transformation}
 521      *         is {@code null}, empty, in an invalid format,
 522      *         or if no {@code Provider} supports a {@code CipherSpi}
 523      *         implementation for the specified algorithm
 524      *
 525      * @throws NoSuchPaddingException if {@code transformation}
 526      *         contains a padding scheme that is not available
 527      *
 528      * @see java.security.Provider
 529      */
 530     public static final Cipher getInstance(String transformation)
 531             throws NoSuchAlgorithmException, NoSuchPaddingException
 532     {
 533         if ((transformation == null) || transformation.isEmpty()) {
 534             throw new NoSuchAlgorithmException(&quot;Null or empty transformation&quot;);
 535         }
 536         List&lt;Transform&gt; transforms = getTransforms(transformation);
 537         List&lt;ServiceId&gt; cipherServices = new ArrayList&lt;&gt;(transforms.size());
 538         for (Transform transform : transforms) {
 539             cipherServices.add(new ServiceId(&quot;Cipher&quot;, transform.transform));
 540         }
 541         List&lt;Service&gt; services = GetInstance.getServices(cipherServices);
 542         // make sure there is at least one service from a signed provider
 543         // and that it can use the specified mode and padding
 544         Iterator&lt;Service&gt; t = services.iterator();
 545         Exception failure = null;
 546         while (t.hasNext()) {
 547             Service s = t.next();
 548             if (JceSecurity.canUseProvider(s.getProvider()) == false) {
 549                 continue;
 550             }
 551             Transform tr = getTransform(s, transforms);
 552             if (tr == null) {
 553                 // should never happen
 554                 continue;
 555             }
 556             int canuse = tr.supportsModePadding(s);
 557             if (canuse == S_NO) {
 558                 // does not support mode or padding we need, ignore
 559                 continue;
 560             }
 561             // S_YES, S_MAYBE
 562             // even when mode and padding are both supported, they
 563             // may not be used together, try out and see if it works
 564             try {
 565                 CipherSpi spi = (CipherSpi)s.newInstance(null);
 566                 tr.setModePadding(spi);
 567                 // specify null instead of spi for delayed provider selection
 568                 return new Cipher(null, s, t, transformation, transforms);
 569             } catch (Exception e) {
 570                 failure = e;
 571             }
 572         }
 573         throw new NoSuchAlgorithmException
 574             (&quot;Cannot find any provider supporting &quot; + transformation, failure);
 575     }
 576 
 577     /**
 578      * Returns a {@code Cipher} object that implements the specified
 579      * transformation.
 580      *
 581      * &lt;p&gt; A new Cipher object encapsulating the
 582      * CipherSpi implementation from the specified provider
 583      * is returned.  The specified provider must be registered
 584      * in the security provider list.
 585      *
 586      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 587      * the {@link Security#getProviders() Security.getProviders()} method.
 588      *
 589      * @apiNote
 590      * It is recommended to use a transformation that fully specifies the
 591      * algorithm, mode, and padding. By not doing so, the provider will
 592      * use a default for the mode and padding which may not meet the security
 593      * requirements of your application.
 594      *
 595      * @implNote
 596      * See the Cipher Transformations section of the {@extLink
 597      * security_guide_jdk_providers JDK Providers} document for information
 598      * on the transformation defaults used by JDK providers.
 599      *
 600      * @param transformation the name of the transformation,
 601      * e.g., &lt;i&gt;AES/CBC/PKCS5Padding&lt;/i&gt;.
 602      * See the Cipher section in the &lt;a href=
 603      *   &quot;{@docRoot}/../specs/security/standard-names.html#cipher-algorithm-names&quot;&gt;
 604      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 605      * for information about standard transformation names.
 606      *
 607      * @param provider the name of the provider.
 608      *
 609      * @return a cipher that implements the requested transformation
 610      *
 611      * @throws IllegalArgumentException if the {@code provider}
 612      *         is {@code null} or empty
 613      *
 614      * @throws NoSuchAlgorithmException if {@code transformation}
 615      *         is {@code null}, empty, in an invalid format,
 616      *         or if a {@code CipherSpi} implementation for the
 617      *         specified algorithm is not available from the specified
 618      *         provider
 619      *
 620      * @throws NoSuchPaddingException if {@code transformation}
 621      *         contains a padding scheme that is not available
 622      *
 623      * @throws NoSuchProviderException if the specified provider is not
 624      *         registered in the security provider list
 625      *
 626      * @see java.security.Provider
 627      */
 628     public static final Cipher getInstance(String transformation,
 629                                            String provider)
 630             throws NoSuchAlgorithmException, NoSuchProviderException,
 631             NoSuchPaddingException
 632     {
 633         if ((transformation == null) || transformation.isEmpty()) {
 634             throw new NoSuchAlgorithmException(&quot;Null or empty transformation&quot;);
 635         }
 636         if ((provider == null) || (provider.isEmpty())) {
 637             throw new IllegalArgumentException(&quot;Missing provider&quot;);
 638         }
 639         Provider p = Security.getProvider(provider);
 640         if (p == null) {
 641             throw new NoSuchProviderException(&quot;No such provider: &quot; +
 642                                               provider);
 643         }
 644         return getInstance(transformation, p);
 645     }
 646 
 647     private String getProviderName() {
 648         return (provider == null)  ? &quot;(no provider)&quot; : provider.getName();
 649     }
 650 
 651     /**
 652      * Returns a {@code Cipher} object that implements the specified
 653      * transformation.
 654      *
 655      * &lt;p&gt; A new Cipher object encapsulating the
 656      * CipherSpi implementation from the specified Provider
 657      * object is returned.  Note that the specified Provider object
 658      * does not have to be registered in the provider list.
 659      *
 660      * @apiNote
 661      * It is recommended to use a transformation that fully specifies the
 662      * algorithm, mode, and padding. By not doing so, the provider will
 663      * use a default for the mode and padding which may not meet the security
 664      * requirements of your application.
 665      *
 666      * @implNote
 667      * See the Cipher Transformations section of the {@extLink
 668      * security_guide_jdk_providers JDK Providers} document for information
 669      * on the transformation defaults used by JDK providers.
 670      *
 671      * @param transformation the name of the transformation,
 672      * e.g., &lt;i&gt;AES/CBC/PKCS5Padding&lt;/i&gt;.
 673      * See the Cipher section in the &lt;a href=
 674      *   &quot;{@docRoot}/../specs/security/standard-names.html#cipher-algorithm-names&quot;&gt;
 675      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 676      * for information about standard transformation names.
 677      *
 678      * @param provider the provider.
 679      *
 680      * @return a cipher that implements the requested transformation
 681      *
 682      * @throws IllegalArgumentException if the {@code provider}
 683      *         is {@code null}
 684      *
 685      * @throws NoSuchAlgorithmException if {@code transformation}
 686      *         is {@code null}, empty, in an invalid format,
 687      *         or if a {@code CipherSpi} implementation for the
 688      *         specified algorithm is not available from the specified
 689      *         {@code Provider} object
 690      *
 691      * @throws NoSuchPaddingException if {@code transformation}
 692      *         contains a padding scheme that is not available
 693      *
 694      * @see java.security.Provider
 695      */
 696     public static final Cipher getInstance(String transformation,
 697                                            Provider provider)
 698             throws NoSuchAlgorithmException, NoSuchPaddingException
 699     {
 700         if ((transformation == null) || transformation.isEmpty()) {
 701             throw new NoSuchAlgorithmException(&quot;Null or empty transformation&quot;);
 702         }
 703         if (provider == null) {
 704             throw new IllegalArgumentException(&quot;Missing provider&quot;);
 705         }
 706         Exception failure = null;
 707         List&lt;Transform&gt; transforms = getTransforms(transformation);
 708         boolean providerChecked = false;
 709         String paddingError = null;
 710         for (Transform tr : transforms) {
 711             Service s = provider.getService(&quot;Cipher&quot;, tr.transform);
 712             if (s == null) {
 713                 continue;
 714             }
 715             if (providerChecked == false) {
 716                 // for compatibility, first do the lookup and then verify
 717                 // the provider. this makes the difference between a NSAE
 718                 // and a SecurityException if the
 719                 // provider does not support the algorithm.
 720                 Exception ve = JceSecurity.getVerificationResult(provider);
 721                 if (ve != null) {
 722                     String msg = &quot;JCE cannot authenticate the provider &quot;
 723                         + provider.getName();
 724                     throw new SecurityException(msg, ve);
 725                 }
 726                 providerChecked = true;
 727             }
 728             if (tr.supportsMode(s) == S_NO) {
 729                 continue;
 730             }
 731             if (tr.supportsPadding(s) == S_NO) {
 732                 paddingError = tr.pad;
 733                 continue;
 734             }
 735             try {
 736                 CipherSpi spi = (CipherSpi)s.newInstance(null);
 737                 tr.setModePadding(spi);
 738                 Cipher cipher = new Cipher(spi, transformation);
 739                 cipher.provider = s.getProvider();
 740                 cipher.initCryptoPermission();
 741                 return cipher;
 742             } catch (Exception e) {
 743                 failure = e;
 744             }
 745         }
 746 
 747         // throw NoSuchPaddingException if the problem is with padding
 748         if (failure instanceof NoSuchPaddingException) {
 749             throw (NoSuchPaddingException)failure;
 750         }
 751         if (paddingError != null) {
 752             throw new NoSuchPaddingException
 753                 (&quot;Padding not supported: &quot; + paddingError);
 754         }
 755         throw new NoSuchAlgorithmException
 756                 (&quot;No such algorithm: &quot; + transformation, failure);
 757     }
 758 
 759     // If the requested crypto service is export-controlled,
 760     // determine the maximum allowable keysize.
 761     private void initCryptoPermission() throws NoSuchAlgorithmException {
 762         if (JceSecurity.isRestricted() == false) {
 763             cryptoPerm = CryptoAllPermission.INSTANCE;
 764             exmech = null;
 765             return;
 766         }
 767         cryptoPerm = getConfiguredPermission(transformation);
 768         // Instantiate the exemption mechanism (if required)
 769         String exmechName = cryptoPerm.getExemptionMechanism();
 770         if (exmechName != null) {
 771             exmech = ExemptionMechanism.getInstance(exmechName);
 772         }
 773     }
 774 
 775     // max number of debug warnings to print from chooseFirstProvider()
 776     private static int warnCount = 10;
 777 
 778     /**
 779      * Choose the Spi from the first provider available. Used if
 780      * delayed provider selection is not possible because init()
 781      * is not the first method called.
 782      */
 783     void chooseFirstProvider() {
 784         if (spi != null) {
 785             return;
 786         }
 787         synchronized (lock) {
 788             if (spi != null) {
 789                 return;
 790             }
 791             if (debug != null) {
 792                 int w = --warnCount;
 793                 if (w &gt;= 0) {
 794                     debug.println(&quot;Cipher.init() not first method &quot;
 795                         + &quot;called, disabling delayed provider selection&quot;);
 796                     if (w == 0) {
 797                         debug.println(&quot;Further warnings of this type will &quot;
 798                             + &quot;be suppressed&quot;);
 799                     }
 800                     new Exception(&quot;Call trace&quot;).printStackTrace();
 801                 }
 802             }
 803             Exception lastException = null;
 804             while ((firstService != null) || serviceIterator.hasNext()) {
 805                 Service s;
 806                 CipherSpi thisSpi;
 807                 if (firstService != null) {
 808                     s = firstService;
 809                     thisSpi = firstSpi;
 810                     firstService = null;
 811                     firstSpi = null;
 812                 } else {
 813                     s = serviceIterator.next();
 814                     thisSpi = null;
 815                 }
 816                 if (JceSecurity.canUseProvider(s.getProvider()) == false) {
 817                     continue;
 818                 }
 819                 Transform tr = getTransform(s, transforms);
 820                 if (tr == null) {
 821                     // should never happen
 822                     continue;
 823                 }
 824                 if (tr.supportsModePadding(s) == S_NO) {
 825                     continue;
 826                 }
 827                 try {
 828                     if (thisSpi == null) {
 829                         Object obj = s.newInstance(null);
 830                         if (obj instanceof CipherSpi == false) {
 831                             continue;
 832                         }
 833                         thisSpi = (CipherSpi)obj;
 834                     }
 835                     tr.setModePadding(thisSpi);
 836                     initCryptoPermission();
 837                     spi = thisSpi;
 838                     provider = s.getProvider();
 839                     // not needed any more
 840                     firstService = null;
 841                     serviceIterator = null;
 842                     transforms = null;
 843                     return;
 844                 } catch (Exception e) {
 845                     lastException = e;
 846                 }
 847             }
 848             ProviderException e = new ProviderException
 849                     (&quot;Could not construct CipherSpi instance&quot;);
 850             if (lastException != null) {
 851                 e.initCause(lastException);
 852             }
 853             throw e;
 854         }
 855     }
 856 
 857     private static final int I_KEY       = 1;
 858     private static final int I_PARAMSPEC = 2;
 859     private static final int I_PARAMS    = 3;
 860     private static final int I_CERT      = 4;
 861 
 862     private void implInit(CipherSpi thisSpi, int type, int opmode, Key key,
 863             AlgorithmParameterSpec paramSpec, AlgorithmParameters params,
 864             SecureRandom random) throws InvalidKeyException,
 865             InvalidAlgorithmParameterException {
 866         switch (type) {
 867         case I_KEY:
 868             checkCryptoPerm(thisSpi, key);
 869             thisSpi.engineInit(opmode, key, random);
 870             break;
 871         case I_PARAMSPEC:
 872             checkCryptoPerm(thisSpi, key, paramSpec);
 873             thisSpi.engineInit(opmode, key, paramSpec, random);
 874             break;
 875         case I_PARAMS:
 876             checkCryptoPerm(thisSpi, key, params);
 877             thisSpi.engineInit(opmode, key, params, random);
 878             break;
 879         case I_CERT:
 880             checkCryptoPerm(thisSpi, key);
 881             thisSpi.engineInit(opmode, key, random);
 882             break;
 883         default:
 884             throw new AssertionError(&quot;Internal Cipher error: &quot; + type);
 885         }
 886     }
 887 
 888     private void chooseProvider(int initType, int opmode, Key key,
 889             AlgorithmParameterSpec paramSpec,
 890             AlgorithmParameters params, SecureRandom random)
 891             throws InvalidKeyException, InvalidAlgorithmParameterException {
 892         synchronized (lock) {
 893             if (spi != null) {
 894                 implInit(spi, initType, opmode, key, paramSpec, params, random);
 895                 return;
 896             }
 897             Exception lastException = null;
 898             while ((firstService != null) || serviceIterator.hasNext()) {
 899                 Service s;
 900                 CipherSpi thisSpi;
 901                 if (firstService != null) {
 902                     s = firstService;
 903                     thisSpi = firstSpi;
 904                     firstService = null;
 905                     firstSpi = null;
 906                 } else {
 907                     s = serviceIterator.next();
 908                     thisSpi = null;
 909                 }
 910                 // if provider says it does not support this key, ignore it
 911                 if (s.supportsParameter(key) == false) {
 912                     continue;
 913                 }
 914                 if (JceSecurity.canUseProvider(s.getProvider()) == false) {
 915                     continue;
 916                 }
 917                 Transform tr = getTransform(s, transforms);
 918                 if (tr == null) {
 919                     // should never happen
 920                     continue;
 921                 }
 922                 if (tr.supportsModePadding(s) == S_NO) {
 923                     continue;
 924                 }
 925                 try {
 926                     if (thisSpi == null) {
 927                         thisSpi = (CipherSpi)s.newInstance(null);
 928                     }
 929                     tr.setModePadding(thisSpi);
 930                     initCryptoPermission();
 931                     implInit(thisSpi, initType, opmode, key, paramSpec,
 932                                                         params, random);
 933                     provider = s.getProvider();
 934                     this.spi = thisSpi;
 935                     firstService = null;
 936                     serviceIterator = null;
 937                     transforms = null;
 938                     return;
 939                 } catch (Exception e) {
 940                     // NoSuchAlgorithmException from newInstance()
 941                     // InvalidKeyException from init()
 942                     // RuntimeException (ProviderException) from init()
 943                     // SecurityException from crypto permission check
 944                     if (lastException == null) {
 945                         lastException = e;
 946                     }
 947                 }
 948             }
 949             // no working provider found, fail
 950             if (lastException instanceof InvalidKeyException) {
 951                 throw (InvalidKeyException)lastException;
 952             }
 953             if (lastException instanceof InvalidAlgorithmParameterException) {
 954                 throw (InvalidAlgorithmParameterException)lastException;
 955             }
 956             if (lastException instanceof RuntimeException) {
 957                 throw (RuntimeException)lastException;
 958             }
 959             String kName = (key != null) ? key.getClass().getName() : &quot;(null)&quot;;
 960             throw new InvalidKeyException
 961                 (&quot;No installed provider supports this key: &quot;
 962                 + kName, lastException);
 963         }
 964     }
 965 
 966     /**
 967      * Returns the provider of this {@code Cipher} object.
 968      *
 969      * @return the provider of this {@code Cipher} object
 970      */
 971     public final Provider getProvider() {
 972         chooseFirstProvider();
 973         return this.provider;
 974     }
 975 
 976     /**
 977      * Returns the algorithm name of this {@code Cipher} object.
 978      *
 979      * &lt;p&gt;This is the same name that was specified in one of the
 980      * {@code getInstance} calls that created this {@code Cipher}
 981      * object..
 982      *
 983      * @return the algorithm name of this {@code Cipher} object.
 984      */
 985     public final String getAlgorithm() {
 986         return this.transformation;
 987     }
 988 
 989     /**
 990      * Returns the block size (in bytes).
 991      *
 992      * @return the block size (in bytes), or 0 if the underlying algorithm is
 993      * not a block cipher
 994      */
 995     public final int getBlockSize() {
 996         chooseFirstProvider();
 997         return spi.engineGetBlockSize();
 998     }
 999 
1000     /**
1001      * Returns the length in bytes that an output buffer would need to be in
1002      * order to hold the result of the next {@code update} or
1003      * {@code doFinal} operation, given the input length
1004      * {@code inputLen} (in bytes).
1005      *
1006      * &lt;p&gt;This call takes into account any unprocessed (buffered) data from a
1007      * previous {@code update} call, padding, and AEAD tagging.
1008      *
1009      * &lt;p&gt;The actual output length of the next {@code update} or
1010      * {@code doFinal} call may be smaller than the length returned by
1011      * this method.
1012      *
1013      * @param inputLen the input length (in bytes)
1014      *
1015      * @return the required output buffer size (in bytes)
1016      *
1017      * @exception IllegalStateException if this cipher is in a wrong state
1018      * (e.g., has not yet been initialized)
1019      */
1020     public final int getOutputSize(int inputLen) {
1021 
1022         if (!initialized &amp;&amp; !(this instanceof NullCipher)) {
1023             throw new IllegalStateException(&quot;Cipher not initialized&quot;);
1024         }
1025         if (inputLen &lt; 0) {
1026             throw new IllegalArgumentException(&quot;Input size must be equal &quot; +
1027                                                &quot;to or greater than zero&quot;);
1028         }
1029         chooseFirstProvider();
1030         return spi.engineGetOutputSize(inputLen);
1031     }
1032 
1033     /**
1034      * Returns the initialization vector (IV) in a new buffer.
1035      *
1036      * &lt;p&gt;This is useful in the case where a random IV was created,
1037      * or in the context of password-based encryption or
1038      * decryption, where the IV is derived from a user-supplied password.
1039      *
1040      * @return the initialization vector in a new buffer, or null if the
1041      * underlying algorithm does not use an IV, or if the IV has not yet
1042      * been set.
1043      */
1044     public final byte[] getIV() {
1045         chooseFirstProvider();
1046         return spi.engineGetIV();
1047     }
1048 
1049     /**
1050      * Returns the parameters used with this cipher.
1051      *
1052      * &lt;p&gt;The returned parameters may be the same that were used to initialize
1053      * this cipher, or may contain a combination of default and random
1054      * parameter values used by the underlying cipher implementation if this
1055      * cipher requires algorithm parameters but was not initialized with any.
1056      *
1057      * @return the parameters used with this cipher, or null if this cipher
1058      * does not use any parameters.
1059      */
1060     public final AlgorithmParameters getParameters() {
1061         chooseFirstProvider();
1062         return spi.engineGetParameters();
1063     }
1064 
1065     /**
1066      * Returns the exemption mechanism object used with this cipher.
1067      *
1068      * @return the exemption mechanism object used with this cipher, or
1069      * null if this cipher does not use any exemption mechanism.
1070      */
1071     public final ExemptionMechanism getExemptionMechanism() {
1072         chooseFirstProvider();
1073         return exmech;
1074     }
1075 
1076     //
1077     // Crypto permission check code below
1078     //
1079     private void checkCryptoPerm(CipherSpi checkSpi, Key key)
1080             throws InvalidKeyException {
1081         if (cryptoPerm == CryptoAllPermission.INSTANCE) {
1082             return;
1083         }
1084         // Check if key size and default parameters are within legal limits
1085         AlgorithmParameterSpec params;
1086         try {
1087             params = getAlgorithmParameterSpec(checkSpi.engineGetParameters());
1088         } catch (InvalidParameterSpecException ipse) {
1089             throw new InvalidKeyException
1090                 (&quot;Unsupported default algorithm parameters&quot;);
1091         }
1092         if (!passCryptoPermCheck(checkSpi, key, params)) {
1093             throw new InvalidKeyException(
1094                 &quot;Illegal key size or default parameters&quot;);
1095         }
1096     }
1097 
1098     private void checkCryptoPerm(CipherSpi checkSpi, Key key,
1099             AlgorithmParameterSpec params) throws InvalidKeyException,
1100             InvalidAlgorithmParameterException {
1101         if (cryptoPerm == CryptoAllPermission.INSTANCE) {
1102             return;
1103         }
1104         // Determine keysize and check if it is within legal limits
1105         if (!passCryptoPermCheck(checkSpi, key, null)) {
1106             throw new InvalidKeyException(&quot;Illegal key size&quot;);
1107         }
1108         if ((params != null) &amp;&amp; (!passCryptoPermCheck(checkSpi, key, params))) {
1109             throw new InvalidAlgorithmParameterException(&quot;Illegal parameters&quot;);
1110         }
1111     }
1112 
1113     private void checkCryptoPerm(CipherSpi checkSpi, Key key,
1114             AlgorithmParameters params)
1115             throws InvalidKeyException, InvalidAlgorithmParameterException {
1116         if (cryptoPerm == CryptoAllPermission.INSTANCE) {
1117             return;
1118         }
1119         // Convert the specified parameters into specs and then delegate.
1120         AlgorithmParameterSpec pSpec;
1121         try {
1122             pSpec = getAlgorithmParameterSpec(params);
1123         } catch (InvalidParameterSpecException ipse) {
1124             throw new InvalidAlgorithmParameterException
1125                 (&quot;Failed to retrieve algorithm parameter specification&quot;);
1126         }
1127         checkCryptoPerm(checkSpi, key, pSpec);
1128     }
1129 
1130     private boolean passCryptoPermCheck(CipherSpi checkSpi, Key key,
1131                                         AlgorithmParameterSpec params)
1132             throws InvalidKeyException {
1133         String em = cryptoPerm.getExemptionMechanism();
1134         int keySize = checkSpi.engineGetKeySize(key);
1135         // Use the &quot;algorithm&quot; component of the cipher
1136         // transformation so that the perm check would
1137         // work when the key has the &quot;aliased&quot; algo.
1138         String algComponent;
1139         int index = transformation.indexOf(&#39;/&#39;);
1140         if (index != -1) {
1141             algComponent = transformation.substring(0, index);
1142         } else {
1143             algComponent = transformation;
1144         }
1145         CryptoPermission checkPerm =
1146             new CryptoPermission(algComponent, keySize, params, em);
1147 
1148         if (!cryptoPerm.implies(checkPerm)) {
1149             if (debug != null) {
1150                 debug.println(&quot;Crypto Permission check failed&quot;);
1151                 debug.println(&quot;granted: &quot; + cryptoPerm);
1152                 debug.println(&quot;requesting: &quot; + checkPerm);
1153             }
1154             return false;
1155         }
1156         if (exmech == null) {
1157             return true;
1158         }
1159         try {
1160             if (!exmech.isCryptoAllowed(key)) {
1161                 if (debug != null) {
1162                     debug.println(exmech.getName() + &quot; isn&#39;t enforced&quot;);
1163                 }
1164                 return false;
1165             }
1166         } catch (ExemptionMechanismException eme) {
1167             if (debug != null) {
1168                 debug.println(&quot;Cannot determine whether &quot;+
1169                               exmech.getName() + &quot; has been enforced&quot;);
1170                 eme.printStackTrace();
1171             }
1172             return false;
1173         }
1174         return true;
1175     }
1176 
1177     // check if opmode is one of the defined constants
1178     // throw InvalidParameterExeption if not
1179     private static void checkOpmode(int opmode) {
1180         if ((opmode &lt; ENCRYPT_MODE) || (opmode &gt; UNWRAP_MODE)) {
1181             throw new InvalidParameterException(&quot;Invalid operation mode&quot;);
1182         }
1183     }
1184 
1185     /**
1186      * Initializes this cipher with a key.
1187      *
1188      * &lt;p&gt;The cipher is initialized for one of the following four operations:
1189      * encryption, decryption, key wrapping or key unwrapping, depending
1190      * on the value of {@code opmode}.
1191      *
1192      * &lt;p&gt;If this cipher requires any algorithm parameters that cannot be
1193      * derived from the given {@code key}, the underlying cipher
1194      * implementation is supposed to generate the required parameters itself
1195      * (using provider-specific default or random values) if it is being
1196      * initialized for encryption or key wrapping, and raise an
1197      * {@code InvalidKeyException} if it is being
1198      * initialized for decryption or key unwrapping.
1199      * The generated parameters can be retrieved using
1200      * {@link #getParameters() getParameters} or
1201      * {@link #getIV() getIV} (if the parameter is an IV).
1202      *
1203      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
1204      * derived from the input parameters, and there are no reasonable
1205      * provider-specific default values, initialization will
1206      * necessarily fail.
1207      *
1208      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
1209      * requires any random bytes (e.g., for parameter generation), it will get
1210      * them using the {@link java.security.SecureRandom}
1211      * implementation of the highest-priority
1212      * installed provider as the source of randomness.
1213      * (If none of the installed providers supply an implementation of
1214      * SecureRandom, a system-provided source of randomness will be used.)
1215      *
1216      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
1217      * previously-acquired state. In other words, initializing a Cipher is
1218      * equivalent to creating a new instance of that Cipher and initializing
1219      * it.
1220      *
1221      * @param opmode the operation mode of this cipher (this is one of
1222      * the following:
1223      * {@code ENCRYPT_MODE}, {@code DECRYPT_MODE},
1224      * {@code WRAP_MODE} or {@code UNWRAP_MODE})
1225      * @param key the key
1226      *
1227      * @exception InvalidKeyException if the given key is inappropriate for
1228      * initializing this cipher, or requires
1229      * algorithm parameters that cannot be
1230      * determined from the given key, or if the given key has a keysize that
1231      * exceeds the maximum allowable keysize (as determined from the
1232      * configured jurisdiction policy files).
1233      * @throws UnsupportedOperationException if {@code opmode} is
1234      * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented
1235      * by the underlying {@code CipherSpi}.
1236      */
1237     public final void init(int opmode, Key key) throws InvalidKeyException {
1238         init(opmode, key, JceSecurity.RANDOM);
1239     }
1240 
1241     /**
1242      * Initializes this cipher with a key and a source of randomness.
1243      *
1244      * &lt;p&gt;The cipher is initialized for one of the following four operations:
1245      * encryption, decryption, key wrapping or  key unwrapping, depending
1246      * on the value of {@code opmode}.
1247      *
1248      * &lt;p&gt;If this cipher requires any algorithm parameters that cannot be
1249      * derived from the given {@code key}, the underlying cipher
1250      * implementation is supposed to generate the required parameters itself
1251      * (using provider-specific default or random values) if it is being
1252      * initialized for encryption or key wrapping, and raise an
1253      * {@code InvalidKeyException} if it is being
1254      * initialized for decryption or key unwrapping.
1255      * The generated parameters can be retrieved using
1256      * {@link #getParameters() getParameters} or
1257      * {@link #getIV() getIV} (if the parameter is an IV).
1258      *
1259      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
1260      * derived from the input parameters, and there are no reasonable
1261      * provider-specific default values, initialization will
1262      * necessarily fail.
1263      *
1264      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
1265      * requires any random bytes (e.g., for parameter generation), it will get
1266      * them from {@code random}.
1267      *
1268      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
1269      * previously-acquired state. In other words, initializing a Cipher is
1270      * equivalent to creating a new instance of that Cipher and initializing
1271      * it.
1272      *
1273      * @param opmode the operation mode of this cipher (this is one of the
1274      * following:
1275      * {@code ENCRYPT_MODE}, {@code DECRYPT_MODE},
1276      * {@code WRAP_MODE} or {@code UNWRAP_MODE})
1277      * @param key the encryption key
1278      * @param random the source of randomness
1279      *
1280      * @exception InvalidKeyException if the given key is inappropriate for
1281      * initializing this cipher, or requires
1282      * algorithm parameters that cannot be
1283      * determined from the given key, or if the given key has a keysize that
1284      * exceeds the maximum allowable keysize (as determined from the
1285      * configured jurisdiction policy files).
1286      * @throws UnsupportedOperationException if {@code opmode} is
1287      * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented
1288      * by the underlying {@code CipherSpi}.
1289      */
1290     public final void init(int opmode, Key key, SecureRandom random)
1291             throws InvalidKeyException
1292     {
1293         initialized = false;
1294         checkOpmode(opmode);
1295 
1296         if (spi != null) {
1297             checkCryptoPerm(spi, key);
1298             spi.engineInit(opmode, key, random);
1299         } else {
1300             try {
1301                 chooseProvider(I_KEY, opmode, key, null, null, random);
1302             } catch (InvalidAlgorithmParameterException e) {
1303                 // should never occur
1304                 throw new InvalidKeyException(e);
1305             }
1306         }
1307 
1308         initialized = true;
1309         this.opmode = opmode;
1310 
1311         if (!skipDebug &amp;&amp; pdebug != null) {
1312             pdebug.println(this.toString());
1313         }
1314     }
1315 
1316     /**
1317      * Initializes this cipher with a key and a set of algorithm
1318      * parameters.
1319      *
1320      * &lt;p&gt;The cipher is initialized for one of the following four operations:
1321      * encryption, decryption, key wrapping or  key unwrapping, depending
1322      * on the value of {@code opmode}.
1323      *
1324      * &lt;p&gt;If this cipher requires any algorithm parameters and
1325      * {@code params} is null, the underlying cipher implementation is
1326      * supposed to generate the required parameters itself (using
1327      * provider-specific default or random values) if it is being
1328      * initialized for encryption or key wrapping, and raise an
1329      * {@code InvalidAlgorithmParameterException} if it is being
1330      * initialized for decryption or key unwrapping.
1331      * The generated parameters can be retrieved using
1332      * {@link #getParameters() getParameters} or
1333      * {@link #getIV() getIV} (if the parameter is an IV).
1334      *
1335      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
1336      * derived from the input parameters, and there are no reasonable
1337      * provider-specific default values, initialization will
1338      * necessarily fail.
1339      *
1340      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
1341      * requires any random bytes (e.g., for parameter generation), it will get
1342      * them using the {@link java.security.SecureRandom}
1343      * implementation of the highest-priority
1344      * installed provider as the source of randomness.
1345      * (If none of the installed providers supply an implementation of
1346      * SecureRandom, a system-provided source of randomness will be used.)
1347      *
1348      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
1349      * previously-acquired state. In other words, initializing a Cipher is
1350      * equivalent to creating a new instance of that Cipher and initializing
1351      * it.
1352      *
1353      * @param opmode the operation mode of this cipher (this is one of the
1354      * following:
1355      * {@code ENCRYPT_MODE}, {@code DECRYPT_MODE},
1356      * {@code WRAP_MODE} or {@code UNWRAP_MODE})
1357      * @param key the encryption key
1358      * @param params the algorithm parameters
1359      *
1360      * @exception InvalidKeyException if the given key is inappropriate for
1361      * initializing this cipher, or its keysize exceeds the maximum allowable
1362      * keysize (as determined from the configured jurisdiction policy files).
1363      * @exception InvalidAlgorithmParameterException if the given algorithm
1364      * parameters are inappropriate for this cipher,
1365      * or this cipher requires
1366      * algorithm parameters and {@code params} is null, or the given
1367      * algorithm parameters imply a cryptographic strength that would exceed
1368      * the legal limits (as determined from the configured jurisdiction
1369      * policy files).
1370      * @throws UnsupportedOperationException if {@code opmode} is
1371      * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented
1372      * by the underlying {@code CipherSpi}.
1373      */
1374     public final void init(int opmode, Key key, AlgorithmParameterSpec params)
1375             throws InvalidKeyException, InvalidAlgorithmParameterException
1376     {
1377         init(opmode, key, params, JceSecurity.RANDOM);
1378     }
1379 
1380     /**
1381      * Initializes this cipher with a key, a set of algorithm
1382      * parameters, and a source of randomness.
1383      *
1384      * &lt;p&gt;The cipher is initialized for one of the following four operations:
1385      * encryption, decryption, key wrapping or  key unwrapping, depending
1386      * on the value of {@code opmode}.
1387      *
1388      * &lt;p&gt;If this cipher requires any algorithm parameters and
1389      * {@code params} is null, the underlying cipher implementation is
1390      * supposed to generate the required parameters itself (using
1391      * provider-specific default or random values) if it is being
1392      * initialized for encryption or key wrapping, and raise an
1393      * {@code InvalidAlgorithmParameterException} if it is being
1394      * initialized for decryption or key unwrapping.
1395      * The generated parameters can be retrieved using
1396      * {@link #getParameters() getParameters} or
1397      * {@link #getIV() getIV} (if the parameter is an IV).
1398      *
1399      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
1400      * derived from the input parameters, and there are no reasonable
1401      * provider-specific default values, initialization will
1402      * necessarily fail.
1403      *
1404      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
1405      * requires any random bytes (e.g., for parameter generation), it will get
1406      * them from {@code random}.
1407      *
1408      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
1409      * previously-acquired state. In other words, initializing a Cipher is
1410      * equivalent to creating a new instance of that Cipher and initializing
1411      * it.
1412      *
1413      * @param opmode the operation mode of this cipher (this is one of the
1414      * following:
1415      * {@code ENCRYPT_MODE}, {@code DECRYPT_MODE},
1416      * {@code WRAP_MODE} or {@code UNWRAP_MODE})
1417      * @param key the encryption key
1418      * @param params the algorithm parameters
1419      * @param random the source of randomness
1420      *
1421      * @exception InvalidKeyException if the given key is inappropriate for
1422      * initializing this cipher, or its keysize exceeds the maximum allowable
1423      * keysize (as determined from the configured jurisdiction policy files).
1424      * @exception InvalidAlgorithmParameterException if the given algorithm
1425      * parameters are inappropriate for this cipher,
1426      * or this cipher requires
1427      * algorithm parameters and {@code params} is null, or the given
1428      * algorithm parameters imply a cryptographic strength that would exceed
1429      * the legal limits (as determined from the configured jurisdiction
1430      * policy files).
1431      * @throws UnsupportedOperationException if {@code opmode} is
1432      * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented
1433      * by the underlying {@code CipherSpi}.
1434      */
1435     public final void init(int opmode, Key key, AlgorithmParameterSpec params,
1436                            SecureRandom random)
1437             throws InvalidKeyException, InvalidAlgorithmParameterException
1438     {
1439         initialized = false;
1440         checkOpmode(opmode);
1441 
1442         if (spi != null) {
1443             checkCryptoPerm(spi, key, params);
1444             spi.engineInit(opmode, key, params, random);
1445         } else {
1446             chooseProvider(I_PARAMSPEC, opmode, key, params, null, random);
1447         }
1448 
1449         initialized = true;
1450         this.opmode = opmode;
1451 
1452         if (!skipDebug &amp;&amp; pdebug != null) {
1453             pdebug.println(this.toString());
1454         }
1455     }
1456 
1457     /**
1458      * Initializes this cipher with a key and a set of algorithm
1459      * parameters.
1460      *
1461      * &lt;p&gt;The cipher is initialized for one of the following four operations:
1462      * encryption, decryption, key wrapping or  key unwrapping, depending
1463      * on the value of {@code opmode}.
1464      *
1465      * &lt;p&gt;If this cipher requires any algorithm parameters and
1466      * {@code params} is null, the underlying cipher implementation is
1467      * supposed to generate the required parameters itself (using
1468      * provider-specific default or random values) if it is being
1469      * initialized for encryption or key wrapping, and raise an
1470      * {@code InvalidAlgorithmParameterException} if it is being
1471      * initialized for decryption or key unwrapping.
1472      * The generated parameters can be retrieved using
1473      * {@link #getParameters() getParameters} or
1474      * {@link #getIV() getIV} (if the parameter is an IV).
1475      *
1476      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
1477      * derived from the input parameters, and there are no reasonable
1478      * provider-specific default values, initialization will
1479      * necessarily fail.
1480      *
1481      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
1482      * requires any random bytes (e.g., for parameter generation), it will get
1483      * them using the {@link java.security.SecureRandom}
1484      * implementation of the highest-priority
1485      * installed provider as the source of randomness.
1486      * (If none of the installed providers supply an implementation of
1487      * SecureRandom, a system-provided source of randomness will be used.)
1488      *
1489      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
1490      * previously-acquired state. In other words, initializing a Cipher is
1491      * equivalent to creating a new instance of that Cipher and initializing
1492      * it.
1493      *
1494      * @param opmode the operation mode of this cipher (this is one of the
1495      * following: {@code ENCRYPT_MODE},
1496      * {@code DECRYPT_MODE}, {@code WRAP_MODE}
1497      * or {@code UNWRAP_MODE})
1498      * @param key the encryption key
1499      * @param params the algorithm parameters
1500      *
1501      * @exception InvalidKeyException if the given key is inappropriate for
1502      * initializing this cipher, or its keysize exceeds the maximum allowable
1503      * keysize (as determined from the configured jurisdiction policy files).
1504      * @exception InvalidAlgorithmParameterException if the given algorithm
1505      * parameters are inappropriate for this cipher,
1506      * or this cipher requires
1507      * algorithm parameters and {@code params} is null, or the given
1508      * algorithm parameters imply a cryptographic strength that would exceed
1509      * the legal limits (as determined from the configured jurisdiction
1510      * policy files).
1511      * @throws UnsupportedOperationException if {@code opmode} is
1512      * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented
1513      * by the underlying {@code CipherSpi}.
1514      */
1515     public final void init(int opmode, Key key, AlgorithmParameters params)
1516             throws InvalidKeyException, InvalidAlgorithmParameterException
1517     {
1518         init(opmode, key, params, JceSecurity.RANDOM);
1519     }
1520 
1521     /**
1522      * Initializes this cipher with a key, a set of algorithm
1523      * parameters, and a source of randomness.
1524      *
1525      * &lt;p&gt;The cipher is initialized for one of the following four operations:
1526      * encryption, decryption, key wrapping or  key unwrapping, depending
1527      * on the value of {@code opmode}.
1528      *
1529      * &lt;p&gt;If this cipher requires any algorithm parameters and
1530      * {@code params} is null, the underlying cipher implementation is
1531      * supposed to generate the required parameters itself (using
1532      * provider-specific default or random values) if it is being
1533      * initialized for encryption or key wrapping, and raise an
1534      * {@code InvalidAlgorithmParameterException} if it is being
1535      * initialized for decryption or key unwrapping.
1536      * The generated parameters can be retrieved using
1537      * {@link #getParameters() getParameters} or
1538      * {@link #getIV() getIV} (if the parameter is an IV).
1539      *
1540      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
1541      * derived from the input parameters, and there are no reasonable
1542      * provider-specific default values, initialization will
1543      * necessarily fail.
1544      *
1545      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
1546      * requires any random bytes (e.g., for parameter generation), it will get
1547      * them from {@code random}.
1548      *
1549      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
1550      * previously-acquired state. In other words, initializing a Cipher is
1551      * equivalent to creating a new instance of that Cipher and initializing
1552      * it.
1553      *
1554      * @param opmode the operation mode of this cipher (this is one of the
1555      * following: {@code ENCRYPT_MODE},
1556      * {@code DECRYPT_MODE}, {@code WRAP_MODE}
1557      * or {@code UNWRAP_MODE})
1558      * @param key the encryption key
1559      * @param params the algorithm parameters
1560      * @param random the source of randomness
1561      *
1562      * @exception InvalidKeyException if the given key is inappropriate for
1563      * initializing this cipher, or its keysize exceeds the maximum allowable
1564      * keysize (as determined from the configured jurisdiction policy files).
1565      * @exception InvalidAlgorithmParameterException if the given algorithm
1566      * parameters are inappropriate for this cipher,
1567      * or this cipher requires
1568      * algorithm parameters and {@code params} is null, or the given
1569      * algorithm parameters imply a cryptographic strength that would exceed
1570      * the legal limits (as determined from the configured jurisdiction
1571      * policy files).
1572      * @throws UnsupportedOperationException if {@code opmode} is
1573      * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented
1574      * by the underlying {@code CipherSpi}.
1575      */
1576     public final void init(int opmode, Key key, AlgorithmParameters params,
1577                            SecureRandom random)
1578             throws InvalidKeyException, InvalidAlgorithmParameterException
1579     {
1580         initialized = false;
1581         checkOpmode(opmode);
1582 
1583         if (spi != null) {
1584             checkCryptoPerm(spi, key, params);
1585             spi.engineInit(opmode, key, params, random);
1586         } else {
1587             chooseProvider(I_PARAMS, opmode, key, null, params, random);
1588         }
1589 
1590         initialized = true;
1591         this.opmode = opmode;
1592 
1593         if (!skipDebug &amp;&amp; pdebug != null) {
1594             pdebug.println(this.toString());
1595         }
1596     }
1597 
1598     /**
1599      * Initializes this cipher with the public key from the given certificate.
1600      * &lt;p&gt; The cipher is initialized for one of the following four operations:
1601      * encryption, decryption, key wrapping or  key unwrapping, depending
1602      * on the value of {@code opmode}.
1603      *
1604      * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
1605      * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
1606      * extension field implies that the public key in
1607      * the certificate and its corresponding private key are not
1608      * supposed to be used for the operation represented by the value
1609      * of {@code opmode},
1610      * an {@code InvalidKeyException}
1611      * is thrown.
1612      *
1613      * &lt;p&gt; If this cipher requires any algorithm parameters that cannot be
1614      * derived from the public key in the given certificate, the underlying
1615      * cipher
1616      * implementation is supposed to generate the required parameters itself
1617      * (using provider-specific default or random values) if it is being
1618      * initialized for encryption or key wrapping, and raise an
1619      * {@code InvalidKeyException} if it is being initialized for decryption or
1620      * key unwrapping.
1621      * The generated parameters can be retrieved using
1622      * {@link #getParameters() getParameters} or
1623      * {@link #getIV() getIV} (if the parameter is an IV).
1624      *
1625      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
1626      * derived from the input parameters, and there are no reasonable
1627      * provider-specific default values, initialization will
1628      * necessarily fail.
1629      *
1630      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
1631      * requires any random bytes (e.g., for parameter generation), it will get
1632      * them using the
1633      * {@code SecureRandom}
1634      * implementation of the highest-priority
1635      * installed provider as the source of randomness.
1636      * (If none of the installed providers supply an implementation of
1637      * SecureRandom, a system-provided source of randomness will be used.)
1638      *
1639      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
1640      * previously-acquired state. In other words, initializing a Cipher is
1641      * equivalent to creating a new instance of that Cipher and initializing
1642      * it.
1643      *
1644      * @param opmode the operation mode of this cipher (this is one of the
1645      * following:
1646      * {@code ENCRYPT_MODE}, {@code DECRYPT_MODE},
1647      * {@code WRAP_MODE} or {@code UNWRAP_MODE})
1648      * @param certificate the certificate
1649      *
1650      * @exception InvalidKeyException if the public key in the given
1651      * certificate is inappropriate for initializing this cipher, or this
1652      * cipher requires algorithm parameters that cannot be determined from the
1653      * public key in the given certificate, or the keysize of the public key
1654      * in the given certificate has a keysize that exceeds the maximum
1655      * allowable keysize (as determined by the configured jurisdiction policy
1656      * files).
1657      * @throws UnsupportedOperationException if {@code opmode} is
1658      * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented
1659      * by the underlying {@code CipherSpi}.
1660      */
1661     public final void init(int opmode, Certificate certificate)
1662             throws InvalidKeyException
1663     {
1664         init(opmode, certificate, JceSecurity.RANDOM);
1665     }
1666 
1667     /**
1668      * Initializes this cipher with the public key from the given certificate
1669      * and a source of randomness.
1670      *
1671      * &lt;p&gt;The cipher is initialized for one of the following four operations:
1672      * encryption, decryption, key wrapping
1673      * or key unwrapping, depending on
1674      * the value of {@code opmode}.
1675      *
1676      * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
1677      * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
1678      * extension field implies that the public key in
1679      * the certificate and its corresponding private key are not
1680      * supposed to be used for the operation represented by the value of
1681      * {@code opmode},
1682      * an {@code InvalidKeyException}
1683      * is thrown.
1684      *
1685      * &lt;p&gt;If this cipher requires any algorithm parameters that cannot be
1686      * derived from the public key in the given {@code certificate},
1687      * the underlying cipher
1688      * implementation is supposed to generate the required parameters itself
1689      * (using provider-specific default or random values) if it is being
1690      * initialized for encryption or key wrapping, and raise an
1691      * {@code InvalidKeyException} if it is being
1692      * initialized for decryption or key unwrapping.
1693      * The generated parameters can be retrieved using
1694      * {@link #getParameters() getParameters} or
1695      * {@link #getIV() getIV} (if the parameter is an IV).
1696      *
1697      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
1698      * derived from the input parameters, and there are no reasonable
1699      * provider-specific default values, initialization will
1700      * necessarily fail.
1701      *
1702      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
1703      * requires any random bytes (e.g., for parameter generation), it will get
1704      * them from {@code random}.
1705      *
1706      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
1707      * previously-acquired state. In other words, initializing a Cipher is
1708      * equivalent to creating a new instance of that Cipher and initializing
1709      * it.
1710      *
1711      * @param opmode the operation mode of this cipher (this is one of the
1712      * following:
1713      * {@code ENCRYPT_MODE}, {@code DECRYPT_MODE},
1714      * {@code WRAP_MODE} or {@code UNWRAP_MODE})
1715      * @param certificate the certificate
1716      * @param random the source of randomness
1717      *
1718      * @exception InvalidKeyException if the public key in the given
1719      * certificate is inappropriate for initializing this cipher, or this
1720      * cipher
1721      * requires algorithm parameters that cannot be determined from the
1722      * public key in the given certificate, or the keysize of the public key
1723      * in the given certificate has a keysize that exceeds the maximum
1724      * allowable keysize (as determined by the configured jurisdiction policy
1725      * files).
1726      * @throws UnsupportedOperationException if {@code opmode} is
1727      * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented
1728      * by the underlying {@code CipherSpi}.
1729      */
1730     public final void init(int opmode, Certificate certificate,
1731                            SecureRandom random)
1732             throws InvalidKeyException
1733     {
1734         initialized = false;
1735         checkOpmode(opmode);
1736 
1737         // Check key usage if the certificate is of type X.509.
1738         if (certificate instanceof java.security.cert.X509Certificate) {
1739             // Check whether the cert has a key usage extension
1740             // marked as a critical extension.
1741             X509Certificate cert = (X509Certificate)certificate;
1742             Set&lt;String&gt; critSet = cert.getCriticalExtensionOIDs();
1743 
1744             if (critSet != null &amp;&amp; !critSet.isEmpty()
<a name="4" id="anc4"></a><span class="line-modified">1745                 &amp;&amp; critSet.contains(KEY_USAGE_EXTENSION_OID)) {</span>
1746                 boolean[] keyUsageInfo = cert.getKeyUsage();
1747                 // keyUsageInfo[2] is for keyEncipherment;
1748                 // keyUsageInfo[3] is for dataEncipherment.
1749                 if ((keyUsageInfo != null) &amp;&amp;
1750                     (((opmode == Cipher.ENCRYPT_MODE) &amp;&amp;
1751                       (keyUsageInfo.length &gt; 3) &amp;&amp;
1752                       (keyUsageInfo[3] == false)) ||
1753                      ((opmode == Cipher.WRAP_MODE) &amp;&amp;
1754                       (keyUsageInfo.length &gt; 2) &amp;&amp;
1755                       (keyUsageInfo[2] == false)))) {
1756                     throw new InvalidKeyException(&quot;Wrong key usage&quot;);
1757                 }
1758             }
1759         }
1760 
1761         PublicKey publicKey =
1762             (certificate==null? null:certificate.getPublicKey());
1763 
1764         if (spi != null) {
1765             checkCryptoPerm(spi, publicKey);
1766             spi.engineInit(opmode, publicKey, random);
1767         } else {
1768             try {
1769                 chooseProvider(I_CERT, opmode, publicKey, null, null, random);
1770             } catch (InvalidAlgorithmParameterException e) {
1771                 // should never occur
1772                 throw new InvalidKeyException(e);
1773             }
1774         }
1775 
1776         initialized = true;
1777         this.opmode = opmode;
1778 
1779         if (!skipDebug &amp;&amp; pdebug != null) {
1780             pdebug.println(this.toString());
1781         }
1782     }
1783 
1784     /**
1785      * Ensures that Cipher is in a valid state for update() and doFinal()
1786      * calls - should be initialized and in ENCRYPT_MODE or DECRYPT_MODE.
1787      * @throws IllegalStateException if Cipher object is not in valid state.
1788      */
1789     private void checkCipherState() {
1790         if (!(this instanceof NullCipher)) {
1791             if (!initialized) {
1792                 throw new IllegalStateException(&quot;Cipher not initialized&quot;);
1793             }
1794             if ((opmode != Cipher.ENCRYPT_MODE) &amp;&amp;
1795                 (opmode != Cipher.DECRYPT_MODE)) {
1796                 throw new IllegalStateException(&quot;Cipher not initialized &quot; +
1797                                                 &quot;for encryption/decryption&quot;);
1798             }
1799         }
1800     }
1801 
1802     /**
1803      * Continues a multiple-part encryption or decryption operation
1804      * (depending on how this cipher was initialized), processing another data
1805      * part.
1806      *
1807      * &lt;p&gt;The bytes in the {@code input} buffer are processed, and the
1808      * result is stored in a new buffer.
1809      *
1810      * &lt;p&gt;If {@code input} has a length of zero, this method returns
1811      * {@code null}.
1812      *
1813      * @param input the input buffer
1814      *
1815      * @return the new buffer with the result, or null if the underlying
1816      * cipher is a block cipher and the input data is too short to result in a
1817      * new block.
1818      *
1819      * @exception IllegalStateException if this cipher is in a wrong state
1820      * (e.g., has not been initialized)
1821      */
1822     public final byte[] update(byte[] input) {
1823         checkCipherState();
1824 
1825         // Input sanity check
1826         if (input == null) {
1827             throw new IllegalArgumentException(&quot;Null input buffer&quot;);
1828         }
1829 
1830         chooseFirstProvider();
1831         if (input.length == 0) {
1832             return null;
1833         }
1834         return spi.engineUpdate(input, 0, input.length);
1835     }
1836 
1837     /**
1838      * Continues a multiple-part encryption or decryption operation
1839      * (depending on how this cipher was initialized), processing another data
1840      * part.
1841      *
1842      * &lt;p&gt;The first {@code inputLen} bytes in the {@code input}
1843      * buffer, starting at {@code inputOffset} inclusive, are processed,
1844      * and the result is stored in a new buffer.
1845      *
1846      * &lt;p&gt;If {@code inputLen} is zero, this method returns
1847      * {@code null}.
1848      *
1849      * @param input the input buffer
1850      * @param inputOffset the offset in {@code input} where the input
1851      * starts
1852      * @param inputLen the input length
1853      *
1854      * @return the new buffer with the result, or null if the underlying
1855      * cipher is a block cipher and the input data is too short to result in a
1856      * new block.
1857      *
1858      * @exception IllegalStateException if this cipher is in a wrong state
1859      * (e.g., has not been initialized)
1860      */
1861     public final byte[] update(byte[] input, int inputOffset, int inputLen) {
1862         checkCipherState();
1863 
1864         // Input sanity check
1865         if (input == null || inputOffset &lt; 0
1866             || inputLen &gt; (input.length - inputOffset) || inputLen &lt; 0) {
1867             throw new IllegalArgumentException(&quot;Bad arguments&quot;);
1868         }
1869 
1870         chooseFirstProvider();
1871         if (inputLen == 0) {
1872             return null;
1873         }
1874         return spi.engineUpdate(input, inputOffset, inputLen);
1875     }
1876 
1877     /**
1878      * Continues a multiple-part encryption or decryption operation
1879      * (depending on how this cipher was initialized), processing another data
1880      * part.
1881      *
1882      * &lt;p&gt;The first {@code inputLen} bytes in the {@code input}
1883      * buffer, starting at {@code inputOffset} inclusive, are processed,
1884      * and the result is stored in the {@code output} buffer.
1885      *
1886      * &lt;p&gt;If the {@code output} buffer is too small to hold the result,
1887      * a {@code ShortBufferException} is thrown. In this case, repeat this
1888      * call with a larger output buffer. Use
1889      * {@link #getOutputSize(int) getOutputSize} to determine how big
1890      * the output buffer should be.
1891      *
1892      * &lt;p&gt;If {@code inputLen} is zero, this method returns
1893      * a length of zero.
1894      *
1895      * &lt;p&gt;Note: this method should be copy-safe, which means the
1896      * {@code input} and {@code output} buffers can reference
1897      * the same byte array and no unprocessed input data is overwritten
1898      * when the result is copied into the output buffer.
1899      *
1900      * @param input the input buffer
1901      * @param inputOffset the offset in {@code input} where the input
1902      * starts
1903      * @param inputLen the input length
1904      * @param output the buffer for the result
1905      *
1906      * @return the number of bytes stored in {@code output}
1907      *
1908      * @exception IllegalStateException if this cipher is in a wrong state
1909      * (e.g., has not been initialized)
1910      * @exception ShortBufferException if the given output buffer is too small
1911      * to hold the result
1912      */
1913     public final int update(byte[] input, int inputOffset, int inputLen,
1914                             byte[] output)
1915             throws ShortBufferException {
1916         checkCipherState();
1917 
1918         // Input sanity check
1919         if (input == null || inputOffset &lt; 0
1920             || inputLen &gt; (input.length - inputOffset) || inputLen &lt; 0) {
1921             throw new IllegalArgumentException(&quot;Bad arguments&quot;);
1922         }
1923 
1924         chooseFirstProvider();
1925         if (inputLen == 0) {
1926             return 0;
1927         }
1928         return spi.engineUpdate(input, inputOffset, inputLen,
1929                                       output, 0);
1930     }
1931 
1932     /**
1933      * Continues a multiple-part encryption or decryption operation
1934      * (depending on how this cipher was initialized), processing another data
1935      * part.
1936      *
1937      * &lt;p&gt;The first {@code inputLen} bytes in the {@code input}
1938      * buffer, starting at {@code inputOffset} inclusive, are processed,
1939      * and the result is stored in the {@code output} buffer, starting at
1940      * {@code outputOffset} inclusive.
1941      *
1942      * &lt;p&gt;If the {@code output} buffer is too small to hold the result,
1943      * a {@code ShortBufferException} is thrown. In this case, repeat this
1944      * call with a larger output buffer. Use
1945      * {@link #getOutputSize(int) getOutputSize} to determine how big
1946      * the output buffer should be.
1947      *
1948      * &lt;p&gt;If {@code inputLen} is zero, this method returns
1949      * a length of zero.
1950      *
1951      * &lt;p&gt;Note: this method should be copy-safe, which means the
1952      * {@code input} and {@code output} buffers can reference
1953      * the same byte array and no unprocessed input data is overwritten
1954      * when the result is copied into the output buffer.
1955      *
1956      * @param input the input buffer
1957      * @param inputOffset the offset in {@code input} where the input
1958      * starts
1959      * @param inputLen the input length
1960      * @param output the buffer for the result
1961      * @param outputOffset the offset in {@code output} where the result
1962      * is stored
1963      *
1964      * @return the number of bytes stored in {@code output}
1965      *
1966      * @exception IllegalStateException if this cipher is in a wrong state
1967      * (e.g., has not been initialized)
1968      * @exception ShortBufferException if the given output buffer is too small
1969      * to hold the result
1970      */
1971     public final int update(byte[] input, int inputOffset, int inputLen,
1972                             byte[] output, int outputOffset)
1973             throws ShortBufferException {
1974         checkCipherState();
1975 
1976         // Input sanity check
1977         if (input == null || inputOffset &lt; 0
1978             || inputLen &gt; (input.length - inputOffset) || inputLen &lt; 0
1979             || outputOffset &lt; 0) {
1980             throw new IllegalArgumentException(&quot;Bad arguments&quot;);
1981         }
1982 
1983         chooseFirstProvider();
1984         if (inputLen == 0) {
1985             return 0;
1986         }
1987         return spi.engineUpdate(input, inputOffset, inputLen,
1988                                       output, outputOffset);
1989     }
1990 
1991     /**
1992      * Continues a multiple-part encryption or decryption operation
1993      * (depending on how this cipher was initialized), processing another data
1994      * part.
1995      *
1996      * &lt;p&gt;All {@code input.remaining()} bytes starting at
1997      * {@code input.position()} are processed. The result is stored
1998      * in the output buffer.
1999      * Upon return, the input buffer&#39;s position will be equal
2000      * to its limit; its limit will not have changed. The output buffer&#39;s
2001      * position will have advanced by n, where n is the value returned
2002      * by this method; the output buffer&#39;s limit will not have changed.
2003      *
2004      * &lt;p&gt;If {@code output.remaining()} bytes are insufficient to
2005      * hold the result, a {@code ShortBufferException} is thrown.
2006      * In this case, repeat this call with a larger output buffer. Use
2007      * {@link #getOutputSize(int) getOutputSize} to determine how big
2008      * the output buffer should be.
2009      *
2010      * &lt;p&gt;Note: this method should be copy-safe, which means the
2011      * {@code input} and {@code output} buffers can reference
2012      * the same block of memory and no unprocessed input data is overwritten
2013      * when the result is copied into the output buffer.
2014      *
2015      * @param input the input ByteBuffer
2016      * @param output the output ByteByffer
2017      *
2018      * @return the number of bytes stored in {@code output}
2019      *
2020      * @exception IllegalStateException if this cipher is in a wrong state
2021      * (e.g., has not been initialized)
2022      * @exception IllegalArgumentException if input and output are the
2023      *   same object
2024      * @exception ReadOnlyBufferException if the output buffer is read-only
2025      * @exception ShortBufferException if there is insufficient space in the
2026      * output buffer
2027      * @since 1.5
2028      */
2029     public final int update(ByteBuffer input, ByteBuffer output)
2030             throws ShortBufferException {
2031         checkCipherState();
2032 
2033         if ((input == null) || (output == null)) {
2034             throw new IllegalArgumentException(&quot;Buffers must not be null&quot;);
2035         }
2036         if (input == output) {
2037             throw new IllegalArgumentException(&quot;Input and output buffers must &quot;
2038                 + &quot;not be the same object, consider using buffer.duplicate()&quot;);
2039         }
2040         if (output.isReadOnly()) {
2041             throw new ReadOnlyBufferException();
2042         }
2043 
2044         chooseFirstProvider();
2045         return spi.engineUpdate(input, output);
2046     }
2047 
2048     /**
2049      * Finishes a multiple-part encryption or decryption operation, depending
2050      * on how this cipher was initialized.
2051      *
2052      * &lt;p&gt;Input data that may have been buffered during a previous
2053      * {@code update} operation is processed, with padding (if requested)
2054      * being applied.
2055      * If an AEAD mode such as GCM/CCM is being used, the authentication
2056      * tag is appended in the case of encryption, or verified in the
2057      * case of decryption.
2058      * The result is stored in a new buffer.
2059      *
2060      * &lt;p&gt;Upon finishing, this method resets this cipher object to the state
2061      * it was in when previously initialized via a call to {@code init}.
2062      * That is, the object is reset and available to encrypt or decrypt
2063      * (depending on the operation mode that was specified in the call to
2064      * {@code init}) more data.
2065      *
2066      * &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
2067      * be reset before it can be used again.
2068      *
2069      * @return the new buffer with the result
2070      *
2071      * @exception IllegalStateException if this cipher is in a wrong state
2072      * (e.g., has not been initialized)
2073      * @exception IllegalBlockSizeException if this cipher is a block cipher,
2074      * no padding has been requested (only in encryption mode), and the total
2075      * input length of the data processed by this cipher is not a multiple of
2076      * block size; or if this encryption algorithm is unable to
2077      * process the input data provided.
2078      * @exception BadPaddingException if this cipher is in decryption mode,
2079      * and (un)padding has been requested, but the decrypted data is not
2080      * bounded by the appropriate padding bytes
2081      * @exception AEADBadTagException if this cipher is decrypting in an
2082      * AEAD mode (such as GCM/CCM), and the received authentication tag
2083      * does not match the calculated value
2084      */
2085     public final byte[] doFinal()
2086             throws IllegalBlockSizeException, BadPaddingException {
2087         checkCipherState();
2088 
2089         chooseFirstProvider();
2090         return spi.engineDoFinal(null, 0, 0);
2091     }
2092 
2093     /**
2094      * Finishes a multiple-part encryption or decryption operation, depending
2095      * on how this cipher was initialized.
2096      *
2097      * &lt;p&gt;Input data that may have been buffered during a previous
2098      * {@code update} operation is processed, with padding (if requested)
2099      * being applied.
2100      * If an AEAD mode such as GCM/CCM is being used, the authentication
2101      * tag is appended in the case of encryption, or verified in the
2102      * case of decryption.
2103      * The result is stored in the {@code output} buffer, starting at
2104      * {@code outputOffset} inclusive.
2105      *
2106      * &lt;p&gt;If the {@code output} buffer is too small to hold the result,
2107      * a {@code ShortBufferException} is thrown. In this case, repeat this
2108      * call with a larger output buffer. Use
2109      * {@link #getOutputSize(int) getOutputSize} to determine how big
2110      * the output buffer should be.
2111      *
2112      * &lt;p&gt;Upon finishing, this method resets this cipher object to the state
2113      * it was in when previously initialized via a call to {@code init}.
2114      * That is, the object is reset and available to encrypt or decrypt
2115      * (depending on the operation mode that was specified in the call to
2116      * {@code init}) more data.
2117      *
2118      * &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
2119      * be reset before it can be used again.
2120      *
2121      * @param output the buffer for the result
2122      * @param outputOffset the offset in {@code output} where the result
2123      * is stored
2124      *
2125      * @return the number of bytes stored in {@code output}
2126      *
2127      * @exception IllegalStateException if this cipher is in a wrong state
2128      * (e.g., has not been initialized)
2129      * @exception IllegalBlockSizeException if this cipher is a block cipher,
2130      * no padding has been requested (only in encryption mode), and the total
2131      * input length of the data processed by this cipher is not a multiple of
2132      * block size; or if this encryption algorithm is unable to
2133      * process the input data provided.
2134      * @exception ShortBufferException if the given output buffer is too small
2135      * to hold the result
2136      * @exception BadPaddingException if this cipher is in decryption mode,
2137      * and (un)padding has been requested, but the decrypted data is not
2138      * bounded by the appropriate padding bytes
2139      * @exception AEADBadTagException if this cipher is decrypting in an
2140      * AEAD mode (such as GCM/CCM), and the received authentication tag
2141      * does not match the calculated value
2142      */
2143     public final int doFinal(byte[] output, int outputOffset)
2144             throws IllegalBlockSizeException, ShortBufferException,
2145                BadPaddingException {
2146         checkCipherState();
2147 
2148         // Input sanity check
2149         if ((output == null) || (outputOffset &lt; 0)) {
2150             throw new IllegalArgumentException(&quot;Bad arguments&quot;);
2151         }
2152 
2153         chooseFirstProvider();
2154         return spi.engineDoFinal(null, 0, 0, output, outputOffset);
2155     }
2156 
2157     /**
2158      * Encrypts or decrypts data in a single-part operation, or finishes a
2159      * multiple-part operation. The data is encrypted or decrypted,
2160      * depending on how this cipher was initialized.
2161      *
2162      * &lt;p&gt;The bytes in the {@code input} buffer, and any input bytes that
2163      * may have been buffered during a previous {@code update} operation,
2164      * are processed, with padding (if requested) being applied.
2165      * If an AEAD mode such as GCM/CCM is being used, the authentication
2166      * tag is appended in the case of encryption, or verified in the
2167      * case of decryption.
2168      * The result is stored in a new buffer.
2169      *
2170      * &lt;p&gt;Upon finishing, this method resets this cipher object to the state
2171      * it was in when previously initialized via a call to {@code init}.
2172      * That is, the object is reset and available to encrypt or decrypt
2173      * (depending on the operation mode that was specified in the call to
2174      * {@code init}) more data.
2175      *
2176      * &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
2177      * be reset before it can be used again.
2178      *
2179      * @param input the input buffer
2180      *
2181      * @return the new buffer with the result
2182      *
2183      * @exception IllegalStateException if this cipher is in a wrong state
2184      * (e.g., has not been initialized)
2185      * @exception IllegalBlockSizeException if this cipher is a block cipher,
2186      * no padding has been requested (only in encryption mode), and the total
2187      * input length of the data processed by this cipher is not a multiple of
2188      * block size; or if this encryption algorithm is unable to
2189      * process the input data provided.
2190      * @exception BadPaddingException if this cipher is in decryption mode,
2191      * and (un)padding has been requested, but the decrypted data is not
2192      * bounded by the appropriate padding bytes
2193      * @exception AEADBadTagException if this cipher is decrypting in an
2194      * AEAD mode (such as GCM/CCM), and the received authentication tag
2195      * does not match the calculated value
2196      */
2197     public final byte[] doFinal(byte[] input)
2198             throws IllegalBlockSizeException, BadPaddingException {
2199         checkCipherState();
2200 
2201         // Input sanity check
2202         if (input == null) {
2203             throw new IllegalArgumentException(&quot;Null input buffer&quot;);
2204         }
2205 
2206         chooseFirstProvider();
2207         return spi.engineDoFinal(input, 0, input.length);
2208     }
2209 
2210     /**
2211      * Encrypts or decrypts data in a single-part operation, or finishes a
2212      * multiple-part operation. The data is encrypted or decrypted,
2213      * depending on how this cipher was initialized.
2214      *
2215      * &lt;p&gt;The first {@code inputLen} bytes in the {@code input}
2216      * buffer, starting at {@code inputOffset} inclusive, and any input
2217      * bytes that may have been buffered during a previous {@code update}
2218      * operation, are processed, with padding (if requested) being applied.
2219      * If an AEAD mode such as GCM/CCM is being used, the authentication
2220      * tag is appended in the case of encryption, or verified in the
2221      * case of decryption.
2222      * The result is stored in a new buffer.
2223      *
2224      * &lt;p&gt;Upon finishing, this method resets this cipher object to the state
2225      * it was in when previously initialized via a call to {@code init}.
2226      * That is, the object is reset and available to encrypt or decrypt
2227      * (depending on the operation mode that was specified in the call to
2228      * {@code init}) more data.
2229      *
2230      * &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
2231      * be reset before it can be used again.
2232      *
2233      * @param input the input buffer
2234      * @param inputOffset the offset in {@code input} where the input
2235      * starts
2236      * @param inputLen the input length
2237      *
2238      * @return the new buffer with the result
2239      *
2240      * @exception IllegalStateException if this cipher is in a wrong state
2241      * (e.g., has not been initialized)
2242      * @exception IllegalBlockSizeException if this cipher is a block cipher,
2243      * no padding has been requested (only in encryption mode), and the total
2244      * input length of the data processed by this cipher is not a multiple of
2245      * block size; or if this encryption algorithm is unable to
2246      * process the input data provided.
2247      * @exception BadPaddingException if this cipher is in decryption mode,
2248      * and (un)padding has been requested, but the decrypted data is not
2249      * bounded by the appropriate padding bytes
2250      * @exception AEADBadTagException if this cipher is decrypting in an
2251      * AEAD mode (such as GCM/CCM), and the received authentication tag
2252      * does not match the calculated value
2253      */
2254     public final byte[] doFinal(byte[] input, int inputOffset, int inputLen)
2255             throws IllegalBlockSizeException, BadPaddingException {
2256         checkCipherState();
2257 
2258         // Input sanity check
2259         if (input == null || inputOffset &lt; 0
2260             || inputLen &gt; (input.length - inputOffset) || inputLen &lt; 0) {
2261             throw new IllegalArgumentException(&quot;Bad arguments&quot;);
2262         }
2263 
2264         chooseFirstProvider();
2265         return spi.engineDoFinal(input, inputOffset, inputLen);
2266     }
2267 
2268     /**
2269      * Encrypts or decrypts data in a single-part operation, or finishes a
2270      * multiple-part operation. The data is encrypted or decrypted,
2271      * depending on how this cipher was initialized.
2272      *
2273      * &lt;p&gt;The first {@code inputLen} bytes in the {@code input}
2274      * buffer, starting at {@code inputOffset} inclusive, and any input
2275      * bytes that may have been buffered during a previous {@code update}
2276      * operation, are processed, with padding (if requested) being applied.
2277      * If an AEAD mode such as GCM/CCM is being used, the authentication
2278      * tag is appended in the case of encryption, or verified in the
2279      * case of decryption.
2280      * The result is stored in the {@code output} buffer.
2281      *
2282      * &lt;p&gt;If the {@code output} buffer is too small to hold the result,
2283      * a {@code ShortBufferException} is thrown. In this case, repeat this
2284      * call with a larger output buffer. Use
2285      * {@link #getOutputSize(int) getOutputSize} to determine how big
2286      * the output buffer should be.
2287      *
2288      * &lt;p&gt;Upon finishing, this method resets this cipher object to the state
2289      * it was in when previously initialized via a call to {@code init}.
2290      * That is, the object is reset and available to encrypt or decrypt
2291      * (depending on the operation mode that was specified in the call to
2292      * {@code init}) more data.
2293      *
2294      * &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
2295      * be reset before it can be used again.
2296      *
2297      * &lt;p&gt;Note: this method should be copy-safe, which means the
2298      * {@code input} and {@code output} buffers can reference
2299      * the same byte array and no unprocessed input data is overwritten
2300      * when the result is copied into the output buffer.
2301      *
2302      * @param input the input buffer
2303      * @param inputOffset the offset in {@code input} where the input
2304      * starts
2305      * @param inputLen the input length
2306      * @param output the buffer for the result
2307      *
2308      * @return the number of bytes stored in {@code output}
2309      *
2310      * @exception IllegalStateException if this cipher is in a wrong state
2311      * (e.g., has not been initialized)
2312      * @exception IllegalBlockSizeException if this cipher is a block cipher,
2313      * no padding has been requested (only in encryption mode), and the total
2314      * input length of the data processed by this cipher is not a multiple of
2315      * block size; or if this encryption algorithm is unable to
2316      * process the input data provided.
2317      * @exception ShortBufferException if the given output buffer is too small
2318      * to hold the result
2319      * @exception BadPaddingException if this cipher is in decryption mode,
2320      * and (un)padding has been requested, but the decrypted data is not
2321      * bounded by the appropriate padding bytes
2322      * @exception AEADBadTagException if this cipher is decrypting in an
2323      * AEAD mode (such as GCM/CCM), and the received authentication tag
2324      * does not match the calculated value
2325      */
2326     public final int doFinal(byte[] input, int inputOffset, int inputLen,
2327                              byte[] output)
2328             throws ShortBufferException, IllegalBlockSizeException,
2329             BadPaddingException {
2330         checkCipherState();
2331 
2332         // Input sanity check
2333         if (input == null || inputOffset &lt; 0
2334             || inputLen &gt; (input.length - inputOffset) || inputLen &lt; 0) {
2335             throw new IllegalArgumentException(&quot;Bad arguments&quot;);
2336         }
2337 
2338         chooseFirstProvider();
2339         return spi.engineDoFinal(input, inputOffset, inputLen,
2340                                        output, 0);
2341     }
2342 
2343     /**
2344      * Encrypts or decrypts data in a single-part operation, or finishes a
2345      * multiple-part operation. The data is encrypted or decrypted,
2346      * depending on how this cipher was initialized.
2347      *
2348      * &lt;p&gt;The first {@code inputLen} bytes in the {@code input}
2349      * buffer, starting at {@code inputOffset} inclusive, and any input
2350      * bytes that may have been buffered during a previous
2351      * {@code update} operation, are processed, with padding
2352      * (if requested) being applied.
2353      * If an AEAD mode such as GCM/CCM is being used, the authentication
2354      * tag is appended in the case of encryption, or verified in the
2355      * case of decryption.
2356      * The result is stored in the {@code output} buffer, starting at
2357      * {@code outputOffset} inclusive.
2358      *
2359      * &lt;p&gt;If the {@code output} buffer is too small to hold the result,
2360      * a {@code ShortBufferException} is thrown. In this case, repeat this
2361      * call with a larger output buffer. Use
2362      * {@link #getOutputSize(int) getOutputSize} to determine how big
2363      * the output buffer should be.
2364      *
2365      * &lt;p&gt;Upon finishing, this method resets this cipher object to the state
2366      * it was in when previously initialized via a call to {@code init}.
2367      * That is, the object is reset and available to encrypt or decrypt
2368      * (depending on the operation mode that was specified in the call to
2369      * {@code init}) more data.
2370      *
2371      * &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
2372      * be reset before it can be used again.
2373      *
2374      * &lt;p&gt;Note: this method should be copy-safe, which means the
2375      * {@code input} and {@code output} buffers can reference
2376      * the same byte array and no unprocessed input data is overwritten
2377      * when the result is copied into the output buffer.
2378      *
2379      * @param input the input buffer
2380      * @param inputOffset the offset in {@code input} where the input
2381      * starts
2382      * @param inputLen the input length
2383      * @param output the buffer for the result
2384      * @param outputOffset the offset in {@code output} where the result
2385      * is stored
2386      *
2387      * @return the number of bytes stored in {@code output}
2388      *
2389      * @exception IllegalStateException if this cipher is in a wrong state
2390      * (e.g., has not been initialized)
2391      * @exception IllegalBlockSizeException if this cipher is a block cipher,
2392      * no padding has been requested (only in encryption mode), and the total
2393      * input length of the data processed by this cipher is not a multiple of
2394      * block size; or if this encryption algorithm is unable to
2395      * process the input data provided.
2396      * @exception ShortBufferException if the given output buffer is too small
2397      * to hold the result
2398      * @exception BadPaddingException if this cipher is in decryption mode,
2399      * and (un)padding has been requested, but the decrypted data is not
2400      * bounded by the appropriate padding bytes
2401      * @exception AEADBadTagException if this cipher is decrypting in an
2402      * AEAD mode (such as GCM/CCM), and the received authentication tag
2403      * does not match the calculated value
2404      */
2405     public final int doFinal(byte[] input, int inputOffset, int inputLen,
2406                              byte[] output, int outputOffset)
2407             throws ShortBufferException, IllegalBlockSizeException,
2408             BadPaddingException {
2409         checkCipherState();
2410 
2411         // Input sanity check
2412         if (input == null || inputOffset &lt; 0
2413             || inputLen &gt; (input.length - inputOffset) || inputLen &lt; 0
2414             || outputOffset &lt; 0) {
2415             throw new IllegalArgumentException(&quot;Bad arguments&quot;);
2416         }
2417 
2418         chooseFirstProvider();
2419         return spi.engineDoFinal(input, inputOffset, inputLen,
2420                                        output, outputOffset);
2421     }
2422 
2423     /**
2424      * Encrypts or decrypts data in a single-part operation, or finishes a
2425      * multiple-part operation. The data is encrypted or decrypted,
2426      * depending on how this cipher was initialized.
2427      *
2428      * &lt;p&gt;All {@code input.remaining()} bytes starting at
2429      * {@code input.position()} are processed.
2430      * If an AEAD mode such as GCM/CCM is being used, the authentication
2431      * tag is appended in the case of encryption, or verified in the
2432      * case of decryption.
2433      * The result is stored in the output buffer.
2434      * Upon return, the input buffer&#39;s position will be equal
2435      * to its limit; its limit will not have changed. The output buffer&#39;s
2436      * position will have advanced by n, where n is the value returned
2437      * by this method; the output buffer&#39;s limit will not have changed.
2438      *
2439      * &lt;p&gt;If {@code output.remaining()} bytes are insufficient to
2440      * hold the result, a {@code ShortBufferException} is thrown.
2441      * In this case, repeat this call with a larger output buffer. Use
2442      * {@link #getOutputSize(int) getOutputSize} to determine how big
2443      * the output buffer should be.
2444      *
2445      * &lt;p&gt;Upon finishing, this method resets this cipher object to the state
2446      * it was in when previously initialized via a call to {@code init}.
2447      * That is, the object is reset and available to encrypt or decrypt
2448      * (depending on the operation mode that was specified in the call to
2449      * {@code init}) more data.
2450      *
2451      * &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
2452      * be reset before it can be used again.
2453      *
2454      * &lt;p&gt;Note: this method should be copy-safe, which means the
2455      * {@code input} and {@code output} buffers can reference
2456      * the same byte array and no unprocessed input data is overwritten
2457      * when the result is copied into the output buffer.
2458      *
2459      * @param input the input ByteBuffer
2460      * @param output the output ByteBuffer
2461      *
2462      * @return the number of bytes stored in {@code output}
2463      *
2464      * @exception IllegalStateException if this cipher is in a wrong state
2465      * (e.g., has not been initialized)
2466      * @exception IllegalArgumentException if input and output are the
2467      *   same object
2468      * @exception ReadOnlyBufferException if the output buffer is read-only
2469      * @exception IllegalBlockSizeException if this cipher is a block cipher,
2470      * no padding has been requested (only in encryption mode), and the total
2471      * input length of the data processed by this cipher is not a multiple of
2472      * block size; or if this encryption algorithm is unable to
2473      * process the input data provided.
2474      * @exception ShortBufferException if there is insufficient space in the
2475      * output buffer
2476      * @exception BadPaddingException if this cipher is in decryption mode,
2477      * and (un)padding has been requested, but the decrypted data is not
2478      * bounded by the appropriate padding bytes
2479      * @exception AEADBadTagException if this cipher is decrypting in an
2480      * AEAD mode (such as GCM/CCM), and the received authentication tag
2481      * does not match the calculated value
2482      *
2483      * @since 1.5
2484      */
2485     public final int doFinal(ByteBuffer input, ByteBuffer output)
2486             throws ShortBufferException, IllegalBlockSizeException,
2487             BadPaddingException {
2488         checkCipherState();
2489 
2490         if ((input == null) || (output == null)) {
2491             throw new IllegalArgumentException(&quot;Buffers must not be null&quot;);
2492         }
2493         if (input == output) {
2494             throw new IllegalArgumentException(&quot;Input and output buffers must &quot;
2495                 + &quot;not be the same object, consider using buffer.duplicate()&quot;);
2496         }
2497         if (output.isReadOnly()) {
2498             throw new ReadOnlyBufferException();
2499         }
2500 
2501         chooseFirstProvider();
2502         return spi.engineDoFinal(input, output);
2503     }
2504 
2505     /**
2506      * Wrap a key.
2507      *
2508      * @param key the key to be wrapped.
2509      *
2510      * @return the wrapped key.
2511      *
2512      * @exception IllegalStateException if this cipher is in a wrong
2513      * state (e.g., has not been initialized).
2514      *
2515      * @exception IllegalBlockSizeException if this cipher is a block
2516      * cipher, no padding has been requested, and the length of the
2517      * encoding of the key to be wrapped is not a
2518      * multiple of the block size.
2519      *
2520      * @exception InvalidKeyException if it is impossible or unsafe to
2521      * wrap the key with this cipher (e.g., a hardware protected key is
2522      * being passed to a software-only cipher).
2523      *
2524      * @throws UnsupportedOperationException if the corresponding method in the
2525      * {@code CipherSpi} is not supported.
2526      */
2527     public final byte[] wrap(Key key)
2528             throws IllegalBlockSizeException, InvalidKeyException {
2529         if (!(this instanceof NullCipher)) {
2530             if (!initialized) {
2531                 throw new IllegalStateException(&quot;Cipher not initialized&quot;);
2532             }
2533             if (opmode != Cipher.WRAP_MODE) {
2534                 throw new IllegalStateException(&quot;Cipher not initialized &quot; +
2535                                                 &quot;for wrapping keys&quot;);
2536             }
2537         }
2538 
2539         chooseFirstProvider();
2540         return spi.engineWrap(key);
2541     }
2542 
2543     /**
2544      * Unwrap a previously wrapped key.
2545      *
2546      * @param wrappedKey the key to be unwrapped.
2547      *
2548      * @param wrappedKeyAlgorithm the algorithm associated with the wrapped
2549      * key.
2550      *
2551      * @param wrappedKeyType the type of the wrapped key. This must be one of
2552      * {@code SECRET_KEY}, {@code PRIVATE_KEY}, or
2553      * {@code PUBLIC_KEY}.
2554      *
2555      * @return the unwrapped key.
2556      *
2557      * @exception IllegalStateException if this cipher is in a wrong state
2558      * (e.g., has not been initialized).
2559      *
2560      * @exception NoSuchAlgorithmException if no installed providers
2561      * can create keys of type {@code wrappedKeyType} for the
2562      * {@code wrappedKeyAlgorithm}.
2563      *
2564      * @exception InvalidKeyException if {@code wrappedKey} does not
2565      * represent a wrapped key of type {@code wrappedKeyType} for
2566      * the {@code wrappedKeyAlgorithm}.
2567      *
2568      * @throws UnsupportedOperationException if the corresponding method in the
2569      * {@code CipherSpi} is not supported.
2570      */
2571     public final Key unwrap(byte[] wrappedKey,
2572                             String wrappedKeyAlgorithm,
2573                             int wrappedKeyType)
2574             throws InvalidKeyException, NoSuchAlgorithmException {
2575 
2576         if (!(this instanceof NullCipher)) {
2577             if (!initialized) {
2578                 throw new IllegalStateException(&quot;Cipher not initialized&quot;);
2579             }
2580             if (opmode != Cipher.UNWRAP_MODE) {
2581                 throw new IllegalStateException(&quot;Cipher not initialized &quot; +
2582                                                 &quot;for unwrapping keys&quot;);
2583             }
2584         }
2585         if ((wrappedKeyType != SECRET_KEY) &amp;&amp;
2586             (wrappedKeyType != PRIVATE_KEY) &amp;&amp;
2587             (wrappedKeyType != PUBLIC_KEY)) {
2588             throw new InvalidParameterException(&quot;Invalid key type&quot;);
2589         }
2590 
2591         chooseFirstProvider();
2592         return spi.engineUnwrap(wrappedKey,
2593                                       wrappedKeyAlgorithm,
2594                                       wrappedKeyType);
2595     }
2596 
2597     private AlgorithmParameterSpec getAlgorithmParameterSpec(
2598                                       AlgorithmParameters params)
2599             throws InvalidParameterSpecException {
2600         if (params == null) {
2601             return null;
2602         }
2603 
2604         String alg = params.getAlgorithm().toUpperCase(Locale.ENGLISH);
2605 
2606         if (alg.equalsIgnoreCase(&quot;RC2&quot;)) {
2607             return params.getParameterSpec(RC2ParameterSpec.class);
2608         }
2609 
2610         if (alg.equalsIgnoreCase(&quot;RC5&quot;)) {
2611             return params.getParameterSpec(RC5ParameterSpec.class);
2612         }
2613 
2614         if (alg.startsWith(&quot;PBE&quot;)) {
2615             return params.getParameterSpec(PBEParameterSpec.class);
2616         }
2617 
2618         if (alg.startsWith(&quot;DES&quot;)) {
2619             return params.getParameterSpec(IvParameterSpec.class);
2620         }
2621         return null;
2622     }
2623 
2624     private static CryptoPermission getConfiguredPermission(
2625             String transformation) throws NullPointerException,
2626             NoSuchAlgorithmException {
2627         if (transformation == null) throw new NullPointerException();
2628         String[] parts = tokenizeTransformation(transformation);
2629         return JceSecurityManager.INSTANCE.getCryptoPermission(parts[0]);
2630     }
2631 
2632     /**
2633      * Returns the maximum key length for the specified transformation
2634      * according to the installed JCE jurisdiction policy files. If
2635      * JCE unlimited strength jurisdiction policy files are installed,
2636      * Integer.MAX_VALUE will be returned.
2637      * For more information on the default key sizes and the JCE jurisdiction
2638      * policy files, please see the Cryptographic defaults and limitations in
2639      * the {@extLink security_guide_jdk_providers JDK Providers Documentation}.
2640      *
2641      * @param transformation the cipher transformation.
2642      * @return the maximum key length in bits or Integer.MAX_VALUE.
2643      * @exception NullPointerException if {@code transformation} is null.
2644      * @exception NoSuchAlgorithmException if {@code transformation}
2645      * is not a valid transformation, i.e. in the form of &quot;algorithm&quot; or
2646      * &quot;algorithm/mode/padding&quot;.
2647      * @since 1.5
2648      */
2649     public static final int getMaxAllowedKeyLength(String transformation)
2650             throws NoSuchAlgorithmException {
2651         CryptoPermission cp = getConfiguredPermission(transformation);
2652         return cp.getMaxKeySize();
2653     }
2654 
2655     /**
2656      * Returns an AlgorithmParameterSpec object which contains
2657      * the maximum cipher parameter value according to the
2658      * jurisdiction policy file. If JCE unlimited strength jurisdiction
2659      * policy files are installed or there is no maximum limit on the
2660      * parameters for the specified transformation in the policy file,
2661      * null will be returned.
2662      *
2663      * @param transformation the cipher transformation.
2664      * @return an AlgorithmParameterSpec which holds the maximum
2665      * value or null.
2666      * @exception NullPointerException if {@code transformation}
2667      * is null.
2668      * @exception NoSuchAlgorithmException if {@code transformation}
2669      * is not a valid transformation, i.e. in the form of &quot;algorithm&quot; or
2670      * &quot;algorithm/mode/padding&quot;.
2671      * @since 1.5
2672      */
2673     public static final AlgorithmParameterSpec getMaxAllowedParameterSpec(
2674             String transformation) throws NoSuchAlgorithmException {
2675         CryptoPermission cp = getConfiguredPermission(transformation);
2676         return cp.getAlgorithmParameterSpec();
2677     }
2678 
2679     /**
2680      * Continues a multi-part update of the Additional Authentication
2681      * Data (AAD).
2682      * &lt;p&gt;
2683      * Calls to this method provide AAD to the cipher when operating in
2684      * modes such as AEAD (GCM/CCM).  If this cipher is operating in
2685      * either GCM or CCM mode, all AAD must be supplied before beginning
2686      * operations on the ciphertext (via the {@code update} and
2687      * {@code doFinal} methods).
2688      *
2689      * @param src the buffer containing the Additional Authentication Data
2690      *
2691      * @throws IllegalArgumentException if the {@code src}
2692      * byte array is null
2693      * @throws IllegalStateException if this cipher is in a wrong state
2694      * (e.g., has not been initialized), does not accept AAD, or if
2695      * operating in either GCM or CCM mode and one of the {@code update}
2696      * methods has already been called for the active
2697      * encryption/decryption operation
2698      * @throws UnsupportedOperationException if the corresponding method
2699      * in the {@code CipherSpi} has not been overridden by an
2700      * implementation
2701      *
2702      * @since 1.7
2703      */
2704     public final void updateAAD(byte[] src) {
2705         if (src == null) {
2706             throw new IllegalArgumentException(&quot;src buffer is null&quot;);
2707         }
2708 
2709         updateAAD(src, 0, src.length);
2710     }
2711 
2712     /**
2713      * Continues a multi-part update of the Additional Authentication
2714      * Data (AAD), using a subset of the provided buffer.
2715      * &lt;p&gt;
2716      * Calls to this method provide AAD to the cipher when operating in
2717      * modes such as AEAD (GCM/CCM).  If this cipher is operating in
2718      * either GCM or CCM mode, all AAD must be supplied before beginning
2719      * operations on the ciphertext (via the {@code update}
2720      * and {@code doFinal} methods).
2721      *
2722      * @param src the buffer containing the AAD
2723      * @param offset the offset in {@code src} where the AAD input starts
2724      * @param len the number of AAD bytes
2725      *
2726      * @throws IllegalArgumentException if the {@code src}
2727      * byte array is null, or the {@code offset} or {@code length}
2728      * is less than 0, or the sum of the {@code offset} and
2729      * {@code len} is greater than the length of the
2730      * {@code src} byte array
2731      * @throws IllegalStateException if this cipher is in a wrong state
2732      * (e.g., has not been initialized), does not accept AAD, or if
2733      * operating in either GCM or CCM mode and one of the {@code update}
2734      * methods has already been called for the active
2735      * encryption/decryption operation
2736      * @throws UnsupportedOperationException if the corresponding method
2737      * in the {@code CipherSpi} has not been overridden by an
2738      * implementation
2739      *
2740      * @since 1.7
2741      */
2742     public final void updateAAD(byte[] src, int offset, int len) {
2743         checkCipherState();
2744 
2745         // Input sanity check
2746         if ((src == null) || (offset &lt; 0) || (len &lt; 0)
2747                 || len &gt; (src.length - offset)) {
2748             throw new IllegalArgumentException(&quot;Bad arguments&quot;);
2749         }
2750 
2751         chooseFirstProvider();
2752         if (len == 0) {
2753             return;
2754         }
2755         spi.engineUpdateAAD(src, offset, len);
2756     }
2757 
2758     /**
2759      * Continues a multi-part update of the Additional Authentication
2760      * Data (AAD).
2761      * &lt;p&gt;
2762      * Calls to this method provide AAD to the cipher when operating in
2763      * modes such as AEAD (GCM/CCM).  If this cipher is operating in
2764      * either GCM or CCM mode, all AAD must be supplied before beginning
2765      * operations on the ciphertext (via the {@code update}
2766      * and {@code doFinal} methods).
2767      * &lt;p&gt;
2768      * All {@code src.remaining()} bytes starting at
2769      * {@code src.position()} are processed.
2770      * Upon return, the input buffer&#39;s position will be equal
2771      * to its limit; its limit will not have changed.
2772      *
2773      * @param src the buffer containing the AAD
2774      *
2775      * @throws IllegalArgumentException if the {@code src ByteBuffer}
2776      * is null
2777      * @throws IllegalStateException if this cipher is in a wrong state
2778      * (e.g., has not been initialized), does not accept AAD, or if
2779      * operating in either GCM or CCM mode and one of the {@code update}
2780      * methods has already been called for the active
2781      * encryption/decryption operation
2782      * @throws UnsupportedOperationException if the corresponding method
2783      * in the {@code CipherSpi} has not been overridden by an
2784      * implementation
2785      *
2786      * @since 1.7
2787      */
2788     public final void updateAAD(ByteBuffer src) {
2789         checkCipherState();
2790 
2791         // Input sanity check
2792         if (src == null) {
2793             throw new IllegalArgumentException(&quot;src ByteBuffer is null&quot;);
2794         }
2795 
2796         chooseFirstProvider();
2797         if (src.remaining() == 0) {
2798             return;
2799         }
2800         spi.engineUpdateAAD(src);
2801     }
2802 
2803     /**
2804      * Returns a String representation of this Cipher.
2805      *
2806      * @implNote
2807      * This implementation returns a String containing the transformation,
2808      * mode, and provider of this Cipher.
2809      * The exact format of the String is unspecified and is subject to change.
2810      *
2811      * @return a String describing this Cipher
2812      */
2813     @Override
2814     public String toString() {
2815         final StringBuilder sb = new StringBuilder();
2816         sb.append(&quot;Cipher.&quot;)
2817                 .append(transformation)
2818                 .append(&quot;, mode: &quot;);
2819         switch (opmode) {
2820             case 0:
2821                 sb.append(&quot;not initialized&quot;);
2822                 break;
2823             case ENCRYPT_MODE:
2824                 sb.append(&quot;encryption&quot;);
2825                 break;
2826             case DECRYPT_MODE:
2827                 sb.append(&quot;decryption&quot;);
2828                 break;
2829             case WRAP_MODE:
2830                 sb.append(&quot;key wrapping&quot;);
2831                 break;
2832             case UNWRAP_MODE:
2833                 sb.append(&quot;key unwrapping&quot;);
2834                 break;
2835             default:
2836                 // should never happen
2837                 sb.append(&quot;error:&quot;).append(Integer.toString(opmode));
2838         }
2839         sb.append(&quot;, algorithm from: &quot;).append(getProviderName());
2840         return sb.toString();
2841     }
2842 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
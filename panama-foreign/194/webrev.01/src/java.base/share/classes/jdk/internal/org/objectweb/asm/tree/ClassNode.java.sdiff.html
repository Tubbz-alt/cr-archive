<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/org/objectweb/asm/tree/ClassNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../commons/ClassRemapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../util/ASMifier.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/org/objectweb/asm/tree/ClassNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
143     /** The runtime visible type annotations of this class. May be {@literal null}. */
144     public List&lt;TypeAnnotationNode&gt; visibleTypeAnnotations;
145 
146     /** The runtime invisible type annotations of this class. May be {@literal null}. */
147     public List&lt;TypeAnnotationNode&gt; invisibleTypeAnnotations;
148 
149     /** The non standard attributes of this class. May be {@literal null}. */
150     public List&lt;Attribute&gt; attrs;
151 
152     /** The inner classes of this class. */
153     public List&lt;InnerClassNode&gt; innerClasses;
154 
155     /** The internal name of the nest host class of this class. May be {@literal null}. */
156     public String nestHostClass;
157 
158     /** The internal names of the nest members of this class. May be {@literal null}. */
159     public List&lt;String&gt; nestMembers;
160 
161     /**
162       * &lt;b&gt;Experimental, use at your own risk. This method will be renamed when it becomes stable, this
<span class="line-modified">163       * will break existing code using it&lt;/b&gt;. The internal names of the permitted subtypes of this</span>
164       * class. May be {@literal null}.
165       *
166       * @deprecated this API is experimental.
167       */
<span class="line-modified">168     @Deprecated public List&lt;String&gt; permittedSubtypesExperimental;</span>
169 
170     /** The record components of this class. May be {@literal null}. */
171     public List&lt;RecordComponentNode&gt; recordComponents;
172 
173     /** The fields of this class. */
174     public List&lt;FieldNode&gt; fields;
175 
176     /** The methods of this class. */
177     public List&lt;MethodNode&gt; methods;
178 
179     /**
180       * Constructs a new {@link ClassNode}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;. Instead,
181       * they must use the {@link #ClassNode(int)} version.
182       *
183       * @throws IllegalStateException If a subclass calls this constructor.
184       */
185     public ClassNode() {
186         this(Opcodes.ASM8);
187         if (getClass() != ClassNode.class) {
188             throw new IllegalStateException();
</pre>
<hr />
<pre>
267             visibleTypeAnnotations = Util.add(visibleTypeAnnotations, typeAnnotation);
268         } else {
269             invisibleTypeAnnotations = Util.add(invisibleTypeAnnotations, typeAnnotation);
270         }
271         return typeAnnotation;
272     }
273 
274     @Override
275     public void visitAttribute(final Attribute attribute) {
276         attrs = Util.add(attrs, attribute);
277     }
278 
279     @Override
280     public void visitNestMember(final String nestMember) {
281         nestMembers = Util.add(nestMembers, nestMember);
282     }
283 
284     /**
285       * &lt;b&gt;Experimental, use at your own risk.&lt;/b&gt;.
286       *
<span class="line-modified">287       * @param permittedSubtype the internal name of a permitted subtype.</span>
288       * @deprecated this API is experimental.
289       */
290     @Override
291     @Deprecated
<span class="line-modified">292     public void visitPermittedSubtypeExperimental(final String permittedSubtype) {</span>
<span class="line-modified">293         permittedSubtypesExperimental = Util.add(permittedSubtypesExperimental, permittedSubtype);</span>
294     }
295 
296     @Override
297     public void visitInnerClass(
298             final String name, final String outerName, final String innerName, final int access) {
299         InnerClassNode innerClass = new InnerClassNode(name, outerName, innerName, access);
300         innerClasses.add(innerClass);
301     }
302 
303     @Override
304     public RecordComponentVisitor visitRecordComponent(
305             final String name, final String descriptor, final String signature) {
306         RecordComponentNode recordComponent = new RecordComponentNode(name, descriptor, signature);
307         recordComponents = Util.add(recordComponents, recordComponent);
308         return recordComponent;
309     }
310 
311     @Override
312     public FieldVisitor visitField(
313             final int access,
</pre>
<hr />
<pre>
334 
335     @Override
336     public void visitEnd() {
337         // Nothing to do.
338     }
339 
340     // -----------------------------------------------------------------------------------------------
341     // Accept method
342     // -----------------------------------------------------------------------------------------------
343 
344     /**
345       * Checks that this class node is compatible with the given ASM API version. This method checks
346       * that this node, and all its children recursively, do not contain elements that were introduced
347       * in more recent versions of the ASM API than the given version.
348       *
349       * @param api an ASM API version. Must be one of {@link Opcodes#ASM4}, {@link Opcodes#ASM5},
350       *     {@link Opcodes#ASM6}, {@link Opcodes#ASM7}. or {@link Opcodes#ASM8}.
351       */
352     @SuppressWarnings(&quot;deprecation&quot;)
353     public void check(final int api) {
<span class="line-modified">354         if (api != Opcodes.ASM9_EXPERIMENTAL &amp;&amp; permittedSubtypesExperimental != null) {</span>
355             throw new UnsupportedClassVersionException();
356         }
357         if (api &lt; Opcodes.ASM8 &amp;&amp; ((access &amp; Opcodes.ACC_RECORD) != 0 || recordComponents != null)) {
358             throw new UnsupportedClassVersionException();
359         }
360         if (api &lt; Opcodes.ASM7 &amp;&amp; (nestHostClass != null || nestMembers != null)) {
361             throw new UnsupportedClassVersionException();
362         }
363         if (api &lt; Opcodes.ASM6 &amp;&amp; module != null) {
364             throw new UnsupportedClassVersionException();
365         }
366         if (api &lt; Opcodes.ASM5) {
367             if (visibleTypeAnnotations != null &amp;&amp; !visibleTypeAnnotations.isEmpty()) {
368                 throw new UnsupportedClassVersionException();
369             }
370             if (invisibleTypeAnnotations != null &amp;&amp; !invisibleTypeAnnotations.isEmpty()) {
371                 throw new UnsupportedClassVersionException();
372             }
373         }
374         // Check the annotations.
</pre>
<hr />
<pre>
456         if (invisibleTypeAnnotations != null) {
457             for (int i = 0, n = invisibleTypeAnnotations.size(); i &lt; n; ++i) {
458                 TypeAnnotationNode typeAnnotation = invisibleTypeAnnotations.get(i);
459                 typeAnnotation.accept(
460                         classVisitor.visitTypeAnnotation(
461                                 typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, false));
462             }
463         }
464         // Visit the non standard attributes.
465         if (attrs != null) {
466             for (int i = 0, n = attrs.size(); i &lt; n; ++i) {
467                 classVisitor.visitAttribute(attrs.get(i));
468             }
469         }
470         // Visit the nest members.
471         if (nestMembers != null) {
472             for (int i = 0, n = nestMembers.size(); i &lt; n; ++i) {
473                 classVisitor.visitNestMember(nestMembers.get(i));
474             }
475         }
<span class="line-modified">476         // Visit the permitted subtypes.</span>
<span class="line-modified">477         if (permittedSubtypesExperimental != null) {</span>
<span class="line-modified">478             for (int i = 0, n = permittedSubtypesExperimental.size(); i &lt; n; ++i) {</span>
<span class="line-modified">479                 classVisitor.visitPermittedSubtypeExperimental(permittedSubtypesExperimental.get(i));</span>
480             }
481         }
482         // Visit the inner classes.
483         for (int i = 0, n = innerClasses.size(); i &lt; n; ++i) {
484             innerClasses.get(i).accept(classVisitor);
485         }
486         // Visit the record components.
487         if (recordComponents != null) {
488             for (int i = 0, n = recordComponents.size(); i &lt; n; ++i) {
489                 recordComponents.get(i).accept(classVisitor);
490             }
491         }
492         // Visit the fields.
493         for (int i = 0, n = fields.size(); i &lt; n; ++i) {
494             fields.get(i).accept(classVisitor);
495         }
496         // Visit the methods.
497         for (int i = 0, n = methods.size(); i &lt; n; ++i) {
498             methods.get(i).accept(classVisitor);
499         }
</pre>
</td>
<td>
<hr />
<pre>
143     /** The runtime visible type annotations of this class. May be {@literal null}. */
144     public List&lt;TypeAnnotationNode&gt; visibleTypeAnnotations;
145 
146     /** The runtime invisible type annotations of this class. May be {@literal null}. */
147     public List&lt;TypeAnnotationNode&gt; invisibleTypeAnnotations;
148 
149     /** The non standard attributes of this class. May be {@literal null}. */
150     public List&lt;Attribute&gt; attrs;
151 
152     /** The inner classes of this class. */
153     public List&lt;InnerClassNode&gt; innerClasses;
154 
155     /** The internal name of the nest host class of this class. May be {@literal null}. */
156     public String nestHostClass;
157 
158     /** The internal names of the nest members of this class. May be {@literal null}. */
159     public List&lt;String&gt; nestMembers;
160 
161     /**
162       * &lt;b&gt;Experimental, use at your own risk. This method will be renamed when it becomes stable, this
<span class="line-modified">163       * will break existing code using it&lt;/b&gt;. The internal names of the permitted subclasses of this</span>
164       * class. May be {@literal null}.
165       *
166       * @deprecated this API is experimental.
167       */
<span class="line-modified">168     @Deprecated public List&lt;String&gt; permittedSubclassesExperimental;</span>
169 
170     /** The record components of this class. May be {@literal null}. */
171     public List&lt;RecordComponentNode&gt; recordComponents;
172 
173     /** The fields of this class. */
174     public List&lt;FieldNode&gt; fields;
175 
176     /** The methods of this class. */
177     public List&lt;MethodNode&gt; methods;
178 
179     /**
180       * Constructs a new {@link ClassNode}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;. Instead,
181       * they must use the {@link #ClassNode(int)} version.
182       *
183       * @throws IllegalStateException If a subclass calls this constructor.
184       */
185     public ClassNode() {
186         this(Opcodes.ASM8);
187         if (getClass() != ClassNode.class) {
188             throw new IllegalStateException();
</pre>
<hr />
<pre>
267             visibleTypeAnnotations = Util.add(visibleTypeAnnotations, typeAnnotation);
268         } else {
269             invisibleTypeAnnotations = Util.add(invisibleTypeAnnotations, typeAnnotation);
270         }
271         return typeAnnotation;
272     }
273 
274     @Override
275     public void visitAttribute(final Attribute attribute) {
276         attrs = Util.add(attrs, attribute);
277     }
278 
279     @Override
280     public void visitNestMember(final String nestMember) {
281         nestMembers = Util.add(nestMembers, nestMember);
282     }
283 
284     /**
285       * &lt;b&gt;Experimental, use at your own risk.&lt;/b&gt;.
286       *
<span class="line-modified">287       * @param permittedSubclass the internal name of a permitted subclass.</span>
288       * @deprecated this API is experimental.
289       */
290     @Override
291     @Deprecated
<span class="line-modified">292     public void visitPermittedSubclassExperimental(final String permittedSubclass) {</span>
<span class="line-modified">293         permittedSubclassesExperimental = Util.add(permittedSubclassesExperimental, permittedSubclass);</span>
294     }
295 
296     @Override
297     public void visitInnerClass(
298             final String name, final String outerName, final String innerName, final int access) {
299         InnerClassNode innerClass = new InnerClassNode(name, outerName, innerName, access);
300         innerClasses.add(innerClass);
301     }
302 
303     @Override
304     public RecordComponentVisitor visitRecordComponent(
305             final String name, final String descriptor, final String signature) {
306         RecordComponentNode recordComponent = new RecordComponentNode(name, descriptor, signature);
307         recordComponents = Util.add(recordComponents, recordComponent);
308         return recordComponent;
309     }
310 
311     @Override
312     public FieldVisitor visitField(
313             final int access,
</pre>
<hr />
<pre>
334 
335     @Override
336     public void visitEnd() {
337         // Nothing to do.
338     }
339 
340     // -----------------------------------------------------------------------------------------------
341     // Accept method
342     // -----------------------------------------------------------------------------------------------
343 
344     /**
345       * Checks that this class node is compatible with the given ASM API version. This method checks
346       * that this node, and all its children recursively, do not contain elements that were introduced
347       * in more recent versions of the ASM API than the given version.
348       *
349       * @param api an ASM API version. Must be one of {@link Opcodes#ASM4}, {@link Opcodes#ASM5},
350       *     {@link Opcodes#ASM6}, {@link Opcodes#ASM7}. or {@link Opcodes#ASM8}.
351       */
352     @SuppressWarnings(&quot;deprecation&quot;)
353     public void check(final int api) {
<span class="line-modified">354         if (api != Opcodes.ASM9_EXPERIMENTAL &amp;&amp; permittedSubclassesExperimental != null) {</span>
355             throw new UnsupportedClassVersionException();
356         }
357         if (api &lt; Opcodes.ASM8 &amp;&amp; ((access &amp; Opcodes.ACC_RECORD) != 0 || recordComponents != null)) {
358             throw new UnsupportedClassVersionException();
359         }
360         if (api &lt; Opcodes.ASM7 &amp;&amp; (nestHostClass != null || nestMembers != null)) {
361             throw new UnsupportedClassVersionException();
362         }
363         if (api &lt; Opcodes.ASM6 &amp;&amp; module != null) {
364             throw new UnsupportedClassVersionException();
365         }
366         if (api &lt; Opcodes.ASM5) {
367             if (visibleTypeAnnotations != null &amp;&amp; !visibleTypeAnnotations.isEmpty()) {
368                 throw new UnsupportedClassVersionException();
369             }
370             if (invisibleTypeAnnotations != null &amp;&amp; !invisibleTypeAnnotations.isEmpty()) {
371                 throw new UnsupportedClassVersionException();
372             }
373         }
374         // Check the annotations.
</pre>
<hr />
<pre>
456         if (invisibleTypeAnnotations != null) {
457             for (int i = 0, n = invisibleTypeAnnotations.size(); i &lt; n; ++i) {
458                 TypeAnnotationNode typeAnnotation = invisibleTypeAnnotations.get(i);
459                 typeAnnotation.accept(
460                         classVisitor.visitTypeAnnotation(
461                                 typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, false));
462             }
463         }
464         // Visit the non standard attributes.
465         if (attrs != null) {
466             for (int i = 0, n = attrs.size(); i &lt; n; ++i) {
467                 classVisitor.visitAttribute(attrs.get(i));
468             }
469         }
470         // Visit the nest members.
471         if (nestMembers != null) {
472             for (int i = 0, n = nestMembers.size(); i &lt; n; ++i) {
473                 classVisitor.visitNestMember(nestMembers.get(i));
474             }
475         }
<span class="line-modified">476         // Visit the permitted subclass.</span>
<span class="line-modified">477         if (permittedSubclassesExperimental != null) {</span>
<span class="line-modified">478             for (int i = 0, n = permittedSubclassesExperimental.size(); i &lt; n; ++i) {</span>
<span class="line-modified">479                 classVisitor.visitPermittedSubclassExperimental(permittedSubclassesExperimental.get(i));</span>
480             }
481         }
482         // Visit the inner classes.
483         for (int i = 0, n = innerClasses.size(); i &lt; n; ++i) {
484             innerClasses.get(i).accept(classVisitor);
485         }
486         // Visit the record components.
487         if (recordComponents != null) {
488             for (int i = 0, n = recordComponents.size(); i &lt; n; ++i) {
489                 recordComponents.get(i).accept(classVisitor);
490             }
491         }
492         // Visit the fields.
493         for (int i = 0, n = fields.size(); i &lt; n; ++i) {
494             fields.get(i).accept(classVisitor);
495         }
496         // Visit the methods.
497         for (int i = 0, n = methods.size(); i &lt; n; ++i) {
498             methods.get(i).accept(classVisitor);
499         }
</pre>
</td>
</tr>
</table>
<center><a href="../commons/ClassRemapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../util/ASMifier.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassVisitor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Constants.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 191     private AnnotationWriter lastRuntimeVisibleTypeAnnotation;
 192 
 193     /**
 194       * The last runtime invisible type annotation of this class. The previous ones can be accessed
 195       * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
 196       */
 197     private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;
 198 
 199     /** The Module attribute of this class, or {@literal null}. */
 200     private ModuleWriter moduleWriter;
 201 
 202     /** The host_class_index field of the NestHost attribute, or 0. */
 203     private int nestHostClassIndex;
 204 
 205     /** The number_of_classes field of the NestMembers attribute, or 0. */
 206     private int numberOfNestMemberClasses;
 207 
 208     /** The &#39;classes&#39; array of the NestMembers attribute, or {@literal null}. */
 209     private ByteVector nestMemberClasses;
 210 
<span class="line-modified"> 211     /** The number_of_classes field of the PermittedSubtypes attribute, or 0. */</span>
<span class="line-modified"> 212     private int numberOfPermittedSubtypeClasses;</span>
 213 
<span class="line-modified"> 214     /** The &#39;classes&#39; array of the PermittedSubtypes attribute, or {@literal null}. */</span>
<span class="line-modified"> 215     private ByteVector permittedSubtypeClasses;</span>
 216 
 217     /**
 218       * The record components of this class, stored in a linked list of {@link RecordComponentWriter}
 219       * linked via their {@link RecordComponentWriter#delegate} field. This field stores the first
 220       * element of this list.
 221       */
 222     private RecordComponentWriter firstRecordComponent;
 223 
 224     /**
 225       * The record components of this class, stored in a linked list of {@link RecordComponentWriter}
 226       * linked via their {@link RecordComponentWriter#delegate} field. This field stores the last
 227       * element of this list.
 228       */
 229     private RecordComponentWriter lastRecordComponent;
 230 
 231     /**
 232       * The first non standard attribute of this class. The next ones can be accessed with the {@link
 233       * Attribute#nextAttribute} field. May be {@literal null}.
 234       *
 235       * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: this list stores the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit.
</pre>
<hr />
<pre>
 389 
 390     @Override
 391     public final void visitAttribute(final Attribute attribute) {
 392         // Store the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit by this method.
 393         attribute.nextAttribute = firstAttribute;
 394         firstAttribute = attribute;
 395     }
 396 
 397     @Override
 398     public final void visitNestMember(final String nestMember) {
 399         if (nestMemberClasses == null) {
 400             nestMemberClasses = new ByteVector();
 401         }
 402         ++numberOfNestMemberClasses;
 403         nestMemberClasses.putShort(symbolTable.addConstantClass(nestMember).index);
 404     }
 405 
 406     /**
 407       * &lt;b&gt;Experimental, use at your own risk.&lt;/b&gt;
 408       *
<span class="line-modified"> 409       * @param permittedSubtype the internal name of a permitted subtype.</span>
 410       * @deprecated this API is experimental.
 411       */
 412     @Override
 413     @Deprecated
<span class="line-modified"> 414     public final void visitPermittedSubtypeExperimental(final String permittedSubtype) {</span>
<span class="line-modified"> 415         if (permittedSubtypeClasses == null) {</span>
<span class="line-modified"> 416             permittedSubtypeClasses = new ByteVector();</span>
 417         }
<span class="line-modified"> 418         ++numberOfPermittedSubtypeClasses;</span>
<span class="line-modified"> 419         permittedSubtypeClasses.putShort(symbolTable.addConstantClass(permittedSubtype).index);</span>
 420     }
 421 
 422     @Override
 423     public final void visitInnerClass(
 424             final String name, final String outerName, final String innerName, final int access) {
 425         if (innerClasses == null) {
 426             innerClasses = new ByteVector();
 427         }
 428         // Section 4.7.6 of the JVMS states &quot;Every CONSTANT_Class_info entry in the constant_pool table
 429         // which represents a class or interface C that is not a package member must have exactly one
 430         // corresponding entry in the classes array&quot;. To avoid duplicates we keep track in the info
 431         // field of the Symbol of each CONSTANT_Class_info entry C whether an inner class entry has
 432         // already been added for C. If so, we store the index of this inner class entry (plus one) in
 433         // the info field. This trick allows duplicate detection in O(1) time.
 434         Symbol nameSymbol = symbolTable.addConstantClass(name);
 435         if (nameSymbol.info == 0) {
 436             ++numberOfInnerClasses;
 437             innerClasses.putShort(nameSymbol.index);
 438             innerClasses.putShort(outerName == null ? 0 : symbolTable.addConstantClass(outerName).index);
 439             innerClasses.putShort(innerName == null ? 0 : symbolTable.addConstantUtf8(innerName));
</pre>
<hr />
<pre>
 590                             Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
 591         }
 592         if (symbolTable.computeBootstrapMethodsSize() &gt; 0) {
 593             ++attributesCount;
 594             size += symbolTable.computeBootstrapMethodsSize();
 595         }
 596         if (moduleWriter != null) {
 597             attributesCount += moduleWriter.getAttributeCount();
 598             size += moduleWriter.computeAttributesSize();
 599         }
 600         if (nestHostClassIndex != 0) {
 601             ++attributesCount;
 602             size += 8;
 603             symbolTable.addConstantUtf8(Constants.NEST_HOST);
 604         }
 605         if (nestMemberClasses != null) {
 606             ++attributesCount;
 607             size += 8 + nestMemberClasses.length;
 608             symbolTable.addConstantUtf8(Constants.NEST_MEMBERS);
 609         }
<span class="line-modified"> 610         if (permittedSubtypeClasses != null) {</span>
 611             ++attributesCount;
<span class="line-modified"> 612             size += 8 + permittedSubtypeClasses.length;</span>
<span class="line-modified"> 613             symbolTable.addConstantUtf8(Constants.PERMITTED_SUBTYPES);</span>
 614         }
 615         int recordComponentCount = 0;
 616         int recordSize = 0;
 617         if ((accessFlags &amp; Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {
 618             RecordComponentWriter recordComponentWriter = firstRecordComponent;
 619             while (recordComponentWriter != null) {
 620                 ++recordComponentCount;
 621                 recordSize += recordComponentWriter.computeRecordComponentInfoSize();
 622                 recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;
 623             }
 624             ++attributesCount;
 625             size += 8 + recordSize;
 626             symbolTable.addConstantUtf8(Constants.RECORD);
 627         }
 628         if (firstAttribute != null) {
 629             attributesCount += firstAttribute.getAttributeCount();
 630             size += firstAttribute.computeAttributesSize(symbolTable);
 631         }
 632         // IMPORTANT: this must be the last part of the ClassFile size computation, because the previous
 633         // statements can add attribute names to the constant pool, thereby changing its size!
</pre>
<hr />
<pre>
 712                 lastRuntimeVisibleTypeAnnotation,
 713                 lastRuntimeInvisibleTypeAnnotation,
 714                 result);
 715         symbolTable.putBootstrapMethods(result);
 716         if (moduleWriter != null) {
 717             moduleWriter.putAttributes(result);
 718         }
 719         if (nestHostClassIndex != 0) {
 720             result
 721                     .putShort(symbolTable.addConstantUtf8(Constants.NEST_HOST))
 722                     .putInt(2)
 723                     .putShort(nestHostClassIndex);
 724         }
 725         if (nestMemberClasses != null) {
 726             result
 727                     .putShort(symbolTable.addConstantUtf8(Constants.NEST_MEMBERS))
 728                     .putInt(nestMemberClasses.length + 2)
 729                     .putShort(numberOfNestMemberClasses)
 730                     .putByteArray(nestMemberClasses.data, 0, nestMemberClasses.length);
 731         }
<span class="line-modified"> 732         if (permittedSubtypeClasses != null) {</span>
 733             result
<span class="line-modified"> 734                     .putShort(symbolTable.addConstantUtf8(Constants.PERMITTED_SUBTYPES))</span>
<span class="line-modified"> 735                     .putInt(permittedSubtypeClasses.length + 2)</span>
<span class="line-modified"> 736                     .putShort(numberOfPermittedSubtypeClasses)</span>
<span class="line-modified"> 737                     .putByteArray(permittedSubtypeClasses.data, 0, permittedSubtypeClasses.length);</span>
 738         }
 739         if ((accessFlags &amp; Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {
 740             result
 741                     .putShort(symbolTable.addConstantUtf8(Constants.RECORD))
 742                     .putInt(recordSize + 2)
 743                     .putShort(recordComponentCount);
 744             RecordComponentWriter recordComponentWriter = firstRecordComponent;
 745             while (recordComponentWriter != null) {
 746                 recordComponentWriter.putRecordComponentInfo(result);
 747                 recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;
 748             }
 749         }
 750         if (firstAttribute != null) {
 751             firstAttribute.putAttributes(symbolTable, result);
 752         }
 753 
 754         // Third step: replace the ASM specific instructions, if any.
 755         if (hasAsmInstructions) {
 756             return replaceAsmInstructions(result.data, hasFrames);
 757         } else {
</pre>
<hr />
<pre>
 766       * @param classFile a class file containing ASM specific instructions, generated by this
 767       *     ClassWriter.
 768       * @param hasFrames whether there is at least one stack map frames in &#39;classFile&#39;.
 769       * @return an equivalent of &#39;classFile&#39;, with the ASM specific instructions replaced with standard
 770       *     ones.
 771       */
 772     private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) {
 773         final Attribute[] attributes = getAttributePrototypes();
 774         firstField = null;
 775         lastField = null;
 776         firstMethod = null;
 777         lastMethod = null;
 778         lastRuntimeVisibleAnnotation = null;
 779         lastRuntimeInvisibleAnnotation = null;
 780         lastRuntimeVisibleTypeAnnotation = null;
 781         lastRuntimeInvisibleTypeAnnotation = null;
 782         moduleWriter = null;
 783         nestHostClassIndex = 0;
 784         numberOfNestMemberClasses = 0;
 785         nestMemberClasses = null;
<span class="line-modified"> 786         numberOfPermittedSubtypeClasses = 0;</span>
<span class="line-modified"> 787         permittedSubtypeClasses = null;</span>
 788         firstRecordComponent = null;
 789         lastRecordComponent = null;
 790         firstAttribute = null;
 791         compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING;
 792         new ClassReader(classFile, 0, /* checkClassVersion = */ false)
 793                 .accept(
 794                         this,
 795                         attributes,
 796                         (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS);
 797         return toByteArray();
 798     }
 799 
 800     /**
 801       * Returns the prototypes of the attributes used by this class, its fields and its methods.
 802       *
 803       * @return the prototypes of the attributes used by this class, its fields and its methods.
 804       */
 805     private Attribute[] getAttributePrototypes() {
 806         Attribute.Set attributePrototypes = new Attribute.Set();
 807         attributePrototypes.addAttributes(firstAttribute);
</pre>
</td>
<td>
<hr />
<pre>
 191     private AnnotationWriter lastRuntimeVisibleTypeAnnotation;
 192 
 193     /**
 194       * The last runtime invisible type annotation of this class. The previous ones can be accessed
 195       * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
 196       */
 197     private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;
 198 
 199     /** The Module attribute of this class, or {@literal null}. */
 200     private ModuleWriter moduleWriter;
 201 
 202     /** The host_class_index field of the NestHost attribute, or 0. */
 203     private int nestHostClassIndex;
 204 
 205     /** The number_of_classes field of the NestMembers attribute, or 0. */
 206     private int numberOfNestMemberClasses;
 207 
 208     /** The &#39;classes&#39; array of the NestMembers attribute, or {@literal null}. */
 209     private ByteVector nestMemberClasses;
 210 
<span class="line-modified"> 211     /** The number_of_classes field of the PermittedSubclasses attribute, or 0. */</span>
<span class="line-modified"> 212     private int numberOfPermittedSubclassClasses;</span>
 213 
<span class="line-modified"> 214     /** The &#39;classes&#39; array of the PermittedSubclasses attribute, or {@literal null}. */</span>
<span class="line-modified"> 215     private ByteVector permittedSubclassClasses;</span>
 216 
 217     /**
 218       * The record components of this class, stored in a linked list of {@link RecordComponentWriter}
 219       * linked via their {@link RecordComponentWriter#delegate} field. This field stores the first
 220       * element of this list.
 221       */
 222     private RecordComponentWriter firstRecordComponent;
 223 
 224     /**
 225       * The record components of this class, stored in a linked list of {@link RecordComponentWriter}
 226       * linked via their {@link RecordComponentWriter#delegate} field. This field stores the last
 227       * element of this list.
 228       */
 229     private RecordComponentWriter lastRecordComponent;
 230 
 231     /**
 232       * The first non standard attribute of this class. The next ones can be accessed with the {@link
 233       * Attribute#nextAttribute} field. May be {@literal null}.
 234       *
 235       * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: this list stores the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit.
</pre>
<hr />
<pre>
 389 
 390     @Override
 391     public final void visitAttribute(final Attribute attribute) {
 392         // Store the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit by this method.
 393         attribute.nextAttribute = firstAttribute;
 394         firstAttribute = attribute;
 395     }
 396 
 397     @Override
 398     public final void visitNestMember(final String nestMember) {
 399         if (nestMemberClasses == null) {
 400             nestMemberClasses = new ByteVector();
 401         }
 402         ++numberOfNestMemberClasses;
 403         nestMemberClasses.putShort(symbolTable.addConstantClass(nestMember).index);
 404     }
 405 
 406     /**
 407       * &lt;b&gt;Experimental, use at your own risk.&lt;/b&gt;
 408       *
<span class="line-modified"> 409       * @param permittedSubclass the internal name of a permitted subclass.</span>
 410       * @deprecated this API is experimental.
 411       */
 412     @Override
 413     @Deprecated
<span class="line-modified"> 414     public final void visitPermittedSubclassExperimental(final String permittedSubclass) {</span>
<span class="line-modified"> 415         if (permittedSubclassClasses == null) {</span>
<span class="line-modified"> 416             permittedSubclassClasses = new ByteVector();</span>
 417         }
<span class="line-modified"> 418         ++numberOfPermittedSubclassClasses;</span>
<span class="line-modified"> 419         permittedSubclassClasses.putShort(symbolTable.addConstantClass(permittedSubclass).index);</span>
 420     }
 421 
 422     @Override
 423     public final void visitInnerClass(
 424             final String name, final String outerName, final String innerName, final int access) {
 425         if (innerClasses == null) {
 426             innerClasses = new ByteVector();
 427         }
 428         // Section 4.7.6 of the JVMS states &quot;Every CONSTANT_Class_info entry in the constant_pool table
 429         // which represents a class or interface C that is not a package member must have exactly one
 430         // corresponding entry in the classes array&quot;. To avoid duplicates we keep track in the info
 431         // field of the Symbol of each CONSTANT_Class_info entry C whether an inner class entry has
 432         // already been added for C. If so, we store the index of this inner class entry (plus one) in
 433         // the info field. This trick allows duplicate detection in O(1) time.
 434         Symbol nameSymbol = symbolTable.addConstantClass(name);
 435         if (nameSymbol.info == 0) {
 436             ++numberOfInnerClasses;
 437             innerClasses.putShort(nameSymbol.index);
 438             innerClasses.putShort(outerName == null ? 0 : symbolTable.addConstantClass(outerName).index);
 439             innerClasses.putShort(innerName == null ? 0 : symbolTable.addConstantUtf8(innerName));
</pre>
<hr />
<pre>
 590                             Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
 591         }
 592         if (symbolTable.computeBootstrapMethodsSize() &gt; 0) {
 593             ++attributesCount;
 594             size += symbolTable.computeBootstrapMethodsSize();
 595         }
 596         if (moduleWriter != null) {
 597             attributesCount += moduleWriter.getAttributeCount();
 598             size += moduleWriter.computeAttributesSize();
 599         }
 600         if (nestHostClassIndex != 0) {
 601             ++attributesCount;
 602             size += 8;
 603             symbolTable.addConstantUtf8(Constants.NEST_HOST);
 604         }
 605         if (nestMemberClasses != null) {
 606             ++attributesCount;
 607             size += 8 + nestMemberClasses.length;
 608             symbolTable.addConstantUtf8(Constants.NEST_MEMBERS);
 609         }
<span class="line-modified"> 610         if (permittedSubclassClasses != null) {</span>
 611             ++attributesCount;
<span class="line-modified"> 612             size += 8 + permittedSubclassClasses.length;</span>
<span class="line-modified"> 613             symbolTable.addConstantUtf8(Constants.PERMITTED_SUBCLASSES);</span>
 614         }
 615         int recordComponentCount = 0;
 616         int recordSize = 0;
 617         if ((accessFlags &amp; Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {
 618             RecordComponentWriter recordComponentWriter = firstRecordComponent;
 619             while (recordComponentWriter != null) {
 620                 ++recordComponentCount;
 621                 recordSize += recordComponentWriter.computeRecordComponentInfoSize();
 622                 recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;
 623             }
 624             ++attributesCount;
 625             size += 8 + recordSize;
 626             symbolTable.addConstantUtf8(Constants.RECORD);
 627         }
 628         if (firstAttribute != null) {
 629             attributesCount += firstAttribute.getAttributeCount();
 630             size += firstAttribute.computeAttributesSize(symbolTable);
 631         }
 632         // IMPORTANT: this must be the last part of the ClassFile size computation, because the previous
 633         // statements can add attribute names to the constant pool, thereby changing its size!
</pre>
<hr />
<pre>
 712                 lastRuntimeVisibleTypeAnnotation,
 713                 lastRuntimeInvisibleTypeAnnotation,
 714                 result);
 715         symbolTable.putBootstrapMethods(result);
 716         if (moduleWriter != null) {
 717             moduleWriter.putAttributes(result);
 718         }
 719         if (nestHostClassIndex != 0) {
 720             result
 721                     .putShort(symbolTable.addConstantUtf8(Constants.NEST_HOST))
 722                     .putInt(2)
 723                     .putShort(nestHostClassIndex);
 724         }
 725         if (nestMemberClasses != null) {
 726             result
 727                     .putShort(symbolTable.addConstantUtf8(Constants.NEST_MEMBERS))
 728                     .putInt(nestMemberClasses.length + 2)
 729                     .putShort(numberOfNestMemberClasses)
 730                     .putByteArray(nestMemberClasses.data, 0, nestMemberClasses.length);
 731         }
<span class="line-modified"> 732         if (permittedSubclassClasses != null) {</span>
 733             result
<span class="line-modified"> 734                     .putShort(symbolTable.addConstantUtf8(Constants.PERMITTED_SUBCLASSES))</span>
<span class="line-modified"> 735                     .putInt(permittedSubclassClasses.length + 2)</span>
<span class="line-modified"> 736                     .putShort(numberOfPermittedSubclassClasses)</span>
<span class="line-modified"> 737                     .putByteArray(permittedSubclassClasses.data, 0, permittedSubclassClasses.length);</span>
 738         }
 739         if ((accessFlags &amp; Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {
 740             result
 741                     .putShort(symbolTable.addConstantUtf8(Constants.RECORD))
 742                     .putInt(recordSize + 2)
 743                     .putShort(recordComponentCount);
 744             RecordComponentWriter recordComponentWriter = firstRecordComponent;
 745             while (recordComponentWriter != null) {
 746                 recordComponentWriter.putRecordComponentInfo(result);
 747                 recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;
 748             }
 749         }
 750         if (firstAttribute != null) {
 751             firstAttribute.putAttributes(symbolTable, result);
 752         }
 753 
 754         // Third step: replace the ASM specific instructions, if any.
 755         if (hasAsmInstructions) {
 756             return replaceAsmInstructions(result.data, hasFrames);
 757         } else {
</pre>
<hr />
<pre>
 766       * @param classFile a class file containing ASM specific instructions, generated by this
 767       *     ClassWriter.
 768       * @param hasFrames whether there is at least one stack map frames in &#39;classFile&#39;.
 769       * @return an equivalent of &#39;classFile&#39;, with the ASM specific instructions replaced with standard
 770       *     ones.
 771       */
 772     private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) {
 773         final Attribute[] attributes = getAttributePrototypes();
 774         firstField = null;
 775         lastField = null;
 776         firstMethod = null;
 777         lastMethod = null;
 778         lastRuntimeVisibleAnnotation = null;
 779         lastRuntimeInvisibleAnnotation = null;
 780         lastRuntimeVisibleTypeAnnotation = null;
 781         lastRuntimeInvisibleTypeAnnotation = null;
 782         moduleWriter = null;
 783         nestHostClassIndex = 0;
 784         numberOfNestMemberClasses = 0;
 785         nestMemberClasses = null;
<span class="line-modified"> 786         numberOfPermittedSubclassClasses = 0;</span>
<span class="line-modified"> 787         permittedSubclassClasses = null;</span>
 788         firstRecordComponent = null;
 789         lastRecordComponent = null;
 790         firstAttribute = null;
 791         compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING;
 792         new ClassReader(classFile, 0, /* checkClassVersion = */ false)
 793                 .accept(
 794                         this,
 795                         attributes,
 796                         (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS);
 797         return toByteArray();
 798     }
 799 
 800     /**
 801       * Returns the prototypes of the attributes used by this class, its fields and its methods.
 802       *
 803       * @return the prototypes of the attributes used by this class, its fields and its methods.
 804       */
 805     private Attribute[] getAttributePrototypes() {
 806         Attribute.Set attributePrototypes = new Attribute.Set();
 807         attributePrototypes.addAttributes(firstAttribute);
</pre>
</td>
</tr>
</table>
<center><a href="ClassVisitor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Constants.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/module/ModuleInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.module;
  27 
  28 import java.io.DataInput;
  29 import java.io.DataInputStream;
  30 import java.io.EOFException;
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.UncheckedIOException;
  34 import java.lang.module.InvalidModuleDescriptorException;
  35 import java.lang.module.ModuleDescriptor;
  36 import java.lang.module.ModuleDescriptor.Builder;
  37 import java.lang.module.ModuleDescriptor.Requires;
  38 import java.lang.module.ModuleDescriptor.Exports;
  39 import java.lang.module.ModuleDescriptor.Opens;
  40 import java.nio.ByteBuffer;
  41 import java.nio.BufferUnderflowException;
  42 import java.util.ArrayList;
  43 import java.util.HashMap;
  44 import java.util.HashSet;
  45 import java.util.List;
  46 import java.util.Map;
  47 import java.util.Set;
  48 import java.util.function.Supplier;
  49 
  50 import jdk.internal.access.JavaLangModuleAccess;
  51 import jdk.internal.access.SharedSecrets;
<a name="1" id="anc1"></a><span class="line-added">  52 import jdk.internal.misc.VM;</span>
  53 
  54 import static jdk.internal.module.ClassFileConstants.*;
  55 
  56 
  57 /**
  58  * Read module information from a {@code module-info} class file.
  59  *
  60  * @implNote The rationale for the hand-coded reader is startup performance
  61  * and fine control over the throwing of InvalidModuleDescriptorException.
  62  */
  63 
  64 public final class ModuleInfo {
  65 
<a name="2" id="anc2"></a>


  66     private static final JavaLangModuleAccess JLMA
  67         = SharedSecrets.getJavaLangModuleAccess();
  68 
  69     // supplies the set of packages when ModulePackages attribute not present
  70     private final Supplier&lt;Set&lt;String&gt;&gt; packageFinder;
  71 
  72     // indicates if the ModuleHashes attribute should be parsed
  73     private final boolean parseHashes;
  74 
  75     private ModuleInfo(Supplier&lt;Set&lt;String&gt;&gt; pf, boolean ph) {
  76         packageFinder = pf;
  77         parseHashes = ph;
  78     }
  79 
  80     private ModuleInfo(Supplier&lt;Set&lt;String&gt;&gt; pf) {
  81         this(pf, true);
  82     }
  83 
  84     /**
  85      * A holder class for the ModuleDescriptor that is created by reading the
  86      * Module and other standard class file attributes. It also holds the objects
  87      * that represent the non-standard class file attributes that are read from
  88      * the class file.
  89      */
  90     public static final class Attributes {
  91         private final ModuleDescriptor descriptor;
  92         private final ModuleTarget target;
  93         private final ModuleHashes recordedHashes;
  94         private final ModuleResolution moduleResolution;
  95         Attributes(ModuleDescriptor descriptor,
  96                    ModuleTarget target,
  97                    ModuleHashes recordedHashes,
  98                    ModuleResolution moduleResolution) {
  99             this.descriptor = descriptor;
 100             this.target = target;
 101             this.recordedHashes = recordedHashes;
 102             this.moduleResolution = moduleResolution;
 103         }
 104         public ModuleDescriptor descriptor() {
 105             return descriptor;
 106         }
 107         public ModuleTarget target() {
 108             return target;
 109         }
 110         public ModuleHashes recordedHashes() {
 111             return recordedHashes;
 112         }
 113         public ModuleResolution moduleResolution() {
 114             return moduleResolution;
 115         }
 116     }
 117 
 118 
 119     /**
 120      * Reads a {@code module-info.class} from the given input stream.
 121      *
 122      * @throws InvalidModuleDescriptorException
 123      * @throws IOException
 124      */
 125     public static Attributes read(InputStream in, Supplier&lt;Set&lt;String&gt;&gt; pf)
 126         throws IOException
 127     {
 128         try {
 129             return new ModuleInfo(pf).doRead(new DataInputStream(in));
 130         } catch (IllegalArgumentException | IllegalStateException e) {
 131             throw invalidModuleDescriptor(e.getMessage());
 132         } catch (EOFException x) {
 133             throw truncatedModuleDescriptor();
 134         }
 135     }
 136 
 137     /**
 138      * Reads a {@code module-info.class} from the given byte buffer.
 139      *
 140      * @throws InvalidModuleDescriptorException
 141      * @throws UncheckedIOException
 142      */
 143     public static Attributes read(ByteBuffer bb, Supplier&lt;Set&lt;String&gt;&gt; pf) {
 144         try {
 145             return new ModuleInfo(pf).doRead(new DataInputWrapper(bb));
 146         } catch (IllegalArgumentException | IllegalStateException e) {
 147             throw invalidModuleDescriptor(e.getMessage());
 148         } catch (EOFException x) {
 149             throw truncatedModuleDescriptor();
 150         } catch (IOException ioe) {
 151             throw new UncheckedIOException(ioe);
 152         }
 153     }
 154 
 155     /**
 156      * Reads a {@code module-info.class} from the given byte buffer
 157      * but ignore the {@code ModuleHashes} attribute.
 158      *
 159      * @throws InvalidModuleDescriptorException
 160      * @throws UncheckedIOException
 161      */
 162     public static Attributes readIgnoringHashes(ByteBuffer bb, Supplier&lt;Set&lt;String&gt;&gt; pf) {
 163         try {
 164             return new ModuleInfo(pf, false).doRead(new DataInputWrapper(bb));
 165         } catch (IllegalArgumentException | IllegalStateException e) {
 166             throw invalidModuleDescriptor(e.getMessage());
 167         } catch (EOFException x) {
 168             throw truncatedModuleDescriptor();
 169         } catch (IOException ioe) {
 170             throw new UncheckedIOException(ioe);
 171         }
 172     }
 173 
 174     /**
 175      * Reads the input as a module-info class file.
 176      *
 177      * @throws IOException
 178      * @throws InvalidModuleDescriptorException
 179      * @throws IllegalArgumentException if thrown by the ModuleDescriptor.Builder
 180      *         because an identifier is not a legal Java identifier, duplicate
 181      *         exports, and many other reasons
 182      */
 183     private Attributes doRead(DataInput in) throws IOException {
 184 
 185         int magic = in.readInt();
 186         if (magic != 0xCAFEBABE)
 187             throw invalidModuleDescriptor(&quot;Bad magic number&quot;);
 188 
 189         int minor_version = in.readUnsignedShort();
 190         int major_version = in.readUnsignedShort();
<a name="3" id="anc3"></a><span class="line-modified"> 191         if (!VM.isSupportedModuleDescriptorVersion(major_version, minor_version)) {</span>

 192             throw invalidModuleDescriptor(&quot;Unsupported major.minor version &quot;
 193                                           + major_version + &quot;.&quot; + minor_version);
 194         }
 195 
 196         ConstantPool cpool = new ConstantPool(in);
 197 
 198         int access_flags = in.readUnsignedShort();
 199         if (access_flags != ACC_MODULE)
 200             throw invalidModuleDescriptor(&quot;access_flags should be ACC_MODULE&quot;);
 201 
 202         int this_class = in.readUnsignedShort();
 203         String mn = cpool.getClassName(this_class);
 204         if (!&quot;module-info&quot;.equals(mn))
 205             throw invalidModuleDescriptor(&quot;this_class should be module-info&quot;);
 206 
 207         int super_class = in.readUnsignedShort();
 208         if (super_class &gt; 0)
 209             throw invalidModuleDescriptor(&quot;bad #super_class&quot;);
 210 
 211         int interfaces_count = in.readUnsignedShort();
 212         if (interfaces_count &gt; 0)
 213             throw invalidModuleDescriptor(&quot;Bad #interfaces&quot;);
 214 
 215         int fields_count = in.readUnsignedShort();
 216         if (fields_count &gt; 0)
 217             throw invalidModuleDescriptor(&quot;Bad #fields&quot;);
 218 
 219         int methods_count = in.readUnsignedShort();
 220         if (methods_count &gt; 0)
 221             throw invalidModuleDescriptor(&quot;Bad #methods&quot;);
 222 
 223         int attributes_count = in.readUnsignedShort();
 224 
 225         // the names of the attributes found in the class file
 226         Set&lt;String&gt; attributes = new HashSet&lt;&gt;();
 227 
 228         Builder builder = null;
 229         Set&lt;String&gt; allPackages = null;
 230         String mainClass = null;
 231         ModuleTarget moduleTarget = null;
 232         ModuleHashes moduleHashes = null;
 233         ModuleResolution moduleResolution = null;
 234 
 235         for (int i = 0; i &lt; attributes_count ; i++) {
 236             int name_index = in.readUnsignedShort();
 237             String attribute_name = cpool.getUtf8(name_index);
 238             int length = in.readInt();
 239 
 240             boolean added = attributes.add(attribute_name);
 241             if (!added &amp;&amp; isAttributeAtMostOnce(attribute_name)) {
 242                 throw invalidModuleDescriptor(&quot;More than one &quot;
 243                                               + attribute_name + &quot; attribute&quot;);
 244             }
 245 
 246             switch (attribute_name) {
 247 
 248                 case MODULE :
 249                     builder = readModuleAttribute(in, cpool, major_version);
 250                     break;
 251 
 252                 case MODULE_PACKAGES :
 253                     allPackages = readModulePackagesAttribute(in, cpool);
 254                     break;
 255 
 256                 case MODULE_MAIN_CLASS :
 257                     mainClass = readModuleMainClassAttribute(in, cpool);
 258                     break;
 259 
 260                 case MODULE_TARGET :
 261                     moduleTarget = readModuleTargetAttribute(in, cpool);
 262                     break;
 263 
 264                 case MODULE_HASHES :
 265                     if (parseHashes) {
 266                         moduleHashes = readModuleHashesAttribute(in, cpool);
 267                     } else {
 268                         in.skipBytes(length);
 269                     }
 270                     break;
 271 
 272                 case MODULE_RESOLUTION :
 273                     moduleResolution = readModuleResolution(in, cpool);
 274                     break;
 275 
 276                 default:
 277                     if (isAttributeDisallowed(attribute_name)) {
 278                         throw invalidModuleDescriptor(attribute_name
 279                                                       + &quot; attribute not allowed&quot;);
 280                     } else {
 281                         in.skipBytes(length);
 282                     }
 283 
 284             }
 285         }
 286 
 287         // the Module attribute is required
 288         if (builder == null) {
 289             throw invalidModuleDescriptor(MODULE + &quot; attribute not found&quot;);
 290         }
 291 
 292         // ModuleMainClass  attribute
 293         if (mainClass != null) {
 294             builder.mainClass(mainClass);
 295         }
 296 
 297         // If the ModulePackages attribute is not present then the packageFinder
 298         // is used to find the set of packages
 299         boolean usedPackageFinder = false;
 300         if (allPackages == null &amp;&amp; packageFinder != null) {
 301             try {
 302                 allPackages = packageFinder.get();
 303             } catch (UncheckedIOException x) {
 304                 throw x.getCause();
 305             }
 306             usedPackageFinder = true;
 307         }
 308         if (allPackages != null) {
 309             Set&lt;String&gt; knownPackages = JLMA.packages(builder);
 310             if (!allPackages.containsAll(knownPackages)) {
 311                 Set&lt;String&gt; missingPackages = new HashSet&lt;&gt;(knownPackages);
 312                 missingPackages.removeAll(allPackages);
 313                 assert !missingPackages.isEmpty();
 314                 String missingPackage = missingPackages.iterator().next();
 315                 String tail;
 316                 if (usedPackageFinder) {
 317                     tail = &quot; not found in module&quot;;
 318                 } else {
 319                     tail = &quot; missing from ModulePackages class file attribute&quot;;
 320                 }
 321                 throw invalidModuleDescriptor(&quot;Package &quot; + missingPackage + tail);
 322 
 323             }
 324             builder.packages(allPackages);
 325         }
 326 
 327         ModuleDescriptor descriptor = builder.build();
 328         return new Attributes(descriptor,
 329                               moduleTarget,
 330                               moduleHashes,
 331                               moduleResolution);
 332     }
 333 
 334     /**
 335      * Reads the Module attribute, returning the ModuleDescriptor.Builder to
 336      * build the corresponding ModuleDescriptor.
 337      */
 338     private Builder readModuleAttribute(DataInput in, ConstantPool cpool, int major)
 339         throws IOException
 340     {
 341         // module_name
 342         int module_name_index = in.readUnsignedShort();
 343         String mn = cpool.getModuleName(module_name_index);
 344 
 345         int module_flags = in.readUnsignedShort();
 346 
 347         Set&lt;ModuleDescriptor.Modifier&gt; modifiers = new HashSet&lt;&gt;();
 348         boolean open = ((module_flags &amp; ACC_OPEN) != 0);
 349         if (open)
 350             modifiers.add(ModuleDescriptor.Modifier.OPEN);
 351         if ((module_flags &amp; ACC_SYNTHETIC) != 0)
 352             modifiers.add(ModuleDescriptor.Modifier.SYNTHETIC);
 353         if ((module_flags &amp; ACC_MANDATED) != 0)
 354             modifiers.add(ModuleDescriptor.Modifier.MANDATED);
 355 
 356         Builder builder = JLMA.newModuleBuilder(mn, false, modifiers);
 357 
 358         int module_version_index = in.readUnsignedShort();
 359         if (module_version_index != 0) {
 360             String vs = cpool.getUtf8(module_version_index);
 361             builder.version(vs);
 362         }
 363 
 364         int requires_count = in.readUnsignedShort();
 365         boolean requiresJavaBase = false;
 366         for (int i=0; i&lt;requires_count; i++) {
 367             int requires_index = in.readUnsignedShort();
 368             String dn = cpool.getModuleName(requires_index);
 369 
 370             int requires_flags = in.readUnsignedShort();
 371             Set&lt;Requires.Modifier&gt; mods;
 372             if (requires_flags == 0) {
 373                 mods = Set.of();
 374             } else {
 375                 mods = new HashSet&lt;&gt;();
 376                 if ((requires_flags &amp; ACC_TRANSITIVE) != 0)
 377                     mods.add(Requires.Modifier.TRANSITIVE);
 378                 if ((requires_flags &amp; ACC_STATIC_PHASE) != 0)
 379                     mods.add(Requires.Modifier.STATIC);
 380                 if ((requires_flags &amp; ACC_SYNTHETIC) != 0)
 381                     mods.add(Requires.Modifier.SYNTHETIC);
 382                 if ((requires_flags &amp; ACC_MANDATED) != 0)
 383                     mods.add(Requires.Modifier.MANDATED);
 384             }
 385 
 386             int requires_version_index = in.readUnsignedShort();
 387             if (requires_version_index == 0) {
 388                 builder.requires(mods, dn);
 389             } else {
 390                 String vs = cpool.getUtf8(requires_version_index);
 391                 JLMA.requires(builder, mods, dn, vs);
 392             }
 393 
 394             if (dn.equals(&quot;java.base&quot;)) {
 395                 if (major &gt;= 54
 396                     &amp;&amp; (mods.contains(Requires.Modifier.TRANSITIVE)
 397                         || mods.contains(Requires.Modifier.STATIC))) {
 398                     String flagName;
 399                     if (mods.contains(Requires.Modifier.TRANSITIVE)) {
 400                         flagName = &quot;ACC_TRANSITIVE&quot;;
 401                     } else {
 402                         flagName = &quot;ACC_STATIC_PHASE&quot;;
 403                     }
 404                     throw invalidModuleDescriptor(&quot;The requires entry for java.base&quot;
 405                                                   + &quot; has &quot; + flagName + &quot; set&quot;);
 406                 }
 407                 requiresJavaBase = true;
 408             }
 409         }
 410         if (mn.equals(&quot;java.base&quot;)) {
 411             if (requires_count &gt; 0) {
 412                 throw invalidModuleDescriptor(&quot;The requires table for java.base&quot;
 413                                               + &quot; must be 0 length&quot;);
 414             }
 415         } else if (!requiresJavaBase) {
 416             throw invalidModuleDescriptor(&quot;The requires table must have&quot;
 417                                           + &quot; an entry for java.base&quot;);
 418         }
 419 
 420         int exports_count = in.readUnsignedShort();
 421         if (exports_count &gt; 0) {
 422             for (int i=0; i&lt;exports_count; i++) {
 423                 int exports_index = in.readUnsignedShort();
 424                 String pkg = cpool.getPackageName(exports_index);
 425 
 426                 Set&lt;Exports.Modifier&gt; mods;
 427                 int exports_flags = in.readUnsignedShort();
 428                 if (exports_flags == 0) {
 429                     mods = Set.of();
 430                 } else {
 431                     mods = new HashSet&lt;&gt;();
 432                     if ((exports_flags &amp; ACC_SYNTHETIC) != 0)
 433                         mods.add(Exports.Modifier.SYNTHETIC);
 434                     if ((exports_flags &amp; ACC_MANDATED) != 0)
 435                         mods.add(Exports.Modifier.MANDATED);
 436                 }
 437 
 438                 int exports_to_count = in.readUnsignedShort();
 439                 if (exports_to_count &gt; 0) {
 440                     Set&lt;String&gt; targets = new HashSet&lt;&gt;(exports_to_count);
 441                     for (int j=0; j&lt;exports_to_count; j++) {
 442                         int exports_to_index = in.readUnsignedShort();
 443                         String target = cpool.getModuleName(exports_to_index);
 444                         if (!targets.add(target)) {
 445                             throw invalidModuleDescriptor(pkg + &quot; exported to &quot;
 446                                                           + target + &quot; more than once&quot;);
 447                         }
 448                     }
 449                     builder.exports(mods, pkg, targets);
 450                 } else {
 451                     builder.exports(mods, pkg);
 452                 }
 453             }
 454         }
 455 
 456         int opens_count = in.readUnsignedShort();
 457         if (opens_count &gt; 0) {
 458             if (open) {
 459                 throw invalidModuleDescriptor(&quot;The opens table for an open&quot;
 460                                               + &quot; module must be 0 length&quot;);
 461             }
 462             for (int i=0; i&lt;opens_count; i++) {
 463                 int opens_index = in.readUnsignedShort();
 464                 String pkg = cpool.getPackageName(opens_index);
 465 
 466                 Set&lt;Opens.Modifier&gt; mods;
 467                 int opens_flags = in.readUnsignedShort();
 468                 if (opens_flags == 0) {
 469                     mods = Set.of();
 470                 } else {
 471                     mods = new HashSet&lt;&gt;();
 472                     if ((opens_flags &amp; ACC_SYNTHETIC) != 0)
 473                         mods.add(Opens.Modifier.SYNTHETIC);
 474                     if ((opens_flags &amp; ACC_MANDATED) != 0)
 475                         mods.add(Opens.Modifier.MANDATED);
 476                 }
 477 
 478                 int open_to_count = in.readUnsignedShort();
 479                 if (open_to_count &gt; 0) {
 480                     Set&lt;String&gt; targets = new HashSet&lt;&gt;(open_to_count);
 481                     for (int j=0; j&lt;open_to_count; j++) {
 482                         int opens_to_index = in.readUnsignedShort();
 483                         String target = cpool.getModuleName(opens_to_index);
 484                         if (!targets.add(target)) {
 485                             throw invalidModuleDescriptor(pkg + &quot; opened to &quot;
 486                                                           + target + &quot; more than once&quot;);
 487                         }
 488                     }
 489                     builder.opens(mods, pkg, targets);
 490                 } else {
 491                     builder.opens(mods, pkg);
 492                 }
 493             }
 494         }
 495 
 496         int uses_count = in.readUnsignedShort();
 497         if (uses_count &gt; 0) {
 498             for (int i=0; i&lt;uses_count; i++) {
 499                 int index = in.readUnsignedShort();
 500                 String sn = cpool.getClassName(index);
 501                 builder.uses(sn);
 502             }
 503         }
 504 
 505         int provides_count = in.readUnsignedShort();
 506         if (provides_count &gt; 0) {
 507             for (int i=0; i&lt;provides_count; i++) {
 508                 int index = in.readUnsignedShort();
 509                 String sn = cpool.getClassName(index);
 510                 int with_count = in.readUnsignedShort();
 511                 List&lt;String&gt; providers = new ArrayList&lt;&gt;(with_count);
 512                 for (int j=0; j&lt;with_count; j++) {
 513                     index = in.readUnsignedShort();
 514                     String pn = cpool.getClassName(index);
 515                     if (!providers.add(pn)) {
 516                         throw invalidModuleDescriptor(sn + &quot; provides &quot; + pn
 517                                                       + &quot; more than once&quot;);
 518                     }
 519                 }
 520                 builder.provides(sn, providers);
 521             }
 522         }
 523 
 524         return builder;
 525     }
 526 
 527     /**
 528      * Reads the ModulePackages attribute
 529      */
 530     private Set&lt;String&gt; readModulePackagesAttribute(DataInput in, ConstantPool cpool)
 531         throws IOException
 532     {
 533         int package_count = in.readUnsignedShort();
 534         Set&lt;String&gt; packages = new HashSet&lt;&gt;(package_count);
 535         for (int i=0; i&lt;package_count; i++) {
 536             int index = in.readUnsignedShort();
 537             String pn = cpool.getPackageName(index);
 538             boolean added = packages.add(pn);
 539             if (!added) {
 540                 throw invalidModuleDescriptor(&quot;Package &quot; + pn + &quot; in ModulePackages&quot;
 541                                               + &quot;attribute more than once&quot;);
 542             }
 543         }
 544         return packages;
 545     }
 546 
 547     /**
 548      * Reads the ModuleMainClass attribute
 549      */
 550     private String readModuleMainClassAttribute(DataInput in, ConstantPool cpool)
 551         throws IOException
 552     {
 553         int index = in.readUnsignedShort();
 554         return cpool.getClassName(index);
 555     }
 556 
 557     /**
 558      * Reads the ModuleTarget attribute
 559      */
 560     private ModuleTarget readModuleTargetAttribute(DataInput in, ConstantPool cpool)
 561         throws IOException
 562     {
 563         String targetPlatform = null;
 564 
 565         int index = in.readUnsignedShort();
 566         if (index != 0)
 567             targetPlatform = cpool.getUtf8(index);
 568 
 569         return new ModuleTarget(targetPlatform);
 570     }
 571 
 572     /**
 573      * Reads the ModuleHashes attribute
 574      */
 575     private ModuleHashes readModuleHashesAttribute(DataInput in, ConstantPool cpool)
 576         throws IOException
 577     {
 578         int algorithm_index = in.readUnsignedShort();
 579         String algorithm = cpool.getUtf8(algorithm_index);
 580 
 581         int hash_count = in.readUnsignedShort();
 582         Map&lt;String, byte[]&gt; map = new HashMap&lt;&gt;(hash_count);
 583         for (int i=0; i&lt;hash_count; i++) {
 584             int module_name_index = in.readUnsignedShort();
 585             String mn = cpool.getModuleName(module_name_index);
 586             int hash_length = in.readUnsignedShort();
 587             if (hash_length == 0) {
 588                 throw invalidModuleDescriptor(&quot;hash_length == 0&quot;);
 589             }
 590             byte[] hash = new byte[hash_length];
 591             in.readFully(hash);
 592             map.put(mn, hash);
 593         }
 594 
 595         return new ModuleHashes(algorithm, map);
 596     }
 597 
 598     /**
 599      * Reads the ModuleResolution attribute.
 600      */
 601     private ModuleResolution readModuleResolution(DataInput in,
 602                                                   ConstantPool cpool)
 603         throws IOException
 604     {
 605         int flags = in.readUnsignedShort();
 606 
 607         int reason = 0;
 608         if ((flags &amp; WARN_DEPRECATED) != 0)
 609             reason = WARN_DEPRECATED;
 610         if ((flags &amp; WARN_DEPRECATED_FOR_REMOVAL) != 0) {
 611             if (reason != 0)
 612                 throw invalidModuleDescriptor(&quot;Bad module resolution flags:&quot; + flags);
 613             reason = WARN_DEPRECATED_FOR_REMOVAL;
 614         }
 615         if ((flags &amp; WARN_INCUBATING) != 0) {
 616             if (reason != 0)
 617                 throw invalidModuleDescriptor(&quot;Bad module resolution flags:&quot; + flags);
 618         }
 619 
 620         return new ModuleResolution(flags);
 621     }
 622 
 623     /**
 624      * Returns true if the given attribute can be present at most once
 625      * in the class file. Returns false otherwise.
 626      */
 627     private static boolean isAttributeAtMostOnce(String name) {
 628 
 629         if (name.equals(MODULE) ||
 630                 name.equals(SOURCE_FILE) ||
 631                 name.equals(SDE) ||
 632                 name.equals(MODULE_PACKAGES) ||
 633                 name.equals(MODULE_MAIN_CLASS) ||
 634                 name.equals(MODULE_TARGET) ||
 635                 name.equals(MODULE_HASHES) ||
 636                 name.equals(MODULE_RESOLUTION))
 637             return true;
 638 
 639         return false;
 640     }
 641 
 642     /**
 643      * Return true if the given attribute name is the name of a pre-defined
 644      * attribute in JVMS 4.7 that is not allowed in a module-info class.
 645      */
 646     private static boolean isAttributeDisallowed(String name) {
 647         Set&lt;String&gt; notAllowed = predefinedNotAllowed;
 648         if (notAllowed == null) {
 649             notAllowed = Set.of(
 650                     &quot;ConstantValue&quot;,
 651                     &quot;Code&quot;,
 652                     &quot;Deprecated&quot;,
 653                     &quot;StackMapTable&quot;,
 654                     &quot;Exceptions&quot;,
 655                     &quot;EnclosingMethod&quot;,
 656                     &quot;Signature&quot;,
 657                     &quot;LineNumberTable&quot;,
 658                     &quot;LocalVariableTable&quot;,
 659                     &quot;LocalVariableTypeTable&quot;,
 660                     &quot;RuntimeVisibleParameterAnnotations&quot;,
 661                     &quot;RuntimeInvisibleParameterAnnotations&quot;,
 662                     &quot;RuntimeVisibleTypeAnnotations&quot;,
 663                     &quot;RuntimeInvisibleTypeAnnotations&quot;,
 664                     &quot;Synthetic&quot;,
 665                     &quot;AnnotationDefault&quot;,
 666                     &quot;BootstrapMethods&quot;,
 667                     &quot;MethodParameters&quot;);
 668             predefinedNotAllowed = notAllowed;
 669         }
 670         return notAllowed.contains(name);
 671     }
 672 
 673     // lazily created set the pre-defined attributes that are not allowed
 674     private static volatile Set&lt;String&gt; predefinedNotAllowed;
 675 
 676 
 677     /**
 678      * The constant pool in a class file.
 679      */
 680     private static class ConstantPool {
 681         static final int CONSTANT_Utf8 = 1;
 682         static final int CONSTANT_Integer = 3;
 683         static final int CONSTANT_Float = 4;
 684         static final int CONSTANT_Long = 5;
 685         static final int CONSTANT_Double = 6;
 686         static final int CONSTANT_Class = 7;
 687         static final int CONSTANT_String = 8;
 688         static final int CONSTANT_Fieldref = 9;
 689         static final int CONSTANT_Methodref = 10;
 690         static final int CONSTANT_InterfaceMethodref = 11;
 691         static final int CONSTANT_NameAndType = 12;
 692         static final int CONSTANT_MethodHandle = 15;
 693         static final int CONSTANT_MethodType = 16;
 694         static final int CONSTANT_InvokeDynamic = 18;
 695         static final int CONSTANT_Module = 19;
 696         static final int CONSTANT_Package = 20;
 697 
 698         private static class Entry {
 699             protected Entry(int tag) {
 700                 this.tag = tag;
 701             }
 702             final int tag;
 703         }
 704 
 705         private static class IndexEntry extends Entry {
 706             IndexEntry(int tag, int index) {
 707                 super(tag);
 708                 this.index = index;
 709             }
 710             final int index;
 711         }
 712 
 713         private static class Index2Entry extends Entry {
 714             Index2Entry(int tag, int index1, int index2) {
 715                 super(tag);
 716                 this.index1 = index1;
 717                 this.index2 = index2;
 718             }
 719             final int index1,  index2;
 720         }
 721 
 722         private static class ValueEntry extends Entry {
 723             ValueEntry(int tag, Object value) {
 724                 super(tag);
 725                 this.value = value;
 726             }
 727             final Object value;
 728         }
 729 
 730         final Entry[] pool;
 731 
 732         ConstantPool(DataInput in) throws IOException {
 733             int count = in.readUnsignedShort();
 734             pool = new Entry[count];
 735 
 736             for (int i = 1; i &lt; count; i++) {
 737                 int tag = in.readUnsignedByte();
 738                 switch (tag) {
 739 
 740                     case CONSTANT_Utf8:
 741                         String svalue = in.readUTF();
 742                         pool[i] = new ValueEntry(tag, svalue);
 743                         break;
 744 
 745                     case CONSTANT_Class:
 746                     case CONSTANT_Package:
 747                     case CONSTANT_Module:
 748                     case CONSTANT_String:
 749                         int index = in.readUnsignedShort();
 750                         pool[i] = new IndexEntry(tag, index);
 751                         break;
 752 
 753                     case CONSTANT_Double:
 754                         double dvalue = in.readDouble();
 755                         pool[i] = new ValueEntry(tag, dvalue);
 756                         i++;
 757                         break;
 758 
 759                     case CONSTANT_Fieldref:
 760                     case CONSTANT_InterfaceMethodref:
 761                     case CONSTANT_Methodref:
 762                     case CONSTANT_InvokeDynamic:
 763                     case CONSTANT_NameAndType:
 764                         int index1 = in.readUnsignedShort();
 765                         int index2 = in.readUnsignedShort();
 766                         pool[i] = new Index2Entry(tag, index1, index2);
 767                         break;
 768 
 769                     case CONSTANT_MethodHandle:
 770                         int refKind = in.readUnsignedByte();
 771                         index = in.readUnsignedShort();
 772                         pool[i] = new Index2Entry(tag, refKind, index);
 773                         break;
 774 
 775                     case CONSTANT_MethodType:
 776                         index = in.readUnsignedShort();
 777                         pool[i] = new IndexEntry(tag, index);
 778                         break;
 779 
 780                     case CONSTANT_Float:
 781                         float fvalue = in.readFloat();
 782                         pool[i] = new ValueEntry(tag, fvalue);
 783                         break;
 784 
 785                     case CONSTANT_Integer:
 786                         int ivalue = in.readInt();
 787                         pool[i] = new ValueEntry(tag, ivalue);
 788                         break;
 789 
 790                     case CONSTANT_Long:
 791                         long lvalue = in.readLong();
 792                         pool[i] = new ValueEntry(tag, lvalue);
 793                         i++;
 794                         break;
 795 
 796                     default:
 797                         throw invalidModuleDescriptor(&quot;Bad constant pool entry: &quot;
 798                                                       + i);
 799                 }
 800             }
 801         }
 802 
 803         String getClassName(int index) {
 804             checkIndex(index);
 805             Entry e = pool[index];
 806             if (e.tag != CONSTANT_Class) {
 807                 throw invalidModuleDescriptor(&quot;CONSTANT_Class expected at entry: &quot;
 808                                               + index);
 809             }
 810             String value = getUtf8(((IndexEntry) e).index);
 811             checkUnqualifiedName(&quot;CONSTANT_Class&quot;, index, value);
 812             return value.replace(&#39;/&#39;, &#39;.&#39;);  // internal form -&gt; binary name
 813         }
 814 
 815         String getPackageName(int index) {
 816             checkIndex(index);
 817             Entry e = pool[index];
 818             if (e.tag != CONSTANT_Package) {
 819                 throw invalidModuleDescriptor(&quot;CONSTANT_Package expected at entry: &quot;
 820                                               + index);
 821             }
 822             String value = getUtf8(((IndexEntry) e).index);
 823             checkUnqualifiedName(&quot;CONSTANT_Package&quot;, index, value);
 824             return value.replace(&#39;/&#39;, &#39;.&#39;);  // internal form -&gt; binary name
 825         }
 826 
 827         String getModuleName(int index) {
 828             checkIndex(index);
 829             Entry e = pool[index];
 830             if (e.tag != CONSTANT_Module) {
 831                 throw invalidModuleDescriptor(&quot;CONSTANT_Module expected at entry: &quot;
 832                                               + index);
 833             }
 834             String value = getUtf8(((IndexEntry) e).index);
 835             return decodeModuleName(index, value);
 836         }
 837 
 838         String getUtf8(int index) {
 839             checkIndex(index);
 840             Entry e = pool[index];
 841             if (e.tag != CONSTANT_Utf8) {
 842                 throw invalidModuleDescriptor(&quot;CONSTANT_Utf8 expected at entry: &quot;
 843                                               + index);
 844             }
 845             return (String) (((ValueEntry) e).value);
 846         }
 847 
 848         void checkIndex(int index) {
 849             if (index &lt; 1 || index &gt;= pool.length)
 850                 throw invalidModuleDescriptor(&quot;Index into constant pool out of range&quot;);
 851         }
 852 
 853         void checkUnqualifiedName(String what, int index, String value) {
 854             int len = value.length();
 855             if (len == 0) {
 856                 throw invalidModuleDescriptor(what + &quot; at entry &quot; + index
 857                                               + &quot; has zero length&quot;);
 858             }
 859             for (int i=0; i&lt;len; i++) {
 860                 char c = value.charAt(i);
 861                 if (c == &#39;.&#39; || c == &#39;;&#39; || c == &#39;[&#39;) {
 862                     throw invalidModuleDescriptor(what + &quot; at entry &quot; + index
 863                                                   + &quot; has illegal character: &#39;&quot;
 864                                                   + c + &quot;&#39;&quot;);
 865                 }
 866             }
 867         }
 868 
 869         /**
 870          * &quot;Decode&quot; a module name that has been read from the constant pool.
 871          */
 872         String decodeModuleName(int index, String value) {
 873             int len = value.length();
 874             if (len == 0) {
 875                 throw invalidModuleDescriptor(&quot;CONSTANT_Module at entry &quot;
 876                                               + index + &quot; is zero length&quot;);
 877             }
 878             int i = 0;
 879             while (i &lt; len) {
 880                 int cp = value.codePointAt(i);
 881                 if (cp == &#39;:&#39; || cp == &#39;@&#39; || cp &lt; 0x20) {
 882                     throw invalidModuleDescriptor(&quot;CONSTANT_Module at entry &quot;
 883                                                   + index + &quot; has illegal character: &quot;
 884                                                   + Character.getName(cp));
 885                 }
 886 
 887                 // blackslash is the escape character
 888                 if (cp == &#39;\\&#39;)
 889                     return decodeModuleName(index, i, value);
 890 
 891                 i += Character.charCount(cp);
 892             }
 893             return value;
 894         }
 895 
 896         /**
 897          * &quot;Decode&quot; a module name that has been read from the constant pool and
 898          * partly checked for illegal characters (up to position {@code i}).
 899          */
 900         String decodeModuleName(int index, int i, String value) {
 901             StringBuilder sb = new StringBuilder();
 902 
 903             // copy the code points that have been checked
 904             int j = 0;
 905             while (j &lt; i) {
 906                 int cp = value.codePointAt(j);
 907                 sb.appendCodePoint(cp);
 908                 j += Character.charCount(cp);
 909             }
 910 
 911             // decode from position {@code i} to end
 912             int len = value.length();
 913             while (i &lt; len) {
 914                 int cp = value.codePointAt(i);
 915                 if (cp == &#39;:&#39; || cp == &#39;@&#39; || cp &lt; 0x20) {
 916                     throw invalidModuleDescriptor(&quot;CONSTANT_Module at entry &quot;
 917                                                   + index + &quot; has illegal character: &quot;
 918                                                   + Character.getName(cp));
 919                 }
 920 
 921                 // blackslash is the escape character
 922                 if (cp == &#39;\\&#39;) {
 923                     j = i + Character.charCount(cp);
 924                     if (j &gt;= len) {
 925                         throw invalidModuleDescriptor(&quot;CONSTANT_Module at entry &quot;
 926                                                        + index + &quot; has illegal &quot;
 927                                                        + &quot;escape sequence&quot;);
 928                     }
 929                     int next = value.codePointAt(j);
 930                     if (next != &#39;\\&#39; &amp;&amp; next != &#39;:&#39; &amp;&amp; next != &#39;@&#39;) {
 931                         throw invalidModuleDescriptor(&quot;CONSTANT_Module at entry &quot;
 932                                                       + index + &quot; has illegal &quot;
 933                                                       + &quot;escape sequence&quot;);
 934                     }
 935                     sb.appendCodePoint(next);
 936                     i += Character.charCount(next);
 937                 } else {
 938                     sb.appendCodePoint(cp);
 939                 }
 940 
 941                 i += Character.charCount(cp);
 942             }
 943             return sb.toString();
 944         }
 945     }
 946 
 947     /**
 948      * A DataInput implementation that reads from a ByteBuffer.
 949      */
 950     private static class DataInputWrapper implements DataInput {
 951         private final ByteBuffer bb;
 952 
 953         DataInputWrapper(ByteBuffer bb) {
 954             this.bb = bb;
 955         }
 956 
 957         @Override
 958         public void readFully(byte b[]) throws IOException {
 959             readFully(b, 0, b.length);
 960         }
 961 
 962         @Override
 963         public void readFully(byte b[], int off, int len) throws IOException {
 964             try {
 965                 bb.get(b, off, len);
 966             } catch (BufferUnderflowException e) {
 967                 throw new EOFException(e.getMessage());
 968             }
 969         }
 970 
 971         @Override
 972         public int skipBytes(int n) {
 973             int skip = Math.min(n, bb.remaining());
 974             bb.position(bb.position() + skip);
 975             return skip;
 976         }
 977 
 978         @Override
 979         public boolean readBoolean() throws IOException {
 980             try {
 981                 int ch = bb.get();
 982                 return (ch != 0);
 983             } catch (BufferUnderflowException e) {
 984                 throw new EOFException(e.getMessage());
 985             }
 986         }
 987 
 988         @Override
 989         public byte readByte() throws IOException {
 990             try {
 991                 return bb.get();
 992             } catch (BufferUnderflowException e) {
 993                 throw new EOFException(e.getMessage());
 994             }
 995         }
 996 
 997         @Override
 998         public int readUnsignedByte() throws IOException {
 999             try {
1000                 return ((int) bb.get()) &amp; 0xff;
1001             } catch (BufferUnderflowException e) {
1002                 throw new EOFException(e.getMessage());
1003             }
1004         }
1005 
1006         @Override
1007         public short readShort() throws IOException {
1008             try {
1009                 return bb.getShort();
1010             } catch (BufferUnderflowException e) {
1011                 throw new EOFException(e.getMessage());
1012             }
1013         }
1014 
1015         @Override
1016         public int readUnsignedShort() throws IOException {
1017             try {
1018                 return ((int) bb.getShort()) &amp; 0xffff;
1019             } catch (BufferUnderflowException e) {
1020                 throw new EOFException(e.getMessage());
1021             }
1022         }
1023 
1024         @Override
1025         public char readChar() throws IOException {
1026             try {
1027                 return bb.getChar();
1028             } catch (BufferUnderflowException e) {
1029                 throw new EOFException(e.getMessage());
1030             }
1031         }
1032 
1033         @Override
1034         public int readInt() throws IOException {
1035             try {
1036                 return bb.getInt();
1037             } catch (BufferUnderflowException e) {
1038                 throw new EOFException(e.getMessage());
1039             }
1040         }
1041 
1042         @Override
1043         public long readLong() throws IOException {
1044             try {
1045                 return bb.getLong();
1046             } catch (BufferUnderflowException e) {
1047                 throw new EOFException(e.getMessage());
1048             }
1049         }
1050 
1051         @Override
1052         public float readFloat() throws IOException {
1053             try {
1054                 return bb.getFloat();
1055             } catch (BufferUnderflowException e) {
1056                 throw new EOFException(e.getMessage());
1057             }
1058         }
1059 
1060         @Override
1061         public double readDouble() throws IOException {
1062             try {
1063                 return bb.getDouble();
1064             } catch (BufferUnderflowException e) {
1065                 throw new EOFException(e.getMessage());
1066             }
1067         }
1068 
1069         @Override
1070         public String readLine() {
1071             throw new RuntimeException(&quot;not implemented&quot;);
1072         }
1073 
1074         @Override
1075         public String readUTF() throws IOException {
1076             // ### Need to measure the performance and feasibility of using
1077             // the UTF-8 decoder instead.
1078             return DataInputStream.readUTF(this);
1079         }
1080     }
1081 
1082     /**
1083      * Returns an InvalidModuleDescriptorException with the given detail
1084      * message
1085      */
1086     private static InvalidModuleDescriptorException
1087     invalidModuleDescriptor(String msg) {
1088         return new InvalidModuleDescriptorException(msg);
1089     }
1090 
1091     /**
1092      * Returns an InvalidModuleDescriptorException with a detail message to
1093      * indicate that the class file is truncated.
1094      */
1095     private static InvalidModuleDescriptorException truncatedModuleDescriptor() {
1096         return invalidModuleDescriptor(&quot;Truncated module-info.class&quot;);
1097     }
1098 
1099 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
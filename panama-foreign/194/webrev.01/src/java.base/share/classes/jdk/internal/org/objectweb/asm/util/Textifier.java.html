<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/Textifier.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * ASM: a very small and fast Java bytecode manipulation framework
  32  * Copyright (c) 2000-2011 INRIA, France Telecom
  33  * All rights reserved.
  34  *
  35  * Redistribution and use in source and binary forms, with or without
  36  * modification, are permitted provided that the following conditions
  37  * are met:
  38  * 1. Redistributions of source code must retain the above copyright
  39  *    notice, this list of conditions and the following disclaimer.
  40  * 2. Redistributions in binary form must reproduce the above copyright
  41  *    notice, this list of conditions and the following disclaimer in the
  42  *    documentation and/or other materials provided with the distribution.
  43  * 3. Neither the name of the copyright holders nor the names of its
  44  *    contributors may be used to endorse or promote products derived from
  45  *    this software without specific prior written permission.
  46  *
  47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  57  * THE POSSIBILITY OF SUCH DAMAGE.
  58  */
  59 package jdk.internal.org.objectweb.asm.util;
  60 
  61 import java.io.IOException;
  62 import java.io.PrintWriter;
  63 import java.util.Arrays;
  64 import java.util.Collections;
  65 import java.util.HashMap;
  66 import java.util.List;
  67 import java.util.Map;
  68 import jdk.internal.org.objectweb.asm.Attribute;
  69 import jdk.internal.org.objectweb.asm.Handle;
  70 import jdk.internal.org.objectweb.asm.Label;
  71 import jdk.internal.org.objectweb.asm.Opcodes;
  72 import jdk.internal.org.objectweb.asm.Type;
  73 import jdk.internal.org.objectweb.asm.TypePath;
  74 import jdk.internal.org.objectweb.asm.TypeReference;
  75 import jdk.internal.org.objectweb.asm.signature.SignatureReader;
  76 
  77 /**
  78  * A {@link Printer} that prints a disassembled view of the classes it visits.
  79  *
  80  * @author Eric Bruneton
  81  */
  82 public class Textifier extends Printer {
  83 
  84     /** The help message shown when command line arguments are incorrect. */
  85     private static final String USAGE =
  86             &quot;Prints a disassembled view of the given class.\n&quot;
  87                     + &quot;Usage: Textifier [-debug] &lt;fully qualified class name or class file name&gt;&quot;;
  88 
  89     /** The type of internal names. See {@link #appendDescriptor}. */
  90     public static final int INTERNAL_NAME = 0;
  91 
  92     /** The type of field descriptors. See {@link #appendDescriptor}. */
  93     public static final int FIELD_DESCRIPTOR = 1;
  94 
  95     /** The type of field signatures. See {@link #appendDescriptor}. */
  96     public static final int FIELD_SIGNATURE = 2;
  97 
  98     /** The type of method descriptors. See {@link #appendDescriptor}. */
  99     public static final int METHOD_DESCRIPTOR = 3;
 100 
 101     /** The type of method signatures. See {@link #appendDescriptor}. */
 102     public static final int METHOD_SIGNATURE = 4;
 103 
 104     /** The type of class signatures. See {@link #appendDescriptor}. */
 105     public static final int CLASS_SIGNATURE = 5;
 106 
 107     /** The type of method handle descriptors. See {@link #appendDescriptor}. */
 108     public static final int HANDLE_DESCRIPTOR = 9;
 109 
 110     private static final String CLASS_SUFFIX = &quot;.class&quot;;
 111     private static final String DEPRECATED = &quot;// DEPRECATED\n&quot;;
 112     private static final String RECORD = &quot;// RECORD\n&quot;;
 113     private static final String INVISIBLE = &quot; // invisible\n&quot;;
 114 
 115     private static final List&lt;String&gt; FRAME_TYPES =
 116             Collections.unmodifiableList(Arrays.asList(&quot;T&quot;, &quot;I&quot;, &quot;F&quot;, &quot;D&quot;, &quot;J&quot;, &quot;N&quot;, &quot;U&quot;));
 117 
 118     /** The indentation of class members at depth level 1 (e.g. fields, methods). */
 119     protected String tab = &quot;  &quot;;
 120 
 121     /** The indentation of class elements at depth level 2 (e.g. bytecode instructions in methods). */
 122     protected String tab2 = &quot;    &quot;;
 123 
 124     /** The indentation of class elements at depth level 3 (e.g. switch cases in methods). */
 125     protected String tab3 = &quot;      &quot;;
 126 
 127     /** The indentation of labels. */
 128     protected String ltab = &quot;   &quot;;
 129 
 130     /** The names of the labels. */
 131     protected Map&lt;Label, String&gt; labelNames;
 132 
 133     /** The access flags of the visited class. */
 134     private int access;
 135 
 136     /** The number of annotation values visited so far. */
 137     private int numAnnotationValues;
 138 
 139     /**
 140       * Constructs a new {@link Textifier}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;. Instead,
 141       * they must use the {@link #Textifier(int)} version.
 142       *
 143       * @throws IllegalStateException If a subclass calls this constructor.
 144       */
 145     public Textifier() {
 146         this(/* latest api = */ Opcodes.ASM8);
 147         if (getClass() != Textifier.class) {
 148             throw new IllegalStateException();
 149         }
 150     }
 151 
 152     /**
 153       * Constructs a new {@link Textifier}.
 154       *
 155       * @param api the ASM API version implemented by this visitor. Must be one of {@link
 156       *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link
 157       *     Opcodes#ASM8}.
 158       */
 159     protected Textifier(final int api) {
 160         super(api);
 161     }
 162 
 163     /**
 164       * Prints a disassembled view of the given class to the standard output.
 165       *
 166       * &lt;p&gt;Usage: Textifier [-debug] &amp;lt;binary class name or class file name &amp;gt;
 167       *
 168       * @param args the command line arguments.
 169       * @throws IOException if the class cannot be found, or if an IOException occurs.
 170       */
 171     public static void main(final String[] args) throws IOException {
 172         main(args, new PrintWriter(System.out, true), new PrintWriter(System.err, true));
 173     }
 174 
 175     /**
 176       * Prints a disassembled view of the given class to the given output.
 177       *
 178       * &lt;p&gt;Usage: Textifier [-debug] &amp;lt;binary class name or class file name &amp;gt;
 179       *
 180       * @param args the command line arguments.
 181       * @param output where to print the result.
 182       * @param logger where to log errors.
 183       * @throws IOException if the class cannot be found, or if an IOException occurs.
 184       */
 185     static void main(final String[] args, final PrintWriter output, final PrintWriter logger)
 186             throws IOException {
 187         main(args, USAGE, new Textifier(), output, logger);
 188     }
 189 
 190     // -----------------------------------------------------------------------------------------------
 191     // Classes
 192     // -----------------------------------------------------------------------------------------------
 193 
 194     @Override
 195     public void visit(
 196             final int version,
 197             final int access,
 198             final String name,
 199             final String signature,
 200             final String superName,
 201             final String[] interfaces) {
 202         if ((access &amp; Opcodes.ACC_MODULE) != 0) {
 203             // Modules are printed in visitModule.
 204             return;
 205         }
 206         this.access = access;
 207         int majorVersion = version &amp; 0xFFFF;
 208         int minorVersion = version &gt;&gt;&gt; 16;
 209         stringBuilder.setLength(0);
 210         stringBuilder
 211                 .append(&quot;// class version &quot;)
 212                 .append(majorVersion)
 213                 .append(&#39;.&#39;)
 214                 .append(minorVersion)
 215                 .append(&quot; (&quot;)
 216                 .append(version)
 217                 .append(&quot;)\n&quot;);
 218         if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {
 219             stringBuilder.append(DEPRECATED);
 220         }
 221         if ((access &amp; Opcodes.ACC_RECORD) != 0) {
 222             stringBuilder.append(RECORD);
 223         }
 224         appendRawAccess(access);
 225 
 226         appendDescriptor(CLASS_SIGNATURE, signature);
 227         if (signature != null) {
 228             appendJavaDeclaration(name, signature);
 229         }
 230 
 231         appendAccess(access &amp; ~(Opcodes.ACC_SUPER | Opcodes.ACC_MODULE));
 232         if ((access &amp; Opcodes.ACC_ANNOTATION) != 0) {
 233             stringBuilder.append(&quot;@interface &quot;);
 234         } else if ((access &amp; Opcodes.ACC_INTERFACE) != 0) {
 235             stringBuilder.append(&quot;interface &quot;);
 236         } else if ((access &amp; Opcodes.ACC_ENUM) == 0) {
 237             stringBuilder.append(&quot;class &quot;);
 238         }
 239         appendDescriptor(INTERNAL_NAME, name);
 240 
 241         if (superName != null &amp;&amp; !&quot;java/lang/Object&quot;.equals(superName)) {
 242             stringBuilder.append(&quot; extends &quot;);
 243             appendDescriptor(INTERNAL_NAME, superName);
 244         }
 245         if (interfaces != null &amp;&amp; interfaces.length &gt; 0) {
 246             stringBuilder.append(&quot; implements &quot;);
 247             for (int i = 0; i &lt; interfaces.length; ++i) {
 248                 appendDescriptor(INTERNAL_NAME, interfaces[i]);
 249                 if (i != interfaces.length - 1) {
 250                     stringBuilder.append(&#39; &#39;);
 251                 }
 252             }
 253         }
 254         stringBuilder.append(&quot; {\n\n&quot;);
 255 
 256         text.add(stringBuilder.toString());
 257     }
 258 
 259     @Override
 260     public void visitSource(final String file, final String debug) {
 261         stringBuilder.setLength(0);
 262         if (file != null) {
 263             stringBuilder.append(tab).append(&quot;// compiled from: &quot;).append(file).append(&#39;\n&#39;);
 264         }
 265         if (debug != null) {
 266             stringBuilder.append(tab).append(&quot;// debug info: &quot;).append(debug).append(&#39;\n&#39;);
 267         }
 268         if (stringBuilder.length() &gt; 0) {
 269             text.add(stringBuilder.toString());
 270         }
 271     }
 272 
 273     @Override
 274     public Printer visitModule(final String name, final int access, final String version) {
 275         stringBuilder.setLength(0);
 276         if ((access &amp; Opcodes.ACC_OPEN) != 0) {
 277             stringBuilder.append(&quot;open &quot;);
 278         }
 279         stringBuilder
 280                 .append(&quot;module &quot;)
 281                 .append(name)
 282                 .append(&quot; { &quot;)
 283                 .append(version == null ? &quot;&quot; : &quot;// &quot; + version)
 284                 .append(&quot;\n\n&quot;);
 285         text.add(stringBuilder.toString());
 286         return addNewTextifier(null);
 287     }
 288 
 289     @Override
 290     public void visitNestHost(final String nestHost) {
 291         stringBuilder.setLength(0);
 292         stringBuilder.append(tab).append(&quot;NESTHOST &quot;);
 293         appendDescriptor(INTERNAL_NAME, nestHost);
 294         stringBuilder.append(&#39;\n&#39;);
 295         text.add(stringBuilder.toString());
 296     }
 297 
 298     @Override
 299     public void visitOuterClass(final String owner, final String name, final String descriptor) {
 300         stringBuilder.setLength(0);
 301         stringBuilder.append(tab).append(&quot;OUTERCLASS &quot;);
 302         appendDescriptor(INTERNAL_NAME, owner);
 303         stringBuilder.append(&#39; &#39;);
 304         if (name != null) {
 305             stringBuilder.append(name).append(&#39; &#39;);
 306         }
 307         appendDescriptor(METHOD_DESCRIPTOR, descriptor);
 308         stringBuilder.append(&#39;\n&#39;);
 309         text.add(stringBuilder.toString());
 310     }
 311 
 312     @Override
 313     public Textifier visitClassAnnotation(final String descriptor, final boolean visible) {
 314         text.add(&quot;\n&quot;);
 315         return visitAnnotation(descriptor, visible);
 316     }
 317 
 318     @Override
 319     public Printer visitClassTypeAnnotation(
 320             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 321         text.add(&quot;\n&quot;);
 322         return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
 323     }
 324 
 325     @Override
 326     public void visitClassAttribute(final Attribute attribute) {
 327         text.add(&quot;\n&quot;);
 328         visitAttribute(attribute);
 329     }
 330 
 331     @Override
 332     public void visitNestMember(final String nestMember) {
 333         stringBuilder.setLength(0);
 334         stringBuilder.append(tab).append(&quot;NESTMEMBER &quot;);
 335         appendDescriptor(INTERNAL_NAME, nestMember);
 336         stringBuilder.append(&#39;\n&#39;);
 337         text.add(stringBuilder.toString());
 338     }
 339 
 340     /**
 341       * &lt;b&gt;Experimental, use at your own risk.&lt;/b&gt;.
 342       *
 343       * @param permittedSubclass the internal name of a permitted subclass.
 344       * @deprecated this API is experimental.
 345       */
 346     @Override
 347     @Deprecated
 348     public void visitPermittedSubclassExperimental(final String permittedSubclass) {
 349         stringBuilder.setLength(0);
 350         stringBuilder.append(tab).append(&quot;PERMITTEDSUBCLASS &quot;);
 351         appendDescriptor(INTERNAL_NAME, permittedSubclass);
 352         stringBuilder.append(&#39;\n&#39;);
 353         text.add(stringBuilder.toString());
 354     }
 355 
 356     @Override
 357     public void visitInnerClass(
 358             final String name, final String outerName, final String innerName, final int access) {
 359         stringBuilder.setLength(0);
 360         stringBuilder.append(tab);
 361         appendRawAccess(access &amp; ~Opcodes.ACC_SUPER);
 362         stringBuilder.append(tab);
 363         appendAccess(access);
 364         stringBuilder.append(&quot;INNERCLASS &quot;);
 365         appendDescriptor(INTERNAL_NAME, name);
 366         stringBuilder.append(&#39; &#39;);
 367         appendDescriptor(INTERNAL_NAME, outerName);
 368         stringBuilder.append(&#39; &#39;);
 369         appendDescriptor(INTERNAL_NAME, innerName);
 370         stringBuilder.append(&#39;\n&#39;);
 371         text.add(stringBuilder.toString());
 372     }
 373 
 374     @Override
 375     public Printer visitRecordComponent(
 376             final String name, final String descriptor, final String signature) {
 377         stringBuilder.setLength(0);
 378         stringBuilder.append(tab).append(&quot;RECORDCOMPONENT &quot;);
 379         if (signature != null) {
 380             stringBuilder.append(tab);
 381             appendDescriptor(FIELD_SIGNATURE, signature);
 382             stringBuilder.append(tab);
 383             appendJavaDeclaration(name, signature);
 384         }
 385 
 386         stringBuilder.append(tab);
 387 
 388         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
 389         stringBuilder.append(&#39; &#39;).append(name);
 390 
 391         stringBuilder.append(&#39;\n&#39;);
 392         text.add(stringBuilder.toString());
 393         return addNewTextifier(null);
 394     }
 395 
 396     @Override
 397     public Textifier visitField(
 398             final int access,
 399             final String name,
 400             final String descriptor,
 401             final String signature,
 402             final Object value) {
 403         stringBuilder.setLength(0);
 404         stringBuilder.append(&#39;\n&#39;);
 405         if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {
 406             stringBuilder.append(tab).append(DEPRECATED);
 407         }
 408         stringBuilder.append(tab);
 409         appendRawAccess(access);
 410         if (signature != null) {
 411             stringBuilder.append(tab);
 412             appendDescriptor(FIELD_SIGNATURE, signature);
 413             stringBuilder.append(tab);
 414             appendJavaDeclaration(name, signature);
 415         }
 416 
 417         stringBuilder.append(tab);
 418         appendAccess(access);
 419 
 420         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
 421         stringBuilder.append(&#39; &#39;).append(name);
 422         if (value != null) {
 423             stringBuilder.append(&quot; = &quot;);
 424             if (value instanceof String) {
 425                 stringBuilder.append(&#39;\&quot;&#39;).append(value).append(&#39;\&quot;&#39;);
 426             } else {
 427                 stringBuilder.append(value);
 428             }
 429         }
 430 
 431         stringBuilder.append(&#39;\n&#39;);
 432         text.add(stringBuilder.toString());
 433         return addNewTextifier(null);
 434     }
 435 
 436     @Override
 437     public Textifier visitMethod(
 438             final int access,
 439             final String name,
 440             final String descriptor,
 441             final String signature,
 442             final String[] exceptions) {
 443         stringBuilder.setLength(0);
 444         stringBuilder.append(&#39;\n&#39;);
 445         if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {
 446             stringBuilder.append(tab).append(DEPRECATED);
 447         }
 448         stringBuilder.append(tab);
 449         appendRawAccess(access);
 450 
 451         if (signature != null) {
 452             stringBuilder.append(tab);
 453             appendDescriptor(METHOD_SIGNATURE, signature);
 454             stringBuilder.append(tab);
 455             appendJavaDeclaration(name, signature);
 456         }
 457 
 458         stringBuilder.append(tab);
 459         appendAccess(access &amp; ~(Opcodes.ACC_VOLATILE | Opcodes.ACC_TRANSIENT));
 460         if ((access &amp; Opcodes.ACC_NATIVE) != 0) {
 461             stringBuilder.append(&quot;native &quot;);
 462         }
 463         if ((access &amp; Opcodes.ACC_VARARGS) != 0) {
 464             stringBuilder.append(&quot;varargs &quot;);
 465         }
 466         if ((access &amp; Opcodes.ACC_BRIDGE) != 0) {
 467             stringBuilder.append(&quot;bridge &quot;);
 468         }
 469         if ((this.access &amp; Opcodes.ACC_INTERFACE) != 0
 470                 &amp;&amp; (access &amp; (Opcodes.ACC_ABSTRACT | Opcodes.ACC_STATIC)) == 0) {
 471             stringBuilder.append(&quot;default &quot;);
 472         }
 473 
 474         stringBuilder.append(name);
 475         appendDescriptor(METHOD_DESCRIPTOR, descriptor);
 476         if (exceptions != null &amp;&amp; exceptions.length &gt; 0) {
 477             stringBuilder.append(&quot; throws &quot;);
 478             for (String exception : exceptions) {
 479                 appendDescriptor(INTERNAL_NAME, exception);
 480                 stringBuilder.append(&#39; &#39;);
 481             }
 482         }
 483 
 484         stringBuilder.append(&#39;\n&#39;);
 485         text.add(stringBuilder.toString());
 486         return addNewTextifier(null);
 487     }
 488 
 489     @Override
 490     public void visitClassEnd() {
 491         text.add(&quot;}\n&quot;);
 492     }
 493 
 494     // -----------------------------------------------------------------------------------------------
 495     // Modules
 496     // -----------------------------------------------------------------------------------------------
 497 
 498     @Override
 499     public void visitMainClass(final String mainClass) {
 500         stringBuilder.setLength(0);
 501         stringBuilder.append(&quot;  // main class &quot;).append(mainClass).append(&#39;\n&#39;);
 502         text.add(stringBuilder.toString());
 503     }
 504 
 505     @Override
 506     public void visitPackage(final String packaze) {
 507         stringBuilder.setLength(0);
 508         stringBuilder.append(&quot;  // package &quot;).append(packaze).append(&#39;\n&#39;);
 509         text.add(stringBuilder.toString());
 510     }
 511 
 512     @Override
 513     public void visitRequire(final String require, final int access, final String version) {
 514         stringBuilder.setLength(0);
 515         stringBuilder.append(tab).append(&quot;requires &quot;);
 516         if ((access &amp; Opcodes.ACC_TRANSITIVE) != 0) {
 517             stringBuilder.append(&quot;transitive &quot;);
 518         }
 519         if ((access &amp; Opcodes.ACC_STATIC_PHASE) != 0) {
 520             stringBuilder.append(&quot;static &quot;);
 521         }
 522         stringBuilder.append(require).append(&#39;;&#39;);
 523         appendRawAccess(access);
 524         if (version != null) {
 525             stringBuilder.append(&quot;  // version &quot;).append(version).append(&#39;\n&#39;);
 526         }
 527         text.add(stringBuilder.toString());
 528     }
 529 
 530     @Override
 531     public void visitExport(final String packaze, final int access, final String... modules) {
 532         visitExportOrOpen(&quot;exports &quot;, packaze, access, modules);
 533     }
 534 
 535     @Override
 536     public void visitOpen(final String packaze, final int access, final String... modules) {
 537         visitExportOrOpen(&quot;opens &quot;, packaze, access, modules);
 538     }
 539 
 540     private void visitExportOrOpen(
 541             final String method, final String packaze, final int access, final String... modules) {
 542         stringBuilder.setLength(0);
 543         stringBuilder.append(tab).append(method);
 544         stringBuilder.append(packaze);
 545         if (modules != null &amp;&amp; modules.length &gt; 0) {
 546             stringBuilder.append(&quot; to&quot;);
 547         } else {
 548             stringBuilder.append(&#39;;&#39;);
 549         }
 550         appendRawAccess(access);
 551         if (modules != null &amp;&amp; modules.length &gt; 0) {
 552             for (int i = 0; i &lt; modules.length; ++i) {
 553                 stringBuilder.append(tab2).append(modules[i]);
 554                 stringBuilder.append(i != modules.length - 1 ? &quot;,\n&quot; : &quot;;\n&quot;);
 555             }
 556         }
 557         text.add(stringBuilder.toString());
 558     }
 559 
 560     @Override
 561     public void visitUse(final String use) {
 562         stringBuilder.setLength(0);
 563         stringBuilder.append(tab).append(&quot;uses &quot;);
 564         appendDescriptor(INTERNAL_NAME, use);
 565         stringBuilder.append(&quot;;\n&quot;);
 566         text.add(stringBuilder.toString());
 567     }
 568 
 569     @Override
 570     public void visitProvide(final String provide, final String... providers) {
 571         stringBuilder.setLength(0);
 572         stringBuilder.append(tab).append(&quot;provides &quot;);
 573         appendDescriptor(INTERNAL_NAME, provide);
 574         stringBuilder.append(&quot; with\n&quot;);
 575         for (int i = 0; i &lt; providers.length; ++i) {
 576             stringBuilder.append(tab2);
 577             appendDescriptor(INTERNAL_NAME, providers[i]);
 578             stringBuilder.append(i != providers.length - 1 ? &quot;,\n&quot; : &quot;;\n&quot;);
 579         }
 580         text.add(stringBuilder.toString());
 581     }
 582 
 583     @Override
 584     public void visitModuleEnd() {
 585         // Nothing to do.
 586     }
 587 
 588     // -----------------------------------------------------------------------------------------------
 589     // Annotations
 590     // -----------------------------------------------------------------------------------------------
 591 
 592     // DontCheck(OverloadMethodsDeclarationOrder): overloads are semantically different.
 593     @Override
 594     public void visit(final String name, final Object value) {
 595         visitAnnotationValue(name);
 596         if (value instanceof String) {
 597             visitString((String) value);
 598         } else if (value instanceof Type) {
 599             visitType((Type) value);
 600         } else if (value instanceof Byte) {
 601             visitByte(((Byte) value).byteValue());
 602         } else if (value instanceof Boolean) {
 603             visitBoolean(((Boolean) value).booleanValue());
 604         } else if (value instanceof Short) {
 605             visitShort(((Short) value).shortValue());
 606         } else if (value instanceof Character) {
 607             visitChar(((Character) value).charValue());
 608         } else if (value instanceof Integer) {
 609             visitInt(((Integer) value).intValue());
 610         } else if (value instanceof Float) {
 611             visitFloat(((Float) value).floatValue());
 612         } else if (value instanceof Long) {
 613             visitLong(((Long) value).longValue());
 614         } else if (value instanceof Double) {
 615             visitDouble(((Double) value).doubleValue());
 616         } else if (value.getClass().isArray()) {
 617             stringBuilder.append(&#39;{&#39;);
 618             if (value instanceof byte[]) {
 619                 byte[] byteArray = (byte[]) value;
 620                 for (int i = 0; i &lt; byteArray.length; i++) {
 621                     maybeAppendComma(i);
 622                     visitByte(byteArray[i]);
 623                 }
 624             } else if (value instanceof boolean[]) {
 625                 boolean[] booleanArray = (boolean[]) value;
 626                 for (int i = 0; i &lt; booleanArray.length; i++) {
 627                     maybeAppendComma(i);
 628                     visitBoolean(booleanArray[i]);
 629                 }
 630             } else if (value instanceof short[]) {
 631                 short[] shortArray = (short[]) value;
 632                 for (int i = 0; i &lt; shortArray.length; i++) {
 633                     maybeAppendComma(i);
 634                     visitShort(shortArray[i]);
 635                 }
 636             } else if (value instanceof char[]) {
 637                 char[] charArray = (char[]) value;
 638                 for (int i = 0; i &lt; charArray.length; i++) {
 639                     maybeAppendComma(i);
 640                     visitChar(charArray[i]);
 641                 }
 642             } else if (value instanceof int[]) {
 643                 int[] intArray = (int[]) value;
 644                 for (int i = 0; i &lt; intArray.length; i++) {
 645                     maybeAppendComma(i);
 646                     visitInt(intArray[i]);
 647                 }
 648             } else if (value instanceof long[]) {
 649                 long[] longArray = (long[]) value;
 650                 for (int i = 0; i &lt; longArray.length; i++) {
 651                     maybeAppendComma(i);
 652                     visitLong(longArray[i]);
 653                 }
 654             } else if (value instanceof float[]) {
 655                 float[] floatArray = (float[]) value;
 656                 for (int i = 0; i &lt; floatArray.length; i++) {
 657                     maybeAppendComma(i);
 658                     visitFloat(floatArray[i]);
 659                 }
 660             } else if (value instanceof double[]) {
 661                 double[] doubleArray = (double[]) value;
 662                 for (int i = 0; i &lt; doubleArray.length; i++) {
 663                     maybeAppendComma(i);
 664                     visitDouble(doubleArray[i]);
 665                 }
 666             }
 667             stringBuilder.append(&#39;}&#39;);
 668         }
 669         text.add(stringBuilder.toString());
 670     }
 671 
 672     private void visitInt(final int value) {
 673         stringBuilder.append(value);
 674     }
 675 
 676     private void visitLong(final long value) {
 677         stringBuilder.append(value).append(&#39;L&#39;);
 678     }
 679 
 680     private void visitFloat(final float value) {
 681         stringBuilder.append(value).append(&#39;F&#39;);
 682     }
 683 
 684     private void visitDouble(final double value) {
 685         stringBuilder.append(value).append(&#39;D&#39;);
 686     }
 687 
 688     private void visitChar(final char value) {
 689         stringBuilder.append(&quot;(char)&quot;).append((int) value);
 690     }
 691 
 692     private void visitShort(final short value) {
 693         stringBuilder.append(&quot;(short)&quot;).append(value);
 694     }
 695 
 696     private void visitByte(final byte value) {
 697         stringBuilder.append(&quot;(byte)&quot;).append(value);
 698     }
 699 
 700     private void visitBoolean(final boolean value) {
 701         stringBuilder.append(value);
 702     }
 703 
 704     private void visitString(final String value) {
 705         appendString(stringBuilder, value);
 706     }
 707 
 708     private void visitType(final Type value) {
 709         stringBuilder.append(value.getClassName()).append(CLASS_SUFFIX);
 710     }
 711 
 712     @Override
 713     public void visitEnum(final String name, final String descriptor, final String value) {
 714         visitAnnotationValue(name);
 715         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
 716         stringBuilder.append(&#39;.&#39;).append(value);
 717         text.add(stringBuilder.toString());
 718     }
 719 
 720     @Override
 721     public Textifier visitAnnotation(final String name, final String descriptor) {
 722         visitAnnotationValue(name);
 723         stringBuilder.append(&#39;@&#39;);
 724         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
 725         stringBuilder.append(&#39;(&#39;);
 726         text.add(stringBuilder.toString());
 727         return addNewTextifier(&quot;)&quot;);
 728     }
 729 
 730     @Override
 731     public Textifier visitArray(final String name) {
 732         visitAnnotationValue(name);
 733         stringBuilder.append(&#39;{&#39;);
 734         text.add(stringBuilder.toString());
 735         return addNewTextifier(&quot;}&quot;);
 736     }
 737 
 738     @Override
 739     public void visitAnnotationEnd() {
 740         // Nothing to do.
 741     }
 742 
 743     private void visitAnnotationValue(final String name) {
 744         stringBuilder.setLength(0);
 745         maybeAppendComma(numAnnotationValues++);
 746         if (name != null) {
 747             stringBuilder.append(name).append(&#39;=&#39;);
 748         }
 749     }
 750 
 751     // -----------------------------------------------------------------------------------------------
 752     // Record components
 753     // -----------------------------------------------------------------------------------------------
 754 
 755     @Override
 756     public Textifier visitRecordComponentAnnotation(final String descriptor, final boolean visible) {
 757         return visitAnnotation(descriptor, visible);
 758     }
 759 
 760     @Override
 761     public Printer visitRecordComponentTypeAnnotation(
 762             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 763         return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
 764     }
 765 
 766     @Override
 767     public void visitRecordComponentAttribute(final Attribute attribute) {
 768         visitAttribute(attribute);
 769     }
 770 
 771     @Override
 772     public void visitRecordComponentEnd() {
 773         // Nothing to do.
 774     }
 775 
 776     // -----------------------------------------------------------------------------------------------
 777     // Fields
 778     // -----------------------------------------------------------------------------------------------
 779 
 780     @Override
 781     public Textifier visitFieldAnnotation(final String descriptor, final boolean visible) {
 782         return visitAnnotation(descriptor, visible);
 783     }
 784 
 785     @Override
 786     public Printer visitFieldTypeAnnotation(
 787             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 788         return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
 789     }
 790 
 791     @Override
 792     public void visitFieldAttribute(final Attribute attribute) {
 793         visitAttribute(attribute);
 794     }
 795 
 796     @Override
 797     public void visitFieldEnd() {
 798         // Nothing to do.
 799     }
 800 
 801     // -----------------------------------------------------------------------------------------------
 802     // Methods
 803     // -----------------------------------------------------------------------------------------------
 804 
 805     @Override
 806     public void visitParameter(final String name, final int access) {
 807         stringBuilder.setLength(0);
 808         stringBuilder.append(tab2).append(&quot;// parameter &quot;);
 809         appendAccess(access);
 810         stringBuilder.append(&#39; &#39;).append((name == null) ? &quot;&lt;no name&gt;&quot; : name).append(&#39;\n&#39;);
 811         text.add(stringBuilder.toString());
 812     }
 813 
 814     @Override
 815     public Textifier visitAnnotationDefault() {
 816         text.add(tab2 + &quot;default=&quot;);
 817         return addNewTextifier(&quot;\n&quot;);
 818     }
 819 
 820     @Override
 821     public Textifier visitMethodAnnotation(final String descriptor, final boolean visible) {
 822         return visitAnnotation(descriptor, visible);
 823     }
 824 
 825     @Override
 826     public Printer visitMethodTypeAnnotation(
 827             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 828         return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
 829     }
 830 
 831     @Override
 832     public Textifier visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
 833         stringBuilder.setLength(0);
 834         stringBuilder.append(tab2).append(&quot;// annotable parameter count: &quot;);
 835         stringBuilder.append(parameterCount);
 836         stringBuilder.append(visible ? &quot; (visible)\n&quot; : &quot; (invisible)\n&quot;);
 837         text.add(stringBuilder.toString());
 838         return this;
 839     }
 840 
 841     @Override
 842     public Textifier visitParameterAnnotation(
 843             final int parameter, final String descriptor, final boolean visible) {
 844         stringBuilder.setLength(0);
 845         stringBuilder.append(tab2).append(&#39;@&#39;);
 846         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
 847         stringBuilder.append(&#39;(&#39;);
 848         text.add(stringBuilder.toString());
 849 
 850         stringBuilder.setLength(0);
 851         stringBuilder
 852                 .append(visible ? &quot;) // parameter &quot; : &quot;) // invisible, parameter &quot;)
 853                 .append(parameter)
 854                 .append(&#39;\n&#39;);
 855         return addNewTextifier(stringBuilder.toString());
 856     }
 857 
 858     @Override
 859     public void visitMethodAttribute(final Attribute attribute) {
 860         visitAttribute(attribute);
 861     }
 862 
 863     @Override
 864     public void visitCode() {
 865         // Nothing to do.
 866     }
 867 
 868     @Override
 869     public void visitFrame(
 870             final int type,
 871             final int numLocal,
 872             final Object[] local,
 873             final int numStack,
 874             final Object[] stack) {
 875         stringBuilder.setLength(0);
 876         stringBuilder.append(ltab);
 877         stringBuilder.append(&quot;FRAME &quot;);
 878         switch (type) {
 879             case Opcodes.F_NEW:
 880             case Opcodes.F_FULL:
 881                 stringBuilder.append(&quot;FULL [&quot;);
 882                 appendFrameTypes(numLocal, local);
 883                 stringBuilder.append(&quot;] [&quot;);
 884                 appendFrameTypes(numStack, stack);
 885                 stringBuilder.append(&#39;]&#39;);
 886                 break;
 887             case Opcodes.F_APPEND:
 888                 stringBuilder.append(&quot;APPEND [&quot;);
 889                 appendFrameTypes(numLocal, local);
 890                 stringBuilder.append(&#39;]&#39;);
 891                 break;
 892             case Opcodes.F_CHOP:
 893                 stringBuilder.append(&quot;CHOP &quot;).append(numLocal);
 894                 break;
 895             case Opcodes.F_SAME:
 896                 stringBuilder.append(&quot;SAME&quot;);
 897                 break;
 898             case Opcodes.F_SAME1:
 899                 stringBuilder.append(&quot;SAME1 &quot;);
 900                 appendFrameTypes(1, stack);
 901                 break;
 902             default:
 903                 throw new IllegalArgumentException();
 904         }
 905         stringBuilder.append(&#39;\n&#39;);
 906         text.add(stringBuilder.toString());
 907     }
 908 
 909     @Override
 910     public void visitInsn(final int opcode) {
 911         stringBuilder.setLength(0);
 912         stringBuilder.append(tab2).append(OPCODES[opcode]).append(&#39;\n&#39;);
 913         text.add(stringBuilder.toString());
 914     }
 915 
 916     @Override
 917     public void visitIntInsn(final int opcode, final int operand) {
 918         stringBuilder.setLength(0);
 919         stringBuilder
 920                 .append(tab2)
 921                 .append(OPCODES[opcode])
 922                 .append(&#39; &#39;)
 923                 .append(opcode == Opcodes.NEWARRAY ? TYPES[operand] : Integer.toString(operand))
 924                 .append(&#39;\n&#39;);
 925         text.add(stringBuilder.toString());
 926     }
 927 
 928     @Override
 929     public void visitVarInsn(final int opcode, final int var) {
 930         stringBuilder.setLength(0);
 931         stringBuilder.append(tab2).append(OPCODES[opcode]).append(&#39; &#39;).append(var).append(&#39;\n&#39;);
 932         text.add(stringBuilder.toString());
 933     }
 934 
 935     @Override
 936     public void visitTypeInsn(final int opcode, final String type) {
 937         stringBuilder.setLength(0);
 938         stringBuilder.append(tab2).append(OPCODES[opcode]).append(&#39; &#39;);
 939         appendDescriptor(INTERNAL_NAME, type);
 940         stringBuilder.append(&#39;\n&#39;);
 941         text.add(stringBuilder.toString());
 942     }
 943 
 944     @Override
 945     public void visitFieldInsn(
 946             final int opcode, final String owner, final String name, final String descriptor) {
 947         stringBuilder.setLength(0);
 948         stringBuilder.append(tab2).append(OPCODES[opcode]).append(&#39; &#39;);
 949         appendDescriptor(INTERNAL_NAME, owner);
 950         stringBuilder.append(&#39;.&#39;).append(name).append(&quot; : &quot;);
 951         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
 952         stringBuilder.append(&#39;\n&#39;);
 953         text.add(stringBuilder.toString());
 954     }
 955 
 956     @Override
 957     public void visitMethodInsn(
 958             final int opcode,
 959             final String owner,
 960             final String name,
 961             final String descriptor,
 962             final boolean isInterface) {
 963         stringBuilder.setLength(0);
 964         stringBuilder.append(tab2).append(OPCODES[opcode]).append(&#39; &#39;);
 965         appendDescriptor(INTERNAL_NAME, owner);
 966         stringBuilder.append(&#39;.&#39;).append(name).append(&#39; &#39;);
 967         appendDescriptor(METHOD_DESCRIPTOR, descriptor);
 968         if (isInterface) {
 969             stringBuilder.append(&quot; (itf)&quot;);
 970         }
 971         stringBuilder.append(&#39;\n&#39;);
 972         text.add(stringBuilder.toString());
 973     }
 974 
 975     @Override
 976     public void visitInvokeDynamicInsn(
 977             final String name,
 978             final String descriptor,
 979             final Handle bootstrapMethodHandle,
 980             final Object... bootstrapMethodArguments) {
 981         stringBuilder.setLength(0);
 982         stringBuilder.append(tab2).append(&quot;INVOKEDYNAMIC&quot;).append(&#39; &#39;);
 983         stringBuilder.append(name);
 984         appendDescriptor(METHOD_DESCRIPTOR, descriptor);
 985         stringBuilder.append(&quot; [&quot;);
 986         stringBuilder.append(&#39;\n&#39;);
 987         stringBuilder.append(tab3);
 988         appendHandle(bootstrapMethodHandle);
 989         stringBuilder.append(&#39;\n&#39;);
 990         stringBuilder.append(tab3).append(&quot;// arguments:&quot;);
 991         if (bootstrapMethodArguments.length == 0) {
 992             stringBuilder.append(&quot; none&quot;);
 993         } else {
 994             stringBuilder.append(&#39;\n&#39;);
 995             for (Object value : bootstrapMethodArguments) {
 996                 stringBuilder.append(tab3);
 997                 if (value instanceof String) {
 998                     Printer.appendString(stringBuilder, (String) value);
 999                 } else if (value instanceof Type) {
1000                     Type type = (Type) value;
1001                     if (type.getSort() == Type.METHOD) {
1002                         appendDescriptor(METHOD_DESCRIPTOR, type.getDescriptor());
1003                     } else {
1004                         visitType(type);
1005                     }
1006                 } else if (value instanceof Handle) {
1007                     appendHandle((Handle) value);
1008                 } else {
1009                     stringBuilder.append(value);
1010                 }
1011                 stringBuilder.append(&quot;, \n&quot;);
1012             }
1013             stringBuilder.setLength(stringBuilder.length() - 3);
1014         }
1015         stringBuilder.append(&#39;\n&#39;);
1016         stringBuilder.append(tab2).append(&quot;]\n&quot;);
1017         text.add(stringBuilder.toString());
1018     }
1019 
1020     @Override
1021     public void visitJumpInsn(final int opcode, final Label label) {
1022         stringBuilder.setLength(0);
1023         stringBuilder.append(tab2).append(OPCODES[opcode]).append(&#39; &#39;);
1024         appendLabel(label);
1025         stringBuilder.append(&#39;\n&#39;);
1026         text.add(stringBuilder.toString());
1027     }
1028 
1029     @Override
1030     public void visitLabel(final Label label) {
1031         stringBuilder.setLength(0);
1032         stringBuilder.append(ltab);
1033         appendLabel(label);
1034         stringBuilder.append(&#39;\n&#39;);
1035         text.add(stringBuilder.toString());
1036     }
1037 
1038     @Override
1039     public void visitLdcInsn(final Object value) {
1040         stringBuilder.setLength(0);
1041         stringBuilder.append(tab2).append(&quot;LDC &quot;);
1042         if (value instanceof String) {
1043             Printer.appendString(stringBuilder, (String) value);
1044         } else if (value instanceof Type) {
1045             stringBuilder.append(((Type) value).getDescriptor()).append(CLASS_SUFFIX);
1046         } else {
1047             stringBuilder.append(value);
1048         }
1049         stringBuilder.append(&#39;\n&#39;);
1050         text.add(stringBuilder.toString());
1051     }
1052 
1053     @Override
1054     public void visitIincInsn(final int var, final int increment) {
1055         stringBuilder.setLength(0);
1056         stringBuilder
1057                 .append(tab2)
1058                 .append(&quot;IINC &quot;)
1059                 .append(var)
1060                 .append(&#39; &#39;)
1061                 .append(increment)
1062                 .append(&#39;\n&#39;);
1063         text.add(stringBuilder.toString());
1064     }
1065 
1066     @Override
1067     public void visitTableSwitchInsn(
1068             final int min, final int max, final Label dflt, final Label... labels) {
1069         stringBuilder.setLength(0);
1070         stringBuilder.append(tab2).append(&quot;TABLESWITCH\n&quot;);
1071         for (int i = 0; i &lt; labels.length; ++i) {
1072             stringBuilder.append(tab3).append(min + i).append(&quot;: &quot;);
1073             appendLabel(labels[i]);
1074             stringBuilder.append(&#39;\n&#39;);
1075         }
1076         stringBuilder.append(tab3).append(&quot;default: &quot;);
1077         appendLabel(dflt);
1078         stringBuilder.append(&#39;\n&#39;);
1079         text.add(stringBuilder.toString());
1080     }
1081 
1082     @Override
1083     public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
1084         stringBuilder.setLength(0);
1085         stringBuilder.append(tab2).append(&quot;LOOKUPSWITCH\n&quot;);
1086         for (int i = 0; i &lt; labels.length; ++i) {
1087             stringBuilder.append(tab3).append(keys[i]).append(&quot;: &quot;);
1088             appendLabel(labels[i]);
1089             stringBuilder.append(&#39;\n&#39;);
1090         }
1091         stringBuilder.append(tab3).append(&quot;default: &quot;);
1092         appendLabel(dflt);
1093         stringBuilder.append(&#39;\n&#39;);
1094         text.add(stringBuilder.toString());
1095     }
1096 
1097     @Override
1098     public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
1099         stringBuilder.setLength(0);
1100         stringBuilder.append(tab2).append(&quot;MULTIANEWARRAY &quot;);
1101         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
1102         stringBuilder.append(&#39; &#39;).append(numDimensions).append(&#39;\n&#39;);
1103         text.add(stringBuilder.toString());
1104     }
1105 
1106     @Override
1107     public Printer visitInsnAnnotation(
1108             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
1109         return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
1110     }
1111 
1112     @Override
1113     public void visitTryCatchBlock(
1114             final Label start, final Label end, final Label handler, final String type) {
1115         stringBuilder.setLength(0);
1116         stringBuilder.append(tab2).append(&quot;TRYCATCHBLOCK &quot;);
1117         appendLabel(start);
1118         stringBuilder.append(&#39; &#39;);
1119         appendLabel(end);
1120         stringBuilder.append(&#39; &#39;);
1121         appendLabel(handler);
1122         stringBuilder.append(&#39; &#39;);
1123         appendDescriptor(INTERNAL_NAME, type);
1124         stringBuilder.append(&#39;\n&#39;);
1125         text.add(stringBuilder.toString());
1126     }
1127 
1128     @Override
1129     public Printer visitTryCatchAnnotation(
1130             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
1131         stringBuilder.setLength(0);
1132         stringBuilder.append(tab2).append(&quot;TRYCATCHBLOCK @&quot;);
1133         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
1134         stringBuilder.append(&#39;(&#39;);
1135         text.add(stringBuilder.toString());
1136 
1137         stringBuilder.setLength(0);
1138         stringBuilder.append(&quot;) : &quot;);
1139         appendTypeReference(typeRef);
1140         stringBuilder.append(&quot;, &quot;).append(typePath);
1141         stringBuilder.append(visible ? &quot;\n&quot; : INVISIBLE);
1142         return addNewTextifier(stringBuilder.toString());
1143     }
1144 
1145     @Override
1146     public void visitLocalVariable(
1147             final String name,
1148             final String descriptor,
1149             final String signature,
1150             final Label start,
1151             final Label end,
1152             final int index) {
1153         stringBuilder.setLength(0);
1154         stringBuilder.append(tab2).append(&quot;LOCALVARIABLE &quot;).append(name).append(&#39; &#39;);
1155         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
1156         stringBuilder.append(&#39; &#39;);
1157         appendLabel(start);
1158         stringBuilder.append(&#39; &#39;);
1159         appendLabel(end);
1160         stringBuilder.append(&#39; &#39;).append(index).append(&#39;\n&#39;);
1161 
1162         if (signature != null) {
1163             stringBuilder.append(tab2);
1164             appendDescriptor(FIELD_SIGNATURE, signature);
1165             stringBuilder.append(tab2);
1166             appendJavaDeclaration(name, signature);
1167         }
1168         text.add(stringBuilder.toString());
1169     }
1170 
1171     @Override
1172     public Printer visitLocalVariableAnnotation(
1173             final int typeRef,
1174             final TypePath typePath,
1175             final Label[] start,
1176             final Label[] end,
1177             final int[] index,
1178             final String descriptor,
1179             final boolean visible) {
1180         stringBuilder.setLength(0);
1181         stringBuilder.append(tab2).append(&quot;LOCALVARIABLE @&quot;);
1182         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
1183         stringBuilder.append(&#39;(&#39;);
1184         text.add(stringBuilder.toString());
1185 
1186         stringBuilder.setLength(0);
1187         stringBuilder.append(&quot;) : &quot;);
1188         appendTypeReference(typeRef);
1189         stringBuilder.append(&quot;, &quot;).append(typePath);
1190         for (int i = 0; i &lt; start.length; ++i) {
1191             stringBuilder.append(&quot; [ &quot;);
1192             appendLabel(start[i]);
1193             stringBuilder.append(&quot; - &quot;);
1194             appendLabel(end[i]);
1195             stringBuilder.append(&quot; - &quot;).append(index[i]).append(&quot; ]&quot;);
1196         }
1197         stringBuilder.append(visible ? &quot;\n&quot; : INVISIBLE);
1198         return addNewTextifier(stringBuilder.toString());
1199     }
1200 
1201     @Override
1202     public void visitLineNumber(final int line, final Label start) {
1203         stringBuilder.setLength(0);
1204         stringBuilder.append(tab2).append(&quot;LINENUMBER &quot;).append(line).append(&#39; &#39;);
1205         appendLabel(start);
1206         stringBuilder.append(&#39;\n&#39;);
1207         text.add(stringBuilder.toString());
1208     }
1209 
1210     @Override
1211     public void visitMaxs(final int maxStack, final int maxLocals) {
1212         stringBuilder.setLength(0);
1213         stringBuilder.append(tab2).append(&quot;MAXSTACK = &quot;).append(maxStack).append(&#39;\n&#39;);
1214         text.add(stringBuilder.toString());
1215 
1216         stringBuilder.setLength(0);
1217         stringBuilder.append(tab2).append(&quot;MAXLOCALS = &quot;).append(maxLocals).append(&#39;\n&#39;);
1218         text.add(stringBuilder.toString());
1219     }
1220 
1221     @Override
1222     public void visitMethodEnd() {
1223         // Nothing to do.
1224     }
1225 
1226     // -----------------------------------------------------------------------------------------------
1227     // Common methods
1228     // -----------------------------------------------------------------------------------------------
1229 
1230     /**
1231       * Prints a disassembled view of the given annotation.
1232       *
1233       * @param descriptor the class descriptor of the annotation class.
1234       * @param visible {@literal true} if the annotation is visible at runtime.
1235       * @return a visitor to visit the annotation values.
1236       */
1237     // DontCheck(OverloadMethodsDeclarationOrder): overloads are semantically different.
1238     public Textifier visitAnnotation(final String descriptor, final boolean visible) {
1239         stringBuilder.setLength(0);
1240         stringBuilder.append(tab).append(&#39;@&#39;);
1241         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
1242         stringBuilder.append(&#39;(&#39;);
1243         text.add(stringBuilder.toString());
1244         return addNewTextifier(visible ? &quot;)\n&quot; : &quot;) // invisible\n&quot;);
1245     }
1246 
1247     /**
1248       * Prints a disassembled view of the given type annotation.
1249       *
1250       * @param typeRef a reference to the annotated type. See {@link TypeReference}.
1251       * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
1252       *     static inner type within &#39;typeRef&#39;. May be {@literal null} if the annotation targets
1253       *     &#39;typeRef&#39; as a whole.
1254       * @param descriptor the class descriptor of the annotation class.
1255       * @param visible {@literal true} if the annotation is visible at runtime.
1256       * @return a visitor to visit the annotation values.
1257       */
1258     public Textifier visitTypeAnnotation(
1259             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
1260         stringBuilder.setLength(0);
1261         stringBuilder.append(tab).append(&#39;@&#39;);
1262         appendDescriptor(FIELD_DESCRIPTOR, descriptor);
1263         stringBuilder.append(&#39;(&#39;);
1264         text.add(stringBuilder.toString());
1265 
1266         stringBuilder.setLength(0);
1267         stringBuilder.append(&quot;) : &quot;);
1268         appendTypeReference(typeRef);
1269         stringBuilder.append(&quot;, &quot;).append(typePath);
1270         stringBuilder.append(visible ? &quot;\n&quot; : INVISIBLE);
1271         return addNewTextifier(stringBuilder.toString());
1272     }
1273 
1274     /**
1275       * Prints a disassembled view of the given attribute.
1276       *
1277       * @param attribute an attribute.
1278       */
1279     public void visitAttribute(final Attribute attribute) {
1280         stringBuilder.setLength(0);
1281         stringBuilder.append(tab).append(&quot;ATTRIBUTE &quot;);
1282         appendDescriptor(-1, attribute.type);
1283 
1284         if (attribute instanceof TextifierSupport) {
1285             if (labelNames == null) {
1286                 labelNames = new HashMap&lt;&gt;();
1287             }
1288             ((TextifierSupport) attribute).textify(stringBuilder, labelNames);
1289         } else {
1290             stringBuilder.append(&quot; : unknown\n&quot;);
1291         }
1292 
1293         text.add(stringBuilder.toString());
1294     }
1295 
1296     // -----------------------------------------------------------------------------------------------
1297     // Utility methods
1298     // -----------------------------------------------------------------------------------------------
1299 
1300     /**
1301       * Appends a string representation of the given access flags to {@link #stringBuilder}.
1302       *
1303       * @param accessFlags some access flags.
1304       */
1305     private void appendAccess(final int accessFlags) {
1306         if ((accessFlags &amp; Opcodes.ACC_PUBLIC) != 0) {
1307             stringBuilder.append(&quot;public &quot;);
1308         }
1309         if ((accessFlags &amp; Opcodes.ACC_PRIVATE) != 0) {
1310             stringBuilder.append(&quot;private &quot;);
1311         }
1312         if ((accessFlags &amp; Opcodes.ACC_PROTECTED) != 0) {
1313             stringBuilder.append(&quot;protected &quot;);
1314         }
1315         if ((accessFlags &amp; Opcodes.ACC_FINAL) != 0) {
1316             stringBuilder.append(&quot;final &quot;);
1317         }
1318         if ((accessFlags &amp; Opcodes.ACC_STATIC) != 0) {
1319             stringBuilder.append(&quot;static &quot;);
1320         }
1321         if ((accessFlags &amp; Opcodes.ACC_SYNCHRONIZED) != 0) {
1322             stringBuilder.append(&quot;synchronized &quot;);
1323         }
1324         if ((accessFlags &amp; Opcodes.ACC_VOLATILE) != 0) {
1325             stringBuilder.append(&quot;volatile &quot;);
1326         }
1327         if ((accessFlags &amp; Opcodes.ACC_TRANSIENT) != 0) {
1328             stringBuilder.append(&quot;transient &quot;);
1329         }
1330         if ((accessFlags &amp; Opcodes.ACC_ABSTRACT) != 0) {
1331             stringBuilder.append(&quot;abstract &quot;);
1332         }
1333         if ((accessFlags &amp; Opcodes.ACC_STRICT) != 0) {
1334             stringBuilder.append(&quot;strictfp &quot;);
1335         }
1336         if ((accessFlags &amp; Opcodes.ACC_SYNTHETIC) != 0) {
1337             stringBuilder.append(&quot;synthetic &quot;);
1338         }
1339         if ((accessFlags &amp; Opcodes.ACC_MANDATED) != 0) {
1340             stringBuilder.append(&quot;mandated &quot;);
1341         }
1342         if ((accessFlags &amp; Opcodes.ACC_ENUM) != 0) {
1343             stringBuilder.append(&quot;enum &quot;);
1344         }
1345     }
1346 
1347     /**
1348       * Appends the hexadecimal value of the given access flags to {@link #stringBuilder}.
1349       *
1350       * @param accessFlags some access flags.
1351       */
1352     private void appendRawAccess(final int accessFlags) {
1353         stringBuilder
1354                 .append(&quot;// access flags 0x&quot;)
1355                 .append(Integer.toHexString(accessFlags).toUpperCase())
1356                 .append(&#39;\n&#39;);
1357     }
1358 
1359     /**
1360       * Appends an internal name, a type descriptor or a type signature to {@link #stringBuilder}.
1361       *
1362       * @param type the type of &#39;value&#39;. Must be one of {@link #INTERNAL_NAME}, {@link
1363       *     #FIELD_DESCRIPTOR}, {@link #FIELD_SIGNATURE}, {@link #METHOD_DESCRIPTOR}, {@link
1364       *     #METHOD_SIGNATURE}, {@link #CLASS_SIGNATURE} or {@link #HANDLE_DESCRIPTOR}.
1365       * @param value an internal name, type descriptor or a type signature. May be {@literal null}.
1366       */
1367     protected void appendDescriptor(final int type, final String value) {
1368         if (type == CLASS_SIGNATURE || type == FIELD_SIGNATURE || type == METHOD_SIGNATURE) {
1369             if (value != null) {
1370                 stringBuilder.append(&quot;// signature &quot;).append(value).append(&#39;\n&#39;);
1371             }
1372         } else {
1373             stringBuilder.append(value);
1374         }
1375     }
1376 
1377     /**
1378       * Appends the Java generic type declaration corresponding to the given signature.
1379       *
1380       * @param name a class, field or method name.
1381       * @param signature a class, field or method signature.
1382       */
1383     private void appendJavaDeclaration(final String name, final String signature) {
1384         TraceSignatureVisitor traceSignatureVisitor = new TraceSignatureVisitor(access);
1385         new SignatureReader(signature).accept(traceSignatureVisitor);
1386         stringBuilder.append(&quot;// declaration: &quot;);
1387         if (traceSignatureVisitor.getReturnType() != null) {
1388             stringBuilder.append(traceSignatureVisitor.getReturnType());
1389             stringBuilder.append(&#39; &#39;);
1390         }
1391         stringBuilder.append(name);
1392         stringBuilder.append(traceSignatureVisitor.getDeclaration());
1393         if (traceSignatureVisitor.getExceptions() != null) {
1394             stringBuilder.append(&quot; throws &quot;).append(traceSignatureVisitor.getExceptions());
1395         }
1396         stringBuilder.append(&#39;\n&#39;);
1397     }
1398 
1399     /**
1400       * Appends the name of the given label to {@link #stringBuilder}. Constructs a new label name if
1401       * the given label does not yet have one.
1402       *
1403       * @param label a label.
1404       */
1405     protected void appendLabel(final Label label) {
1406         if (labelNames == null) {
1407             labelNames = new HashMap&lt;&gt;();
1408         }
1409         String name = labelNames.get(label);
1410         if (name == null) {
1411             name = &quot;L&quot; + labelNames.size();
1412             labelNames.put(label, name);
1413         }
1414         stringBuilder.append(name);
1415     }
1416 
1417     /**
1418       * Appends a string representation of the given handle to {@link #stringBuilder}.
1419       *
1420       * @param handle a handle.
1421       */
1422     protected void appendHandle(final Handle handle) {
1423         int tag = handle.getTag();
1424         stringBuilder.append(&quot;// handle kind 0x&quot;).append(Integer.toHexString(tag)).append(&quot; : &quot;);
1425         boolean isMethodHandle = false;
1426         switch (tag) {
1427             case Opcodes.H_GETFIELD:
1428                 stringBuilder.append(&quot;GETFIELD&quot;);
1429                 break;
1430             case Opcodes.H_GETSTATIC:
1431                 stringBuilder.append(&quot;GETSTATIC&quot;);
1432                 break;
1433             case Opcodes.H_PUTFIELD:
1434                 stringBuilder.append(&quot;PUTFIELD&quot;);
1435                 break;
1436             case Opcodes.H_PUTSTATIC:
1437                 stringBuilder.append(&quot;PUTSTATIC&quot;);
1438                 break;
1439             case Opcodes.H_INVOKEINTERFACE:
1440                 stringBuilder.append(&quot;INVOKEINTERFACE&quot;);
1441                 isMethodHandle = true;
1442                 break;
1443             case Opcodes.H_INVOKESPECIAL:
1444                 stringBuilder.append(&quot;INVOKESPECIAL&quot;);
1445                 isMethodHandle = true;
1446                 break;
1447             case Opcodes.H_INVOKESTATIC:
1448                 stringBuilder.append(&quot;INVOKESTATIC&quot;);
1449                 isMethodHandle = true;
1450                 break;
1451             case Opcodes.H_INVOKEVIRTUAL:
1452                 stringBuilder.append(&quot;INVOKEVIRTUAL&quot;);
1453                 isMethodHandle = true;
1454                 break;
1455             case Opcodes.H_NEWINVOKESPECIAL:
1456                 stringBuilder.append(&quot;NEWINVOKESPECIAL&quot;);
1457                 isMethodHandle = true;
1458                 break;
1459             default:
1460                 throw new IllegalArgumentException();
1461         }
1462         stringBuilder.append(&#39;\n&#39;);
1463         stringBuilder.append(tab3);
1464         appendDescriptor(INTERNAL_NAME, handle.getOwner());
1465         stringBuilder.append(&#39;.&#39;);
1466         stringBuilder.append(handle.getName());
1467         if (!isMethodHandle) {
1468             stringBuilder.append(&#39;(&#39;);
1469         }
1470         appendDescriptor(HANDLE_DESCRIPTOR, handle.getDesc());
1471         if (!isMethodHandle) {
1472             stringBuilder.append(&#39;)&#39;);
1473         }
1474         if (handle.isInterface()) {
1475             stringBuilder.append(&quot; itf&quot;);
1476         }
1477     }
1478 
1479     /**
1480       * Appends a comma to {@link #stringBuilder} if the given number is strictly positive.
1481       *
1482       * @param numValues a number of &#39;values visited so far&#39;, for instance the number of annotation
1483       *     values visited so far in an annotation visitor.
1484       */
1485     private void maybeAppendComma(final int numValues) {
1486         if (numValues &gt; 0) {
1487             stringBuilder.append(&quot;, &quot;);
1488         }
1489     }
1490 
1491     /**
1492       * Appends a string representation of the given type reference to {@link #stringBuilder}.
1493       *
1494       * @param typeRef a type reference. See {@link TypeReference}.
1495       */
1496     private void appendTypeReference(final int typeRef) {
1497         TypeReference typeReference = new TypeReference(typeRef);
1498         switch (typeReference.getSort()) {
1499             case TypeReference.CLASS_TYPE_PARAMETER:
1500                 stringBuilder.append(&quot;CLASS_TYPE_PARAMETER &quot;).append(typeReference.getTypeParameterIndex());
1501                 break;
1502             case TypeReference.METHOD_TYPE_PARAMETER:
1503                 stringBuilder
1504                         .append(&quot;METHOD_TYPE_PARAMETER &quot;)
1505                         .append(typeReference.getTypeParameterIndex());
1506                 break;
1507             case TypeReference.CLASS_EXTENDS:
1508                 stringBuilder.append(&quot;CLASS_EXTENDS &quot;).append(typeReference.getSuperTypeIndex());
1509                 break;
1510             case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
1511                 stringBuilder
1512                         .append(&quot;CLASS_TYPE_PARAMETER_BOUND &quot;)
1513                         .append(typeReference.getTypeParameterIndex())
1514                         .append(&quot;, &quot;)
1515                         .append(typeReference.getTypeParameterBoundIndex());
1516                 break;
1517             case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
1518                 stringBuilder
1519                         .append(&quot;METHOD_TYPE_PARAMETER_BOUND &quot;)
1520                         .append(typeReference.getTypeParameterIndex())
1521                         .append(&quot;, &quot;)
1522                         .append(typeReference.getTypeParameterBoundIndex());
1523                 break;
1524             case TypeReference.FIELD:
1525                 stringBuilder.append(&quot;FIELD&quot;);
1526                 break;
1527             case TypeReference.METHOD_RETURN:
1528                 stringBuilder.append(&quot;METHOD_RETURN&quot;);
1529                 break;
1530             case TypeReference.METHOD_RECEIVER:
1531                 stringBuilder.append(&quot;METHOD_RECEIVER&quot;);
1532                 break;
1533             case TypeReference.METHOD_FORMAL_PARAMETER:
1534                 stringBuilder
1535                         .append(&quot;METHOD_FORMAL_PARAMETER &quot;)
1536                         .append(typeReference.getFormalParameterIndex());
1537                 break;
1538             case TypeReference.THROWS:
1539                 stringBuilder.append(&quot;THROWS &quot;).append(typeReference.getExceptionIndex());
1540                 break;
1541             case TypeReference.LOCAL_VARIABLE:
1542                 stringBuilder.append(&quot;LOCAL_VARIABLE&quot;);
1543                 break;
1544             case TypeReference.RESOURCE_VARIABLE:
1545                 stringBuilder.append(&quot;RESOURCE_VARIABLE&quot;);
1546                 break;
1547             case TypeReference.EXCEPTION_PARAMETER:
1548                 stringBuilder.append(&quot;EXCEPTION_PARAMETER &quot;).append(typeReference.getTryCatchBlockIndex());
1549                 break;
1550             case TypeReference.INSTANCEOF:
1551                 stringBuilder.append(&quot;INSTANCEOF&quot;);
1552                 break;
1553             case TypeReference.NEW:
1554                 stringBuilder.append(&quot;NEW&quot;);
1555                 break;
1556             case TypeReference.CONSTRUCTOR_REFERENCE:
1557                 stringBuilder.append(&quot;CONSTRUCTOR_REFERENCE&quot;);
1558                 break;
1559             case TypeReference.METHOD_REFERENCE:
1560                 stringBuilder.append(&quot;METHOD_REFERENCE&quot;);
1561                 break;
1562             case TypeReference.CAST:
1563                 stringBuilder.append(&quot;CAST &quot;).append(typeReference.getTypeArgumentIndex());
1564                 break;
1565             case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
1566                 stringBuilder
1567                         .append(&quot;CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT &quot;)
1568                         .append(typeReference.getTypeArgumentIndex());
1569                 break;
1570             case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
1571                 stringBuilder
1572                         .append(&quot;METHOD_INVOCATION_TYPE_ARGUMENT &quot;)
1573                         .append(typeReference.getTypeArgumentIndex());
1574                 break;
1575             case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
1576                 stringBuilder
1577                         .append(&quot;CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT &quot;)
1578                         .append(typeReference.getTypeArgumentIndex());
1579                 break;
1580             case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
1581                 stringBuilder
1582                         .append(&quot;METHOD_REFERENCE_TYPE_ARGUMENT &quot;)
1583                         .append(typeReference.getTypeArgumentIndex());
1584                 break;
1585             default:
1586                 throw new IllegalArgumentException();
1587         }
1588     }
1589 
1590     /**
1591       * Appends the given stack map frame types to {@link #stringBuilder}.
1592       *
1593       * @param numTypes the number of stack map frame types in &#39;frameTypes&#39;.
1594       * @param frameTypes an array of stack map frame types, in the format described in {@link
1595       *     jdk.internal.org.objectweb.asm.MethodVisitor#visitFrame}.
1596       */
1597     private void appendFrameTypes(final int numTypes, final Object[] frameTypes) {
1598         for (int i = 0; i &lt; numTypes; ++i) {
1599             if (i &gt; 0) {
1600                 stringBuilder.append(&#39; &#39;);
1601             }
1602             if (frameTypes[i] instanceof String) {
1603                 String descriptor = (String) frameTypes[i];
1604                 if (descriptor.charAt(0) == &#39;[&#39;) {
1605                     appendDescriptor(FIELD_DESCRIPTOR, descriptor);
1606                 } else {
1607                     appendDescriptor(INTERNAL_NAME, descriptor);
1608                 }
1609             } else if (frameTypes[i] instanceof Integer) {
1610                 stringBuilder.append(FRAME_TYPES.get(((Integer) frameTypes[i]).intValue()));
1611             } else {
1612                 appendLabel((Label) frameTypes[i]);
1613             }
1614         }
1615     }
1616 
1617     /**
1618       * Creates and adds to {@link #text} a new {@link Textifier}, followed by the given string.
1619       *
1620       * @param endText the text to add to {@link #text} after the textifier. May be {@literal null}.
1621       * @return the newly created {@link Textifier}.
1622       */
1623     private Textifier addNewTextifier(final String endText) {
1624         Textifier textifier = createTextifier();
1625         text.add(textifier.getText());
1626         if (endText != null) {
1627             text.add(endText);
1628         }
1629         return textifier;
1630     }
1631 
1632     /**
1633       * Creates a new {@link Textifier}.
1634       *
1635       * @return a new {@link Textifier}.
1636       */
1637     protected Textifier createTextifier() {
1638         return new Textifier(api);
1639     }
1640 }
    </pre>
  </body>
</html>
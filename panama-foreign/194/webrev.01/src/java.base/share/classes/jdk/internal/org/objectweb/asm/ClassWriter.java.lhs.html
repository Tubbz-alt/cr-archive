<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * ASM: a very small and fast Java bytecode manipulation framework
  32  * Copyright (c) 2000-2011 INRIA, France Telecom
  33  * All rights reserved.
  34  *
  35  * Redistribution and use in source and binary forms, with or without
  36  * modification, are permitted provided that the following conditions
  37  * are met:
  38  * 1. Redistributions of source code must retain the above copyright
  39  *    notice, this list of conditions and the following disclaimer.
  40  * 2. Redistributions in binary form must reproduce the above copyright
  41  *    notice, this list of conditions and the following disclaimer in the
  42  *    documentation and/or other materials provided with the distribution.
  43  * 3. Neither the name of the copyright holders nor the names of its
  44  *    contributors may be used to endorse or promote products derived from
  45  *    this software without specific prior written permission.
  46  *
  47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  57  * THE POSSIBILITY OF SUCH DAMAGE.
  58  */
  59 package jdk.internal.org.objectweb.asm;
  60 
  61 /**
  62  * A {@link ClassVisitor} that generates a corresponding ClassFile structure, as defined in the Java
  63  * Virtual Machine Specification (JVMS). It can be used alone, to generate a Java class &quot;from
  64  * scratch&quot;, or with one or more {@link ClassReader} and adapter {@link ClassVisitor} to generate a
  65  * modified class from one or more existing Java classes.
  66  *
  67  * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html&quot;&gt;JVMS 4&lt;/a&gt;
  68  * @author Eric Bruneton
  69  */
  70 public class ClassWriter extends ClassVisitor {
  71 
  72     /**
  73       * A flag to automatically compute the maximum stack size and the maximum number of local
  74       * variables of methods. If this flag is set, then the arguments of the {@link
  75       * MethodVisitor#visitMaxs} method of the {@link MethodVisitor} returned by the {@link
  76       * #visitMethod} method will be ignored, and computed automatically from the signature and the
  77       * bytecode of each method.
  78       *
  79       * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; for classes whose version is {@link Opcodes#V1_7} of more, this option requires
  80       * valid stack map frames. The maximum stack size is then computed from these frames, and from the
  81       * bytecode instructions in between. If stack map frames are not present or must be recomputed,
  82       * used {@link #COMPUTE_FRAMES} instead.
  83       *
  84       * @see #ClassWriter(int)
  85       */
  86     public static final int COMPUTE_MAXS = 1;
  87 
  88     /**
  89       * A flag to automatically compute the stack map frames of methods from scratch. If this flag is
  90       * set, then the calls to the {@link MethodVisitor#visitFrame} method are ignored, and the stack
  91       * map frames are recomputed from the methods bytecode. The arguments of the {@link
  92       * MethodVisitor#visitMaxs} method are also ignored and recomputed from the bytecode. In other
  93       * words, {@link #COMPUTE_FRAMES} implies {@link #COMPUTE_MAXS}.
  94       *
  95       * @see #ClassWriter(int)
  96       */
  97     public static final int COMPUTE_FRAMES = 2;
  98 
  99     // Note: fields are ordered as in the ClassFile structure, and those related to attributes are
 100     // ordered as in Section 4.7 of the JVMS.
 101 
 102     /**
 103       * The minor_version and major_version fields of the JVMS ClassFile structure. minor_version is
 104       * stored in the 16 most significant bits, and major_version in the 16 least significant bits.
 105       */
 106     private int version;
 107 
 108     /** The symbol table for this class (contains the constant_pool and the BootstrapMethods). */
 109     private final SymbolTable symbolTable;
 110 
 111     /**
 112       * The access_flags field of the JVMS ClassFile structure. This field can contain ASM specific
 113       * access flags, such as {@link Opcodes#ACC_DEPRECATED} or {}@link Opcodes#ACC_RECORD}, which are
 114       * removed when generating the ClassFile structure.
 115       */
 116     private int accessFlags;
 117 
 118     /** The this_class field of the JVMS ClassFile structure. */
 119     private int thisClass;
 120 
 121     /** The super_class field of the JVMS ClassFile structure. */
 122     private int superClass;
 123 
 124     /** The interface_count field of the JVMS ClassFile structure. */
 125     private int interfaceCount;
 126 
 127     /** The &#39;interfaces&#39; array of the JVMS ClassFile structure. */
 128     private int[] interfaces;
 129 
 130     /**
 131       * The fields of this class, stored in a linked list of {@link FieldWriter} linked via their
 132       * {@link FieldWriter#fv} field. This field stores the first element of this list.
 133       */
 134     private FieldWriter firstField;
 135 
 136     /**
 137       * The fields of this class, stored in a linked list of {@link FieldWriter} linked via their
 138       * {@link FieldWriter#fv} field. This field stores the last element of this list.
 139       */
 140     private FieldWriter lastField;
 141 
 142     /**
 143       * The methods of this class, stored in a linked list of {@link MethodWriter} linked via their
 144       * {@link MethodWriter#mv} field. This field stores the first element of this list.
 145       */
 146     private MethodWriter firstMethod;
 147 
 148     /**
 149       * The methods of this class, stored in a linked list of {@link MethodWriter} linked via their
 150       * {@link MethodWriter#mv} field. This field stores the last element of this list.
 151       */
 152     private MethodWriter lastMethod;
 153 
 154     /** The number_of_classes field of the InnerClasses attribute, or 0. */
 155     private int numberOfInnerClasses;
 156 
 157     /** The &#39;classes&#39; array of the InnerClasses attribute, or {@literal null}. */
 158     private ByteVector innerClasses;
 159 
 160     /** The class_index field of the EnclosingMethod attribute, or 0. */
 161     private int enclosingClassIndex;
 162 
 163     /** The method_index field of the EnclosingMethod attribute. */
 164     private int enclosingMethodIndex;
 165 
 166     /** The signature_index field of the Signature attribute, or 0. */
 167     private int signatureIndex;
 168 
 169     /** The source_file_index field of the SourceFile attribute, or 0. */
 170     private int sourceFileIndex;
 171 
 172     /** The debug_extension field of the SourceDebugExtension attribute, or {@literal null}. */
 173     private ByteVector debugExtension;
 174 
 175     /**
 176       * The last runtime visible annotation of this class. The previous ones can be accessed with the
 177       * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
 178       */
 179     private AnnotationWriter lastRuntimeVisibleAnnotation;
 180 
 181     /**
 182       * The last runtime invisible annotation of this class. The previous ones can be accessed with the
 183       * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
 184       */
 185     private AnnotationWriter lastRuntimeInvisibleAnnotation;
 186 
 187     /**
 188       * The last runtime visible type annotation of this class. The previous ones can be accessed with
 189       * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
 190       */
 191     private AnnotationWriter lastRuntimeVisibleTypeAnnotation;
 192 
 193     /**
 194       * The last runtime invisible type annotation of this class. The previous ones can be accessed
 195       * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
 196       */
 197     private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;
 198 
 199     /** The Module attribute of this class, or {@literal null}. */
 200     private ModuleWriter moduleWriter;
 201 
 202     /** The host_class_index field of the NestHost attribute, or 0. */
 203     private int nestHostClassIndex;
 204 
 205     /** The number_of_classes field of the NestMembers attribute, or 0. */
 206     private int numberOfNestMemberClasses;
 207 
 208     /** The &#39;classes&#39; array of the NestMembers attribute, or {@literal null}. */
 209     private ByteVector nestMemberClasses;
 210 
<a name="1" id="anc1"></a><span class="line-modified"> 211     /** The number_of_classes field of the PermittedSubtypes attribute, or 0. */</span>
<span class="line-modified"> 212     private int numberOfPermittedSubtypeClasses;</span>
 213 
<a name="2" id="anc2"></a><span class="line-modified"> 214     /** The &#39;classes&#39; array of the PermittedSubtypes attribute, or {@literal null}. */</span>
<span class="line-modified"> 215     private ByteVector permittedSubtypeClasses;</span>
 216 
 217     /**
 218       * The record components of this class, stored in a linked list of {@link RecordComponentWriter}
 219       * linked via their {@link RecordComponentWriter#delegate} field. This field stores the first
 220       * element of this list.
 221       */
 222     private RecordComponentWriter firstRecordComponent;
 223 
 224     /**
 225       * The record components of this class, stored in a linked list of {@link RecordComponentWriter}
 226       * linked via their {@link RecordComponentWriter#delegate} field. This field stores the last
 227       * element of this list.
 228       */
 229     private RecordComponentWriter lastRecordComponent;
 230 
 231     /**
 232       * The first non standard attribute of this class. The next ones can be accessed with the {@link
 233       * Attribute#nextAttribute} field. May be {@literal null}.
 234       *
 235       * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: this list stores the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit.
 236       * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link
 237       * #toByteArray} method writes the attributes in the order defined by this list, i.e. in the
 238       * reverse order specified by the user.
 239       */
 240     private Attribute firstAttribute;
 241 
 242     /**
 243       * Indicates what must be automatically computed in {@link MethodWriter}. Must be one of {@link
 244       * MethodWriter#COMPUTE_NOTHING}, {@link MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL}, {@link
 245       * MethodWriter#COMPUTE_INSERTED_FRAMES}, or {@link MethodWriter#COMPUTE_ALL_FRAMES}.
 246       */
 247     private int compute;
 248 
 249     // -----------------------------------------------------------------------------------------------
 250     // Constructor
 251     // -----------------------------------------------------------------------------------------------
 252 
 253     /**
 254       * Constructs a new {@link ClassWriter} object.
 255       *
 256       * @param flags option flags that can be used to modify the default behavior of this class. Must
 257       *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.
 258       */
 259     public ClassWriter(final int flags) {
 260         this(null, flags);
 261     }
 262 
 263     /**
 264       * Constructs a new {@link ClassWriter} object and enables optimizations for &quot;mostly add&quot; bytecode
 265       * transformations. These optimizations are the following:
 266       *
 267       * &lt;ul&gt;
 268       *   &lt;li&gt;The constant pool and bootstrap methods from the original class are copied as is in the
 269       *       new class, which saves time. New constant pool entries and new bootstrap methods will be
 270       *       added at the end if necessary, but unused constant pool entries or bootstrap methods
 271       *       &lt;i&gt;won&#39;t be removed&lt;/i&gt;.
 272       *   &lt;li&gt;Methods that are not transformed are copied as is in the new class, directly from the
 273       *       original class bytecode (i.e. without emitting visit events for all the method
 274       *       instructions), which saves a &lt;i&gt;lot&lt;/i&gt; of time. Untransformed methods are detected by
 275       *       the fact that the {@link ClassReader} receives {@link MethodVisitor} objects that come
 276       *       from a {@link ClassWriter} (and not from any other {@link ClassVisitor} instance).
 277       * &lt;/ul&gt;
 278       *
 279       * @param classReader the {@link ClassReader} used to read the original class. It will be used to
 280       *     copy the entire constant pool and bootstrap methods from the original class and also to
 281       *     copy other fragments of original bytecode where applicable.
 282       * @param flags option flags that can be used to modify the default behavior of this class.Must be
 283       *     zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}. &lt;i&gt;These option flags do
 284       *     not affect methods that are copied as is in the new class. This means that neither the
 285       *     maximum stack size nor the stack frames will be computed for these methods&lt;/i&gt;.
 286       */
 287     public ClassWriter(final ClassReader classReader, final int flags) {
 288         super(/* latest api = */ Opcodes.ASM8);
 289         symbolTable = classReader == null ? new SymbolTable(this) : new SymbolTable(this, classReader);
 290         if ((flags &amp; COMPUTE_FRAMES) != 0) {
 291             this.compute = MethodWriter.COMPUTE_ALL_FRAMES;
 292         } else if ((flags &amp; COMPUTE_MAXS) != 0) {
 293             this.compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL;
 294         } else {
 295             this.compute = MethodWriter.COMPUTE_NOTHING;
 296         }
 297     }
 298 
 299     // -----------------------------------------------------------------------------------------------
 300     // Implementation of the ClassVisitor abstract class
 301     // -----------------------------------------------------------------------------------------------
 302 
 303     @Override
 304     public final void visit(
 305             final int version,
 306             final int access,
 307             final String name,
 308             final String signature,
 309             final String superName,
 310             final String[] interfaces) {
 311         this.version = version;
 312         this.accessFlags = access;
 313         this.thisClass = symbolTable.setMajorVersionAndClassName(version &amp; 0xFFFF, name);
 314         if (signature != null) {
 315             this.signatureIndex = symbolTable.addConstantUtf8(signature);
 316         }
 317         this.superClass = superName == null ? 0 : symbolTable.addConstantClass(superName).index;
 318         if (interfaces != null &amp;&amp; interfaces.length &gt; 0) {
 319             interfaceCount = interfaces.length;
 320             this.interfaces = new int[interfaceCount];
 321             for (int i = 0; i &lt; interfaceCount; ++i) {
 322                 this.interfaces[i] = symbolTable.addConstantClass(interfaces[i]).index;
 323             }
 324         }
 325         if (compute == MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL &amp;&amp; (version &amp; 0xFFFF) &gt;= Opcodes.V1_7) {
 326             compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES;
 327         }
 328     }
 329 
 330     @Override
 331     public final void visitSource(final String file, final String debug) {
 332         if (file != null) {
 333             sourceFileIndex = symbolTable.addConstantUtf8(file);
 334         }
 335         if (debug != null) {
 336             debugExtension = new ByteVector().encodeUtf8(debug, 0, Integer.MAX_VALUE);
 337         }
 338     }
 339 
 340     @Override
 341     public final ModuleVisitor visitModule(
 342             final String name, final int access, final String version) {
 343         return moduleWriter =
 344                 new ModuleWriter(
 345                         symbolTable,
 346                         symbolTable.addConstantModule(name).index,
 347                         access,
 348                         version == null ? 0 : symbolTable.addConstantUtf8(version));
 349     }
 350 
 351     @Override
 352     public final void visitNestHost(final String nestHost) {
 353         nestHostClassIndex = symbolTable.addConstantClass(nestHost).index;
 354     }
 355 
 356     @Override
 357     public final void visitOuterClass(
 358             final String owner, final String name, final String descriptor) {
 359         enclosingClassIndex = symbolTable.addConstantClass(owner).index;
 360         if (name != null &amp;&amp; descriptor != null) {
 361             enclosingMethodIndex = symbolTable.addConstantNameAndType(name, descriptor);
 362         }
 363     }
 364 
 365     @Override
 366     public final AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
 367         if (visible) {
 368             return lastRuntimeVisibleAnnotation =
 369                     AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);
 370         } else {
 371             return lastRuntimeInvisibleAnnotation =
 372                     AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);
 373         }
 374     }
 375 
 376     @Override
 377     public final AnnotationVisitor visitTypeAnnotation(
 378             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 379         if (visible) {
 380             return lastRuntimeVisibleTypeAnnotation =
 381                     AnnotationWriter.create(
 382                             symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);
 383         } else {
 384             return lastRuntimeInvisibleTypeAnnotation =
 385                     AnnotationWriter.create(
 386                             symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);
 387         }
 388     }
 389 
 390     @Override
 391     public final void visitAttribute(final Attribute attribute) {
 392         // Store the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit by this method.
 393         attribute.nextAttribute = firstAttribute;
 394         firstAttribute = attribute;
 395     }
 396 
 397     @Override
 398     public final void visitNestMember(final String nestMember) {
 399         if (nestMemberClasses == null) {
 400             nestMemberClasses = new ByteVector();
 401         }
 402         ++numberOfNestMemberClasses;
 403         nestMemberClasses.putShort(symbolTable.addConstantClass(nestMember).index);
 404     }
 405 
 406     /**
 407       * &lt;b&gt;Experimental, use at your own risk.&lt;/b&gt;
 408       *
<a name="3" id="anc3"></a><span class="line-modified"> 409       * @param permittedSubtype the internal name of a permitted subtype.</span>
 410       * @deprecated this API is experimental.
 411       */
 412     @Override
 413     @Deprecated
<a name="4" id="anc4"></a><span class="line-modified"> 414     public final void visitPermittedSubtypeExperimental(final String permittedSubtype) {</span>
<span class="line-modified"> 415         if (permittedSubtypeClasses == null) {</span>
<span class="line-modified"> 416             permittedSubtypeClasses = new ByteVector();</span>
 417         }
<a name="5" id="anc5"></a><span class="line-modified"> 418         ++numberOfPermittedSubtypeClasses;</span>
<span class="line-modified"> 419         permittedSubtypeClasses.putShort(symbolTable.addConstantClass(permittedSubtype).index);</span>
 420     }
 421 
 422     @Override
 423     public final void visitInnerClass(
 424             final String name, final String outerName, final String innerName, final int access) {
 425         if (innerClasses == null) {
 426             innerClasses = new ByteVector();
 427         }
 428         // Section 4.7.6 of the JVMS states &quot;Every CONSTANT_Class_info entry in the constant_pool table
 429         // which represents a class or interface C that is not a package member must have exactly one
 430         // corresponding entry in the classes array&quot;. To avoid duplicates we keep track in the info
 431         // field of the Symbol of each CONSTANT_Class_info entry C whether an inner class entry has
 432         // already been added for C. If so, we store the index of this inner class entry (plus one) in
 433         // the info field. This trick allows duplicate detection in O(1) time.
 434         Symbol nameSymbol = symbolTable.addConstantClass(name);
 435         if (nameSymbol.info == 0) {
 436             ++numberOfInnerClasses;
 437             innerClasses.putShort(nameSymbol.index);
 438             innerClasses.putShort(outerName == null ? 0 : symbolTable.addConstantClass(outerName).index);
 439             innerClasses.putShort(innerName == null ? 0 : symbolTable.addConstantUtf8(innerName));
 440             innerClasses.putShort(access);
 441             nameSymbol.info = numberOfInnerClasses;
 442         }
 443         // Else, compare the inner classes entry nameSymbol.info - 1 with the arguments of this method
 444         // and throw an exception if there is a difference?
 445     }
 446 
 447     @Override
 448     public final RecordComponentVisitor visitRecordComponent(
 449             final String name, final String descriptor, final String signature) {
 450         RecordComponentWriter recordComponentWriter =
 451                 new RecordComponentWriter(symbolTable, name, descriptor, signature);
 452         if (firstRecordComponent == null) {
 453             firstRecordComponent = recordComponentWriter;
 454         } else {
 455             lastRecordComponent.delegate = recordComponentWriter;
 456         }
 457         return lastRecordComponent = recordComponentWriter;
 458     }
 459 
 460     @Override
 461     public final FieldVisitor visitField(
 462             final int access,
 463             final String name,
 464             final String descriptor,
 465             final String signature,
 466             final Object value) {
 467         FieldWriter fieldWriter =
 468                 new FieldWriter(symbolTable, access, name, descriptor, signature, value);
 469         if (firstField == null) {
 470             firstField = fieldWriter;
 471         } else {
 472             lastField.fv = fieldWriter;
 473         }
 474         return lastField = fieldWriter;
 475     }
 476 
 477     @Override
 478     public final MethodVisitor visitMethod(
 479             final int access,
 480             final String name,
 481             final String descriptor,
 482             final String signature,
 483             final String[] exceptions) {
 484         MethodWriter methodWriter =
 485                 new MethodWriter(symbolTable, access, name, descriptor, signature, exceptions, compute);
 486         if (firstMethod == null) {
 487             firstMethod = methodWriter;
 488         } else {
 489             lastMethod.mv = methodWriter;
 490         }
 491         return lastMethod = methodWriter;
 492     }
 493 
 494     @Override
 495     public final void visitEnd() {
 496         // Nothing to do.
 497     }
 498 
 499     // -----------------------------------------------------------------------------------------------
 500     // Other public methods
 501     // -----------------------------------------------------------------------------------------------
 502 
 503     /**
 504       * Returns the content of the class file that was built by this ClassWriter.
 505       *
 506       * @return the binary content of the JVMS ClassFile structure that was built by this ClassWriter.
 507       * @throws ClassTooLargeException if the constant pool of the class is too large.
 508       * @throws MethodTooLargeException if the Code attribute of a method is too large.
 509       */
 510     public byte[] toByteArray() {
 511         // First step: compute the size in bytes of the ClassFile structure.
 512         // The magic field uses 4 bytes, 10 mandatory fields (minor_version, major_version,
 513         // constant_pool_count, access_flags, this_class, super_class, interfaces_count, fields_count,
 514         // methods_count and attributes_count) use 2 bytes each, and each interface uses 2 bytes too.
 515         int size = 24 + 2 * interfaceCount;
 516         int fieldsCount = 0;
 517         FieldWriter fieldWriter = firstField;
 518         while (fieldWriter != null) {
 519             ++fieldsCount;
 520             size += fieldWriter.computeFieldInfoSize();
 521             fieldWriter = (FieldWriter) fieldWriter.fv;
 522         }
 523         int methodsCount = 0;
 524         MethodWriter methodWriter = firstMethod;
 525         while (methodWriter != null) {
 526             ++methodsCount;
 527             size += methodWriter.computeMethodInfoSize();
 528             methodWriter = (MethodWriter) methodWriter.mv;
 529         }
 530 
 531         // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
 532         int attributesCount = 0;
 533         if (innerClasses != null) {
 534             ++attributesCount;
 535             size += 8 + innerClasses.length;
 536             symbolTable.addConstantUtf8(Constants.INNER_CLASSES);
 537         }
 538         if (enclosingClassIndex != 0) {
 539             ++attributesCount;
 540             size += 10;
 541             symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD);
 542         }
 543         if ((accessFlags &amp; Opcodes.ACC_SYNTHETIC) != 0 &amp;&amp; (version &amp; 0xFFFF) &lt; Opcodes.V1_5) {
 544             ++attributesCount;
 545             size += 6;
 546             symbolTable.addConstantUtf8(Constants.SYNTHETIC);
 547         }
 548         if (signatureIndex != 0) {
 549             ++attributesCount;
 550             size += 8;
 551             symbolTable.addConstantUtf8(Constants.SIGNATURE);
 552         }
 553         if (sourceFileIndex != 0) {
 554             ++attributesCount;
 555             size += 8;
 556             symbolTable.addConstantUtf8(Constants.SOURCE_FILE);
 557         }
 558         if (debugExtension != null) {
 559             ++attributesCount;
 560             size += 6 + debugExtension.length;
 561             symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION);
 562         }
 563         if ((accessFlags &amp; Opcodes.ACC_DEPRECATED) != 0) {
 564             ++attributesCount;
 565             size += 6;
 566             symbolTable.addConstantUtf8(Constants.DEPRECATED);
 567         }
 568         if (lastRuntimeVisibleAnnotation != null) {
 569             ++attributesCount;
 570             size +=
 571                     lastRuntimeVisibleAnnotation.computeAnnotationsSize(
 572                             Constants.RUNTIME_VISIBLE_ANNOTATIONS);
 573         }
 574         if (lastRuntimeInvisibleAnnotation != null) {
 575             ++attributesCount;
 576             size +=
 577                     lastRuntimeInvisibleAnnotation.computeAnnotationsSize(
 578                             Constants.RUNTIME_INVISIBLE_ANNOTATIONS);
 579         }
 580         if (lastRuntimeVisibleTypeAnnotation != null) {
 581             ++attributesCount;
 582             size +=
 583                     lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(
 584                             Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);
 585         }
 586         if (lastRuntimeInvisibleTypeAnnotation != null) {
 587             ++attributesCount;
 588             size +=
 589                     lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(
 590                             Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
 591         }
 592         if (symbolTable.computeBootstrapMethodsSize() &gt; 0) {
 593             ++attributesCount;
 594             size += symbolTable.computeBootstrapMethodsSize();
 595         }
 596         if (moduleWriter != null) {
 597             attributesCount += moduleWriter.getAttributeCount();
 598             size += moduleWriter.computeAttributesSize();
 599         }
 600         if (nestHostClassIndex != 0) {
 601             ++attributesCount;
 602             size += 8;
 603             symbolTable.addConstantUtf8(Constants.NEST_HOST);
 604         }
 605         if (nestMemberClasses != null) {
 606             ++attributesCount;
 607             size += 8 + nestMemberClasses.length;
 608             symbolTable.addConstantUtf8(Constants.NEST_MEMBERS);
 609         }
<a name="6" id="anc6"></a><span class="line-modified"> 610         if (permittedSubtypeClasses != null) {</span>
 611             ++attributesCount;
<a name="7" id="anc7"></a><span class="line-modified"> 612             size += 8 + permittedSubtypeClasses.length;</span>
<span class="line-modified"> 613             symbolTable.addConstantUtf8(Constants.PERMITTED_SUBTYPES);</span>
 614         }
 615         int recordComponentCount = 0;
 616         int recordSize = 0;
 617         if ((accessFlags &amp; Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {
 618             RecordComponentWriter recordComponentWriter = firstRecordComponent;
 619             while (recordComponentWriter != null) {
 620                 ++recordComponentCount;
 621                 recordSize += recordComponentWriter.computeRecordComponentInfoSize();
 622                 recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;
 623             }
 624             ++attributesCount;
 625             size += 8 + recordSize;
 626             symbolTable.addConstantUtf8(Constants.RECORD);
 627         }
 628         if (firstAttribute != null) {
 629             attributesCount += firstAttribute.getAttributeCount();
 630             size += firstAttribute.computeAttributesSize(symbolTable);
 631         }
 632         // IMPORTANT: this must be the last part of the ClassFile size computation, because the previous
 633         // statements can add attribute names to the constant pool, thereby changing its size!
 634         size += symbolTable.getConstantPoolLength();
 635         int constantPoolCount = symbolTable.getConstantPoolCount();
 636         if (constantPoolCount &gt; 0xFFFF) {
 637             throw new ClassTooLargeException(symbolTable.getClassName(), constantPoolCount);
 638         }
 639 
 640         // Second step: allocate a ByteVector of the correct size (in order to avoid any array copy in
 641         // dynamic resizes) and fill it with the ClassFile content.
 642         ByteVector result = new ByteVector(size);
 643         result.putInt(0xCAFEBABE).putInt(version);
 644         symbolTable.putConstantPool(result);
 645         int mask = (version &amp; 0xFFFF) &lt; Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : 0;
 646         result.putShort(accessFlags &amp; ~mask).putShort(thisClass).putShort(superClass);
 647         result.putShort(interfaceCount);
 648         for (int i = 0; i &lt; interfaceCount; ++i) {
 649             result.putShort(interfaces[i]);
 650         }
 651         result.putShort(fieldsCount);
 652         fieldWriter = firstField;
 653         while (fieldWriter != null) {
 654             fieldWriter.putFieldInfo(result);
 655             fieldWriter = (FieldWriter) fieldWriter.fv;
 656         }
 657         result.putShort(methodsCount);
 658         boolean hasFrames = false;
 659         boolean hasAsmInstructions = false;
 660         methodWriter = firstMethod;
 661         while (methodWriter != null) {
 662             hasFrames |= methodWriter.hasFrames();
 663             hasAsmInstructions |= methodWriter.hasAsmInstructions();
 664             methodWriter.putMethodInfo(result);
 665             methodWriter = (MethodWriter) methodWriter.mv;
 666         }
 667         // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
 668         result.putShort(attributesCount);
 669         if (innerClasses != null) {
 670             result
 671                     .putShort(symbolTable.addConstantUtf8(Constants.INNER_CLASSES))
 672                     .putInt(innerClasses.length + 2)
 673                     .putShort(numberOfInnerClasses)
 674                     .putByteArray(innerClasses.data, 0, innerClasses.length);
 675         }
 676         if (enclosingClassIndex != 0) {
 677             result
 678                     .putShort(symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD))
 679                     .putInt(4)
 680                     .putShort(enclosingClassIndex)
 681                     .putShort(enclosingMethodIndex);
 682         }
 683         if ((accessFlags &amp; Opcodes.ACC_SYNTHETIC) != 0 &amp;&amp; (version &amp; 0xFFFF) &lt; Opcodes.V1_5) {
 684             result.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);
 685         }
 686         if (signatureIndex != 0) {
 687             result
 688                     .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE))
 689                     .putInt(2)
 690                     .putShort(signatureIndex);
 691         }
 692         if (sourceFileIndex != 0) {
 693             result
 694                     .putShort(symbolTable.addConstantUtf8(Constants.SOURCE_FILE))
 695                     .putInt(2)
 696                     .putShort(sourceFileIndex);
 697         }
 698         if (debugExtension != null) {
 699             int length = debugExtension.length;
 700             result
 701                     .putShort(symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION))
 702                     .putInt(length)
 703                     .putByteArray(debugExtension.data, 0, length);
 704         }
 705         if ((accessFlags &amp; Opcodes.ACC_DEPRECATED) != 0) {
 706             result.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);
 707         }
 708         AnnotationWriter.putAnnotations(
 709                 symbolTable,
 710                 lastRuntimeVisibleAnnotation,
 711                 lastRuntimeInvisibleAnnotation,
 712                 lastRuntimeVisibleTypeAnnotation,
 713                 lastRuntimeInvisibleTypeAnnotation,
 714                 result);
 715         symbolTable.putBootstrapMethods(result);
 716         if (moduleWriter != null) {
 717             moduleWriter.putAttributes(result);
 718         }
 719         if (nestHostClassIndex != 0) {
 720             result
 721                     .putShort(symbolTable.addConstantUtf8(Constants.NEST_HOST))
 722                     .putInt(2)
 723                     .putShort(nestHostClassIndex);
 724         }
 725         if (nestMemberClasses != null) {
 726             result
 727                     .putShort(symbolTable.addConstantUtf8(Constants.NEST_MEMBERS))
 728                     .putInt(nestMemberClasses.length + 2)
 729                     .putShort(numberOfNestMemberClasses)
 730                     .putByteArray(nestMemberClasses.data, 0, nestMemberClasses.length);
 731         }
<a name="8" id="anc8"></a><span class="line-modified"> 732         if (permittedSubtypeClasses != null) {</span>
 733             result
<a name="9" id="anc9"></a><span class="line-modified"> 734                     .putShort(symbolTable.addConstantUtf8(Constants.PERMITTED_SUBTYPES))</span>
<span class="line-modified"> 735                     .putInt(permittedSubtypeClasses.length + 2)</span>
<span class="line-modified"> 736                     .putShort(numberOfPermittedSubtypeClasses)</span>
<span class="line-modified"> 737                     .putByteArray(permittedSubtypeClasses.data, 0, permittedSubtypeClasses.length);</span>
 738         }
 739         if ((accessFlags &amp; Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {
 740             result
 741                     .putShort(symbolTable.addConstantUtf8(Constants.RECORD))
 742                     .putInt(recordSize + 2)
 743                     .putShort(recordComponentCount);
 744             RecordComponentWriter recordComponentWriter = firstRecordComponent;
 745             while (recordComponentWriter != null) {
 746                 recordComponentWriter.putRecordComponentInfo(result);
 747                 recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;
 748             }
 749         }
 750         if (firstAttribute != null) {
 751             firstAttribute.putAttributes(symbolTable, result);
 752         }
 753 
 754         // Third step: replace the ASM specific instructions, if any.
 755         if (hasAsmInstructions) {
 756             return replaceAsmInstructions(result.data, hasFrames);
 757         } else {
 758             return result.data;
 759         }
 760     }
 761 
 762     /**
 763       * Returns the equivalent of the given class file, with the ASM specific instructions replaced
 764       * with standard ones. This is done with a ClassReader -&amp;gt; ClassWriter round trip.
 765       *
 766       * @param classFile a class file containing ASM specific instructions, generated by this
 767       *     ClassWriter.
 768       * @param hasFrames whether there is at least one stack map frames in &#39;classFile&#39;.
 769       * @return an equivalent of &#39;classFile&#39;, with the ASM specific instructions replaced with standard
 770       *     ones.
 771       */
 772     private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) {
 773         final Attribute[] attributes = getAttributePrototypes();
 774         firstField = null;
 775         lastField = null;
 776         firstMethod = null;
 777         lastMethod = null;
 778         lastRuntimeVisibleAnnotation = null;
 779         lastRuntimeInvisibleAnnotation = null;
 780         lastRuntimeVisibleTypeAnnotation = null;
 781         lastRuntimeInvisibleTypeAnnotation = null;
 782         moduleWriter = null;
 783         nestHostClassIndex = 0;
 784         numberOfNestMemberClasses = 0;
 785         nestMemberClasses = null;
<a name="10" id="anc10"></a><span class="line-modified"> 786         numberOfPermittedSubtypeClasses = 0;</span>
<span class="line-modified"> 787         permittedSubtypeClasses = null;</span>
 788         firstRecordComponent = null;
 789         lastRecordComponent = null;
 790         firstAttribute = null;
 791         compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING;
 792         new ClassReader(classFile, 0, /* checkClassVersion = */ false)
 793                 .accept(
 794                         this,
 795                         attributes,
 796                         (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS);
 797         return toByteArray();
 798     }
 799 
 800     /**
 801       * Returns the prototypes of the attributes used by this class, its fields and its methods.
 802       *
 803       * @return the prototypes of the attributes used by this class, its fields and its methods.
 804       */
 805     private Attribute[] getAttributePrototypes() {
 806         Attribute.Set attributePrototypes = new Attribute.Set();
 807         attributePrototypes.addAttributes(firstAttribute);
 808         FieldWriter fieldWriter = firstField;
 809         while (fieldWriter != null) {
 810             fieldWriter.collectAttributePrototypes(attributePrototypes);
 811             fieldWriter = (FieldWriter) fieldWriter.fv;
 812         }
 813         MethodWriter methodWriter = firstMethod;
 814         while (methodWriter != null) {
 815             methodWriter.collectAttributePrototypes(attributePrototypes);
 816             methodWriter = (MethodWriter) methodWriter.mv;
 817         }
 818         RecordComponentWriter recordComponentWriter = firstRecordComponent;
 819         while (recordComponentWriter != null) {
 820             recordComponentWriter.collectAttributePrototypes(attributePrototypes);
 821             recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;
 822         }
 823         return attributePrototypes.toArray();
 824     }
 825 
 826     // -----------------------------------------------------------------------------------------------
 827     // Utility methods: constant pool management for Attribute sub classes
 828     // -----------------------------------------------------------------------------------------------
 829 
 830     /**
 831       * Adds a number or string constant to the constant pool of the class being build. Does nothing if
 832       * the constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link
 833       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
 834       *
 835       * @param value the value of the constant to be added to the constant pool. This parameter must be
 836       *     an {@link Integer}, a {@link Float}, a {@link Long}, a {@link Double} or a {@link String}.
 837       * @return the index of a new or already existing constant item with the given value.
 838       */
 839     public int newConst(final Object value) {
 840         return symbolTable.addConstant(value).index;
 841     }
 842 
 843     /**
 844       * Adds an UTF8 string to the constant pool of the class being build. Does nothing if the constant
 845       * pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute} sub
 846       * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
 847       *
 848       * @param value the String value.
 849       * @return the index of a new or already existing UTF8 item.
 850       */
 851     // DontCheck(AbbreviationAsWordInName): can&#39;t be renamed (for backward binary compatibility).
 852     public int newUTF8(final String value) {
 853         return symbolTable.addConstantUtf8(value);
 854     }
 855 
 856     /**
 857       * Adds a class reference to the constant pool of the class being build. Does nothing if the
 858       * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
 859       * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
 860       *
 861       * @param value the internal name of the class.
 862       * @return the index of a new or already existing class reference item.
 863       */
 864     public int newClass(final String value) {
 865         return symbolTable.addConstantClass(value).index;
 866     }
 867 
 868     /**
 869       * Adds a method type reference to the constant pool of the class being build. Does nothing if the
 870       * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
 871       * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
 872       *
 873       * @param methodDescriptor method descriptor of the method type.
 874       * @return the index of a new or already existing method type reference item.
 875       */
 876     public int newMethodType(final String methodDescriptor) {
 877         return symbolTable.addConstantMethodType(methodDescriptor).index;
 878     }
 879 
 880     /**
 881       * Adds a module reference to the constant pool of the class being build. Does nothing if the
 882       * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
 883       * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
 884       *
 885       * @param moduleName name of the module.
 886       * @return the index of a new or already existing module reference item.
 887       */
 888     public int newModule(final String moduleName) {
 889         return symbolTable.addConstantModule(moduleName).index;
 890     }
 891 
 892     /**
 893       * Adds a package reference to the constant pool of the class being build. Does nothing if the
 894       * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
 895       * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
 896       *
 897       * @param packageName name of the package in its internal form.
 898       * @return the index of a new or already existing module reference item.
 899       */
 900     public int newPackage(final String packageName) {
 901         return symbolTable.addConstantPackage(packageName).index;
 902     }
 903 
 904     /**
 905       * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool
 906       * already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute} sub classes,
 907       * and is normally not needed by class generators or adapters.&lt;/i&gt;
 908       *
 909       * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link
 910       *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link
 911       *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},
 912       *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
 913       * @param owner the internal name of the field or method owner class.
 914       * @param name the name of the field or method.
 915       * @param descriptor the descriptor of the field or method.
 916       * @return the index of a new or already existing method type reference item.
 917       * @deprecated this method is superseded by {@link #newHandle(int, String, String, String,
 918       *     boolean)}.
 919       */
 920     @Deprecated
 921     public int newHandle(
 922             final int tag, final String owner, final String name, final String descriptor) {
 923         return newHandle(tag, owner, name, descriptor, tag == Opcodes.H_INVOKEINTERFACE);
 924     }
 925 
 926     /**
 927       * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool
 928       * already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute} sub classes,
 929       * and is normally not needed by class generators or adapters.&lt;/i&gt;
 930       *
 931       * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link
 932       *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link
 933       *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},
 934       *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
 935       * @param owner the internal name of the field or method owner class.
 936       * @param name the name of the field or method.
 937       * @param descriptor the descriptor of the field or method.
 938       * @param isInterface true if the owner is an interface.
 939       * @return the index of a new or already existing method type reference item.
 940       */
 941     public int newHandle(
 942             final int tag,
 943             final String owner,
 944             final String name,
 945             final String descriptor,
 946             final boolean isInterface) {
 947         return symbolTable.addConstantMethodHandle(tag, owner, name, descriptor, isInterface).index;
 948     }
 949 
 950     /**
 951       * Adds a dynamic constant reference to the constant pool of the class being build. Does nothing
 952       * if the constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link
 953       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
 954       *
 955       * @param name name of the invoked method.
 956       * @param descriptor field descriptor of the constant type.
 957       * @param bootstrapMethodHandle the bootstrap method.
 958       * @param bootstrapMethodArguments the bootstrap method constant arguments.
 959       * @return the index of a new or already existing dynamic constant reference item.
 960       */
 961     public int newConstantDynamic(
 962             final String name,
 963             final String descriptor,
 964             final Handle bootstrapMethodHandle,
 965             final Object... bootstrapMethodArguments) {
 966         return symbolTable.addConstantDynamic(
 967                         name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)
 968                 .index;
 969     }
 970 
 971     /**
 972       * Adds an invokedynamic reference to the constant pool of the class being build. Does nothing if
 973       * the constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link
 974       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
 975       *
 976       * @param name name of the invoked method.
 977       * @param descriptor descriptor of the invoke method.
 978       * @param bootstrapMethodHandle the bootstrap method.
 979       * @param bootstrapMethodArguments the bootstrap method constant arguments.
 980       * @return the index of a new or already existing invokedynamic reference item.
 981       */
 982     public int newInvokeDynamic(
 983             final String name,
 984             final String descriptor,
 985             final Handle bootstrapMethodHandle,
 986             final Object... bootstrapMethodArguments) {
 987         return symbolTable.addConstantInvokeDynamic(
 988                         name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)
 989                 .index;
 990     }
 991 
 992     /**
 993       * Adds a field reference to the constant pool of the class being build. Does nothing if the
 994       * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
 995       * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
 996       *
 997       * @param owner the internal name of the field&#39;s owner class.
 998       * @param name the field&#39;s name.
 999       * @param descriptor the field&#39;s descriptor.
1000       * @return the index of a new or already existing field reference item.
1001       */
1002     public int newField(final String owner, final String name, final String descriptor) {
1003         return symbolTable.addConstantFieldref(owner, name, descriptor).index;
1004     }
1005 
1006     /**
1007       * Adds a method reference to the constant pool of the class being build. Does nothing if the
1008       * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
1009       * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
1010       *
1011       * @param owner the internal name of the method&#39;s owner class.
1012       * @param name the method&#39;s name.
1013       * @param descriptor the method&#39;s descriptor.
1014       * @param isInterface {@literal true} if {@code owner} is an interface.
1015       * @return the index of a new or already existing method reference item.
1016       */
1017     public int newMethod(
1018             final String owner, final String name, final String descriptor, final boolean isInterface) {
1019         return symbolTable.addConstantMethodref(owner, name, descriptor, isInterface).index;
1020     }
1021 
1022     /**
1023       * Adds a name and type to the constant pool of the class being build. Does nothing if the
1024       * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
1025       * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
1026       *
1027       * @param name a name.
1028       * @param descriptor a type descriptor.
1029       * @return the index of a new or already existing name and type item.
1030       */
1031     public int newNameType(final String name, final String descriptor) {
1032         return symbolTable.addConstantNameAndType(name, descriptor);
1033     }
1034 
1035     // -----------------------------------------------------------------------------------------------
1036     // Default method to compute common super classes when computing stack map frames
1037     // -----------------------------------------------------------------------------------------------
1038 
1039     /**
1040       * Returns the common super type of the two given types. The default implementation of this method
1041       * &lt;i&gt;loads&lt;/i&gt; the two given classes and uses the java.lang.Class methods to find the common
1042       * super class. It can be overridden to compute this common super type in other ways, in
1043       * particular without actually loading any class, or to take into account the class that is
1044       * currently being generated by this ClassWriter, which can of course not be loaded since it is
1045       * under construction.
1046       *
1047       * @param type1 the internal name of a class.
1048       * @param type2 the internal name of another class.
1049       * @return the internal name of the common super class of the two given classes.
1050       */
1051     protected String getCommonSuperClass(final String type1, final String type2) {
1052         ClassLoader classLoader = getClassLoader();
1053         Class&lt;?&gt; class1;
1054         try {
1055             class1 = Class.forName(type1.replace(&#39;/&#39;, &#39;.&#39;), false, classLoader);
1056         } catch (ClassNotFoundException e) {
1057             throw new TypeNotPresentException(type1, e);
1058         }
1059         Class&lt;?&gt; class2;
1060         try {
1061             class2 = Class.forName(type2.replace(&#39;/&#39;, &#39;.&#39;), false, classLoader);
1062         } catch (ClassNotFoundException e) {
1063             throw new TypeNotPresentException(type2, e);
1064         }
1065         if (class1.isAssignableFrom(class2)) {
1066             return type1;
1067         }
1068         if (class2.isAssignableFrom(class1)) {
1069             return type2;
1070         }
1071         if (class1.isInterface() || class2.isInterface()) {
1072             return &quot;java/lang/Object&quot;;
1073         } else {
1074             do {
1075                 class1 = class1.getSuperclass();
1076             } while (!class1.isAssignableFrom(class2));
1077             return class1.getName().replace(&#39;.&#39;, &#39;/&#39;);
1078         }
1079     }
1080 
1081     /**
1082       * Returns the {@link ClassLoader} to be used by the default implementation of {@link
1083       * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}&#39;s runtime type by
1084       * default.
1085       *
1086       * @return ClassLoader
1087       */
1088     protected ClassLoader getClassLoader() {
1089         return getClass().getClassLoader();
1090     }
1091 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
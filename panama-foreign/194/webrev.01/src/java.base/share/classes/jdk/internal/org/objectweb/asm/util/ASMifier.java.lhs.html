<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/ASMifier.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * ASM: a very small and fast Java bytecode manipulation framework
  32  * Copyright (c) 2000-2011 INRIA, France Telecom
  33  * All rights reserved.
  34  *
  35  * Redistribution and use in source and binary forms, with or without
  36  * modification, are permitted provided that the following conditions
  37  * are met:
  38  * 1. Redistributions of source code must retain the above copyright
  39  *    notice, this list of conditions and the following disclaimer.
  40  * 2. Redistributions in binary form must reproduce the above copyright
  41  *    notice, this list of conditions and the following disclaimer in the
  42  *    documentation and/or other materials provided with the distribution.
  43  * 3. Neither the name of the copyright holders nor the names of its
  44  *    contributors may be used to endorse or promote products derived from
  45  *    this software without specific prior written permission.
  46  *
  47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  57  * THE POSSIBILITY OF SUCH DAMAGE.
  58  */
  59 package jdk.internal.org.objectweb.asm.util;
  60 
  61 import java.io.IOException;
  62 import java.io.PrintWriter;
  63 import java.util.Arrays;
  64 import java.util.Collections;
  65 import java.util.HashMap;
  66 import java.util.List;
  67 import java.util.Map;
  68 import jdk.internal.org.objectweb.asm.Attribute;
  69 import jdk.internal.org.objectweb.asm.ConstantDynamic;
  70 import jdk.internal.org.objectweb.asm.Handle;
  71 import jdk.internal.org.objectweb.asm.Label;
  72 import jdk.internal.org.objectweb.asm.Opcodes;
  73 import jdk.internal.org.objectweb.asm.Type;
  74 import jdk.internal.org.objectweb.asm.TypePath;
  75 
  76 /**
  77  * A {@link Printer} that prints the ASM code to generate the classes if visits.
  78  *
  79  * @author Eric Bruneton
  80  */
  81 // DontCheck(AbbreviationAsWordInName): can&#39;t be renamed (for backward binary compatibility).
  82 public class ASMifier extends Printer {
  83 
  84     /** The help message shown when command line arguments are incorrect. */
  85     private static final String USAGE =
  86             &quot;Prints the ASM code to generate the given class.\n&quot;
  87                     + &quot;Usage: ASMifier [-debug] &lt;fully qualified class name or class file name&gt;&quot;;
  88 
  89     /** A pseudo access flag used to distinguish class access flags. */
  90     private static final int ACCESS_CLASS = 0x40000;
  91 
  92     /** A pseudo access flag used to distinguish field access flags. */
  93     private static final int ACCESS_FIELD = 0x80000;
  94 
  95     /** A pseudo access flag used to distinguish inner class flags. */
  96     private static final int ACCESS_INNER = 0x100000;
  97 
  98     /** A pseudo access flag used to distinguish module requires / exports flags. */
  99     private static final int ACCESS_MODULE = 0x200000;
 100 
 101     private static final String ANNOTATION_VISITOR = &quot;annotationVisitor&quot;;
 102     private static final String ANNOTATION_VISITOR0 = &quot;annotationVisitor0 = &quot;;
 103     private static final String COMMA = &quot;\&quot;, \&quot;&quot;;
 104     private static final String END_ARRAY = &quot; });\n&quot;;
 105     private static final String END_PARAMETERS = &quot;);\n\n&quot;;
 106     private static final String NEW_OBJECT_ARRAY = &quot;, new Object[] {&quot;;
 107     private static final String VISIT_END = &quot;.visitEnd();\n&quot;;
 108 
 109     private static final List&lt;String&gt; FRAME_TYPES =
 110             Collections.unmodifiableList(
 111                     Arrays.asList(
 112                             &quot;Opcodes.TOP&quot;,
 113                             &quot;Opcodes.INTEGER&quot;,
 114                             &quot;Opcodes.FLOAT&quot;,
 115                             &quot;Opcodes.DOUBLE&quot;,
 116                             &quot;Opcodes.LONG&quot;,
 117                             &quot;Opcodes.NULL&quot;,
 118                             &quot;Opcodes.UNINITIALIZED_THIS&quot;));
 119 
 120     private static final Map&lt;Integer, String&gt; CLASS_VERSIONS;
 121 
 122     static {
 123         HashMap&lt;Integer, String&gt; classVersions = new HashMap&lt;&gt;();
 124         classVersions.put(Opcodes.V1_1, &quot;V1_1&quot;);
 125         classVersions.put(Opcodes.V1_2, &quot;V1_2&quot;);
 126         classVersions.put(Opcodes.V1_3, &quot;V1_3&quot;);
 127         classVersions.put(Opcodes.V1_4, &quot;V1_4&quot;);
 128         classVersions.put(Opcodes.V1_5, &quot;V1_5&quot;);
 129         classVersions.put(Opcodes.V1_6, &quot;V1_6&quot;);
 130         classVersions.put(Opcodes.V1_7, &quot;V1_7&quot;);
 131         classVersions.put(Opcodes.V1_8, &quot;V1_8&quot;);
 132         classVersions.put(Opcodes.V9, &quot;V9&quot;);
 133         classVersions.put(Opcodes.V10, &quot;V10&quot;);
 134         classVersions.put(Opcodes.V11, &quot;V11&quot;);
 135         classVersions.put(Opcodes.V12, &quot;V12&quot;);
 136         classVersions.put(Opcodes.V13, &quot;V13&quot;);
 137         classVersions.put(Opcodes.V14, &quot;V14&quot;);
 138         classVersions.put(Opcodes.V15, &quot;V15&quot;);
 139         CLASS_VERSIONS = Collections.unmodifiableMap(classVersions);
 140     }
 141 
 142     /** The name of the visitor variable in the produced code. */
 143     protected final String name;
 144 
 145     /** The identifier of the annotation visitor variable in the produced code. */
 146     protected final int id;
 147 
 148     /** The name of the Label variables in the produced code. */
 149     protected Map&lt;Label, String&gt; labelNames;
 150 
 151     /**
 152       * Constructs a new {@link ASMifier}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;. Instead,
 153       * they must use the {@link #ASMifier(int, String, int)} version.
 154       *
 155       * @throws IllegalStateException If a subclass calls this constructor.
 156       */
 157     public ASMifier() {
 158         this(/* latest api = */ Opcodes.ASM8, &quot;classWriter&quot;, 0);
 159         if (getClass() != ASMifier.class) {
 160             throw new IllegalStateException();
 161         }
 162     }
 163 
 164     /**
 165       * Constructs a new {@link ASMifier}.
 166       *
 167       * @param api the ASM API version implemented by this class. Must be one of {@link Opcodes#ASM4},
 168       *     {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link Opcodes#ASM8}.
 169       * @param visitorVariableName the name of the visitor variable in the produced code.
 170       * @param annotationVisitorId identifier of the annotation visitor variable in the produced code.
 171       */
 172     protected ASMifier(
 173             final int api, final String visitorVariableName, final int annotationVisitorId) {
 174         super(api);
 175         this.name = visitorVariableName;
 176         this.id = annotationVisitorId;
 177     }
 178 
 179     /**
 180       * Prints the ASM source code to generate the given class to the standard output.
 181       *
 182       * &lt;p&gt;Usage: ASMifier [-debug] &amp;lt;binary class name or class file name&amp;gt;
 183       *
 184       * @param args the command line arguments.
 185       * @throws IOException if the class cannot be found, or if an IOException occurs.
 186       */
 187     public static void main(final String[] args) throws IOException {
 188         main(args, new PrintWriter(System.out, true), new PrintWriter(System.err, true));
 189     }
 190 
 191     /**
 192       * Prints the ASM source code to generate the given class to the given output.
 193       *
 194       * &lt;p&gt;Usage: ASMifier [-debug] &amp;lt;binary class name or class file name&amp;gt;
 195       *
 196       * @param args the command line arguments.
 197       * @param output where to print the result.
 198       * @param logger where to log errors.
 199       * @throws IOException if the class cannot be found, or if an IOException occurs.
 200       */
 201     static void main(final String[] args, final PrintWriter output, final PrintWriter logger)
 202             throws IOException {
 203         main(args, USAGE, new ASMifier(), output, logger);
 204     }
 205 
 206     // -----------------------------------------------------------------------------------------------
 207     // Classes
 208     // -----------------------------------------------------------------------------------------------
 209 
 210     @Override
 211     public void visit(
 212             final int version,
 213             final int access,
 214             final String name,
 215             final String signature,
 216             final String superName,
 217             final String[] interfaces) {
 218         String simpleName;
 219         if (name == null) {
 220             simpleName = &quot;module-info&quot;;
 221         } else {
 222             int lastSlashIndex = name.lastIndexOf(&#39;/&#39;);
 223             if (lastSlashIndex == -1) {
 224                 simpleName = name;
 225             } else {
 226                 text.add(&quot;package asm.&quot; + name.substring(0, lastSlashIndex).replace(&#39;/&#39;, &#39;.&#39;) + &quot;;\n&quot;);
 227                 simpleName = name.substring(lastSlashIndex + 1).replaceAll(&quot;[-\\(\\)]&quot;, &quot;_&quot;);
 228             }
 229         }
 230         text.add(&quot;import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n&quot;);
 231         text.add(&quot;import jdk.internal.org.objectweb.asm.Attribute;\n&quot;);
 232         text.add(&quot;import jdk.internal.org.objectweb.asm.ClassReader;\n&quot;);
 233         text.add(&quot;import jdk.internal.org.objectweb.asm.ClassWriter;\n&quot;);
 234         text.add(&quot;import jdk.internal.org.objectweb.asm.ConstantDynamic;\n&quot;);
 235         text.add(&quot;import jdk.internal.org.objectweb.asm.FieldVisitor;\n&quot;);
 236         text.add(&quot;import jdk.internal.org.objectweb.asm.Handle;\n&quot;);
 237         text.add(&quot;import jdk.internal.org.objectweb.asm.Label;\n&quot;);
 238         text.add(&quot;import jdk.internal.org.objectweb.asm.MethodVisitor;\n&quot;);
 239         text.add(&quot;import jdk.internal.org.objectweb.asm.Opcodes;\n&quot;);
 240         text.add(&quot;import jdk.internal.org.objectweb.asm.RecordComponentVisitor;\n&quot;);
 241         text.add(&quot;import jdk.internal.org.objectweb.asm.Type;\n&quot;);
 242         text.add(&quot;import jdk.internal.org.objectweb.asm.TypePath;\n&quot;);
 243         text.add(&quot;public class &quot; + simpleName + &quot;Dump implements Opcodes {\n\n&quot;);
 244         text.add(&quot;public static byte[] dump () throws Exception {\n\n&quot;);
 245         text.add(&quot;ClassWriter classWriter = new ClassWriter(0);\n&quot;);
 246         text.add(&quot;FieldVisitor fieldVisitor;\n&quot;);
 247         text.add(&quot;RecordComponentVisitor recordComponentVisitor;\n&quot;);
 248         text.add(&quot;MethodVisitor methodVisitor;\n&quot;);
 249         text.add(&quot;AnnotationVisitor annotationVisitor0;\n\n&quot;);
 250 
 251         stringBuilder.setLength(0);
 252         stringBuilder.append(&quot;classWriter.visit(&quot;);
 253         String versionString = CLASS_VERSIONS.get(version);
 254         if (versionString != null) {
 255             stringBuilder.append(versionString);
 256         } else {
 257             stringBuilder.append(version);
 258         }
 259         stringBuilder.append(&quot;, &quot;);
 260         appendAccessFlags(access | ACCESS_CLASS);
 261         stringBuilder.append(&quot;, &quot;);
 262         appendConstant(name);
 263         stringBuilder.append(&quot;, &quot;);
 264         appendConstant(signature);
 265         stringBuilder.append(&quot;, &quot;);
 266         appendConstant(superName);
 267         stringBuilder.append(&quot;, &quot;);
 268         if (interfaces != null &amp;&amp; interfaces.length &gt; 0) {
 269             stringBuilder.append(&quot;new String[] {&quot;);
 270             for (int i = 0; i &lt; interfaces.length; ++i) {
 271                 stringBuilder.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
 272                 appendConstant(interfaces[i]);
 273             }
 274             stringBuilder.append(&quot; }&quot;);
 275         } else {
 276             stringBuilder.append(&quot;null&quot;);
 277         }
 278         stringBuilder.append(END_PARAMETERS);
 279         text.add(stringBuilder.toString());
 280     }
 281 
 282     @Override
 283     public void visitSource(final String file, final String debug) {
 284         stringBuilder.setLength(0);
 285         stringBuilder.append(&quot;classWriter.visitSource(&quot;);
 286         appendConstant(file);
 287         stringBuilder.append(&quot;, &quot;);
 288         appendConstant(debug);
 289         stringBuilder.append(END_PARAMETERS);
 290         text.add(stringBuilder.toString());
 291     }
 292 
 293     @Override
 294     public Printer visitModule(final String name, final int flags, final String version) {
 295         stringBuilder.setLength(0);
 296         stringBuilder.append(&quot;ModuleVisitor moduleVisitor = classWriter.visitModule(&quot;);
 297         appendConstant(name);
 298         stringBuilder.append(&quot;, &quot;);
 299         appendAccessFlags(flags | ACCESS_MODULE);
 300         stringBuilder.append(&quot;, &quot;);
 301         appendConstant(version);
 302         stringBuilder.append(END_PARAMETERS);
 303         text.add(stringBuilder.toString());
 304         ASMifier asmifier = createASMifier(&quot;moduleVisitor&quot;, 0);
 305         text.add(asmifier.getText());
 306         text.add(&quot;}\n&quot;);
 307         return asmifier;
 308     }
 309 
 310     @Override
 311     public void visitNestHost(final String nestHost) {
 312         stringBuilder.setLength(0);
 313         stringBuilder.append(&quot;classWriter.visitNestHost(&quot;);
 314         appendConstant(nestHost);
 315         stringBuilder.append(END_PARAMETERS);
 316         text.add(stringBuilder.toString());
 317     }
 318 
 319     @Override
 320     public void visitOuterClass(final String owner, final String name, final String descriptor) {
 321         stringBuilder.setLength(0);
 322         stringBuilder.append(&quot;classWriter.visitOuterClass(&quot;);
 323         appendConstant(owner);
 324         stringBuilder.append(&quot;, &quot;);
 325         appendConstant(name);
 326         stringBuilder.append(&quot;, &quot;);
 327         appendConstant(descriptor);
 328         stringBuilder.append(END_PARAMETERS);
 329         text.add(stringBuilder.toString());
 330     }
 331 
 332     @Override
 333     public ASMifier visitClassAnnotation(final String descriptor, final boolean visible) {
 334         return visitAnnotation(descriptor, visible);
 335     }
 336 
 337     @Override
 338     public ASMifier visitClassTypeAnnotation(
 339             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 340         return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
 341     }
 342 
 343     @Override
 344     public void visitClassAttribute(final Attribute attribute) {
 345         visitAttribute(attribute);
 346     }
 347 
 348     @Override
 349     public void visitNestMember(final String nestMember) {
 350         stringBuilder.setLength(0);
 351         stringBuilder.append(&quot;classWriter.visitNestMember(&quot;);
 352         appendConstant(nestMember);
 353         stringBuilder.append(END_PARAMETERS);
 354         text.add(stringBuilder.toString());
 355     }
 356 
 357     /**
 358       * &lt;b&gt;Experimental, use at your own risk.&lt;/b&gt;.
 359       *
<a name="1" id="anc1"></a><span class="line-modified"> 360       * @param permittedSubtype the internal name of a permitted subtype.</span>
 361       * @deprecated this API is experimental.
 362       */
 363     @Override
 364     @Deprecated
<a name="2" id="anc2"></a><span class="line-modified"> 365     public void visitPermittedSubtypeExperimental(final String permittedSubtype) {</span>
 366         stringBuilder.setLength(0);
<a name="3" id="anc3"></a><span class="line-modified"> 367         stringBuilder.append(&quot;classWriter.visitPermittedSubtypeExperimental(&quot;);</span>
<span class="line-modified"> 368         appendConstant(permittedSubtype);</span>
 369         stringBuilder.append(END_PARAMETERS);
 370         text.add(stringBuilder.toString());
 371     }
 372 
 373     @Override
 374     public void visitInnerClass(
 375             final String name, final String outerName, final String innerName, final int access) {
 376         stringBuilder.setLength(0);
 377         stringBuilder.append(&quot;classWriter.visitInnerClass(&quot;);
 378         appendConstant(name);
 379         stringBuilder.append(&quot;, &quot;);
 380         appendConstant(outerName);
 381         stringBuilder.append(&quot;, &quot;);
 382         appendConstant(innerName);
 383         stringBuilder.append(&quot;, &quot;);
 384         appendAccessFlags(access | ACCESS_INNER);
 385         stringBuilder.append(END_PARAMETERS);
 386         text.add(stringBuilder.toString());
 387     }
 388 
 389     @Override
 390     public ASMifier visitRecordComponent(
 391             final String name, final String descriptor, final String signature) {
 392         stringBuilder.setLength(0);
 393         stringBuilder.append(&quot;{\n&quot;);
 394         stringBuilder.append(&quot;recordComponentVisitor = classWriter.visitRecordComponent(&quot;);
 395         appendConstant(name);
 396         stringBuilder.append(&quot;, &quot;);
 397         appendConstant(descriptor);
 398         stringBuilder.append(&quot;, &quot;);
 399         appendConstant(signature);
 400         stringBuilder.append(&quot;);\n&quot;);
 401         text.add(stringBuilder.toString());
 402         ASMifier asmifier = createASMifier(&quot;recordComponentVisitor&quot;, 0);
 403         text.add(asmifier.getText());
 404         text.add(&quot;}\n&quot;);
 405         return asmifier;
 406     }
 407 
 408     @Override
 409     public ASMifier visitField(
 410             final int access,
 411             final String name,
 412             final String descriptor,
 413             final String signature,
 414             final Object value) {
 415         stringBuilder.setLength(0);
 416         stringBuilder.append(&quot;{\n&quot;);
 417         stringBuilder.append(&quot;fieldVisitor = classWriter.visitField(&quot;);
 418         appendAccessFlags(access | ACCESS_FIELD);
 419         stringBuilder.append(&quot;, &quot;);
 420         appendConstant(name);
 421         stringBuilder.append(&quot;, &quot;);
 422         appendConstant(descriptor);
 423         stringBuilder.append(&quot;, &quot;);
 424         appendConstant(signature);
 425         stringBuilder.append(&quot;, &quot;);
 426         appendConstant(value);
 427         stringBuilder.append(&quot;);\n&quot;);
 428         text.add(stringBuilder.toString());
 429         ASMifier asmifier = createASMifier(&quot;fieldVisitor&quot;, 0);
 430         text.add(asmifier.getText());
 431         text.add(&quot;}\n&quot;);
 432         return asmifier;
 433     }
 434 
 435     @Override
 436     public ASMifier visitMethod(
 437             final int access,
 438             final String name,
 439             final String descriptor,
 440             final String signature,
 441             final String[] exceptions) {
 442         stringBuilder.setLength(0);
 443         stringBuilder.append(&quot;{\n&quot;);
 444         stringBuilder.append(&quot;methodVisitor = classWriter.visitMethod(&quot;);
 445         appendAccessFlags(access);
 446         stringBuilder.append(&quot;, &quot;);
 447         appendConstant(name);
 448         stringBuilder.append(&quot;, &quot;);
 449         appendConstant(descriptor);
 450         stringBuilder.append(&quot;, &quot;);
 451         appendConstant(signature);
 452         stringBuilder.append(&quot;, &quot;);
 453         if (exceptions != null &amp;&amp; exceptions.length &gt; 0) {
 454             stringBuilder.append(&quot;new String[] {&quot;);
 455             for (int i = 0; i &lt; exceptions.length; ++i) {
 456                 stringBuilder.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
 457                 appendConstant(exceptions[i]);
 458             }
 459             stringBuilder.append(&quot; }&quot;);
 460         } else {
 461             stringBuilder.append(&quot;null&quot;);
 462         }
 463         stringBuilder.append(&quot;);\n&quot;);
 464         text.add(stringBuilder.toString());
 465         ASMifier asmifier = createASMifier(&quot;methodVisitor&quot;, 0);
 466         text.add(asmifier.getText());
 467         text.add(&quot;}\n&quot;);
 468         return asmifier;
 469     }
 470 
 471     @Override
 472     public void visitClassEnd() {
 473         text.add(&quot;classWriter.visitEnd();\n\n&quot;);
 474         text.add(&quot;return classWriter.toByteArray();\n&quot;);
 475         text.add(&quot;}\n&quot;);
 476         text.add(&quot;}\n&quot;);
 477     }
 478 
 479     // -----------------------------------------------------------------------------------------------
 480     // Modules
 481     // -----------------------------------------------------------------------------------------------
 482 
 483     @Override
 484     public void visitMainClass(final String mainClass) {
 485         stringBuilder.setLength(0);
 486         stringBuilder.append(&quot;moduleVisitor.visitMainClass(&quot;);
 487         appendConstant(mainClass);
 488         stringBuilder.append(&quot;);\n&quot;);
 489         text.add(stringBuilder.toString());
 490     }
 491 
 492     @Override
 493     public void visitPackage(final String packaze) {
 494         stringBuilder.setLength(0);
 495         stringBuilder.append(&quot;moduleVisitor.visitPackage(&quot;);
 496         appendConstant(packaze);
 497         stringBuilder.append(&quot;);\n&quot;);
 498         text.add(stringBuilder.toString());
 499     }
 500 
 501     @Override
 502     public void visitRequire(final String module, final int access, final String version) {
 503         stringBuilder.setLength(0);
 504         stringBuilder.append(&quot;moduleVisitor.visitRequire(&quot;);
 505         appendConstant(module);
 506         stringBuilder.append(&quot;, &quot;);
 507         appendAccessFlags(access | ACCESS_MODULE);
 508         stringBuilder.append(&quot;, &quot;);
 509         appendConstant(version);
 510         stringBuilder.append(&quot;);\n&quot;);
 511         text.add(stringBuilder.toString());
 512     }
 513 
 514     @Override
 515     public void visitExport(final String packaze, final int access, final String... modules) {
 516         visitExportOrOpen(&quot;moduleVisitor.visitExport(&quot;, packaze, access, modules);
 517     }
 518 
 519     @Override
 520     public void visitOpen(final String packaze, final int access, final String... modules) {
 521         visitExportOrOpen(&quot;moduleVisitor.visitOpen(&quot;, packaze, access, modules);
 522     }
 523 
 524     private void visitExportOrOpen(
 525             final String visitMethod, final String packaze, final int access, final String... modules) {
 526         stringBuilder.setLength(0);
 527         stringBuilder.append(visitMethod);
 528         appendConstant(packaze);
 529         stringBuilder.append(&quot;, &quot;);
 530         appendAccessFlags(access | ACCESS_MODULE);
 531         if (modules != null &amp;&amp; modules.length &gt; 0) {
 532             stringBuilder.append(&quot;, new String[] {&quot;);
 533             for (int i = 0; i &lt; modules.length; ++i) {
 534                 stringBuilder.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
 535                 appendConstant(modules[i]);
 536             }
 537             stringBuilder.append(&quot; }&quot;);
 538         }
 539         stringBuilder.append(&quot;);\n&quot;);
 540         text.add(stringBuilder.toString());
 541     }
 542 
 543     @Override
 544     public void visitUse(final String service) {
 545         stringBuilder.setLength(0);
 546         stringBuilder.append(&quot;moduleVisitor.visitUse(&quot;);
 547         appendConstant(service);
 548         stringBuilder.append(&quot;);\n&quot;);
 549         text.add(stringBuilder.toString());
 550     }
 551 
 552     @Override
 553     public void visitProvide(final String service, final String... providers) {
 554         stringBuilder.setLength(0);
 555         stringBuilder.append(&quot;moduleVisitor.visitProvide(&quot;);
 556         appendConstant(service);
 557         stringBuilder.append(&quot;,  new String[] {&quot;);
 558         for (int i = 0; i &lt; providers.length; ++i) {
 559             stringBuilder.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
 560             appendConstant(providers[i]);
 561         }
 562         stringBuilder.append(END_ARRAY);
 563         text.add(stringBuilder.toString());
 564     }
 565 
 566     @Override
 567     public void visitModuleEnd() {
 568         text.add(&quot;moduleVisitor.visitEnd();\n&quot;);
 569     }
 570 
 571     // -----------------------------------------------------------------------------------------------
 572     // Annotations
 573     // -----------------------------------------------------------------------------------------------
 574 
 575     // DontCheck(OverloadMethodsDeclarationOrder): overloads are semantically different.
 576     @Override
 577     public void visit(final String name, final Object value) {
 578         stringBuilder.setLength(0);
 579         stringBuilder.append(ANNOTATION_VISITOR).append(id).append(&quot;.visit(&quot;);
 580         appendConstant(name);
 581         stringBuilder.append(&quot;, &quot;);
 582         appendConstant(value);
 583         stringBuilder.append(&quot;);\n&quot;);
 584         text.add(stringBuilder.toString());
 585     }
 586 
 587     @Override
 588     public void visitEnum(final String name, final String descriptor, final String value) {
 589         stringBuilder.setLength(0);
 590         stringBuilder.append(ANNOTATION_VISITOR).append(id).append(&quot;.visitEnum(&quot;);
 591         appendConstant(name);
 592         stringBuilder.append(&quot;, &quot;);
 593         appendConstant(descriptor);
 594         stringBuilder.append(&quot;, &quot;);
 595         appendConstant(value);
 596         stringBuilder.append(&quot;);\n&quot;);
 597         text.add(stringBuilder.toString());
 598     }
 599 
 600     @Override
 601     public ASMifier visitAnnotation(final String name, final String descriptor) {
 602         stringBuilder.setLength(0);
 603         stringBuilder
 604                 .append(&quot;{\n&quot;)
 605                 .append(&quot;AnnotationVisitor annotationVisitor&quot;)
 606                 .append(id + 1)
 607                 .append(&quot; = annotationVisitor&quot;);
 608         stringBuilder.append(id).append(&quot;.visitAnnotation(&quot;);
 609         appendConstant(name);
 610         stringBuilder.append(&quot;, &quot;);
 611         appendConstant(descriptor);
 612         stringBuilder.append(&quot;);\n&quot;);
 613         text.add(stringBuilder.toString());
 614         ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, id + 1);
 615         text.add(asmifier.getText());
 616         text.add(&quot;}\n&quot;);
 617         return asmifier;
 618     }
 619 
 620     @Override
 621     public ASMifier visitArray(final String name) {
 622         stringBuilder.setLength(0);
 623         stringBuilder.append(&quot;{\n&quot;);
 624         stringBuilder
 625                 .append(&quot;AnnotationVisitor annotationVisitor&quot;)
 626                 .append(id + 1)
 627                 .append(&quot; = annotationVisitor&quot;);
 628         stringBuilder.append(id).append(&quot;.visitArray(&quot;);
 629         appendConstant(name);
 630         stringBuilder.append(&quot;);\n&quot;);
 631         text.add(stringBuilder.toString());
 632         ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, id + 1);
 633         text.add(asmifier.getText());
 634         text.add(&quot;}\n&quot;);
 635         return asmifier;
 636     }
 637 
 638     @Override
 639     public void visitAnnotationEnd() {
 640         stringBuilder.setLength(0);
 641         stringBuilder.append(ANNOTATION_VISITOR).append(id).append(VISIT_END);
 642         text.add(stringBuilder.toString());
 643     }
 644 
 645     // -----------------------------------------------------------------------------------------------
 646     // Record components
 647     // -----------------------------------------------------------------------------------------------
 648 
 649     @Override
 650     public ASMifier visitRecordComponentAnnotation(final String descriptor, final boolean visible) {
 651         return visitAnnotation(descriptor, visible);
 652     }
 653 
 654     @Override
 655     public ASMifier visitRecordComponentTypeAnnotation(
 656             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 657         return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
 658     }
 659 
 660     @Override
 661     public void visitRecordComponentAttribute(final Attribute attribute) {
 662         visitAttribute(attribute);
 663     }
 664 
 665     @Override
 666     public void visitRecordComponentEnd() {
 667         stringBuilder.setLength(0);
 668         stringBuilder.append(name).append(VISIT_END);
 669         text.add(stringBuilder.toString());
 670     }
 671 
 672     // -----------------------------------------------------------------------------------------------
 673     // Fields
 674     // -----------------------------------------------------------------------------------------------
 675 
 676     @Override
 677     public ASMifier visitFieldAnnotation(final String descriptor, final boolean visible) {
 678         return visitAnnotation(descriptor, visible);
 679     }
 680 
 681     @Override
 682     public ASMifier visitFieldTypeAnnotation(
 683             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 684         return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
 685     }
 686 
 687     @Override
 688     public void visitFieldAttribute(final Attribute attribute) {
 689         visitAttribute(attribute);
 690     }
 691 
 692     @Override
 693     public void visitFieldEnd() {
 694         stringBuilder.setLength(0);
 695         stringBuilder.append(name).append(VISIT_END);
 696         text.add(stringBuilder.toString());
 697     }
 698 
 699     // -----------------------------------------------------------------------------------------------
 700     // Methods
 701     // -----------------------------------------------------------------------------------------------
 702 
 703     @Override
 704     public void visitParameter(final String parameterName, final int access) {
 705         stringBuilder.setLength(0);
 706         stringBuilder.append(name).append(&quot;.visitParameter(&quot;);
 707         appendString(stringBuilder, parameterName);
 708         stringBuilder.append(&quot;, &quot;);
 709         appendAccessFlags(access);
 710         text.add(stringBuilder.append(&quot;);\n&quot;).toString());
 711     }
 712 
 713     @Override
 714     public ASMifier visitAnnotationDefault() {
 715         stringBuilder.setLength(0);
 716         stringBuilder
 717                 .append(&quot;{\n&quot;)
 718                 .append(ANNOTATION_VISITOR0)
 719                 .append(name)
 720                 .append(&quot;.visitAnnotationDefault();\n&quot;);
 721         text.add(stringBuilder.toString());
 722         ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, 0);
 723         text.add(asmifier.getText());
 724         text.add(&quot;}\n&quot;);
 725         return asmifier;
 726     }
 727 
 728     @Override
 729     public ASMifier visitMethodAnnotation(final String descriptor, final boolean visible) {
 730         return visitAnnotation(descriptor, visible);
 731     }
 732 
 733     @Override
 734     public ASMifier visitMethodTypeAnnotation(
 735             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 736         return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
 737     }
 738 
 739     @Override
 740     public ASMifier visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
 741         stringBuilder.setLength(0);
 742         stringBuilder
 743                 .append(name)
 744                 .append(&quot;.visitAnnotableParameterCount(&quot;)
 745                 .append(parameterCount)
 746                 .append(&quot;, &quot;)
 747                 .append(visible)
 748                 .append(&quot;);\n&quot;);
 749         text.add(stringBuilder.toString());
 750         return this;
 751     }
 752 
 753     @Override
 754     public ASMifier visitParameterAnnotation(
 755             final int parameter, final String descriptor, final boolean visible) {
 756         stringBuilder.setLength(0);
 757         stringBuilder
 758                 .append(&quot;{\n&quot;)
 759                 .append(ANNOTATION_VISITOR0)
 760                 .append(name)
 761                 .append(&quot;.visitParameterAnnotation(&quot;)
 762                 .append(parameter)
 763                 .append(&quot;, &quot;);
 764         appendConstant(descriptor);
 765         stringBuilder.append(&quot;, &quot;).append(visible).append(&quot;);\n&quot;);
 766         text.add(stringBuilder.toString());
 767         ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, 0);
 768         text.add(asmifier.getText());
 769         text.add(&quot;}\n&quot;);
 770         return asmifier;
 771     }
 772 
 773     @Override
 774     public void visitMethodAttribute(final Attribute attribute) {
 775         visitAttribute(attribute);
 776     }
 777 
 778     @Override
 779     public void visitCode() {
 780         text.add(name + &quot;.visitCode();\n&quot;);
 781     }
 782 
 783     @Override
 784     public void visitFrame(
 785             final int type,
 786             final int numLocal,
 787             final Object[] local,
 788             final int numStack,
 789             final Object[] stack) {
 790         stringBuilder.setLength(0);
 791         switch (type) {
 792             case Opcodes.F_NEW:
 793             case Opcodes.F_FULL:
 794                 declareFrameTypes(numLocal, local);
 795                 declareFrameTypes(numStack, stack);
 796                 if (type == Opcodes.F_NEW) {
 797                     stringBuilder.append(name).append(&quot;.visitFrame(Opcodes.F_NEW, &quot;);
 798                 } else {
 799                     stringBuilder.append(name).append(&quot;.visitFrame(Opcodes.F_FULL, &quot;);
 800                 }
 801                 stringBuilder.append(numLocal).append(NEW_OBJECT_ARRAY);
 802                 appendFrameTypes(numLocal, local);
 803                 stringBuilder.append(&quot;}, &quot;).append(numStack).append(NEW_OBJECT_ARRAY);
 804                 appendFrameTypes(numStack, stack);
 805                 stringBuilder.append(&#39;}&#39;);
 806                 break;
 807             case Opcodes.F_APPEND:
 808                 declareFrameTypes(numLocal, local);
 809                 stringBuilder
 810                         .append(name)
 811                         .append(&quot;.visitFrame(Opcodes.F_APPEND,&quot;)
 812                         .append(numLocal)
 813                         .append(NEW_OBJECT_ARRAY);
 814                 appendFrameTypes(numLocal, local);
 815                 stringBuilder.append(&quot;}, 0, null&quot;);
 816                 break;
 817             case Opcodes.F_CHOP:
 818                 stringBuilder
 819                         .append(name)
 820                         .append(&quot;.visitFrame(Opcodes.F_CHOP,&quot;)
 821                         .append(numLocal)
 822                         .append(&quot;, null, 0, null&quot;);
 823                 break;
 824             case Opcodes.F_SAME:
 825                 stringBuilder.append(name).append(&quot;.visitFrame(Opcodes.F_SAME, 0, null, 0, null&quot;);
 826                 break;
 827             case Opcodes.F_SAME1:
 828                 declareFrameTypes(1, stack);
 829                 stringBuilder
 830                         .append(name)
 831                         .append(&quot;.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] {&quot;);
 832                 appendFrameTypes(1, stack);
 833                 stringBuilder.append(&#39;}&#39;);
 834                 break;
 835             default:
 836                 throw new IllegalArgumentException();
 837         }
 838         stringBuilder.append(&quot;);\n&quot;);
 839         text.add(stringBuilder.toString());
 840     }
 841 
 842     @Override
 843     public void visitInsn(final int opcode) {
 844         stringBuilder.setLength(0);
 845         stringBuilder.append(name).append(&quot;.visitInsn(&quot;).append(OPCODES[opcode]).append(&quot;);\n&quot;);
 846         text.add(stringBuilder.toString());
 847     }
 848 
 849     @Override
 850     public void visitIntInsn(final int opcode, final int operand) {
 851         stringBuilder.setLength(0);
 852         stringBuilder
 853                 .append(name)
 854                 .append(&quot;.visitIntInsn(&quot;)
 855                 .append(OPCODES[opcode])
 856                 .append(&quot;, &quot;)
 857                 .append(opcode == Opcodes.NEWARRAY ? TYPES[operand] : Integer.toString(operand))
 858                 .append(&quot;);\n&quot;);
 859         text.add(stringBuilder.toString());
 860     }
 861 
 862     @Override
 863     public void visitVarInsn(final int opcode, final int var) {
 864         stringBuilder.setLength(0);
 865         stringBuilder
 866                 .append(name)
 867                 .append(&quot;.visitVarInsn(&quot;)
 868                 .append(OPCODES[opcode])
 869                 .append(&quot;, &quot;)
 870                 .append(var)
 871                 .append(&quot;);\n&quot;);
 872         text.add(stringBuilder.toString());
 873     }
 874 
 875     @Override
 876     public void visitTypeInsn(final int opcode, final String type) {
 877         stringBuilder.setLength(0);
 878         stringBuilder.append(name).append(&quot;.visitTypeInsn(&quot;).append(OPCODES[opcode]).append(&quot;, &quot;);
 879         appendConstant(type);
 880         stringBuilder.append(&quot;);\n&quot;);
 881         text.add(stringBuilder.toString());
 882     }
 883 
 884     @Override
 885     public void visitFieldInsn(
 886             final int opcode, final String owner, final String name, final String descriptor) {
 887         stringBuilder.setLength(0);
 888         stringBuilder.append(this.name).append(&quot;.visitFieldInsn(&quot;).append(OPCODES[opcode]).append(&quot;, &quot;);
 889         appendConstant(owner);
 890         stringBuilder.append(&quot;, &quot;);
 891         appendConstant(name);
 892         stringBuilder.append(&quot;, &quot;);
 893         appendConstant(descriptor);
 894         stringBuilder.append(&quot;);\n&quot;);
 895         text.add(stringBuilder.toString());
 896     }
 897 
 898     @Override
 899     public void visitMethodInsn(
 900             final int opcode,
 901             final String owner,
 902             final String name,
 903             final String descriptor,
 904             final boolean isInterface) {
 905         stringBuilder.setLength(0);
 906         stringBuilder
 907                 .append(this.name)
 908                 .append(&quot;.visitMethodInsn(&quot;)
 909                 .append(OPCODES[opcode])
 910                 .append(&quot;, &quot;);
 911         appendConstant(owner);
 912         stringBuilder.append(&quot;, &quot;);
 913         appendConstant(name);
 914         stringBuilder.append(&quot;, &quot;);
 915         appendConstant(descriptor);
 916         stringBuilder.append(&quot;, &quot;);
 917         stringBuilder.append(isInterface ? &quot;true&quot; : &quot;false&quot;);
 918         stringBuilder.append(&quot;);\n&quot;);
 919         text.add(stringBuilder.toString());
 920     }
 921 
 922     @Override
 923     public void visitInvokeDynamicInsn(
 924             final String name,
 925             final String descriptor,
 926             final Handle bootstrapMethodHandle,
 927             final Object... bootstrapMethodArguments) {
 928         stringBuilder.setLength(0);
 929         stringBuilder.append(this.name).append(&quot;.visitInvokeDynamicInsn(&quot;);
 930         appendConstant(name);
 931         stringBuilder.append(&quot;, &quot;);
 932         appendConstant(descriptor);
 933         stringBuilder.append(&quot;, &quot;);
 934         appendConstant(bootstrapMethodHandle);
 935         stringBuilder.append(&quot;, new Object[]{&quot;);
 936         for (int i = 0; i &lt; bootstrapMethodArguments.length; ++i) {
 937             appendConstant(bootstrapMethodArguments[i]);
 938             if (i != bootstrapMethodArguments.length - 1) {
 939                 stringBuilder.append(&quot;, &quot;);
 940             }
 941         }
 942         stringBuilder.append(&quot;});\n&quot;);
 943         text.add(stringBuilder.toString());
 944     }
 945 
 946     @Override
 947     public void visitJumpInsn(final int opcode, final Label label) {
 948         stringBuilder.setLength(0);
 949         declareLabel(label);
 950         stringBuilder.append(name).append(&quot;.visitJumpInsn(&quot;).append(OPCODES[opcode]).append(&quot;, &quot;);
 951         appendLabel(label);
 952         stringBuilder.append(&quot;);\n&quot;);
 953         text.add(stringBuilder.toString());
 954     }
 955 
 956     @Override
 957     public void visitLabel(final Label label) {
 958         stringBuilder.setLength(0);
 959         declareLabel(label);
 960         stringBuilder.append(name).append(&quot;.visitLabel(&quot;);
 961         appendLabel(label);
 962         stringBuilder.append(&quot;);\n&quot;);
 963         text.add(stringBuilder.toString());
 964     }
 965 
 966     @Override
 967     public void visitLdcInsn(final Object value) {
 968         stringBuilder.setLength(0);
 969         stringBuilder.append(name).append(&quot;.visitLdcInsn(&quot;);
 970         appendConstant(value);
 971         stringBuilder.append(&quot;);\n&quot;);
 972         text.add(stringBuilder.toString());
 973     }
 974 
 975     @Override
 976     public void visitIincInsn(final int var, final int increment) {
 977         stringBuilder.setLength(0);
 978         stringBuilder
 979                 .append(name)
 980                 .append(&quot;.visitIincInsn(&quot;)
 981                 .append(var)
 982                 .append(&quot;, &quot;)
 983                 .append(increment)
 984                 .append(&quot;);\n&quot;);
 985         text.add(stringBuilder.toString());
 986     }
 987 
 988     @Override
 989     public void visitTableSwitchInsn(
 990             final int min, final int max, final Label dflt, final Label... labels) {
 991         stringBuilder.setLength(0);
 992         for (Label label : labels) {
 993             declareLabel(label);
 994         }
 995         declareLabel(dflt);
 996 
 997         stringBuilder
 998                 .append(name)
 999                 .append(&quot;.visitTableSwitchInsn(&quot;)
1000                 .append(min)
1001                 .append(&quot;, &quot;)
1002                 .append(max)
1003                 .append(&quot;, &quot;);
1004         appendLabel(dflt);
1005         stringBuilder.append(&quot;, new Label[] {&quot;);
1006         for (int i = 0; i &lt; labels.length; ++i) {
1007             stringBuilder.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
1008             appendLabel(labels[i]);
1009         }
1010         stringBuilder.append(END_ARRAY);
1011         text.add(stringBuilder.toString());
1012     }
1013 
1014     @Override
1015     public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
1016         stringBuilder.setLength(0);
1017         for (Label label : labels) {
1018             declareLabel(label);
1019         }
1020         declareLabel(dflt);
1021 
1022         stringBuilder.append(name).append(&quot;.visitLookupSwitchInsn(&quot;);
1023         appendLabel(dflt);
1024         stringBuilder.append(&quot;, new int[] {&quot;);
1025         for (int i = 0; i &lt; keys.length; ++i) {
1026             stringBuilder.append(i == 0 ? &quot; &quot; : &quot;, &quot;).append(keys[i]);
1027         }
1028         stringBuilder.append(&quot; }, new Label[] {&quot;);
1029         for (int i = 0; i &lt; labels.length; ++i) {
1030             stringBuilder.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
1031             appendLabel(labels[i]);
1032         }
1033         stringBuilder.append(END_ARRAY);
1034         text.add(stringBuilder.toString());
1035     }
1036 
1037     @Override
1038     public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
1039         stringBuilder.setLength(0);
1040         stringBuilder.append(name).append(&quot;.visitMultiANewArrayInsn(&quot;);
1041         appendConstant(descriptor);
1042         stringBuilder.append(&quot;, &quot;).append(numDimensions).append(&quot;);\n&quot;);
1043         text.add(stringBuilder.toString());
1044     }
1045 
1046     @Override
1047     public ASMifier visitInsnAnnotation(
1048             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
1049         return visitTypeAnnotation(&quot;visitInsnAnnotation&quot;, typeRef, typePath, descriptor, visible);
1050     }
1051 
1052     @Override
1053     public void visitTryCatchBlock(
1054             final Label start, final Label end, final Label handler, final String type) {
1055         stringBuilder.setLength(0);
1056         declareLabel(start);
1057         declareLabel(end);
1058         declareLabel(handler);
1059         stringBuilder.append(name).append(&quot;.visitTryCatchBlock(&quot;);
1060         appendLabel(start);
1061         stringBuilder.append(&quot;, &quot;);
1062         appendLabel(end);
1063         stringBuilder.append(&quot;, &quot;);
1064         appendLabel(handler);
1065         stringBuilder.append(&quot;, &quot;);
1066         appendConstant(type);
1067         stringBuilder.append(&quot;);\n&quot;);
1068         text.add(stringBuilder.toString());
1069     }
1070 
1071     @Override
1072     public ASMifier visitTryCatchAnnotation(
1073             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
1074         return visitTypeAnnotation(&quot;visitTryCatchAnnotation&quot;, typeRef, typePath, descriptor, visible);
1075     }
1076 
1077     @Override
1078     public void visitLocalVariable(
1079             final String name,
1080             final String descriptor,
1081             final String signature,
1082             final Label start,
1083             final Label end,
1084             final int index) {
1085         stringBuilder.setLength(0);
1086         stringBuilder.append(this.name).append(&quot;.visitLocalVariable(&quot;);
1087         appendConstant(name);
1088         stringBuilder.append(&quot;, &quot;);
1089         appendConstant(descriptor);
1090         stringBuilder.append(&quot;, &quot;);
1091         appendConstant(signature);
1092         stringBuilder.append(&quot;, &quot;);
1093         appendLabel(start);
1094         stringBuilder.append(&quot;, &quot;);
1095         appendLabel(end);
1096         stringBuilder.append(&quot;, &quot;).append(index).append(&quot;);\n&quot;);
1097         text.add(stringBuilder.toString());
1098     }
1099 
1100     @Override
1101     public Printer visitLocalVariableAnnotation(
1102             final int typeRef,
1103             final TypePath typePath,
1104             final Label[] start,
1105             final Label[] end,
1106             final int[] index,
1107             final String descriptor,
1108             final boolean visible) {
1109         stringBuilder.setLength(0);
1110         stringBuilder
1111                 .append(&quot;{\n&quot;)
1112                 .append(ANNOTATION_VISITOR0)
1113                 .append(name)
1114                 .append(&quot;.visitLocalVariableAnnotation(&quot;)
1115                 .append(typeRef);
1116         if (typePath == null) {
1117             stringBuilder.append(&quot;, null, &quot;);
1118         } else {
1119             stringBuilder.append(&quot;, TypePath.fromString(\&quot;&quot;).append(typePath).append(&quot;\&quot;), &quot;);
1120         }
1121         stringBuilder.append(&quot;new Label[] {&quot;);
1122         for (int i = 0; i &lt; start.length; ++i) {
1123             stringBuilder.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
1124             appendLabel(start[i]);
1125         }
1126         stringBuilder.append(&quot; }, new Label[] {&quot;);
1127         for (int i = 0; i &lt; end.length; ++i) {
1128             stringBuilder.append(i == 0 ? &quot; &quot; : &quot;, &quot;);
1129             appendLabel(end[i]);
1130         }
1131         stringBuilder.append(&quot; }, new int[] {&quot;);
1132         for (int i = 0; i &lt; index.length; ++i) {
1133             stringBuilder.append(i == 0 ? &quot; &quot; : &quot;, &quot;).append(index[i]);
1134         }
1135         stringBuilder.append(&quot; }, &quot;);
1136         appendConstant(descriptor);
1137         stringBuilder.append(&quot;, &quot;).append(visible).append(&quot;);\n&quot;);
1138         text.add(stringBuilder.toString());
1139         ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, 0);
1140         text.add(asmifier.getText());
1141         text.add(&quot;}\n&quot;);
1142         return asmifier;
1143     }
1144 
1145     @Override
1146     public void visitLineNumber(final int line, final Label start) {
1147         stringBuilder.setLength(0);
1148         stringBuilder.append(name).append(&quot;.visitLineNumber(&quot;).append(line).append(&quot;, &quot;);
1149         appendLabel(start);
1150         stringBuilder.append(&quot;);\n&quot;);
1151         text.add(stringBuilder.toString());
1152     }
1153 
1154     @Override
1155     public void visitMaxs(final int maxStack, final int maxLocals) {
1156         stringBuilder.setLength(0);
1157         stringBuilder
1158                 .append(name)
1159                 .append(&quot;.visitMaxs(&quot;)
1160                 .append(maxStack)
1161                 .append(&quot;, &quot;)
1162                 .append(maxLocals)
1163                 .append(&quot;);\n&quot;);
1164         text.add(stringBuilder.toString());
1165     }
1166 
1167     @Override
1168     public void visitMethodEnd() {
1169         stringBuilder.setLength(0);
1170         stringBuilder.append(name).append(VISIT_END);
1171         text.add(stringBuilder.toString());
1172     }
1173 
1174     // -----------------------------------------------------------------------------------------------
1175     // Common methods
1176     // -----------------------------------------------------------------------------------------------
1177 
1178     /**
1179       * Visits a class, field or method annotation.
1180       *
1181       * @param descriptor the class descriptor of the annotation class.
1182       * @param visible {@literal true} if the annotation is visible at runtime.
1183       * @return a new {@link ASMifier} to visit the annotation values.
1184       */
1185     // DontCheck(OverloadMethodsDeclarationOrder): overloads are semantically different.
1186     public ASMifier visitAnnotation(final String descriptor, final boolean visible) {
1187         stringBuilder.setLength(0);
1188         stringBuilder
1189                 .append(&quot;{\n&quot;)
1190                 .append(ANNOTATION_VISITOR0)
1191                 .append(name)
1192                 .append(&quot;.visitAnnotation(&quot;);
1193         appendConstant(descriptor);
1194         stringBuilder.append(&quot;, &quot;).append(visible).append(&quot;);\n&quot;);
1195         text.add(stringBuilder.toString());
1196         ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, 0);
1197         text.add(asmifier.getText());
1198         text.add(&quot;}\n&quot;);
1199         return asmifier;
1200     }
1201 
1202     /**
1203       * Visits a class, field or method type annotation.
1204       *
1205       * @param typeRef a reference to the annotated type. The sort of this type reference must be
1206       *     {@link jdk.internal.org.objectweb.asm.TypeReference#FIELD}. See {@link jdk.internal.org.objectweb.asm.TypeReference}.
1207       * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
1208       *     static inner type within &#39;typeRef&#39;. May be {@literal null} if the annotation targets
1209       *     &#39;typeRef&#39; as a whole.
1210       * @param descriptor the class descriptor of the annotation class.
1211       * @param visible {@literal true} if the annotation is visible at runtime.
1212       * @return a new {@link ASMifier} to visit the annotation values.
1213       */
1214     public ASMifier visitTypeAnnotation(
1215             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
1216         return visitTypeAnnotation(&quot;visitTypeAnnotation&quot;, typeRef, typePath, descriptor, visible);
1217     }
1218 
1219     /**
1220       * Visits a class, field, method, instruction or try catch block type annotation.
1221       *
1222       * @param method the name of the visit method for this type of annotation.
1223       * @param typeRef a reference to the annotated type. The sort of this type reference must be
1224       *     {@link jdk.internal.org.objectweb.asm.TypeReference#FIELD}. See {@link jdk.internal.org.objectweb.asm.TypeReference}.
1225       * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
1226       *     static inner type within &#39;typeRef&#39;. May be {@literal null} if the annotation targets
1227       *     &#39;typeRef&#39; as a whole.
1228       * @param descriptor the class descriptor of the annotation class.
1229       * @param visible {@literal true} if the annotation is visible at runtime.
1230       * @return a new {@link ASMifier} to visit the annotation values.
1231       */
1232     public ASMifier visitTypeAnnotation(
1233             final String method,
1234             final int typeRef,
1235             final TypePath typePath,
1236             final String descriptor,
1237             final boolean visible) {
1238         stringBuilder.setLength(0);
1239         stringBuilder
1240                 .append(&quot;{\n&quot;)
1241                 .append(ANNOTATION_VISITOR0)
1242                 .append(name)
1243                 .append(&quot;.&quot;)
1244                 .append(method)
1245                 .append(&quot;(&quot;)
1246                 .append(typeRef);
1247         if (typePath == null) {
1248             stringBuilder.append(&quot;, null, &quot;);
1249         } else {
1250             stringBuilder.append(&quot;, TypePath.fromString(\&quot;&quot;).append(typePath).append(&quot;\&quot;), &quot;);
1251         }
1252         appendConstant(descriptor);
1253         stringBuilder.append(&quot;, &quot;).append(visible).append(&quot;);\n&quot;);
1254         text.add(stringBuilder.toString());
1255         ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, 0);
1256         text.add(asmifier.getText());
1257         text.add(&quot;}\n&quot;);
1258         return asmifier;
1259     }
1260 
1261     /**
1262       * Visit a class, field or method attribute.
1263       *
1264       * @param attribute an attribute.
1265       */
1266     public void visitAttribute(final Attribute attribute) {
1267         stringBuilder.setLength(0);
1268         stringBuilder.append(&quot;// ATTRIBUTE &quot;).append(attribute.type).append(&#39;\n&#39;);
1269         if (attribute instanceof ASMifierSupport) {
1270             if (labelNames == null) {
1271                 labelNames = new HashMap&lt;&gt;();
1272             }
1273             stringBuilder.append(&quot;{\n&quot;);
1274             ((ASMifierSupport) attribute).asmify(stringBuilder, &quot;attribute&quot;, labelNames);
1275             stringBuilder.append(name).append(&quot;.visitAttribute(attribute);\n&quot;);
1276             stringBuilder.append(&quot;}\n&quot;);
1277         }
1278         text.add(stringBuilder.toString());
1279     }
1280 
1281     // -----------------------------------------------------------------------------------------------
1282     // Utility methods
1283     // -----------------------------------------------------------------------------------------------
1284 
1285     /**
1286       * Constructs a new {@link ASMifier}.
1287       *
1288       * @param visitorVariableName the name of the visitor variable in the produced code.
1289       * @param annotationVisitorId identifier of the annotation visitor variable in the produced code.
1290       * @return a new {@link ASMifier}.
1291       */
1292     // DontCheck(AbbreviationAsWordInName): can&#39;t be renamed (for backward binary compatibility).
1293     protected ASMifier createASMifier(
1294             final String visitorVariableName, final int annotationVisitorId) {
1295         return new ASMifier(api, visitorVariableName, annotationVisitorId);
1296     }
1297 
1298     /**
1299       * Appends a string representation of the given access flags to {@link #stringBuilder}.
1300       *
1301       * @param accessFlags some access flags.
1302       */
1303     private void appendAccessFlags(final int accessFlags) {
1304         boolean isEmpty = true;
1305         if ((accessFlags &amp; Opcodes.ACC_PUBLIC) != 0) {
1306             stringBuilder.append(&quot;ACC_PUBLIC&quot;);
1307             isEmpty = false;
1308         }
1309         if ((accessFlags &amp; Opcodes.ACC_PRIVATE) != 0) {
1310             stringBuilder.append(&quot;ACC_PRIVATE&quot;);
1311             isEmpty = false;
1312         }
1313         if ((accessFlags &amp; Opcodes.ACC_PROTECTED) != 0) {
1314             stringBuilder.append(&quot;ACC_PROTECTED&quot;);
1315             isEmpty = false;
1316         }
1317         if ((accessFlags &amp; Opcodes.ACC_FINAL) != 0) {
1318             if (!isEmpty) {
1319                 stringBuilder.append(&quot; | &quot;);
1320             }
1321             if ((accessFlags &amp; ACCESS_MODULE) == 0) {
1322                 stringBuilder.append(&quot;ACC_FINAL&quot;);
1323             } else {
1324                 stringBuilder.append(&quot;ACC_TRANSITIVE&quot;);
1325             }
1326             isEmpty = false;
1327         }
1328         if ((accessFlags &amp; Opcodes.ACC_STATIC) != 0) {
1329             if (!isEmpty) {
1330                 stringBuilder.append(&quot; | &quot;);
1331             }
1332             stringBuilder.append(&quot;ACC_STATIC&quot;);
1333             isEmpty = false;
1334         }
1335         if ((accessFlags &amp; (Opcodes.ACC_SYNCHRONIZED | Opcodes.ACC_SUPER | Opcodes.ACC_TRANSITIVE))
1336                 != 0) {
1337             if (!isEmpty) {
1338                 stringBuilder.append(&quot; | &quot;);
1339             }
1340             if ((accessFlags &amp; ACCESS_CLASS) == 0) {
1341                 if ((accessFlags &amp; ACCESS_MODULE) == 0) {
1342                     stringBuilder.append(&quot;ACC_SYNCHRONIZED&quot;);
1343                 } else {
1344                     stringBuilder.append(&quot;ACC_TRANSITIVE&quot;);
1345                 }
1346             } else {
1347                 stringBuilder.append(&quot;ACC_SUPER&quot;);
1348             }
1349             isEmpty = false;
1350         }
1351         if ((accessFlags &amp; (Opcodes.ACC_VOLATILE | Opcodes.ACC_BRIDGE | Opcodes.ACC_STATIC_PHASE))
1352                 != 0) {
1353             if (!isEmpty) {
1354                 stringBuilder.append(&quot; | &quot;);
1355             }
1356             if ((accessFlags &amp; ACCESS_FIELD) == 0) {
1357                 if ((accessFlags &amp; ACCESS_MODULE) == 0) {
1358                     stringBuilder.append(&quot;ACC_BRIDGE&quot;);
1359                 } else {
1360                     stringBuilder.append(&quot;ACC_STATIC_PHASE&quot;);
1361                 }
1362             } else {
1363                 stringBuilder.append(&quot;ACC_VOLATILE&quot;);
1364             }
1365             isEmpty = false;
1366         }
1367         if ((accessFlags &amp; Opcodes.ACC_VARARGS) != 0
1368                 &amp;&amp; (accessFlags &amp; (ACCESS_CLASS | ACCESS_FIELD)) == 0) {
1369             if (!isEmpty) {
1370                 stringBuilder.append(&quot; | &quot;);
1371             }
1372             stringBuilder.append(&quot;ACC_VARARGS&quot;);
1373             isEmpty = false;
1374         }
1375         if ((accessFlags &amp; Opcodes.ACC_TRANSIENT) != 0 &amp;&amp; (accessFlags &amp; ACCESS_FIELD) != 0) {
1376             if (!isEmpty) {
1377                 stringBuilder.append(&quot; | &quot;);
1378             }
1379             stringBuilder.append(&quot;ACC_TRANSIENT&quot;);
1380             isEmpty = false;
1381         }
1382         if ((accessFlags &amp; Opcodes.ACC_NATIVE) != 0
1383                 &amp;&amp; (accessFlags &amp; (ACCESS_CLASS | ACCESS_FIELD)) == 0) {
1384             if (!isEmpty) {
1385                 stringBuilder.append(&quot; | &quot;);
1386             }
1387             stringBuilder.append(&quot;ACC_NATIVE&quot;);
1388             isEmpty = false;
1389         }
1390         if ((accessFlags &amp; Opcodes.ACC_ENUM) != 0
1391                 &amp;&amp; (accessFlags &amp; (ACCESS_CLASS | ACCESS_FIELD | ACCESS_INNER)) != 0) {
1392             if (!isEmpty) {
1393                 stringBuilder.append(&quot; | &quot;);
1394             }
1395             stringBuilder.append(&quot;ACC_ENUM&quot;);
1396             isEmpty = false;
1397         }
1398         if ((accessFlags &amp; Opcodes.ACC_ANNOTATION) != 0
1399                 &amp;&amp; (accessFlags &amp; (ACCESS_CLASS | ACCESS_INNER)) != 0) {
1400             if (!isEmpty) {
1401                 stringBuilder.append(&quot; | &quot;);
1402             }
1403             stringBuilder.append(&quot;ACC_ANNOTATION&quot;);
1404             isEmpty = false;
1405         }
1406         if ((accessFlags &amp; Opcodes.ACC_ABSTRACT) != 0) {
1407             if (!isEmpty) {
1408                 stringBuilder.append(&quot; | &quot;);
1409             }
1410             stringBuilder.append(&quot;ACC_ABSTRACT&quot;);
1411             isEmpty = false;
1412         }
1413         if ((accessFlags &amp; Opcodes.ACC_INTERFACE) != 0) {
1414             if (!isEmpty) {
1415                 stringBuilder.append(&quot; | &quot;);
1416             }
1417             stringBuilder.append(&quot;ACC_INTERFACE&quot;);
1418             isEmpty = false;
1419         }
1420         if ((accessFlags &amp; Opcodes.ACC_STRICT) != 0) {
1421             if (!isEmpty) {
1422                 stringBuilder.append(&quot; | &quot;);
1423             }
1424             stringBuilder.append(&quot;ACC_STRICT&quot;);
1425             isEmpty = false;
1426         }
1427         if ((accessFlags &amp; Opcodes.ACC_SYNTHETIC) != 0) {
1428             if (!isEmpty) {
1429                 stringBuilder.append(&quot; | &quot;);
1430             }
1431             stringBuilder.append(&quot;ACC_SYNTHETIC&quot;);
1432             isEmpty = false;
1433         }
1434         if ((accessFlags &amp; Opcodes.ACC_DEPRECATED) != 0) {
1435             if (!isEmpty) {
1436                 stringBuilder.append(&quot; | &quot;);
1437             }
1438             stringBuilder.append(&quot;ACC_DEPRECATED&quot;);
1439             isEmpty = false;
1440         }
1441         if ((accessFlags &amp; Opcodes.ACC_RECORD) != 0) {
1442             if (!isEmpty) {
1443                 stringBuilder.append(&quot; | &quot;);
1444             }
1445             stringBuilder.append(&quot;ACC_RECORD&quot;);
1446             isEmpty = false;
1447         }
1448         if ((accessFlags &amp; (Opcodes.ACC_MANDATED | Opcodes.ACC_MODULE)) != 0) {
1449             if (!isEmpty) {
1450                 stringBuilder.append(&quot; | &quot;);
1451             }
1452             if ((accessFlags &amp; ACCESS_CLASS) == 0) {
1453                 stringBuilder.append(&quot;ACC_MANDATED&quot;);
1454             } else {
1455                 stringBuilder.append(&quot;ACC_MODULE&quot;);
1456             }
1457             isEmpty = false;
1458         }
1459         if (isEmpty) {
1460             stringBuilder.append(&#39;0&#39;);
1461         }
1462     }
1463 
1464     /**
1465       * Appends a string representation of the given constant to {@link #stringBuilder}.
1466       *
1467       * @param value a {@link String}, {@link Type}, {@link Handle}, {@link Byte}, {@link Short},
1468       *     {@link Character}, {@link Integer}, {@link Float}, {@link Long} or {@link Double} object,
1469       *     or an array of primitive values. May be {@literal null}.
1470       */
1471     protected void appendConstant(final Object value) {
1472         if (value == null) {
1473             stringBuilder.append(&quot;null&quot;);
1474         } else if (value instanceof String) {
1475             appendString(stringBuilder, (String) value);
1476         } else if (value instanceof Type) {
1477             stringBuilder.append(&quot;Type.getType(\&quot;&quot;);
1478             stringBuilder.append(((Type) value).getDescriptor());
1479             stringBuilder.append(&quot;\&quot;)&quot;);
1480         } else if (value instanceof Handle) {
1481             stringBuilder.append(&quot;new Handle(&quot;);
1482             Handle handle = (Handle) value;
1483             stringBuilder.append(&quot;Opcodes.&quot;).append(HANDLE_TAG[handle.getTag()]).append(&quot;, \&quot;&quot;);
1484             stringBuilder.append(handle.getOwner()).append(COMMA);
1485             stringBuilder.append(handle.getName()).append(COMMA);
1486             stringBuilder.append(handle.getDesc()).append(&quot;\&quot;, &quot;);
1487             stringBuilder.append(handle.isInterface()).append(&quot;)&quot;);
1488         } else if (value instanceof ConstantDynamic) {
1489             stringBuilder.append(&quot;new ConstantDynamic(\&quot;&quot;);
1490             ConstantDynamic constantDynamic = (ConstantDynamic) value;
1491             stringBuilder.append(constantDynamic.getName()).append(COMMA);
1492             stringBuilder.append(constantDynamic.getDescriptor()).append(&quot;\&quot;, &quot;);
1493             appendConstant(constantDynamic.getBootstrapMethod());
1494             stringBuilder.append(NEW_OBJECT_ARRAY);
1495             int bootstrapMethodArgumentCount = constantDynamic.getBootstrapMethodArgumentCount();
1496             for (int i = 0; i &lt; bootstrapMethodArgumentCount; ++i) {
1497                 appendConstant(constantDynamic.getBootstrapMethodArgument(i));
1498                 if (i != bootstrapMethodArgumentCount - 1) {
1499                     stringBuilder.append(&quot;, &quot;);
1500                 }
1501             }
1502             stringBuilder.append(&quot;})&quot;);
1503         } else if (value instanceof Byte) {
1504             stringBuilder.append(&quot;new Byte((byte)&quot;).append(value).append(&#39;)&#39;);
1505         } else if (value instanceof Boolean) {
1506             stringBuilder.append(((Boolean) value).booleanValue() ? &quot;Boolean.TRUE&quot; : &quot;Boolean.FALSE&quot;);
1507         } else if (value instanceof Short) {
1508             stringBuilder.append(&quot;new Short((short)&quot;).append(value).append(&#39;)&#39;);
1509         } else if (value instanceof Character) {
1510             stringBuilder
1511                     .append(&quot;new Character((char)&quot;)
1512                     .append((int) ((Character) value).charValue())
1513                     .append(&#39;)&#39;);
1514         } else if (value instanceof Integer) {
1515             stringBuilder.append(&quot;new Integer(&quot;).append(value).append(&#39;)&#39;);
1516         } else if (value instanceof Float) {
1517             stringBuilder.append(&quot;new Float(\&quot;&quot;).append(value).append(&quot;\&quot;)&quot;);
1518         } else if (value instanceof Long) {
1519             stringBuilder.append(&quot;new Long(&quot;).append(value).append(&quot;L)&quot;);
1520         } else if (value instanceof Double) {
1521             stringBuilder.append(&quot;new Double(\&quot;&quot;).append(value).append(&quot;\&quot;)&quot;);
1522         } else if (value instanceof byte[]) {
1523             byte[] byteArray = (byte[]) value;
1524             stringBuilder.append(&quot;new byte[] {&quot;);
1525             for (int i = 0; i &lt; byteArray.length; i++) {
1526                 stringBuilder.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(byteArray[i]);
1527             }
1528             stringBuilder.append(&#39;}&#39;);
1529         } else if (value instanceof boolean[]) {
1530             boolean[] booleanArray = (boolean[]) value;
1531             stringBuilder.append(&quot;new boolean[] {&quot;);
1532             for (int i = 0; i &lt; booleanArray.length; i++) {
1533                 stringBuilder.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(booleanArray[i]);
1534             }
1535             stringBuilder.append(&#39;}&#39;);
1536         } else if (value instanceof short[]) {
1537             short[] shortArray = (short[]) value;
1538             stringBuilder.append(&quot;new short[] {&quot;);
1539             for (int i = 0; i &lt; shortArray.length; i++) {
1540                 stringBuilder.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(&quot;(short)&quot;).append(shortArray[i]);
1541             }
1542             stringBuilder.append(&#39;}&#39;);
1543         } else if (value instanceof char[]) {
1544             char[] charArray = (char[]) value;
1545             stringBuilder.append(&quot;new char[] {&quot;);
1546             for (int i = 0; i &lt; charArray.length; i++) {
1547                 stringBuilder.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(&quot;(char)&quot;).append((int) charArray[i]);
1548             }
1549             stringBuilder.append(&#39;}&#39;);
1550         } else if (value instanceof int[]) {
1551             int[] intArray = (int[]) value;
1552             stringBuilder.append(&quot;new int[] {&quot;);
1553             for (int i = 0; i &lt; intArray.length; i++) {
1554                 stringBuilder.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(intArray[i]);
1555             }
1556             stringBuilder.append(&#39;}&#39;);
1557         } else if (value instanceof long[]) {
1558             long[] longArray = (long[]) value;
1559             stringBuilder.append(&quot;new long[] {&quot;);
1560             for (int i = 0; i &lt; longArray.length; i++) {
1561                 stringBuilder.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(longArray[i]).append(&#39;L&#39;);
1562             }
1563             stringBuilder.append(&#39;}&#39;);
1564         } else if (value instanceof float[]) {
1565             float[] floatArray = (float[]) value;
1566             stringBuilder.append(&quot;new float[] {&quot;);
1567             for (int i = 0; i &lt; floatArray.length; i++) {
1568                 stringBuilder.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(floatArray[i]).append(&#39;f&#39;);
1569             }
1570             stringBuilder.append(&#39;}&#39;);
1571         } else if (value instanceof double[]) {
1572             double[] doubleArray = (double[]) value;
1573             stringBuilder.append(&quot;new double[] {&quot;);
1574             for (int i = 0; i &lt; doubleArray.length; i++) {
1575                 stringBuilder.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(doubleArray[i]).append(&#39;d&#39;);
1576             }
1577             stringBuilder.append(&#39;}&#39;);
1578         }
1579     }
1580 
1581     /**
1582       * Calls {@link #declareLabel} for each label in the given stack map frame types.
1583       *
1584       * @param numTypes the number of stack map frame types in &#39;frameTypes&#39;.
1585       * @param frameTypes an array of stack map frame types, in the format described in {@link
1586       *     jdk.internal.org.objectweb.asm.MethodVisitor#visitFrame}.
1587       */
1588     private void declareFrameTypes(final int numTypes, final Object[] frameTypes) {
1589         for (int i = 0; i &lt; numTypes; ++i) {
1590             if (frameTypes[i] instanceof Label) {
1591                 declareLabel((Label) frameTypes[i]);
1592             }
1593         }
1594     }
1595 
1596     /**
1597       * Appends the given stack map frame types to {@link #stringBuilder}.
1598       *
1599       * @param numTypes the number of stack map frame types in &#39;frameTypes&#39;.
1600       * @param frameTypes an array of stack map frame types, in the format described in {@link
1601       *     jdk.internal.org.objectweb.asm.MethodVisitor#visitFrame}.
1602       */
1603     private void appendFrameTypes(final int numTypes, final Object[] frameTypes) {
1604         for (int i = 0; i &lt; numTypes; ++i) {
1605             if (i &gt; 0) {
1606                 stringBuilder.append(&quot;, &quot;);
1607             }
1608             if (frameTypes[i] instanceof String) {
1609                 appendConstant(frameTypes[i]);
1610             } else if (frameTypes[i] instanceof Integer) {
1611                 stringBuilder.append(FRAME_TYPES.get(((Integer) frameTypes[i]).intValue()));
1612             } else {
1613                 appendLabel((Label) frameTypes[i]);
1614             }
1615         }
1616     }
1617 
1618     /**
1619       * Appends a declaration of the given label to {@link #stringBuilder}. This declaration is of the
1620       * form &quot;Label labelXXX = new Label();&quot;. Does nothing if the given label has already been
1621       * declared.
1622       *
1623       * @param label a label.
1624       */
1625     protected void declareLabel(final Label label) {
1626         if (labelNames == null) {
1627             labelNames = new HashMap&lt;&gt;();
1628         }
1629         String labelName = labelNames.get(label);
1630         if (labelName == null) {
1631             labelName = &quot;label&quot; + labelNames.size();
1632             labelNames.put(label, labelName);
1633             stringBuilder.append(&quot;Label &quot;).append(labelName).append(&quot; = new Label();\n&quot;);
1634         }
1635     }
1636 
1637     /**
1638       * Appends the name of the given label to {@link #stringBuilder}. The given label &lt;i&gt;must&lt;/i&gt;
1639       * already have a name. One way to ensure this is to always call {@link #declareLabel} before
1640       * calling this method.
1641       *
1642       * @param label a label.
1643       */
1644     protected void appendLabel(final Label label) {
1645         stringBuilder.append(labelNames.get(label));
1646     }
1647 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
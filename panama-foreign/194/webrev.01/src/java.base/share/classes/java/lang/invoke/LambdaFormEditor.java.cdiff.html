<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InvokerBytecodeGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 59,48 ***</span>
          // Always use uncustomized version for editing.
          // It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
          return new LambdaFormEditor(lambdaForm.uncustomize());
      }
  
<span class="line-modified">!     /** A description of a cached transform, possibly associated with the result of the transform.</span>
<span class="line-modified">!      *  The logical content is a sequence of byte values, starting with a kind value.</span>
<span class="line-modified">!      *  The sequence is unterminated, ending with an indefinite number of zero bytes.</span>
<span class="line-modified">!      *  Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.</span>
       */
      private static final class Transform extends SoftReference&lt;LambdaForm&gt; {
          final long packedBytes;
          final byte[] fullBytes;
  
<span class="line-modified">!         // maybe add more for guard with test, catch exception, pointwise type conversions</span>
<span class="line-modified">!         private static final byte</span>
<span class="line-modified">!                 BIND_ARG = 1,</span>
<span class="line-modified">!                 ADD_ARG = 2,</span>
<span class="line-modified">!                 DUP_ARG = 3,</span>
<span class="line-modified">!                 SPREAD_ARGS = 4,</span>
<span class="line-modified">!                 FILTER_ARG = 5,</span>
<span class="line-modified">!                 FILTER_RETURN = 6,</span>
<span class="line-modified">!                 FILTER_RETURN_TO_ZERO = 7,</span>
<span class="line-modified">!                 COLLECT_ARGS = 8,</span>
<span class="line-modified">!                 COLLECT_ARGS_TO_VOID = 9,</span>
<span class="line-modified">!                 COLLECT_ARGS_TO_ARRAY = 10,</span>
<span class="line-modified">!                 FOLD_ARGS = 11,</span>
<span class="line-modified">!                 FOLD_ARGS_TO_VOID = 12,</span>
<span class="line-modified">!                 PERMUTE_ARGS = 13,</span>
<span class="line-modified">!                 LOCAL_TYPES = 14,</span>
<span class="line-modified">!                 FOLD_SELECT_ARGS = 15,</span>
<span class="line-modified">!                 FOLD_SELECT_ARGS_TO_VOID = 16,</span>
<span class="line-modified">!                 FILTER_SELECT_ARGS = 17,</span>
<span class="line-modified">!                 REPEAT_FILTER_ARGS = 18;</span>
  
          private static final boolean STRESS_TEST = false; // turn on to disable most packing
          private static final int
                  PACKED_BYTE_SIZE = (STRESS_TEST ? 2 : 4),
                  PACKED_BYTE_MASK = (1 &lt;&lt; PACKED_BYTE_SIZE) - 1,
                  PACKED_BYTE_MAX_LENGTH = (STRESS_TEST ? 3 : 64 / PACKED_BYTE_SIZE);
  
          private static long packedBytes(byte[] bytes) {
<span class="line-modified">!             if (bytes.length &gt; PACKED_BYTE_MAX_LENGTH)  return 0;</span>
              long pb = 0;
              int bitset = 0;
              for (int i = 0; i &lt; bytes.length; i++) {
                  int b = bytes[i] &amp; 0xFF;
                  bitset |= b;
<span class="line-new-header">--- 59,182 ---</span>
          // Always use uncustomized version for editing.
          // It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
          return new LambdaFormEditor(lambdaForm.uncustomize());
      }
  
<span class="line-modified">!     // Transform types</span>
<span class="line-modified">!     // maybe add more for guard with test, catch exception, pointwise type conversions</span>
<span class="line-modified">!     private static final byte</span>
<span class="line-modified">!             BIND_ARG = 1,</span>
<span class="line-added">+             ADD_ARG = 2,</span>
<span class="line-added">+             DUP_ARG = 3,</span>
<span class="line-added">+             SPREAD_ARGS = 4,</span>
<span class="line-added">+             FILTER_ARG = 5,</span>
<span class="line-added">+             FILTER_RETURN = 6,</span>
<span class="line-added">+             FILTER_RETURN_TO_ZERO = 7,</span>
<span class="line-added">+             COLLECT_ARGS = 8,</span>
<span class="line-added">+             COLLECT_ARGS_TO_VOID = 9,</span>
<span class="line-added">+             COLLECT_ARGS_TO_ARRAY = 10,</span>
<span class="line-added">+             FOLD_ARGS = 11,</span>
<span class="line-added">+             FOLD_ARGS_TO_VOID = 12,</span>
<span class="line-added">+             PERMUTE_ARGS = 13,</span>
<span class="line-added">+             LOCAL_TYPES = 14,</span>
<span class="line-added">+             FOLD_SELECT_ARGS = 15,</span>
<span class="line-added">+             FOLD_SELECT_ARGS_TO_VOID = 16,</span>
<span class="line-added">+             FILTER_SELECT_ARGS = 17,</span>
<span class="line-added">+             REPEAT_FILTER_ARGS = 18;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * A description of a cached transform, possibly associated with the result of the transform.</span>
<span class="line-added">+      * The logical content is a sequence of byte values, starting with a kind value.</span>
<span class="line-added">+      * The sequence is unterminated, ending with an indefinite number of zero bytes.</span>
<span class="line-added">+      * Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Tightly coupled with the TransformKey class, which is used to lookup existing</span>
<span class="line-added">+      * Transforms.</span>
       */
      private static final class Transform extends SoftReference&lt;LambdaForm&gt; {
          final long packedBytes;
          final byte[] fullBytes;
  
<span class="line-modified">!         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {</span>
<span class="line-modified">!             super(result);</span>
<span class="line-modified">!             this.packedBytes = packedBytes;</span>
<span class="line-modified">!             this.fullBytes = fullBytes;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public boolean equals(Object obj) {</span>
<span class="line-modified">!             if (obj instanceof TransformKey) {</span>
<span class="line-modified">!                 return equals((TransformKey) obj);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private boolean equals(TransformKey that) {</span>
<span class="line-modified">!             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private boolean equals(Transform that) {</span>
<span class="line-modified">!             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public int hashCode() {</span>
<span class="line-added">+             if (packedBytes != 0) {</span>
<span class="line-added">+                 assert(fullBytes == null);</span>
<span class="line-added">+                 return Long.hashCode(packedBytes);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return Arrays.hashCode(fullBytes);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public String toString() {</span>
<span class="line-added">+             StringBuilder buf = new StringBuilder();</span>
<span class="line-added">+             buf.append(new TransformKey(packedBytes, fullBytes).toString());</span>
<span class="line-added">+             LambdaForm result = get();</span>
<span class="line-added">+             if (result != null) {</span>
<span class="line-added">+                 buf.append(&quot; result=&quot;);</span>
<span class="line-added">+                 buf.append(result);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return buf.toString();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Used as a lookup key to find existing Transforms</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static final class TransformKey {</span>
<span class="line-added">+         final long packedBytes;</span>
<span class="line-added">+         final byte[] fullBytes;</span>
<span class="line-added">+ </span>
<span class="line-added">+         private TransformKey(long packedBytes) {</span>
<span class="line-added">+             this.packedBytes = packedBytes;</span>
<span class="line-added">+             this.fullBytes = null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private TransformKey(byte[] fullBytes) {</span>
<span class="line-added">+             this.fullBytes = fullBytes;</span>
<span class="line-added">+             this.packedBytes = 0;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private TransformKey(long packedBytes, byte[] fullBytes) {</span>
<span class="line-added">+             this.fullBytes = fullBytes;</span>
<span class="line-added">+             this.packedBytes = packedBytes;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private static byte bval(int b) {</span>
<span class="line-added">+             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte</span>
<span class="line-added">+             return (byte)b;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         static TransformKey of(byte k, int b1) {</span>
<span class="line-added">+             byte b0 = bval(k);</span>
<span class="line-added">+             if (inRange(b0 | b1))</span>
<span class="line-added">+                 return new TransformKey(packedBytes(b0, b1));</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 return new TransformKey(fullBytes(b0, b1));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         static TransformKey of(byte b0, int b1, int b2) {</span>
<span class="line-added">+             if (inRange(b0 | b1 | b2))</span>
<span class="line-added">+                 return new TransformKey(packedBytes(b0, b1, b2));</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 return new TransformKey(fullBytes(b0, b1, b2));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         static TransformKey of(byte b0, int b1, int b2, int b3) {</span>
<span class="line-added">+             if (inRange(b0 | b1 | b2 | b3))</span>
<span class="line-added">+                 return new TransformKey(packedBytes(b0, b1, b2, b3));</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 return new TransformKey(fullBytes(b0, b1, b2, b3));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         private static final byte[] NO_BYTES = {};</span>
<span class="line-added">+         static TransformKey of(byte kind, int... b123) {</span>
<span class="line-added">+             return ofBothArrays(kind, b123, NO_BYTES);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         static TransformKey of(byte kind, int b1, int[] b23456) {</span>
<span class="line-added">+             byte[] fullBytes = new byte[b23456.length + 2];</span>
<span class="line-added">+             fullBytes[0] = kind;</span>
<span class="line-added">+             fullBytes[1] = bval(b1);</span>
<span class="line-added">+             for (int i = 0; i &lt; b23456.length; i++) {</span>
<span class="line-added">+                 fullBytes[i + 2] = TransformKey.bval(b23456[i]);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             long packedBytes = packedBytes(fullBytes);</span>
<span class="line-added">+             if (packedBytes != 0)</span>
<span class="line-added">+                 return new TransformKey(packedBytes);</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 return new TransformKey(fullBytes);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         static TransformKey of(byte kind, int b1, int b2, byte[] b345) {</span>
<span class="line-added">+             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         private static TransformKey ofBothArrays(byte kind, int[] b123, byte[] b456) {</span>
<span class="line-added">+             byte[] fullBytes = new byte[1 + b123.length + b456.length];</span>
<span class="line-added">+             int i = 0;</span>
<span class="line-added">+             fullBytes[i++] = bval(kind);</span>
<span class="line-added">+             for (int bv : b123) {</span>
<span class="line-added">+                 fullBytes[i++] = bval(bv);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             for (byte bv : b456) {</span>
<span class="line-added">+                 fullBytes[i++] = bv;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             long packedBytes = packedBytes(fullBytes);</span>
<span class="line-added">+             if (packedBytes != 0)</span>
<span class="line-added">+                 return new TransformKey(packedBytes);</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 return new TransformKey(fullBytes);</span>
<span class="line-added">+         }</span>
  
          private static final boolean STRESS_TEST = false; // turn on to disable most packing
          private static final int
                  PACKED_BYTE_SIZE = (STRESS_TEST ? 2 : 4),
                  PACKED_BYTE_MASK = (1 &lt;&lt; PACKED_BYTE_SIZE) - 1,
                  PACKED_BYTE_MAX_LENGTH = (STRESS_TEST ? 3 : 64 / PACKED_BYTE_SIZE);
  
          private static long packedBytes(byte[] bytes) {
<span class="line-modified">!             if (!inRange(bytes[0]) || bytes.length &gt; PACKED_BYTE_MAX_LENGTH)</span>
<span class="line-added">+                 return 0;</span>
              long pb = 0;
              int bitset = 0;
              for (int i = 0; i &lt; bytes.length; i++) {
                  int b = bytes[i] &amp; 0xFF;
                  bitset |= b;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,92 ***</span>
              }
              assert(packedBytes(bytes) == 0);
              return bytes;
          }
  
<span class="line-removed">-         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {</span>
<span class="line-removed">-             super(result);</span>
<span class="line-removed">-             this.packedBytes = packedBytes;</span>
<span class="line-removed">-             this.fullBytes = fullBytes;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         private Transform(long packedBytes) {</span>
<span class="line-removed">-             this(packedBytes, null, null);</span>
<span class="line-removed">-             assert(packedBytes != 0);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         private Transform(byte[] fullBytes) {</span>
<span class="line-removed">-             this(0, fullBytes, null);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static byte bval(int b) {</span>
<span class="line-removed">-             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte</span>
<span class="line-removed">-             return (byte)b;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         static Transform of(byte k, int b1) {</span>
<span class="line-removed">-             byte b0 = bval(k);</span>
<span class="line-removed">-             if (inRange(b0 | b1))</span>
<span class="line-removed">-                 return new Transform(packedBytes(b0, b1));</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-                 return new Transform(fullBytes(b0, b1));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         static Transform of(byte b0, int b1, int b2) {</span>
<span class="line-removed">-             if (inRange(b0 | b1 | b2))</span>
<span class="line-removed">-                 return new Transform(packedBytes(b0, b1, b2));</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-                 return new Transform(fullBytes(b0, b1, b2));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         static Transform of(byte b0, int b1, int b2, int b3) {</span>
<span class="line-removed">-             if (inRange(b0 | b1 | b2 | b3))</span>
<span class="line-removed">-                 return new Transform(packedBytes(b0, b1, b2, b3));</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-                 return new Transform(fullBytes(b0, b1, b2, b3));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         private static final byte[] NO_BYTES = {};</span>
<span class="line-removed">-         static Transform of(byte kind, int... b123) {</span>
<span class="line-removed">-             return ofBothArrays(kind, b123, NO_BYTES);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         static Transform of(byte kind, int b1, byte[] b234) {</span>
<span class="line-removed">-             return ofBothArrays(kind, new int[]{ b1 }, b234);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         static Transform of(byte kind, int b1, int b2, byte[] b345) {</span>
<span class="line-removed">-             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         private static Transform ofBothArrays(byte kind, int[] b123, byte[] b456) {</span>
<span class="line-removed">-             byte[] fullBytes = new byte[1 + b123.length + b456.length];</span>
<span class="line-removed">-             int i = 0;</span>
<span class="line-removed">-             fullBytes[i++] = bval(kind);</span>
<span class="line-removed">-             for (int bv : b123) {</span>
<span class="line-removed">-                 fullBytes[i++] = bval(bv);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             for (byte bv : b456) {</span>
<span class="line-removed">-                 fullBytes[i++] = bv;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             long packedBytes = packedBytes(fullBytes);</span>
<span class="line-removed">-             if (packedBytes != 0)</span>
<span class="line-removed">-                 return new Transform(packedBytes);</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-                 return new Transform(fullBytes);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          Transform withResult(LambdaForm result) {
              return new Transform(this.packedBytes, this.fullBytes, result);
          }
  
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public boolean equals(Object obj) {</span>
<span class="line-removed">-             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         public boolean equals(Transform that) {</span>
<span class="line-removed">-             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public int hashCode() {</span>
<span class="line-removed">-             if (packedBytes != 0) {</span>
<span class="line-removed">-                 assert(fullBytes == null);</span>
<span class="line-removed">-                 return Long.hashCode(packedBytes);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return Arrays.hashCode(fullBytes);</span>
<span class="line-removed">-         }</span>
          @Override
          public String toString() {
              StringBuilder buf = new StringBuilder();
              long bits = packedBytes;
              if (bits != 0) {
<span class="line-new-header">--- 274,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 239,22 ***</span>
              }
              if (fullBytes != null) {
                  buf.append(&quot;unpacked&quot;);
                  buf.append(Arrays.toString(fullBytes));
              }
<span class="line-removed">-             LambdaForm result = get();</span>
<span class="line-removed">-             if (result != null) {</span>
<span class="line-removed">-                 buf.append(&quot; result=&quot;);</span>
<span class="line-removed">-                 buf.append(result);</span>
<span class="line-removed">-             }</span>
              return buf.toString();
          }
      }
  
      /** Find a previously cached transform equivalent to the given one, and return its result. */
<span class="line-modified">!     private LambdaForm getInCache(Transform key) {</span>
<span class="line-removed">-         assert(key.get() == null);</span>
          // The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
          Object c = lambdaForm.transformCache;
          Transform k = null;
          if (c instanceof ConcurrentHashMap) {
              @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-new-header">--- 295,41 ---</span>
              }
              if (fullBytes != null) {
                  buf.append(&quot;unpacked&quot;);
                  buf.append(Arrays.toString(fullBytes));
              }
              return buf.toString();
          }
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public boolean equals(Object obj) {</span>
<span class="line-added">+             if (obj instanceof TransformKey) {</span>
<span class="line-added">+                 return equals((TransformKey) obj);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private boolean equals(TransformKey that) {</span>
<span class="line-added">+             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private boolean equals(Transform that) {</span>
<span class="line-added">+             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public int hashCode() {</span>
<span class="line-added">+             if (packedBytes != 0) {</span>
<span class="line-added">+                 assert(fullBytes == null);</span>
<span class="line-added">+                 return Long.hashCode(packedBytes);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return Arrays.hashCode(fullBytes);</span>
<span class="line-added">+         }</span>
      }
  
      /** Find a previously cached transform equivalent to the given one, and return its result. */
<span class="line-modified">!     private LambdaForm getInCache(TransformKey key) {</span>
          // The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
          Object c = lambdaForm.transformCache;
          Transform k = null;
          if (c instanceof ConcurrentHashMap) {
              @SuppressWarnings(&quot;unchecked&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 282,24 ***</span>
      private static final int MIN_CACHE_ARRAY_SIZE = 4, MAX_CACHE_ARRAY_SIZE = 16;
  
      /** Cache a transform with its result, and return that result.
       *  But if an equivalent transform has already been cached, return its result instead.
       */
<span class="line-modified">!     private LambdaForm putInCache(Transform key, LambdaForm form) {</span>
<span class="line-modified">!         key = key.withResult(form);</span>
          for (int pass = 0; ; pass++) {
              Object c = lambdaForm.transformCache;
              if (c instanceof ConcurrentHashMap) {
                  @SuppressWarnings(&quot;unchecked&quot;)
                  ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
<span class="line-modified">!                 Transform k = m.putIfAbsent(key, key);</span>
                  if (k == null) return form;
                  LambdaForm result = k.get();
                  if (result != null) {
                      return result;
                  } else {
<span class="line-modified">!                     if (m.replace(key, k, key)) {</span>
                          return form;
                      } else {
                          continue;
                      }
                  }
<span class="line-new-header">--- 357,24 ---</span>
      private static final int MIN_CACHE_ARRAY_SIZE = 4, MAX_CACHE_ARRAY_SIZE = 16;
  
      /** Cache a transform with its result, and return that result.
       *  But if an equivalent transform has already been cached, return its result instead.
       */
<span class="line-modified">!     private LambdaForm putInCache(TransformKey key, LambdaForm form) {</span>
<span class="line-modified">!         Transform transform = key.withResult(form);</span>
          for (int pass = 0; ; pass++) {
              Object c = lambdaForm.transformCache;
              if (c instanceof ConcurrentHashMap) {
                  @SuppressWarnings(&quot;unchecked&quot;)
                  ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
<span class="line-modified">!                 Transform k = m.putIfAbsent(transform, transform);</span>
                  if (k == null) return form;
                  LambdaForm result = k.get();
                  if (result != null) {
                      return result;
                  } else {
<span class="line-modified">!                     if (m.replace(transform, k, transform)) {</span>
                          return form;
                      } else {
                          continue;
                      }
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,26 ***</span>
              synchronized (lambdaForm) {
                  c = lambdaForm.transformCache;
                  if (c instanceof ConcurrentHashMap)
                      continue;
                  if (c == null) {
<span class="line-modified">!                     lambdaForm.transformCache = key;</span>
                      return form;
                  }
                  Transform[] ta;
                  if (c instanceof Transform) {
                      Transform k = (Transform)c;
                      if (k.equals(key)) {
                          LambdaForm result = k.get();
                          if (result == null) {
<span class="line-modified">!                             lambdaForm.transformCache = key;</span>
                              return form;
                          } else {
                              return result;
                          }
                      } else if (k.get() == null) { // overwrite stale entry
<span class="line-modified">!                         lambdaForm.transformCache = key;</span>
                          return form;
                      }
                      // expand one-element cache to small array
                      ta = new Transform[MIN_CACHE_ARRAY_SIZE];
                      ta[0] = k;
<span class="line-new-header">--- 383,26 ---</span>
              synchronized (lambdaForm) {
                  c = lambdaForm.transformCache;
                  if (c instanceof ConcurrentHashMap)
                      continue;
                  if (c == null) {
<span class="line-modified">!                     lambdaForm.transformCache = transform;</span>
                      return form;
                  }
                  Transform[] ta;
                  if (c instanceof Transform) {
                      Transform k = (Transform)c;
                      if (k.equals(key)) {
                          LambdaForm result = k.get();
                          if (result == null) {
<span class="line-modified">!                             lambdaForm.transformCache = transform;</span>
                              return form;
                          } else {
                              return result;
                          }
                      } else if (k.get() == null) { // overwrite stale entry
<span class="line-modified">!                         lambdaForm.transformCache = transform;</span>
                          return form;
                      }
                      // expand one-element cache to small array
                      ta = new Transform[MIN_CACHE_ARRAY_SIZE];
                      ta[0] = k;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 342,14 ***</span>
                  for (i = 0; i &lt; len; i++) {
                      Transform k = ta[i];
                      if (k == null) {
                          break;
                      }
<span class="line-modified">!                     if (k.equals(key)) {</span>
                          LambdaForm result = k.get();
                          if (result == null) {
<span class="line-modified">!                             ta[i] = key;</span>
                              return form;
                          } else {
                              return result;
                          }
                      } else if (stale &lt; 0 &amp;&amp; k.get() == null) {
<span class="line-new-header">--- 417,14 ---</span>
                  for (i = 0; i &lt; len; i++) {
                      Transform k = ta[i];
                      if (k == null) {
                          break;
                      }
<span class="line-modified">!                     if (k.equals(transform)) {</span>
                          LambdaForm result = k.get();
                          if (result == null) {
<span class="line-modified">!                             ta[i] = transform;</span>
                              return form;
                          } else {
                              return result;
                          }
                      } else if (stale &lt; 0 &amp;&amp; k.get() == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,11 ***</span>
                      lambdaForm.transformCache = m;
                      // The second iteration will update for this query, concurrently.
                      continue;
                  }
                  int idx = (stale &gt;= 0) ? stale : i;
<span class="line-modified">!                 ta[idx] = key;</span>
                  return form;
              }
          }
      }
  
<span class="line-new-header">--- 445,11 ---</span>
                      lambdaForm.transformCache = m;
                      // The second iteration will update for this query, concurrently.
                      continue;
                  }
                  int idx = (stale &gt;= 0) ? stale : i;
<span class="line-modified">!                 ta[idx] = transform;</span>
                  return form;
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 440,11 ***</span>
  
      /// Editing methods for lambda forms.
      // Each editing method can (potentially) cache the edited LF so that it can be reused later.
  
      LambdaForm bindArgumentForm(int pos) {
<span class="line-modified">!         Transform key = Transform.of(Transform.BIND_ARG, pos);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.parameterConstraint(0) == newSpeciesData(lambdaForm.parameterType(pos)));
              return form;
          }
<span class="line-new-header">--- 515,11 ---</span>
  
      /// Editing methods for lambda forms.
      // Each editing method can (potentially) cache the edited LF so that it can be reused later.
  
      LambdaForm bindArgumentForm(int pos) {
<span class="line-modified">!         TransformKey key = TransformKey.of(BIND_ARG, pos);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.parameterConstraint(0) == newSpeciesData(lambdaForm.parameterType(pos)));
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 475,11 ***</span>
          form = buf.endEdit();
          return putInCache(key, form);
      }
  
      LambdaForm addArgumentForm(int pos, BasicType type) {
<span class="line-modified">!         Transform key = Transform.of(Transform.ADD_ARG, pos, type.ordinal());</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity+1);
              assert(form.parameterType(pos) == type);
              return form;
<span class="line-new-header">--- 550,11 ---</span>
          form = buf.endEdit();
          return putInCache(key, form);
      }
  
      LambdaForm addArgumentForm(int pos, BasicType type) {
<span class="line-modified">!         TransformKey key = TransformKey.of(ADD_ARG, pos, type.ordinal());</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity+1);
              assert(form.parameterType(pos) == type);
              return form;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 492,11 ***</span>
          form = buf.endEdit();
          return putInCache(key, form);
      }
  
      LambdaForm dupArgumentForm(int srcPos, int dstPos) {
<span class="line-modified">!         Transform key = Transform.of(Transform.DUP_ARG, srcPos, dstPos);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity-1);
              return form;
          }
<span class="line-new-header">--- 567,11 ---</span>
          form = buf.endEdit();
          return putInCache(key, form);
      }
  
      LambdaForm dupArgumentForm(int srcPos, int dstPos) {
<span class="line-modified">!         TransformKey key = TransformKey.of(DUP_ARG, srcPos, dstPos);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity-1);
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 521,11 ***</span>
          if (bt.basicTypeClass() != elementType) {
              if (elementType.isPrimitive()) {
                  elementTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
              }
          }
<span class="line-modified">!         Transform key = Transform.of(Transform.SPREAD_ARGS, pos, elementTypeKey, arrayLength);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity - arrayLength + 1);
              return form;
          }
<span class="line-new-header">--- 596,11 ---</span>
          if (bt.basicTypeClass() != elementType) {
              if (elementType.isPrimitive()) {
                  elementTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
              }
          }
<span class="line-modified">!         TransformKey key = TransformKey.of(SPREAD_ARGS, pos, elementTypeKey, arrayLength);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity - arrayLength + 1);
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 560,16 ***</span>
          int collectorArity = collectorType.parameterCount();
          boolean dropResult = (collectorType.returnType() == void.class);
          if (collectorArity == 1 &amp;&amp; !dropResult) {
              return filterArgumentForm(pos, basicType(collectorType.parameterType(0)));
          }
<span class="line-modified">!         byte[] newTypes = BasicType.basicTypesOrd(collectorType.parameterArray());</span>
<span class="line-modified">!         byte kind = (dropResult</span>
<span class="line-removed">-                 ? Transform.COLLECT_ARGS_TO_VOID</span>
<span class="line-removed">-                 : Transform.COLLECT_ARGS);</span>
          if (dropResult &amp;&amp; collectorArity == 0)  pos = 1;  // pure side effect
<span class="line-modified">!         Transform key = Transform.of(kind, pos, collectorArity, newTypes);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity - (dropResult ? 0 : 1) + collectorArity);
              return form;
          }
<span class="line-new-header">--- 635,14 ---</span>
          int collectorArity = collectorType.parameterCount();
          boolean dropResult = (collectorType.returnType() == void.class);
          if (collectorArity == 1 &amp;&amp; !dropResult) {
              return filterArgumentForm(pos, basicType(collectorType.parameterType(0)));
          }
<span class="line-modified">!         byte[] newTypes = BasicType.basicTypesOrd(collectorType.ptypes());</span>
<span class="line-modified">!         byte kind = (dropResult ? COLLECT_ARGS_TO_VOID : COLLECT_ARGS);</span>
          if (dropResult &amp;&amp; collectorArity == 0)  pos = 1;  // pure side effect
<span class="line-modified">!         TransformKey key = TransformKey.of(kind, pos, collectorArity, newTypes);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity - (dropResult ? 0 : 1) + collectorArity);
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,12 ***</span>
              if (!elementType.isPrimitive())
                  return null;
              argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
          }
          assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));
<span class="line-modified">!         byte kind = Transform.COLLECT_ARGS_TO_ARRAY;</span>
<span class="line-modified">!         Transform key = Transform.of(kind, pos, collectorArity, argTypeKey);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity - 1 + collectorArity);
              return form;
          }
<span class="line-new-header">--- 663,12 ---</span>
              if (!elementType.isPrimitive())
                  return null;
              argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
          }
          assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));
<span class="line-modified">!         byte kind = COLLECT_ARGS_TO_ARRAY;</span>
<span class="line-modified">!         TransformKey key = TransformKey.of(kind, pos, collectorArity, argTypeKey);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity - 1 + collectorArity);
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 627,11 ***</span>
          form = buf.endEdit();
          return putInCache(key, form);
      }
  
      LambdaForm filterArgumentForm(int pos, BasicType newType) {
<span class="line-modified">!         Transform key = Transform.of(Transform.FILTER_ARG, pos, newType.ordinal());</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity);
              assert(form.parameterType(pos) == newType);
              return form;
<span class="line-new-header">--- 700,11 ---</span>
          form = buf.endEdit();
          return putInCache(key, form);
      }
  
      LambdaForm filterArgumentForm(int pos, BasicType newType) {
<span class="line-modified">!         TransformKey key = TransformKey.of(FILTER_ARG, pos, newType.ordinal());</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity);
              assert(form.parameterType(pos) == newType);
              return form;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 651,17 ***</span>
       * by reapplying of {@code filterArgumentForm(int,BasicType)}, and should do
       * no worse in the worst case.
       */
      LambdaForm filterRepeatedArgumentForm(BasicType newType, int... argPositions) {
          assert (argPositions.length &gt; 1);
<span class="line-modified">!         byte[] keyArgs = new byte[argPositions.length + 2];</span>
<span class="line-removed">-         keyArgs[0] = Transform.REPEAT_FILTER_ARGS;</span>
<span class="line-removed">-         keyArgs[argPositions.length + 1] = (byte)newType.ordinal();</span>
<span class="line-removed">-         for (int i = 0; i &lt; argPositions.length; i++) {</span>
<span class="line-removed">-             keyArgs[i + 1] = (byte)argPositions[i];</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         Transform key = new Transform(keyArgs);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity &amp;&amp;
                      formParametersMatch(form, newType, argPositions));
              return form;
<span class="line-new-header">--- 724,11 ---</span>
       * by reapplying of {@code filterArgumentForm(int,BasicType)}, and should do
       * no worse in the worst case.
       */
      LambdaForm filterRepeatedArgumentForm(BasicType newType, int... argPositions) {
          assert (argPositions.length &gt; 1);
<span class="line-modified">!         TransformKey key = TransformKey.of(REPEAT_FILTER_ARGS, newType.ordinal(), argPositions);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity &amp;&amp;
                      formParametersMatch(form, newType, argPositions));
              return form;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 870,12 ***</span>
  
          return buf.endEdit();
      }
  
      LambdaForm filterReturnForm(BasicType newType, boolean constantZero) {
<span class="line-modified">!         byte kind = (constantZero ? Transform.FILTER_RETURN_TO_ZERO : Transform.FILTER_RETURN);</span>
<span class="line-modified">!         Transform key = Transform.of(kind, newType.ordinal());</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity);
              assert(form.returnType() == newType);
              return form;
<span class="line-new-header">--- 937,12 ---</span>
  
          return buf.endEdit();
      }
  
      LambdaForm filterReturnForm(BasicType newType, boolean constantZero) {
<span class="line-modified">!         byte kind = (constantZero ? FILTER_RETURN_TO_ZERO : FILTER_RETURN);</span>
<span class="line-modified">!         TransformKey key = TransformKey.of(kind, newType.ordinal());</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity);
              assert(form.returnType() == newType);
              return form;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 973,41 ***</span>
          return buf.endEdit();
      }
  
      LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
          int combinerArity = combinerType.parameterCount();
<span class="line-modified">!         byte kind = (dropResult ? Transform.FOLD_ARGS_TO_VOID : Transform.FOLD_ARGS);</span>
<span class="line-modified">!         Transform key = Transform.of(kind, foldPos, combinerArity);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
<span class="line-modified">!             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_ARGS ? 1 : 0));</span>
              return form;
          }
          form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
          return putInCache(key, form);
      }
  
      LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType, int ... argPositions) {
<span class="line-modified">!         byte kind = (dropResult ? Transform.FOLD_SELECT_ARGS_TO_VOID</span>
<span class="line-modified">!                                 : Transform.FOLD_SELECT_ARGS);</span>
<span class="line-removed">-         int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);</span>
<span class="line-removed">-         keyArgs[argPositions.length] = foldPos;</span>
<span class="line-removed">-         Transform key = Transform.of(kind, keyArgs);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
<span class="line-modified">!             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_SELECT_ARGS ? 1 : 0));</span>
              return form;
          }
          form = makeArgumentCombinationForm(foldPos, combinerType, argPositions, true, dropResult);
          return putInCache(key, form);
      }
  
      LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {
<span class="line-modified">!         byte kind = Transform.FILTER_SELECT_ARGS;</span>
<span class="line-removed">-         int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);</span>
<span class="line-removed">-         keyArgs[argPositions.length] = filterPos;</span>
<span class="line-removed">-         Transform key = Transform.of(kind, keyArgs);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity);
              return form;
          }
<span class="line-new-header">--- 1040,35 ---</span>
          return buf.endEdit();
      }
  
      LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
          int combinerArity = combinerType.parameterCount();
<span class="line-modified">!         byte kind = (dropResult ? FOLD_ARGS_TO_VOID : FOLD_ARGS);</span>
<span class="line-modified">!         TransformKey key = TransformKey.of(kind, foldPos, combinerArity);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
<span class="line-modified">!             assert(form.arity == lambdaForm.arity - (kind == FOLD_ARGS ? 1 : 0));</span>
              return form;
          }
          form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
          return putInCache(key, form);
      }
  
      LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType, int ... argPositions) {
<span class="line-modified">!         byte kind = (dropResult ? FOLD_SELECT_ARGS_TO_VOID : FOLD_SELECT_ARGS);</span>
<span class="line-modified">!         TransformKey key = TransformKey.of(kind, foldPos, argPositions);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
<span class="line-modified">!             assert(form.arity == lambdaForm.arity - (kind == FOLD_SELECT_ARGS ? 1 : 0));</span>
              return form;
          }
          form = makeArgumentCombinationForm(foldPos, combinerType, argPositions, true, dropResult);
          return putInCache(key, form);
      }
  
      LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {
<span class="line-modified">!         TransformKey key = TransformKey.of(FILTER_SELECT_ARGS, filterPos, argPositions);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity);
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1026,11 ***</span>
              if (inArg != i)  nullPerm = false;
              inTypes = Math.max(inTypes, inArg+1);
          }
          assert(skip + reorder.length == lambdaForm.arity);
          if (nullPerm)  return lambdaForm;  // do not bother to cache
<span class="line-modified">!         Transform key = Transform.of(Transform.PERMUTE_ARGS, reorder);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == skip+inTypes) : form;
              return form;
          }
<span class="line-new-header">--- 1087,11 ---</span>
              if (inArg != i)  nullPerm = false;
              inTypes = Math.max(inTypes, inArg+1);
          }
          assert(skip + reorder.length == lambdaForm.arity);
          if (nullPerm)  return lambdaForm;  // do not bother to cache
<span class="line-modified">!         TransformKey key = TransformKey.of(PERMUTE_ARGS, reorder);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == skip+inTypes) : form;
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1095,11 ***</span>
      LambdaForm noteLoopLocalTypesForm(int pos, BasicType[] localTypes) {
          assert(lambdaForm.isLoop(pos));
          int[] desc = BasicType.basicTypeOrds(localTypes);
          desc = Arrays.copyOf(desc, desc.length + 1);
          desc[desc.length - 1] = pos;
<span class="line-modified">!         Transform key = Transform.of(Transform.LOCAL_TYPES, desc);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              return form;
          }
  
<span class="line-new-header">--- 1156,11 ---</span>
      LambdaForm noteLoopLocalTypesForm(int pos, BasicType[] localTypes) {
          assert(lambdaForm.isLoop(pos));
          int[] desc = BasicType.basicTypeOrds(localTypes);
          desc = Arrays.copyOf(desc, desc.length + 1);
          desc[desc.length - 1] = pos;
<span class="line-modified">!         TransformKey key = TransformKey.of(LOCAL_TYPES, desc);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              return form;
          }
  
</pre>
<center><a href="InvokerBytecodeGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
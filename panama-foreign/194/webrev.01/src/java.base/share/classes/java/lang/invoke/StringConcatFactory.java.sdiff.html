<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../net/InetAddress.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.access.JavaLangAccess;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.vm.annotation.Stable;
 31 import sun.invoke.util.Wrapper;
 32 
 33 import java.lang.invoke.MethodHandles.Lookup;
 34 import java.util.ArrayList;
<span class="line-removed"> 35 import java.util.Arrays;</span>
 36 import java.util.List;
 37 import java.util.Objects;
 38 import java.util.concurrent.ConcurrentHashMap;
 39 import java.util.concurrent.ConcurrentMap;
 40 import java.util.function.Function;
 41 
 42 import static java.lang.invoke.MethodType.methodType;
 43 
 44 /**
 45  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
 46  * can be used to efficiently concatenate a known number of arguments of known
 47  * types, possibly after type adaptation and partial evaluation of arguments.
 48  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
 49  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 50  * feature of the Java Programming Language.
 51  *
 52  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
 53  * MethodHandle} proceeds in order through two phases:
 54  *
 55  * &lt;ol&gt;
</pre>
<hr />
<pre>
104      * Tag used to demarcate an ordinary argument.
105      */
106     private static final char TAG_ARG = &#39;\u0001&#39;;
107 
108     /**
109      * Tag used to demarcate a constant.
110      */
111     private static final char TAG_CONST = &#39;\u0002&#39;;
112 
113     /**
114      * Maximum number of argument slots in String Concat call.
115      *
116      * While the maximum number of argument slots that indy call can handle is 253,
117      * we do not use all those slots, to let the strategies with MethodHandle
118      * combinators to use some arguments.
119      */
120     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
121 
122     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
123 
<span class="line-removed">124     /**</span>
<span class="line-removed">125      * Parses the recipe string, and produces a traversable collection of</span>
<span class="line-removed">126      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator</span>
<span class="line-removed">127      * strategies. Notably, this class parses out the constants from the recipe</span>
<span class="line-removed">128      * and from other static arguments.</span>
<span class="line-removed">129      */</span>
<span class="line-removed">130     private static final class Recipe {</span>
<span class="line-removed">131         private final List&lt;RecipeElement&gt; elements;</span>
<span class="line-removed">132 </span>
<span class="line-removed">133         public Recipe(String src, Object[] constants) {</span>
<span class="line-removed">134             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();</span>
<span class="line-removed">135 </span>
<span class="line-removed">136             int constC = 0;</span>
<span class="line-removed">137             int argC = 0;</span>
<span class="line-removed">138 </span>
<span class="line-removed">139             StringBuilder acc = new StringBuilder();</span>
<span class="line-removed">140 </span>
<span class="line-removed">141             for (int i = 0; i &lt; src.length(); i++) {</span>
<span class="line-removed">142                 char c = src.charAt(i);</span>
<span class="line-removed">143 </span>
<span class="line-removed">144                 if (c == TAG_CONST || c == TAG_ARG) {</span>
<span class="line-removed">145                     // Detected a special tag, flush all accumulated characters</span>
<span class="line-removed">146                     // as a constant first:</span>
<span class="line-removed">147                     if (acc.length() &gt; 0) {</span>
<span class="line-removed">148                         el.add(new RecipeElement(acc.toString()));</span>
<span class="line-removed">149                         acc.setLength(0);</span>
<span class="line-removed">150                     }</span>
<span class="line-removed">151                     if (c == TAG_CONST) {</span>
<span class="line-removed">152                         Object cnst = constants[constC++];</span>
<span class="line-removed">153                         el.add(new RecipeElement(cnst));</span>
<span class="line-removed">154                     } else if (c == TAG_ARG) {</span>
<span class="line-removed">155                         el.add(new RecipeElement(argC++));</span>
<span class="line-removed">156                     }</span>
<span class="line-removed">157                 } else {</span>
<span class="line-removed">158                     // Not a special character, this is a constant embedded into</span>
<span class="line-removed">159                     // the recipe itself.</span>
<span class="line-removed">160                     acc.append(c);</span>
<span class="line-removed">161                 }</span>
<span class="line-removed">162             }</span>
<span class="line-removed">163 </span>
<span class="line-removed">164             // Flush the remaining characters as constant:</span>
<span class="line-removed">165             if (acc.length() &gt; 0) {</span>
<span class="line-removed">166                 el.add(new RecipeElement(acc.toString()));</span>
<span class="line-removed">167             }</span>
<span class="line-removed">168 </span>
<span class="line-removed">169             elements = el;</span>
<span class="line-removed">170         }</span>
<span class="line-removed">171 </span>
<span class="line-removed">172         public List&lt;RecipeElement&gt; getElements() {</span>
<span class="line-removed">173             return elements;</span>
<span class="line-removed">174         }</span>
<span class="line-removed">175 </span>
<span class="line-removed">176         @Override</span>
<span class="line-removed">177         public boolean equals(Object o) {</span>
<span class="line-removed">178             if (this == o) return true;</span>
<span class="line-removed">179             if (o == null || getClass() != o.getClass()) return false;</span>
<span class="line-removed">180 </span>
<span class="line-removed">181             Recipe recipe = (Recipe) o;</span>
<span class="line-removed">182             return elements.equals(recipe.elements);</span>
<span class="line-removed">183         }</span>
<span class="line-removed">184 </span>
<span class="line-removed">185         @Override</span>
<span class="line-removed">186         public String toString() {</span>
<span class="line-removed">187             return &quot;Recipe{&quot; +</span>
<span class="line-removed">188                     &quot;elements=&quot; + elements +</span>
<span class="line-removed">189                     &#39;}&#39;;</span>
<span class="line-removed">190         }</span>
<span class="line-removed">191 </span>
<span class="line-removed">192         @Override</span>
<span class="line-removed">193         public int hashCode() {</span>
<span class="line-removed">194             return elements.hashCode();</span>
<span class="line-removed">195         }</span>
<span class="line-removed">196     }</span>
<span class="line-removed">197 </span>
<span class="line-removed">198     private static final class RecipeElement {</span>
<span class="line-removed">199         private final String value;</span>
<span class="line-removed">200         private final int argPos;</span>
<span class="line-removed">201         private final char tag;</span>
<span class="line-removed">202 </span>
<span class="line-removed">203         public RecipeElement(Object cnst) {</span>
<span class="line-removed">204             this.value = String.valueOf(Objects.requireNonNull(cnst));</span>
<span class="line-removed">205             this.argPos = -1;</span>
<span class="line-removed">206             this.tag = TAG_CONST;</span>
<span class="line-removed">207         }</span>
<span class="line-removed">208 </span>
<span class="line-removed">209         public RecipeElement(int arg) {</span>
<span class="line-removed">210             this.value = null;</span>
<span class="line-removed">211             this.argPos = arg;</span>
<span class="line-removed">212             this.tag = TAG_ARG;</span>
<span class="line-removed">213         }</span>
<span class="line-removed">214 </span>
<span class="line-removed">215         public String getValue() {</span>
<span class="line-removed">216             assert (tag == TAG_CONST);</span>
<span class="line-removed">217             return value;</span>
<span class="line-removed">218         }</span>
<span class="line-removed">219 </span>
<span class="line-removed">220         public int getArgPos() {</span>
<span class="line-removed">221             assert (tag == TAG_ARG);</span>
<span class="line-removed">222             return argPos;</span>
<span class="line-removed">223         }</span>
<span class="line-removed">224 </span>
<span class="line-removed">225         public char getTag() {</span>
<span class="line-removed">226             return tag;</span>
<span class="line-removed">227         }</span>
<span class="line-removed">228 </span>
<span class="line-removed">229         @Override</span>
<span class="line-removed">230         public boolean equals(Object o) {</span>
<span class="line-removed">231             if (this == o) return true;</span>
<span class="line-removed">232             if (o == null || getClass() != o.getClass()) return false;</span>
<span class="line-removed">233 </span>
<span class="line-removed">234             RecipeElement that = (RecipeElement) o;</span>
<span class="line-removed">235 </span>
<span class="line-removed">236             if (this.tag != that.tag) return false;</span>
<span class="line-removed">237             if (this.tag == TAG_CONST &amp;&amp; (!value.equals(that.value))) return false;</span>
<span class="line-removed">238             if (this.tag == TAG_ARG &amp;&amp; (argPos != that.argPos)) return false;</span>
<span class="line-removed">239             return true;</span>
<span class="line-removed">240         }</span>
<span class="line-removed">241 </span>
<span class="line-removed">242         @Override</span>
<span class="line-removed">243         public String toString() {</span>
<span class="line-removed">244             return &quot;RecipeElement{&quot; +</span>
<span class="line-removed">245                     &quot;value=&#39;&quot; + value + &#39;\&#39;&#39; +</span>
<span class="line-removed">246                     &quot;, argPos=&quot; + argPos +</span>
<span class="line-removed">247                     &quot;, tag=&quot; + tag +</span>
<span class="line-removed">248                     &#39;}&#39;;</span>
<span class="line-removed">249         }</span>
<span class="line-removed">250 </span>
<span class="line-removed">251         @Override</span>
<span class="line-removed">252         public int hashCode() {</span>
<span class="line-removed">253             return (int)tag;</span>
<span class="line-removed">254         }</span>
<span class="line-removed">255     }</span>
<span class="line-removed">256 </span>
257     // StringConcatFactory bootstrap methods are startup sensitive, and may be
<span class="line-modified">258     // special cased in java.lang.invokeBootstrapMethodInvoker to ensure</span>
259     // methods are invoked with exact type information to avoid generating
260     // code for runtime checks. Take care any changes or additions here are
261     // reflected there as appropriate.
262 
263     /**
264      * Facilitates the creation of optimized String concatenation methods, that
265      * can be used to efficiently concatenate a known number of arguments of
266      * known types, possibly after type adaptation and partial evaluation of
267      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
268      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
269      * feature of the Java Programming Language.
270      *
271      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
272      * invoked, it returns the result of String concatenation, taking all
273      * function arguments passed to the linkage method as inputs for
274      * concatenation. The target signature is given by {@code concatType}.
275      * For a target accepting:
276      * &lt;ul&gt;
277      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
278      *     &lt;li&gt;one input, concatenation results in the single
</pre>
<hr />
<pre>
315      *                   java.lang.String}.  When used with {@code invokedynamic},
316      *                   this is provided by the {@code NameAndType} of the {@code
317      *                   InvokeDynamic} structure and is stacked automatically by
318      *                   the VM.
319      * @return a CallSite whose target can be used to perform String
320      * concatenation, with dynamic concatenation arguments described by the given
321      * {@code concatType}.
322      * @throws StringConcatException If any of the linkage invariants described
323      *                               here are violated, or the lookup context
324      *                               does not have private access privileges.
325      * @throws NullPointerException If any of the incoming arguments is null.
326      *                              This will never happen when a bootstrap method
327      *                              is called with invokedynamic.
328      *
329      * @jls  5.1.11 String Conversion
330      * @jls 15.18.1 String Concatenation Operator +
331      */
332     public static CallSite makeConcat(MethodHandles.Lookup lookup,
333                                       String name,
334                                       MethodType concatType) throws StringConcatException {
<span class="line-modified">335         return doStringConcat(lookup, name, concatType, true, null);</span>





336     }
337 
338     /**
339      * Facilitates the creation of optimized String concatenation methods, that
340      * can be used to efficiently concatenate a known number of arguments of
341      * known types, possibly after type adaptation and partial evaluation of
342      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
343      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
344      * feature of the Java Programming Language.
345      *
346      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
347      * invoked, it returns the result of String concatenation, taking all
348      * function arguments and constants passed to the linkage method as inputs for
349      * concatenation. The target signature is given by {@code concatType}, and
350      * does not include constants.
351      * For a target accepting:
352      * &lt;ul&gt;
353      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
354      *     &lt;li&gt;one input, concatenation results in the single
355      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
</pre>
<hr />
<pre>
433      *                               does not have private access privileges.
434      * @throws NullPointerException If any of the incoming arguments is null, or
435      *                              any constant in {@code recipe} is null.
436      *                              This will never happen when a bootstrap method
437      *                              is called with invokedynamic.
438      * @apiNote Code generators have three distinct ways to process a constant
439      * string operand S in a string concatenation expression.  First, S can be
440      * materialized as a reference (using ldc) and passed as an ordinary argument
441      * (recipe &#39;\1&#39;). Or, S can be stored in the constant pool and passed as a
442      * constant (recipe &#39;\2&#39;) . Finally, if S contains neither of the recipe
443      * tag characters (&#39;\1&#39;, &#39;\2&#39;) then S can be interpolated into the recipe
444      * itself, causing its characters to be inserted into the result.
445      *
446      * @jls  5.1.11 String Conversion
447      * @jls 15.18.1 String Concatenation Operator +
448      */
449     public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
450                                                    String name,
451                                                    MethodType concatType,
452                                                    String recipe,
<span class="line-modified">453                                                    Object... constants) throws StringConcatException {</span>
<span class="line-modified">454         return doStringConcat(lookup, name, concatType, false, recipe, constants);</span>
<span class="line-modified">455     }</span>
<span class="line-removed">456 </span>
<span class="line-removed">457     private static CallSite doStringConcat(MethodHandles.Lookup lookup,</span>
<span class="line-removed">458                                            String name,</span>
<span class="line-removed">459                                            MethodType concatType,</span>
<span class="line-removed">460                                            boolean generateRecipe,</span>
<span class="line-removed">461                                            String recipe,</span>
<span class="line-removed">462                                            Object... constants) throws StringConcatException {</span>
463         Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
464         Objects.requireNonNull(name, &quot;Name is null&quot;);
465         Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
466         Objects.requireNonNull(constants, &quot;Constants are null&quot;);
467 
<span class="line-removed">468         for (Object o : constants) {</span>
<span class="line-removed">469             Objects.requireNonNull(o, &quot;Cannot accept null constants&quot;);</span>
<span class="line-removed">470         }</span>
<span class="line-removed">471 </span>
472         if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
473             throw new StringConcatException(&quot;Invalid caller: &quot; +
474                     lookup.lookupClass().getName());
475         }
476 
<span class="line-modified">477         int cCount = 0;</span>
<span class="line-removed">478         int oCount = 0;</span>
<span class="line-removed">479         if (generateRecipe) {</span>
<span class="line-removed">480             // Mock the recipe to reuse the concat generator code</span>
<span class="line-removed">481             char[] value = new char[concatType.parameterCount()];</span>
<span class="line-removed">482             Arrays.fill(value, TAG_ARG);</span>
<span class="line-removed">483             recipe = new String(value);</span>
<span class="line-removed">484             oCount = concatType.parameterCount();</span>
<span class="line-removed">485         } else {</span>
<span class="line-removed">486             Objects.requireNonNull(recipe, &quot;Recipe is null&quot;);</span>
<span class="line-removed">487 </span>
<span class="line-removed">488             for (int i = 0; i &lt; recipe.length(); i++) {</span>
<span class="line-removed">489                 char c = recipe.charAt(i);</span>
<span class="line-removed">490                 if (c == TAG_CONST) cCount++;</span>
<span class="line-removed">491                 if (c == TAG_ARG)   oCount++;</span>
<span class="line-removed">492             }</span>
<span class="line-removed">493         }</span>
<span class="line-removed">494 </span>
<span class="line-removed">495         if (oCount != concatType.parameterCount()) {</span>
<span class="line-removed">496             throw new StringConcatException(</span>
<span class="line-removed">497                     &quot;Mismatched number of concat arguments: recipe wants &quot; +</span>
<span class="line-removed">498                             oCount +</span>
<span class="line-removed">499                             &quot; arguments, but signature provides &quot; +</span>
<span class="line-removed">500                             concatType.parameterCount());</span>
<span class="line-removed">501         }</span>
<span class="line-removed">502 </span>
<span class="line-removed">503         if (cCount != constants.length) {</span>
<span class="line-removed">504             throw new StringConcatException(</span>
<span class="line-removed">505                     &quot;Mismatched number of concat constants: recipe wants &quot; +</span>
<span class="line-removed">506                             cCount +</span>
<span class="line-removed">507                             &quot; constants, but only &quot; +</span>
<span class="line-removed">508                             constants.length +</span>
<span class="line-removed">509                             &quot; are passed&quot;);</span>
<span class="line-removed">510         }</span>
511 
512         if (!concatType.returnType().isAssignableFrom(String.class)) {
513             throw new StringConcatException(
514                     &quot;The return type should be compatible with String, but it is &quot; +
515                             concatType.returnType());
516         }
517 
518         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
519             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
520                     concatType.parameterSlotCount() +
521                     &quot;, can only accept &quot; +
522                     MAX_INDY_CONCAT_ARG_SLOTS);
523         }
524 
<span class="line-removed">525         Recipe rec = new Recipe(recipe, constants);</span>
<span class="line-removed">526         MethodHandle mh = generate(lookup, concatType, rec);</span>
<span class="line-removed">527         return new ConstantCallSite(mh.asType(concatType));</span>
<span class="line-removed">528     }</span>
<span class="line-removed">529 </span>
<span class="line-removed">530     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {</span>
531         try {
<span class="line-modified">532             return generateMHInlineCopy(mt, recipe);</span>
<span class="line-modified">533         } catch (Error | StringConcatException e) {</span>
<span class="line-modified">534             // Pass through any error or existing StringConcatException</span>


535             throw e;
536         } catch (Throwable t) {
537             throw new StringConcatException(&quot;Generator failed&quot;, t);
538         }
539     }
540 




































































541 
542     /**
543      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the
544      * byte[] array on its own and passes that byte[] array to String
545      * constructor. This strategy requires access to some private APIs in JDK,
546      * most notably, the private String constructor that accepts byte[] arrays
547      * without copying.
548      */
<span class="line-modified">549     private static MethodHandle generateMHInlineCopy(MethodType mt, Recipe recipe) throws Throwable {</span>
550 
551         // Fast-path two-argument Object + Object concatenations
<span class="line-modified">552         if (recipe.getElements().size() == 2) {</span>
553             // Two object arguments



554             if (mt.parameterCount() == 2 &amp;&amp;
555                     !mt.parameterType(0).isPrimitive() &amp;&amp;
556                     !mt.parameterType(1).isPrimitive() &amp;&amp;
<span class="line-modified">557                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="line-modified">558                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-removed">559 </span>
560                 return simpleConcat();
<span class="line-removed">561 </span>
562             } else if (mt.parameterCount() == 1 &amp;&amp;
563                     !mt.parameterType(0).isPrimitive()) {

564                 // One Object argument, one constant
565                 MethodHandle mh = simpleConcat();
566 
<span class="line-modified">567                 if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-removed">568                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
569                     // First recipe element is a constant
<span class="line-modified">570                     return MethodHandles.insertArguments(mh, 0,</span>
<span class="line-removed">571                             recipe.getElements().get(0).getValue());</span>
572 
<span class="line-modified">573                 } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-removed">574                         recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
575                     // Second recipe element is a constant
<span class="line-modified">576                     return MethodHandles.insertArguments(mh, 1,</span>
<span class="line-removed">577                             recipe.getElements().get(1).getValue());</span>
578 
579                 }
580             }
581             // else... fall-through to slow-path
582         }
583 
584         // Create filters and obtain filtered parameter types. Filters would be used in the beginning
585         // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
586         // The filtered argument type list is used all over in the combinators below.
<span class="line-modified">587         Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>

588         MethodHandle[] filters = null;
589         for (int i = 0; i &lt; ptypes.length; i++) {
590             MethodHandle filter = stringifierFor(ptypes[i]);
591             if (filter != null) {
592                 if (filters == null) {
593                     filters = new MethodHandle[ptypes.length];
594                 }
595                 filters[i] = filter;
<span class="line-modified">596                 ptypes[i] = filter.type().returnType();</span>
597             }
598         }
599 
600         // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
601         // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
602         // assembled bottom-up, which makes the code arguably hard to read.
603 
604         // Drop all remaining parameter types, leave only helper arguments:
<span class="line-modified">605         MethodHandle mh;</span>
<span class="line-removed">606 </span>
<span class="line-removed">607         mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
608 
609         long initialLengthCoder = INITIAL_CODER;
610 
611         // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
612         // known from the combinators below. We are assembling the string backwards, so the index coded
613         // into indexCoder is the *ending* index.
614 
615         // We need one prepender per argument, but also need to fold in constants. We do so by greedily
616         // create prependers that fold in surrounding constants into the argument prepender. This reduces
617         // the number of unique MH combinator tree shapes we&#39;ll create in an application.
618         String constant = null;
<span class="line-modified">619         for (RecipeElement el : recipe.getElements()) {</span>

620             // Do the prepend, and put &quot;new&quot; index at index 1
<span class="line-modified">621             switch (el.getTag()) {</span>
<span class="line-modified">622                 case TAG_CONST: {</span>
<span class="line-modified">623                     String constantValue = el.getValue();</span>
<span class="line-modified">624 </span>
<span class="line-modified">625                     // Eagerly update the initialLengthCoder value</span>
<span class="line-modified">626                     initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constantValue);</span>
<span class="line-modified">627 </span>
<span class="line-modified">628                     // Collecting into a single constant that we&#39;ll either fold</span>
<span class="line-modified">629                     // into the next argument prepender, or into the newArray</span>
<span class="line-modified">630                     // combinator</span>
<span class="line-modified">631                     constant = constant == null ? constantValue : constant + constantValue;</span>
<span class="line-modified">632                     break;</span>
<span class="line-modified">633                 }</span>
<span class="line-modified">634                 case TAG_ARG: {</span>
<span class="line-modified">635                     // Add prepender, along with any prefix constant</span>
<span class="line-modified">636                     int pos = el.getArgPos();</span>
<span class="line-modified">637                     mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="line-modified">638                             mh, 1,</span>
<span class="line-modified">639                             prepender(constant, ptypes[pos]),</span>
<span class="line-modified">640                             1, 0, // indexCoder, storage</span>
<span class="line-removed">641                             2 + pos  // selected argument</span>
<span class="line-removed">642                     );</span>
<span class="line-removed">643                     constant = null;</span>
<span class="line-removed">644                     break;</span>
<span class="line-removed">645                 }</span>
<span class="line-removed">646                 default:</span>
<span class="line-removed">647                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
648             }
649         }
650 
651         // Fold in byte[] instantiation at argument 0
652         MethodHandle newArrayCombinator;
653         if (constant != null) {
654             // newArray variant that deals with prepending the trailing constant
655             //
656             // initialLengthCoder has been adjusted to have the correct coder
657             // and length already, but to avoid binding an extra variable to
658             // the method handle we now adjust the length to be correct for the
659             // first prepender above, while adjusting for the missing length of
660             // the constant in StringConcatHelper
661             initialLengthCoder -= constant.length();
662             newArrayCombinator = newArrayWithSuffix(constant);
663         } else {
664             newArrayCombinator = newArray();
665         }
666         mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,
667                 1 // index
</pre>
<hr />
<pre>
669 
670         // Start combining length and coder mixers.
671         //
672         // Length is easy: constant lengths can be computed on the spot, and all non-constant
673         // shapes have been either converted to Strings, or explicit methods for getting the
674         // string length out of primitives are provided.
675         //
676         // Coders are more interesting. Only Object, String and char arguments (and constants)
677         // can have non-Latin1 encoding. It is easier to blindly convert constants to String,
678         // and deduce the coder from there. Arguments would be either converted to Strings
679         // during the initial filtering, or handled by specializations in MIXERS.
680         //
681         // The method handle shape before all mixers are combined in is:
682         //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)
683         //
684         // We will bind the initialLengthCoder value to the last mixer (the one that will be
685         // executed first), then fold that in. This leaves the shape after all mixers are
686         // combined in as:
687         //   (&lt;args&gt;)String = (&lt;args&gt;)
688 
<span class="line-modified">689         int ac = -1;</span>
690         MethodHandle mix = null;
<span class="line-modified">691         for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-modified">692             switch (el.getTag()) {</span>
<span class="line-modified">693                 case TAG_CONST:</span>
<span class="line-modified">694                     // Constants already handled in the code above</span>
<span class="line-removed">695                     break;</span>
<span class="line-removed">696                 case TAG_ARG:</span>
<span class="line-removed">697                     if (ac &gt;= 0) {</span>
698                         // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.
699                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,
700                                 0, // old-index
<span class="line-modified">701                                 1 + ac // selected argument</span>
702                         );
703                     }
704 
<span class="line-modified">705                     ac = el.getArgPos();</span>
<span class="line-removed">706                     Class&lt;?&gt; argClass = ptypes[ac];</span>
707                     mix = mixer(argClass);
<span class="line-removed">708 </span>
<span class="line-removed">709                     break;</span>
<span class="line-removed">710                 default:</span>
<span class="line-removed">711                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
712             }
713         }
714 
715         // Insert the initialLengthCoder value into the final mixer, then
716         // fold that into the base method handle
<span class="line-modified">717         if (ac &gt;= 0) {</span>
718             mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);
719             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,
<span class="line-modified">720                     1 + ac // selected argument</span>
721             );
722         } else {
723             // No mixer (constants only concat), insert initialLengthCoder directly
724             mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
725         }
726 
727         // The method handle shape here is (&lt;args&gt;).
728 
729         // Apply filters, converting the arguments:
730         if (filters != null) {
731             mh = MethodHandles.filterArguments(mh, 0, filters);
732         }
733 
734         return mh;
735     }
736 
737     private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl) {
738         if (prefix == null) {
739             return NULL_PREPENDERS.computeIfAbsent(cl, NULL_PREPEND);
740         }
741         return MethodHandles.insertArguments(
742                         PREPENDERS.computeIfAbsent(cl, PREPEND), 3, prefix);
743     }
744 
745     private static MethodHandle mixer(Class&lt;?&gt; cl) {
746         return MIXERS.computeIfAbsent(cl, MIX);
747     }
748 
749     // These are deliberately not lambdas to optimize startup time:
750     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
751         @Override
752         public MethodHandle apply(Class&lt;?&gt; c) {
<span class="line-modified">753             return JLA.stringConcatHelper(&quot;prepend&quot;,</span>
754                     methodType(long.class, long.class, byte[].class,
755                             Wrapper.asPrimitiveType(c), String.class));

756         }
757     };
758 
759     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPEND = new Function&lt;&gt;() {
760         @Override
761         public MethodHandle apply(Class&lt;?&gt; c) {
762             return MethodHandles.insertArguments(
<span class="line-modified">763                             PREPENDERS.computeIfAbsent(c, PREPEND), 3, (String)null);</span>
764         }
765     };
766 
767     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
768         @Override
769         public MethodHandle apply(Class&lt;?&gt; c) {
<span class="line-modified">770             return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>


771         }
772     };
773 
774     private @Stable static MethodHandle SIMPLE_CONCAT;
775     private static MethodHandle simpleConcat() {
<span class="line-modified">776         if (SIMPLE_CONCAT == null) {</span>
<span class="line-modified">777             SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>



778         }
<span class="line-modified">779         return SIMPLE_CONCAT;</span>
780     }
781 
782     private @Stable static MethodHandle NEW_STRING;
783     private static MethodHandle newString() {
784         MethodHandle mh = NEW_STRING;
785         if (mh == null) {
<span class="line-modified">786             NEW_STRING = mh =</span>
<span class="line-modified">787                     JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));</span>

788         }
789         return mh;
790     }
791 
792     private @Stable static MethodHandle NEW_ARRAY_SUFFIX;
793     private static MethodHandle newArrayWithSuffix(String suffix) {
794         MethodHandle mh = NEW_ARRAY_SUFFIX;
795         if (mh == null) {
<span class="line-modified">796             NEW_ARRAY_SUFFIX = mh =</span>
<span class="line-modified">797                     JLA.stringConcatHelper(&quot;newArrayWithSuffix&quot;,</span>
<span class="line-modified">798                             methodType(byte[].class, String.class, long.class));</span>
799         }
800         return MethodHandles.insertArguments(mh, 0, suffix);
801     }
802 
803     private @Stable static MethodHandle NEW_ARRAY;
804     private static MethodHandle newArray() {
805         MethodHandle mh = NEW_ARRAY;
806         if (mh == null) {
807             NEW_ARRAY = mh =
808                     JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));
809         }
810         return mh;
811     }
812 
813     /**
814      * Public gateways to public &quot;stringify&quot; methods. These methods have the
815      * form String apply(T obj), and normally delegate to {@code String.valueOf},
816      * depending on argument&#39;s type.
817      */
818     private @Stable static MethodHandle OBJECT_STRINGIFIER;
819     private static MethodHandle objectStringifier() {
820         MethodHandle mh = OBJECT_STRINGIFIER;
821         if (mh == null) {
<span class="line-modified">822             OBJECT_STRINGIFIER = mh =</span>
<span class="line-modified">823                     JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));</span>
824         }
825         return mh;
826     }
827     private @Stable static MethodHandle FLOAT_STRINGIFIER;
828     private static MethodHandle floatStringifier() {
829         MethodHandle mh = FLOAT_STRINGIFIER;
830         if (mh == null) {
831             FLOAT_STRINGIFIER = mh =
832                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
833         }
834         return mh;
835     }
836     private @Stable static MethodHandle DOUBLE_STRINGIFIER;
837     private static MethodHandle doubleStringifier() {
838         MethodHandle mh = DOUBLE_STRINGIFIER;
839         if (mh == null) {
840             DOUBLE_STRINGIFIER = mh =
841                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);
842         }
843         return mh;
</pre>
<hr />
<pre>
846     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
847     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPENDERS;
848     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
849     private static final long INITIAL_CODER;
850 
851     static {
852         INITIAL_CODER = JLA.stringConcatInitialCoder();
853         PREPENDERS = new ConcurrentHashMap&lt;&gt;();
854         NULL_PREPENDERS = new ConcurrentHashMap&lt;&gt;();
855         MIXERS = new ConcurrentHashMap&lt;&gt;();
856     }
857 
858     /**
859      * Returns a stringifier for references and floats/doubles only.
860      * Always returns null for other primitives.
861      *
862      * @param t class to stringify
863      * @return stringifier; null, if not available
864      */
865     private static MethodHandle stringifierFor(Class&lt;?&gt; t) {
<span class="line-modified">866         if (!t.isPrimitive()) {</span>
867             return objectStringifier();
868         } else if (t == float.class) {
869             return floatStringifier();
870         } else if (t == double.class) {
871             return doubleStringifier();
872         }
873         return null;
874     }
875 
876     private static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name,
877                                      Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
878         try {
879             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));
880         } catch (NoSuchMethodException | IllegalAccessException e) {
881             throw new AssertionError(e);
882         }
883     }
884 
885     private StringConcatFactory() {
886         // no instantiation
</pre>
</td>
<td>
<hr />
<pre>
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.access.JavaLangAccess;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.vm.annotation.Stable;
 31 import sun.invoke.util.Wrapper;
 32 
 33 import java.lang.invoke.MethodHandles.Lookup;
 34 import java.util.ArrayList;

 35 import java.util.List;
 36 import java.util.Objects;
 37 import java.util.concurrent.ConcurrentHashMap;
 38 import java.util.concurrent.ConcurrentMap;
 39 import java.util.function.Function;
 40 
 41 import static java.lang.invoke.MethodType.methodType;
 42 
 43 /**
 44  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
 45  * can be used to efficiently concatenate a known number of arguments of known
 46  * types, possibly after type adaptation and partial evaluation of arguments.
 47  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
 48  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 49  * feature of the Java Programming Language.
 50  *
 51  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
 52  * MethodHandle} proceeds in order through two phases:
 53  *
 54  * &lt;ol&gt;
</pre>
<hr />
<pre>
103      * Tag used to demarcate an ordinary argument.
104      */
105     private static final char TAG_ARG = &#39;\u0001&#39;;
106 
107     /**
108      * Tag used to demarcate a constant.
109      */
110     private static final char TAG_CONST = &#39;\u0002&#39;;
111 
112     /**
113      * Maximum number of argument slots in String Concat call.
114      *
115      * While the maximum number of argument slots that indy call can handle is 253,
116      * we do not use all those slots, to let the strategies with MethodHandle
117      * combinators to use some arguments.
118      */
119     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
120 
121     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
122 





































































































































123     // StringConcatFactory bootstrap methods are startup sensitive, and may be
<span class="line-modified">124     // special cased in java.lang.invoke.BootstrapMethodInvoker to ensure</span>
125     // methods are invoked with exact type information to avoid generating
126     // code for runtime checks. Take care any changes or additions here are
127     // reflected there as appropriate.
128 
129     /**
130      * Facilitates the creation of optimized String concatenation methods, that
131      * can be used to efficiently concatenate a known number of arguments of
132      * known types, possibly after type adaptation and partial evaluation of
133      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
134      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
135      * feature of the Java Programming Language.
136      *
137      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
138      * invoked, it returns the result of String concatenation, taking all
139      * function arguments passed to the linkage method as inputs for
140      * concatenation. The target signature is given by {@code concatType}.
141      * For a target accepting:
142      * &lt;ul&gt;
143      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
144      *     &lt;li&gt;one input, concatenation results in the single
</pre>
<hr />
<pre>
181      *                   java.lang.String}.  When used with {@code invokedynamic},
182      *                   this is provided by the {@code NameAndType} of the {@code
183      *                   InvokeDynamic} structure and is stacked automatically by
184      *                   the VM.
185      * @return a CallSite whose target can be used to perform String
186      * concatenation, with dynamic concatenation arguments described by the given
187      * {@code concatType}.
188      * @throws StringConcatException If any of the linkage invariants described
189      *                               here are violated, or the lookup context
190      *                               does not have private access privileges.
191      * @throws NullPointerException If any of the incoming arguments is null.
192      *                              This will never happen when a bootstrap method
193      *                              is called with invokedynamic.
194      *
195      * @jls  5.1.11 String Conversion
196      * @jls 15.18.1 String Concatenation Operator +
197      */
198     public static CallSite makeConcat(MethodHandles.Lookup lookup,
199                                       String name,
200                                       MethodType concatType) throws StringConcatException {
<span class="line-modified">201         // This bootstrap method is unlikely to be used in practice,</span>
<span class="line-added">202         // avoid optimizing it at the expense of makeConcatWithConstants</span>
<span class="line-added">203 </span>
<span class="line-added">204         // Mock the recipe to reuse the concat generator code</span>
<span class="line-added">205         String recipe = &quot;\u0001&quot;.repeat(concatType.parameterCount());</span>
<span class="line-added">206         return makeConcatWithConstants(lookup, name, concatType, recipe);</span>
207     }
208 
209     /**
210      * Facilitates the creation of optimized String concatenation methods, that
211      * can be used to efficiently concatenate a known number of arguments of
212      * known types, possibly after type adaptation and partial evaluation of
213      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
214      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
215      * feature of the Java Programming Language.
216      *
217      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
218      * invoked, it returns the result of String concatenation, taking all
219      * function arguments and constants passed to the linkage method as inputs for
220      * concatenation. The target signature is given by {@code concatType}, and
221      * does not include constants.
222      * For a target accepting:
223      * &lt;ul&gt;
224      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
225      *     &lt;li&gt;one input, concatenation results in the single
226      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
</pre>
<hr />
<pre>
304      *                               does not have private access privileges.
305      * @throws NullPointerException If any of the incoming arguments is null, or
306      *                              any constant in {@code recipe} is null.
307      *                              This will never happen when a bootstrap method
308      *                              is called with invokedynamic.
309      * @apiNote Code generators have three distinct ways to process a constant
310      * string operand S in a string concatenation expression.  First, S can be
311      * materialized as a reference (using ldc) and passed as an ordinary argument
312      * (recipe &#39;\1&#39;). Or, S can be stored in the constant pool and passed as a
313      * constant (recipe &#39;\2&#39;) . Finally, if S contains neither of the recipe
314      * tag characters (&#39;\1&#39;, &#39;\2&#39;) then S can be interpolated into the recipe
315      * itself, causing its characters to be inserted into the result.
316      *
317      * @jls  5.1.11 String Conversion
318      * @jls 15.18.1 String Concatenation Operator +
319      */
320     public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
321                                                    String name,
322                                                    MethodType concatType,
323                                                    String recipe,
<span class="line-modified">324                                                    Object... constants)</span>
<span class="line-modified">325         throws StringConcatException</span>
<span class="line-modified">326     {</span>







327         Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
328         Objects.requireNonNull(name, &quot;Name is null&quot;);
329         Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
330         Objects.requireNonNull(constants, &quot;Constants are null&quot;);
331 




332         if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
333             throw new StringConcatException(&quot;Invalid caller: &quot; +
334                     lookup.lookupClass().getName());
335         }
336 
<span class="line-modified">337         List&lt;String&gt; elements = parseRecipe(concatType, recipe, constants);</span>

































338 
339         if (!concatType.returnType().isAssignableFrom(String.class)) {
340             throw new StringConcatException(
341                     &quot;The return type should be compatible with String, but it is &quot; +
342                             concatType.returnType());
343         }
344 
345         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
346             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
347                     concatType.parameterSlotCount() +
348                     &quot;, can only accept &quot; +
349                     MAX_INDY_CONCAT_ARG_SLOTS);
350         }
351 






352         try {
<span class="line-modified">353             return new ConstantCallSite(</span>
<span class="line-modified">354                     generateMHInlineCopy(concatType, elements)</span>
<span class="line-modified">355                             .viewAsType(concatType, true));</span>
<span class="line-added">356         } catch (Error e) {</span>
<span class="line-added">357             // Pass through any error</span>
358             throw e;
359         } catch (Throwable t) {
360             throw new StringConcatException(&quot;Generator failed&quot;, t);
361         }
362     }
363 
<span class="line-added">364     private static List&lt;String&gt; parseRecipe(MethodType concatType,</span>
<span class="line-added">365                                             String recipe,</span>
<span class="line-added">366                                             Object[] constants)</span>
<span class="line-added">367         throws StringConcatException</span>
<span class="line-added">368     {</span>
<span class="line-added">369 </span>
<span class="line-added">370         Objects.requireNonNull(recipe, &quot;Recipe is null&quot;);</span>
<span class="line-added">371         // Element list containing String constants, or null for arguments</span>
<span class="line-added">372         List&lt;String&gt; elements = new ArrayList&lt;&gt;();</span>
<span class="line-added">373 </span>
<span class="line-added">374         int cCount = 0;</span>
<span class="line-added">375         int oCount = 0;</span>
<span class="line-added">376 </span>
<span class="line-added">377         StringBuilder acc = new StringBuilder();</span>
<span class="line-added">378 </span>
<span class="line-added">379         for (int i = 0; i &lt; recipe.length(); i++) {</span>
<span class="line-added">380             char c = recipe.charAt(i);</span>
<span class="line-added">381 </span>
<span class="line-added">382             if (c == TAG_CONST) {</span>
<span class="line-added">383                 if (cCount == constants.length) {</span>
<span class="line-added">384                     // Not enough constants</span>
<span class="line-added">385                     throw constantMismatch(concatType, oCount);</span>
<span class="line-added">386                 }</span>
<span class="line-added">387                 // Accumulate constant args along with any constants encoded</span>
<span class="line-added">388                 // into the recipe</span>
<span class="line-added">389                 acc.append(Objects.requireNonNull(constants[cCount++], &quot;Cannot accept null constants&quot;));</span>
<span class="line-added">390             } else if (c == TAG_ARG) {</span>
<span class="line-added">391                 // Flush any accumulated characters into a constant</span>
<span class="line-added">392                 if (acc.length() &gt; 0) {</span>
<span class="line-added">393                     elements.add(acc.toString());</span>
<span class="line-added">394                     acc.setLength(0);</span>
<span class="line-added">395                 }</span>
<span class="line-added">396                 elements.add(null);</span>
<span class="line-added">397                 oCount++;</span>
<span class="line-added">398             } else {</span>
<span class="line-added">399                 // Not a special character, this is a constant embedded into</span>
<span class="line-added">400                 // the recipe itself.</span>
<span class="line-added">401                 acc.append(c);</span>
<span class="line-added">402             }</span>
<span class="line-added">403         }</span>
<span class="line-added">404 </span>
<span class="line-added">405         // Flush the remaining characters as constant:</span>
<span class="line-added">406         if (acc.length() &gt; 0) {</span>
<span class="line-added">407             elements.add(acc.toString());</span>
<span class="line-added">408         }</span>
<span class="line-added">409 </span>
<span class="line-added">410         if (oCount != concatType.parameterCount()) {</span>
<span class="line-added">411             throw constantMismatch(concatType, oCount);</span>
<span class="line-added">412         }</span>
<span class="line-added">413         if (cCount != constants.length) {</span>
<span class="line-added">414             throw new StringConcatException(</span>
<span class="line-added">415                     &quot;Mismatched number of concat constants: recipe wants &quot; +</span>
<span class="line-added">416                             cCount +</span>
<span class="line-added">417                             &quot; constants, but only &quot; +</span>
<span class="line-added">418                             constants.length +</span>
<span class="line-added">419                             &quot; are passed&quot;);</span>
<span class="line-added">420         }</span>
<span class="line-added">421         return elements;</span>
<span class="line-added">422     }</span>
<span class="line-added">423 </span>
<span class="line-added">424     private static StringConcatException constantMismatch(MethodType concatType,</span>
<span class="line-added">425                                                           int oCount) {</span>
<span class="line-added">426         return new StringConcatException(</span>
<span class="line-added">427                 &quot;Mismatched number of concat arguments: recipe wants &quot; +</span>
<span class="line-added">428                         oCount +</span>
<span class="line-added">429                         &quot; arguments, but signature provides &quot; +</span>
<span class="line-added">430                         concatType.parameterCount());</span>
<span class="line-added">431     }</span>
432 
433     /**
434      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the
435      * byte[] array on its own and passes that byte[] array to String
436      * constructor. This strategy requires access to some private APIs in JDK,
437      * most notably, the private String constructor that accepts byte[] arrays
438      * without copying.
439      */
<span class="line-modified">440     private static MethodHandle generateMHInlineCopy(MethodType mt, List&lt;String&gt; elements) {</span>
441 
442         // Fast-path two-argument Object + Object concatenations
<span class="line-modified">443         if (elements.size() == 2) {</span>
444             // Two object arguments
<span class="line-added">445             String s0 = elements.get(0);</span>
<span class="line-added">446             String s1 = elements.get(1);</span>
<span class="line-added">447 </span>
448             if (mt.parameterCount() == 2 &amp;&amp;
449                     !mt.parameterType(0).isPrimitive() &amp;&amp;
450                     !mt.parameterType(1).isPrimitive() &amp;&amp;
<span class="line-modified">451                     s0 == null &amp;&amp;</span>
<span class="line-modified">452                     s1 == null) {</span>

453                 return simpleConcat();

454             } else if (mt.parameterCount() == 1 &amp;&amp;
455                     !mt.parameterType(0).isPrimitive()) {
<span class="line-added">456 </span>
457                 // One Object argument, one constant
458                 MethodHandle mh = simpleConcat();
459 
<span class="line-modified">460                 if (s0 != null &amp;&amp; s1 == null) {</span>

461                     // First recipe element is a constant
<span class="line-modified">462                     return MethodHandles.insertArguments(mh, 0, s0);</span>

463 
<span class="line-modified">464                 } else if (s1 != null &amp;&amp; s0 == null) {</span>

465                     // Second recipe element is a constant
<span class="line-modified">466                     return MethodHandles.insertArguments(mh, 1, s1);</span>

467 
468                 }
469             }
470             // else... fall-through to slow-path
471         }
472 
473         // Create filters and obtain filtered parameter types. Filters would be used in the beginning
474         // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
475         // The filtered argument type list is used all over in the combinators below.
<span class="line-modified">476 </span>
<span class="line-added">477         Class&lt;?&gt;[] ptypes = mt.erase().parameterArray();</span>
478         MethodHandle[] filters = null;
479         for (int i = 0; i &lt; ptypes.length; i++) {
480             MethodHandle filter = stringifierFor(ptypes[i]);
481             if (filter != null) {
482                 if (filters == null) {
483                     filters = new MethodHandle[ptypes.length];
484                 }
485                 filters[i] = filter;
<span class="line-modified">486                 ptypes[i] = String.class;</span>
487             }
488         }
489 
490         // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
491         // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
492         // assembled bottom-up, which makes the code arguably hard to read.
493 
494         // Drop all remaining parameter types, leave only helper arguments:
<span class="line-modified">495         MethodHandle mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>


496 
497         long initialLengthCoder = INITIAL_CODER;
498 
499         // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
500         // known from the combinators below. We are assembling the string backwards, so the index coded
501         // into indexCoder is the *ending* index.
502 
503         // We need one prepender per argument, but also need to fold in constants. We do so by greedily
504         // create prependers that fold in surrounding constants into the argument prepender. This reduces
505         // the number of unique MH combinator tree shapes we&#39;ll create in an application.
506         String constant = null;
<span class="line-modified">507         int pos = 0;</span>
<span class="line-added">508         for (String el : elements) {</span>
509             // Do the prepend, and put &quot;new&quot; index at index 1
<span class="line-modified">510             if (el != null) {</span>
<span class="line-modified">511                 // Constant element</span>
<span class="line-modified">512 </span>
<span class="line-modified">513                 // Eagerly update the initialLengthCoder value</span>
<span class="line-modified">514                 initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, el);</span>
<span class="line-modified">515 </span>
<span class="line-modified">516                 // Save the constant and fold it either into the next</span>
<span class="line-modified">517                 // argument prepender, or into the newArray combinator</span>
<span class="line-modified">518                 assert (constant == null);</span>
<span class="line-modified">519                 constant = el;</span>
<span class="line-modified">520             } else {</span>
<span class="line-modified">521                 // Add prepender, along with any prefix constant</span>
<span class="line-modified">522                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="line-modified">523                         mh, 1,</span>
<span class="line-modified">524                         prepender(constant, ptypes[pos]),</span>
<span class="line-modified">525                         1, 0, // indexCoder, storage</span>
<span class="line-modified">526                         2 + pos  // selected argument</span>
<span class="line-modified">527                 );</span>
<span class="line-modified">528                 constant = null;</span>
<span class="line-modified">529                 pos++;</span>







530             }
531         }
532 
533         // Fold in byte[] instantiation at argument 0
534         MethodHandle newArrayCombinator;
535         if (constant != null) {
536             // newArray variant that deals with prepending the trailing constant
537             //
538             // initialLengthCoder has been adjusted to have the correct coder
539             // and length already, but to avoid binding an extra variable to
540             // the method handle we now adjust the length to be correct for the
541             // first prepender above, while adjusting for the missing length of
542             // the constant in StringConcatHelper
543             initialLengthCoder -= constant.length();
544             newArrayCombinator = newArrayWithSuffix(constant);
545         } else {
546             newArrayCombinator = newArray();
547         }
548         mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,
549                 1 // index
</pre>
<hr />
<pre>
551 
552         // Start combining length and coder mixers.
553         //
554         // Length is easy: constant lengths can be computed on the spot, and all non-constant
555         // shapes have been either converted to Strings, or explicit methods for getting the
556         // string length out of primitives are provided.
557         //
558         // Coders are more interesting. Only Object, String and char arguments (and constants)
559         // can have non-Latin1 encoding. It is easier to blindly convert constants to String,
560         // and deduce the coder from there. Arguments would be either converted to Strings
561         // during the initial filtering, or handled by specializations in MIXERS.
562         //
563         // The method handle shape before all mixers are combined in is:
564         //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)
565         //
566         // We will bind the initialLengthCoder value to the last mixer (the one that will be
567         // executed first), then fold that in. This leaves the shape after all mixers are
568         // combined in as:
569         //   (&lt;args&gt;)String = (&lt;args&gt;)
570 
<span class="line-modified">571         pos = -1;</span>
572         MethodHandle mix = null;
<span class="line-modified">573         for (String el : elements) {</span>
<span class="line-modified">574             // Constants already handled in the code above</span>
<span class="line-modified">575             if (el == null) {</span>
<span class="line-modified">576                     if (pos &gt;= 0) {</span>



577                         // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.
578                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,
579                                 0, // old-index
<span class="line-modified">580                                 1 + pos // selected argument</span>
581                         );
582                     }
583 
<span class="line-modified">584                     Class&lt;?&gt; argClass = ptypes[++pos];</span>

585                     mix = mixer(argClass);




586             }
587         }
588 
589         // Insert the initialLengthCoder value into the final mixer, then
590         // fold that into the base method handle
<span class="line-modified">591         if (pos &gt;= 0) {</span>
592             mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);
593             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,
<span class="line-modified">594                     1 + pos // selected argument</span>
595             );
596         } else {
597             // No mixer (constants only concat), insert initialLengthCoder directly
598             mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
599         }
600 
601         // The method handle shape here is (&lt;args&gt;).
602 
603         // Apply filters, converting the arguments:
604         if (filters != null) {
605             mh = MethodHandles.filterArguments(mh, 0, filters);
606         }
607 
608         return mh;
609     }
610 
611     private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl) {
612         if (prefix == null) {
613             return NULL_PREPENDERS.computeIfAbsent(cl, NULL_PREPEND);
614         }
615         return MethodHandles.insertArguments(
616                         PREPENDERS.computeIfAbsent(cl, PREPEND), 3, prefix);
617     }
618 
619     private static MethodHandle mixer(Class&lt;?&gt; cl) {
620         return MIXERS.computeIfAbsent(cl, MIX);
621     }
622 
623     // These are deliberately not lambdas to optimize startup time:
624     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
625         @Override
626         public MethodHandle apply(Class&lt;?&gt; c) {
<span class="line-modified">627             MethodHandle prepend = JLA.stringConcatHelper(&quot;prepend&quot;,</span>
628                     methodType(long.class, long.class, byte[].class,
629                             Wrapper.asPrimitiveType(c), String.class));
<span class="line-added">630             return prepend.rebind();</span>
631         }
632     };
633 
634     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPEND = new Function&lt;&gt;() {
635         @Override
636         public MethodHandle apply(Class&lt;?&gt; c) {
637             return MethodHandles.insertArguments(
<span class="line-modified">638                     PREPENDERS.computeIfAbsent(c, PREPEND), 3, (String)null);</span>
639         }
640     };
641 
642     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
643         @Override
644         public MethodHandle apply(Class&lt;?&gt; c) {
<span class="line-modified">645             MethodHandle mix = JLA.stringConcatHelper(&quot;mix&quot;,</span>
<span class="line-added">646                     methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
<span class="line-added">647             return mix.rebind();</span>
648         }
649     };
650 
651     private @Stable static MethodHandle SIMPLE_CONCAT;
652     private static MethodHandle simpleConcat() {
<span class="line-modified">653         MethodHandle mh = SIMPLE_CONCAT;</span>
<span class="line-modified">654         if (mh == null) {</span>
<span class="line-added">655             MethodHandle simpleConcat = JLA.stringConcatHelper(&quot;simpleConcat&quot;,</span>
<span class="line-added">656                     methodType(String.class, Object.class, Object.class));</span>
<span class="line-added">657             SIMPLE_CONCAT = mh = simpleConcat.rebind();</span>
658         }
<span class="line-modified">659         return mh;</span>
660     }
661 
662     private @Stable static MethodHandle NEW_STRING;
663     private static MethodHandle newString() {
664         MethodHandle mh = NEW_STRING;
665         if (mh == null) {
<span class="line-modified">666             MethodHandle newString = JLA.stringConcatHelper(&quot;newString&quot;,</span>
<span class="line-modified">667                     methodType(String.class, byte[].class, long.class));</span>
<span class="line-added">668             NEW_STRING = mh = newString.rebind();</span>
669         }
670         return mh;
671     }
672 
673     private @Stable static MethodHandle NEW_ARRAY_SUFFIX;
674     private static MethodHandle newArrayWithSuffix(String suffix) {
675         MethodHandle mh = NEW_ARRAY_SUFFIX;
676         if (mh == null) {
<span class="line-modified">677             MethodHandle newArrayWithSuffix = JLA.stringConcatHelper(&quot;newArrayWithSuffix&quot;,</span>
<span class="line-modified">678                     methodType(byte[].class, String.class, long.class));</span>
<span class="line-modified">679             NEW_ARRAY_SUFFIX = mh = newArrayWithSuffix.rebind();</span>
680         }
681         return MethodHandles.insertArguments(mh, 0, suffix);
682     }
683 
684     private @Stable static MethodHandle NEW_ARRAY;
685     private static MethodHandle newArray() {
686         MethodHandle mh = NEW_ARRAY;
687         if (mh == null) {
688             NEW_ARRAY = mh =
689                     JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));
690         }
691         return mh;
692     }
693 
694     /**
695      * Public gateways to public &quot;stringify&quot; methods. These methods have the
696      * form String apply(T obj), and normally delegate to {@code String.valueOf},
697      * depending on argument&#39;s type.
698      */
699     private @Stable static MethodHandle OBJECT_STRINGIFIER;
700     private static MethodHandle objectStringifier() {
701         MethodHandle mh = OBJECT_STRINGIFIER;
702         if (mh == null) {
<span class="line-modified">703             OBJECT_STRINGIFIER = mh = JLA.stringConcatHelper(&quot;stringOf&quot;,</span>
<span class="line-modified">704                     methodType(String.class, Object.class));</span>
705         }
706         return mh;
707     }
708     private @Stable static MethodHandle FLOAT_STRINGIFIER;
709     private static MethodHandle floatStringifier() {
710         MethodHandle mh = FLOAT_STRINGIFIER;
711         if (mh == null) {
712             FLOAT_STRINGIFIER = mh =
713                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
714         }
715         return mh;
716     }
717     private @Stable static MethodHandle DOUBLE_STRINGIFIER;
718     private static MethodHandle doubleStringifier() {
719         MethodHandle mh = DOUBLE_STRINGIFIER;
720         if (mh == null) {
721             DOUBLE_STRINGIFIER = mh =
722                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);
723         }
724         return mh;
</pre>
<hr />
<pre>
727     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
728     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPENDERS;
729     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
730     private static final long INITIAL_CODER;
731 
732     static {
733         INITIAL_CODER = JLA.stringConcatInitialCoder();
734         PREPENDERS = new ConcurrentHashMap&lt;&gt;();
735         NULL_PREPENDERS = new ConcurrentHashMap&lt;&gt;();
736         MIXERS = new ConcurrentHashMap&lt;&gt;();
737     }
738 
739     /**
740      * Returns a stringifier for references and floats/doubles only.
741      * Always returns null for other primitives.
742      *
743      * @param t class to stringify
744      * @return stringifier; null, if not available
745      */
746     private static MethodHandle stringifierFor(Class&lt;?&gt; t) {
<span class="line-modified">747         if (t == Object.class) {</span>
748             return objectStringifier();
749         } else if (t == float.class) {
750             return floatStringifier();
751         } else if (t == double.class) {
752             return doubleStringifier();
753         }
754         return null;
755     }
756 
757     private static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name,
758                                      Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
759         try {
760             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));
761         } catch (NoSuchMethodException | IllegalAccessException e) {
762             throw new AssertionError(e);
763         }
764     }
765 
766     private StringConcatFactory() {
767         // no instantiation
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../net/InetAddress.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/stream/IntStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.util.stream;
  26 
  27 import java.util.Arrays;
  28 import java.util.IntSummaryStatistics;
  29 import java.util.Objects;
  30 import java.util.OptionalDouble;
  31 import java.util.OptionalInt;
  32 import java.util.PrimitiveIterator;
  33 import java.util.Spliterator;
  34 import java.util.Spliterators;
  35 import java.util.function.BiConsumer;
  36 import java.util.function.Function;
  37 import java.util.function.IntBinaryOperator;
  38 import java.util.function.IntConsumer;
  39 import java.util.function.IntFunction;
  40 import java.util.function.IntPredicate;
  41 import java.util.function.IntSupplier;
  42 import java.util.function.IntToDoubleFunction;
  43 import java.util.function.IntToLongFunction;
  44 import java.util.function.IntUnaryOperator;
  45 import java.util.function.ObjIntConsumer;
  46 import java.util.function.Supplier;
  47 
  48 /**
  49  * A sequence of primitive int-valued elements supporting sequential and parallel
  50  * aggregate operations.  This is the {@code int} primitive specialization of
  51  * {@link Stream}.
  52  *
  53  * &lt;p&gt;The following example illustrates an aggregate operation using
  54  * {@link Stream} and {@link IntStream}, computing the sum of the weights of the
  55  * red widgets:
  56  *
  57  * &lt;pre&gt;{@code
  58  *     int sum = widgets.stream()
  59  *                      .filter(w -&gt; w.getColor() == RED)
  60  *                      .mapToInt(w -&gt; w.getWeight())
  61  *                      .sum();
  62  * }&lt;/pre&gt;
  63  *
  64  * See the class documentation for {@link Stream} and the package documentation
  65  * for &lt;a href=&quot;package-summary.html&quot;&gt;java.util.stream&lt;/a&gt; for additional
  66  * specification of streams, stream operations, stream pipelines, and
  67  * parallelism.
  68  *
  69  * @since 1.8
  70  * @see Stream
  71  * @see &lt;a href=&quot;package-summary.html&quot;&gt;java.util.stream&lt;/a&gt;
  72  */
  73 public interface IntStream extends BaseStream&lt;Integer, IntStream&gt; {
  74 
  75     /**
  76      * Returns a stream consisting of the elements of this stream that match
  77      * the given predicate.
  78      *
  79      * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate
  80      * operation&lt;/a&gt;.
  81      *
  82      * @param predicate a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
  83      *                  &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
  84      *                  predicate to apply to each element to determine if it
  85      *                  should be included
  86      * @return the new stream
  87      */
  88     IntStream filter(IntPredicate predicate);
  89 
  90     /**
  91      * Returns a stream consisting of the results of applying the given
  92      * function to the elements of this stream.
  93      *
  94      * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate
  95      * operation&lt;/a&gt;.
  96      *
  97      * @param mapper a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
  98      *               &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
  99      *               function to apply to each element
 100      * @return the new stream
 101      */
 102     IntStream map(IntUnaryOperator mapper);
 103 
 104     /**
 105      * Returns an object-valued {@code Stream} consisting of the results of
 106      * applying the given function to the elements of this stream.
 107      *
 108      * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;
 109      *     intermediate operation&lt;/a&gt;.
 110      *
 111      * @param &lt;U&gt; the element type of the new stream
 112      * @param mapper a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 113      *               &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 114      *               function to apply to each element
 115      * @return the new stream
 116      */
 117     &lt;U&gt; Stream&lt;U&gt; mapToObj(IntFunction&lt;? extends U&gt; mapper);
 118 
 119     /**
 120      * Returns a {@code LongStream} consisting of the results of applying the
 121      * given function to the elements of this stream.
 122      *
 123      * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate
 124      * operation&lt;/a&gt;.
 125      *
 126      * @param mapper a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 127      *               &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 128      *               function to apply to each element
 129      * @return the new stream
 130      */
 131     LongStream mapToLong(IntToLongFunction mapper);
 132 
 133     /**
 134      * Returns a {@code DoubleStream} consisting of the results of applying the
 135      * given function to the elements of this stream.
 136      *
 137      * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate
 138      * operation&lt;/a&gt;.
 139      *
 140      * @param mapper a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 141      *               &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 142      *               function to apply to each element
 143      * @return the new stream
 144      */
 145     DoubleStream mapToDouble(IntToDoubleFunction mapper);
 146 
 147     /**
 148      * Returns a stream consisting of the results of replacing each element of
 149      * this stream with the contents of a mapped stream produced by applying
 150      * the provided mapping function to each element.  Each mapped stream is
 151      * {@link java.util.stream.BaseStream#close() closed} after its contents
 152      * have been placed into this stream.  (If a mapped stream is {@code null}
 153      * an empty stream is used, instead.)
 154      *
 155      * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate
 156      * operation&lt;/a&gt;.
 157      *
 158      * @param mapper a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 159      *               &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 160      *               function to apply to each element which produces an
 161      *               {@code IntStream} of new values
 162      * @return the new stream
 163      * @see Stream#flatMap(Function)
 164      */
 165     IntStream flatMap(IntFunction&lt;? extends IntStream&gt; mapper);
 166 
 167     /**
 168      * Returns a stream consisting of the distinct elements of this stream.
 169      *
 170      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;stateful
 171      * intermediate operation&lt;/a&gt;.
 172      *
 173      * @return the new stream
 174      */
 175     IntStream distinct();
 176 
 177     /**
 178      * Returns a stream consisting of the elements of this stream in sorted
 179      * order.
 180      *
 181      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;stateful
 182      * intermediate operation&lt;/a&gt;.
 183      *
 184      * @return the new stream
 185      */
 186     IntStream sorted();
 187 
 188     /**
 189      * Returns a stream consisting of the elements of this stream, additionally
 190      * performing the provided action on each element as elements are consumed
 191      * from the resulting stream.
 192      *
 193      * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate
 194      * operation&lt;/a&gt;.
 195      *
 196      * &lt;p&gt;For parallel stream pipelines, the action may be called at
 197      * whatever time and in whatever thread the element is made available by the
 198      * upstream operation.  If the action modifies shared state,
 199      * it is responsible for providing the required synchronization.
 200      *
 201      * @apiNote This method exists mainly to support debugging, where you want
 202      * to see the elements as they flow past a certain point in a pipeline:
 203      * &lt;pre&gt;{@code
 204      *     IntStream.of(1, 2, 3, 4)
 205      *         .filter(e -&gt; e &gt; 2)
 206      *         .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e))
 207      *         .map(e -&gt; e * e)
 208      *         .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e))
 209      *         .sum();
 210      * }&lt;/pre&gt;
 211      *
 212      * &lt;p&gt;In cases where the stream implementation is able to optimize away the
 213      * production of some or all the elements (such as with short-circuiting
 214      * operations like {@code findFirst}, or in the example described in
 215      * {@link #count}), the action will not be invoked for those elements.
 216      *
 217      * @param action a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;
 218      *               non-interfering&lt;/a&gt; action to perform on the elements as
 219      *               they are consumed from the stream
 220      * @return the new stream
 221      */
 222     IntStream peek(IntConsumer action);
 223 
 224     /**
 225      * Returns a stream consisting of the elements of this stream, truncated
 226      * to be no longer than {@code maxSize} in length.
 227      *
 228      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;short-circuiting
 229      * stateful intermediate operation&lt;/a&gt;.
 230      *
 231      * @apiNote
 232      * While {@code limit()} is generally a cheap operation on sequential
 233      * stream pipelines, it can be quite expensive on ordered parallel pipelines,
 234      * especially for large values of {@code maxSize}, since {@code limit(n)}
 235      * is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the
 236      * &lt;em&gt;first n&lt;/em&gt; elements in the encounter order.  Using an unordered
 237      * stream source (such as {@link #generate(IntSupplier)}) or removing the
 238      * ordering constraint with {@link #unordered()} may result in significant
 239      * speedups of {@code limit()} in parallel pipelines, if the semantics of
 240      * your situation permit.  If consistency with encounter order is required,
 241      * and you are experiencing poor performance or memory utilization with
 242      * {@code limit()} in parallel pipelines, switching to sequential execution
 243      * with {@link #sequential()} may improve performance.
 244      *
 245      * @param maxSize the number of elements the stream should be limited to
 246      * @return the new stream
 247      * @throws IllegalArgumentException if {@code maxSize} is negative
 248      */
 249     IntStream limit(long maxSize);
 250 
 251     /**
 252      * Returns a stream consisting of the remaining elements of this stream
 253      * after discarding the first {@code n} elements of the stream.
 254      * If this stream contains fewer than {@code n} elements then an
 255      * empty stream will be returned.
 256      *
 257      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;stateful
 258      * intermediate operation&lt;/a&gt;.
 259      *
 260      * @apiNote
 261      * While {@code skip()} is generally a cheap operation on sequential
 262      * stream pipelines, it can be quite expensive on ordered parallel pipelines,
 263      * especially for large values of {@code n}, since {@code skip(n)}
 264      * is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the
 265      * &lt;em&gt;first n&lt;/em&gt; elements in the encounter order.  Using an unordered
 266      * stream source (such as {@link #generate(IntSupplier)}) or removing the
 267      * ordering constraint with {@link #unordered()} may result in significant
 268      * speedups of {@code skip()} in parallel pipelines, if the semantics of
 269      * your situation permit.  If consistency with encounter order is required,
 270      * and you are experiencing poor performance or memory utilization with
 271      * {@code skip()} in parallel pipelines, switching to sequential execution
 272      * with {@link #sequential()} may improve performance.
 273      *
 274      * @param n the number of leading elements to skip
 275      * @return the new stream
 276      * @throws IllegalArgumentException if {@code n} is negative
 277      */
 278     IntStream skip(long n);
 279 
 280     /**
 281      * Returns, if this stream is ordered, a stream consisting of the longest
 282      * prefix of elements taken from this stream that match the given predicate.
 283      * Otherwise returns, if this stream is unordered, a stream consisting of a
 284      * subset of elements taken from this stream that match the given predicate.
 285      *
 286      * &lt;p&gt;If this stream is ordered then the longest prefix is a contiguous
 287      * sequence of elements of this stream that match the given predicate.  The
 288      * first element of the sequence is the first element of this stream, and
 289      * the element immediately following the last element of the sequence does
 290      * not match the given predicate.
 291      *
 292      * &lt;p&gt;If this stream is unordered, and some (but not all) elements of this
 293      * stream match the given predicate, then the behavior of this operation is
 294      * nondeterministic; it is free to take any subset of matching elements
 295      * (which includes the empty set).
 296      *
 297      * &lt;p&gt;Independent of whether this stream is ordered or unordered if all
 298      * elements of this stream match the given predicate then this operation
 299      * takes all elements (the result is the same as the input), or if no
 300      * elements of the stream match the given predicate then no elements are
 301      * taken (the result is an empty stream).
 302      *
 303      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;short-circuiting
 304      * stateful intermediate operation&lt;/a&gt;.
 305      *
 306      * @implSpec
 307      * The default implementation obtains the {@link #spliterator() spliterator}
 308      * of this stream, wraps that spliterator so as to support the semantics
 309      * of this operation on traversal, and returns a new stream associated with
 310      * the wrapped spliterator.  The returned stream preserves the execution
 311      * characteristics of this stream (namely parallel or sequential execution
 312      * as per {@link #isParallel()}) but the wrapped spliterator may choose to
 313      * not support splitting.  When the returned stream is closed, the close
 314      * handlers for both the returned and this stream are invoked.
 315      *
 316      * @apiNote
 317      * While {@code takeWhile()} is generally a cheap operation on sequential
 318      * stream pipelines, it can be quite expensive on ordered parallel
 319      * pipelines, since the operation is constrained to return not just any
 320      * valid prefix, but the longest prefix of elements in the encounter order.
 321      * Using an unordered stream source (such as {@link #generate(IntSupplier)})
 322      * or removing the ordering constraint with {@link #unordered()} may result
 323      * in significant speedups of {@code takeWhile()} in parallel pipelines, if
 324      * the semantics of your situation permit.  If consistency with encounter
 325      * order is required, and you are experiencing poor performance or memory
 326      * utilization with {@code takeWhile()} in parallel pipelines, switching to
 327      * sequential execution with {@link #sequential()} may improve performance.
 328      *
 329      * @param predicate a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 330      *                  &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 331      *                  predicate to apply to elements to determine the longest
 332      *                  prefix of elements.
 333      * @return the new stream
 334      * @since 9
 335      */
 336     default IntStream takeWhile(IntPredicate predicate) {
 337         Objects.requireNonNull(predicate);
 338         // Reuses the unordered spliterator, which, when encounter is present,
 339         // is safe to use as long as it configured not to split
 340         return StreamSupport.intStream(
 341                 new WhileOps.UnorderedWhileSpliterator.OfInt.Taking(spliterator(), true, predicate),
 342                 isParallel()).onClose(this::close);
 343     }
 344 
 345     /**
 346      * Returns, if this stream is ordered, a stream consisting of the remaining
 347      * elements of this stream after dropping the longest prefix of elements
 348      * that match the given predicate.  Otherwise returns, if this stream is
 349      * unordered, a stream consisting of the remaining elements of this stream
 350      * after dropping a subset of elements that match the given predicate.
 351      *
 352      * &lt;p&gt;If this stream is ordered then the longest prefix is a contiguous
 353      * sequence of elements of this stream that match the given predicate.  The
 354      * first element of the sequence is the first element of this stream, and
 355      * the element immediately following the last element of the sequence does
 356      * not match the given predicate.
 357      *
 358      * &lt;p&gt;If this stream is unordered, and some (but not all) elements of this
 359      * stream match the given predicate, then the behavior of this operation is
 360      * nondeterministic; it is free to drop any subset of matching elements
 361      * (which includes the empty set).
 362      *
 363      * &lt;p&gt;Independent of whether this stream is ordered or unordered if all
 364      * elements of this stream match the given predicate then this operation
 365      * drops all elements (the result is an empty stream), or if no elements of
 366      * the stream match the given predicate then no elements are dropped (the
 367      * result is the same as the input).
 368      *
 369      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;stateful
 370      * intermediate operation&lt;/a&gt;.
 371      *
 372      * @implSpec
 373      * The default implementation obtains the {@link #spliterator() spliterator}
 374      * of this stream, wraps that spliterator so as to support the semantics
 375      * of this operation on traversal, and returns a new stream associated with
 376      * the wrapped spliterator.  The returned stream preserves the execution
 377      * characteristics of this stream (namely parallel or sequential execution
 378      * as per {@link #isParallel()}) but the wrapped spliterator may choose to
 379      * not support splitting.  When the returned stream is closed, the close
 380      * handlers for both the returned and this stream are invoked.
 381      *
 382      * @apiNote
 383      * While {@code dropWhile()} is generally a cheap operation on sequential
 384      * stream pipelines, it can be quite expensive on ordered parallel
 385      * pipelines, since the operation is constrained to return not just any
 386      * valid prefix, but the longest prefix of elements in the encounter order.
 387      * Using an unordered stream source (such as {@link #generate(IntSupplier)})
 388      * or removing the ordering constraint with {@link #unordered()} may result
 389      * in significant speedups of {@code dropWhile()} in parallel pipelines, if
 390      * the semantics of your situation permit.  If consistency with encounter
 391      * order is required, and you are experiencing poor performance or memory
 392      * utilization with {@code dropWhile()} in parallel pipelines, switching to
 393      * sequential execution with {@link #sequential()} may improve performance.
 394      *
 395      * @param predicate a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 396      *                  &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 397      *                  predicate to apply to elements to determine the longest
 398      *                  prefix of elements.
 399      * @return the new stream
 400      * @since 9
 401      */
 402     default IntStream dropWhile(IntPredicate predicate) {
 403         Objects.requireNonNull(predicate);
 404         // Reuses the unordered spliterator, which, when encounter is present,
 405         // is safe to use as long as it configured not to split
 406         return StreamSupport.intStream(
 407                 new WhileOps.UnorderedWhileSpliterator.OfInt.Dropping(spliterator(), true, predicate),
 408                 isParallel()).onClose(this::close);
 409     }
 410 
 411     /**
 412      * Performs an action for each element of this stream.
 413      *
 414      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal
 415      * operation&lt;/a&gt;.
 416      *
 417      * &lt;p&gt;For parallel stream pipelines, this operation does &lt;em&gt;not&lt;/em&gt;
 418      * guarantee to respect the encounter order of the stream, as doing so
 419      * would sacrifice the benefit of parallelism.  For any given element, the
 420      * action may be performed at whatever time and in whatever thread the
 421      * library chooses.  If the action accesses shared state, it is
 422      * responsible for providing the required synchronization.
 423      *
 424      * @param action a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;
 425      *               non-interfering&lt;/a&gt; action to perform on the elements
 426      */
 427     void forEach(IntConsumer action);
 428 
 429     /**
 430      * Performs an action for each element of this stream, guaranteeing that
 431      * each element is processed in encounter order for streams that have a
 432      * defined encounter order.
 433      *
 434      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal
 435      * operation&lt;/a&gt;.
 436      *
 437      * @param action a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;
 438      *               non-interfering&lt;/a&gt; action to perform on the elements
 439      * @see #forEach(IntConsumer)
 440      */
 441     void forEachOrdered(IntConsumer action);
 442 
 443     /**
 444      * Returns an array containing the elements of this stream.
 445      *
 446      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal
 447      * operation&lt;/a&gt;.
 448      *
 449      * @return an array containing the elements of this stream
 450      */
 451     int[] toArray();
 452 
 453     /**
 454      * Performs a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt; on the
 455      * elements of this stream, using the provided identity value and an
 456      * &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt;
 457      * accumulation function, and returns the reduced value.  This is equivalent
 458      * to:
 459      * &lt;pre&gt;{@code
 460      *     int result = identity;
 461      *     for (int element : this stream)
 462      *         result = accumulator.applyAsInt(result, element)
 463      *     return result;
 464      * }&lt;/pre&gt;
 465      *
 466      * but is not constrained to execute sequentially.
 467      *
 468      * &lt;p&gt;The {@code identity} value must be an identity for the accumulator
 469      * function. This means that for all {@code x},
 470      * {@code accumulator.apply(identity, x)} is equal to {@code x}.
 471      * The {@code accumulator} function must be an
 472      * &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt; function.
 473      *
 474      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal
 475      * operation&lt;/a&gt;.
 476      *
<a name="2" id="anc2"></a><span class="line-modified"> 477      * @apiNote Sum, min and max are all special cases of reduction that can be</span>
<span class="line-modified"> 478      * expressed using this method.</span>
<span class="line-added"> 479      * For example, summing a stream can be expressed as:</span>
 480      *
 481      * &lt;pre&gt;{@code
 482      *     int sum = integers.reduce(0, (a, b) -&gt; a+b);
 483      * }&lt;/pre&gt;
 484      *
 485      * or more compactly:
 486      *
 487      * &lt;pre&gt;{@code
 488      *     int sum = integers.reduce(0, Integer::sum);
 489      * }&lt;/pre&gt;
 490      *
 491      * &lt;p&gt;While this may seem a more roundabout way to perform an aggregation
 492      * compared to simply mutating a running total in a loop, reduction
 493      * operations parallelize more gracefully, without needing additional
 494      * synchronization and with greatly reduced risk of data races.
 495      *
 496      * @param identity the identity value for the accumulating function
 497      * @param op an &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt;,
 498      *           &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 499      *           &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 500      *           function for combining two values
 501      * @return the result of the reduction
 502      * @see #sum()
 503      * @see #min()
 504      * @see #max()
 505      * @see #average()
 506      */
 507     int reduce(int identity, IntBinaryOperator op);
 508 
 509     /**
 510      * Performs a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt; on the
 511      * elements of this stream, using an
 512      * &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt; accumulation
 513      * function, and returns an {@code OptionalInt} describing the reduced value,
 514      * if any. This is equivalent to:
 515      * &lt;pre&gt;{@code
 516      *     boolean foundAny = false;
 517      *     int result = null;
 518      *     for (int element : this stream) {
 519      *         if (!foundAny) {
 520      *             foundAny = true;
 521      *             result = element;
 522      *         }
 523      *         else
 524      *             result = accumulator.applyAsInt(result, element);
 525      *     }
 526      *     return foundAny ? OptionalInt.of(result) : OptionalInt.empty();
 527      * }&lt;/pre&gt;
 528      *
 529      * but is not constrained to execute sequentially.
 530      *
 531      * &lt;p&gt;The {@code accumulator} function must be an
 532      * &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt; function.
 533      *
 534      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal
 535      * operation&lt;/a&gt;.
 536      *
 537      * @param op an &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt;,
 538      *           &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 539      *           &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 540      *           function for combining two values
 541      * @return the result of the reduction
 542      * @see #reduce(int, IntBinaryOperator)
 543      */
 544     OptionalInt reduce(IntBinaryOperator op);
 545 
 546     /**
 547      * Performs a &lt;a href=&quot;package-summary.html#MutableReduction&quot;&gt;mutable
 548      * reduction&lt;/a&gt; operation on the elements of this stream.  A mutable
 549      * reduction is one in which the reduced value is a mutable result container,
 550      * such as an {@code ArrayList}, and elements are incorporated by updating
 551      * the state of the result rather than by replacing the result.  This
 552      * produces a result equivalent to:
 553      * &lt;pre&gt;{@code
 554      *     R result = supplier.get();
 555      *     for (int element : this stream)
 556      *         accumulator.accept(result, element);
 557      *     return result;
 558      * }&lt;/pre&gt;
 559      *
 560      * &lt;p&gt;Like {@link #reduce(int, IntBinaryOperator)}, {@code collect} operations
 561      * can be parallelized without requiring additional synchronization.
 562      *
 563      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal
 564      * operation&lt;/a&gt;.
 565      *
 566      * @param &lt;R&gt; the type of the mutable result container
 567      * @param supplier a function that creates a new mutable result container.
 568      *                 For a parallel execution, this function may be called
 569      *                 multiple times and must return a fresh value each time.
 570      * @param accumulator an &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt;,
 571      *                    &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 572      *                    &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 573      *                    function that must fold an element into a result
 574      *                    container.
 575      * @param combiner an &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt;,
 576      *                    &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 577      *                    &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 578      *                    function that accepts two partial result containers
 579      *                    and merges them, which must be compatible with the
 580      *                    accumulator function.  The combiner function must fold
 581      *                    the elements from the second result container into the
 582      *                    first result container.
 583      * @return the result of the reduction
 584      * @see Stream#collect(Supplier, BiConsumer, BiConsumer)
 585      */
 586     &lt;R&gt; R collect(Supplier&lt;R&gt; supplier,
 587                   ObjIntConsumer&lt;R&gt; accumulator,
 588                   BiConsumer&lt;R, R&gt; combiner);
 589 
 590     /**
 591      * Returns the sum of elements in this stream.  This is a special case
 592      * of a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt;
 593      * and is equivalent to:
 594      * &lt;pre&gt;{@code
 595      *     return reduce(0, Integer::sum);
 596      * }&lt;/pre&gt;
 597      *
 598      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal
 599      * operation&lt;/a&gt;.
 600      *
 601      * @return the sum of elements in this stream
 602      */
 603     int sum();
 604 
 605     /**
 606      * Returns an {@code OptionalInt} describing the minimum element of this
 607      * stream, or an empty optional if this stream is empty.  This is a special
 608      * case of a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt;
 609      * and is equivalent to:
 610      * &lt;pre&gt;{@code
 611      *     return reduce(Integer::min);
 612      * }&lt;/pre&gt;
 613      *
 614      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal operation&lt;/a&gt;.
 615      *
 616      * @return an {@code OptionalInt} containing the minimum element of this
 617      * stream, or an empty {@code OptionalInt} if the stream is empty
 618      */
 619     OptionalInt min();
 620 
 621     /**
 622      * Returns an {@code OptionalInt} describing the maximum element of this
 623      * stream, or an empty optional if this stream is empty.  This is a special
 624      * case of a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt;
 625      * and is equivalent to:
 626      * &lt;pre&gt;{@code
 627      *     return reduce(Integer::max);
 628      * }&lt;/pre&gt;
 629      *
 630      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal
 631      * operation&lt;/a&gt;.
 632      *
 633      * @return an {@code OptionalInt} containing the maximum element of this
 634      * stream, or an empty {@code OptionalInt} if the stream is empty
 635      */
 636     OptionalInt max();
 637 
 638     /**
 639      * Returns the count of elements in this stream.  This is a special case of
 640      * a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt; and is
 641      * equivalent to:
 642      * &lt;pre&gt;{@code
 643      *     return mapToLong(e -&gt; 1L).sum();
 644      * }&lt;/pre&gt;
 645      *
 646      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal operation&lt;/a&gt;.
 647      *
 648      * @apiNote
 649      * An implementation may choose to not execute the stream pipeline (either
 650      * sequentially or in parallel) if it is capable of computing the count
 651      * directly from the stream source.  In such cases no source elements will
 652      * be traversed and no intermediate operations will be evaluated.
 653      * Behavioral parameters with side-effects, which are strongly discouraged
 654      * except for harmless cases such as debugging, may be affected.  For
 655      * example, consider the following stream:
 656      * &lt;pre&gt;{@code
 657      *     IntStream s = IntStream.of(1, 2, 3, 4);
 658      *     long count = s.peek(System.out::println).count();
 659      * }&lt;/pre&gt;
 660      * The number of elements covered by the stream source is known and the
 661      * intermediate operation, {@code peek}, does not inject into or remove
 662      * elements from the stream (as may be the case for {@code flatMap} or
 663      * {@code filter} operations).  Thus the count is 4 and there is no need to
 664      * execute the pipeline and, as a side-effect, print out the elements.
 665      *
 666      * @return the count of elements in this stream
 667      */
 668     long count();
 669 
 670     /**
 671      * Returns an {@code OptionalDouble} describing the arithmetic mean of elements of
 672      * this stream, or an empty optional if this stream is empty.  This is a
 673      * special case of a
 674      * &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt;.
 675      *
 676      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal
 677      * operation&lt;/a&gt;.
 678      *
 679      * @return an {@code OptionalDouble} containing the average element of this
 680      * stream, or an empty optional if the stream is empty
 681      */
 682     OptionalDouble average();
 683 
 684     /**
 685      * Returns an {@code IntSummaryStatistics} describing various
 686      * summary data about the elements of this stream.  This is a special
 687      * case of a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt;.
 688      *
 689      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal
 690      * operation&lt;/a&gt;.
 691      *
 692      * @return an {@code IntSummaryStatistics} describing various summary data
 693      * about the elements of this stream
 694      */
 695     IntSummaryStatistics summaryStatistics();
 696 
 697     /**
 698      * Returns whether any elements of this stream match the provided
 699      * predicate.  May not evaluate the predicate on all elements if not
 700      * necessary for determining the result.  If the stream is empty then
 701      * {@code false} is returned and the predicate is not evaluated.
 702      *
 703      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;short-circuiting
 704      * terminal operation&lt;/a&gt;.
 705      *
 706      * @apiNote
 707      * This method evaluates the &lt;em&gt;existential quantification&lt;/em&gt; of the
 708      * predicate over the elements of the stream (for some x P(x)).
 709      *
 710      * @param predicate a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 711      *                  &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 712      *                  predicate to apply to elements of this stream
 713      * @return {@code true} if any elements of the stream match the provided
 714      * predicate, otherwise {@code false}
 715      */
 716     boolean anyMatch(IntPredicate predicate);
 717 
 718     /**
 719      * Returns whether all elements of this stream match the provided predicate.
 720      * May not evaluate the predicate on all elements if not necessary for
 721      * determining the result.  If the stream is empty then {@code true} is
 722      * returned and the predicate is not evaluated.
 723      *
 724      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;short-circuiting
 725      * terminal operation&lt;/a&gt;.
 726      *
 727      * @apiNote
 728      * This method evaluates the &lt;em&gt;universal quantification&lt;/em&gt; of the
 729      * predicate over the elements of the stream (for all x P(x)).  If the
 730      * stream is empty, the quantification is said to be &lt;em&gt;vacuously
 731      * satisfied&lt;/em&gt; and is always {@code true} (regardless of P(x)).
 732      *
 733      * @param predicate a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 734      *                  &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 735      *                  predicate to apply to elements of this stream
 736      * @return {@code true} if either all elements of the stream match the
 737      * provided predicate or the stream is empty, otherwise {@code false}
 738      */
 739     boolean allMatch(IntPredicate predicate);
 740 
 741     /**
 742      * Returns whether no elements of this stream match the provided predicate.
 743      * May not evaluate the predicate on all elements if not necessary for
 744      * determining the result.  If the stream is empty then {@code true} is
 745      * returned and the predicate is not evaluated.
 746      *
 747      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;short-circuiting
 748      * terminal operation&lt;/a&gt;.
 749      *
 750      * @apiNote
 751      * This method evaluates the &lt;em&gt;universal quantification&lt;/em&gt; of the
 752      * negated predicate over the elements of the stream (for all x ~P(x)).  If
 753      * the stream is empty, the quantification is said to be vacuously satisfied
 754      * and is always {@code true}, regardless of P(x).
 755      *
 756      * @param predicate a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,
 757      *                  &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;
 758      *                  predicate to apply to elements of this stream
 759      * @return {@code true} if either no elements of the stream match the
 760      * provided predicate or the stream is empty, otherwise {@code false}
 761      */
 762     boolean noneMatch(IntPredicate predicate);
 763 
 764     /**
 765      * Returns an {@link OptionalInt} describing the first element of this
 766      * stream, or an empty {@code OptionalInt} if the stream is empty.  If the
 767      * stream has no encounter order, then any element may be returned.
 768      *
 769      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;short-circuiting
 770      * terminal operation&lt;/a&gt;.
 771      *
 772      * @return an {@code OptionalInt} describing the first element of this stream,
 773      * or an empty {@code OptionalInt} if the stream is empty
 774      */
 775     OptionalInt findFirst();
 776 
 777     /**
 778      * Returns an {@link OptionalInt} describing some element of the stream, or
 779      * an empty {@code OptionalInt} if the stream is empty.
 780      *
 781      * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;short-circuiting
 782      * terminal operation&lt;/a&gt;.
 783      *
 784      * &lt;p&gt;The behavior of this operation is explicitly nondeterministic; it is
 785      * free to select any element in the stream.  This is to allow for maximal
 786      * performance in parallel operations; the cost is that multiple invocations
 787      * on the same source may not return the same result.  (If a stable result
 788      * is desired, use {@link #findFirst()} instead.)
 789      *
 790      * @return an {@code OptionalInt} describing some element of this stream, or
 791      * an empty {@code OptionalInt} if the stream is empty
 792      * @see #findFirst()
 793      */
 794     OptionalInt findAny();
 795 
 796     /**
 797      * Returns a {@code LongStream} consisting of the elements of this stream,
 798      * converted to {@code long}.
 799      *
 800      * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate
 801      * operation&lt;/a&gt;.
 802      *
 803      * @return a {@code LongStream} consisting of the elements of this stream,
 804      * converted to {@code long}
 805      */
 806     LongStream asLongStream();
 807 
 808     /**
 809      * Returns a {@code DoubleStream} consisting of the elements of this stream,
 810      * converted to {@code double}.
 811      *
 812      * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate
 813      * operation&lt;/a&gt;.
 814      *
 815      * @return a {@code DoubleStream} consisting of the elements of this stream,
 816      * converted to {@code double}
 817      */
 818     DoubleStream asDoubleStream();
 819 
 820     /**
 821      * Returns a {@code Stream} consisting of the elements of this stream,
 822      * each boxed to an {@code Integer}.
 823      *
 824      * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate
 825      * operation&lt;/a&gt;.
 826      *
 827      * @return a {@code Stream} consistent of the elements of this stream,
 828      * each boxed to an {@code Integer}
 829      */
 830     Stream&lt;Integer&gt; boxed();
 831 
 832     @Override
 833     IntStream sequential();
 834 
 835     @Override
 836     IntStream parallel();
 837 
 838     @Override
 839     PrimitiveIterator.OfInt iterator();
 840 
 841     @Override
 842     Spliterator.OfInt spliterator();
 843 
 844     // Static factories
 845 
 846     /**
 847      * Returns a builder for an {@code IntStream}.
 848      *
 849      * @return a stream builder
 850      */
 851     public static Builder builder() {
 852         return new Streams.IntStreamBuilderImpl();
 853     }
 854 
 855     /**
 856      * Returns an empty sequential {@code IntStream}.
 857      *
 858      * @return an empty sequential stream
 859      */
 860     public static IntStream empty() {
 861         return StreamSupport.intStream(Spliterators.emptyIntSpliterator(), false);
 862     }
 863 
 864     /**
 865      * Returns a sequential {@code IntStream} containing a single element.
 866      *
 867      * @param t the single element
 868      * @return a singleton sequential stream
 869      */
 870     public static IntStream of(int t) {
 871         return StreamSupport.intStream(new Streams.IntStreamBuilderImpl(t), false);
 872     }
 873 
 874     /**
 875      * Returns a sequential ordered stream whose elements are the specified values.
 876      *
 877      * @param values the elements of the new stream
 878      * @return the new stream
 879      */
 880     public static IntStream of(int... values) {
 881         return Arrays.stream(values);
 882     }
 883 
 884     /**
 885      * Returns an infinite sequential ordered {@code IntStream} produced by iterative
 886      * application of a function {@code f} to an initial element {@code seed},
 887      * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},
 888      * {@code f(f(seed))}, etc.
 889      *
 890      * &lt;p&gt;The first element (position {@code 0}) in the {@code IntStream} will be
 891      * the provided {@code seed}.  For {@code n &gt; 0}, the element at position
 892      * {@code n}, will be the result of applying the function {@code f} to the
 893      * element at position {@code n - 1}.
 894      *
 895      * &lt;p&gt;The action of applying {@code f} for one element
 896      * &lt;a href=&quot;../concurrent/package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt;
 897      * the action of applying {@code f} for subsequent elements.  For any given
 898      * element the action may be performed in whatever thread the library
 899      * chooses.
 900      *
 901      * @param seed the initial element
 902      * @param f a function to be applied to the previous element to produce
 903      *          a new element
 904      * @return a new sequential {@code IntStream}
 905      */
 906     public static IntStream iterate(final int seed, final IntUnaryOperator f) {
 907         Objects.requireNonNull(f);
 908         Spliterator.OfInt spliterator = new Spliterators.AbstractIntSpliterator(Long.MAX_VALUE,
 909                Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL) {
 910             int prev;
 911             boolean started;
 912 
 913             @Override
 914             public boolean tryAdvance(IntConsumer action) {
 915                 Objects.requireNonNull(action);
 916                 int t;
 917                 if (started)
 918                     t = f.applyAsInt(prev);
 919                 else {
 920                     t = seed;
 921                     started = true;
 922                 }
 923                 action.accept(prev = t);
 924                 return true;
 925             }
 926         };
 927         return StreamSupport.intStream(spliterator, false);
 928     }
 929 
 930     /**
 931      * Returns a sequential ordered {@code IntStream} produced by iterative
 932      * application of the given {@code next} function to an initial element,
 933      * conditioned on satisfying the given {@code hasNext} predicate.  The
 934      * stream terminates as soon as the {@code hasNext} predicate returns false.
 935      *
 936      * &lt;p&gt;{@code IntStream.iterate} should produce the same sequence of elements as
 937      * produced by the corresponding for-loop:
 938      * &lt;pre&gt;{@code
 939      *     for (int index=seed; hasNext.test(index); index = next.applyAsInt(index)) {
 940      *         ...
 941      *     }
 942      * }&lt;/pre&gt;
 943      *
 944      * &lt;p&gt;The resulting sequence may be empty if the {@code hasNext} predicate
 945      * does not hold on the seed value.  Otherwise the first element will be the
 946      * supplied {@code seed} value, the next element (if present) will be the
 947      * result of applying the {@code next} function to the {@code seed} value,
 948      * and so on iteratively until the {@code hasNext} predicate indicates that
 949      * the stream should terminate.
 950      *
 951      * &lt;p&gt;The action of applying the {@code hasNext} predicate to an element
 952      * &lt;a href=&quot;../concurrent/package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt;
 953      * the action of applying the {@code next} function to that element.  The
 954      * action of applying the {@code next} function for one element
 955      * &lt;i&gt;happens-before&lt;/i&gt; the action of applying the {@code hasNext}
 956      * predicate for subsequent elements.  For any given element an action may
 957      * be performed in whatever thread the library chooses.
 958      *
 959      * @param seed the initial element
 960      * @param hasNext a predicate to apply to elements to determine when the
 961      *                stream must terminate.
 962      * @param next a function to be applied to the previous element to produce
 963      *             a new element
 964      * @return a new sequential {@code IntStream}
 965      * @since 9
 966      */
 967     public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next) {
 968         Objects.requireNonNull(next);
 969         Objects.requireNonNull(hasNext);
 970         Spliterator.OfInt spliterator = new Spliterators.AbstractIntSpliterator(Long.MAX_VALUE,
 971                Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL) {
 972             int prev;
 973             boolean started, finished;
 974 
 975             @Override
 976             public boolean tryAdvance(IntConsumer action) {
 977                 Objects.requireNonNull(action);
 978                 if (finished)
 979                     return false;
 980                 int t;
 981                 if (started)
 982                     t = next.applyAsInt(prev);
 983                 else {
 984                     t = seed;
 985                     started = true;
 986                 }
 987                 if (!hasNext.test(t)) {
 988                     finished = true;
 989                     return false;
 990                 }
 991                 action.accept(prev = t);
 992                 return true;
 993             }
 994 
 995             @Override
 996             public void forEachRemaining(IntConsumer action) {
 997                 Objects.requireNonNull(action);
 998                 if (finished)
 999                     return;
1000                 finished = true;
1001                 int t = started ? next.applyAsInt(prev) : seed;
1002                 while (hasNext.test(t)) {
1003                     action.accept(t);
1004                     t = next.applyAsInt(t);
1005                 }
1006             }
1007         };
1008         return StreamSupport.intStream(spliterator, false);
1009     }
1010 
1011     /**
1012      * Returns an infinite sequential unordered stream where each element is
1013      * generated by the provided {@code IntSupplier}.  This is suitable for
1014      * generating constant streams, streams of random elements, etc.
1015      *
1016      * @param s the {@code IntSupplier} for generated elements
1017      * @return a new infinite sequential unordered {@code IntStream}
1018      */
1019     public static IntStream generate(IntSupplier s) {
1020         Objects.requireNonNull(s);
1021         return StreamSupport.intStream(
1022                 new StreamSpliterators.InfiniteSupplyingSpliterator.OfInt(Long.MAX_VALUE, s), false);
1023     }
1024 
1025     /**
1026      * Returns a sequential ordered {@code IntStream} from {@code startInclusive}
1027      * (inclusive) to {@code endExclusive} (exclusive) by an incremental step of
1028      * {@code 1}.
1029      *
1030      * @apiNote
1031      * &lt;p&gt;An equivalent sequence of increasing values can be produced
1032      * sequentially using a {@code for} loop as follows:
1033      * &lt;pre&gt;{@code
1034      *     for (int i = startInclusive; i &lt; endExclusive ; i++) { ... }
1035      * }&lt;/pre&gt;
1036      *
1037      * @param startInclusive the (inclusive) initial value
1038      * @param endExclusive the exclusive upper bound
1039      * @return a sequential {@code IntStream} for the range of {@code int}
1040      *         elements
1041      */
1042     public static IntStream range(int startInclusive, int endExclusive) {
1043         if (startInclusive &gt;= endExclusive) {
1044             return empty();
1045         } else {
1046             return StreamSupport.intStream(
1047                     new Streams.RangeIntSpliterator(startInclusive, endExclusive, false), false);
1048         }
1049     }
1050 
1051     /**
1052      * Returns a sequential ordered {@code IntStream} from {@code startInclusive}
1053      * (inclusive) to {@code endInclusive} (inclusive) by an incremental step of
1054      * {@code 1}.
1055      *
1056      * @apiNote
1057      * &lt;p&gt;An equivalent sequence of increasing values can be produced
1058      * sequentially using a {@code for} loop as follows:
1059      * &lt;pre&gt;{@code
1060      *     for (int i = startInclusive; i &lt;= endInclusive ; i++) { ... }
1061      * }&lt;/pre&gt;
1062      *
1063      * @param startInclusive the (inclusive) initial value
1064      * @param endInclusive the inclusive upper bound
1065      * @return a sequential {@code IntStream} for the range of {@code int}
1066      *         elements
1067      */
1068     public static IntStream rangeClosed(int startInclusive, int endInclusive) {
1069         if (startInclusive &gt; endInclusive) {
1070             return empty();
1071         } else {
1072             return StreamSupport.intStream(
1073                     new Streams.RangeIntSpliterator(startInclusive, endInclusive, true), false);
1074         }
1075     }
1076 
1077     /**
1078      * Creates a lazily concatenated stream whose elements are all the
1079      * elements of the first stream followed by all the elements of the
1080      * second stream.  The resulting stream is ordered if both
1081      * of the input streams are ordered, and parallel if either of the input
1082      * streams is parallel.  When the resulting stream is closed, the close
1083      * handlers for both input streams are invoked.
1084      *
1085      * &lt;p&gt;This method operates on the two input streams and binds each stream
1086      * to its source.  As a result subsequent modifications to an input stream
1087      * source may not be reflected in the concatenated stream result.
1088      *
1089      * @implNote
1090      * Use caution when constructing streams from repeated concatenation.
1091      * Accessing an element of a deeply concatenated stream can result in deep
1092      * call chains, or even {@code StackOverflowError}.
1093      *
1094      * @apiNote
1095      * To preserve optimization opportunities this method binds each stream to
1096      * its source and accepts only two streams as parameters.  For example, the
1097      * exact size of the concatenated stream source can be computed if the exact
1098      * size of each input stream source is known.
1099      * To concatenate more streams without binding, or without nested calls to
1100      * this method, try creating a stream of streams and flat-mapping with the
1101      * identity function, for example:
1102      * &lt;pre&gt;{@code
1103      *     IntStream concat = Stream.of(s1, s2, s3, s4).flatMapToInt(s -&gt; s);
1104      * }&lt;/pre&gt;
1105      *
1106      * @param a the first stream
1107      * @param b the second stream
1108      * @return the concatenation of the two input streams
1109      */
1110     public static IntStream concat(IntStream a, IntStream b) {
1111         Objects.requireNonNull(a);
1112         Objects.requireNonNull(b);
1113 
1114         Spliterator.OfInt split = new Streams.ConcatSpliterator.OfInt(
1115                 a.spliterator(), b.spliterator());
1116         IntStream stream = StreamSupport.intStream(split, a.isParallel() || b.isParallel());
1117         return stream.onClose(Streams.composedClose(a, b));
1118     }
1119 
1120     /**
1121      * A mutable builder for an {@code IntStream}.
1122      *
1123      * &lt;p&gt;A stream builder has a lifecycle, which starts in a building
1124      * phase, during which elements can be added, and then transitions to a built
1125      * phase, after which elements may not be added.  The built phase
1126      * begins when the {@link #build()} method is called, which creates an
1127      * ordered stream whose elements are the elements that were added to the
1128      * stream builder, in the order they were added.
1129      *
1130      * @see IntStream#builder()
1131      * @since 1.8
1132      */
1133     public interface Builder extends IntConsumer {
1134 
1135         /**
1136          * Adds an element to the stream being built.
1137          *
1138          * @throws IllegalStateException if the builder has already transitioned
1139          * to the built state
1140          */
1141         @Override
1142         void accept(int t);
1143 
1144         /**
1145          * Adds an element to the stream being built.
1146          *
1147          * @implSpec
1148          * The default implementation behaves as if:
1149          * &lt;pre&gt;{@code
1150          *     accept(t)
1151          *     return this;
1152          * }&lt;/pre&gt;
1153          *
1154          * @param t the element to add
1155          * @return {@code this} builder
1156          * @throws IllegalStateException if the builder has already transitioned
1157          * to the built state
1158          */
1159         default Builder add(int t) {
1160             accept(t);
1161             return this;
1162         }
1163 
1164         /**
1165          * Builds the stream, transitioning this builder to the built state.
1166          * An {@code IllegalStateException} is thrown if there are further
1167          * attempts to operate on the builder after it has entered the built
1168          * state.
1169          *
1170          * @return the built stream
1171          * @throws IllegalStateException if the builder has already transitioned to
1172          * the built state
1173          */
1174         IntStream build();
1175     }
1176 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
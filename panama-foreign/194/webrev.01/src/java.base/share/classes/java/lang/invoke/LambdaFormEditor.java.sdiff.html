<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InvokerBytecodeGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  44  *  The editor can cache derived LFs, which simplifies the reuse of their underlying bytecodes.
  45  *  To support this caching, a LF has an optional pointer to its editor.
  46  */
  47 class LambdaFormEditor {
  48     final LambdaForm lambdaForm;
  49 
  50     private LambdaFormEditor(LambdaForm lambdaForm) {
  51         this.lambdaForm = lambdaForm;
  52     }
  53 
  54     // Factory method.
  55     static LambdaFormEditor lambdaFormEditor(LambdaForm lambdaForm) {
  56         // TO DO:  Consider placing intern logic here, to cut down on duplication.
  57         // lambdaForm = findPreexistingEquivalent(lambdaForm)
  58 
  59         // Always use uncustomized version for editing.
  60         // It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
  61         return new LambdaFormEditor(lambdaForm.uncustomize());
  62     }
  63 
<span class="line-modified">  64     /** A description of a cached transform, possibly associated with the result of the transform.</span>
<span class="line-modified">  65      *  The logical content is a sequence of byte values, starting with a kind value.</span>
<span class="line-modified">  66      *  The sequence is unterminated, ending with an indefinite number of zero bytes.</span>
<span class="line-modified">  67      *  Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.</span>


























  68      */
  69     private static final class Transform extends SoftReference&lt;LambdaForm&gt; {
  70         final long packedBytes;
  71         final byte[] fullBytes;
  72 
<span class="line-modified">  73         // maybe add more for guard with test, catch exception, pointwise type conversions</span>
<span class="line-modified">  74         private static final byte</span>
<span class="line-modified">  75                 BIND_ARG = 1,</span>
<span class="line-modified">  76                 ADD_ARG = 2,</span>
<span class="line-modified">  77                 DUP_ARG = 3,</span>
<span class="line-modified">  78                 SPREAD_ARGS = 4,</span>
<span class="line-modified">  79                 FILTER_ARG = 5,</span>
<span class="line-modified">  80                 FILTER_RETURN = 6,</span>
<span class="line-modified">  81                 FILTER_RETURN_TO_ZERO = 7,</span>
<span class="line-modified">  82                 COLLECT_ARGS = 8,</span>
<span class="line-modified">  83                 COLLECT_ARGS_TO_VOID = 9,</span>
<span class="line-modified">  84                 COLLECT_ARGS_TO_ARRAY = 10,</span>
<span class="line-modified">  85                 FOLD_ARGS = 11,</span>
<span class="line-modified">  86                 FOLD_ARGS_TO_VOID = 12,</span>
<span class="line-modified">  87                 PERMUTE_ARGS = 13,</span>
<span class="line-modified">  88                 LOCAL_TYPES = 14,</span>
<span class="line-modified">  89                 FOLD_SELECT_ARGS = 15,</span>
<span class="line-modified">  90                 FOLD_SELECT_ARGS_TO_VOID = 16,</span>
<span class="line-modified">  91                 FILTER_SELECT_ARGS = 17,</span>
<span class="line-modified">  92                 REPEAT_FILTER_ARGS = 18;</span>











































































































  93 
  94         private static final boolean STRESS_TEST = false; // turn on to disable most packing
  95         private static final int
  96                 PACKED_BYTE_SIZE = (STRESS_TEST ? 2 : 4),
  97                 PACKED_BYTE_MASK = (1 &lt;&lt; PACKED_BYTE_SIZE) - 1,
  98                 PACKED_BYTE_MAX_LENGTH = (STRESS_TEST ? 3 : 64 / PACKED_BYTE_SIZE);
  99 
 100         private static long packedBytes(byte[] bytes) {
<span class="line-modified"> 101             if (bytes.length &gt; PACKED_BYTE_MAX_LENGTH)  return 0;</span>

 102             long pb = 0;
 103             int bitset = 0;
 104             for (int i = 0; i &lt; bytes.length; i++) {
 105                 int b = bytes[i] &amp; 0xFF;
 106                 bitset |= b;
 107                 pb |= (long)b &lt;&lt; (i * PACKED_BYTE_SIZE);
 108             }
 109             if (!inRange(bitset))
 110                 return 0;
 111             return pb;
 112         }
 113         private static long packedBytes(int b0, int b1) {
 114             assert(inRange(b0 | b1));
 115             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 116                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE));
 117         }
 118         private static long packedBytes(int b0, int b1, int b2) {
 119             assert(inRange(b0 | b1 | b2));
 120             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 121                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
</pre>
<hr />
<pre>
 125             assert(inRange(b0 | b1 | b2 | b3));
 126             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 127                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
 128                     | (b2 &lt;&lt; 2*PACKED_BYTE_SIZE)
 129                     | (b3 &lt;&lt; 3*PACKED_BYTE_SIZE));
 130         }
 131         private static boolean inRange(int bitset) {
 132             assert((bitset &amp; 0xFF) == bitset);  // incoming values must fit in *unsigned* byte
 133             return ((bitset &amp; ~PACKED_BYTE_MASK) == 0);
 134         }
 135         private static byte[] fullBytes(int... byteValues) {
 136             byte[] bytes = new byte[byteValues.length];
 137             int i = 0;
 138             for (int bv : byteValues) {
 139                 bytes[i++] = bval(bv);
 140             }
 141             assert(packedBytes(bytes) == 0);
 142             return bytes;
 143         }
 144 
<span class="line-removed"> 145         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {</span>
<span class="line-removed"> 146             super(result);</span>
<span class="line-removed"> 147             this.packedBytes = packedBytes;</span>
<span class="line-removed"> 148             this.fullBytes = fullBytes;</span>
<span class="line-removed"> 149         }</span>
<span class="line-removed"> 150         private Transform(long packedBytes) {</span>
<span class="line-removed"> 151             this(packedBytes, null, null);</span>
<span class="line-removed"> 152             assert(packedBytes != 0);</span>
<span class="line-removed"> 153         }</span>
<span class="line-removed"> 154         private Transform(byte[] fullBytes) {</span>
<span class="line-removed"> 155             this(0, fullBytes, null);</span>
<span class="line-removed"> 156         }</span>
<span class="line-removed"> 157 </span>
<span class="line-removed"> 158         private static byte bval(int b) {</span>
<span class="line-removed"> 159             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte</span>
<span class="line-removed"> 160             return (byte)b;</span>
<span class="line-removed"> 161         }</span>
<span class="line-removed"> 162         static Transform of(byte k, int b1) {</span>
<span class="line-removed"> 163             byte b0 = bval(k);</span>
<span class="line-removed"> 164             if (inRange(b0 | b1))</span>
<span class="line-removed"> 165                 return new Transform(packedBytes(b0, b1));</span>
<span class="line-removed"> 166             else</span>
<span class="line-removed"> 167                 return new Transform(fullBytes(b0, b1));</span>
<span class="line-removed"> 168         }</span>
<span class="line-removed"> 169         static Transform of(byte b0, int b1, int b2) {</span>
<span class="line-removed"> 170             if (inRange(b0 | b1 | b2))</span>
<span class="line-removed"> 171                 return new Transform(packedBytes(b0, b1, b2));</span>
<span class="line-removed"> 172             else</span>
<span class="line-removed"> 173                 return new Transform(fullBytes(b0, b1, b2));</span>
<span class="line-removed"> 174         }</span>
<span class="line-removed"> 175         static Transform of(byte b0, int b1, int b2, int b3) {</span>
<span class="line-removed"> 176             if (inRange(b0 | b1 | b2 | b3))</span>
<span class="line-removed"> 177                 return new Transform(packedBytes(b0, b1, b2, b3));</span>
<span class="line-removed"> 178             else</span>
<span class="line-removed"> 179                 return new Transform(fullBytes(b0, b1, b2, b3));</span>
<span class="line-removed"> 180         }</span>
<span class="line-removed"> 181         private static final byte[] NO_BYTES = {};</span>
<span class="line-removed"> 182         static Transform of(byte kind, int... b123) {</span>
<span class="line-removed"> 183             return ofBothArrays(kind, b123, NO_BYTES);</span>
<span class="line-removed"> 184         }</span>
<span class="line-removed"> 185         static Transform of(byte kind, int b1, byte[] b234) {</span>
<span class="line-removed"> 186             return ofBothArrays(kind, new int[]{ b1 }, b234);</span>
<span class="line-removed"> 187         }</span>
<span class="line-removed"> 188         static Transform of(byte kind, int b1, int b2, byte[] b345) {</span>
<span class="line-removed"> 189             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);</span>
<span class="line-removed"> 190         }</span>
<span class="line-removed"> 191         private static Transform ofBothArrays(byte kind, int[] b123, byte[] b456) {</span>
<span class="line-removed"> 192             byte[] fullBytes = new byte[1 + b123.length + b456.length];</span>
<span class="line-removed"> 193             int i = 0;</span>
<span class="line-removed"> 194             fullBytes[i++] = bval(kind);</span>
<span class="line-removed"> 195             for (int bv : b123) {</span>
<span class="line-removed"> 196                 fullBytes[i++] = bval(bv);</span>
<span class="line-removed"> 197             }</span>
<span class="line-removed"> 198             for (byte bv : b456) {</span>
<span class="line-removed"> 199                 fullBytes[i++] = bv;</span>
<span class="line-removed"> 200             }</span>
<span class="line-removed"> 201             long packedBytes = packedBytes(fullBytes);</span>
<span class="line-removed"> 202             if (packedBytes != 0)</span>
<span class="line-removed"> 203                 return new Transform(packedBytes);</span>
<span class="line-removed"> 204             else</span>
<span class="line-removed"> 205                 return new Transform(fullBytes);</span>
<span class="line-removed"> 206         }</span>
<span class="line-removed"> 207 </span>
 208         Transform withResult(LambdaForm result) {
 209             return new Transform(this.packedBytes, this.fullBytes, result);
 210         }
 211 
<span class="line-removed"> 212         @Override</span>
<span class="line-removed"> 213         public boolean equals(Object obj) {</span>
<span class="line-removed"> 214             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="line-removed"> 215         }</span>
<span class="line-removed"> 216         public boolean equals(Transform that) {</span>
<span class="line-removed"> 217             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-removed"> 218         }</span>
<span class="line-removed"> 219         @Override</span>
<span class="line-removed"> 220         public int hashCode() {</span>
<span class="line-removed"> 221             if (packedBytes != 0) {</span>
<span class="line-removed"> 222                 assert(fullBytes == null);</span>
<span class="line-removed"> 223                 return Long.hashCode(packedBytes);</span>
<span class="line-removed"> 224             }</span>
<span class="line-removed"> 225             return Arrays.hashCode(fullBytes);</span>
<span class="line-removed"> 226         }</span>
 227         @Override
 228         public String toString() {
 229             StringBuilder buf = new StringBuilder();
 230             long bits = packedBytes;
 231             if (bits != 0) {
 232                 buf.append(&quot;(&quot;);
 233                 while (bits != 0) {
 234                     buf.append(bits &amp; PACKED_BYTE_MASK);
 235                     bits &gt;&gt;&gt;= PACKED_BYTE_SIZE;
 236                     if (bits != 0)  buf.append(&quot;,&quot;);
 237                 }
 238                 buf.append(&quot;)&quot;);
 239             }
 240             if (fullBytes != null) {
 241                 buf.append(&quot;unpacked&quot;);
 242                 buf.append(Arrays.toString(fullBytes));
 243             }
<span class="line-removed"> 244             LambdaForm result = get();</span>
<span class="line-removed"> 245             if (result != null) {</span>
<span class="line-removed"> 246                 buf.append(&quot; result=&quot;);</span>
<span class="line-removed"> 247                 buf.append(result);</span>
<span class="line-removed"> 248             }</span>
 249             return buf.toString();
 250         }

























 251     }
 252 
 253     /** Find a previously cached transform equivalent to the given one, and return its result. */
<span class="line-modified"> 254     private LambdaForm getInCache(Transform key) {</span>
<span class="line-removed"> 255         assert(key.get() == null);</span>
 256         // The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
 257         Object c = lambdaForm.transformCache;
 258         Transform k = null;
 259         if (c instanceof ConcurrentHashMap) {
 260             @SuppressWarnings(&quot;unchecked&quot;)
 261             ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
 262             k = m.get(key);
 263         } else if (c == null) {
 264             return null;
 265         } else if (c instanceof Transform) {
 266             // one-element cache avoids overhead of an array
 267             Transform t = (Transform)c;
 268             if (t.equals(key))  k = t;
 269         } else {
 270             Transform[] ta = (Transform[])c;
 271             for (int i = 0; i &lt; ta.length; i++) {
 272                 Transform t = ta[i];
 273                 if (t == null)  break;
 274                 if (t.equals(key)) { k = t; break; }
 275             }
 276         }
 277         assert(k == null || key.equals(k));
 278         return (k != null) ? k.get() : null;
 279     }
 280 
 281     /** Arbitrary but reasonable limits on Transform[] size for cache. */
 282     private static final int MIN_CACHE_ARRAY_SIZE = 4, MAX_CACHE_ARRAY_SIZE = 16;
 283 
 284     /** Cache a transform with its result, and return that result.
 285      *  But if an equivalent transform has already been cached, return its result instead.
 286      */
<span class="line-modified"> 287     private LambdaForm putInCache(Transform key, LambdaForm form) {</span>
<span class="line-modified"> 288         key = key.withResult(form);</span>
 289         for (int pass = 0; ; pass++) {
 290             Object c = lambdaForm.transformCache;
 291             if (c instanceof ConcurrentHashMap) {
 292                 @SuppressWarnings(&quot;unchecked&quot;)
 293                 ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
<span class="line-modified"> 294                 Transform k = m.putIfAbsent(key, key);</span>
 295                 if (k == null) return form;
 296                 LambdaForm result = k.get();
 297                 if (result != null) {
 298                     return result;
 299                 } else {
<span class="line-modified"> 300                     if (m.replace(key, k, key)) {</span>
 301                         return form;
 302                     } else {
 303                         continue;
 304                     }
 305                 }
 306             }
 307             assert(pass == 0);
 308             synchronized (lambdaForm) {
 309                 c = lambdaForm.transformCache;
 310                 if (c instanceof ConcurrentHashMap)
 311                     continue;
 312                 if (c == null) {
<span class="line-modified"> 313                     lambdaForm.transformCache = key;</span>
 314                     return form;
 315                 }
 316                 Transform[] ta;
 317                 if (c instanceof Transform) {
 318                     Transform k = (Transform)c;
 319                     if (k.equals(key)) {
 320                         LambdaForm result = k.get();
 321                         if (result == null) {
<span class="line-modified"> 322                             lambdaForm.transformCache = key;</span>
 323                             return form;
 324                         } else {
 325                             return result;
 326                         }
 327                     } else if (k.get() == null) { // overwrite stale entry
<span class="line-modified"> 328                         lambdaForm.transformCache = key;</span>
 329                         return form;
 330                     }
 331                     // expand one-element cache to small array
 332                     ta = new Transform[MIN_CACHE_ARRAY_SIZE];
 333                     ta[0] = k;
 334                     lambdaForm.transformCache = ta;
 335                 } else {
 336                     // it is already expanded
 337                     ta = (Transform[])c;
 338                 }
 339                 int len = ta.length;
 340                 int stale = -1;
 341                 int i;
 342                 for (i = 0; i &lt; len; i++) {
 343                     Transform k = ta[i];
 344                     if (k == null) {
 345                         break;
 346                     }
<span class="line-modified"> 347                     if (k.equals(key)) {</span>
 348                         LambdaForm result = k.get();
 349                         if (result == null) {
<span class="line-modified"> 350                             ta[i] = key;</span>
 351                             return form;
 352                         } else {
 353                             return result;
 354                         }
 355                     } else if (stale &lt; 0 &amp;&amp; k.get() == null) {
 356                         stale = i; // remember 1st stale entry index
 357                     }
 358                 }
 359                 if (i &lt; len || stale &gt;= 0) {
 360                     // just fall through to cache update
 361                 } else if (len &lt; MAX_CACHE_ARRAY_SIZE) {
 362                     len = Math.min(len * 2, MAX_CACHE_ARRAY_SIZE);
 363                     ta = Arrays.copyOf(ta, len);
 364                     lambdaForm.transformCache = ta;
 365                 } else {
 366                     ConcurrentHashMap&lt;Transform, Transform&gt; m = new ConcurrentHashMap&lt;&gt;(MAX_CACHE_ARRAY_SIZE * 2);
 367                     for (Transform k : ta) {
 368                         m.put(k, k);
 369                     }
 370                     lambdaForm.transformCache = m;
 371                     // The second iteration will update for this query, concurrently.
 372                     continue;
 373                 }
 374                 int idx = (stale &gt;= 0) ? stale : i;
<span class="line-modified"> 375                 ta[idx] = key;</span>
 376                 return form;
 377             }
 378         }
 379     }
 380 
 381     private LambdaFormBuffer buffer() {
 382         return new LambdaFormBuffer(lambdaForm);
 383     }
 384 
 385     /// Editing methods for method handles.  These need to have fast paths.
 386 
 387     private BoundMethodHandle.SpeciesData oldSpeciesData() {
 388         return BoundMethodHandle.speciesDataFor(lambdaForm);
 389     }
 390 
 391     private BoundMethodHandle.SpeciesData newSpeciesData(BasicType type) {
 392         return oldSpeciesData().extendWith((byte) type.ordinal());
 393     }
 394 
 395     BoundMethodHandle bindArgumentL(BoundMethodHandle mh, int pos, Object value) {
</pre>
<hr />
<pre>
 425 
 426     BoundMethodHandle bindArgumentD(BoundMethodHandle mh, int pos, double value) {
 427         assert(mh.speciesData() == oldSpeciesData());
 428         BasicType bt = D_TYPE;
 429         MethodType type2 = bindArgumentType(mh, pos, bt);
 430         LambdaForm form2 = bindArgumentForm(1+pos);
 431         return mh.copyWithExtendD(type2, form2, value);
 432     }
 433 
 434     private MethodType bindArgumentType(BoundMethodHandle mh, int pos, BasicType bt) {
 435         assert(mh.form.uncustomize() == lambdaForm);
 436         assert(mh.form.names[1+pos].type == bt);
 437         assert(BasicType.basicType(mh.type().parameterType(pos)) == bt);
 438         return mh.type().dropParameterTypes(pos, pos+1);
 439     }
 440 
 441     /// Editing methods for lambda forms.
 442     // Each editing method can (potentially) cache the edited LF so that it can be reused later.
 443 
 444     LambdaForm bindArgumentForm(int pos) {
<span class="line-modified"> 445         Transform key = Transform.of(Transform.BIND_ARG, pos);</span>
 446         LambdaForm form = getInCache(key);
 447         if (form != null) {
 448             assert(form.parameterConstraint(0) == newSpeciesData(lambdaForm.parameterType(pos)));
 449             return form;
 450         }
 451         LambdaFormBuffer buf = buffer();
 452         buf.startEdit();
 453 
 454         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 455         BoundMethodHandle.SpeciesData newData = newSpeciesData(lambdaForm.parameterType(pos));
 456         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 457         Name newBaseAddress;
 458         NamedFunction getter = newData.getterFunction(oldData.fieldCount());
 459 
 460         if (pos != 0) {
 461             // The newly created LF will run with a different BMH.
 462             // Switch over any pre-existing BMH field references to the new BMH class.
 463             buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 464             newBaseAddress = oldBaseAddress.withConstraint(newData);
 465             buf.renameParameter(0, newBaseAddress);
 466             buf.replaceParameterByNewExpression(pos, new Name(getter, newBaseAddress));
 467         } else {
 468             // cannot bind the MH arg itself, unless oldData is empty
 469             assert(oldData == BoundMethodHandle.SPECIALIZER.topSpecies());
 470             newBaseAddress = new Name(L_TYPE).withConstraint(newData);
 471             buf.replaceParameterByNewExpression(0, new Name(getter, newBaseAddress));
 472             buf.insertParameter(0, newBaseAddress);
 473         }
 474 
 475         form = buf.endEdit();
 476         return putInCache(key, form);
 477     }
 478 
 479     LambdaForm addArgumentForm(int pos, BasicType type) {
<span class="line-modified"> 480         Transform key = Transform.of(Transform.ADD_ARG, pos, type.ordinal());</span>
 481         LambdaForm form = getInCache(key);
 482         if (form != null) {
 483             assert(form.arity == lambdaForm.arity+1);
 484             assert(form.parameterType(pos) == type);
 485             return form;
 486         }
 487         LambdaFormBuffer buf = buffer();
 488         buf.startEdit();
 489 
 490         buf.insertParameter(pos, new Name(type));
 491 
 492         form = buf.endEdit();
 493         return putInCache(key, form);
 494     }
 495 
 496     LambdaForm dupArgumentForm(int srcPos, int dstPos) {
<span class="line-modified"> 497         Transform key = Transform.of(Transform.DUP_ARG, srcPos, dstPos);</span>
 498         LambdaForm form = getInCache(key);
 499         if (form != null) {
 500             assert(form.arity == lambdaForm.arity-1);
 501             return form;
 502         }
 503         LambdaFormBuffer buf = buffer();
 504         buf.startEdit();
 505 
 506         assert(lambdaForm.parameter(srcPos).constraint == null);
 507         assert(lambdaForm.parameter(dstPos).constraint == null);
 508         buf.replaceParameterByCopy(dstPos, srcPos);
 509 
 510         form = buf.endEdit();
 511         return putInCache(key, form);
 512     }
 513 
 514     LambdaForm spreadArgumentsForm(int pos, Class&lt;?&gt; arrayType, int arrayLength) {
 515         Class&lt;?&gt; elementType = arrayType.getComponentType();
 516         Class&lt;?&gt; erasedArrayType = arrayType;
 517         if (!elementType.isPrimitive())
 518             erasedArrayType = Object[].class;
 519         BasicType bt = basicType(elementType);
 520         int elementTypeKey = bt.ordinal();
 521         if (bt.basicTypeClass() != elementType) {
 522             if (elementType.isPrimitive()) {
 523                 elementTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 524             }
 525         }
<span class="line-modified"> 526         Transform key = Transform.of(Transform.SPREAD_ARGS, pos, elementTypeKey, arrayLength);</span>
 527         LambdaForm form = getInCache(key);
 528         if (form != null) {
 529             assert(form.arity == lambdaForm.arity - arrayLength + 1);
 530             return form;
 531         }
 532         LambdaFormBuffer buf = buffer();
 533         buf.startEdit();
 534 
 535         assert(pos &lt;= MethodType.MAX_JVM_ARITY);
 536         assert(pos + arrayLength &lt;= lambdaForm.arity);
 537         assert(pos &gt; 0);  // cannot spread the MH arg itself
 538 
 539         Name spreadParam = new Name(L_TYPE);
 540         Name checkSpread = new Name(MethodHandleImpl.getFunction(MethodHandleImpl.NF_checkSpreadArgument),
 541                 spreadParam, arrayLength);
 542 
 543         // insert the new expressions
 544         int exprPos = lambdaForm.arity();
 545         buf.insertExpression(exprPos++, checkSpread);
 546         // adjust the arguments
 547         MethodHandle aload = MethodHandles.arrayElementGetter(erasedArrayType);
 548         for (int i = 0; i &lt; arrayLength; i++) {
 549             Name loadArgument = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), spreadParam, i);
 550             buf.insertExpression(exprPos + i, loadArgument);
 551             buf.replaceParameterByCopy(pos + i, exprPos + i);
 552         }
 553         buf.insertParameter(pos, spreadParam);
 554 
 555         form = buf.endEdit();
 556         return putInCache(key, form);
 557     }
 558 
 559     LambdaForm collectArgumentsForm(int pos, MethodType collectorType) {
 560         int collectorArity = collectorType.parameterCount();
 561         boolean dropResult = (collectorType.returnType() == void.class);
 562         if (collectorArity == 1 &amp;&amp; !dropResult) {
 563             return filterArgumentForm(pos, basicType(collectorType.parameterType(0)));
 564         }
<span class="line-modified"> 565         byte[] newTypes = BasicType.basicTypesOrd(collectorType.parameterArray());</span>
<span class="line-modified"> 566         byte kind = (dropResult</span>
<span class="line-removed"> 567                 ? Transform.COLLECT_ARGS_TO_VOID</span>
<span class="line-removed"> 568                 : Transform.COLLECT_ARGS);</span>
 569         if (dropResult &amp;&amp; collectorArity == 0)  pos = 1;  // pure side effect
<span class="line-modified"> 570         Transform key = Transform.of(kind, pos, collectorArity, newTypes);</span>
 571         LambdaForm form = getInCache(key);
 572         if (form != null) {
 573             assert(form.arity == lambdaForm.arity - (dropResult ? 0 : 1) + collectorArity);
 574             return form;
 575         }
 576         form = makeArgumentCombinationForm(pos, collectorType, false, dropResult);
 577         return putInCache(key, form);
 578     }
 579 
 580     LambdaForm collectArgumentArrayForm(int pos, MethodHandle arrayCollector) {
 581         MethodType collectorType = arrayCollector.type();
 582         int collectorArity = collectorType.parameterCount();
 583         assert(arrayCollector.intrinsicName() == Intrinsic.NEW_ARRAY);
 584         Class&lt;?&gt; arrayType = collectorType.returnType();
 585         Class&lt;?&gt; elementType = arrayType.getComponentType();
 586         BasicType argType = basicType(elementType);
 587         int argTypeKey = argType.ordinal();
 588         if (argType.basicTypeClass() != elementType) {
 589             // return null if it requires more metadata (like String[].class)
 590             if (!elementType.isPrimitive())
 591                 return null;
 592             argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 593         }
 594         assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));
<span class="line-modified"> 595         byte kind = Transform.COLLECT_ARGS_TO_ARRAY;</span>
<span class="line-modified"> 596         Transform key = Transform.of(kind, pos, collectorArity, argTypeKey);</span>
 597         LambdaForm form = getInCache(key);
 598         if (form != null) {
 599             assert(form.arity == lambdaForm.arity - 1 + collectorArity);
 600             return form;
 601         }
 602         LambdaFormBuffer buf = buffer();
 603         buf.startEdit();
 604 
 605         assert(pos + 1 &lt;= lambdaForm.arity);
 606         assert(pos &gt; 0);  // cannot filter the MH arg itself
 607 
 608         Name[] newParams = new Name[collectorArity];
 609         for (int i = 0; i &lt; collectorArity; i++) {
 610             newParams[i] = new Name(pos + i, argType);
 611         }
 612         Name callCombiner = new Name(new NamedFunction(arrayCollector, Intrinsic.NEW_ARRAY),
 613                                         (Object[]) /*...*/ newParams);
 614 
 615         // insert the new expression
 616         int exprPos = lambdaForm.arity();
 617         buf.insertExpression(exprPos, callCombiner);
 618 
 619         // insert new arguments
 620         int argPos = pos + 1;  // skip result parameter
 621         for (Name newParam : newParams) {
 622             buf.insertParameter(argPos++, newParam);
 623         }
 624         assert(buf.lastIndexOf(callCombiner) == exprPos+newParams.length);
 625         buf.replaceParameterByCopy(pos, exprPos+newParams.length);
 626 
 627         form = buf.endEdit();
 628         return putInCache(key, form);
 629     }
 630 
 631     LambdaForm filterArgumentForm(int pos, BasicType newType) {
<span class="line-modified"> 632         Transform key = Transform.of(Transform.FILTER_ARG, pos, newType.ordinal());</span>
 633         LambdaForm form = getInCache(key);
 634         if (form != null) {
 635             assert(form.arity == lambdaForm.arity);
 636             assert(form.parameterType(pos) == newType);
 637             return form;
 638         }
 639 
 640         BasicType oldType = lambdaForm.parameterType(pos);
 641         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 642                 newType.basicTypeClass());
 643         form = makeArgumentCombinationForm(pos, filterType, false, false);
 644         return putInCache(key, form);
 645     }
 646 
 647     /**
 648      * This creates a LF that will repeatedly invoke some unary filter function
 649      * at each of the given positions. This allows fewer LFs and BMH species
 650      * classes to be generated in typical cases compared to building up the form
 651      * by reapplying of {@code filterArgumentForm(int,BasicType)}, and should do
 652      * no worse in the worst case.
 653      */
 654     LambdaForm filterRepeatedArgumentForm(BasicType newType, int... argPositions) {
 655         assert (argPositions.length &gt; 1);
<span class="line-modified"> 656         byte[] keyArgs = new byte[argPositions.length + 2];</span>
<span class="line-removed"> 657         keyArgs[0] = Transform.REPEAT_FILTER_ARGS;</span>
<span class="line-removed"> 658         keyArgs[argPositions.length + 1] = (byte)newType.ordinal();</span>
<span class="line-removed"> 659         for (int i = 0; i &lt; argPositions.length; i++) {</span>
<span class="line-removed"> 660             keyArgs[i + 1] = (byte)argPositions[i];</span>
<span class="line-removed"> 661         }</span>
<span class="line-removed"> 662         Transform key = new Transform(keyArgs);</span>
 663         LambdaForm form = getInCache(key);
 664         if (form != null) {
 665             assert(form.arity == lambdaForm.arity &amp;&amp;
 666                     formParametersMatch(form, newType, argPositions));
 667             return form;
 668         }
 669         BasicType oldType = lambdaForm.parameterType(argPositions[0]);
 670         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 671                 newType.basicTypeClass());
 672         form = makeRepeatedFilterForm(filterType, argPositions);
 673         assert (formParametersMatch(form, newType, argPositions));
 674         return putInCache(key, form);
 675     }
 676 
 677     private boolean formParametersMatch(LambdaForm form, BasicType newType, int... argPositions) {
 678         for (int i : argPositions) {
 679             if (form.parameterType(i) != newType) {
 680                 return false;
 681             }
 682         }
</pre>
<hr />
<pre>
 855         // insert the two new expressions
 856         int exprPos = lambdaForm.arity();
 857         buf.insertExpression(exprPos+0, getCombiner);
 858         buf.insertExpression(exprPos+1, callCombiner);
 859 
 860         // insert new arguments, if needed
 861         int argPos = pos + resultArity;  // skip result parameter
 862         if (newParam != null) {
 863             buf.insertParameter(argPos++, newParam);
 864             exprPos++;
 865         }
 866         assert(buf.lastIndexOf(callCombiner) == exprPos+1);
 867         if (!dropResult) {
 868             buf.replaceParameterByCopy(pos, exprPos+1);
 869         }
 870 
 871         return buf.endEdit();
 872     }
 873 
 874     LambdaForm filterReturnForm(BasicType newType, boolean constantZero) {
<span class="line-modified"> 875         byte kind = (constantZero ? Transform.FILTER_RETURN_TO_ZERO : Transform.FILTER_RETURN);</span>
<span class="line-modified"> 876         Transform key = Transform.of(kind, newType.ordinal());</span>
 877         LambdaForm form = getInCache(key);
 878         if (form != null) {
 879             assert(form.arity == lambdaForm.arity);
 880             assert(form.returnType() == newType);
 881             return form;
 882         }
 883         LambdaFormBuffer buf = buffer();
 884         buf.startEdit();
 885 
 886         int insPos = lambdaForm.names.length;
 887         Name callFilter;
 888         if (constantZero) {
 889             // Synthesize a constant zero value for the given type.
 890             if (newType == V_TYPE)
 891                 callFilter = null;
 892             else
 893                 callFilter = new Name(constantZero(newType));
 894         } else {
 895             BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 896             BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
</pre>
<hr />
<pre>
 958         // the last filter argument is set to point at the result of the target method handle
 959         combinerArgs[combinerArity] = buf.name(lambdaForm.names.length - 1);
 960         Name callCombiner = new Name(combinerType, combinerArgs);
 961 
 962         // insert the two new expressions
 963         buf.insertExpression(exprPos, getCombiner);
 964         buf.insertExpression(exprPos + 1, callCombiner);
 965 
 966         // insert additional arguments
 967         int insPos = argPos;
 968         for (Name newParam : newParams) {
 969             buf.insertParameter(insPos++, newParam);
 970         }
 971 
 972         buf.setResult(callCombiner);
 973         return buf.endEdit();
 974     }
 975 
 976     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
 977         int combinerArity = combinerType.parameterCount();
<span class="line-modified"> 978         byte kind = (dropResult ? Transform.FOLD_ARGS_TO_VOID : Transform.FOLD_ARGS);</span>
<span class="line-modified"> 979         Transform key = Transform.of(kind, foldPos, combinerArity);</span>
 980         LambdaForm form = getInCache(key);
 981         if (form != null) {
<span class="line-modified"> 982             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_ARGS ? 1 : 0));</span>
 983             return form;
 984         }
 985         form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
 986         return putInCache(key, form);
 987     }
 988 
 989     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType, int ... argPositions) {
<span class="line-modified"> 990         byte kind = (dropResult ? Transform.FOLD_SELECT_ARGS_TO_VOID</span>
<span class="line-modified"> 991                                 : Transform.FOLD_SELECT_ARGS);</span>
<span class="line-removed"> 992         int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);</span>
<span class="line-removed"> 993         keyArgs[argPositions.length] = foldPos;</span>
<span class="line-removed"> 994         Transform key = Transform.of(kind, keyArgs);</span>
 995         LambdaForm form = getInCache(key);
 996         if (form != null) {
<span class="line-modified"> 997             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_SELECT_ARGS ? 1 : 0));</span>
 998             return form;
 999         }
1000         form = makeArgumentCombinationForm(foldPos, combinerType, argPositions, true, dropResult);
1001         return putInCache(key, form);
1002     }
1003 
1004     LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {
<span class="line-modified">1005         byte kind = Transform.FILTER_SELECT_ARGS;</span>
<span class="line-removed">1006         int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);</span>
<span class="line-removed">1007         keyArgs[argPositions.length] = filterPos;</span>
<span class="line-removed">1008         Transform key = Transform.of(kind, keyArgs);</span>
1009         LambdaForm form = getInCache(key);
1010         if (form != null) {
1011             assert(form.arity == lambdaForm.arity);
1012             return form;
1013         }
1014         form = makeArgumentCombinationForm(filterPos, combinerType, argPositions, false, false);
1015         return putInCache(key, form);
1016     }
1017 
1018     LambdaForm permuteArgumentsForm(int skip, int[] reorder) {
1019         assert(skip == 1);  // skip only the leading MH argument, names[0]
1020         int length = lambdaForm.names.length;
1021         int outArgs = reorder.length;
1022         int inTypes = 0;
1023         boolean nullPerm = true;
1024         for (int i = 0; i &lt; reorder.length; i++) {
1025             int inArg = reorder[i];
1026             if (inArg != i)  nullPerm = false;
1027             inTypes = Math.max(inTypes, inArg+1);
1028         }
1029         assert(skip + reorder.length == lambdaForm.arity);
1030         if (nullPerm)  return lambdaForm;  // do not bother to cache
<span class="line-modified">1031         Transform key = Transform.of(Transform.PERMUTE_ARGS, reorder);</span>
1032         LambdaForm form = getInCache(key);
1033         if (form != null) {
1034             assert(form.arity == skip+inTypes) : form;
1035             return form;
1036         }
1037 
1038         BasicType[] types = new BasicType[inTypes];
1039         for (int i = 0; i &lt; outArgs; i++) {
1040             int inArg = reorder[i];
1041             types[inArg] = lambdaForm.names[skip + i].type;
1042         }
1043         assert (skip + outArgs == lambdaForm.arity);
1044         assert (permutedTypesMatch(reorder, types, lambdaForm.names, skip));
1045         int pos = 0;
1046         while (pos &lt; outArgs &amp;&amp; reorder[pos] == pos) {
1047             pos += 1;
1048         }
1049         Name[] names2 = new Name[length - outArgs + inTypes];
1050         System.arraycopy(lambdaForm.names, 0, names2, 0, skip + pos);
1051         int bodyLength = length - lambdaForm.arity;
</pre>
<hr />
<pre>
1080         for (int j = lambdaForm.arity; j &lt; lambdaForm.names.length; j++) {
1081             int i = j - lambdaForm.arity + arity2;
1082             Name n = lambdaForm.names[j];
1083             Name n2 = names2[i];
1084             if (n != n2) {
1085                 for (int k = i + 1; k &lt; names2.length; k++) {
1086                     names2[k] = names2[k].replaceName(n, n2);
1087                 }
1088             }
1089         }
1090 
1091         form = new LambdaForm(arity2, names2, result2);
1092         return putInCache(key, form);
1093     }
1094 
1095     LambdaForm noteLoopLocalTypesForm(int pos, BasicType[] localTypes) {
1096         assert(lambdaForm.isLoop(pos));
1097         int[] desc = BasicType.basicTypeOrds(localTypes);
1098         desc = Arrays.copyOf(desc, desc.length + 1);
1099         desc[desc.length - 1] = pos;
<span class="line-modified">1100         Transform key = Transform.of(Transform.LOCAL_TYPES, desc);</span>
1101         LambdaForm form = getInCache(key);
1102         if (form != null) {
1103             return form;
1104         }
1105 
1106         // replace the null entry in the MHImpl.loop invocation with localTypes
1107         Name invokeLoop = lambdaForm.names[pos + 1];
1108         assert(invokeLoop.function.equals(MethodHandleImpl.getFunction(NF_loop)));
1109         Object[] args = Arrays.copyOf(invokeLoop.arguments, invokeLoop.arguments.length);
1110         assert(args[0] == null);
1111         args[0] = localTypes;
1112 
1113         LambdaFormBuffer buf = buffer();
1114         buf.startEdit();
1115         buf.changeName(pos + 1, new Name(MethodHandleImpl.getFunction(NF_loop), args));
1116         form = buf.endEdit();
1117 
1118         return putInCache(key, form);
1119     }
1120 
</pre>
</td>
<td>
<hr />
<pre>
  44  *  The editor can cache derived LFs, which simplifies the reuse of their underlying bytecodes.
  45  *  To support this caching, a LF has an optional pointer to its editor.
  46  */
  47 class LambdaFormEditor {
  48     final LambdaForm lambdaForm;
  49 
  50     private LambdaFormEditor(LambdaForm lambdaForm) {
  51         this.lambdaForm = lambdaForm;
  52     }
  53 
  54     // Factory method.
  55     static LambdaFormEditor lambdaFormEditor(LambdaForm lambdaForm) {
  56         // TO DO:  Consider placing intern logic here, to cut down on duplication.
  57         // lambdaForm = findPreexistingEquivalent(lambdaForm)
  58 
  59         // Always use uncustomized version for editing.
  60         // It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
  61         return new LambdaFormEditor(lambdaForm.uncustomize());
  62     }
  63 
<span class="line-modified">  64     // Transform types</span>
<span class="line-modified">  65     // maybe add more for guard with test, catch exception, pointwise type conversions</span>
<span class="line-modified">  66     private static final byte</span>
<span class="line-modified">  67             BIND_ARG = 1,</span>
<span class="line-added">  68             ADD_ARG = 2,</span>
<span class="line-added">  69             DUP_ARG = 3,</span>
<span class="line-added">  70             SPREAD_ARGS = 4,</span>
<span class="line-added">  71             FILTER_ARG = 5,</span>
<span class="line-added">  72             FILTER_RETURN = 6,</span>
<span class="line-added">  73             FILTER_RETURN_TO_ZERO = 7,</span>
<span class="line-added">  74             COLLECT_ARGS = 8,</span>
<span class="line-added">  75             COLLECT_ARGS_TO_VOID = 9,</span>
<span class="line-added">  76             COLLECT_ARGS_TO_ARRAY = 10,</span>
<span class="line-added">  77             FOLD_ARGS = 11,</span>
<span class="line-added">  78             FOLD_ARGS_TO_VOID = 12,</span>
<span class="line-added">  79             PERMUTE_ARGS = 13,</span>
<span class="line-added">  80             LOCAL_TYPES = 14,</span>
<span class="line-added">  81             FOLD_SELECT_ARGS = 15,</span>
<span class="line-added">  82             FOLD_SELECT_ARGS_TO_VOID = 16,</span>
<span class="line-added">  83             FILTER_SELECT_ARGS = 17,</span>
<span class="line-added">  84             REPEAT_FILTER_ARGS = 18;</span>
<span class="line-added">  85 </span>
<span class="line-added">  86     /**</span>
<span class="line-added">  87      * A description of a cached transform, possibly associated with the result of the transform.</span>
<span class="line-added">  88      * The logical content is a sequence of byte values, starting with a kind value.</span>
<span class="line-added">  89      * The sequence is unterminated, ending with an indefinite number of zero bytes.</span>
<span class="line-added">  90      * Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.</span>
<span class="line-added">  91      *</span>
<span class="line-added">  92      * Tightly coupled with the TransformKey class, which is used to lookup existing</span>
<span class="line-added">  93      * Transforms.</span>
  94      */
  95     private static final class Transform extends SoftReference&lt;LambdaForm&gt; {
  96         final long packedBytes;
  97         final byte[] fullBytes;
  98 
<span class="line-modified">  99         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {</span>
<span class="line-modified"> 100             super(result);</span>
<span class="line-modified"> 101             this.packedBytes = packedBytes;</span>
<span class="line-modified"> 102             this.fullBytes = fullBytes;</span>
<span class="line-modified"> 103         }</span>
<span class="line-modified"> 104 </span>
<span class="line-modified"> 105         @Override</span>
<span class="line-modified"> 106         public boolean equals(Object obj) {</span>
<span class="line-modified"> 107             if (obj instanceof TransformKey) {</span>
<span class="line-modified"> 108                 return equals((TransformKey) obj);</span>
<span class="line-modified"> 109             }</span>
<span class="line-modified"> 110             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="line-modified"> 111         }</span>
<span class="line-modified"> 112 </span>
<span class="line-modified"> 113         private boolean equals(TransformKey that) {</span>
<span class="line-modified"> 114             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-modified"> 115         }</span>
<span class="line-modified"> 116 </span>
<span class="line-modified"> 117         private boolean equals(Transform that) {</span>
<span class="line-modified"> 118             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-added"> 119         }</span>
<span class="line-added"> 120 </span>
<span class="line-added"> 121         @Override</span>
<span class="line-added"> 122         public int hashCode() {</span>
<span class="line-added"> 123             if (packedBytes != 0) {</span>
<span class="line-added"> 124                 assert(fullBytes == null);</span>
<span class="line-added"> 125                 return Long.hashCode(packedBytes);</span>
<span class="line-added"> 126             }</span>
<span class="line-added"> 127             return Arrays.hashCode(fullBytes);</span>
<span class="line-added"> 128         }</span>
<span class="line-added"> 129 </span>
<span class="line-added"> 130         @Override</span>
<span class="line-added"> 131         public String toString() {</span>
<span class="line-added"> 132             StringBuilder buf = new StringBuilder();</span>
<span class="line-added"> 133             buf.append(new TransformKey(packedBytes, fullBytes).toString());</span>
<span class="line-added"> 134             LambdaForm result = get();</span>
<span class="line-added"> 135             if (result != null) {</span>
<span class="line-added"> 136                 buf.append(&quot; result=&quot;);</span>
<span class="line-added"> 137                 buf.append(result);</span>
<span class="line-added"> 138             }</span>
<span class="line-added"> 139             return buf.toString();</span>
<span class="line-added"> 140         }</span>
<span class="line-added"> 141     }</span>
<span class="line-added"> 142 </span>
<span class="line-added"> 143     /**</span>
<span class="line-added"> 144      * Used as a lookup key to find existing Transforms</span>
<span class="line-added"> 145      */</span>
<span class="line-added"> 146     private static final class TransformKey {</span>
<span class="line-added"> 147         final long packedBytes;</span>
<span class="line-added"> 148         final byte[] fullBytes;</span>
<span class="line-added"> 149 </span>
<span class="line-added"> 150         private TransformKey(long packedBytes) {</span>
<span class="line-added"> 151             this.packedBytes = packedBytes;</span>
<span class="line-added"> 152             this.fullBytes = null;</span>
<span class="line-added"> 153         }</span>
<span class="line-added"> 154 </span>
<span class="line-added"> 155         private TransformKey(byte[] fullBytes) {</span>
<span class="line-added"> 156             this.fullBytes = fullBytes;</span>
<span class="line-added"> 157             this.packedBytes = 0;</span>
<span class="line-added"> 158         }</span>
<span class="line-added"> 159 </span>
<span class="line-added"> 160         private TransformKey(long packedBytes, byte[] fullBytes) {</span>
<span class="line-added"> 161             this.fullBytes = fullBytes;</span>
<span class="line-added"> 162             this.packedBytes = packedBytes;</span>
<span class="line-added"> 163         }</span>
<span class="line-added"> 164 </span>
<span class="line-added"> 165         private static byte bval(int b) {</span>
<span class="line-added"> 166             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte</span>
<span class="line-added"> 167             return (byte)b;</span>
<span class="line-added"> 168         }</span>
<span class="line-added"> 169         static TransformKey of(byte k, int b1) {</span>
<span class="line-added"> 170             byte b0 = bval(k);</span>
<span class="line-added"> 171             if (inRange(b0 | b1))</span>
<span class="line-added"> 172                 return new TransformKey(packedBytes(b0, b1));</span>
<span class="line-added"> 173             else</span>
<span class="line-added"> 174                 return new TransformKey(fullBytes(b0, b1));</span>
<span class="line-added"> 175         }</span>
<span class="line-added"> 176         static TransformKey of(byte b0, int b1, int b2) {</span>
<span class="line-added"> 177             if (inRange(b0 | b1 | b2))</span>
<span class="line-added"> 178                 return new TransformKey(packedBytes(b0, b1, b2));</span>
<span class="line-added"> 179             else</span>
<span class="line-added"> 180                 return new TransformKey(fullBytes(b0, b1, b2));</span>
<span class="line-added"> 181         }</span>
<span class="line-added"> 182         static TransformKey of(byte b0, int b1, int b2, int b3) {</span>
<span class="line-added"> 183             if (inRange(b0 | b1 | b2 | b3))</span>
<span class="line-added"> 184                 return new TransformKey(packedBytes(b0, b1, b2, b3));</span>
<span class="line-added"> 185             else</span>
<span class="line-added"> 186                 return new TransformKey(fullBytes(b0, b1, b2, b3));</span>
<span class="line-added"> 187         }</span>
<span class="line-added"> 188         private static final byte[] NO_BYTES = {};</span>
<span class="line-added"> 189         static TransformKey of(byte kind, int... b123) {</span>
<span class="line-added"> 190             return ofBothArrays(kind, b123, NO_BYTES);</span>
<span class="line-added"> 191         }</span>
<span class="line-added"> 192 </span>
<span class="line-added"> 193         static TransformKey of(byte kind, int b1, int[] b23456) {</span>
<span class="line-added"> 194             byte[] fullBytes = new byte[b23456.length + 2];</span>
<span class="line-added"> 195             fullBytes[0] = kind;</span>
<span class="line-added"> 196             fullBytes[1] = bval(b1);</span>
<span class="line-added"> 197             for (int i = 0; i &lt; b23456.length; i++) {</span>
<span class="line-added"> 198                 fullBytes[i + 2] = TransformKey.bval(b23456[i]);</span>
<span class="line-added"> 199             }</span>
<span class="line-added"> 200             long packedBytes = packedBytes(fullBytes);</span>
<span class="line-added"> 201             if (packedBytes != 0)</span>
<span class="line-added"> 202                 return new TransformKey(packedBytes);</span>
<span class="line-added"> 203             else</span>
<span class="line-added"> 204                 return new TransformKey(fullBytes);</span>
<span class="line-added"> 205         }</span>
<span class="line-added"> 206 </span>
<span class="line-added"> 207         static TransformKey of(byte kind, int b1, int b2, byte[] b345) {</span>
<span class="line-added"> 208             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);</span>
<span class="line-added"> 209         }</span>
<span class="line-added"> 210         private static TransformKey ofBothArrays(byte kind, int[] b123, byte[] b456) {</span>
<span class="line-added"> 211             byte[] fullBytes = new byte[1 + b123.length + b456.length];</span>
<span class="line-added"> 212             int i = 0;</span>
<span class="line-added"> 213             fullBytes[i++] = bval(kind);</span>
<span class="line-added"> 214             for (int bv : b123) {</span>
<span class="line-added"> 215                 fullBytes[i++] = bval(bv);</span>
<span class="line-added"> 216             }</span>
<span class="line-added"> 217             for (byte bv : b456) {</span>
<span class="line-added"> 218                 fullBytes[i++] = bv;</span>
<span class="line-added"> 219             }</span>
<span class="line-added"> 220             long packedBytes = packedBytes(fullBytes);</span>
<span class="line-added"> 221             if (packedBytes != 0)</span>
<span class="line-added"> 222                 return new TransformKey(packedBytes);</span>
<span class="line-added"> 223             else</span>
<span class="line-added"> 224                 return new TransformKey(fullBytes);</span>
<span class="line-added"> 225         }</span>
 226 
 227         private static final boolean STRESS_TEST = false; // turn on to disable most packing
 228         private static final int
 229                 PACKED_BYTE_SIZE = (STRESS_TEST ? 2 : 4),
 230                 PACKED_BYTE_MASK = (1 &lt;&lt; PACKED_BYTE_SIZE) - 1,
 231                 PACKED_BYTE_MAX_LENGTH = (STRESS_TEST ? 3 : 64 / PACKED_BYTE_SIZE);
 232 
 233         private static long packedBytes(byte[] bytes) {
<span class="line-modified"> 234             if (!inRange(bytes[0]) || bytes.length &gt; PACKED_BYTE_MAX_LENGTH)</span>
<span class="line-added"> 235                 return 0;</span>
 236             long pb = 0;
 237             int bitset = 0;
 238             for (int i = 0; i &lt; bytes.length; i++) {
 239                 int b = bytes[i] &amp; 0xFF;
 240                 bitset |= b;
 241                 pb |= (long)b &lt;&lt; (i * PACKED_BYTE_SIZE);
 242             }
 243             if (!inRange(bitset))
 244                 return 0;
 245             return pb;
 246         }
 247         private static long packedBytes(int b0, int b1) {
 248             assert(inRange(b0 | b1));
 249             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 250                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE));
 251         }
 252         private static long packedBytes(int b0, int b1, int b2) {
 253             assert(inRange(b0 | b1 | b2));
 254             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 255                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
</pre>
<hr />
<pre>
 259             assert(inRange(b0 | b1 | b2 | b3));
 260             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 261                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
 262                     | (b2 &lt;&lt; 2*PACKED_BYTE_SIZE)
 263                     | (b3 &lt;&lt; 3*PACKED_BYTE_SIZE));
 264         }
 265         private static boolean inRange(int bitset) {
 266             assert((bitset &amp; 0xFF) == bitset);  // incoming values must fit in *unsigned* byte
 267             return ((bitset &amp; ~PACKED_BYTE_MASK) == 0);
 268         }
 269         private static byte[] fullBytes(int... byteValues) {
 270             byte[] bytes = new byte[byteValues.length];
 271             int i = 0;
 272             for (int bv : byteValues) {
 273                 bytes[i++] = bval(bv);
 274             }
 275             assert(packedBytes(bytes) == 0);
 276             return bytes;
 277         }
 278 































































 279         Transform withResult(LambdaForm result) {
 280             return new Transform(this.packedBytes, this.fullBytes, result);
 281         }
 282 















 283         @Override
 284         public String toString() {
 285             StringBuilder buf = new StringBuilder();
 286             long bits = packedBytes;
 287             if (bits != 0) {
 288                 buf.append(&quot;(&quot;);
 289                 while (bits != 0) {
 290                     buf.append(bits &amp; PACKED_BYTE_MASK);
 291                     bits &gt;&gt;&gt;= PACKED_BYTE_SIZE;
 292                     if (bits != 0)  buf.append(&quot;,&quot;);
 293                 }
 294                 buf.append(&quot;)&quot;);
 295             }
 296             if (fullBytes != null) {
 297                 buf.append(&quot;unpacked&quot;);
 298                 buf.append(Arrays.toString(fullBytes));
 299             }





 300             return buf.toString();
 301         }
<span class="line-added"> 302 </span>
<span class="line-added"> 303         @Override</span>
<span class="line-added"> 304         public boolean equals(Object obj) {</span>
<span class="line-added"> 305             if (obj instanceof TransformKey) {</span>
<span class="line-added"> 306                 return equals((TransformKey) obj);</span>
<span class="line-added"> 307             }</span>
<span class="line-added"> 308             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="line-added"> 309         }</span>
<span class="line-added"> 310 </span>
<span class="line-added"> 311         private boolean equals(TransformKey that) {</span>
<span class="line-added"> 312             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-added"> 313         }</span>
<span class="line-added"> 314 </span>
<span class="line-added"> 315         private boolean equals(Transform that) {</span>
<span class="line-added"> 316             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-added"> 317         }</span>
<span class="line-added"> 318 </span>
<span class="line-added"> 319         @Override</span>
<span class="line-added"> 320         public int hashCode() {</span>
<span class="line-added"> 321             if (packedBytes != 0) {</span>
<span class="line-added"> 322                 assert(fullBytes == null);</span>
<span class="line-added"> 323                 return Long.hashCode(packedBytes);</span>
<span class="line-added"> 324             }</span>
<span class="line-added"> 325             return Arrays.hashCode(fullBytes);</span>
<span class="line-added"> 326         }</span>
 327     }
 328 
 329     /** Find a previously cached transform equivalent to the given one, and return its result. */
<span class="line-modified"> 330     private LambdaForm getInCache(TransformKey key) {</span>

 331         // The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
 332         Object c = lambdaForm.transformCache;
 333         Transform k = null;
 334         if (c instanceof ConcurrentHashMap) {
 335             @SuppressWarnings(&quot;unchecked&quot;)
 336             ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
 337             k = m.get(key);
 338         } else if (c == null) {
 339             return null;
 340         } else if (c instanceof Transform) {
 341             // one-element cache avoids overhead of an array
 342             Transform t = (Transform)c;
 343             if (t.equals(key))  k = t;
 344         } else {
 345             Transform[] ta = (Transform[])c;
 346             for (int i = 0; i &lt; ta.length; i++) {
 347                 Transform t = ta[i];
 348                 if (t == null)  break;
 349                 if (t.equals(key)) { k = t; break; }
 350             }
 351         }
 352         assert(k == null || key.equals(k));
 353         return (k != null) ? k.get() : null;
 354     }
 355 
 356     /** Arbitrary but reasonable limits on Transform[] size for cache. */
 357     private static final int MIN_CACHE_ARRAY_SIZE = 4, MAX_CACHE_ARRAY_SIZE = 16;
 358 
 359     /** Cache a transform with its result, and return that result.
 360      *  But if an equivalent transform has already been cached, return its result instead.
 361      */
<span class="line-modified"> 362     private LambdaForm putInCache(TransformKey key, LambdaForm form) {</span>
<span class="line-modified"> 363         Transform transform = key.withResult(form);</span>
 364         for (int pass = 0; ; pass++) {
 365             Object c = lambdaForm.transformCache;
 366             if (c instanceof ConcurrentHashMap) {
 367                 @SuppressWarnings(&quot;unchecked&quot;)
 368                 ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
<span class="line-modified"> 369                 Transform k = m.putIfAbsent(transform, transform);</span>
 370                 if (k == null) return form;
 371                 LambdaForm result = k.get();
 372                 if (result != null) {
 373                     return result;
 374                 } else {
<span class="line-modified"> 375                     if (m.replace(transform, k, transform)) {</span>
 376                         return form;
 377                     } else {
 378                         continue;
 379                     }
 380                 }
 381             }
 382             assert(pass == 0);
 383             synchronized (lambdaForm) {
 384                 c = lambdaForm.transformCache;
 385                 if (c instanceof ConcurrentHashMap)
 386                     continue;
 387                 if (c == null) {
<span class="line-modified"> 388                     lambdaForm.transformCache = transform;</span>
 389                     return form;
 390                 }
 391                 Transform[] ta;
 392                 if (c instanceof Transform) {
 393                     Transform k = (Transform)c;
 394                     if (k.equals(key)) {
 395                         LambdaForm result = k.get();
 396                         if (result == null) {
<span class="line-modified"> 397                             lambdaForm.transformCache = transform;</span>
 398                             return form;
 399                         } else {
 400                             return result;
 401                         }
 402                     } else if (k.get() == null) { // overwrite stale entry
<span class="line-modified"> 403                         lambdaForm.transformCache = transform;</span>
 404                         return form;
 405                     }
 406                     // expand one-element cache to small array
 407                     ta = new Transform[MIN_CACHE_ARRAY_SIZE];
 408                     ta[0] = k;
 409                     lambdaForm.transformCache = ta;
 410                 } else {
 411                     // it is already expanded
 412                     ta = (Transform[])c;
 413                 }
 414                 int len = ta.length;
 415                 int stale = -1;
 416                 int i;
 417                 for (i = 0; i &lt; len; i++) {
 418                     Transform k = ta[i];
 419                     if (k == null) {
 420                         break;
 421                     }
<span class="line-modified"> 422                     if (k.equals(transform)) {</span>
 423                         LambdaForm result = k.get();
 424                         if (result == null) {
<span class="line-modified"> 425                             ta[i] = transform;</span>
 426                             return form;
 427                         } else {
 428                             return result;
 429                         }
 430                     } else if (stale &lt; 0 &amp;&amp; k.get() == null) {
 431                         stale = i; // remember 1st stale entry index
 432                     }
 433                 }
 434                 if (i &lt; len || stale &gt;= 0) {
 435                     // just fall through to cache update
 436                 } else if (len &lt; MAX_CACHE_ARRAY_SIZE) {
 437                     len = Math.min(len * 2, MAX_CACHE_ARRAY_SIZE);
 438                     ta = Arrays.copyOf(ta, len);
 439                     lambdaForm.transformCache = ta;
 440                 } else {
 441                     ConcurrentHashMap&lt;Transform, Transform&gt; m = new ConcurrentHashMap&lt;&gt;(MAX_CACHE_ARRAY_SIZE * 2);
 442                     for (Transform k : ta) {
 443                         m.put(k, k);
 444                     }
 445                     lambdaForm.transformCache = m;
 446                     // The second iteration will update for this query, concurrently.
 447                     continue;
 448                 }
 449                 int idx = (stale &gt;= 0) ? stale : i;
<span class="line-modified"> 450                 ta[idx] = transform;</span>
 451                 return form;
 452             }
 453         }
 454     }
 455 
 456     private LambdaFormBuffer buffer() {
 457         return new LambdaFormBuffer(lambdaForm);
 458     }
 459 
 460     /// Editing methods for method handles.  These need to have fast paths.
 461 
 462     private BoundMethodHandle.SpeciesData oldSpeciesData() {
 463         return BoundMethodHandle.speciesDataFor(lambdaForm);
 464     }
 465 
 466     private BoundMethodHandle.SpeciesData newSpeciesData(BasicType type) {
 467         return oldSpeciesData().extendWith((byte) type.ordinal());
 468     }
 469 
 470     BoundMethodHandle bindArgumentL(BoundMethodHandle mh, int pos, Object value) {
</pre>
<hr />
<pre>
 500 
 501     BoundMethodHandle bindArgumentD(BoundMethodHandle mh, int pos, double value) {
 502         assert(mh.speciesData() == oldSpeciesData());
 503         BasicType bt = D_TYPE;
 504         MethodType type2 = bindArgumentType(mh, pos, bt);
 505         LambdaForm form2 = bindArgumentForm(1+pos);
 506         return mh.copyWithExtendD(type2, form2, value);
 507     }
 508 
 509     private MethodType bindArgumentType(BoundMethodHandle mh, int pos, BasicType bt) {
 510         assert(mh.form.uncustomize() == lambdaForm);
 511         assert(mh.form.names[1+pos].type == bt);
 512         assert(BasicType.basicType(mh.type().parameterType(pos)) == bt);
 513         return mh.type().dropParameterTypes(pos, pos+1);
 514     }
 515 
 516     /// Editing methods for lambda forms.
 517     // Each editing method can (potentially) cache the edited LF so that it can be reused later.
 518 
 519     LambdaForm bindArgumentForm(int pos) {
<span class="line-modified"> 520         TransformKey key = TransformKey.of(BIND_ARG, pos);</span>
 521         LambdaForm form = getInCache(key);
 522         if (form != null) {
 523             assert(form.parameterConstraint(0) == newSpeciesData(lambdaForm.parameterType(pos)));
 524             return form;
 525         }
 526         LambdaFormBuffer buf = buffer();
 527         buf.startEdit();
 528 
 529         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 530         BoundMethodHandle.SpeciesData newData = newSpeciesData(lambdaForm.parameterType(pos));
 531         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 532         Name newBaseAddress;
 533         NamedFunction getter = newData.getterFunction(oldData.fieldCount());
 534 
 535         if (pos != 0) {
 536             // The newly created LF will run with a different BMH.
 537             // Switch over any pre-existing BMH field references to the new BMH class.
 538             buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 539             newBaseAddress = oldBaseAddress.withConstraint(newData);
 540             buf.renameParameter(0, newBaseAddress);
 541             buf.replaceParameterByNewExpression(pos, new Name(getter, newBaseAddress));
 542         } else {
 543             // cannot bind the MH arg itself, unless oldData is empty
 544             assert(oldData == BoundMethodHandle.SPECIALIZER.topSpecies());
 545             newBaseAddress = new Name(L_TYPE).withConstraint(newData);
 546             buf.replaceParameterByNewExpression(0, new Name(getter, newBaseAddress));
 547             buf.insertParameter(0, newBaseAddress);
 548         }
 549 
 550         form = buf.endEdit();
 551         return putInCache(key, form);
 552     }
 553 
 554     LambdaForm addArgumentForm(int pos, BasicType type) {
<span class="line-modified"> 555         TransformKey key = TransformKey.of(ADD_ARG, pos, type.ordinal());</span>
 556         LambdaForm form = getInCache(key);
 557         if (form != null) {
 558             assert(form.arity == lambdaForm.arity+1);
 559             assert(form.parameterType(pos) == type);
 560             return form;
 561         }
 562         LambdaFormBuffer buf = buffer();
 563         buf.startEdit();
 564 
 565         buf.insertParameter(pos, new Name(type));
 566 
 567         form = buf.endEdit();
 568         return putInCache(key, form);
 569     }
 570 
 571     LambdaForm dupArgumentForm(int srcPos, int dstPos) {
<span class="line-modified"> 572         TransformKey key = TransformKey.of(DUP_ARG, srcPos, dstPos);</span>
 573         LambdaForm form = getInCache(key);
 574         if (form != null) {
 575             assert(form.arity == lambdaForm.arity-1);
 576             return form;
 577         }
 578         LambdaFormBuffer buf = buffer();
 579         buf.startEdit();
 580 
 581         assert(lambdaForm.parameter(srcPos).constraint == null);
 582         assert(lambdaForm.parameter(dstPos).constraint == null);
 583         buf.replaceParameterByCopy(dstPos, srcPos);
 584 
 585         form = buf.endEdit();
 586         return putInCache(key, form);
 587     }
 588 
 589     LambdaForm spreadArgumentsForm(int pos, Class&lt;?&gt; arrayType, int arrayLength) {
 590         Class&lt;?&gt; elementType = arrayType.getComponentType();
 591         Class&lt;?&gt; erasedArrayType = arrayType;
 592         if (!elementType.isPrimitive())
 593             erasedArrayType = Object[].class;
 594         BasicType bt = basicType(elementType);
 595         int elementTypeKey = bt.ordinal();
 596         if (bt.basicTypeClass() != elementType) {
 597             if (elementType.isPrimitive()) {
 598                 elementTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 599             }
 600         }
<span class="line-modified"> 601         TransformKey key = TransformKey.of(SPREAD_ARGS, pos, elementTypeKey, arrayLength);</span>
 602         LambdaForm form = getInCache(key);
 603         if (form != null) {
 604             assert(form.arity == lambdaForm.arity - arrayLength + 1);
 605             return form;
 606         }
 607         LambdaFormBuffer buf = buffer();
 608         buf.startEdit();
 609 
 610         assert(pos &lt;= MethodType.MAX_JVM_ARITY);
 611         assert(pos + arrayLength &lt;= lambdaForm.arity);
 612         assert(pos &gt; 0);  // cannot spread the MH arg itself
 613 
 614         Name spreadParam = new Name(L_TYPE);
 615         Name checkSpread = new Name(MethodHandleImpl.getFunction(MethodHandleImpl.NF_checkSpreadArgument),
 616                 spreadParam, arrayLength);
 617 
 618         // insert the new expressions
 619         int exprPos = lambdaForm.arity();
 620         buf.insertExpression(exprPos++, checkSpread);
 621         // adjust the arguments
 622         MethodHandle aload = MethodHandles.arrayElementGetter(erasedArrayType);
 623         for (int i = 0; i &lt; arrayLength; i++) {
 624             Name loadArgument = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), spreadParam, i);
 625             buf.insertExpression(exprPos + i, loadArgument);
 626             buf.replaceParameterByCopy(pos + i, exprPos + i);
 627         }
 628         buf.insertParameter(pos, spreadParam);
 629 
 630         form = buf.endEdit();
 631         return putInCache(key, form);
 632     }
 633 
 634     LambdaForm collectArgumentsForm(int pos, MethodType collectorType) {
 635         int collectorArity = collectorType.parameterCount();
 636         boolean dropResult = (collectorType.returnType() == void.class);
 637         if (collectorArity == 1 &amp;&amp; !dropResult) {
 638             return filterArgumentForm(pos, basicType(collectorType.parameterType(0)));
 639         }
<span class="line-modified"> 640         byte[] newTypes = BasicType.basicTypesOrd(collectorType.ptypes());</span>
<span class="line-modified"> 641         byte kind = (dropResult ? COLLECT_ARGS_TO_VOID : COLLECT_ARGS);</span>


 642         if (dropResult &amp;&amp; collectorArity == 0)  pos = 1;  // pure side effect
<span class="line-modified"> 643         TransformKey key = TransformKey.of(kind, pos, collectorArity, newTypes);</span>
 644         LambdaForm form = getInCache(key);
 645         if (form != null) {
 646             assert(form.arity == lambdaForm.arity - (dropResult ? 0 : 1) + collectorArity);
 647             return form;
 648         }
 649         form = makeArgumentCombinationForm(pos, collectorType, false, dropResult);
 650         return putInCache(key, form);
 651     }
 652 
 653     LambdaForm collectArgumentArrayForm(int pos, MethodHandle arrayCollector) {
 654         MethodType collectorType = arrayCollector.type();
 655         int collectorArity = collectorType.parameterCount();
 656         assert(arrayCollector.intrinsicName() == Intrinsic.NEW_ARRAY);
 657         Class&lt;?&gt; arrayType = collectorType.returnType();
 658         Class&lt;?&gt; elementType = arrayType.getComponentType();
 659         BasicType argType = basicType(elementType);
 660         int argTypeKey = argType.ordinal();
 661         if (argType.basicTypeClass() != elementType) {
 662             // return null if it requires more metadata (like String[].class)
 663             if (!elementType.isPrimitive())
 664                 return null;
 665             argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 666         }
 667         assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));
<span class="line-modified"> 668         byte kind = COLLECT_ARGS_TO_ARRAY;</span>
<span class="line-modified"> 669         TransformKey key = TransformKey.of(kind, pos, collectorArity, argTypeKey);</span>
 670         LambdaForm form = getInCache(key);
 671         if (form != null) {
 672             assert(form.arity == lambdaForm.arity - 1 + collectorArity);
 673             return form;
 674         }
 675         LambdaFormBuffer buf = buffer();
 676         buf.startEdit();
 677 
 678         assert(pos + 1 &lt;= lambdaForm.arity);
 679         assert(pos &gt; 0);  // cannot filter the MH arg itself
 680 
 681         Name[] newParams = new Name[collectorArity];
 682         for (int i = 0; i &lt; collectorArity; i++) {
 683             newParams[i] = new Name(pos + i, argType);
 684         }
 685         Name callCombiner = new Name(new NamedFunction(arrayCollector, Intrinsic.NEW_ARRAY),
 686                                         (Object[]) /*...*/ newParams);
 687 
 688         // insert the new expression
 689         int exprPos = lambdaForm.arity();
 690         buf.insertExpression(exprPos, callCombiner);
 691 
 692         // insert new arguments
 693         int argPos = pos + 1;  // skip result parameter
 694         for (Name newParam : newParams) {
 695             buf.insertParameter(argPos++, newParam);
 696         }
 697         assert(buf.lastIndexOf(callCombiner) == exprPos+newParams.length);
 698         buf.replaceParameterByCopy(pos, exprPos+newParams.length);
 699 
 700         form = buf.endEdit();
 701         return putInCache(key, form);
 702     }
 703 
 704     LambdaForm filterArgumentForm(int pos, BasicType newType) {
<span class="line-modified"> 705         TransformKey key = TransformKey.of(FILTER_ARG, pos, newType.ordinal());</span>
 706         LambdaForm form = getInCache(key);
 707         if (form != null) {
 708             assert(form.arity == lambdaForm.arity);
 709             assert(form.parameterType(pos) == newType);
 710             return form;
 711         }
 712 
 713         BasicType oldType = lambdaForm.parameterType(pos);
 714         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 715                 newType.basicTypeClass());
 716         form = makeArgumentCombinationForm(pos, filterType, false, false);
 717         return putInCache(key, form);
 718     }
 719 
 720     /**
 721      * This creates a LF that will repeatedly invoke some unary filter function
 722      * at each of the given positions. This allows fewer LFs and BMH species
 723      * classes to be generated in typical cases compared to building up the form
 724      * by reapplying of {@code filterArgumentForm(int,BasicType)}, and should do
 725      * no worse in the worst case.
 726      */
 727     LambdaForm filterRepeatedArgumentForm(BasicType newType, int... argPositions) {
 728         assert (argPositions.length &gt; 1);
<span class="line-modified"> 729         TransformKey key = TransformKey.of(REPEAT_FILTER_ARGS, newType.ordinal(), argPositions);</span>






 730         LambdaForm form = getInCache(key);
 731         if (form != null) {
 732             assert(form.arity == lambdaForm.arity &amp;&amp;
 733                     formParametersMatch(form, newType, argPositions));
 734             return form;
 735         }
 736         BasicType oldType = lambdaForm.parameterType(argPositions[0]);
 737         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 738                 newType.basicTypeClass());
 739         form = makeRepeatedFilterForm(filterType, argPositions);
 740         assert (formParametersMatch(form, newType, argPositions));
 741         return putInCache(key, form);
 742     }
 743 
 744     private boolean formParametersMatch(LambdaForm form, BasicType newType, int... argPositions) {
 745         for (int i : argPositions) {
 746             if (form.parameterType(i) != newType) {
 747                 return false;
 748             }
 749         }
</pre>
<hr />
<pre>
 922         // insert the two new expressions
 923         int exprPos = lambdaForm.arity();
 924         buf.insertExpression(exprPos+0, getCombiner);
 925         buf.insertExpression(exprPos+1, callCombiner);
 926 
 927         // insert new arguments, if needed
 928         int argPos = pos + resultArity;  // skip result parameter
 929         if (newParam != null) {
 930             buf.insertParameter(argPos++, newParam);
 931             exprPos++;
 932         }
 933         assert(buf.lastIndexOf(callCombiner) == exprPos+1);
 934         if (!dropResult) {
 935             buf.replaceParameterByCopy(pos, exprPos+1);
 936         }
 937 
 938         return buf.endEdit();
 939     }
 940 
 941     LambdaForm filterReturnForm(BasicType newType, boolean constantZero) {
<span class="line-modified"> 942         byte kind = (constantZero ? FILTER_RETURN_TO_ZERO : FILTER_RETURN);</span>
<span class="line-modified"> 943         TransformKey key = TransformKey.of(kind, newType.ordinal());</span>
 944         LambdaForm form = getInCache(key);
 945         if (form != null) {
 946             assert(form.arity == lambdaForm.arity);
 947             assert(form.returnType() == newType);
 948             return form;
 949         }
 950         LambdaFormBuffer buf = buffer();
 951         buf.startEdit();
 952 
 953         int insPos = lambdaForm.names.length;
 954         Name callFilter;
 955         if (constantZero) {
 956             // Synthesize a constant zero value for the given type.
 957             if (newType == V_TYPE)
 958                 callFilter = null;
 959             else
 960                 callFilter = new Name(constantZero(newType));
 961         } else {
 962             BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 963             BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
</pre>
<hr />
<pre>
1025         // the last filter argument is set to point at the result of the target method handle
1026         combinerArgs[combinerArity] = buf.name(lambdaForm.names.length - 1);
1027         Name callCombiner = new Name(combinerType, combinerArgs);
1028 
1029         // insert the two new expressions
1030         buf.insertExpression(exprPos, getCombiner);
1031         buf.insertExpression(exprPos + 1, callCombiner);
1032 
1033         // insert additional arguments
1034         int insPos = argPos;
1035         for (Name newParam : newParams) {
1036             buf.insertParameter(insPos++, newParam);
1037         }
1038 
1039         buf.setResult(callCombiner);
1040         return buf.endEdit();
1041     }
1042 
1043     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
1044         int combinerArity = combinerType.parameterCount();
<span class="line-modified">1045         byte kind = (dropResult ? FOLD_ARGS_TO_VOID : FOLD_ARGS);</span>
<span class="line-modified">1046         TransformKey key = TransformKey.of(kind, foldPos, combinerArity);</span>
1047         LambdaForm form = getInCache(key);
1048         if (form != null) {
<span class="line-modified">1049             assert(form.arity == lambdaForm.arity - (kind == FOLD_ARGS ? 1 : 0));</span>
1050             return form;
1051         }
1052         form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
1053         return putInCache(key, form);
1054     }
1055 
1056     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType, int ... argPositions) {
<span class="line-modified">1057         byte kind = (dropResult ? FOLD_SELECT_ARGS_TO_VOID : FOLD_SELECT_ARGS);</span>
<span class="line-modified">1058         TransformKey key = TransformKey.of(kind, foldPos, argPositions);</span>



1059         LambdaForm form = getInCache(key);
1060         if (form != null) {
<span class="line-modified">1061             assert(form.arity == lambdaForm.arity - (kind == FOLD_SELECT_ARGS ? 1 : 0));</span>
1062             return form;
1063         }
1064         form = makeArgumentCombinationForm(foldPos, combinerType, argPositions, true, dropResult);
1065         return putInCache(key, form);
1066     }
1067 
1068     LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {
<span class="line-modified">1069         TransformKey key = TransformKey.of(FILTER_SELECT_ARGS, filterPos, argPositions);</span>



1070         LambdaForm form = getInCache(key);
1071         if (form != null) {
1072             assert(form.arity == lambdaForm.arity);
1073             return form;
1074         }
1075         form = makeArgumentCombinationForm(filterPos, combinerType, argPositions, false, false);
1076         return putInCache(key, form);
1077     }
1078 
1079     LambdaForm permuteArgumentsForm(int skip, int[] reorder) {
1080         assert(skip == 1);  // skip only the leading MH argument, names[0]
1081         int length = lambdaForm.names.length;
1082         int outArgs = reorder.length;
1083         int inTypes = 0;
1084         boolean nullPerm = true;
1085         for (int i = 0; i &lt; reorder.length; i++) {
1086             int inArg = reorder[i];
1087             if (inArg != i)  nullPerm = false;
1088             inTypes = Math.max(inTypes, inArg+1);
1089         }
1090         assert(skip + reorder.length == lambdaForm.arity);
1091         if (nullPerm)  return lambdaForm;  // do not bother to cache
<span class="line-modified">1092         TransformKey key = TransformKey.of(PERMUTE_ARGS, reorder);</span>
1093         LambdaForm form = getInCache(key);
1094         if (form != null) {
1095             assert(form.arity == skip+inTypes) : form;
1096             return form;
1097         }
1098 
1099         BasicType[] types = new BasicType[inTypes];
1100         for (int i = 0; i &lt; outArgs; i++) {
1101             int inArg = reorder[i];
1102             types[inArg] = lambdaForm.names[skip + i].type;
1103         }
1104         assert (skip + outArgs == lambdaForm.arity);
1105         assert (permutedTypesMatch(reorder, types, lambdaForm.names, skip));
1106         int pos = 0;
1107         while (pos &lt; outArgs &amp;&amp; reorder[pos] == pos) {
1108             pos += 1;
1109         }
1110         Name[] names2 = new Name[length - outArgs + inTypes];
1111         System.arraycopy(lambdaForm.names, 0, names2, 0, skip + pos);
1112         int bodyLength = length - lambdaForm.arity;
</pre>
<hr />
<pre>
1141         for (int j = lambdaForm.arity; j &lt; lambdaForm.names.length; j++) {
1142             int i = j - lambdaForm.arity + arity2;
1143             Name n = lambdaForm.names[j];
1144             Name n2 = names2[i];
1145             if (n != n2) {
1146                 for (int k = i + 1; k &lt; names2.length; k++) {
1147                     names2[k] = names2[k].replaceName(n, n2);
1148                 }
1149             }
1150         }
1151 
1152         form = new LambdaForm(arity2, names2, result2);
1153         return putInCache(key, form);
1154     }
1155 
1156     LambdaForm noteLoopLocalTypesForm(int pos, BasicType[] localTypes) {
1157         assert(lambdaForm.isLoop(pos));
1158         int[] desc = BasicType.basicTypeOrds(localTypes);
1159         desc = Arrays.copyOf(desc, desc.length + 1);
1160         desc[desc.length - 1] = pos;
<span class="line-modified">1161         TransformKey key = TransformKey.of(LOCAL_TYPES, desc);</span>
1162         LambdaForm form = getInCache(key);
1163         if (form != null) {
1164             return form;
1165         }
1166 
1167         // replace the null entry in the MHImpl.loop invocation with localTypes
1168         Name invokeLoop = lambdaForm.names[pos + 1];
1169         assert(invokeLoop.function.equals(MethodHandleImpl.getFunction(NF_loop)));
1170         Object[] args = Arrays.copyOf(invokeLoop.arguments, invokeLoop.arguments.length);
1171         assert(args[0] == null);
1172         args[0] = localTypes;
1173 
1174         LambdaFormBuffer buf = buffer();
1175         buf.startEdit();
1176         buf.changeName(pos + 1, new Name(MethodHandleImpl.getFunction(NF_loop), args));
1177         form = buf.endEdit();
1178 
1179         return putInCache(key, form);
1180     }
1181 
</pre>
</td>
</tr>
</table>
<center><a href="InvokerBytecodeGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/cert/X509CertSelector.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="X509CRLSelector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/Arrays.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/cert/X509CertSelector.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 100     private ObjectIdentifier subjectPublicKeyAlgID;
 101     private PublicKey subjectPublicKey;
 102     private byte[] subjectPublicKeyBytes;
 103     private boolean[] keyUsage;
 104     private Set&lt;String&gt; keyPurposeSet;
 105     private Set&lt;ObjectIdentifier&gt; keyPurposeOIDSet;
 106     private Set&lt;List&lt;?&gt;&gt; subjectAlternativeNames;
 107     private Set&lt;GeneralNameInterface&gt; subjectAlternativeGeneralNames;
 108     private CertificatePolicySet policy;
 109     private Set&lt;String&gt; policySet;
 110     private Set&lt;List&lt;?&gt;&gt; pathToNames;
 111     private Set&lt;GeneralNameInterface&gt; pathToGeneralNames;
 112     private NameConstraintsExtension nc;
 113     private byte[] ncBytes;
 114     private int basicConstraints = -1;
 115     private X509Certificate x509Cert;
 116     private boolean matchAllSubjectAltNames = true;
 117 
 118     private static final Boolean FALSE = Boolean.FALSE;
 119 
<span class="line-removed"> 120     private static final int PRIVATE_KEY_USAGE_ID = 0;</span>
<span class="line-removed"> 121     private static final int SUBJECT_ALT_NAME_ID = 1;</span>
<span class="line-removed"> 122     private static final int NAME_CONSTRAINTS_ID = 2;</span>
<span class="line-removed"> 123     private static final int CERT_POLICIES_ID = 3;</span>
<span class="line-removed"> 124     private static final int EXTENDED_KEY_USAGE_ID = 4;</span>
<span class="line-removed"> 125     private static final int NUM_OF_EXTENSIONS = 5;</span>
<span class="line-removed"> 126     private static final String[] EXTENSION_OIDS = new String[NUM_OF_EXTENSIONS];</span>
<span class="line-removed"> 127 </span>
<span class="line-removed"> 128     static {</span>
<span class="line-removed"> 129         EXTENSION_OIDS[PRIVATE_KEY_USAGE_ID]  = &quot;2.5.29.16&quot;;</span>
<span class="line-removed"> 130         EXTENSION_OIDS[SUBJECT_ALT_NAME_ID]   = &quot;2.5.29.17&quot;;</span>
<span class="line-removed"> 131         EXTENSION_OIDS[NAME_CONSTRAINTS_ID]   = &quot;2.5.29.30&quot;;</span>
<span class="line-removed"> 132         EXTENSION_OIDS[CERT_POLICIES_ID]      = &quot;2.5.29.32&quot;;</span>
<span class="line-removed"> 133         EXTENSION_OIDS[EXTENDED_KEY_USAGE_ID] = &quot;2.5.29.37&quot;;</span>
<span class="line-removed"> 134     };</span>
<span class="line-removed"> 135 </span>
 136     /* Constants representing the GeneralName types */
 137     static final int NAME_ANY = 0;
 138     static final int NAME_RFC822 = 1;
 139     static final int NAME_DNS = 2;
 140     static final int NAME_X400 = 3;
 141     static final int NAME_DIRECTORY = 4;
 142     static final int NAME_EDI = 5;
 143     static final int NAME_URI = 6;
 144     static final int NAME_IP = 7;
 145     static final int NAME_OID = 8;
 146 
 147     /**
 148      * Creates an {@code X509CertSelector}. Initially, no criteria are set
 149      * so any {@code X509Certificate} will match.
 150      */
 151     public X509CertSelector() {
 152         // empty
 153     }
 154 
 155     /**
</pre>
<hr />
<pre>
1923 
1924     /**
1925      * Returns an Extension object given any X509Certificate and extension oid.
1926      * Throw an {@code IOException} if the extension byte value is
1927      * malformed.
1928      *
1929      * @param cert a {@code X509Certificate}
1930      * @param extId an {@code integer} which specifies the extension index.
1931      * Currently, the supported extensions are as follows:
1932      * index 0 - PrivateKeyUsageExtension
1933      * index 1 - SubjectAlternativeNameExtension
1934      * index 2 - NameConstraintsExtension
1935      * index 3 - CertificatePoliciesExtension
1936      * index 4 - ExtendedKeyUsageExtension
1937      * @return an {@code Extension} object whose real type is as specified
1938      * by the extension oid.
1939      * @throws IOException if cannot construct the {@code Extension}
1940      * object with the extension encoding retrieved from the passed in
1941      * {@code X509Certificate}.
1942      */
<span class="line-modified">1943     private static Extension getExtensionObject(X509Certificate cert, int extId)</span>
1944             throws IOException {
1945         if (cert instanceof X509CertImpl) {
<span class="line-modified">1946             X509CertImpl impl = (X509CertImpl)cert;</span>
1947             switch (extId) {
<span class="line-modified">1948             case PRIVATE_KEY_USAGE_ID:</span>
<span class="line-modified">1949                 return impl.getPrivateKeyUsageExtension();</span>
<span class="line-modified">1950             case SUBJECT_ALT_NAME_ID:</span>
<span class="line-modified">1951                 return impl.getSubjectAlternativeNameExtension();</span>
<span class="line-modified">1952             case NAME_CONSTRAINTS_ID:</span>
<span class="line-modified">1953                 return impl.getNameConstraintsExtension();</span>
<span class="line-modified">1954             case CERT_POLICIES_ID:</span>
<span class="line-modified">1955                 return impl.getCertificatePoliciesExtension();</span>
<span class="line-modified">1956             case EXTENDED_KEY_USAGE_ID:</span>
<span class="line-modified">1957                 return impl.getExtendedKeyUsageExtension();</span>
<span class="line-modified">1958             default:</span>
<span class="line-modified">1959                 return null;</span>
1960             }
1961         }
<span class="line-modified">1962         byte[] rawExtVal = cert.getExtensionValue(EXTENSION_OIDS[extId]);</span>
1963         if (rawExtVal == null) {
1964             return null;
1965         }
1966         DerInputStream in = new DerInputStream(rawExtVal);
1967         byte[] encoded = in.getOctetString();
1968         switch (extId) {
<span class="line-modified">1969         case PRIVATE_KEY_USAGE_ID:</span>
<span class="line-modified">1970             try {</span>
<span class="line-modified">1971                 return new PrivateKeyUsageExtension(FALSE, encoded);</span>
<span class="line-modified">1972             } catch (CertificateException ex) {</span>
<span class="line-modified">1973                 throw new IOException(ex.getMessage());</span>
<span class="line-modified">1974             }</span>
<span class="line-modified">1975         case SUBJECT_ALT_NAME_ID:</span>
<span class="line-modified">1976             return new SubjectAlternativeNameExtension(FALSE, encoded);</span>
<span class="line-modified">1977         case NAME_CONSTRAINTS_ID:</span>
<span class="line-modified">1978             return new NameConstraintsExtension(FALSE, encoded);</span>
<span class="line-modified">1979         case CERT_POLICIES_ID:</span>
<span class="line-modified">1980             return new CertificatePoliciesExtension(FALSE, encoded);</span>
<span class="line-modified">1981         case EXTENDED_KEY_USAGE_ID:</span>
<span class="line-modified">1982             return new ExtendedKeyUsageExtension(FALSE, encoded);</span>
<span class="line-modified">1983         default:</span>
<span class="line-modified">1984             return null;</span>
1985         }
1986     }
1987 
1988     /**
1989      * Decides whether a {@code Certificate} should be selected.
1990      *
1991      * @param cert the {@code Certificate} to be checked
1992      * @return {@code true} if the {@code Certificate} should be
1993      *         selected, {@code false} otherwise
1994      */
1995     public boolean match(Certificate cert) {
1996         if (!(cert instanceof X509Certificate)) {
1997             return false;
1998         }
1999         X509Certificate xcert = (X509Certificate)cert;
2000 
2001         if (debug != null) {
2002             debug.println(&quot;X509CertSelector.match(SN: &quot;
2003                 + (xcert.getSerialNumber()).toString(16) + &quot;\n  Issuer: &quot;
2004                 + xcert.getIssuerDN() + &quot;\n  Subject: &quot; + xcert.getSubjectDN()
</pre>
<hr />
<pre>
2154                 return false;
2155             }
2156         } catch (IOException ex) {
2157             if (debug != null) {
2158                 debug.println(&quot;X509CertSelector.match: &quot;
2159                     + &quot;exception in authority key ID check&quot;);
2160             }
2161             return false;
2162         }
2163         return true;
2164     }
2165 
2166     /* match on private key usage range */
2167     private boolean matchPrivateKeyValid(X509Certificate xcert) {
2168         if (privateKeyValid == null) {
2169             return true;
2170         }
2171         PrivateKeyUsageExtension ext = null;
2172         try {
2173             ext = (PrivateKeyUsageExtension)
<span class="line-modified">2174                 getExtensionObject(xcert, PRIVATE_KEY_USAGE_ID);</span>
2175             if (ext != null) {
2176                 ext.valid(privateKeyValid);
2177             }
2178         } catch (CertificateExpiredException e1) {
2179             if (debug != null) {
2180                 String time = &quot;n/a&quot;;
2181                 try {
2182                     Date notAfter = ext.get(PrivateKeyUsageExtension.NOT_AFTER);
2183                     time = notAfter.toString();
2184                 } catch (CertificateException ex) {
2185                     // not able to retrieve notAfter value
2186                 }
2187                 debug.println(&quot;X509CertSelector.match: private key usage not &quot;
2188                     + &quot;within validity date; ext.NOT_After: &quot;
2189                     + time + &quot;; X509CertSelector: &quot;
2190                     + this.toString());
2191                 e1.printStackTrace();
2192             }
2193             return false;
2194         } catch (CertificateNotYetValidException e2) {
</pre>
<hr />
<pre>
2266                     ((keyBit &gt;= certKeyUsage.length) || !certKeyUsage[keyBit])) {
2267                     if (debug != null) {
2268                         debug.println(&quot;X509CertSelector.match: &quot;
2269                             + &quot;key usage bits don&#39;t match&quot;);
2270                     }
2271                     return false;
2272                 }
2273             }
2274         }
2275         return true;
2276     }
2277 
2278     /* match on extended key usage purpose OIDs */
2279     private boolean matchExtendedKeyUsage(X509Certificate xcert) {
2280         if ((keyPurposeSet == null) || keyPurposeSet.isEmpty()) {
2281             return true;
2282         }
2283         try {
2284             ExtendedKeyUsageExtension ext =
2285                 (ExtendedKeyUsageExtension)getExtensionObject(xcert,
<span class="line-modified">2286                                                 EXTENDED_KEY_USAGE_ID);</span>
2287             if (ext != null) {
2288                 Vector&lt;ObjectIdentifier&gt; certKeyPurposeVector =
2289                     ext.get(ExtendedKeyUsageExtension.USAGES);
2290                 if (!certKeyPurposeVector.contains(ANY_EXTENDED_KEY_USAGE)
2291                         &amp;&amp; !certKeyPurposeVector.containsAll(keyPurposeOIDSet)) {
2292                     if (debug != null) {
2293                         debug.println(&quot;X509CertSelector.match: cert failed &quot;
2294                             + &quot;extendedKeyUsage criterion&quot;);
2295                     }
2296                     return false;
2297                 }
2298             }
2299         } catch (IOException ex) {
2300             if (debug != null) {
2301                 debug.println(&quot;X509CertSelector.match: &quot;
2302                     + &quot;IOException in extended key usage check&quot;);
2303             }
2304             return false;
2305         }
2306         return true;
2307     }
2308 
2309     /* match on subject alternative name extension names */
2310     private boolean matchSubjectAlternativeNames(X509Certificate xcert) {
2311         if ((subjectAlternativeNames == null) || subjectAlternativeNames.isEmpty()) {
2312             return true;
2313         }
2314         try {
2315             SubjectAlternativeNameExtension sanExt =
<span class="line-modified">2316                 (SubjectAlternativeNameExtension) getExtensionObject(xcert,</span>
<span class="line-modified">2317                                                       SUBJECT_ALT_NAME_ID);</span>
2318             if (sanExt == null) {
2319                 if (debug != null) {
2320                   debug.println(&quot;X509CertSelector.match: &quot;
2321                       + &quot;no subject alternative name extension&quot;);
2322                 }
2323                 return false;
2324             }
2325             GeneralNames certNames =
2326                     sanExt.get(SubjectAlternativeNameExtension.SUBJECT_NAME);
2327             Iterator&lt;GeneralNameInterface&gt; i =
2328                                 subjectAlternativeGeneralNames.iterator();
2329             while (i.hasNext()) {
2330                 GeneralNameInterface matchName = i.next();
2331                 boolean found = false;
2332                 for (Iterator&lt;GeneralName&gt; t = certNames.iterator();
2333                                                 t.hasNext() &amp;&amp; !found; ) {
2334                     GeneralNameInterface certName = (t.next()).getName();
2335                     found = certName.equals(matchName);
2336                 }
2337                 if (!found &amp;&amp; (matchAllSubjectAltNames || !i.hasNext())) {
</pre>
<hr />
<pre>
2366                 }
2367                 return false;
2368             }
2369         } catch (IOException e) {
2370             if (debug != null) {
2371                 debug.println(&quot;X509CertSelector.match: &quot;
2372                     + &quot;IOException in name constraints check&quot;);
2373             }
2374             return false;
2375         }
2376         return true;
2377     }
2378 
2379     /* match on policy OIDs */
2380     private boolean matchPolicy(X509Certificate xcert) {
2381         if (policy == null) {
2382             return true;
2383         }
2384         try {
2385             CertificatePoliciesExtension ext = (CertificatePoliciesExtension)
<span class="line-modified">2386                 getExtensionObject(xcert, CERT_POLICIES_ID);</span>
2387             if (ext == null) {
2388                 if (debug != null) {
2389                   debug.println(&quot;X509CertSelector.match: &quot;
2390                       + &quot;no certificate policy extension&quot;);
2391                 }
2392                 return false;
2393             }
2394             List&lt;PolicyInformation&gt; policies = ext.get(CertificatePoliciesExtension.POLICIES);
2395             /*
2396              * Convert the Vector of PolicyInformation to a Vector
2397              * of CertificatePolicyIds for easier comparison.
2398              */
2399             List&lt;CertificatePolicyId&gt; policyIDs = new ArrayList&lt;&gt;(policies.size());
2400             for (PolicyInformation info : policies) {
2401                 policyIDs.add(info.getPolicyIdentifier());
2402             }
2403             if (policy != null) {
2404                 boolean foundOne = false;
2405                 /*
2406                  * if the user passes in an empty policy Set, then
</pre>
<hr />
<pre>
2431                     }
2432                 }
2433             }
2434         } catch (IOException ex) {
2435             if (debug != null) {
2436                 debug.println(&quot;X509CertSelector.match: &quot;
2437                     + &quot;IOException in certificate policy ID check&quot;);
2438             }
2439             return false;
2440         }
2441         return true;
2442     }
2443 
2444     /* match on pathToNames */
2445     private boolean matchPathToNames(X509Certificate xcert) {
2446         if (pathToGeneralNames == null) {
2447             return true;
2448         }
2449         try {
2450             NameConstraintsExtension ext = (NameConstraintsExtension)
<span class="line-modified">2451                 getExtensionObject(xcert, NAME_CONSTRAINTS_ID);</span>
2452             if (ext == null) {
2453                 return true;
2454             }
2455             if ((debug != null) &amp;&amp; Debug.isOn(&quot;certpath&quot;)) {
2456                 debug.println(&quot;X509CertSelector.match pathToNames:\n&quot;);
2457                 Iterator&lt;GeneralNameInterface&gt; i =
2458                                         pathToGeneralNames.iterator();
2459                 while (i.hasNext()) {
2460                     debug.println(&quot;    &quot; + i.next() + &quot;\n&quot;);
2461                 }
2462             }
2463 
2464             GeneralSubtrees permitted =
2465                     ext.get(NameConstraintsExtension.PERMITTED_SUBTREES);
2466             GeneralSubtrees excluded =
2467                     ext.get(NameConstraintsExtension.EXCLUDED_SUBTREES);
2468             if (excluded != null) {
2469                 if (matchExcluded(excluded) == false) {
2470                     return false;
2471                 }
</pre>
</td>
<td>
<hr />
<pre>
 100     private ObjectIdentifier subjectPublicKeyAlgID;
 101     private PublicKey subjectPublicKey;
 102     private byte[] subjectPublicKeyBytes;
 103     private boolean[] keyUsage;
 104     private Set&lt;String&gt; keyPurposeSet;
 105     private Set&lt;ObjectIdentifier&gt; keyPurposeOIDSet;
 106     private Set&lt;List&lt;?&gt;&gt; subjectAlternativeNames;
 107     private Set&lt;GeneralNameInterface&gt; subjectAlternativeGeneralNames;
 108     private CertificatePolicySet policy;
 109     private Set&lt;String&gt; policySet;
 110     private Set&lt;List&lt;?&gt;&gt; pathToNames;
 111     private Set&lt;GeneralNameInterface&gt; pathToGeneralNames;
 112     private NameConstraintsExtension nc;
 113     private byte[] ncBytes;
 114     private int basicConstraints = -1;
 115     private X509Certificate x509Cert;
 116     private boolean matchAllSubjectAltNames = true;
 117 
 118     private static final Boolean FALSE = Boolean.FALSE;
 119 
















 120     /* Constants representing the GeneralName types */
 121     static final int NAME_ANY = 0;
 122     static final int NAME_RFC822 = 1;
 123     static final int NAME_DNS = 2;
 124     static final int NAME_X400 = 3;
 125     static final int NAME_DIRECTORY = 4;
 126     static final int NAME_EDI = 5;
 127     static final int NAME_URI = 6;
 128     static final int NAME_IP = 7;
 129     static final int NAME_OID = 8;
 130 
 131     /**
 132      * Creates an {@code X509CertSelector}. Initially, no criteria are set
 133      * so any {@code X509Certificate} will match.
 134      */
 135     public X509CertSelector() {
 136         // empty
 137     }
 138 
 139     /**
</pre>
<hr />
<pre>
1907 
1908     /**
1909      * Returns an Extension object given any X509Certificate and extension oid.
1910      * Throw an {@code IOException} if the extension byte value is
1911      * malformed.
1912      *
1913      * @param cert a {@code X509Certificate}
1914      * @param extId an {@code integer} which specifies the extension index.
1915      * Currently, the supported extensions are as follows:
1916      * index 0 - PrivateKeyUsageExtension
1917      * index 1 - SubjectAlternativeNameExtension
1918      * index 2 - NameConstraintsExtension
1919      * index 3 - CertificatePoliciesExtension
1920      * index 4 - ExtendedKeyUsageExtension
1921      * @return an {@code Extension} object whose real type is as specified
1922      * by the extension oid.
1923      * @throws IOException if cannot construct the {@code Extension}
1924      * object with the extension encoding retrieved from the passed in
1925      * {@code X509Certificate}.
1926      */
<span class="line-modified">1927     private static Extension getExtensionObject(X509Certificate cert, KnownOIDs extId)</span>
1928             throws IOException {
1929         if (cert instanceof X509CertImpl) {
<span class="line-modified">1930             X509CertImpl impl = (X509CertImpl) cert;</span>
1931             switch (extId) {
<span class="line-modified">1932                 case PrivateKeyUsage:</span>
<span class="line-modified">1933                     return impl.getPrivateKeyUsageExtension();</span>
<span class="line-modified">1934                 case SubjectAlternativeName:</span>
<span class="line-modified">1935                     return impl.getSubjectAlternativeNameExtension();</span>
<span class="line-modified">1936                 case NameConstraints:</span>
<span class="line-modified">1937                     return impl.getNameConstraintsExtension();</span>
<span class="line-modified">1938                 case CertificatePolicies:</span>
<span class="line-modified">1939                     return impl.getCertificatePoliciesExtension();</span>
<span class="line-modified">1940                 case extendedKeyUsage:</span>
<span class="line-modified">1941                     return impl.getExtendedKeyUsageExtension();</span>
<span class="line-modified">1942                 default:</span>
<span class="line-modified">1943                     return null;</span>
1944             }
1945         }
<span class="line-modified">1946         byte[] rawExtVal = cert.getExtensionValue(extId.value());</span>
1947         if (rawExtVal == null) {
1948             return null;
1949         }
1950         DerInputStream in = new DerInputStream(rawExtVal);
1951         byte[] encoded = in.getOctetString();
1952         switch (extId) {
<span class="line-modified">1953             case PrivateKeyUsage:</span>
<span class="line-modified">1954                 try {</span>
<span class="line-modified">1955                     return new PrivateKeyUsageExtension(FALSE, encoded);</span>
<span class="line-modified">1956                 } catch (CertificateException ex) {</span>
<span class="line-modified">1957                     throw new IOException(ex.getMessage());</span>
<span class="line-modified">1958                 }</span>
<span class="line-modified">1959             case SubjectAlternativeName:</span>
<span class="line-modified">1960                 return new SubjectAlternativeNameExtension(FALSE, encoded);</span>
<span class="line-modified">1961             case NameConstraints:</span>
<span class="line-modified">1962                 return new NameConstraintsExtension(FALSE, encoded);</span>
<span class="line-modified">1963             case CertificatePolicies:</span>
<span class="line-modified">1964                 return new CertificatePoliciesExtension(FALSE, encoded);</span>
<span class="line-modified">1965             case extendedKeyUsage:</span>
<span class="line-modified">1966                 return new ExtendedKeyUsageExtension(FALSE, encoded);</span>
<span class="line-modified">1967             default:</span>
<span class="line-modified">1968                 return null;</span>
1969         }
1970     }
1971 
1972     /**
1973      * Decides whether a {@code Certificate} should be selected.
1974      *
1975      * @param cert the {@code Certificate} to be checked
1976      * @return {@code true} if the {@code Certificate} should be
1977      *         selected, {@code false} otherwise
1978      */
1979     public boolean match(Certificate cert) {
1980         if (!(cert instanceof X509Certificate)) {
1981             return false;
1982         }
1983         X509Certificate xcert = (X509Certificate)cert;
1984 
1985         if (debug != null) {
1986             debug.println(&quot;X509CertSelector.match(SN: &quot;
1987                 + (xcert.getSerialNumber()).toString(16) + &quot;\n  Issuer: &quot;
1988                 + xcert.getIssuerDN() + &quot;\n  Subject: &quot; + xcert.getSubjectDN()
</pre>
<hr />
<pre>
2138                 return false;
2139             }
2140         } catch (IOException ex) {
2141             if (debug != null) {
2142                 debug.println(&quot;X509CertSelector.match: &quot;
2143                     + &quot;exception in authority key ID check&quot;);
2144             }
2145             return false;
2146         }
2147         return true;
2148     }
2149 
2150     /* match on private key usage range */
2151     private boolean matchPrivateKeyValid(X509Certificate xcert) {
2152         if (privateKeyValid == null) {
2153             return true;
2154         }
2155         PrivateKeyUsageExtension ext = null;
2156         try {
2157             ext = (PrivateKeyUsageExtension)
<span class="line-modified">2158                 getExtensionObject(xcert, KnownOIDs.PrivateKeyUsage);</span>
2159             if (ext != null) {
2160                 ext.valid(privateKeyValid);
2161             }
2162         } catch (CertificateExpiredException e1) {
2163             if (debug != null) {
2164                 String time = &quot;n/a&quot;;
2165                 try {
2166                     Date notAfter = ext.get(PrivateKeyUsageExtension.NOT_AFTER);
2167                     time = notAfter.toString();
2168                 } catch (CertificateException ex) {
2169                     // not able to retrieve notAfter value
2170                 }
2171                 debug.println(&quot;X509CertSelector.match: private key usage not &quot;
2172                     + &quot;within validity date; ext.NOT_After: &quot;
2173                     + time + &quot;; X509CertSelector: &quot;
2174                     + this.toString());
2175                 e1.printStackTrace();
2176             }
2177             return false;
2178         } catch (CertificateNotYetValidException e2) {
</pre>
<hr />
<pre>
2250                     ((keyBit &gt;= certKeyUsage.length) || !certKeyUsage[keyBit])) {
2251                     if (debug != null) {
2252                         debug.println(&quot;X509CertSelector.match: &quot;
2253                             + &quot;key usage bits don&#39;t match&quot;);
2254                     }
2255                     return false;
2256                 }
2257             }
2258         }
2259         return true;
2260     }
2261 
2262     /* match on extended key usage purpose OIDs */
2263     private boolean matchExtendedKeyUsage(X509Certificate xcert) {
2264         if ((keyPurposeSet == null) || keyPurposeSet.isEmpty()) {
2265             return true;
2266         }
2267         try {
2268             ExtendedKeyUsageExtension ext =
2269                 (ExtendedKeyUsageExtension)getExtensionObject(xcert,
<span class="line-modified">2270                                                 KnownOIDs.extendedKeyUsage);</span>
2271             if (ext != null) {
2272                 Vector&lt;ObjectIdentifier&gt; certKeyPurposeVector =
2273                     ext.get(ExtendedKeyUsageExtension.USAGES);
2274                 if (!certKeyPurposeVector.contains(ANY_EXTENDED_KEY_USAGE)
2275                         &amp;&amp; !certKeyPurposeVector.containsAll(keyPurposeOIDSet)) {
2276                     if (debug != null) {
2277                         debug.println(&quot;X509CertSelector.match: cert failed &quot;
2278                             + &quot;extendedKeyUsage criterion&quot;);
2279                     }
2280                     return false;
2281                 }
2282             }
2283         } catch (IOException ex) {
2284             if (debug != null) {
2285                 debug.println(&quot;X509CertSelector.match: &quot;
2286                     + &quot;IOException in extended key usage check&quot;);
2287             }
2288             return false;
2289         }
2290         return true;
2291     }
2292 
2293     /* match on subject alternative name extension names */
2294     private boolean matchSubjectAlternativeNames(X509Certificate xcert) {
2295         if ((subjectAlternativeNames == null) || subjectAlternativeNames.isEmpty()) {
2296             return true;
2297         }
2298         try {
2299             SubjectAlternativeNameExtension sanExt =
<span class="line-modified">2300                 (SubjectAlternativeNameExtension) getExtensionObject(</span>
<span class="line-modified">2301                         xcert, KnownOIDs.SubjectAlternativeName);</span>
2302             if (sanExt == null) {
2303                 if (debug != null) {
2304                   debug.println(&quot;X509CertSelector.match: &quot;
2305                       + &quot;no subject alternative name extension&quot;);
2306                 }
2307                 return false;
2308             }
2309             GeneralNames certNames =
2310                     sanExt.get(SubjectAlternativeNameExtension.SUBJECT_NAME);
2311             Iterator&lt;GeneralNameInterface&gt; i =
2312                                 subjectAlternativeGeneralNames.iterator();
2313             while (i.hasNext()) {
2314                 GeneralNameInterface matchName = i.next();
2315                 boolean found = false;
2316                 for (Iterator&lt;GeneralName&gt; t = certNames.iterator();
2317                                                 t.hasNext() &amp;&amp; !found; ) {
2318                     GeneralNameInterface certName = (t.next()).getName();
2319                     found = certName.equals(matchName);
2320                 }
2321                 if (!found &amp;&amp; (matchAllSubjectAltNames || !i.hasNext())) {
</pre>
<hr />
<pre>
2350                 }
2351                 return false;
2352             }
2353         } catch (IOException e) {
2354             if (debug != null) {
2355                 debug.println(&quot;X509CertSelector.match: &quot;
2356                     + &quot;IOException in name constraints check&quot;);
2357             }
2358             return false;
2359         }
2360         return true;
2361     }
2362 
2363     /* match on policy OIDs */
2364     private boolean matchPolicy(X509Certificate xcert) {
2365         if (policy == null) {
2366             return true;
2367         }
2368         try {
2369             CertificatePoliciesExtension ext = (CertificatePoliciesExtension)
<span class="line-modified">2370                 getExtensionObject(xcert, KnownOIDs.CertificatePolicies);</span>
2371             if (ext == null) {
2372                 if (debug != null) {
2373                   debug.println(&quot;X509CertSelector.match: &quot;
2374                       + &quot;no certificate policy extension&quot;);
2375                 }
2376                 return false;
2377             }
2378             List&lt;PolicyInformation&gt; policies = ext.get(CertificatePoliciesExtension.POLICIES);
2379             /*
2380              * Convert the Vector of PolicyInformation to a Vector
2381              * of CertificatePolicyIds for easier comparison.
2382              */
2383             List&lt;CertificatePolicyId&gt; policyIDs = new ArrayList&lt;&gt;(policies.size());
2384             for (PolicyInformation info : policies) {
2385                 policyIDs.add(info.getPolicyIdentifier());
2386             }
2387             if (policy != null) {
2388                 boolean foundOne = false;
2389                 /*
2390                  * if the user passes in an empty policy Set, then
</pre>
<hr />
<pre>
2415                     }
2416                 }
2417             }
2418         } catch (IOException ex) {
2419             if (debug != null) {
2420                 debug.println(&quot;X509CertSelector.match: &quot;
2421                     + &quot;IOException in certificate policy ID check&quot;);
2422             }
2423             return false;
2424         }
2425         return true;
2426     }
2427 
2428     /* match on pathToNames */
2429     private boolean matchPathToNames(X509Certificate xcert) {
2430         if (pathToGeneralNames == null) {
2431             return true;
2432         }
2433         try {
2434             NameConstraintsExtension ext = (NameConstraintsExtension)
<span class="line-modified">2435                 getExtensionObject(xcert, KnownOIDs.NameConstraints);</span>
2436             if (ext == null) {
2437                 return true;
2438             }
2439             if ((debug != null) &amp;&amp; Debug.isOn(&quot;certpath&quot;)) {
2440                 debug.println(&quot;X509CertSelector.match pathToNames:\n&quot;);
2441                 Iterator&lt;GeneralNameInterface&gt; i =
2442                                         pathToGeneralNames.iterator();
2443                 while (i.hasNext()) {
2444                     debug.println(&quot;    &quot; + i.next() + &quot;\n&quot;);
2445                 }
2446             }
2447 
2448             GeneralSubtrees permitted =
2449                     ext.get(NameConstraintsExtension.PERMITTED_SUBTREES);
2450             GeneralSubtrees excluded =
2451                     ext.get(NameConstraintsExtension.EXCLUDED_SUBTREES);
2452             if (excluded != null) {
2453                 if (matchExcluded(excluded) == false) {
2454                     return false;
2455                 }
</pre>
</td>
</tr>
</table>
<center><a href="X509CRLSelector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/Arrays.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
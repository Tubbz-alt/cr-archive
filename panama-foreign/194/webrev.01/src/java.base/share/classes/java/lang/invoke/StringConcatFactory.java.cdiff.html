<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../net/InetAddress.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,11 ***</span>
  import jdk.internal.vm.annotation.Stable;
  import sun.invoke.util.Wrapper;
  
  import java.lang.invoke.MethodHandles.Lookup;
  import java.util.ArrayList;
<span class="line-removed">- import java.util.Arrays;</span>
  import java.util.List;
  import java.util.Objects;
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.concurrent.ConcurrentMap;
  import java.util.function.Function;
<span class="line-new-header">--- 30,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,145 ***</span>
       */
      private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
  
      private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Parses the recipe string, and produces a traversable collection of</span>
<span class="line-removed">-      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator</span>
<span class="line-removed">-      * strategies. Notably, this class parses out the constants from the recipe</span>
<span class="line-removed">-      * and from other static arguments.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final class Recipe {</span>
<span class="line-removed">-         private final List&lt;RecipeElement&gt; elements;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public Recipe(String src, Object[] constants) {</span>
<span class="line-removed">-             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             int constC = 0;</span>
<span class="line-removed">-             int argC = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             StringBuilder acc = new StringBuilder();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             for (int i = 0; i &lt; src.length(); i++) {</span>
<span class="line-removed">-                 char c = src.charAt(i);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 if (c == TAG_CONST || c == TAG_ARG) {</span>
<span class="line-removed">-                     // Detected a special tag, flush all accumulated characters</span>
<span class="line-removed">-                     // as a constant first:</span>
<span class="line-removed">-                     if (acc.length() &gt; 0) {</span>
<span class="line-removed">-                         el.add(new RecipeElement(acc.toString()));</span>
<span class="line-removed">-                         acc.setLength(0);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     if (c == TAG_CONST) {</span>
<span class="line-removed">-                         Object cnst = constants[constC++];</span>
<span class="line-removed">-                         el.add(new RecipeElement(cnst));</span>
<span class="line-removed">-                     } else if (c == TAG_ARG) {</span>
<span class="line-removed">-                         el.add(new RecipeElement(argC++));</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     // Not a special character, this is a constant embedded into</span>
<span class="line-removed">-                     // the recipe itself.</span>
<span class="line-removed">-                     acc.append(c);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Flush the remaining characters as constant:</span>
<span class="line-removed">-             if (acc.length() &gt; 0) {</span>
<span class="line-removed">-                 el.add(new RecipeElement(acc.toString()));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             elements = el;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public List&lt;RecipeElement&gt; getElements() {</span>
<span class="line-removed">-             return elements;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public boolean equals(Object o) {</span>
<span class="line-removed">-             if (this == o) return true;</span>
<span class="line-removed">-             if (o == null || getClass() != o.getClass()) return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             Recipe recipe = (Recipe) o;</span>
<span class="line-removed">-             return elements.equals(recipe.elements);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public String toString() {</span>
<span class="line-removed">-             return &quot;Recipe{&quot; +</span>
<span class="line-removed">-                     &quot;elements=&quot; + elements +</span>
<span class="line-removed">-                     &#39;}&#39;;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public int hashCode() {</span>
<span class="line-removed">-             return elements.hashCode();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static final class RecipeElement {</span>
<span class="line-removed">-         private final String value;</span>
<span class="line-removed">-         private final int argPos;</span>
<span class="line-removed">-         private final char tag;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public RecipeElement(Object cnst) {</span>
<span class="line-removed">-             this.value = String.valueOf(Objects.requireNonNull(cnst));</span>
<span class="line-removed">-             this.argPos = -1;</span>
<span class="line-removed">-             this.tag = TAG_CONST;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public RecipeElement(int arg) {</span>
<span class="line-removed">-             this.value = null;</span>
<span class="line-removed">-             this.argPos = arg;</span>
<span class="line-removed">-             this.tag = TAG_ARG;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public String getValue() {</span>
<span class="line-removed">-             assert (tag == TAG_CONST);</span>
<span class="line-removed">-             return value;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public int getArgPos() {</span>
<span class="line-removed">-             assert (tag == TAG_ARG);</span>
<span class="line-removed">-             return argPos;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public char getTag() {</span>
<span class="line-removed">-             return tag;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public boolean equals(Object o) {</span>
<span class="line-removed">-             if (this == o) return true;</span>
<span class="line-removed">-             if (o == null || getClass() != o.getClass()) return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             RecipeElement that = (RecipeElement) o;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (this.tag != that.tag) return false;</span>
<span class="line-removed">-             if (this.tag == TAG_CONST &amp;&amp; (!value.equals(that.value))) return false;</span>
<span class="line-removed">-             if (this.tag == TAG_ARG &amp;&amp; (argPos != that.argPos)) return false;</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public String toString() {</span>
<span class="line-removed">-             return &quot;RecipeElement{&quot; +</span>
<span class="line-removed">-                     &quot;value=&#39;&quot; + value + &#39;\&#39;&#39; +</span>
<span class="line-removed">-                     &quot;, argPos=&quot; + argPos +</span>
<span class="line-removed">-                     &quot;, tag=&quot; + tag +</span>
<span class="line-removed">-                     &#39;}&#39;;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public int hashCode() {</span>
<span class="line-removed">-             return (int)tag;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      // StringConcatFactory bootstrap methods are startup sensitive, and may be
<span class="line-modified">!     // special cased in java.lang.invokeBootstrapMethodInvoker to ensure</span>
      // methods are invoked with exact type information to avoid generating
      // code for runtime checks. Take care any changes or additions here are
      // reflected there as appropriate.
  
      /**
<span class="line-new-header">--- 118,12 ---</span>
       */
      private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
  
      private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
  
      // StringConcatFactory bootstrap methods are startup sensitive, and may be
<span class="line-modified">!     // special cased in java.lang.invoke.BootstrapMethodInvoker to ensure</span>
      // methods are invoked with exact type information to avoid generating
      // code for runtime checks. Take care any changes or additions here are
      // reflected there as appropriate.
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 330,11 ***</span>
       * @jls 15.18.1 String Concatenation Operator +
       */
      public static CallSite makeConcat(MethodHandles.Lookup lookup,
                                        String name,
                                        MethodType concatType) throws StringConcatException {
<span class="line-modified">!         return doStringConcat(lookup, name, concatType, true, null);</span>
      }
  
      /**
       * Facilitates the creation of optimized String concatenation methods, that
       * can be used to efficiently concatenate a known number of arguments of
<span class="line-new-header">--- 196,16 ---</span>
       * @jls 15.18.1 String Concatenation Operator +
       */
      public static CallSite makeConcat(MethodHandles.Lookup lookup,
                                        String name,
                                        MethodType concatType) throws StringConcatException {
<span class="line-modified">!         // This bootstrap method is unlikely to be used in practice,</span>
<span class="line-added">+         // avoid optimizing it at the expense of makeConcatWithConstants</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Mock the recipe to reuse the concat generator code</span>
<span class="line-added">+         String recipe = &quot;\u0001&quot;.repeat(concatType.parameterCount());</span>
<span class="line-added">+         return makeConcatWithConstants(lookup, name, concatType, recipe);</span>
      }
  
      /**
       * Facilitates the creation of optimized String concatenation methods, that
       * can be used to efficiently concatenate a known number of arguments of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 448,68 ***</span>
       */
      public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
                                                     String name,
                                                     MethodType concatType,
                                                     String recipe,
<span class="line-modified">!                                                    Object... constants) throws StringConcatException {</span>
<span class="line-modified">!         return doStringConcat(lookup, name, concatType, false, recipe, constants);</span>
<span class="line-modified">!     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static CallSite doStringConcat(MethodHandles.Lookup lookup,</span>
<span class="line-removed">-                                            String name,</span>
<span class="line-removed">-                                            MethodType concatType,</span>
<span class="line-removed">-                                            boolean generateRecipe,</span>
<span class="line-removed">-                                            String recipe,</span>
<span class="line-removed">-                                            Object... constants) throws StringConcatException {</span>
          Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
          Objects.requireNonNull(name, &quot;Name is null&quot;);
          Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
          Objects.requireNonNull(constants, &quot;Constants are null&quot;);
  
<span class="line-removed">-         for (Object o : constants) {</span>
<span class="line-removed">-             Objects.requireNonNull(o, &quot;Cannot accept null constants&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
              throw new StringConcatException(&quot;Invalid caller: &quot; +
                      lookup.lookupClass().getName());
          }
  
<span class="line-modified">!         int cCount = 0;</span>
<span class="line-removed">-         int oCount = 0;</span>
<span class="line-removed">-         if (generateRecipe) {</span>
<span class="line-removed">-             // Mock the recipe to reuse the concat generator code</span>
<span class="line-removed">-             char[] value = new char[concatType.parameterCount()];</span>
<span class="line-removed">-             Arrays.fill(value, TAG_ARG);</span>
<span class="line-removed">-             recipe = new String(value);</span>
<span class="line-removed">-             oCount = concatType.parameterCount();</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             Objects.requireNonNull(recipe, &quot;Recipe is null&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             for (int i = 0; i &lt; recipe.length(); i++) {</span>
<span class="line-removed">-                 char c = recipe.charAt(i);</span>
<span class="line-removed">-                 if (c == TAG_CONST) cCount++;</span>
<span class="line-removed">-                 if (c == TAG_ARG)   oCount++;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (oCount != concatType.parameterCount()) {</span>
<span class="line-removed">-             throw new StringConcatException(</span>
<span class="line-removed">-                     &quot;Mismatched number of concat arguments: recipe wants &quot; +</span>
<span class="line-removed">-                             oCount +</span>
<span class="line-removed">-                             &quot; arguments, but signature provides &quot; +</span>
<span class="line-removed">-                             concatType.parameterCount());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (cCount != constants.length) {</span>
<span class="line-removed">-             throw new StringConcatException(</span>
<span class="line-removed">-                     &quot;Mismatched number of concat constants: recipe wants &quot; +</span>
<span class="line-removed">-                             cCount +</span>
<span class="line-removed">-                             &quot; constants, but only &quot; +</span>
<span class="line-removed">-                             constants.length +</span>
<span class="line-removed">-                             &quot; are passed&quot;);</span>
<span class="line-removed">-         }</span>
  
          if (!concatType.returnType().isAssignableFrom(String.class)) {
              throw new StringConcatException(
                      &quot;The return type should be compatible with String, but it is &quot; +
                              concatType.returnType());
<span class="line-new-header">--- 319,24 ---</span>
       */
      public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
                                                     String name,
                                                     MethodType concatType,
                                                     String recipe,
<span class="line-modified">!                                                    Object... constants)</span>
<span class="line-modified">!         throws StringConcatException</span>
<span class="line-modified">!     {</span>
          Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
          Objects.requireNonNull(name, &quot;Name is null&quot;);
          Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
          Objects.requireNonNull(constants, &quot;Constants are null&quot;);
  
          if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
              throw new StringConcatException(&quot;Invalid caller: &quot; +
                      lookup.lookupClass().getName());
          }
  
<span class="line-modified">!         List&lt;String&gt; elements = parseRecipe(concatType, recipe, constants);</span>
  
          if (!concatType.returnType().isAssignableFrom(String.class)) {
              throw new StringConcatException(
                      &quot;The return type should be compatible with String, but it is &quot; +
                              concatType.returnType());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 520,93 ***</span>
                      concatType.parameterSlotCount() +
                      &quot;, can only accept &quot; +
                      MAX_INDY_CONCAT_ARG_SLOTS);
          }
  
<span class="line-removed">-         Recipe rec = new Recipe(recipe, constants);</span>
<span class="line-removed">-         MethodHandle mh = generate(lookup, concatType, rec);</span>
<span class="line-removed">-         return new ConstantCallSite(mh.asType(concatType));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {</span>
          try {
<span class="line-modified">!             return generateMHInlineCopy(mt, recipe);</span>
<span class="line-modified">!         } catch (Error | StringConcatException e) {</span>
<span class="line-modified">!             // Pass through any error or existing StringConcatException</span>
              throw e;
          } catch (Throwable t) {
              throw new StringConcatException(&quot;Generator failed&quot;, t);
          }
      }
  
  
      /**
       * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the
       * byte[] array on its own and passes that byte[] array to String
       * constructor. This strategy requires access to some private APIs in JDK,
       * most notably, the private String constructor that accepts byte[] arrays
       * without copying.
       */
<span class="line-modified">!     private static MethodHandle generateMHInlineCopy(MethodType mt, Recipe recipe) throws Throwable {</span>
  
          // Fast-path two-argument Object + Object concatenations
<span class="line-modified">!         if (recipe.getElements().size() == 2) {</span>
              // Two object arguments
              if (mt.parameterCount() == 2 &amp;&amp;
                      !mt.parameterType(0).isPrimitive() &amp;&amp;
                      !mt.parameterType(1).isPrimitive() &amp;&amp;
<span class="line-modified">!                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="line-modified">!                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-removed">- </span>
                  return simpleConcat();
<span class="line-removed">- </span>
              } else if (mt.parameterCount() == 1 &amp;&amp;
                      !mt.parameterType(0).isPrimitive()) {
                  // One Object argument, one constant
                  MethodHandle mh = simpleConcat();
  
<span class="line-modified">!                 if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-removed">-                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
                      // First recipe element is a constant
<span class="line-modified">!                     return MethodHandles.insertArguments(mh, 0,</span>
<span class="line-removed">-                             recipe.getElements().get(0).getValue());</span>
  
<span class="line-modified">!                 } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-removed">-                         recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
                      // Second recipe element is a constant
<span class="line-modified">!                     return MethodHandles.insertArguments(mh, 1,</span>
<span class="line-removed">-                             recipe.getElements().get(1).getValue());</span>
  
                  }
              }
              // else... fall-through to slow-path
          }
  
          // Create filters and obtain filtered parameter types. Filters would be used in the beginning
          // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
          // The filtered argument type list is used all over in the combinators below.
<span class="line-modified">!         Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
          MethodHandle[] filters = null;
          for (int i = 0; i &lt; ptypes.length; i++) {
              MethodHandle filter = stringifierFor(ptypes[i]);
              if (filter != null) {
                  if (filters == null) {
                      filters = new MethodHandle[ptypes.length];
                  }
                  filters[i] = filter;
<span class="line-modified">!                 ptypes[i] = filter.type().returnType();</span>
              }
          }
  
          // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
          // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
          // assembled bottom-up, which makes the code arguably hard to read.
  
          // Drop all remaining parameter types, leave only helper arguments:
<span class="line-modified">!         MethodHandle mh;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
  
          long initialLengthCoder = INITIAL_CODER;
  
          // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
          // known from the combinators below. We are assembling the string backwards, so the index coded
<span class="line-new-header">--- 347,154 ---</span>
                      concatType.parameterSlotCount() +
                      &quot;, can only accept &quot; +
                      MAX_INDY_CONCAT_ARG_SLOTS);
          }
  
          try {
<span class="line-modified">!             return new ConstantCallSite(</span>
<span class="line-modified">!                     generateMHInlineCopy(concatType, elements)</span>
<span class="line-modified">!                             .viewAsType(concatType, true));</span>
<span class="line-added">+         } catch (Error e) {</span>
<span class="line-added">+             // Pass through any error</span>
              throw e;
          } catch (Throwable t) {
              throw new StringConcatException(&quot;Generator failed&quot;, t);
          }
      }
  
<span class="line-added">+     private static List&lt;String&gt; parseRecipe(MethodType concatType,</span>
<span class="line-added">+                                             String recipe,</span>
<span class="line-added">+                                             Object[] constants)</span>
<span class="line-added">+         throws StringConcatException</span>
<span class="line-added">+     {</span>
<span class="line-added">+ </span>
<span class="line-added">+         Objects.requireNonNull(recipe, &quot;Recipe is null&quot;);</span>
<span class="line-added">+         // Element list containing String constants, or null for arguments</span>
<span class="line-added">+         List&lt;String&gt; elements = new ArrayList&lt;&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+         int cCount = 0;</span>
<span class="line-added">+         int oCount = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         StringBuilder acc = new StringBuilder();</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (int i = 0; i &lt; recipe.length(); i++) {</span>
<span class="line-added">+             char c = recipe.charAt(i);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (c == TAG_CONST) {</span>
<span class="line-added">+                 if (cCount == constants.length) {</span>
<span class="line-added">+                     // Not enough constants</span>
<span class="line-added">+                     throw constantMismatch(concatType, oCount);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 // Accumulate constant args along with any constants encoded</span>
<span class="line-added">+                 // into the recipe</span>
<span class="line-added">+                 acc.append(Objects.requireNonNull(constants[cCount++], &quot;Cannot accept null constants&quot;));</span>
<span class="line-added">+             } else if (c == TAG_ARG) {</span>
<span class="line-added">+                 // Flush any accumulated characters into a constant</span>
<span class="line-added">+                 if (acc.length() &gt; 0) {</span>
<span class="line-added">+                     elements.add(acc.toString());</span>
<span class="line-added">+                     acc.setLength(0);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 elements.add(null);</span>
<span class="line-added">+                 oCount++;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 // Not a special character, this is a constant embedded into</span>
<span class="line-added">+                 // the recipe itself.</span>
<span class="line-added">+                 acc.append(c);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Flush the remaining characters as constant:</span>
<span class="line-added">+         if (acc.length() &gt; 0) {</span>
<span class="line-added">+             elements.add(acc.toString());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (oCount != concatType.parameterCount()) {</span>
<span class="line-added">+             throw constantMismatch(concatType, oCount);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (cCount != constants.length) {</span>
<span class="line-added">+             throw new StringConcatException(</span>
<span class="line-added">+                     &quot;Mismatched number of concat constants: recipe wants &quot; +</span>
<span class="line-added">+                             cCount +</span>
<span class="line-added">+                             &quot; constants, but only &quot; +</span>
<span class="line-added">+                             constants.length +</span>
<span class="line-added">+                             &quot; are passed&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return elements;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static StringConcatException constantMismatch(MethodType concatType,</span>
<span class="line-added">+                                                           int oCount) {</span>
<span class="line-added">+         return new StringConcatException(</span>
<span class="line-added">+                 &quot;Mismatched number of concat arguments: recipe wants &quot; +</span>
<span class="line-added">+                         oCount +</span>
<span class="line-added">+                         &quot; arguments, but signature provides &quot; +</span>
<span class="line-added">+                         concatType.parameterCount());</span>
<span class="line-added">+     }</span>
  
      /**
       * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the
       * byte[] array on its own and passes that byte[] array to String
       * constructor. This strategy requires access to some private APIs in JDK,
       * most notably, the private String constructor that accepts byte[] arrays
       * without copying.
       */
<span class="line-modified">!     private static MethodHandle generateMHInlineCopy(MethodType mt, List&lt;String&gt; elements) {</span>
  
          // Fast-path two-argument Object + Object concatenations
<span class="line-modified">!         if (elements.size() == 2) {</span>
              // Two object arguments
<span class="line-added">+             String s0 = elements.get(0);</span>
<span class="line-added">+             String s1 = elements.get(1);</span>
<span class="line-added">+ </span>
              if (mt.parameterCount() == 2 &amp;&amp;
                      !mt.parameterType(0).isPrimitive() &amp;&amp;
                      !mt.parameterType(1).isPrimitive() &amp;&amp;
<span class="line-modified">!                     s0 == null &amp;&amp;</span>
<span class="line-modified">!                     s1 == null) {</span>
                  return simpleConcat();
              } else if (mt.parameterCount() == 1 &amp;&amp;
                      !mt.parameterType(0).isPrimitive()) {
<span class="line-added">+ </span>
                  // One Object argument, one constant
                  MethodHandle mh = simpleConcat();
  
<span class="line-modified">!                 if (s0 != null &amp;&amp; s1 == null) {</span>
                      // First recipe element is a constant
<span class="line-modified">!                     return MethodHandles.insertArguments(mh, 0, s0);</span>
  
<span class="line-modified">!                 } else if (s1 != null &amp;&amp; s0 == null) {</span>
                      // Second recipe element is a constant
<span class="line-modified">!                     return MethodHandles.insertArguments(mh, 1, s1);</span>
  
                  }
              }
              // else... fall-through to slow-path
          }
  
          // Create filters and obtain filtered parameter types. Filters would be used in the beginning
          // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
          // The filtered argument type list is used all over in the combinators below.
<span class="line-modified">! </span>
<span class="line-added">+         Class&lt;?&gt;[] ptypes = mt.erase().parameterArray();</span>
          MethodHandle[] filters = null;
          for (int i = 0; i &lt; ptypes.length; i++) {
              MethodHandle filter = stringifierFor(ptypes[i]);
              if (filter != null) {
                  if (filters == null) {
                      filters = new MethodHandle[ptypes.length];
                  }
                  filters[i] = filter;
<span class="line-modified">!                 ptypes[i] = String.class;</span>
              }
          }
  
          // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
          // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
          // assembled bottom-up, which makes the code arguably hard to read.
  
          // Drop all remaining parameter types, leave only helper arguments:
<span class="line-modified">!         MethodHandle mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
  
          long initialLengthCoder = INITIAL_CODER;
  
          // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
          // known from the combinators below. We are assembling the string backwards, so the index coded
</pre>
<hr />
<pre>
<span class="line-old-header">*** 614,39 ***</span>
  
          // We need one prepender per argument, but also need to fold in constants. We do so by greedily
          // create prependers that fold in surrounding constants into the argument prepender. This reduces
          // the number of unique MH combinator tree shapes we&#39;ll create in an application.
          String constant = null;
<span class="line-modified">!         for (RecipeElement el : recipe.getElements()) {</span>
              // Do the prepend, and put &quot;new&quot; index at index 1
<span class="line-modified">!             switch (el.getTag()) {</span>
<span class="line-modified">!                 case TAG_CONST: {</span>
<span class="line-modified">!                     String constantValue = el.getValue();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // Eagerly update the initialLengthCoder value</span>
<span class="line-modified">!                     initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constantValue);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // Collecting into a single constant that we&#39;ll either fold</span>
<span class="line-modified">!                     // into the next argument prepender, or into the newArray</span>
<span class="line-modified">!                     // combinator</span>
<span class="line-modified">!                     constant = constant == null ? constantValue : constant + constantValue;</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case TAG_ARG: {</span>
<span class="line-modified">!                     // Add prepender, along with any prefix constant</span>
<span class="line-modified">!                     int pos = el.getArgPos();</span>
<span class="line-modified">!                     mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="line-modified">!                             mh, 1,</span>
<span class="line-modified">!                             prepender(constant, ptypes[pos]),</span>
<span class="line-modified">!                             1, 0, // indexCoder, storage</span>
<span class="line-removed">-                             2 + pos  // selected argument</span>
<span class="line-removed">-                     );</span>
<span class="line-removed">-                     constant = null;</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 default:</span>
<span class="line-removed">-                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
              }
          }
  
          // Fold in byte[] instantiation at argument 0
          MethodHandle newArrayCombinator;
<span class="line-new-header">--- 502,33 ---</span>
  
          // We need one prepender per argument, but also need to fold in constants. We do so by greedily
          // create prependers that fold in surrounding constants into the argument prepender. This reduces
          // the number of unique MH combinator tree shapes we&#39;ll create in an application.
          String constant = null;
<span class="line-modified">!         int pos = 0;</span>
<span class="line-added">+         for (String el : elements) {</span>
              // Do the prepend, and put &quot;new&quot; index at index 1
<span class="line-modified">!             if (el != null) {</span>
<span class="line-modified">!                 // Constant element</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // Eagerly update the initialLengthCoder value</span>
<span class="line-modified">!                 initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, el);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // Save the constant and fold it either into the next</span>
<span class="line-modified">!                 // argument prepender, or into the newArray combinator</span>
<span class="line-modified">!                 assert (constant == null);</span>
<span class="line-modified">!                 constant = el;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 // Add prepender, along with any prefix constant</span>
<span class="line-modified">!                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="line-modified">!                         mh, 1,</span>
<span class="line-modified">!                         prepender(constant, ptypes[pos]),</span>
<span class="line-modified">!                         1, 0, // indexCoder, storage</span>
<span class="line-modified">!                         2 + pos  // selected argument</span>
<span class="line-modified">!                 );</span>
<span class="line-modified">!                 constant = null;</span>
<span class="line-modified">!                 pos++;</span>
              }
          }
  
          // Fold in byte[] instantiation at argument 0
          MethodHandle newArrayCombinator;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 684,42 ***</span>
          // We will bind the initialLengthCoder value to the last mixer (the one that will be
          // executed first), then fold that in. This leaves the shape after all mixers are
          // combined in as:
          //   (&lt;args&gt;)String = (&lt;args&gt;)
  
<span class="line-modified">!         int ac = -1;</span>
          MethodHandle mix = null;
<span class="line-modified">!         for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-modified">!             switch (el.getTag()) {</span>
<span class="line-modified">!                 case TAG_CONST:</span>
<span class="line-modified">!                     // Constants already handled in the code above</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case TAG_ARG:</span>
<span class="line-removed">-                     if (ac &gt;= 0) {</span>
                          // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.
                          mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,
                                  0, // old-index
<span class="line-modified">!                                 1 + ac // selected argument</span>
                          );
                      }
  
<span class="line-modified">!                     ac = el.getArgPos();</span>
<span class="line-removed">-                     Class&lt;?&gt; argClass = ptypes[ac];</span>
                      mix = mixer(argClass);
<span class="line-removed">- </span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 default:</span>
<span class="line-removed">-                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
              }
          }
  
          // Insert the initialLengthCoder value into the final mixer, then
          // fold that into the base method handle
<span class="line-modified">!         if (ac &gt;= 0) {</span>
              mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);
              mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,
<span class="line-modified">!                     1 + ac // selected argument</span>
              );
          } else {
              // No mixer (constants only concat), insert initialLengthCoder directly
              mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
          }
<span class="line-new-header">--- 566,34 ---</span>
          // We will bind the initialLengthCoder value to the last mixer (the one that will be
          // executed first), then fold that in. This leaves the shape after all mixers are
          // combined in as:
          //   (&lt;args&gt;)String = (&lt;args&gt;)
  
<span class="line-modified">!         pos = -1;</span>
          MethodHandle mix = null;
<span class="line-modified">!         for (String el : elements) {</span>
<span class="line-modified">!             // Constants already handled in the code above</span>
<span class="line-modified">!             if (el == null) {</span>
<span class="line-modified">!                     if (pos &gt;= 0) {</span>
                          // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.
                          mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,
                                  0, // old-index
<span class="line-modified">!                                 1 + pos // selected argument</span>
                          );
                      }
  
<span class="line-modified">!                     Class&lt;?&gt; argClass = ptypes[++pos];</span>
                      mix = mixer(argClass);
              }
          }
  
          // Insert the initialLengthCoder value into the final mixer, then
          // fold that into the base method handle
<span class="line-modified">!         if (pos &gt;= 0) {</span>
              mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);
              mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,
<span class="line-modified">!                     1 + pos // selected argument</span>
              );
          } else {
              // No mixer (constants only concat), insert initialLengthCoder directly
              mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 748,56 ***</span>
  
      // These are deliberately not lambdas to optimize startup time:
      private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
          @Override
          public MethodHandle apply(Class&lt;?&gt; c) {
<span class="line-modified">!             return JLA.stringConcatHelper(&quot;prepend&quot;,</span>
                      methodType(long.class, long.class, byte[].class,
                              Wrapper.asPrimitiveType(c), String.class));
          }
      };
  
      private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPEND = new Function&lt;&gt;() {
          @Override
          public MethodHandle apply(Class&lt;?&gt; c) {
              return MethodHandles.insertArguments(
<span class="line-modified">!                             PREPENDERS.computeIfAbsent(c, PREPEND), 3, (String)null);</span>
          }
      };
  
      private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
          @Override
          public MethodHandle apply(Class&lt;?&gt; c) {
<span class="line-modified">!             return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
          }
      };
  
      private @Stable static MethodHandle SIMPLE_CONCAT;
      private static MethodHandle simpleConcat() {
<span class="line-modified">!         if (SIMPLE_CONCAT == null) {</span>
<span class="line-modified">!             SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>
          }
<span class="line-modified">!         return SIMPLE_CONCAT;</span>
      }
  
      private @Stable static MethodHandle NEW_STRING;
      private static MethodHandle newString() {
          MethodHandle mh = NEW_STRING;
          if (mh == null) {
<span class="line-modified">!             NEW_STRING = mh =</span>
<span class="line-modified">!                     JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));</span>
          }
          return mh;
      }
  
      private @Stable static MethodHandle NEW_ARRAY_SUFFIX;
      private static MethodHandle newArrayWithSuffix(String suffix) {
          MethodHandle mh = NEW_ARRAY_SUFFIX;
          if (mh == null) {
<span class="line-modified">!             NEW_ARRAY_SUFFIX = mh =</span>
<span class="line-modified">!                     JLA.stringConcatHelper(&quot;newArrayWithSuffix&quot;,</span>
<span class="line-modified">!                             methodType(byte[].class, String.class, long.class));</span>
          }
          return MethodHandles.insertArguments(mh, 0, suffix);
      }
  
      private @Stable static MethodHandle NEW_ARRAY;
<span class="line-new-header">--- 622,63 ---</span>
  
      // These are deliberately not lambdas to optimize startup time:
      private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
          @Override
          public MethodHandle apply(Class&lt;?&gt; c) {
<span class="line-modified">!             MethodHandle prepend = JLA.stringConcatHelper(&quot;prepend&quot;,</span>
                      methodType(long.class, long.class, byte[].class,
                              Wrapper.asPrimitiveType(c), String.class));
<span class="line-added">+             return prepend.rebind();</span>
          }
      };
  
      private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPEND = new Function&lt;&gt;() {
          @Override
          public MethodHandle apply(Class&lt;?&gt; c) {
              return MethodHandles.insertArguments(
<span class="line-modified">!                     PREPENDERS.computeIfAbsent(c, PREPEND), 3, (String)null);</span>
          }
      };
  
      private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
          @Override
          public MethodHandle apply(Class&lt;?&gt; c) {
<span class="line-modified">!             MethodHandle mix = JLA.stringConcatHelper(&quot;mix&quot;,</span>
<span class="line-added">+                     methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
<span class="line-added">+             return mix.rebind();</span>
          }
      };
  
      private @Stable static MethodHandle SIMPLE_CONCAT;
      private static MethodHandle simpleConcat() {
<span class="line-modified">!         MethodHandle mh = SIMPLE_CONCAT;</span>
<span class="line-modified">!         if (mh == null) {</span>
<span class="line-added">+             MethodHandle simpleConcat = JLA.stringConcatHelper(&quot;simpleConcat&quot;,</span>
<span class="line-added">+                     methodType(String.class, Object.class, Object.class));</span>
<span class="line-added">+             SIMPLE_CONCAT = mh = simpleConcat.rebind();</span>
          }
<span class="line-modified">!         return mh;</span>
      }
  
      private @Stable static MethodHandle NEW_STRING;
      private static MethodHandle newString() {
          MethodHandle mh = NEW_STRING;
          if (mh == null) {
<span class="line-modified">!             MethodHandle newString = JLA.stringConcatHelper(&quot;newString&quot;,</span>
<span class="line-modified">!                     methodType(String.class, byte[].class, long.class));</span>
<span class="line-added">+             NEW_STRING = mh = newString.rebind();</span>
          }
          return mh;
      }
  
      private @Stable static MethodHandle NEW_ARRAY_SUFFIX;
      private static MethodHandle newArrayWithSuffix(String suffix) {
          MethodHandle mh = NEW_ARRAY_SUFFIX;
          if (mh == null) {
<span class="line-modified">!             MethodHandle newArrayWithSuffix = JLA.stringConcatHelper(&quot;newArrayWithSuffix&quot;,</span>
<span class="line-modified">!                     methodType(byte[].class, String.class, long.class));</span>
<span class="line-modified">!             NEW_ARRAY_SUFFIX = mh = newArrayWithSuffix.rebind();</span>
          }
          return MethodHandles.insertArguments(mh, 0, suffix);
      }
  
      private @Stable static MethodHandle NEW_ARRAY;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 817,12 ***</span>
       */
      private @Stable static MethodHandle OBJECT_STRINGIFIER;
      private static MethodHandle objectStringifier() {
          MethodHandle mh = OBJECT_STRINGIFIER;
          if (mh == null) {
<span class="line-modified">!             OBJECT_STRINGIFIER = mh =</span>
<span class="line-modified">!                     JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));</span>
          }
          return mh;
      }
      private @Stable static MethodHandle FLOAT_STRINGIFIER;
      private static MethodHandle floatStringifier() {
<span class="line-new-header">--- 698,12 ---</span>
       */
      private @Stable static MethodHandle OBJECT_STRINGIFIER;
      private static MethodHandle objectStringifier() {
          MethodHandle mh = OBJECT_STRINGIFIER;
          if (mh == null) {
<span class="line-modified">!             OBJECT_STRINGIFIER = mh = JLA.stringConcatHelper(&quot;stringOf&quot;,</span>
<span class="line-modified">!                     methodType(String.class, Object.class));</span>
          }
          return mh;
      }
      private @Stable static MethodHandle FLOAT_STRINGIFIER;
      private static MethodHandle floatStringifier() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 861,11 ***</span>
       *
       * @param t class to stringify
       * @return stringifier; null, if not available
       */
      private static MethodHandle stringifierFor(Class&lt;?&gt; t) {
<span class="line-modified">!         if (!t.isPrimitive()) {</span>
              return objectStringifier();
          } else if (t == float.class) {
              return floatStringifier();
          } else if (t == double.class) {
              return doubleStringifier();
<span class="line-new-header">--- 742,11 ---</span>
       *
       * @param t class to stringify
       * @return stringifier; null, if not available
       */
      private static MethodHandle stringifierFor(Class&lt;?&gt; t) {
<span class="line-modified">!         if (t == Object.class) {</span>
              return objectStringifier();
          } else if (t == float.class) {
              return floatStringifier();
          } else if (t == double.class) {
              return doubleStringifier();
</pre>
<center><a href="MethodHandles.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../net/InetAddress.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>